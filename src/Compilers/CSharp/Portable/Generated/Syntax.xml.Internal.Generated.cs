// <auto-generated />

#nullable enable

using System;
using System.Collections.Generic;
using System.Diagnostics.CodeAnalysis;
using Microsoft.CodeAnalysis.Syntax.InternalSyntax;
using Roslyn.Utilities;

namespace Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax
{
    /// <summary>Provides the base class from which the classes that represent name syntax nodes are derived. This is an abstract class.</summary>
    internal abstract partial class NameSyntax : TypeSyntax
    {
        internal NameSyntax(SyntaxKind kind, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
        }

        internal NameSyntax(SyntaxKind kind)
          : base(kind)
        {
        }

        protected NameSyntax(ObjectReader reader)
          : base(reader)
        {
        }
    }

    /// <summary>Provides the base class from which the classes that represent simple name syntax nodes are derived. This is an abstract class.</summary>
    internal abstract partial class SimpleNameSyntax : NameSyntax
    {
        internal SimpleNameSyntax(SyntaxKind kind, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
        }

        internal SimpleNameSyntax(SyntaxKind kind)
          : base(kind)
        {
        }

        protected SimpleNameSyntax(ObjectReader reader)
          : base(reader)
        {
        }

        /// <summary>SyntaxToken representing the identifier of the simple name.</summary>
        public abstract SyntaxToken Identifier { get; }
    }

    /// <summary>Class which represents the syntax node for identifier name.</summary>
    internal sealed partial class IdentifierNameSyntax : SimpleNameSyntax
    {
        internal readonly SyntaxToken identifier;

        internal IdentifierNameSyntax(SyntaxKind kind, SyntaxToken identifier, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
            this.SlotCount = 1;
            this.AdjustFlagsAndWidth(identifier);
            this.identifier = identifier;
        }

        internal IdentifierNameSyntax(SyntaxKind kind, SyntaxToken identifier, SyntaxFactoryContext context)
          : base(kind)
        {
            this.SetFactoryContext(context);
            this.SlotCount = 1;
            this.AdjustFlagsAndWidth(identifier);
            this.identifier = identifier;
        }

        internal IdentifierNameSyntax(SyntaxKind kind, SyntaxToken identifier)
          : base(kind)
        {
            this.SlotCount = 1;
            this.AdjustFlagsAndWidth(identifier);
            this.identifier = identifier;
        }

        /// <summary>SyntaxToken representing the keyword for the kind of the identifier name.</summary>
        public override SyntaxToken Identifier => this.identifier;

        internal override GreenNode? GetSlot(int index)
            => index == 0 ? this.identifier : null;

        internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new CSharp.Syntax.IdentifierNameSyntax(this, parent, position);

        public override void Accept(CSharpSyntaxVisitor visitor) => visitor.VisitIdentifierName(this);
        public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor) => visitor.VisitIdentifierName(this);

        public IdentifierNameSyntax Update(SyntaxToken identifier)
        {
            if (identifier != this.Identifier)
            {
                var newNode = SyntaxFactory.IdentifierName(identifier);
                var diags = GetDiagnostics();
                if (diags?.Length > 0)
                    newNode = newNode.WithDiagnosticsGreen(diags);
                var annotations = GetAnnotations();
                if (annotations?.Length > 0)
                    newNode = newNode.WithAnnotationsGreen(annotations);
                return newNode;
            }

            return this;
        }

        internal override GreenNode SetDiagnostics(DiagnosticInfo[]? diagnostics)
            => new IdentifierNameSyntax(this.Kind, this.identifier, diagnostics, GetAnnotations());

        internal override GreenNode SetAnnotations(SyntaxAnnotation[]? annotations)
            => new IdentifierNameSyntax(this.Kind, this.identifier, GetDiagnostics(), annotations);

        internal IdentifierNameSyntax(ObjectReader reader)
          : base(reader)
        {
            this.SlotCount = 1;
            var identifier = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(identifier);
            this.identifier = identifier;
        }

        internal override void WriteTo(ObjectWriter writer)
        {
            base.WriteTo(writer);
            writer.WriteValue(this.identifier);
        }

        static IdentifierNameSyntax()
        {
            ObjectBinder.RegisterTypeReader(typeof(IdentifierNameSyntax), r => new IdentifierNameSyntax(r));
        }
    }

    /// <summary>Class which represents the syntax node for qualified name.</summary>
    internal sealed partial class QualifiedNameSyntax : NameSyntax
    {
        internal readonly NameSyntax left;
        internal readonly SyntaxToken dotToken;
        internal readonly SimpleNameSyntax right;

        internal QualifiedNameSyntax(SyntaxKind kind, NameSyntax left, SyntaxToken dotToken, SimpleNameSyntax right, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
            this.SlotCount = 3;
            this.AdjustFlagsAndWidth(left);
            this.left = left;
            this.AdjustFlagsAndWidth(dotToken);
            this.dotToken = dotToken;
            this.AdjustFlagsAndWidth(right);
            this.right = right;
        }

        internal QualifiedNameSyntax(SyntaxKind kind, NameSyntax left, SyntaxToken dotToken, SimpleNameSyntax right, SyntaxFactoryContext context)
          : base(kind)
        {
            this.SetFactoryContext(context);
            this.SlotCount = 3;
            this.AdjustFlagsAndWidth(left);
            this.left = left;
            this.AdjustFlagsAndWidth(dotToken);
            this.dotToken = dotToken;
            this.AdjustFlagsAndWidth(right);
            this.right = right;
        }

        internal QualifiedNameSyntax(SyntaxKind kind, NameSyntax left, SyntaxToken dotToken, SimpleNameSyntax right)
          : base(kind)
        {
            this.SlotCount = 3;
            this.AdjustFlagsAndWidth(left);
            this.left = left;
            this.AdjustFlagsAndWidth(dotToken);
            this.dotToken = dotToken;
            this.AdjustFlagsAndWidth(right);
            this.right = right;
        }

        /// <summary>NameSyntax node representing the name on the left side of the dot token of the qualified name.</summary>
        public NameSyntax Left => this.left;
        /// <summary>SyntaxToken representing the dot.</summary>
        public SyntaxToken DotToken => this.dotToken;
        /// <summary>SimpleNameSyntax node representing the name on the right side of the dot token of the qualified name.</summary>
        public SimpleNameSyntax Right => this.right;

        internal override GreenNode? GetSlot(int index)
            => index switch
            {
                0 => this.left,
                1 => this.dotToken,
                2 => this.right,
                _ => null,
            };

        internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new CSharp.Syntax.QualifiedNameSyntax(this, parent, position);

        public override void Accept(CSharpSyntaxVisitor visitor) => visitor.VisitQualifiedName(this);
        public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor) => visitor.VisitQualifiedName(this);

        public QualifiedNameSyntax Update(NameSyntax left, SyntaxToken dotToken, SimpleNameSyntax right)
        {
            if (left != this.Left || dotToken != this.DotToken || right != this.Right)
            {
                var newNode = SyntaxFactory.QualifiedName(left, dotToken, right);
                var diags = GetDiagnostics();
                if (diags?.Length > 0)
                    newNode = newNode.WithDiagnosticsGreen(diags);
                var annotations = GetAnnotations();
                if (annotations?.Length > 0)
                    newNode = newNode.WithAnnotationsGreen(annotations);
                return newNode;
            }

            return this;
        }

        internal override GreenNode SetDiagnostics(DiagnosticInfo[]? diagnostics)
            => new QualifiedNameSyntax(this.Kind, this.left, this.dotToken, this.right, diagnostics, GetAnnotations());

        internal override GreenNode SetAnnotations(SyntaxAnnotation[]? annotations)
            => new QualifiedNameSyntax(this.Kind, this.left, this.dotToken, this.right, GetDiagnostics(), annotations);

        internal QualifiedNameSyntax(ObjectReader reader)
          : base(reader)
        {
            this.SlotCount = 3;
            var left = (NameSyntax)reader.ReadValue();
            AdjustFlagsAndWidth(left);
            this.left = left;
            var dotToken = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(dotToken);
            this.dotToken = dotToken;
            var right = (SimpleNameSyntax)reader.ReadValue();
            AdjustFlagsAndWidth(right);
            this.right = right;
        }

        internal override void WriteTo(ObjectWriter writer)
        {
            base.WriteTo(writer);
            writer.WriteValue(this.left);
            writer.WriteValue(this.dotToken);
            writer.WriteValue(this.right);
        }

        static QualifiedNameSyntax()
        {
            ObjectBinder.RegisterTypeReader(typeof(QualifiedNameSyntax), r => new QualifiedNameSyntax(r));
        }
    }

    /// <summary>Class which represents the syntax node for generic name.</summary>
    internal sealed partial class GenericNameSyntax : SimpleNameSyntax
    {
        internal readonly SyntaxToken identifier;
        internal readonly TypeArgumentListSyntax typeArgumentList;

        internal GenericNameSyntax(SyntaxKind kind, SyntaxToken identifier, TypeArgumentListSyntax typeArgumentList, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
            this.SlotCount = 2;
            this.AdjustFlagsAndWidth(identifier);
            this.identifier = identifier;
            this.AdjustFlagsAndWidth(typeArgumentList);
            this.typeArgumentList = typeArgumentList;
        }

        internal GenericNameSyntax(SyntaxKind kind, SyntaxToken identifier, TypeArgumentListSyntax typeArgumentList, SyntaxFactoryContext context)
          : base(kind)
        {
            this.SetFactoryContext(context);
            this.SlotCount = 2;
            this.AdjustFlagsAndWidth(identifier);
            this.identifier = identifier;
            this.AdjustFlagsAndWidth(typeArgumentList);
            this.typeArgumentList = typeArgumentList;
        }

        internal GenericNameSyntax(SyntaxKind kind, SyntaxToken identifier, TypeArgumentListSyntax typeArgumentList)
          : base(kind)
        {
            this.SlotCount = 2;
            this.AdjustFlagsAndWidth(identifier);
            this.identifier = identifier;
            this.AdjustFlagsAndWidth(typeArgumentList);
            this.typeArgumentList = typeArgumentList;
        }

        /// <summary>SyntaxToken representing the name of the identifier of the generic name.</summary>
        public override SyntaxToken Identifier => this.identifier;
        /// <summary>TypeArgumentListSyntax node representing the list of type arguments of the generic name.</summary>
        public TypeArgumentListSyntax TypeArgumentList => this.typeArgumentList;

        internal override GreenNode? GetSlot(int index)
            => index switch
            {
                0 => this.identifier,
                1 => this.typeArgumentList,
                _ => null,
            };

        internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new CSharp.Syntax.GenericNameSyntax(this, parent, position);

        public override void Accept(CSharpSyntaxVisitor visitor) => visitor.VisitGenericName(this);
        public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor) => visitor.VisitGenericName(this);

        public GenericNameSyntax Update(SyntaxToken identifier, TypeArgumentListSyntax typeArgumentList)
        {
            if (identifier != this.Identifier || typeArgumentList != this.TypeArgumentList)
            {
                var newNode = SyntaxFactory.GenericName(identifier, typeArgumentList);
                var diags = GetDiagnostics();
                if (diags?.Length > 0)
                    newNode = newNode.WithDiagnosticsGreen(diags);
                var annotations = GetAnnotations();
                if (annotations?.Length > 0)
                    newNode = newNode.WithAnnotationsGreen(annotations);
                return newNode;
            }

            return this;
        }

        internal override GreenNode SetDiagnostics(DiagnosticInfo[]? diagnostics)
            => new GenericNameSyntax(this.Kind, this.identifier, this.typeArgumentList, diagnostics, GetAnnotations());

        internal override GreenNode SetAnnotations(SyntaxAnnotation[]? annotations)
            => new GenericNameSyntax(this.Kind, this.identifier, this.typeArgumentList, GetDiagnostics(), annotations);

        internal GenericNameSyntax(ObjectReader reader)
          : base(reader)
        {
            this.SlotCount = 2;
            var identifier = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(identifier);
            this.identifier = identifier;
            var typeArgumentList = (TypeArgumentListSyntax)reader.ReadValue();
            AdjustFlagsAndWidth(typeArgumentList);
            this.typeArgumentList = typeArgumentList;
        }

        internal override void WriteTo(ObjectWriter writer)
        {
            base.WriteTo(writer);
            writer.WriteValue(this.identifier);
            writer.WriteValue(this.typeArgumentList);
        }

        static GenericNameSyntax()
        {
            ObjectBinder.RegisterTypeReader(typeof(GenericNameSyntax), r => new GenericNameSyntax(r));
        }
    }

    /// <summary>Class which represents the syntax node for type argument list.</summary>
    internal sealed partial class TypeArgumentListSyntax : CSharpSyntaxNode
    {
        internal readonly SyntaxToken lessThanToken;
        internal readonly GreenNode? arguments;
        internal readonly SyntaxToken greaterThanToken;

        internal TypeArgumentListSyntax(SyntaxKind kind, SyntaxToken lessThanToken, GreenNode? arguments, SyntaxToken greaterThanToken, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
            this.SlotCount = 3;
            this.AdjustFlagsAndWidth(lessThanToken);
            this.lessThanToken = lessThanToken;
            if (arguments != null)
            {
                this.AdjustFlagsAndWidth(arguments);
                this.arguments = arguments;
            }
            this.AdjustFlagsAndWidth(greaterThanToken);
            this.greaterThanToken = greaterThanToken;
        }

        internal TypeArgumentListSyntax(SyntaxKind kind, SyntaxToken lessThanToken, GreenNode? arguments, SyntaxToken greaterThanToken, SyntaxFactoryContext context)
          : base(kind)
        {
            this.SetFactoryContext(context);
            this.SlotCount = 3;
            this.AdjustFlagsAndWidth(lessThanToken);
            this.lessThanToken = lessThanToken;
            if (arguments != null)
            {
                this.AdjustFlagsAndWidth(arguments);
                this.arguments = arguments;
            }
            this.AdjustFlagsAndWidth(greaterThanToken);
            this.greaterThanToken = greaterThanToken;
        }

        internal TypeArgumentListSyntax(SyntaxKind kind, SyntaxToken lessThanToken, GreenNode? arguments, SyntaxToken greaterThanToken)
          : base(kind)
        {
            this.SlotCount = 3;
            this.AdjustFlagsAndWidth(lessThanToken);
            this.lessThanToken = lessThanToken;
            if (arguments != null)
            {
                this.AdjustFlagsAndWidth(arguments);
                this.arguments = arguments;
            }
            this.AdjustFlagsAndWidth(greaterThanToken);
            this.greaterThanToken = greaterThanToken;
        }

        /// <summary>SyntaxToken representing less than.</summary>
        public SyntaxToken LessThanToken => this.lessThanToken;
        /// <summary>SeparatedSyntaxList of TypeSyntax node representing the type arguments.</summary>
        public Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<TypeSyntax> Arguments => new Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<TypeSyntax>(new Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<CSharpSyntaxNode>(this.arguments));
        /// <summary>SyntaxToken representing greater than.</summary>
        public SyntaxToken GreaterThanToken => this.greaterThanToken;

        internal override GreenNode? GetSlot(int index)
            => index switch
            {
                0 => this.lessThanToken,
                1 => this.arguments,
                2 => this.greaterThanToken,
                _ => null,
            };

        internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new CSharp.Syntax.TypeArgumentListSyntax(this, parent, position);

        public override void Accept(CSharpSyntaxVisitor visitor) => visitor.VisitTypeArgumentList(this);
        public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor) => visitor.VisitTypeArgumentList(this);

        public TypeArgumentListSyntax Update(SyntaxToken lessThanToken, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<TypeSyntax> arguments, SyntaxToken greaterThanToken)
        {
            if (lessThanToken != this.LessThanToken || arguments != this.Arguments || greaterThanToken != this.GreaterThanToken)
            {
                var newNode = SyntaxFactory.TypeArgumentList(lessThanToken, arguments, greaterThanToken);
                var diags = GetDiagnostics();
                if (diags?.Length > 0)
                    newNode = newNode.WithDiagnosticsGreen(diags);
                var annotations = GetAnnotations();
                if (annotations?.Length > 0)
                    newNode = newNode.WithAnnotationsGreen(annotations);
                return newNode;
            }

            return this;
        }

        internal override GreenNode SetDiagnostics(DiagnosticInfo[]? diagnostics)
            => new TypeArgumentListSyntax(this.Kind, this.lessThanToken, this.arguments, this.greaterThanToken, diagnostics, GetAnnotations());

        internal override GreenNode SetAnnotations(SyntaxAnnotation[]? annotations)
            => new TypeArgumentListSyntax(this.Kind, this.lessThanToken, this.arguments, this.greaterThanToken, GetDiagnostics(), annotations);

        internal TypeArgumentListSyntax(ObjectReader reader)
          : base(reader)
        {
            this.SlotCount = 3;
            var lessThanToken = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(lessThanToken);
            this.lessThanToken = lessThanToken;
            var arguments = (GreenNode?)reader.ReadValue();
            if (arguments != null)
            {
                AdjustFlagsAndWidth(arguments);
                this.arguments = arguments;
            }
            var greaterThanToken = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(greaterThanToken);
            this.greaterThanToken = greaterThanToken;
        }

        internal override void WriteTo(ObjectWriter writer)
        {
            base.WriteTo(writer);
            writer.WriteValue(this.lessThanToken);
            writer.WriteValue(this.arguments);
            writer.WriteValue(this.greaterThanToken);
        }

        static TypeArgumentListSyntax()
        {
            ObjectBinder.RegisterTypeReader(typeof(TypeArgumentListSyntax), r => new TypeArgumentListSyntax(r));
        }
    }

    /// <summary>Class which represents the syntax node for alias qualified name.</summary>
    internal sealed partial class AliasQualifiedNameSyntax : NameSyntax
    {
        internal readonly IdentifierNameSyntax alias;
        internal readonly SyntaxToken colonColonToken;
        internal readonly SimpleNameSyntax name;

        internal AliasQualifiedNameSyntax(SyntaxKind kind, IdentifierNameSyntax alias, SyntaxToken colonColonToken, SimpleNameSyntax name, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
            this.SlotCount = 3;
            this.AdjustFlagsAndWidth(alias);
            this.alias = alias;
            this.AdjustFlagsAndWidth(colonColonToken);
            this.colonColonToken = colonColonToken;
            this.AdjustFlagsAndWidth(name);
            this.name = name;
        }

        internal AliasQualifiedNameSyntax(SyntaxKind kind, IdentifierNameSyntax alias, SyntaxToken colonColonToken, SimpleNameSyntax name, SyntaxFactoryContext context)
          : base(kind)
        {
            this.SetFactoryContext(context);
            this.SlotCount = 3;
            this.AdjustFlagsAndWidth(alias);
            this.alias = alias;
            this.AdjustFlagsAndWidth(colonColonToken);
            this.colonColonToken = colonColonToken;
            this.AdjustFlagsAndWidth(name);
            this.name = name;
        }

        internal AliasQualifiedNameSyntax(SyntaxKind kind, IdentifierNameSyntax alias, SyntaxToken colonColonToken, SimpleNameSyntax name)
          : base(kind)
        {
            this.SlotCount = 3;
            this.AdjustFlagsAndWidth(alias);
            this.alias = alias;
            this.AdjustFlagsAndWidth(colonColonToken);
            this.colonColonToken = colonColonToken;
            this.AdjustFlagsAndWidth(name);
            this.name = name;
        }

        /// <summary>IdentifierNameSyntax node representing the name of the alias</summary>
        public IdentifierNameSyntax Alias => this.alias;
        /// <summary>SyntaxToken representing colon colon.</summary>
        public SyntaxToken ColonColonToken => this.colonColonToken;
        /// <summary>SimpleNameSyntax node representing the name that is being alias qualified.</summary>
        public SimpleNameSyntax Name => this.name;

        internal override GreenNode? GetSlot(int index)
            => index switch
            {
                0 => this.alias,
                1 => this.colonColonToken,
                2 => this.name,
                _ => null,
            };

        internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new CSharp.Syntax.AliasQualifiedNameSyntax(this, parent, position);

        public override void Accept(CSharpSyntaxVisitor visitor) => visitor.VisitAliasQualifiedName(this);
        public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor) => visitor.VisitAliasQualifiedName(this);

        public AliasQualifiedNameSyntax Update(IdentifierNameSyntax alias, SyntaxToken colonColonToken, SimpleNameSyntax name)
        {
            if (alias != this.Alias || colonColonToken != this.ColonColonToken || name != this.Name)
            {
                var newNode = SyntaxFactory.AliasQualifiedName(alias, colonColonToken, name);
                var diags = GetDiagnostics();
                if (diags?.Length > 0)
                    newNode = newNode.WithDiagnosticsGreen(diags);
                var annotations = GetAnnotations();
                if (annotations?.Length > 0)
                    newNode = newNode.WithAnnotationsGreen(annotations);
                return newNode;
            }

            return this;
        }

        internal override GreenNode SetDiagnostics(DiagnosticInfo[]? diagnostics)
            => new AliasQualifiedNameSyntax(this.Kind, this.alias, this.colonColonToken, this.name, diagnostics, GetAnnotations());

        internal override GreenNode SetAnnotations(SyntaxAnnotation[]? annotations)
            => new AliasQualifiedNameSyntax(this.Kind, this.alias, this.colonColonToken, this.name, GetDiagnostics(), annotations);

        internal AliasQualifiedNameSyntax(ObjectReader reader)
          : base(reader)
        {
            this.SlotCount = 3;
            var alias = (IdentifierNameSyntax)reader.ReadValue();
            AdjustFlagsAndWidth(alias);
            this.alias = alias;
            var colonColonToken = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(colonColonToken);
            this.colonColonToken = colonColonToken;
            var name = (SimpleNameSyntax)reader.ReadValue();
            AdjustFlagsAndWidth(name);
            this.name = name;
        }

        internal override void WriteTo(ObjectWriter writer)
        {
            base.WriteTo(writer);
            writer.WriteValue(this.alias);
            writer.WriteValue(this.colonColonToken);
            writer.WriteValue(this.name);
        }

        static AliasQualifiedNameSyntax()
        {
            ObjectBinder.RegisterTypeReader(typeof(AliasQualifiedNameSyntax), r => new AliasQualifiedNameSyntax(r));
        }
    }

    /// <summary>Provides the base class from which the classes that represent type syntax nodes are derived. This is an abstract class.</summary>
    internal abstract partial class TypeSyntax : ExpressionSyntax
    {
        internal TypeSyntax(SyntaxKind kind, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
        }

        internal TypeSyntax(SyntaxKind kind)
          : base(kind)
        {
        }

        protected TypeSyntax(ObjectReader reader)
          : base(reader)
        {
        }
    }

    /// <summary>Class which represents the syntax node for predefined types.</summary>
    internal sealed partial class PredefinedTypeSyntax : TypeSyntax
    {
        internal readonly SyntaxToken keyword;

        internal PredefinedTypeSyntax(SyntaxKind kind, SyntaxToken keyword, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
            this.SlotCount = 1;
            this.AdjustFlagsAndWidth(keyword);
            this.keyword = keyword;
        }

        internal PredefinedTypeSyntax(SyntaxKind kind, SyntaxToken keyword, SyntaxFactoryContext context)
          : base(kind)
        {
            this.SetFactoryContext(context);
            this.SlotCount = 1;
            this.AdjustFlagsAndWidth(keyword);
            this.keyword = keyword;
        }

        internal PredefinedTypeSyntax(SyntaxKind kind, SyntaxToken keyword)
          : base(kind)
        {
            this.SlotCount = 1;
            this.AdjustFlagsAndWidth(keyword);
            this.keyword = keyword;
        }

        /// <summary>SyntaxToken which represents the keyword corresponding to the predefined type.</summary>
        public SyntaxToken Keyword => this.keyword;

        internal override GreenNode? GetSlot(int index)
            => index == 0 ? this.keyword : null;

        internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new CSharp.Syntax.PredefinedTypeSyntax(this, parent, position);

        public override void Accept(CSharpSyntaxVisitor visitor) => visitor.VisitPredefinedType(this);
        public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor) => visitor.VisitPredefinedType(this);

        public PredefinedTypeSyntax Update(SyntaxToken keyword)
        {
            if (keyword != this.Keyword)
            {
                var newNode = SyntaxFactory.PredefinedType(keyword);
                var diags = GetDiagnostics();
                if (diags?.Length > 0)
                    newNode = newNode.WithDiagnosticsGreen(diags);
                var annotations = GetAnnotations();
                if (annotations?.Length > 0)
                    newNode = newNode.WithAnnotationsGreen(annotations);
                return newNode;
            }

            return this;
        }

        internal override GreenNode SetDiagnostics(DiagnosticInfo[]? diagnostics)
            => new PredefinedTypeSyntax(this.Kind, this.keyword, diagnostics, GetAnnotations());

        internal override GreenNode SetAnnotations(SyntaxAnnotation[]? annotations)
            => new PredefinedTypeSyntax(this.Kind, this.keyword, GetDiagnostics(), annotations);

        internal PredefinedTypeSyntax(ObjectReader reader)
          : base(reader)
        {
            this.SlotCount = 1;
            var keyword = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(keyword);
            this.keyword = keyword;
        }

        internal override void WriteTo(ObjectWriter writer)
        {
            base.WriteTo(writer);
            writer.WriteValue(this.keyword);
        }

        static PredefinedTypeSyntax()
        {
            ObjectBinder.RegisterTypeReader(typeof(PredefinedTypeSyntax), r => new PredefinedTypeSyntax(r));
        }
    }

    /// <summary>Class which represents the syntax node for the array type.</summary>
    internal sealed partial class ArrayTypeSyntax : TypeSyntax
    {
        internal readonly TypeSyntax elementType;
        internal readonly GreenNode? rankSpecifiers;

        internal ArrayTypeSyntax(SyntaxKind kind, TypeSyntax elementType, GreenNode? rankSpecifiers, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
            this.SlotCount = 2;
            this.AdjustFlagsAndWidth(elementType);
            this.elementType = elementType;
            if (rankSpecifiers != null)
            {
                this.AdjustFlagsAndWidth(rankSpecifiers);
                this.rankSpecifiers = rankSpecifiers;
            }
        }

        internal ArrayTypeSyntax(SyntaxKind kind, TypeSyntax elementType, GreenNode? rankSpecifiers, SyntaxFactoryContext context)
          : base(kind)
        {
            this.SetFactoryContext(context);
            this.SlotCount = 2;
            this.AdjustFlagsAndWidth(elementType);
            this.elementType = elementType;
            if (rankSpecifiers != null)
            {
                this.AdjustFlagsAndWidth(rankSpecifiers);
                this.rankSpecifiers = rankSpecifiers;
            }
        }

        internal ArrayTypeSyntax(SyntaxKind kind, TypeSyntax elementType, GreenNode? rankSpecifiers)
          : base(kind)
        {
            this.SlotCount = 2;
            this.AdjustFlagsAndWidth(elementType);
            this.elementType = elementType;
            if (rankSpecifiers != null)
            {
                this.AdjustFlagsAndWidth(rankSpecifiers);
                this.rankSpecifiers = rankSpecifiers;
            }
        }

        /// <summary>TypeSyntax node representing the type of the element of the array.</summary>
        public TypeSyntax ElementType => this.elementType;
        /// <summary>SyntaxList of ArrayRankSpecifierSyntax nodes representing the list of rank specifiers for the array.</summary>
        public Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<ArrayRankSpecifierSyntax> RankSpecifiers => new Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<ArrayRankSpecifierSyntax>(this.rankSpecifiers);

        internal override GreenNode? GetSlot(int index)
            => index switch
            {
                0 => this.elementType,
                1 => this.rankSpecifiers,
                _ => null,
            };

        internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new CSharp.Syntax.ArrayTypeSyntax(this, parent, position);

        public override void Accept(CSharpSyntaxVisitor visitor) => visitor.VisitArrayType(this);
        public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor) => visitor.VisitArrayType(this);

        public ArrayTypeSyntax Update(TypeSyntax elementType, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<ArrayRankSpecifierSyntax> rankSpecifiers)
        {
            if (elementType != this.ElementType || rankSpecifiers != this.RankSpecifiers)
            {
                var newNode = SyntaxFactory.ArrayType(elementType, rankSpecifiers);
                var diags = GetDiagnostics();
                if (diags?.Length > 0)
                    newNode = newNode.WithDiagnosticsGreen(diags);
                var annotations = GetAnnotations();
                if (annotations?.Length > 0)
                    newNode = newNode.WithAnnotationsGreen(annotations);
                return newNode;
            }

            return this;
        }

        internal override GreenNode SetDiagnostics(DiagnosticInfo[]? diagnostics)
            => new ArrayTypeSyntax(this.Kind, this.elementType, this.rankSpecifiers, diagnostics, GetAnnotations());

        internal override GreenNode SetAnnotations(SyntaxAnnotation[]? annotations)
            => new ArrayTypeSyntax(this.Kind, this.elementType, this.rankSpecifiers, GetDiagnostics(), annotations);

        internal ArrayTypeSyntax(ObjectReader reader)
          : base(reader)
        {
            this.SlotCount = 2;
            var elementType = (TypeSyntax)reader.ReadValue();
            AdjustFlagsAndWidth(elementType);
            this.elementType = elementType;
            var rankSpecifiers = (GreenNode?)reader.ReadValue();
            if (rankSpecifiers != null)
            {
                AdjustFlagsAndWidth(rankSpecifiers);
                this.rankSpecifiers = rankSpecifiers;
            }
        }

        internal override void WriteTo(ObjectWriter writer)
        {
            base.WriteTo(writer);
            writer.WriteValue(this.elementType);
            writer.WriteValue(this.rankSpecifiers);
        }

        static ArrayTypeSyntax()
        {
            ObjectBinder.RegisterTypeReader(typeof(ArrayTypeSyntax), r => new ArrayTypeSyntax(r));
        }
    }

    internal sealed partial class ArrayRankSpecifierSyntax : CSharpSyntaxNode
    {
        internal readonly SyntaxToken openBracketToken;
        internal readonly GreenNode? sizes;
        internal readonly SyntaxToken closeBracketToken;

        internal ArrayRankSpecifierSyntax(SyntaxKind kind, SyntaxToken openBracketToken, GreenNode? sizes, SyntaxToken closeBracketToken, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
            this.SlotCount = 3;
            this.AdjustFlagsAndWidth(openBracketToken);
            this.openBracketToken = openBracketToken;
            if (sizes != null)
            {
                this.AdjustFlagsAndWidth(sizes);
                this.sizes = sizes;
            }
            this.AdjustFlagsAndWidth(closeBracketToken);
            this.closeBracketToken = closeBracketToken;
        }

        internal ArrayRankSpecifierSyntax(SyntaxKind kind, SyntaxToken openBracketToken, GreenNode? sizes, SyntaxToken closeBracketToken, SyntaxFactoryContext context)
          : base(kind)
        {
            this.SetFactoryContext(context);
            this.SlotCount = 3;
            this.AdjustFlagsAndWidth(openBracketToken);
            this.openBracketToken = openBracketToken;
            if (sizes != null)
            {
                this.AdjustFlagsAndWidth(sizes);
                this.sizes = sizes;
            }
            this.AdjustFlagsAndWidth(closeBracketToken);
            this.closeBracketToken = closeBracketToken;
        }

        internal ArrayRankSpecifierSyntax(SyntaxKind kind, SyntaxToken openBracketToken, GreenNode? sizes, SyntaxToken closeBracketToken)
          : base(kind)
        {
            this.SlotCount = 3;
            this.AdjustFlagsAndWidth(openBracketToken);
            this.openBracketToken = openBracketToken;
            if (sizes != null)
            {
                this.AdjustFlagsAndWidth(sizes);
                this.sizes = sizes;
            }
            this.AdjustFlagsAndWidth(closeBracketToken);
            this.closeBracketToken = closeBracketToken;
        }

        public SyntaxToken OpenBracketToken => this.openBracketToken;
        public Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<ExpressionSyntax> Sizes => new Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<ExpressionSyntax>(new Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<CSharpSyntaxNode>(this.sizes));
        public SyntaxToken CloseBracketToken => this.closeBracketToken;

        internal override GreenNode? GetSlot(int index)
            => index switch
            {
                0 => this.openBracketToken,
                1 => this.sizes,
                2 => this.closeBracketToken,
                _ => null,
            };

        internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new CSharp.Syntax.ArrayRankSpecifierSyntax(this, parent, position);

        public override void Accept(CSharpSyntaxVisitor visitor) => visitor.VisitArrayRankSpecifier(this);
        public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor) => visitor.VisitArrayRankSpecifier(this);

        public ArrayRankSpecifierSyntax Update(SyntaxToken openBracketToken, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<ExpressionSyntax> sizes, SyntaxToken closeBracketToken)
        {
            if (openBracketToken != this.OpenBracketToken || sizes != this.Sizes || closeBracketToken != this.CloseBracketToken)
            {
                var newNode = SyntaxFactory.ArrayRankSpecifier(openBracketToken, sizes, closeBracketToken);
                var diags = GetDiagnostics();
                if (diags?.Length > 0)
                    newNode = newNode.WithDiagnosticsGreen(diags);
                var annotations = GetAnnotations();
                if (annotations?.Length > 0)
                    newNode = newNode.WithAnnotationsGreen(annotations);
                return newNode;
            }

            return this;
        }

        internal override GreenNode SetDiagnostics(DiagnosticInfo[]? diagnostics)
            => new ArrayRankSpecifierSyntax(this.Kind, this.openBracketToken, this.sizes, this.closeBracketToken, diagnostics, GetAnnotations());

        internal override GreenNode SetAnnotations(SyntaxAnnotation[]? annotations)
            => new ArrayRankSpecifierSyntax(this.Kind, this.openBracketToken, this.sizes, this.closeBracketToken, GetDiagnostics(), annotations);

        internal ArrayRankSpecifierSyntax(ObjectReader reader)
          : base(reader)
        {
            this.SlotCount = 3;
            var openBracketToken = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(openBracketToken);
            this.openBracketToken = openBracketToken;
            var sizes = (GreenNode?)reader.ReadValue();
            if (sizes != null)
            {
                AdjustFlagsAndWidth(sizes);
                this.sizes = sizes;
            }
            var closeBracketToken = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(closeBracketToken);
            this.closeBracketToken = closeBracketToken;
        }

        internal override void WriteTo(ObjectWriter writer)
        {
            base.WriteTo(writer);
            writer.WriteValue(this.openBracketToken);
            writer.WriteValue(this.sizes);
            writer.WriteValue(this.closeBracketToken);
        }

        static ArrayRankSpecifierSyntax()
        {
            ObjectBinder.RegisterTypeReader(typeof(ArrayRankSpecifierSyntax), r => new ArrayRankSpecifierSyntax(r));
        }
    }

    /// <summary>Class which represents the syntax node for pointer type.</summary>
    internal sealed partial class PointerTypeSyntax : TypeSyntax
    {
        internal readonly TypeSyntax elementType;
        internal readonly SyntaxToken asteriskToken;

        internal PointerTypeSyntax(SyntaxKind kind, TypeSyntax elementType, SyntaxToken asteriskToken, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
            this.SlotCount = 2;
            this.AdjustFlagsAndWidth(elementType);
            this.elementType = elementType;
            this.AdjustFlagsAndWidth(asteriskToken);
            this.asteriskToken = asteriskToken;
        }

        internal PointerTypeSyntax(SyntaxKind kind, TypeSyntax elementType, SyntaxToken asteriskToken, SyntaxFactoryContext context)
          : base(kind)
        {
            this.SetFactoryContext(context);
            this.SlotCount = 2;
            this.AdjustFlagsAndWidth(elementType);
            this.elementType = elementType;
            this.AdjustFlagsAndWidth(asteriskToken);
            this.asteriskToken = asteriskToken;
        }

        internal PointerTypeSyntax(SyntaxKind kind, TypeSyntax elementType, SyntaxToken asteriskToken)
          : base(kind)
        {
            this.SlotCount = 2;
            this.AdjustFlagsAndWidth(elementType);
            this.elementType = elementType;
            this.AdjustFlagsAndWidth(asteriskToken);
            this.asteriskToken = asteriskToken;
        }

        /// <summary>TypeSyntax node that represents the element type of the pointer.</summary>
        public TypeSyntax ElementType => this.elementType;
        /// <summary>SyntaxToken representing the asterisk.</summary>
        public SyntaxToken AsteriskToken => this.asteriskToken;

        internal override GreenNode? GetSlot(int index)
            => index switch
            {
                0 => this.elementType,
                1 => this.asteriskToken,
                _ => null,
            };

        internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new CSharp.Syntax.PointerTypeSyntax(this, parent, position);

        public override void Accept(CSharpSyntaxVisitor visitor) => visitor.VisitPointerType(this);
        public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor) => visitor.VisitPointerType(this);

        public PointerTypeSyntax Update(TypeSyntax elementType, SyntaxToken asteriskToken)
        {
            if (elementType != this.ElementType || asteriskToken != this.AsteriskToken)
            {
                var newNode = SyntaxFactory.PointerType(elementType, asteriskToken);
                var diags = GetDiagnostics();
                if (diags?.Length > 0)
                    newNode = newNode.WithDiagnosticsGreen(diags);
                var annotations = GetAnnotations();
                if (annotations?.Length > 0)
                    newNode = newNode.WithAnnotationsGreen(annotations);
                return newNode;
            }

            return this;
        }

        internal override GreenNode SetDiagnostics(DiagnosticInfo[]? diagnostics)
            => new PointerTypeSyntax(this.Kind, this.elementType, this.asteriskToken, diagnostics, GetAnnotations());

        internal override GreenNode SetAnnotations(SyntaxAnnotation[]? annotations)
            => new PointerTypeSyntax(this.Kind, this.elementType, this.asteriskToken, GetDiagnostics(), annotations);

        internal PointerTypeSyntax(ObjectReader reader)
          : base(reader)
        {
            this.SlotCount = 2;
            var elementType = (TypeSyntax)reader.ReadValue();
            AdjustFlagsAndWidth(elementType);
            this.elementType = elementType;
            var asteriskToken = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(asteriskToken);
            this.asteriskToken = asteriskToken;
        }

        internal override void WriteTo(ObjectWriter writer)
        {
            base.WriteTo(writer);
            writer.WriteValue(this.elementType);
            writer.WriteValue(this.asteriskToken);
        }

        static PointerTypeSyntax()
        {
            ObjectBinder.RegisterTypeReader(typeof(PointerTypeSyntax), r => new PointerTypeSyntax(r));
        }
    }

    internal sealed partial class FunctionPointerTypeSyntax : TypeSyntax
    {
        internal readonly SyntaxToken delegateKeyword;
        internal readonly SyntaxToken asteriskToken;
        internal readonly FunctionPointerCallingConventionSyntax? callingConvention;
        internal readonly FunctionPointerParameterListSyntax parameterList;

        internal FunctionPointerTypeSyntax(SyntaxKind kind, SyntaxToken delegateKeyword, SyntaxToken asteriskToken, FunctionPointerCallingConventionSyntax? callingConvention, FunctionPointerParameterListSyntax parameterList, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
            this.SlotCount = 4;
            this.AdjustFlagsAndWidth(delegateKeyword);
            this.delegateKeyword = delegateKeyword;
            this.AdjustFlagsAndWidth(asteriskToken);
            this.asteriskToken = asteriskToken;
            if (callingConvention != null)
            {
                this.AdjustFlagsAndWidth(callingConvention);
                this.callingConvention = callingConvention;
            }
            this.AdjustFlagsAndWidth(parameterList);
            this.parameterList = parameterList;
        }

        internal FunctionPointerTypeSyntax(SyntaxKind kind, SyntaxToken delegateKeyword, SyntaxToken asteriskToken, FunctionPointerCallingConventionSyntax? callingConvention, FunctionPointerParameterListSyntax parameterList, SyntaxFactoryContext context)
          : base(kind)
        {
            this.SetFactoryContext(context);
            this.SlotCount = 4;
            this.AdjustFlagsAndWidth(delegateKeyword);
            this.delegateKeyword = delegateKeyword;
            this.AdjustFlagsAndWidth(asteriskToken);
            this.asteriskToken = asteriskToken;
            if (callingConvention != null)
            {
                this.AdjustFlagsAndWidth(callingConvention);
                this.callingConvention = callingConvention;
            }
            this.AdjustFlagsAndWidth(parameterList);
            this.parameterList = parameterList;
        }

        internal FunctionPointerTypeSyntax(SyntaxKind kind, SyntaxToken delegateKeyword, SyntaxToken asteriskToken, FunctionPointerCallingConventionSyntax? callingConvention, FunctionPointerParameterListSyntax parameterList)
          : base(kind)
        {
            this.SlotCount = 4;
            this.AdjustFlagsAndWidth(delegateKeyword);
            this.delegateKeyword = delegateKeyword;
            this.AdjustFlagsAndWidth(asteriskToken);
            this.asteriskToken = asteriskToken;
            if (callingConvention != null)
            {
                this.AdjustFlagsAndWidth(callingConvention);
                this.callingConvention = callingConvention;
            }
            this.AdjustFlagsAndWidth(parameterList);
            this.parameterList = parameterList;
        }

        /// <summary>SyntaxToken representing the delegate keyword.</summary>
        public SyntaxToken DelegateKeyword => this.delegateKeyword;
        /// <summary>SyntaxToken representing the asterisk.</summary>
        public SyntaxToken AsteriskToken => this.asteriskToken;
        /// <summary>Node representing the optional calling convention.</summary>
        public FunctionPointerCallingConventionSyntax? CallingConvention => this.callingConvention;
        /// <summary>List of the parameter types and return type of the function pointer.</summary>
        public FunctionPointerParameterListSyntax ParameterList => this.parameterList;

        internal override GreenNode? GetSlot(int index)
            => index switch
            {
                0 => this.delegateKeyword,
                1 => this.asteriskToken,
                2 => this.callingConvention,
                3 => this.parameterList,
                _ => null,
            };

        internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new CSharp.Syntax.FunctionPointerTypeSyntax(this, parent, position);

        public override void Accept(CSharpSyntaxVisitor visitor) => visitor.VisitFunctionPointerType(this);
        public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor) => visitor.VisitFunctionPointerType(this);

        public FunctionPointerTypeSyntax Update(SyntaxToken delegateKeyword, SyntaxToken asteriskToken, FunctionPointerCallingConventionSyntax callingConvention, FunctionPointerParameterListSyntax parameterList)
        {
            if (delegateKeyword != this.DelegateKeyword || asteriskToken != this.AsteriskToken || callingConvention != this.CallingConvention || parameterList != this.ParameterList)
            {
                var newNode = SyntaxFactory.FunctionPointerType(delegateKeyword, asteriskToken, callingConvention, parameterList);
                var diags = GetDiagnostics();
                if (diags?.Length > 0)
                    newNode = newNode.WithDiagnosticsGreen(diags);
                var annotations = GetAnnotations();
                if (annotations?.Length > 0)
                    newNode = newNode.WithAnnotationsGreen(annotations);
                return newNode;
            }

            return this;
        }

        internal override GreenNode SetDiagnostics(DiagnosticInfo[]? diagnostics)
            => new FunctionPointerTypeSyntax(this.Kind, this.delegateKeyword, this.asteriskToken, this.callingConvention, this.parameterList, diagnostics, GetAnnotations());

        internal override GreenNode SetAnnotations(SyntaxAnnotation[]? annotations)
            => new FunctionPointerTypeSyntax(this.Kind, this.delegateKeyword, this.asteriskToken, this.callingConvention, this.parameterList, GetDiagnostics(), annotations);

        internal FunctionPointerTypeSyntax(ObjectReader reader)
          : base(reader)
        {
            this.SlotCount = 4;
            var delegateKeyword = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(delegateKeyword);
            this.delegateKeyword = delegateKeyword;
            var asteriskToken = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(asteriskToken);
            this.asteriskToken = asteriskToken;
            var callingConvention = (FunctionPointerCallingConventionSyntax?)reader.ReadValue();
            if (callingConvention != null)
            {
                AdjustFlagsAndWidth(callingConvention);
                this.callingConvention = callingConvention;
            }
            var parameterList = (FunctionPointerParameterListSyntax)reader.ReadValue();
            AdjustFlagsAndWidth(parameterList);
            this.parameterList = parameterList;
        }

        internal override void WriteTo(ObjectWriter writer)
        {
            base.WriteTo(writer);
            writer.WriteValue(this.delegateKeyword);
            writer.WriteValue(this.asteriskToken);
            writer.WriteValue(this.callingConvention);
            writer.WriteValue(this.parameterList);
        }

        static FunctionPointerTypeSyntax()
        {
            ObjectBinder.RegisterTypeReader(typeof(FunctionPointerTypeSyntax), r => new FunctionPointerTypeSyntax(r));
        }
    }

    /// <summary>Function pointer parameter list syntax.</summary>
    internal sealed partial class FunctionPointerParameterListSyntax : CSharpSyntaxNode
    {
        internal readonly SyntaxToken lessThanToken;
        internal readonly GreenNode? parameters;
        internal readonly SyntaxToken greaterThanToken;

        internal FunctionPointerParameterListSyntax(SyntaxKind kind, SyntaxToken lessThanToken, GreenNode? parameters, SyntaxToken greaterThanToken, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
            this.SlotCount = 3;
            this.AdjustFlagsAndWidth(lessThanToken);
            this.lessThanToken = lessThanToken;
            if (parameters != null)
            {
                this.AdjustFlagsAndWidth(parameters);
                this.parameters = parameters;
            }
            this.AdjustFlagsAndWidth(greaterThanToken);
            this.greaterThanToken = greaterThanToken;
        }

        internal FunctionPointerParameterListSyntax(SyntaxKind kind, SyntaxToken lessThanToken, GreenNode? parameters, SyntaxToken greaterThanToken, SyntaxFactoryContext context)
          : base(kind)
        {
            this.SetFactoryContext(context);
            this.SlotCount = 3;
            this.AdjustFlagsAndWidth(lessThanToken);
            this.lessThanToken = lessThanToken;
            if (parameters != null)
            {
                this.AdjustFlagsAndWidth(parameters);
                this.parameters = parameters;
            }
            this.AdjustFlagsAndWidth(greaterThanToken);
            this.greaterThanToken = greaterThanToken;
        }

        internal FunctionPointerParameterListSyntax(SyntaxKind kind, SyntaxToken lessThanToken, GreenNode? parameters, SyntaxToken greaterThanToken)
          : base(kind)
        {
            this.SlotCount = 3;
            this.AdjustFlagsAndWidth(lessThanToken);
            this.lessThanToken = lessThanToken;
            if (parameters != null)
            {
                this.AdjustFlagsAndWidth(parameters);
                this.parameters = parameters;
            }
            this.AdjustFlagsAndWidth(greaterThanToken);
            this.greaterThanToken = greaterThanToken;
        }

        /// <summary>SyntaxToken representing the less than token.</summary>
        public SyntaxToken LessThanToken => this.lessThanToken;
        /// <summary>SeparatedSyntaxList of ParameterSyntaxes representing the list of parameters and return type.</summary>
        public Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<FunctionPointerParameterSyntax> Parameters => new Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<FunctionPointerParameterSyntax>(new Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<CSharpSyntaxNode>(this.parameters));
        /// <summary>SyntaxToken representing the greater than token.</summary>
        public SyntaxToken GreaterThanToken => this.greaterThanToken;

        internal override GreenNode? GetSlot(int index)
            => index switch
            {
                0 => this.lessThanToken,
                1 => this.parameters,
                2 => this.greaterThanToken,
                _ => null,
            };

        internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new CSharp.Syntax.FunctionPointerParameterListSyntax(this, parent, position);

        public override void Accept(CSharpSyntaxVisitor visitor) => visitor.VisitFunctionPointerParameterList(this);
        public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor) => visitor.VisitFunctionPointerParameterList(this);

        public FunctionPointerParameterListSyntax Update(SyntaxToken lessThanToken, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<FunctionPointerParameterSyntax> parameters, SyntaxToken greaterThanToken)
        {
            if (lessThanToken != this.LessThanToken || parameters != this.Parameters || greaterThanToken != this.GreaterThanToken)
            {
                var newNode = SyntaxFactory.FunctionPointerParameterList(lessThanToken, parameters, greaterThanToken);
                var diags = GetDiagnostics();
                if (diags?.Length > 0)
                    newNode = newNode.WithDiagnosticsGreen(diags);
                var annotations = GetAnnotations();
                if (annotations?.Length > 0)
                    newNode = newNode.WithAnnotationsGreen(annotations);
                return newNode;
            }

            return this;
        }

        internal override GreenNode SetDiagnostics(DiagnosticInfo[]? diagnostics)
            => new FunctionPointerParameterListSyntax(this.Kind, this.lessThanToken, this.parameters, this.greaterThanToken, diagnostics, GetAnnotations());

        internal override GreenNode SetAnnotations(SyntaxAnnotation[]? annotations)
            => new FunctionPointerParameterListSyntax(this.Kind, this.lessThanToken, this.parameters, this.greaterThanToken, GetDiagnostics(), annotations);

        internal FunctionPointerParameterListSyntax(ObjectReader reader)
          : base(reader)
        {
            this.SlotCount = 3;
            var lessThanToken = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(lessThanToken);
            this.lessThanToken = lessThanToken;
            var parameters = (GreenNode?)reader.ReadValue();
            if (parameters != null)
            {
                AdjustFlagsAndWidth(parameters);
                this.parameters = parameters;
            }
            var greaterThanToken = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(greaterThanToken);
            this.greaterThanToken = greaterThanToken;
        }

        internal override void WriteTo(ObjectWriter writer)
        {
            base.WriteTo(writer);
            writer.WriteValue(this.lessThanToken);
            writer.WriteValue(this.parameters);
            writer.WriteValue(this.greaterThanToken);
        }

        static FunctionPointerParameterListSyntax()
        {
            ObjectBinder.RegisterTypeReader(typeof(FunctionPointerParameterListSyntax), r => new FunctionPointerParameterListSyntax(r));
        }
    }

    /// <summary>Function pointer calling convention syntax.</summary>
    internal sealed partial class FunctionPointerCallingConventionSyntax : CSharpSyntaxNode
    {
        internal readonly SyntaxToken managedOrUnmanagedKeyword;
        internal readonly FunctionPointerUnmanagedCallingConventionListSyntax? unmanagedCallingConventionList;

        internal FunctionPointerCallingConventionSyntax(SyntaxKind kind, SyntaxToken managedOrUnmanagedKeyword, FunctionPointerUnmanagedCallingConventionListSyntax? unmanagedCallingConventionList, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
            this.SlotCount = 2;
            this.AdjustFlagsAndWidth(managedOrUnmanagedKeyword);
            this.managedOrUnmanagedKeyword = managedOrUnmanagedKeyword;
            if (unmanagedCallingConventionList != null)
            {
                this.AdjustFlagsAndWidth(unmanagedCallingConventionList);
                this.unmanagedCallingConventionList = unmanagedCallingConventionList;
            }
        }

        internal FunctionPointerCallingConventionSyntax(SyntaxKind kind, SyntaxToken managedOrUnmanagedKeyword, FunctionPointerUnmanagedCallingConventionListSyntax? unmanagedCallingConventionList, SyntaxFactoryContext context)
          : base(kind)
        {
            this.SetFactoryContext(context);
            this.SlotCount = 2;
            this.AdjustFlagsAndWidth(managedOrUnmanagedKeyword);
            this.managedOrUnmanagedKeyword = managedOrUnmanagedKeyword;
            if (unmanagedCallingConventionList != null)
            {
                this.AdjustFlagsAndWidth(unmanagedCallingConventionList);
                this.unmanagedCallingConventionList = unmanagedCallingConventionList;
            }
        }

        internal FunctionPointerCallingConventionSyntax(SyntaxKind kind, SyntaxToken managedOrUnmanagedKeyword, FunctionPointerUnmanagedCallingConventionListSyntax? unmanagedCallingConventionList)
          : base(kind)
        {
            this.SlotCount = 2;
            this.AdjustFlagsAndWidth(managedOrUnmanagedKeyword);
            this.managedOrUnmanagedKeyword = managedOrUnmanagedKeyword;
            if (unmanagedCallingConventionList != null)
            {
                this.AdjustFlagsAndWidth(unmanagedCallingConventionList);
                this.unmanagedCallingConventionList = unmanagedCallingConventionList;
            }
        }

        /// <summary>SyntaxToken representing whether the calling convention is managed or unmanaged.</summary>
        public SyntaxToken ManagedOrUnmanagedKeyword => this.managedOrUnmanagedKeyword;
        /// <summary>Optional list of identifiers that will contribute to an unmanaged calling convention.</summary>
        public FunctionPointerUnmanagedCallingConventionListSyntax? UnmanagedCallingConventionList => this.unmanagedCallingConventionList;

        internal override GreenNode? GetSlot(int index)
            => index switch
            {
                0 => this.managedOrUnmanagedKeyword,
                1 => this.unmanagedCallingConventionList,
                _ => null,
            };

        internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new CSharp.Syntax.FunctionPointerCallingConventionSyntax(this, parent, position);

        public override void Accept(CSharpSyntaxVisitor visitor) => visitor.VisitFunctionPointerCallingConvention(this);
        public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor) => visitor.VisitFunctionPointerCallingConvention(this);

        public FunctionPointerCallingConventionSyntax Update(SyntaxToken managedOrUnmanagedKeyword, FunctionPointerUnmanagedCallingConventionListSyntax unmanagedCallingConventionList)
        {
            if (managedOrUnmanagedKeyword != this.ManagedOrUnmanagedKeyword || unmanagedCallingConventionList != this.UnmanagedCallingConventionList)
            {
                var newNode = SyntaxFactory.FunctionPointerCallingConvention(managedOrUnmanagedKeyword, unmanagedCallingConventionList);
                var diags = GetDiagnostics();
                if (diags?.Length > 0)
                    newNode = newNode.WithDiagnosticsGreen(diags);
                var annotations = GetAnnotations();
                if (annotations?.Length > 0)
                    newNode = newNode.WithAnnotationsGreen(annotations);
                return newNode;
            }

            return this;
        }

        internal override GreenNode SetDiagnostics(DiagnosticInfo[]? diagnostics)
            => new FunctionPointerCallingConventionSyntax(this.Kind, this.managedOrUnmanagedKeyword, this.unmanagedCallingConventionList, diagnostics, GetAnnotations());

        internal override GreenNode SetAnnotations(SyntaxAnnotation[]? annotations)
            => new FunctionPointerCallingConventionSyntax(this.Kind, this.managedOrUnmanagedKeyword, this.unmanagedCallingConventionList, GetDiagnostics(), annotations);

        internal FunctionPointerCallingConventionSyntax(ObjectReader reader)
          : base(reader)
        {
            this.SlotCount = 2;
            var managedOrUnmanagedKeyword = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(managedOrUnmanagedKeyword);
            this.managedOrUnmanagedKeyword = managedOrUnmanagedKeyword;
            var unmanagedCallingConventionList = (FunctionPointerUnmanagedCallingConventionListSyntax?)reader.ReadValue();
            if (unmanagedCallingConventionList != null)
            {
                AdjustFlagsAndWidth(unmanagedCallingConventionList);
                this.unmanagedCallingConventionList = unmanagedCallingConventionList;
            }
        }

        internal override void WriteTo(ObjectWriter writer)
        {
            base.WriteTo(writer);
            writer.WriteValue(this.managedOrUnmanagedKeyword);
            writer.WriteValue(this.unmanagedCallingConventionList);
        }

        static FunctionPointerCallingConventionSyntax()
        {
            ObjectBinder.RegisterTypeReader(typeof(FunctionPointerCallingConventionSyntax), r => new FunctionPointerCallingConventionSyntax(r));
        }
    }

    /// <summary>Function pointer calling convention syntax.</summary>
    internal sealed partial class FunctionPointerUnmanagedCallingConventionListSyntax : CSharpSyntaxNode
    {
        internal readonly SyntaxToken openBracketToken;
        internal readonly GreenNode? callingConventions;
        internal readonly SyntaxToken closeBracketToken;

        internal FunctionPointerUnmanagedCallingConventionListSyntax(SyntaxKind kind, SyntaxToken openBracketToken, GreenNode? callingConventions, SyntaxToken closeBracketToken, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
            this.SlotCount = 3;
            this.AdjustFlagsAndWidth(openBracketToken);
            this.openBracketToken = openBracketToken;
            if (callingConventions != null)
            {
                this.AdjustFlagsAndWidth(callingConventions);
                this.callingConventions = callingConventions;
            }
            this.AdjustFlagsAndWidth(closeBracketToken);
            this.closeBracketToken = closeBracketToken;
        }

        internal FunctionPointerUnmanagedCallingConventionListSyntax(SyntaxKind kind, SyntaxToken openBracketToken, GreenNode? callingConventions, SyntaxToken closeBracketToken, SyntaxFactoryContext context)
          : base(kind)
        {
            this.SetFactoryContext(context);
            this.SlotCount = 3;
            this.AdjustFlagsAndWidth(openBracketToken);
            this.openBracketToken = openBracketToken;
            if (callingConventions != null)
            {
                this.AdjustFlagsAndWidth(callingConventions);
                this.callingConventions = callingConventions;
            }
            this.AdjustFlagsAndWidth(closeBracketToken);
            this.closeBracketToken = closeBracketToken;
        }

        internal FunctionPointerUnmanagedCallingConventionListSyntax(SyntaxKind kind, SyntaxToken openBracketToken, GreenNode? callingConventions, SyntaxToken closeBracketToken)
          : base(kind)
        {
            this.SlotCount = 3;
            this.AdjustFlagsAndWidth(openBracketToken);
            this.openBracketToken = openBracketToken;
            if (callingConventions != null)
            {
                this.AdjustFlagsAndWidth(callingConventions);
                this.callingConventions = callingConventions;
            }
            this.AdjustFlagsAndWidth(closeBracketToken);
            this.closeBracketToken = closeBracketToken;
        }

        /// <summary>SyntaxToken representing open bracket.</summary>
        public SyntaxToken OpenBracketToken => this.openBracketToken;
        /// <summary>SeparatedSyntaxList of calling convention identifiers.</summary>
        public Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<FunctionPointerUnmanagedCallingConventionSyntax> CallingConventions => new Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<FunctionPointerUnmanagedCallingConventionSyntax>(new Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<CSharpSyntaxNode>(this.callingConventions));
        /// <summary>SyntaxToken representing close bracket.</summary>
        public SyntaxToken CloseBracketToken => this.closeBracketToken;

        internal override GreenNode? GetSlot(int index)
            => index switch
            {
                0 => this.openBracketToken,
                1 => this.callingConventions,
                2 => this.closeBracketToken,
                _ => null,
            };

        internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new CSharp.Syntax.FunctionPointerUnmanagedCallingConventionListSyntax(this, parent, position);

        public override void Accept(CSharpSyntaxVisitor visitor) => visitor.VisitFunctionPointerUnmanagedCallingConventionList(this);
        public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor) => visitor.VisitFunctionPointerUnmanagedCallingConventionList(this);

        public FunctionPointerUnmanagedCallingConventionListSyntax Update(SyntaxToken openBracketToken, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<FunctionPointerUnmanagedCallingConventionSyntax> callingConventions, SyntaxToken closeBracketToken)
        {
            if (openBracketToken != this.OpenBracketToken || callingConventions != this.CallingConventions || closeBracketToken != this.CloseBracketToken)
            {
                var newNode = SyntaxFactory.FunctionPointerUnmanagedCallingConventionList(openBracketToken, callingConventions, closeBracketToken);
                var diags = GetDiagnostics();
                if (diags?.Length > 0)
                    newNode = newNode.WithDiagnosticsGreen(diags);
                var annotations = GetAnnotations();
                if (annotations?.Length > 0)
                    newNode = newNode.WithAnnotationsGreen(annotations);
                return newNode;
            }

            return this;
        }

        internal override GreenNode SetDiagnostics(DiagnosticInfo[]? diagnostics)
            => new FunctionPointerUnmanagedCallingConventionListSyntax(this.Kind, this.openBracketToken, this.callingConventions, this.closeBracketToken, diagnostics, GetAnnotations());

        internal override GreenNode SetAnnotations(SyntaxAnnotation[]? annotations)
            => new FunctionPointerUnmanagedCallingConventionListSyntax(this.Kind, this.openBracketToken, this.callingConventions, this.closeBracketToken, GetDiagnostics(), annotations);

        internal FunctionPointerUnmanagedCallingConventionListSyntax(ObjectReader reader)
          : base(reader)
        {
            this.SlotCount = 3;
            var openBracketToken = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(openBracketToken);
            this.openBracketToken = openBracketToken;
            var callingConventions = (GreenNode?)reader.ReadValue();
            if (callingConventions != null)
            {
                AdjustFlagsAndWidth(callingConventions);
                this.callingConventions = callingConventions;
            }
            var closeBracketToken = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(closeBracketToken);
            this.closeBracketToken = closeBracketToken;
        }

        internal override void WriteTo(ObjectWriter writer)
        {
            base.WriteTo(writer);
            writer.WriteValue(this.openBracketToken);
            writer.WriteValue(this.callingConventions);
            writer.WriteValue(this.closeBracketToken);
        }

        static FunctionPointerUnmanagedCallingConventionListSyntax()
        {
            ObjectBinder.RegisterTypeReader(typeof(FunctionPointerUnmanagedCallingConventionListSyntax), r => new FunctionPointerUnmanagedCallingConventionListSyntax(r));
        }
    }

    /// <summary>Individual function pointer unmanaged calling convention.</summary>
    internal sealed partial class FunctionPointerUnmanagedCallingConventionSyntax : CSharpSyntaxNode
    {
        internal readonly SyntaxToken name;

        internal FunctionPointerUnmanagedCallingConventionSyntax(SyntaxKind kind, SyntaxToken name, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
            this.SlotCount = 1;
            this.AdjustFlagsAndWidth(name);
            this.name = name;
        }

        internal FunctionPointerUnmanagedCallingConventionSyntax(SyntaxKind kind, SyntaxToken name, SyntaxFactoryContext context)
          : base(kind)
        {
            this.SetFactoryContext(context);
            this.SlotCount = 1;
            this.AdjustFlagsAndWidth(name);
            this.name = name;
        }

        internal FunctionPointerUnmanagedCallingConventionSyntax(SyntaxKind kind, SyntaxToken name)
          : base(kind)
        {
            this.SlotCount = 1;
            this.AdjustFlagsAndWidth(name);
            this.name = name;
        }

        /// <summary>SyntaxToken representing the calling convention identifier.</summary>
        public SyntaxToken Name => this.name;

        internal override GreenNode? GetSlot(int index)
            => index == 0 ? this.name : null;

        internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new CSharp.Syntax.FunctionPointerUnmanagedCallingConventionSyntax(this, parent, position);

        public override void Accept(CSharpSyntaxVisitor visitor) => visitor.VisitFunctionPointerUnmanagedCallingConvention(this);
        public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor) => visitor.VisitFunctionPointerUnmanagedCallingConvention(this);

        public FunctionPointerUnmanagedCallingConventionSyntax Update(SyntaxToken name)
        {
            if (name != this.Name)
            {
                var newNode = SyntaxFactory.FunctionPointerUnmanagedCallingConvention(name);
                var diags = GetDiagnostics();
                if (diags?.Length > 0)
                    newNode = newNode.WithDiagnosticsGreen(diags);
                var annotations = GetAnnotations();
                if (annotations?.Length > 0)
                    newNode = newNode.WithAnnotationsGreen(annotations);
                return newNode;
            }

            return this;
        }

        internal override GreenNode SetDiagnostics(DiagnosticInfo[]? diagnostics)
            => new FunctionPointerUnmanagedCallingConventionSyntax(this.Kind, this.name, diagnostics, GetAnnotations());

        internal override GreenNode SetAnnotations(SyntaxAnnotation[]? annotations)
            => new FunctionPointerUnmanagedCallingConventionSyntax(this.Kind, this.name, GetDiagnostics(), annotations);

        internal FunctionPointerUnmanagedCallingConventionSyntax(ObjectReader reader)
          : base(reader)
        {
            this.SlotCount = 1;
            var name = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(name);
            this.name = name;
        }

        internal override void WriteTo(ObjectWriter writer)
        {
            base.WriteTo(writer);
            writer.WriteValue(this.name);
        }

        static FunctionPointerUnmanagedCallingConventionSyntax()
        {
            ObjectBinder.RegisterTypeReader(typeof(FunctionPointerUnmanagedCallingConventionSyntax), r => new FunctionPointerUnmanagedCallingConventionSyntax(r));
        }
    }

    /// <summary>Class which represents the syntax node for a nullable type.</summary>
    internal sealed partial class NullableTypeSyntax : TypeSyntax
    {
        internal readonly TypeSyntax elementType;
        internal readonly SyntaxToken questionToken;

        internal NullableTypeSyntax(SyntaxKind kind, TypeSyntax elementType, SyntaxToken questionToken, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
            this.SlotCount = 2;
            this.AdjustFlagsAndWidth(elementType);
            this.elementType = elementType;
            this.AdjustFlagsAndWidth(questionToken);
            this.questionToken = questionToken;
        }

        internal NullableTypeSyntax(SyntaxKind kind, TypeSyntax elementType, SyntaxToken questionToken, SyntaxFactoryContext context)
          : base(kind)
        {
            this.SetFactoryContext(context);
            this.SlotCount = 2;
            this.AdjustFlagsAndWidth(elementType);
            this.elementType = elementType;
            this.AdjustFlagsAndWidth(questionToken);
            this.questionToken = questionToken;
        }

        internal NullableTypeSyntax(SyntaxKind kind, TypeSyntax elementType, SyntaxToken questionToken)
          : base(kind)
        {
            this.SlotCount = 2;
            this.AdjustFlagsAndWidth(elementType);
            this.elementType = elementType;
            this.AdjustFlagsAndWidth(questionToken);
            this.questionToken = questionToken;
        }

        /// <summary>TypeSyntax node representing the type of the element.</summary>
        public TypeSyntax ElementType => this.elementType;
        /// <summary>SyntaxToken representing the question mark.</summary>
        public SyntaxToken QuestionToken => this.questionToken;

        internal override GreenNode? GetSlot(int index)
            => index switch
            {
                0 => this.elementType,
                1 => this.questionToken,
                _ => null,
            };

        internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new CSharp.Syntax.NullableTypeSyntax(this, parent, position);

        public override void Accept(CSharpSyntaxVisitor visitor) => visitor.VisitNullableType(this);
        public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor) => visitor.VisitNullableType(this);

        public NullableTypeSyntax Update(TypeSyntax elementType, SyntaxToken questionToken)
        {
            if (elementType != this.ElementType || questionToken != this.QuestionToken)
            {
                var newNode = SyntaxFactory.NullableType(elementType, questionToken);
                var diags = GetDiagnostics();
                if (diags?.Length > 0)
                    newNode = newNode.WithDiagnosticsGreen(diags);
                var annotations = GetAnnotations();
                if (annotations?.Length > 0)
                    newNode = newNode.WithAnnotationsGreen(annotations);
                return newNode;
            }

            return this;
        }

        internal override GreenNode SetDiagnostics(DiagnosticInfo[]? diagnostics)
            => new NullableTypeSyntax(this.Kind, this.elementType, this.questionToken, diagnostics, GetAnnotations());

        internal override GreenNode SetAnnotations(SyntaxAnnotation[]? annotations)
            => new NullableTypeSyntax(this.Kind, this.elementType, this.questionToken, GetDiagnostics(), annotations);

        internal NullableTypeSyntax(ObjectReader reader)
          : base(reader)
        {
            this.SlotCount = 2;
            var elementType = (TypeSyntax)reader.ReadValue();
            AdjustFlagsAndWidth(elementType);
            this.elementType = elementType;
            var questionToken = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(questionToken);
            this.questionToken = questionToken;
        }

        internal override void WriteTo(ObjectWriter writer)
        {
            base.WriteTo(writer);
            writer.WriteValue(this.elementType);
            writer.WriteValue(this.questionToken);
        }

        static NullableTypeSyntax()
        {
            ObjectBinder.RegisterTypeReader(typeof(NullableTypeSyntax), r => new NullableTypeSyntax(r));
        }
    }

    /// <summary>Class which represents the syntax node for tuple type.</summary>
    internal sealed partial class TupleTypeSyntax : TypeSyntax
    {
        internal readonly SyntaxToken openParenToken;
        internal readonly GreenNode? elements;
        internal readonly SyntaxToken closeParenToken;

        internal TupleTypeSyntax(SyntaxKind kind, SyntaxToken openParenToken, GreenNode? elements, SyntaxToken closeParenToken, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
            this.SlotCount = 3;
            this.AdjustFlagsAndWidth(openParenToken);
            this.openParenToken = openParenToken;
            if (elements != null)
            {
                this.AdjustFlagsAndWidth(elements);
                this.elements = elements;
            }
            this.AdjustFlagsAndWidth(closeParenToken);
            this.closeParenToken = closeParenToken;
        }

        internal TupleTypeSyntax(SyntaxKind kind, SyntaxToken openParenToken, GreenNode? elements, SyntaxToken closeParenToken, SyntaxFactoryContext context)
          : base(kind)
        {
            this.SetFactoryContext(context);
            this.SlotCount = 3;
            this.AdjustFlagsAndWidth(openParenToken);
            this.openParenToken = openParenToken;
            if (elements != null)
            {
                this.AdjustFlagsAndWidth(elements);
                this.elements = elements;
            }
            this.AdjustFlagsAndWidth(closeParenToken);
            this.closeParenToken = closeParenToken;
        }

        internal TupleTypeSyntax(SyntaxKind kind, SyntaxToken openParenToken, GreenNode? elements, SyntaxToken closeParenToken)
          : base(kind)
        {
            this.SlotCount = 3;
            this.AdjustFlagsAndWidth(openParenToken);
            this.openParenToken = openParenToken;
            if (elements != null)
            {
                this.AdjustFlagsAndWidth(elements);
                this.elements = elements;
            }
            this.AdjustFlagsAndWidth(closeParenToken);
            this.closeParenToken = closeParenToken;
        }

        /// <summary>SyntaxToken representing the open parenthesis.</summary>
        public SyntaxToken OpenParenToken => this.openParenToken;
        public Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<TupleElementSyntax> Elements => new Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<TupleElementSyntax>(new Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<CSharpSyntaxNode>(this.elements));
        /// <summary>SyntaxToken representing the close parenthesis.</summary>
        public SyntaxToken CloseParenToken => this.closeParenToken;

        internal override GreenNode? GetSlot(int index)
            => index switch
            {
                0 => this.openParenToken,
                1 => this.elements,
                2 => this.closeParenToken,
                _ => null,
            };

        internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new CSharp.Syntax.TupleTypeSyntax(this, parent, position);

        public override void Accept(CSharpSyntaxVisitor visitor) => visitor.VisitTupleType(this);
        public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor) => visitor.VisitTupleType(this);

        public TupleTypeSyntax Update(SyntaxToken openParenToken, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<TupleElementSyntax> elements, SyntaxToken closeParenToken)
        {
            if (openParenToken != this.OpenParenToken || elements != this.Elements || closeParenToken != this.CloseParenToken)
            {
                var newNode = SyntaxFactory.TupleType(openParenToken, elements, closeParenToken);
                var diags = GetDiagnostics();
                if (diags?.Length > 0)
                    newNode = newNode.WithDiagnosticsGreen(diags);
                var annotations = GetAnnotations();
                if (annotations?.Length > 0)
                    newNode = newNode.WithAnnotationsGreen(annotations);
                return newNode;
            }

            return this;
        }

        internal override GreenNode SetDiagnostics(DiagnosticInfo[]? diagnostics)
            => new TupleTypeSyntax(this.Kind, this.openParenToken, this.elements, this.closeParenToken, diagnostics, GetAnnotations());

        internal override GreenNode SetAnnotations(SyntaxAnnotation[]? annotations)
            => new TupleTypeSyntax(this.Kind, this.openParenToken, this.elements, this.closeParenToken, GetDiagnostics(), annotations);

        internal TupleTypeSyntax(ObjectReader reader)
          : base(reader)
        {
            this.SlotCount = 3;
            var openParenToken = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(openParenToken);
            this.openParenToken = openParenToken;
            var elements = (GreenNode?)reader.ReadValue();
            if (elements != null)
            {
                AdjustFlagsAndWidth(elements);
                this.elements = elements;
            }
            var closeParenToken = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(closeParenToken);
            this.closeParenToken = closeParenToken;
        }

        internal override void WriteTo(ObjectWriter writer)
        {
            base.WriteTo(writer);
            writer.WriteValue(this.openParenToken);
            writer.WriteValue(this.elements);
            writer.WriteValue(this.closeParenToken);
        }

        static TupleTypeSyntax()
        {
            ObjectBinder.RegisterTypeReader(typeof(TupleTypeSyntax), r => new TupleTypeSyntax(r));
        }
    }

    /// <summary>Tuple type element.</summary>
    internal sealed partial class TupleElementSyntax : CSharpSyntaxNode
    {
        internal readonly TypeSyntax type;
        internal readonly SyntaxToken? identifier;

        internal TupleElementSyntax(SyntaxKind kind, TypeSyntax type, SyntaxToken? identifier, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
            this.SlotCount = 2;
            this.AdjustFlagsAndWidth(type);
            this.type = type;
            if (identifier != null)
            {
                this.AdjustFlagsAndWidth(identifier);
                this.identifier = identifier;
            }
        }

        internal TupleElementSyntax(SyntaxKind kind, TypeSyntax type, SyntaxToken? identifier, SyntaxFactoryContext context)
          : base(kind)
        {
            this.SetFactoryContext(context);
            this.SlotCount = 2;
            this.AdjustFlagsAndWidth(type);
            this.type = type;
            if (identifier != null)
            {
                this.AdjustFlagsAndWidth(identifier);
                this.identifier = identifier;
            }
        }

        internal TupleElementSyntax(SyntaxKind kind, TypeSyntax type, SyntaxToken? identifier)
          : base(kind)
        {
            this.SlotCount = 2;
            this.AdjustFlagsAndWidth(type);
            this.type = type;
            if (identifier != null)
            {
                this.AdjustFlagsAndWidth(identifier);
                this.identifier = identifier;
            }
        }

        /// <summary>Gets the type of the tuple element.</summary>
        public TypeSyntax Type => this.type;
        /// <summary>Gets the name of the tuple element.</summary>
        public SyntaxToken? Identifier => this.identifier;

        internal override GreenNode? GetSlot(int index)
            => index switch
            {
                0 => this.type,
                1 => this.identifier,
                _ => null,
            };

        internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new CSharp.Syntax.TupleElementSyntax(this, parent, position);

        public override void Accept(CSharpSyntaxVisitor visitor) => visitor.VisitTupleElement(this);
        public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor) => visitor.VisitTupleElement(this);

        public TupleElementSyntax Update(TypeSyntax type, SyntaxToken identifier)
        {
            if (type != this.Type || identifier != this.Identifier)
            {
                var newNode = SyntaxFactory.TupleElement(type, identifier);
                var diags = GetDiagnostics();
                if (diags?.Length > 0)
                    newNode = newNode.WithDiagnosticsGreen(diags);
                var annotations = GetAnnotations();
                if (annotations?.Length > 0)
                    newNode = newNode.WithAnnotationsGreen(annotations);
                return newNode;
            }

            return this;
        }

        internal override GreenNode SetDiagnostics(DiagnosticInfo[]? diagnostics)
            => new TupleElementSyntax(this.Kind, this.type, this.identifier, diagnostics, GetAnnotations());

        internal override GreenNode SetAnnotations(SyntaxAnnotation[]? annotations)
            => new TupleElementSyntax(this.Kind, this.type, this.identifier, GetDiagnostics(), annotations);

        internal TupleElementSyntax(ObjectReader reader)
          : base(reader)
        {
            this.SlotCount = 2;
            var type = (TypeSyntax)reader.ReadValue();
            AdjustFlagsAndWidth(type);
            this.type = type;
            var identifier = (SyntaxToken?)reader.ReadValue();
            if (identifier != null)
            {
                AdjustFlagsAndWidth(identifier);
                this.identifier = identifier;
            }
        }

        internal override void WriteTo(ObjectWriter writer)
        {
            base.WriteTo(writer);
            writer.WriteValue(this.type);
            writer.WriteValue(this.identifier);
        }

        static TupleElementSyntax()
        {
            ObjectBinder.RegisterTypeReader(typeof(TupleElementSyntax), r => new TupleElementSyntax(r));
        }
    }

    /// <summary>Class which represents a placeholder in the type argument list of an unbound generic type.</summary>
    internal sealed partial class OmittedTypeArgumentSyntax : TypeSyntax
    {
        internal readonly SyntaxToken omittedTypeArgumentToken;

        internal OmittedTypeArgumentSyntax(SyntaxKind kind, SyntaxToken omittedTypeArgumentToken, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
            this.SlotCount = 1;
            this.AdjustFlagsAndWidth(omittedTypeArgumentToken);
            this.omittedTypeArgumentToken = omittedTypeArgumentToken;
        }

        internal OmittedTypeArgumentSyntax(SyntaxKind kind, SyntaxToken omittedTypeArgumentToken, SyntaxFactoryContext context)
          : base(kind)
        {
            this.SetFactoryContext(context);
            this.SlotCount = 1;
            this.AdjustFlagsAndWidth(omittedTypeArgumentToken);
            this.omittedTypeArgumentToken = omittedTypeArgumentToken;
        }

        internal OmittedTypeArgumentSyntax(SyntaxKind kind, SyntaxToken omittedTypeArgumentToken)
          : base(kind)
        {
            this.SlotCount = 1;
            this.AdjustFlagsAndWidth(omittedTypeArgumentToken);
            this.omittedTypeArgumentToken = omittedTypeArgumentToken;
        }

        /// <summary>SyntaxToken representing the omitted type argument.</summary>
        public SyntaxToken OmittedTypeArgumentToken => this.omittedTypeArgumentToken;

        internal override GreenNode? GetSlot(int index)
            => index == 0 ? this.omittedTypeArgumentToken : null;

        internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new CSharp.Syntax.OmittedTypeArgumentSyntax(this, parent, position);

        public override void Accept(CSharpSyntaxVisitor visitor) => visitor.VisitOmittedTypeArgument(this);
        public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor) => visitor.VisitOmittedTypeArgument(this);

        public OmittedTypeArgumentSyntax Update(SyntaxToken omittedTypeArgumentToken)
        {
            if (omittedTypeArgumentToken != this.OmittedTypeArgumentToken)
            {
                var newNode = SyntaxFactory.OmittedTypeArgument(omittedTypeArgumentToken);
                var diags = GetDiagnostics();
                if (diags?.Length > 0)
                    newNode = newNode.WithDiagnosticsGreen(diags);
                var annotations = GetAnnotations();
                if (annotations?.Length > 0)
                    newNode = newNode.WithAnnotationsGreen(annotations);
                return newNode;
            }

            return this;
        }

        internal override GreenNode SetDiagnostics(DiagnosticInfo[]? diagnostics)
            => new OmittedTypeArgumentSyntax(this.Kind, this.omittedTypeArgumentToken, diagnostics, GetAnnotations());

        internal override GreenNode SetAnnotations(SyntaxAnnotation[]? annotations)
            => new OmittedTypeArgumentSyntax(this.Kind, this.omittedTypeArgumentToken, GetDiagnostics(), annotations);

        internal OmittedTypeArgumentSyntax(ObjectReader reader)
          : base(reader)
        {
            this.SlotCount = 1;
            var omittedTypeArgumentToken = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(omittedTypeArgumentToken);
            this.omittedTypeArgumentToken = omittedTypeArgumentToken;
        }

        internal override void WriteTo(ObjectWriter writer)
        {
            base.WriteTo(writer);
            writer.WriteValue(this.omittedTypeArgumentToken);
        }

        static OmittedTypeArgumentSyntax()
        {
            ObjectBinder.RegisterTypeReader(typeof(OmittedTypeArgumentSyntax), r => new OmittedTypeArgumentSyntax(r));
        }
    }

    /// <summary>The ref modifier of a method's return value or a local.</summary>
    internal sealed partial class RefTypeSyntax : TypeSyntax
    {
        internal readonly SyntaxToken refKeyword;
        internal readonly SyntaxToken? readOnlyKeyword;
        internal readonly TypeSyntax type;

        internal RefTypeSyntax(SyntaxKind kind, SyntaxToken refKeyword, SyntaxToken? readOnlyKeyword, TypeSyntax type, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
            this.SlotCount = 3;
            this.AdjustFlagsAndWidth(refKeyword);
            this.refKeyword = refKeyword;
            if (readOnlyKeyword != null)
            {
                this.AdjustFlagsAndWidth(readOnlyKeyword);
                this.readOnlyKeyword = readOnlyKeyword;
            }
            this.AdjustFlagsAndWidth(type);
            this.type = type;
        }

        internal RefTypeSyntax(SyntaxKind kind, SyntaxToken refKeyword, SyntaxToken? readOnlyKeyword, TypeSyntax type, SyntaxFactoryContext context)
          : base(kind)
        {
            this.SetFactoryContext(context);
            this.SlotCount = 3;
            this.AdjustFlagsAndWidth(refKeyword);
            this.refKeyword = refKeyword;
            if (readOnlyKeyword != null)
            {
                this.AdjustFlagsAndWidth(readOnlyKeyword);
                this.readOnlyKeyword = readOnlyKeyword;
            }
            this.AdjustFlagsAndWidth(type);
            this.type = type;
        }

        internal RefTypeSyntax(SyntaxKind kind, SyntaxToken refKeyword, SyntaxToken? readOnlyKeyword, TypeSyntax type)
          : base(kind)
        {
            this.SlotCount = 3;
            this.AdjustFlagsAndWidth(refKeyword);
            this.refKeyword = refKeyword;
            if (readOnlyKeyword != null)
            {
                this.AdjustFlagsAndWidth(readOnlyKeyword);
                this.readOnlyKeyword = readOnlyKeyword;
            }
            this.AdjustFlagsAndWidth(type);
            this.type = type;
        }

        public SyntaxToken RefKeyword => this.refKeyword;
        /// <summary>Gets the optional "readonly" keyword.</summary>
        public SyntaxToken? ReadOnlyKeyword => this.readOnlyKeyword;
        public TypeSyntax Type => this.type;

        internal override GreenNode? GetSlot(int index)
            => index switch
            {
                0 => this.refKeyword,
                1 => this.readOnlyKeyword,
                2 => this.type,
                _ => null,
            };

        internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new CSharp.Syntax.RefTypeSyntax(this, parent, position);

        public override void Accept(CSharpSyntaxVisitor visitor) => visitor.VisitRefType(this);
        public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor) => visitor.VisitRefType(this);

        public RefTypeSyntax Update(SyntaxToken refKeyword, SyntaxToken readOnlyKeyword, TypeSyntax type)
        {
            if (refKeyword != this.RefKeyword || readOnlyKeyword != this.ReadOnlyKeyword || type != this.Type)
            {
                var newNode = SyntaxFactory.RefType(refKeyword, readOnlyKeyword, type);
                var diags = GetDiagnostics();
                if (diags?.Length > 0)
                    newNode = newNode.WithDiagnosticsGreen(diags);
                var annotations = GetAnnotations();
                if (annotations?.Length > 0)
                    newNode = newNode.WithAnnotationsGreen(annotations);
                return newNode;
            }

            return this;
        }

        internal override GreenNode SetDiagnostics(DiagnosticInfo[]? diagnostics)
            => new RefTypeSyntax(this.Kind, this.refKeyword, this.readOnlyKeyword, this.type, diagnostics, GetAnnotations());

        internal override GreenNode SetAnnotations(SyntaxAnnotation[]? annotations)
            => new RefTypeSyntax(this.Kind, this.refKeyword, this.readOnlyKeyword, this.type, GetDiagnostics(), annotations);

        internal RefTypeSyntax(ObjectReader reader)
          : base(reader)
        {
            this.SlotCount = 3;
            var refKeyword = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(refKeyword);
            this.refKeyword = refKeyword;
            var readOnlyKeyword = (SyntaxToken?)reader.ReadValue();
            if (readOnlyKeyword != null)
            {
                AdjustFlagsAndWidth(readOnlyKeyword);
                this.readOnlyKeyword = readOnlyKeyword;
            }
            var type = (TypeSyntax)reader.ReadValue();
            AdjustFlagsAndWidth(type);
            this.type = type;
        }

        internal override void WriteTo(ObjectWriter writer)
        {
            base.WriteTo(writer);
            writer.WriteValue(this.refKeyword);
            writer.WriteValue(this.readOnlyKeyword);
            writer.WriteValue(this.type);
        }

        static RefTypeSyntax()
        {
            ObjectBinder.RegisterTypeReader(typeof(RefTypeSyntax), r => new RefTypeSyntax(r));
        }
    }

    internal abstract partial class ExpressionOrPatternSyntax : CSharpSyntaxNode
    {
        internal ExpressionOrPatternSyntax(SyntaxKind kind, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
        }

        internal ExpressionOrPatternSyntax(SyntaxKind kind)
          : base(kind)
        {
        }

        protected ExpressionOrPatternSyntax(ObjectReader reader)
          : base(reader)
        {
        }
    }

    /// <summary>Provides the base class from which the classes that represent expression syntax nodes are derived. This is an abstract class.</summary>
    internal abstract partial class ExpressionSyntax : ExpressionOrPatternSyntax
    {
        internal ExpressionSyntax(SyntaxKind kind, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
        }

        internal ExpressionSyntax(SyntaxKind kind)
          : base(kind)
        {
        }

        protected ExpressionSyntax(ObjectReader reader)
          : base(reader)
        {
        }
    }

    /// <summary>Class which represents the syntax node for parenthesized expression.</summary>
    internal sealed partial class ParenthesizedExpressionSyntax : ExpressionSyntax
    {
        internal readonly SyntaxToken openParenToken;
        internal readonly ExpressionSyntax expression;
        internal readonly SyntaxToken closeParenToken;

        internal ParenthesizedExpressionSyntax(SyntaxKind kind, SyntaxToken openParenToken, ExpressionSyntax expression, SyntaxToken closeParenToken, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
            this.SlotCount = 3;
            this.AdjustFlagsAndWidth(openParenToken);
            this.openParenToken = openParenToken;
            this.AdjustFlagsAndWidth(expression);
            this.expression = expression;
            this.AdjustFlagsAndWidth(closeParenToken);
            this.closeParenToken = closeParenToken;
        }

        internal ParenthesizedExpressionSyntax(SyntaxKind kind, SyntaxToken openParenToken, ExpressionSyntax expression, SyntaxToken closeParenToken, SyntaxFactoryContext context)
          : base(kind)
        {
            this.SetFactoryContext(context);
            this.SlotCount = 3;
            this.AdjustFlagsAndWidth(openParenToken);
            this.openParenToken = openParenToken;
            this.AdjustFlagsAndWidth(expression);
            this.expression = expression;
            this.AdjustFlagsAndWidth(closeParenToken);
            this.closeParenToken = closeParenToken;
        }

        internal ParenthesizedExpressionSyntax(SyntaxKind kind, SyntaxToken openParenToken, ExpressionSyntax expression, SyntaxToken closeParenToken)
          : base(kind)
        {
            this.SlotCount = 3;
            this.AdjustFlagsAndWidth(openParenToken);
            this.openParenToken = openParenToken;
            this.AdjustFlagsAndWidth(expression);
            this.expression = expression;
            this.AdjustFlagsAndWidth(closeParenToken);
            this.closeParenToken = closeParenToken;
        }

        /// <summary>SyntaxToken representing the open parenthesis.</summary>
        public SyntaxToken OpenParenToken => this.openParenToken;
        /// <summary>ExpressionSyntax node representing the expression enclosed within the parenthesis.</summary>
        public ExpressionSyntax Expression => this.expression;
        /// <summary>SyntaxToken representing the close parenthesis.</summary>
        public SyntaxToken CloseParenToken => this.closeParenToken;

        internal override GreenNode? GetSlot(int index)
            => index switch
            {
                0 => this.openParenToken,
                1 => this.expression,
                2 => this.closeParenToken,
                _ => null,
            };

        internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new CSharp.Syntax.ParenthesizedExpressionSyntax(this, parent, position);

        public override void Accept(CSharpSyntaxVisitor visitor) => visitor.VisitParenthesizedExpression(this);
        public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor) => visitor.VisitParenthesizedExpression(this);

        public ParenthesizedExpressionSyntax Update(SyntaxToken openParenToken, ExpressionSyntax expression, SyntaxToken closeParenToken)
        {
            if (openParenToken != this.OpenParenToken || expression != this.Expression || closeParenToken != this.CloseParenToken)
            {
                var newNode = SyntaxFactory.ParenthesizedExpression(openParenToken, expression, closeParenToken);
                var diags = GetDiagnostics();
                if (diags?.Length > 0)
                    newNode = newNode.WithDiagnosticsGreen(diags);
                var annotations = GetAnnotations();
                if (annotations?.Length > 0)
                    newNode = newNode.WithAnnotationsGreen(annotations);
                return newNode;
            }

            return this;
        }

        internal override GreenNode SetDiagnostics(DiagnosticInfo[]? diagnostics)
            => new ParenthesizedExpressionSyntax(this.Kind, this.openParenToken, this.expression, this.closeParenToken, diagnostics, GetAnnotations());

        internal override GreenNode SetAnnotations(SyntaxAnnotation[]? annotations)
            => new ParenthesizedExpressionSyntax(this.Kind, this.openParenToken, this.expression, this.closeParenToken, GetDiagnostics(), annotations);

        internal ParenthesizedExpressionSyntax(ObjectReader reader)
          : base(reader)
        {
            this.SlotCount = 3;
            var openParenToken = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(openParenToken);
            this.openParenToken = openParenToken;
            var expression = (ExpressionSyntax)reader.ReadValue();
            AdjustFlagsAndWidth(expression);
            this.expression = expression;
            var closeParenToken = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(closeParenToken);
            this.closeParenToken = closeParenToken;
        }

        internal override void WriteTo(ObjectWriter writer)
        {
            base.WriteTo(writer);
            writer.WriteValue(this.openParenToken);
            writer.WriteValue(this.expression);
            writer.WriteValue(this.closeParenToken);
        }

        static ParenthesizedExpressionSyntax()
        {
            ObjectBinder.RegisterTypeReader(typeof(ParenthesizedExpressionSyntax), r => new ParenthesizedExpressionSyntax(r));
        }
    }

    /// <summary>Class which represents the syntax node for tuple expression.</summary>
    internal sealed partial class TupleExpressionSyntax : ExpressionSyntax
    {
        internal readonly SyntaxToken openParenToken;
        internal readonly GreenNode? arguments;
        internal readonly SyntaxToken closeParenToken;

        internal TupleExpressionSyntax(SyntaxKind kind, SyntaxToken openParenToken, GreenNode? arguments, SyntaxToken closeParenToken, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
            this.SlotCount = 3;
            this.AdjustFlagsAndWidth(openParenToken);
            this.openParenToken = openParenToken;
            if (arguments != null)
            {
                this.AdjustFlagsAndWidth(arguments);
                this.arguments = arguments;
            }
            this.AdjustFlagsAndWidth(closeParenToken);
            this.closeParenToken = closeParenToken;
        }

        internal TupleExpressionSyntax(SyntaxKind kind, SyntaxToken openParenToken, GreenNode? arguments, SyntaxToken closeParenToken, SyntaxFactoryContext context)
          : base(kind)
        {
            this.SetFactoryContext(context);
            this.SlotCount = 3;
            this.AdjustFlagsAndWidth(openParenToken);
            this.openParenToken = openParenToken;
            if (arguments != null)
            {
                this.AdjustFlagsAndWidth(arguments);
                this.arguments = arguments;
            }
            this.AdjustFlagsAndWidth(closeParenToken);
            this.closeParenToken = closeParenToken;
        }

        internal TupleExpressionSyntax(SyntaxKind kind, SyntaxToken openParenToken, GreenNode? arguments, SyntaxToken closeParenToken)
          : base(kind)
        {
            this.SlotCount = 3;
            this.AdjustFlagsAndWidth(openParenToken);
            this.openParenToken = openParenToken;
            if (arguments != null)
            {
                this.AdjustFlagsAndWidth(arguments);
                this.arguments = arguments;
            }
            this.AdjustFlagsAndWidth(closeParenToken);
            this.closeParenToken = closeParenToken;
        }

        /// <summary>SyntaxToken representing the open parenthesis.</summary>
        public SyntaxToken OpenParenToken => this.openParenToken;
        /// <summary>SeparatedSyntaxList of ArgumentSyntax representing the list of arguments.</summary>
        public Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<ArgumentSyntax> Arguments => new Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<ArgumentSyntax>(new Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<CSharpSyntaxNode>(this.arguments));
        /// <summary>SyntaxToken representing the close parenthesis.</summary>
        public SyntaxToken CloseParenToken => this.closeParenToken;

        internal override GreenNode? GetSlot(int index)
            => index switch
            {
                0 => this.openParenToken,
                1 => this.arguments,
                2 => this.closeParenToken,
                _ => null,
            };

        internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new CSharp.Syntax.TupleExpressionSyntax(this, parent, position);

        public override void Accept(CSharpSyntaxVisitor visitor) => visitor.VisitTupleExpression(this);
        public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor) => visitor.VisitTupleExpression(this);

        public TupleExpressionSyntax Update(SyntaxToken openParenToken, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<ArgumentSyntax> arguments, SyntaxToken closeParenToken)
        {
            if (openParenToken != this.OpenParenToken || arguments != this.Arguments || closeParenToken != this.CloseParenToken)
            {
                var newNode = SyntaxFactory.TupleExpression(openParenToken, arguments, closeParenToken);
                var diags = GetDiagnostics();
                if (diags?.Length > 0)
                    newNode = newNode.WithDiagnosticsGreen(diags);
                var annotations = GetAnnotations();
                if (annotations?.Length > 0)
                    newNode = newNode.WithAnnotationsGreen(annotations);
                return newNode;
            }

            return this;
        }

        internal override GreenNode SetDiagnostics(DiagnosticInfo[]? diagnostics)
            => new TupleExpressionSyntax(this.Kind, this.openParenToken, this.arguments, this.closeParenToken, diagnostics, GetAnnotations());

        internal override GreenNode SetAnnotations(SyntaxAnnotation[]? annotations)
            => new TupleExpressionSyntax(this.Kind, this.openParenToken, this.arguments, this.closeParenToken, GetDiagnostics(), annotations);

        internal TupleExpressionSyntax(ObjectReader reader)
          : base(reader)
        {
            this.SlotCount = 3;
            var openParenToken = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(openParenToken);
            this.openParenToken = openParenToken;
            var arguments = (GreenNode?)reader.ReadValue();
            if (arguments != null)
            {
                AdjustFlagsAndWidth(arguments);
                this.arguments = arguments;
            }
            var closeParenToken = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(closeParenToken);
            this.closeParenToken = closeParenToken;
        }

        internal override void WriteTo(ObjectWriter writer)
        {
            base.WriteTo(writer);
            writer.WriteValue(this.openParenToken);
            writer.WriteValue(this.arguments);
            writer.WriteValue(this.closeParenToken);
        }

        static TupleExpressionSyntax()
        {
            ObjectBinder.RegisterTypeReader(typeof(TupleExpressionSyntax), r => new TupleExpressionSyntax(r));
        }
    }

    /// <summary>Class which represents the syntax node for prefix unary expression.</summary>
    internal sealed partial class PrefixUnaryExpressionSyntax : ExpressionSyntax
    {
        internal readonly SyntaxToken operatorToken;
        internal readonly ExpressionSyntax operand;

        internal PrefixUnaryExpressionSyntax(SyntaxKind kind, SyntaxToken operatorToken, ExpressionSyntax operand, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
            this.SlotCount = 2;
            this.AdjustFlagsAndWidth(operatorToken);
            this.operatorToken = operatorToken;
            this.AdjustFlagsAndWidth(operand);
            this.operand = operand;
        }

        internal PrefixUnaryExpressionSyntax(SyntaxKind kind, SyntaxToken operatorToken, ExpressionSyntax operand, SyntaxFactoryContext context)
          : base(kind)
        {
            this.SetFactoryContext(context);
            this.SlotCount = 2;
            this.AdjustFlagsAndWidth(operatorToken);
            this.operatorToken = operatorToken;
            this.AdjustFlagsAndWidth(operand);
            this.operand = operand;
        }

        internal PrefixUnaryExpressionSyntax(SyntaxKind kind, SyntaxToken operatorToken, ExpressionSyntax operand)
          : base(kind)
        {
            this.SlotCount = 2;
            this.AdjustFlagsAndWidth(operatorToken);
            this.operatorToken = operatorToken;
            this.AdjustFlagsAndWidth(operand);
            this.operand = operand;
        }

        /// <summary>SyntaxToken representing the kind of the operator of the prefix unary expression.</summary>
        public SyntaxToken OperatorToken => this.operatorToken;
        /// <summary>ExpressionSyntax representing the operand of the prefix unary expression.</summary>
        public ExpressionSyntax Operand => this.operand;

        internal override GreenNode? GetSlot(int index)
            => index switch
            {
                0 => this.operatorToken,
                1 => this.operand,
                _ => null,
            };

        internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new CSharp.Syntax.PrefixUnaryExpressionSyntax(this, parent, position);

        public override void Accept(CSharpSyntaxVisitor visitor) => visitor.VisitPrefixUnaryExpression(this);
        public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor) => visitor.VisitPrefixUnaryExpression(this);

        public PrefixUnaryExpressionSyntax Update(SyntaxToken operatorToken, ExpressionSyntax operand)
        {
            if (operatorToken != this.OperatorToken || operand != this.Operand)
            {
                var newNode = SyntaxFactory.PrefixUnaryExpression(this.Kind, operatorToken, operand);
                var diags = GetDiagnostics();
                if (diags?.Length > 0)
                    newNode = newNode.WithDiagnosticsGreen(diags);
                var annotations = GetAnnotations();
                if (annotations?.Length > 0)
                    newNode = newNode.WithAnnotationsGreen(annotations);
                return newNode;
            }

            return this;
        }

        internal override GreenNode SetDiagnostics(DiagnosticInfo[]? diagnostics)
            => new PrefixUnaryExpressionSyntax(this.Kind, this.operatorToken, this.operand, diagnostics, GetAnnotations());

        internal override GreenNode SetAnnotations(SyntaxAnnotation[]? annotations)
            => new PrefixUnaryExpressionSyntax(this.Kind, this.operatorToken, this.operand, GetDiagnostics(), annotations);

        internal PrefixUnaryExpressionSyntax(ObjectReader reader)
          : base(reader)
        {
            this.SlotCount = 2;
            var operatorToken = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(operatorToken);
            this.operatorToken = operatorToken;
            var operand = (ExpressionSyntax)reader.ReadValue();
            AdjustFlagsAndWidth(operand);
            this.operand = operand;
        }

        internal override void WriteTo(ObjectWriter writer)
        {
            base.WriteTo(writer);
            writer.WriteValue(this.operatorToken);
            writer.WriteValue(this.operand);
        }

        static PrefixUnaryExpressionSyntax()
        {
            ObjectBinder.RegisterTypeReader(typeof(PrefixUnaryExpressionSyntax), r => new PrefixUnaryExpressionSyntax(r));
        }
    }

    /// <summary>Class which represents the syntax node for an "await" expression.</summary>
    internal sealed partial class AwaitExpressionSyntax : ExpressionSyntax
    {
        internal readonly SyntaxToken awaitKeyword;
        internal readonly ExpressionSyntax expression;

        internal AwaitExpressionSyntax(SyntaxKind kind, SyntaxToken awaitKeyword, ExpressionSyntax expression, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
            this.SlotCount = 2;
            this.AdjustFlagsAndWidth(awaitKeyword);
            this.awaitKeyword = awaitKeyword;
            this.AdjustFlagsAndWidth(expression);
            this.expression = expression;
        }

        internal AwaitExpressionSyntax(SyntaxKind kind, SyntaxToken awaitKeyword, ExpressionSyntax expression, SyntaxFactoryContext context)
          : base(kind)
        {
            this.SetFactoryContext(context);
            this.SlotCount = 2;
            this.AdjustFlagsAndWidth(awaitKeyword);
            this.awaitKeyword = awaitKeyword;
            this.AdjustFlagsAndWidth(expression);
            this.expression = expression;
        }

        internal AwaitExpressionSyntax(SyntaxKind kind, SyntaxToken awaitKeyword, ExpressionSyntax expression)
          : base(kind)
        {
            this.SlotCount = 2;
            this.AdjustFlagsAndWidth(awaitKeyword);
            this.awaitKeyword = awaitKeyword;
            this.AdjustFlagsAndWidth(expression);
            this.expression = expression;
        }

        /// <summary>SyntaxToken representing the kind "await" keyword.</summary>
        public SyntaxToken AwaitKeyword => this.awaitKeyword;
        /// <summary>ExpressionSyntax representing the operand of the "await" operator.</summary>
        public ExpressionSyntax Expression => this.expression;

        internal override GreenNode? GetSlot(int index)
            => index switch
            {
                0 => this.awaitKeyword,
                1 => this.expression,
                _ => null,
            };

        internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new CSharp.Syntax.AwaitExpressionSyntax(this, parent, position);

        public override void Accept(CSharpSyntaxVisitor visitor) => visitor.VisitAwaitExpression(this);
        public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor) => visitor.VisitAwaitExpression(this);

        public AwaitExpressionSyntax Update(SyntaxToken awaitKeyword, ExpressionSyntax expression)
        {
            if (awaitKeyword != this.AwaitKeyword || expression != this.Expression)
            {
                var newNode = SyntaxFactory.AwaitExpression(awaitKeyword, expression);
                var diags = GetDiagnostics();
                if (diags?.Length > 0)
                    newNode = newNode.WithDiagnosticsGreen(diags);
                var annotations = GetAnnotations();
                if (annotations?.Length > 0)
                    newNode = newNode.WithAnnotationsGreen(annotations);
                return newNode;
            }

            return this;
        }

        internal override GreenNode SetDiagnostics(DiagnosticInfo[]? diagnostics)
            => new AwaitExpressionSyntax(this.Kind, this.awaitKeyword, this.expression, diagnostics, GetAnnotations());

        internal override GreenNode SetAnnotations(SyntaxAnnotation[]? annotations)
            => new AwaitExpressionSyntax(this.Kind, this.awaitKeyword, this.expression, GetDiagnostics(), annotations);

        internal AwaitExpressionSyntax(ObjectReader reader)
          : base(reader)
        {
            this.SlotCount = 2;
            var awaitKeyword = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(awaitKeyword);
            this.awaitKeyword = awaitKeyword;
            var expression = (ExpressionSyntax)reader.ReadValue();
            AdjustFlagsAndWidth(expression);
            this.expression = expression;
        }

        internal override void WriteTo(ObjectWriter writer)
        {
            base.WriteTo(writer);
            writer.WriteValue(this.awaitKeyword);
            writer.WriteValue(this.expression);
        }

        static AwaitExpressionSyntax()
        {
            ObjectBinder.RegisterTypeReader(typeof(AwaitExpressionSyntax), r => new AwaitExpressionSyntax(r));
        }
    }

    /// <summary>Class which represents the syntax node for postfix unary expression.</summary>
    internal sealed partial class PostfixUnaryExpressionSyntax : ExpressionSyntax
    {
        internal readonly ExpressionSyntax operand;
        internal readonly SyntaxToken operatorToken;

        internal PostfixUnaryExpressionSyntax(SyntaxKind kind, ExpressionSyntax operand, SyntaxToken operatorToken, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
            this.SlotCount = 2;
            this.AdjustFlagsAndWidth(operand);
            this.operand = operand;
            this.AdjustFlagsAndWidth(operatorToken);
            this.operatorToken = operatorToken;
        }

        internal PostfixUnaryExpressionSyntax(SyntaxKind kind, ExpressionSyntax operand, SyntaxToken operatorToken, SyntaxFactoryContext context)
          : base(kind)
        {
            this.SetFactoryContext(context);
            this.SlotCount = 2;
            this.AdjustFlagsAndWidth(operand);
            this.operand = operand;
            this.AdjustFlagsAndWidth(operatorToken);
            this.operatorToken = operatorToken;
        }

        internal PostfixUnaryExpressionSyntax(SyntaxKind kind, ExpressionSyntax operand, SyntaxToken operatorToken)
          : base(kind)
        {
            this.SlotCount = 2;
            this.AdjustFlagsAndWidth(operand);
            this.operand = operand;
            this.AdjustFlagsAndWidth(operatorToken);
            this.operatorToken = operatorToken;
        }

        /// <summary>ExpressionSyntax representing the operand of the postfix unary expression.</summary>
        public ExpressionSyntax Operand => this.operand;
        /// <summary>SyntaxToken representing the kind of the operator of the postfix unary expression.</summary>
        public SyntaxToken OperatorToken => this.operatorToken;

        internal override GreenNode? GetSlot(int index)
            => index switch
            {
                0 => this.operand,
                1 => this.operatorToken,
                _ => null,
            };

        internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new CSharp.Syntax.PostfixUnaryExpressionSyntax(this, parent, position);

        public override void Accept(CSharpSyntaxVisitor visitor) => visitor.VisitPostfixUnaryExpression(this);
        public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor) => visitor.VisitPostfixUnaryExpression(this);

        public PostfixUnaryExpressionSyntax Update(ExpressionSyntax operand, SyntaxToken operatorToken)
        {
            if (operand != this.Operand || operatorToken != this.OperatorToken)
            {
                var newNode = SyntaxFactory.PostfixUnaryExpression(this.Kind, operand, operatorToken);
                var diags = GetDiagnostics();
                if (diags?.Length > 0)
                    newNode = newNode.WithDiagnosticsGreen(diags);
                var annotations = GetAnnotations();
                if (annotations?.Length > 0)
                    newNode = newNode.WithAnnotationsGreen(annotations);
                return newNode;
            }

            return this;
        }

        internal override GreenNode SetDiagnostics(DiagnosticInfo[]? diagnostics)
            => new PostfixUnaryExpressionSyntax(this.Kind, this.operand, this.operatorToken, diagnostics, GetAnnotations());

        internal override GreenNode SetAnnotations(SyntaxAnnotation[]? annotations)
            => new PostfixUnaryExpressionSyntax(this.Kind, this.operand, this.operatorToken, GetDiagnostics(), annotations);

        internal PostfixUnaryExpressionSyntax(ObjectReader reader)
          : base(reader)
        {
            this.SlotCount = 2;
            var operand = (ExpressionSyntax)reader.ReadValue();
            AdjustFlagsAndWidth(operand);
            this.operand = operand;
            var operatorToken = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(operatorToken);
            this.operatorToken = operatorToken;
        }

        internal override void WriteTo(ObjectWriter writer)
        {
            base.WriteTo(writer);
            writer.WriteValue(this.operand);
            writer.WriteValue(this.operatorToken);
        }

        static PostfixUnaryExpressionSyntax()
        {
            ObjectBinder.RegisterTypeReader(typeof(PostfixUnaryExpressionSyntax), r => new PostfixUnaryExpressionSyntax(r));
        }
    }

    /// <summary>Class which represents the syntax node for member access expression.</summary>
    internal sealed partial class MemberAccessExpressionSyntax : ExpressionSyntax
    {
        internal readonly ExpressionSyntax expression;
        internal readonly SyntaxToken operatorToken;
        internal readonly SimpleNameSyntax name;

        internal MemberAccessExpressionSyntax(SyntaxKind kind, ExpressionSyntax expression, SyntaxToken operatorToken, SimpleNameSyntax name, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
            this.SlotCount = 3;
            this.AdjustFlagsAndWidth(expression);
            this.expression = expression;
            this.AdjustFlagsAndWidth(operatorToken);
            this.operatorToken = operatorToken;
            this.AdjustFlagsAndWidth(name);
            this.name = name;
        }

        internal MemberAccessExpressionSyntax(SyntaxKind kind, ExpressionSyntax expression, SyntaxToken operatorToken, SimpleNameSyntax name, SyntaxFactoryContext context)
          : base(kind)
        {
            this.SetFactoryContext(context);
            this.SlotCount = 3;
            this.AdjustFlagsAndWidth(expression);
            this.expression = expression;
            this.AdjustFlagsAndWidth(operatorToken);
            this.operatorToken = operatorToken;
            this.AdjustFlagsAndWidth(name);
            this.name = name;
        }

        internal MemberAccessExpressionSyntax(SyntaxKind kind, ExpressionSyntax expression, SyntaxToken operatorToken, SimpleNameSyntax name)
          : base(kind)
        {
            this.SlotCount = 3;
            this.AdjustFlagsAndWidth(expression);
            this.expression = expression;
            this.AdjustFlagsAndWidth(operatorToken);
            this.operatorToken = operatorToken;
            this.AdjustFlagsAndWidth(name);
            this.name = name;
        }

        /// <summary>ExpressionSyntax node representing the object that the member belongs to.</summary>
        public ExpressionSyntax Expression => this.expression;
        /// <summary>SyntaxToken representing the kind of the operator in the member access expression.</summary>
        public SyntaxToken OperatorToken => this.operatorToken;
        /// <summary>SimpleNameSyntax node representing the member being accessed.</summary>
        public SimpleNameSyntax Name => this.name;

        internal override GreenNode? GetSlot(int index)
            => index switch
            {
                0 => this.expression,
                1 => this.operatorToken,
                2 => this.name,
                _ => null,
            };

        internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new CSharp.Syntax.MemberAccessExpressionSyntax(this, parent, position);

        public override void Accept(CSharpSyntaxVisitor visitor) => visitor.VisitMemberAccessExpression(this);
        public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor) => visitor.VisitMemberAccessExpression(this);

        public MemberAccessExpressionSyntax Update(ExpressionSyntax expression, SyntaxToken operatorToken, SimpleNameSyntax name)
        {
            if (expression != this.Expression || operatorToken != this.OperatorToken || name != this.Name)
            {
                var newNode = SyntaxFactory.MemberAccessExpression(this.Kind, expression, operatorToken, name);
                var diags = GetDiagnostics();
                if (diags?.Length > 0)
                    newNode = newNode.WithDiagnosticsGreen(diags);
                var annotations = GetAnnotations();
                if (annotations?.Length > 0)
                    newNode = newNode.WithAnnotationsGreen(annotations);
                return newNode;
            }

            return this;
        }

        internal override GreenNode SetDiagnostics(DiagnosticInfo[]? diagnostics)
            => new MemberAccessExpressionSyntax(this.Kind, this.expression, this.operatorToken, this.name, diagnostics, GetAnnotations());

        internal override GreenNode SetAnnotations(SyntaxAnnotation[]? annotations)
            => new MemberAccessExpressionSyntax(this.Kind, this.expression, this.operatorToken, this.name, GetDiagnostics(), annotations);

        internal MemberAccessExpressionSyntax(ObjectReader reader)
          : base(reader)
        {
            this.SlotCount = 3;
            var expression = (ExpressionSyntax)reader.ReadValue();
            AdjustFlagsAndWidth(expression);
            this.expression = expression;
            var operatorToken = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(operatorToken);
            this.operatorToken = operatorToken;
            var name = (SimpleNameSyntax)reader.ReadValue();
            AdjustFlagsAndWidth(name);
            this.name = name;
        }

        internal override void WriteTo(ObjectWriter writer)
        {
            base.WriteTo(writer);
            writer.WriteValue(this.expression);
            writer.WriteValue(this.operatorToken);
            writer.WriteValue(this.name);
        }

        static MemberAccessExpressionSyntax()
        {
            ObjectBinder.RegisterTypeReader(typeof(MemberAccessExpressionSyntax), r => new MemberAccessExpressionSyntax(r));
        }
    }

    /// <summary>Class which represents the syntax node for conditional access expression.</summary>
    internal sealed partial class ConditionalAccessExpressionSyntax : ExpressionSyntax
    {
        internal readonly ExpressionSyntax expression;
        internal readonly SyntaxToken operatorToken;
        internal readonly ExpressionSyntax whenNotNull;

        internal ConditionalAccessExpressionSyntax(SyntaxKind kind, ExpressionSyntax expression, SyntaxToken operatorToken, ExpressionSyntax whenNotNull, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
            this.SlotCount = 3;
            this.AdjustFlagsAndWidth(expression);
            this.expression = expression;
            this.AdjustFlagsAndWidth(operatorToken);
            this.operatorToken = operatorToken;
            this.AdjustFlagsAndWidth(whenNotNull);
            this.whenNotNull = whenNotNull;
        }

        internal ConditionalAccessExpressionSyntax(SyntaxKind kind, ExpressionSyntax expression, SyntaxToken operatorToken, ExpressionSyntax whenNotNull, SyntaxFactoryContext context)
          : base(kind)
        {
            this.SetFactoryContext(context);
            this.SlotCount = 3;
            this.AdjustFlagsAndWidth(expression);
            this.expression = expression;
            this.AdjustFlagsAndWidth(operatorToken);
            this.operatorToken = operatorToken;
            this.AdjustFlagsAndWidth(whenNotNull);
            this.whenNotNull = whenNotNull;
        }

        internal ConditionalAccessExpressionSyntax(SyntaxKind kind, ExpressionSyntax expression, SyntaxToken operatorToken, ExpressionSyntax whenNotNull)
          : base(kind)
        {
            this.SlotCount = 3;
            this.AdjustFlagsAndWidth(expression);
            this.expression = expression;
            this.AdjustFlagsAndWidth(operatorToken);
            this.operatorToken = operatorToken;
            this.AdjustFlagsAndWidth(whenNotNull);
            this.whenNotNull = whenNotNull;
        }

        /// <summary>ExpressionSyntax node representing the object conditionally accessed.</summary>
        public ExpressionSyntax Expression => this.expression;
        /// <summary>SyntaxToken representing the question mark.</summary>
        public SyntaxToken OperatorToken => this.operatorToken;
        /// <summary>ExpressionSyntax node representing the access expression to be executed when the object is not null.</summary>
        public ExpressionSyntax WhenNotNull => this.whenNotNull;

        internal override GreenNode? GetSlot(int index)
            => index switch
            {
                0 => this.expression,
                1 => this.operatorToken,
                2 => this.whenNotNull,
                _ => null,
            };

        internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new CSharp.Syntax.ConditionalAccessExpressionSyntax(this, parent, position);

        public override void Accept(CSharpSyntaxVisitor visitor) => visitor.VisitConditionalAccessExpression(this);
        public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor) => visitor.VisitConditionalAccessExpression(this);

        public ConditionalAccessExpressionSyntax Update(ExpressionSyntax expression, SyntaxToken operatorToken, ExpressionSyntax whenNotNull)
        {
            if (expression != this.Expression || operatorToken != this.OperatorToken || whenNotNull != this.WhenNotNull)
            {
                var newNode = SyntaxFactory.ConditionalAccessExpression(expression, operatorToken, whenNotNull);
                var diags = GetDiagnostics();
                if (diags?.Length > 0)
                    newNode = newNode.WithDiagnosticsGreen(diags);
                var annotations = GetAnnotations();
                if (annotations?.Length > 0)
                    newNode = newNode.WithAnnotationsGreen(annotations);
                return newNode;
            }

            return this;
        }

        internal override GreenNode SetDiagnostics(DiagnosticInfo[]? diagnostics)
            => new ConditionalAccessExpressionSyntax(this.Kind, this.expression, this.operatorToken, this.whenNotNull, diagnostics, GetAnnotations());

        internal override GreenNode SetAnnotations(SyntaxAnnotation[]? annotations)
            => new ConditionalAccessExpressionSyntax(this.Kind, this.expression, this.operatorToken, this.whenNotNull, GetDiagnostics(), annotations);

        internal ConditionalAccessExpressionSyntax(ObjectReader reader)
          : base(reader)
        {
            this.SlotCount = 3;
            var expression = (ExpressionSyntax)reader.ReadValue();
            AdjustFlagsAndWidth(expression);
            this.expression = expression;
            var operatorToken = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(operatorToken);
            this.operatorToken = operatorToken;
            var whenNotNull = (ExpressionSyntax)reader.ReadValue();
            AdjustFlagsAndWidth(whenNotNull);
            this.whenNotNull = whenNotNull;
        }

        internal override void WriteTo(ObjectWriter writer)
        {
            base.WriteTo(writer);
            writer.WriteValue(this.expression);
            writer.WriteValue(this.operatorToken);
            writer.WriteValue(this.whenNotNull);
        }

        static ConditionalAccessExpressionSyntax()
        {
            ObjectBinder.RegisterTypeReader(typeof(ConditionalAccessExpressionSyntax), r => new ConditionalAccessExpressionSyntax(r));
        }
    }

    /// <summary>Class which represents the syntax node for member binding expression.</summary>
    internal sealed partial class MemberBindingExpressionSyntax : ExpressionSyntax
    {
        internal readonly SyntaxToken operatorToken;
        internal readonly SimpleNameSyntax name;

        internal MemberBindingExpressionSyntax(SyntaxKind kind, SyntaxToken operatorToken, SimpleNameSyntax name, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
            this.SlotCount = 2;
            this.AdjustFlagsAndWidth(operatorToken);
            this.operatorToken = operatorToken;
            this.AdjustFlagsAndWidth(name);
            this.name = name;
        }

        internal MemberBindingExpressionSyntax(SyntaxKind kind, SyntaxToken operatorToken, SimpleNameSyntax name, SyntaxFactoryContext context)
          : base(kind)
        {
            this.SetFactoryContext(context);
            this.SlotCount = 2;
            this.AdjustFlagsAndWidth(operatorToken);
            this.operatorToken = operatorToken;
            this.AdjustFlagsAndWidth(name);
            this.name = name;
        }

        internal MemberBindingExpressionSyntax(SyntaxKind kind, SyntaxToken operatorToken, SimpleNameSyntax name)
          : base(kind)
        {
            this.SlotCount = 2;
            this.AdjustFlagsAndWidth(operatorToken);
            this.operatorToken = operatorToken;
            this.AdjustFlagsAndWidth(name);
            this.name = name;
        }

        /// <summary>SyntaxToken representing dot.</summary>
        public SyntaxToken OperatorToken => this.operatorToken;
        /// <summary>SimpleNameSyntax node representing the member being bound to.</summary>
        public SimpleNameSyntax Name => this.name;

        internal override GreenNode? GetSlot(int index)
            => index switch
            {
                0 => this.operatorToken,
                1 => this.name,
                _ => null,
            };

        internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new CSharp.Syntax.MemberBindingExpressionSyntax(this, parent, position);

        public override void Accept(CSharpSyntaxVisitor visitor) => visitor.VisitMemberBindingExpression(this);
        public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor) => visitor.VisitMemberBindingExpression(this);

        public MemberBindingExpressionSyntax Update(SyntaxToken operatorToken, SimpleNameSyntax name)
        {
            if (operatorToken != this.OperatorToken || name != this.Name)
            {
                var newNode = SyntaxFactory.MemberBindingExpression(operatorToken, name);
                var diags = GetDiagnostics();
                if (diags?.Length > 0)
                    newNode = newNode.WithDiagnosticsGreen(diags);
                var annotations = GetAnnotations();
                if (annotations?.Length > 0)
                    newNode = newNode.WithAnnotationsGreen(annotations);
                return newNode;
            }

            return this;
        }

        internal override GreenNode SetDiagnostics(DiagnosticInfo[]? diagnostics)
            => new MemberBindingExpressionSyntax(this.Kind, this.operatorToken, this.name, diagnostics, GetAnnotations());

        internal override GreenNode SetAnnotations(SyntaxAnnotation[]? annotations)
            => new MemberBindingExpressionSyntax(this.Kind, this.operatorToken, this.name, GetDiagnostics(), annotations);

        internal MemberBindingExpressionSyntax(ObjectReader reader)
          : base(reader)
        {
            this.SlotCount = 2;
            var operatorToken = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(operatorToken);
            this.operatorToken = operatorToken;
            var name = (SimpleNameSyntax)reader.ReadValue();
            AdjustFlagsAndWidth(name);
            this.name = name;
        }

        internal override void WriteTo(ObjectWriter writer)
        {
            base.WriteTo(writer);
            writer.WriteValue(this.operatorToken);
            writer.WriteValue(this.name);
        }

        static MemberBindingExpressionSyntax()
        {
            ObjectBinder.RegisterTypeReader(typeof(MemberBindingExpressionSyntax), r => new MemberBindingExpressionSyntax(r));
        }
    }

    /// <summary>Class which represents the syntax node for element binding expression.</summary>
    internal sealed partial class ElementBindingExpressionSyntax : ExpressionSyntax
    {
        internal readonly BracketedArgumentListSyntax argumentList;

        internal ElementBindingExpressionSyntax(SyntaxKind kind, BracketedArgumentListSyntax argumentList, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
            this.SlotCount = 1;
            this.AdjustFlagsAndWidth(argumentList);
            this.argumentList = argumentList;
        }

        internal ElementBindingExpressionSyntax(SyntaxKind kind, BracketedArgumentListSyntax argumentList, SyntaxFactoryContext context)
          : base(kind)
        {
            this.SetFactoryContext(context);
            this.SlotCount = 1;
            this.AdjustFlagsAndWidth(argumentList);
            this.argumentList = argumentList;
        }

        internal ElementBindingExpressionSyntax(SyntaxKind kind, BracketedArgumentListSyntax argumentList)
          : base(kind)
        {
            this.SlotCount = 1;
            this.AdjustFlagsAndWidth(argumentList);
            this.argumentList = argumentList;
        }

        /// <summary>BracketedArgumentListSyntax node representing the list of arguments of the element binding expression.</summary>
        public BracketedArgumentListSyntax ArgumentList => this.argumentList;

        internal override GreenNode? GetSlot(int index)
            => index == 0 ? this.argumentList : null;

        internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new CSharp.Syntax.ElementBindingExpressionSyntax(this, parent, position);

        public override void Accept(CSharpSyntaxVisitor visitor) => visitor.VisitElementBindingExpression(this);
        public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor) => visitor.VisitElementBindingExpression(this);

        public ElementBindingExpressionSyntax Update(BracketedArgumentListSyntax argumentList)
        {
            if (argumentList != this.ArgumentList)
            {
                var newNode = SyntaxFactory.ElementBindingExpression(argumentList);
                var diags = GetDiagnostics();
                if (diags?.Length > 0)
                    newNode = newNode.WithDiagnosticsGreen(diags);
                var annotations = GetAnnotations();
                if (annotations?.Length > 0)
                    newNode = newNode.WithAnnotationsGreen(annotations);
                return newNode;
            }

            return this;
        }

        internal override GreenNode SetDiagnostics(DiagnosticInfo[]? diagnostics)
            => new ElementBindingExpressionSyntax(this.Kind, this.argumentList, diagnostics, GetAnnotations());

        internal override GreenNode SetAnnotations(SyntaxAnnotation[]? annotations)
            => new ElementBindingExpressionSyntax(this.Kind, this.argumentList, GetDiagnostics(), annotations);

        internal ElementBindingExpressionSyntax(ObjectReader reader)
          : base(reader)
        {
            this.SlotCount = 1;
            var argumentList = (BracketedArgumentListSyntax)reader.ReadValue();
            AdjustFlagsAndWidth(argumentList);
            this.argumentList = argumentList;
        }

        internal override void WriteTo(ObjectWriter writer)
        {
            base.WriteTo(writer);
            writer.WriteValue(this.argumentList);
        }

        static ElementBindingExpressionSyntax()
        {
            ObjectBinder.RegisterTypeReader(typeof(ElementBindingExpressionSyntax), r => new ElementBindingExpressionSyntax(r));
        }
    }

    /// <summary>Class which represents the syntax node for a range expression.</summary>
    internal sealed partial class RangeExpressionSyntax : ExpressionSyntax
    {
        internal readonly ExpressionSyntax? leftOperand;
        internal readonly SyntaxToken operatorToken;
        internal readonly ExpressionSyntax? rightOperand;

        internal RangeExpressionSyntax(SyntaxKind kind, ExpressionSyntax? leftOperand, SyntaxToken operatorToken, ExpressionSyntax? rightOperand, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
            this.SlotCount = 3;
            if (leftOperand != null)
            {
                this.AdjustFlagsAndWidth(leftOperand);
                this.leftOperand = leftOperand;
            }
            this.AdjustFlagsAndWidth(operatorToken);
            this.operatorToken = operatorToken;
            if (rightOperand != null)
            {
                this.AdjustFlagsAndWidth(rightOperand);
                this.rightOperand = rightOperand;
            }
        }

        internal RangeExpressionSyntax(SyntaxKind kind, ExpressionSyntax? leftOperand, SyntaxToken operatorToken, ExpressionSyntax? rightOperand, SyntaxFactoryContext context)
          : base(kind)
        {
            this.SetFactoryContext(context);
            this.SlotCount = 3;
            if (leftOperand != null)
            {
                this.AdjustFlagsAndWidth(leftOperand);
                this.leftOperand = leftOperand;
            }
            this.AdjustFlagsAndWidth(operatorToken);
            this.operatorToken = operatorToken;
            if (rightOperand != null)
            {
                this.AdjustFlagsAndWidth(rightOperand);
                this.rightOperand = rightOperand;
            }
        }

        internal RangeExpressionSyntax(SyntaxKind kind, ExpressionSyntax? leftOperand, SyntaxToken operatorToken, ExpressionSyntax? rightOperand)
          : base(kind)
        {
            this.SlotCount = 3;
            if (leftOperand != null)
            {
                this.AdjustFlagsAndWidth(leftOperand);
                this.leftOperand = leftOperand;
            }
            this.AdjustFlagsAndWidth(operatorToken);
            this.operatorToken = operatorToken;
            if (rightOperand != null)
            {
                this.AdjustFlagsAndWidth(rightOperand);
                this.rightOperand = rightOperand;
            }
        }

        /// <summary>ExpressionSyntax node representing the expression on the left of the range operator.</summary>
        public ExpressionSyntax? LeftOperand => this.leftOperand;
        /// <summary>SyntaxToken representing the operator of the range expression.</summary>
        public SyntaxToken OperatorToken => this.operatorToken;
        /// <summary>ExpressionSyntax node representing the expression on the right of the range operator.</summary>
        public ExpressionSyntax? RightOperand => this.rightOperand;

        internal override GreenNode? GetSlot(int index)
            => index switch
            {
                0 => this.leftOperand,
                1 => this.operatorToken,
                2 => this.rightOperand,
                _ => null,
            };

        internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new CSharp.Syntax.RangeExpressionSyntax(this, parent, position);

        public override void Accept(CSharpSyntaxVisitor visitor) => visitor.VisitRangeExpression(this);
        public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor) => visitor.VisitRangeExpression(this);

        public RangeExpressionSyntax Update(ExpressionSyntax leftOperand, SyntaxToken operatorToken, ExpressionSyntax rightOperand)
        {
            if (leftOperand != this.LeftOperand || operatorToken != this.OperatorToken || rightOperand != this.RightOperand)
            {
                var newNode = SyntaxFactory.RangeExpression(leftOperand, operatorToken, rightOperand);
                var diags = GetDiagnostics();
                if (diags?.Length > 0)
                    newNode = newNode.WithDiagnosticsGreen(diags);
                var annotations = GetAnnotations();
                if (annotations?.Length > 0)
                    newNode = newNode.WithAnnotationsGreen(annotations);
                return newNode;
            }

            return this;
        }

        internal override GreenNode SetDiagnostics(DiagnosticInfo[]? diagnostics)
            => new RangeExpressionSyntax(this.Kind, this.leftOperand, this.operatorToken, this.rightOperand, diagnostics, GetAnnotations());

        internal override GreenNode SetAnnotations(SyntaxAnnotation[]? annotations)
            => new RangeExpressionSyntax(this.Kind, this.leftOperand, this.operatorToken, this.rightOperand, GetDiagnostics(), annotations);

        internal RangeExpressionSyntax(ObjectReader reader)
          : base(reader)
        {
            this.SlotCount = 3;
            var leftOperand = (ExpressionSyntax?)reader.ReadValue();
            if (leftOperand != null)
            {
                AdjustFlagsAndWidth(leftOperand);
                this.leftOperand = leftOperand;
            }
            var operatorToken = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(operatorToken);
            this.operatorToken = operatorToken;
            var rightOperand = (ExpressionSyntax?)reader.ReadValue();
            if (rightOperand != null)
            {
                AdjustFlagsAndWidth(rightOperand);
                this.rightOperand = rightOperand;
            }
        }

        internal override void WriteTo(ObjectWriter writer)
        {
            base.WriteTo(writer);
            writer.WriteValue(this.leftOperand);
            writer.WriteValue(this.operatorToken);
            writer.WriteValue(this.rightOperand);
        }

        static RangeExpressionSyntax()
        {
            ObjectBinder.RegisterTypeReader(typeof(RangeExpressionSyntax), r => new RangeExpressionSyntax(r));
        }
    }

    /// <summary>Class which represents the syntax node for implicit element access expression.</summary>
    internal sealed partial class ImplicitElementAccessSyntax : ExpressionSyntax
    {
        internal readonly BracketedArgumentListSyntax argumentList;

        internal ImplicitElementAccessSyntax(SyntaxKind kind, BracketedArgumentListSyntax argumentList, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
            this.SlotCount = 1;
            this.AdjustFlagsAndWidth(argumentList);
            this.argumentList = argumentList;
        }

        internal ImplicitElementAccessSyntax(SyntaxKind kind, BracketedArgumentListSyntax argumentList, SyntaxFactoryContext context)
          : base(kind)
        {
            this.SetFactoryContext(context);
            this.SlotCount = 1;
            this.AdjustFlagsAndWidth(argumentList);
            this.argumentList = argumentList;
        }

        internal ImplicitElementAccessSyntax(SyntaxKind kind, BracketedArgumentListSyntax argumentList)
          : base(kind)
        {
            this.SlotCount = 1;
            this.AdjustFlagsAndWidth(argumentList);
            this.argumentList = argumentList;
        }

        /// <summary>BracketedArgumentListSyntax node representing the list of arguments of the implicit element access expression.</summary>
        public BracketedArgumentListSyntax ArgumentList => this.argumentList;

        internal override GreenNode? GetSlot(int index)
            => index == 0 ? this.argumentList : null;

        internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new CSharp.Syntax.ImplicitElementAccessSyntax(this, parent, position);

        public override void Accept(CSharpSyntaxVisitor visitor) => visitor.VisitImplicitElementAccess(this);
        public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor) => visitor.VisitImplicitElementAccess(this);

        public ImplicitElementAccessSyntax Update(BracketedArgumentListSyntax argumentList)
        {
            if (argumentList != this.ArgumentList)
            {
                var newNode = SyntaxFactory.ImplicitElementAccess(argumentList);
                var diags = GetDiagnostics();
                if (diags?.Length > 0)
                    newNode = newNode.WithDiagnosticsGreen(diags);
                var annotations = GetAnnotations();
                if (annotations?.Length > 0)
                    newNode = newNode.WithAnnotationsGreen(annotations);
                return newNode;
            }

            return this;
        }

        internal override GreenNode SetDiagnostics(DiagnosticInfo[]? diagnostics)
            => new ImplicitElementAccessSyntax(this.Kind, this.argumentList, diagnostics, GetAnnotations());

        internal override GreenNode SetAnnotations(SyntaxAnnotation[]? annotations)
            => new ImplicitElementAccessSyntax(this.Kind, this.argumentList, GetDiagnostics(), annotations);

        internal ImplicitElementAccessSyntax(ObjectReader reader)
          : base(reader)
        {
            this.SlotCount = 1;
            var argumentList = (BracketedArgumentListSyntax)reader.ReadValue();
            AdjustFlagsAndWidth(argumentList);
            this.argumentList = argumentList;
        }

        internal override void WriteTo(ObjectWriter writer)
        {
            base.WriteTo(writer);
            writer.WriteValue(this.argumentList);
        }

        static ImplicitElementAccessSyntax()
        {
            ObjectBinder.RegisterTypeReader(typeof(ImplicitElementAccessSyntax), r => new ImplicitElementAccessSyntax(r));
        }
    }

    /// <summary>Class which represents an expression that has a binary operator.</summary>
    internal sealed partial class BinaryExpressionSyntax : ExpressionSyntax
    {
        internal readonly ExpressionSyntax left;
        internal readonly SyntaxToken operatorToken;
        internal readonly ExpressionSyntax right;

        internal BinaryExpressionSyntax(SyntaxKind kind, ExpressionSyntax left, SyntaxToken operatorToken, ExpressionSyntax right, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
            this.SlotCount = 3;
            this.AdjustFlagsAndWidth(left);
            this.left = left;
            this.AdjustFlagsAndWidth(operatorToken);
            this.operatorToken = operatorToken;
            this.AdjustFlagsAndWidth(right);
            this.right = right;
        }

        internal BinaryExpressionSyntax(SyntaxKind kind, ExpressionSyntax left, SyntaxToken operatorToken, ExpressionSyntax right, SyntaxFactoryContext context)
          : base(kind)
        {
            this.SetFactoryContext(context);
            this.SlotCount = 3;
            this.AdjustFlagsAndWidth(left);
            this.left = left;
            this.AdjustFlagsAndWidth(operatorToken);
            this.operatorToken = operatorToken;
            this.AdjustFlagsAndWidth(right);
            this.right = right;
        }

        internal BinaryExpressionSyntax(SyntaxKind kind, ExpressionSyntax left, SyntaxToken operatorToken, ExpressionSyntax right)
          : base(kind)
        {
            this.SlotCount = 3;
            this.AdjustFlagsAndWidth(left);
            this.left = left;
            this.AdjustFlagsAndWidth(operatorToken);
            this.operatorToken = operatorToken;
            this.AdjustFlagsAndWidth(right);
            this.right = right;
        }

        /// <summary>ExpressionSyntax node representing the expression on the left of the binary operator.</summary>
        public ExpressionSyntax Left => this.left;
        /// <summary>SyntaxToken representing the operator of the binary expression.</summary>
        public SyntaxToken OperatorToken => this.operatorToken;
        /// <summary>ExpressionSyntax node representing the expression on the right of the binary operator.</summary>
        public ExpressionSyntax Right => this.right;

        internal override GreenNode? GetSlot(int index)
            => index switch
            {
                0 => this.left,
                1 => this.operatorToken,
                2 => this.right,
                _ => null,
            };

        internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new CSharp.Syntax.BinaryExpressionSyntax(this, parent, position);

        public override void Accept(CSharpSyntaxVisitor visitor) => visitor.VisitBinaryExpression(this);
        public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor) => visitor.VisitBinaryExpression(this);

        public BinaryExpressionSyntax Update(ExpressionSyntax left, SyntaxToken operatorToken, ExpressionSyntax right)
        {
            if (left != this.Left || operatorToken != this.OperatorToken || right != this.Right)
            {
                var newNode = SyntaxFactory.BinaryExpression(this.Kind, left, operatorToken, right);
                var diags = GetDiagnostics();
                if (diags?.Length > 0)
                    newNode = newNode.WithDiagnosticsGreen(diags);
                var annotations = GetAnnotations();
                if (annotations?.Length > 0)
                    newNode = newNode.WithAnnotationsGreen(annotations);
                return newNode;
            }

            return this;
        }

        internal override GreenNode SetDiagnostics(DiagnosticInfo[]? diagnostics)
            => new BinaryExpressionSyntax(this.Kind, this.left, this.operatorToken, this.right, diagnostics, GetAnnotations());

        internal override GreenNode SetAnnotations(SyntaxAnnotation[]? annotations)
            => new BinaryExpressionSyntax(this.Kind, this.left, this.operatorToken, this.right, GetDiagnostics(), annotations);

        internal BinaryExpressionSyntax(ObjectReader reader)
          : base(reader)
        {
            this.SlotCount = 3;
            var left = (ExpressionSyntax)reader.ReadValue();
            AdjustFlagsAndWidth(left);
            this.left = left;
            var operatorToken = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(operatorToken);
            this.operatorToken = operatorToken;
            var right = (ExpressionSyntax)reader.ReadValue();
            AdjustFlagsAndWidth(right);
            this.right = right;
        }

        internal override void WriteTo(ObjectWriter writer)
        {
            base.WriteTo(writer);
            writer.WriteValue(this.left);
            writer.WriteValue(this.operatorToken);
            writer.WriteValue(this.right);
        }

        static BinaryExpressionSyntax()
        {
            ObjectBinder.RegisterTypeReader(typeof(BinaryExpressionSyntax), r => new BinaryExpressionSyntax(r));
        }
    }

    /// <summary>Class which represents an expression that has an assignment operator.</summary>
    internal sealed partial class AssignmentExpressionSyntax : ExpressionSyntax
    {
        internal readonly ExpressionSyntax left;
        internal readonly SyntaxToken operatorToken;
        internal readonly ExpressionSyntax right;

        internal AssignmentExpressionSyntax(SyntaxKind kind, ExpressionSyntax left, SyntaxToken operatorToken, ExpressionSyntax right, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
            this.SlotCount = 3;
            this.AdjustFlagsAndWidth(left);
            this.left = left;
            this.AdjustFlagsAndWidth(operatorToken);
            this.operatorToken = operatorToken;
            this.AdjustFlagsAndWidth(right);
            this.right = right;
        }

        internal AssignmentExpressionSyntax(SyntaxKind kind, ExpressionSyntax left, SyntaxToken operatorToken, ExpressionSyntax right, SyntaxFactoryContext context)
          : base(kind)
        {
            this.SetFactoryContext(context);
            this.SlotCount = 3;
            this.AdjustFlagsAndWidth(left);
            this.left = left;
            this.AdjustFlagsAndWidth(operatorToken);
            this.operatorToken = operatorToken;
            this.AdjustFlagsAndWidth(right);
            this.right = right;
        }

        internal AssignmentExpressionSyntax(SyntaxKind kind, ExpressionSyntax left, SyntaxToken operatorToken, ExpressionSyntax right)
          : base(kind)
        {
            this.SlotCount = 3;
            this.AdjustFlagsAndWidth(left);
            this.left = left;
            this.AdjustFlagsAndWidth(operatorToken);
            this.operatorToken = operatorToken;
            this.AdjustFlagsAndWidth(right);
            this.right = right;
        }

        /// <summary>ExpressionSyntax node representing the expression on the left of the assignment operator.</summary>
        public ExpressionSyntax Left => this.left;
        /// <summary>SyntaxToken representing the operator of the assignment expression.</summary>
        public SyntaxToken OperatorToken => this.operatorToken;
        /// <summary>ExpressionSyntax node representing the expression on the right of the assignment operator.</summary>
        public ExpressionSyntax Right => this.right;

        internal override GreenNode? GetSlot(int index)
            => index switch
            {
                0 => this.left,
                1 => this.operatorToken,
                2 => this.right,
                _ => null,
            };

        internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new CSharp.Syntax.AssignmentExpressionSyntax(this, parent, position);

        public override void Accept(CSharpSyntaxVisitor visitor) => visitor.VisitAssignmentExpression(this);
        public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor) => visitor.VisitAssignmentExpression(this);

        public AssignmentExpressionSyntax Update(ExpressionSyntax left, SyntaxToken operatorToken, ExpressionSyntax right)
        {
            if (left != this.Left || operatorToken != this.OperatorToken || right != this.Right)
            {
                var newNode = SyntaxFactory.AssignmentExpression(this.Kind, left, operatorToken, right);
                var diags = GetDiagnostics();
                if (diags?.Length > 0)
                    newNode = newNode.WithDiagnosticsGreen(diags);
                var annotations = GetAnnotations();
                if (annotations?.Length > 0)
                    newNode = newNode.WithAnnotationsGreen(annotations);
                return newNode;
            }

            return this;
        }

        internal override GreenNode SetDiagnostics(DiagnosticInfo[]? diagnostics)
            => new AssignmentExpressionSyntax(this.Kind, this.left, this.operatorToken, this.right, diagnostics, GetAnnotations());

        internal override GreenNode SetAnnotations(SyntaxAnnotation[]? annotations)
            => new AssignmentExpressionSyntax(this.Kind, this.left, this.operatorToken, this.right, GetDiagnostics(), annotations);

        internal AssignmentExpressionSyntax(ObjectReader reader)
          : base(reader)
        {
            this.SlotCount = 3;
            var left = (ExpressionSyntax)reader.ReadValue();
            AdjustFlagsAndWidth(left);
            this.left = left;
            var operatorToken = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(operatorToken);
            this.operatorToken = operatorToken;
            var right = (ExpressionSyntax)reader.ReadValue();
            AdjustFlagsAndWidth(right);
            this.right = right;
        }

        internal override void WriteTo(ObjectWriter writer)
        {
            base.WriteTo(writer);
            writer.WriteValue(this.left);
            writer.WriteValue(this.operatorToken);
            writer.WriteValue(this.right);
        }

        static AssignmentExpressionSyntax()
        {
            ObjectBinder.RegisterTypeReader(typeof(AssignmentExpressionSyntax), r => new AssignmentExpressionSyntax(r));
        }
    }

    /// <summary>Class which represents the syntax node for conditional expression.</summary>
    internal sealed partial class ConditionalExpressionSyntax : ExpressionSyntax
    {
        internal readonly ExpressionSyntax condition;
        internal readonly SyntaxToken questionToken;
        internal readonly ExpressionSyntax whenTrue;
        internal readonly SyntaxToken colonToken;
        internal readonly ExpressionSyntax whenFalse;

        internal ConditionalExpressionSyntax(SyntaxKind kind, ExpressionSyntax condition, SyntaxToken questionToken, ExpressionSyntax whenTrue, SyntaxToken colonToken, ExpressionSyntax whenFalse, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
            this.SlotCount = 5;
            this.AdjustFlagsAndWidth(condition);
            this.condition = condition;
            this.AdjustFlagsAndWidth(questionToken);
            this.questionToken = questionToken;
            this.AdjustFlagsAndWidth(whenTrue);
            this.whenTrue = whenTrue;
            this.AdjustFlagsAndWidth(colonToken);
            this.colonToken = colonToken;
            this.AdjustFlagsAndWidth(whenFalse);
            this.whenFalse = whenFalse;
        }

        internal ConditionalExpressionSyntax(SyntaxKind kind, ExpressionSyntax condition, SyntaxToken questionToken, ExpressionSyntax whenTrue, SyntaxToken colonToken, ExpressionSyntax whenFalse, SyntaxFactoryContext context)
          : base(kind)
        {
            this.SetFactoryContext(context);
            this.SlotCount = 5;
            this.AdjustFlagsAndWidth(condition);
            this.condition = condition;
            this.AdjustFlagsAndWidth(questionToken);
            this.questionToken = questionToken;
            this.AdjustFlagsAndWidth(whenTrue);
            this.whenTrue = whenTrue;
            this.AdjustFlagsAndWidth(colonToken);
            this.colonToken = colonToken;
            this.AdjustFlagsAndWidth(whenFalse);
            this.whenFalse = whenFalse;
        }

        internal ConditionalExpressionSyntax(SyntaxKind kind, ExpressionSyntax condition, SyntaxToken questionToken, ExpressionSyntax whenTrue, SyntaxToken colonToken, ExpressionSyntax whenFalse)
          : base(kind)
        {
            this.SlotCount = 5;
            this.AdjustFlagsAndWidth(condition);
            this.condition = condition;
            this.AdjustFlagsAndWidth(questionToken);
            this.questionToken = questionToken;
            this.AdjustFlagsAndWidth(whenTrue);
            this.whenTrue = whenTrue;
            this.AdjustFlagsAndWidth(colonToken);
            this.colonToken = colonToken;
            this.AdjustFlagsAndWidth(whenFalse);
            this.whenFalse = whenFalse;
        }

        /// <summary>ExpressionSyntax node representing the condition of the conditional expression.</summary>
        public ExpressionSyntax Condition => this.condition;
        /// <summary>SyntaxToken representing the question mark.</summary>
        public SyntaxToken QuestionToken => this.questionToken;
        /// <summary>ExpressionSyntax node representing the expression to be executed when the condition is true.</summary>
        public ExpressionSyntax WhenTrue => this.whenTrue;
        /// <summary>SyntaxToken representing the colon.</summary>
        public SyntaxToken ColonToken => this.colonToken;
        /// <summary>ExpressionSyntax node representing the expression to be executed when the condition is false.</summary>
        public ExpressionSyntax WhenFalse => this.whenFalse;

        internal override GreenNode? GetSlot(int index)
            => index switch
            {
                0 => this.condition,
                1 => this.questionToken,
                2 => this.whenTrue,
                3 => this.colonToken,
                4 => this.whenFalse,
                _ => null,
            };

        internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new CSharp.Syntax.ConditionalExpressionSyntax(this, parent, position);

        public override void Accept(CSharpSyntaxVisitor visitor) => visitor.VisitConditionalExpression(this);
        public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor) => visitor.VisitConditionalExpression(this);

        public ConditionalExpressionSyntax Update(ExpressionSyntax condition, SyntaxToken questionToken, ExpressionSyntax whenTrue, SyntaxToken colonToken, ExpressionSyntax whenFalse)
        {
            if (condition != this.Condition || questionToken != this.QuestionToken || whenTrue != this.WhenTrue || colonToken != this.ColonToken || whenFalse != this.WhenFalse)
            {
                var newNode = SyntaxFactory.ConditionalExpression(condition, questionToken, whenTrue, colonToken, whenFalse);
                var diags = GetDiagnostics();
                if (diags?.Length > 0)
                    newNode = newNode.WithDiagnosticsGreen(diags);
                var annotations = GetAnnotations();
                if (annotations?.Length > 0)
                    newNode = newNode.WithAnnotationsGreen(annotations);
                return newNode;
            }

            return this;
        }

        internal override GreenNode SetDiagnostics(DiagnosticInfo[]? diagnostics)
            => new ConditionalExpressionSyntax(this.Kind, this.condition, this.questionToken, this.whenTrue, this.colonToken, this.whenFalse, diagnostics, GetAnnotations());

        internal override GreenNode SetAnnotations(SyntaxAnnotation[]? annotations)
            => new ConditionalExpressionSyntax(this.Kind, this.condition, this.questionToken, this.whenTrue, this.colonToken, this.whenFalse, GetDiagnostics(), annotations);

        internal ConditionalExpressionSyntax(ObjectReader reader)
          : base(reader)
        {
            this.SlotCount = 5;
            var condition = (ExpressionSyntax)reader.ReadValue();
            AdjustFlagsAndWidth(condition);
            this.condition = condition;
            var questionToken = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(questionToken);
            this.questionToken = questionToken;
            var whenTrue = (ExpressionSyntax)reader.ReadValue();
            AdjustFlagsAndWidth(whenTrue);
            this.whenTrue = whenTrue;
            var colonToken = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(colonToken);
            this.colonToken = colonToken;
            var whenFalse = (ExpressionSyntax)reader.ReadValue();
            AdjustFlagsAndWidth(whenFalse);
            this.whenFalse = whenFalse;
        }

        internal override void WriteTo(ObjectWriter writer)
        {
            base.WriteTo(writer);
            writer.WriteValue(this.condition);
            writer.WriteValue(this.questionToken);
            writer.WriteValue(this.whenTrue);
            writer.WriteValue(this.colonToken);
            writer.WriteValue(this.whenFalse);
        }

        static ConditionalExpressionSyntax()
        {
            ObjectBinder.RegisterTypeReader(typeof(ConditionalExpressionSyntax), r => new ConditionalExpressionSyntax(r));
        }
    }

    /// <summary>Provides the base class from which the classes that represent instance expression syntax nodes are derived. This is an abstract class.</summary>
    internal abstract partial class InstanceExpressionSyntax : ExpressionSyntax
    {
        internal InstanceExpressionSyntax(SyntaxKind kind, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
        }

        internal InstanceExpressionSyntax(SyntaxKind kind)
          : base(kind)
        {
        }

        protected InstanceExpressionSyntax(ObjectReader reader)
          : base(reader)
        {
        }
    }

    /// <summary>Class which represents the syntax node for a this expression.</summary>
    internal sealed partial class ThisExpressionSyntax : InstanceExpressionSyntax
    {
        internal readonly SyntaxToken token;

        internal ThisExpressionSyntax(SyntaxKind kind, SyntaxToken token, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
            this.SlotCount = 1;
            this.AdjustFlagsAndWidth(token);
            this.token = token;
        }

        internal ThisExpressionSyntax(SyntaxKind kind, SyntaxToken token, SyntaxFactoryContext context)
          : base(kind)
        {
            this.SetFactoryContext(context);
            this.SlotCount = 1;
            this.AdjustFlagsAndWidth(token);
            this.token = token;
        }

        internal ThisExpressionSyntax(SyntaxKind kind, SyntaxToken token)
          : base(kind)
        {
            this.SlotCount = 1;
            this.AdjustFlagsAndWidth(token);
            this.token = token;
        }

        /// <summary>SyntaxToken representing the this keyword.</summary>
        public SyntaxToken Token => this.token;

        internal override GreenNode? GetSlot(int index)
            => index == 0 ? this.token : null;

        internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new CSharp.Syntax.ThisExpressionSyntax(this, parent, position);

        public override void Accept(CSharpSyntaxVisitor visitor) => visitor.VisitThisExpression(this);
        public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor) => visitor.VisitThisExpression(this);

        public ThisExpressionSyntax Update(SyntaxToken token)
        {
            if (token != this.Token)
            {
                var newNode = SyntaxFactory.ThisExpression(token);
                var diags = GetDiagnostics();
                if (diags?.Length > 0)
                    newNode = newNode.WithDiagnosticsGreen(diags);
                var annotations = GetAnnotations();
                if (annotations?.Length > 0)
                    newNode = newNode.WithAnnotationsGreen(annotations);
                return newNode;
            }

            return this;
        }

        internal override GreenNode SetDiagnostics(DiagnosticInfo[]? diagnostics)
            => new ThisExpressionSyntax(this.Kind, this.token, diagnostics, GetAnnotations());

        internal override GreenNode SetAnnotations(SyntaxAnnotation[]? annotations)
            => new ThisExpressionSyntax(this.Kind, this.token, GetDiagnostics(), annotations);

        internal ThisExpressionSyntax(ObjectReader reader)
          : base(reader)
        {
            this.SlotCount = 1;
            var token = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(token);
            this.token = token;
        }

        internal override void WriteTo(ObjectWriter writer)
        {
            base.WriteTo(writer);
            writer.WriteValue(this.token);
        }

        static ThisExpressionSyntax()
        {
            ObjectBinder.RegisterTypeReader(typeof(ThisExpressionSyntax), r => new ThisExpressionSyntax(r));
        }
    }

    /// <summary>Class which represents the syntax node for a base expression.</summary>
    internal sealed partial class BaseExpressionSyntax : InstanceExpressionSyntax
    {
        internal readonly SyntaxToken token;

        internal BaseExpressionSyntax(SyntaxKind kind, SyntaxToken token, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
            this.SlotCount = 1;
            this.AdjustFlagsAndWidth(token);
            this.token = token;
        }

        internal BaseExpressionSyntax(SyntaxKind kind, SyntaxToken token, SyntaxFactoryContext context)
          : base(kind)
        {
            this.SetFactoryContext(context);
            this.SlotCount = 1;
            this.AdjustFlagsAndWidth(token);
            this.token = token;
        }

        internal BaseExpressionSyntax(SyntaxKind kind, SyntaxToken token)
          : base(kind)
        {
            this.SlotCount = 1;
            this.AdjustFlagsAndWidth(token);
            this.token = token;
        }

        /// <summary>SyntaxToken representing the base keyword.</summary>
        public SyntaxToken Token => this.token;

        internal override GreenNode? GetSlot(int index)
            => index == 0 ? this.token : null;

        internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new CSharp.Syntax.BaseExpressionSyntax(this, parent, position);

        public override void Accept(CSharpSyntaxVisitor visitor) => visitor.VisitBaseExpression(this);
        public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor) => visitor.VisitBaseExpression(this);

        public BaseExpressionSyntax Update(SyntaxToken token)
        {
            if (token != this.Token)
            {
                var newNode = SyntaxFactory.BaseExpression(token);
                var diags = GetDiagnostics();
                if (diags?.Length > 0)
                    newNode = newNode.WithDiagnosticsGreen(diags);
                var annotations = GetAnnotations();
                if (annotations?.Length > 0)
                    newNode = newNode.WithAnnotationsGreen(annotations);
                return newNode;
            }

            return this;
        }

        internal override GreenNode SetDiagnostics(DiagnosticInfo[]? diagnostics)
            => new BaseExpressionSyntax(this.Kind, this.token, diagnostics, GetAnnotations());

        internal override GreenNode SetAnnotations(SyntaxAnnotation[]? annotations)
            => new BaseExpressionSyntax(this.Kind, this.token, GetDiagnostics(), annotations);

        internal BaseExpressionSyntax(ObjectReader reader)
          : base(reader)
        {
            this.SlotCount = 1;
            var token = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(token);
            this.token = token;
        }

        internal override void WriteTo(ObjectWriter writer)
        {
            base.WriteTo(writer);
            writer.WriteValue(this.token);
        }

        static BaseExpressionSyntax()
        {
            ObjectBinder.RegisterTypeReader(typeof(BaseExpressionSyntax), r => new BaseExpressionSyntax(r));
        }
    }

    /// <summary>Class which represents the syntax node for a literal expression.</summary>
    internal sealed partial class LiteralExpressionSyntax : ExpressionSyntax
    {
        internal readonly SyntaxToken token;

        internal LiteralExpressionSyntax(SyntaxKind kind, SyntaxToken token, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
            this.SlotCount = 1;
            this.AdjustFlagsAndWidth(token);
            this.token = token;
        }

        internal LiteralExpressionSyntax(SyntaxKind kind, SyntaxToken token, SyntaxFactoryContext context)
          : base(kind)
        {
            this.SetFactoryContext(context);
            this.SlotCount = 1;
            this.AdjustFlagsAndWidth(token);
            this.token = token;
        }

        internal LiteralExpressionSyntax(SyntaxKind kind, SyntaxToken token)
          : base(kind)
        {
            this.SlotCount = 1;
            this.AdjustFlagsAndWidth(token);
            this.token = token;
        }

        /// <summary>SyntaxToken representing the keyword corresponding to the kind of the literal expression.</summary>
        public SyntaxToken Token => this.token;

        internal override GreenNode? GetSlot(int index)
            => index == 0 ? this.token : null;

        internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new CSharp.Syntax.LiteralExpressionSyntax(this, parent, position);

        public override void Accept(CSharpSyntaxVisitor visitor) => visitor.VisitLiteralExpression(this);
        public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor) => visitor.VisitLiteralExpression(this);

        public LiteralExpressionSyntax Update(SyntaxToken token)
        {
            if (token != this.Token)
            {
                var newNode = SyntaxFactory.LiteralExpression(this.Kind, token);
                var diags = GetDiagnostics();
                if (diags?.Length > 0)
                    newNode = newNode.WithDiagnosticsGreen(diags);
                var annotations = GetAnnotations();
                if (annotations?.Length > 0)
                    newNode = newNode.WithAnnotationsGreen(annotations);
                return newNode;
            }

            return this;
        }

        internal override GreenNode SetDiagnostics(DiagnosticInfo[]? diagnostics)
            => new LiteralExpressionSyntax(this.Kind, this.token, diagnostics, GetAnnotations());

        internal override GreenNode SetAnnotations(SyntaxAnnotation[]? annotations)
            => new LiteralExpressionSyntax(this.Kind, this.token, GetDiagnostics(), annotations);

        internal LiteralExpressionSyntax(ObjectReader reader)
          : base(reader)
        {
            this.SlotCount = 1;
            var token = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(token);
            this.token = token;
        }

        internal override void WriteTo(ObjectWriter writer)
        {
            base.WriteTo(writer);
            writer.WriteValue(this.token);
        }

        static LiteralExpressionSyntax()
        {
            ObjectBinder.RegisterTypeReader(typeof(LiteralExpressionSyntax), r => new LiteralExpressionSyntax(r));
        }
    }

    /// <summary>Class which represents the syntax node for MakeRef expression.</summary>
    internal sealed partial class MakeRefExpressionSyntax : ExpressionSyntax
    {
        internal readonly SyntaxToken keyword;
        internal readonly SyntaxToken openParenToken;
        internal readonly ExpressionSyntax expression;
        internal readonly SyntaxToken closeParenToken;

        internal MakeRefExpressionSyntax(SyntaxKind kind, SyntaxToken keyword, SyntaxToken openParenToken, ExpressionSyntax expression, SyntaxToken closeParenToken, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
            this.SlotCount = 4;
            this.AdjustFlagsAndWidth(keyword);
            this.keyword = keyword;
            this.AdjustFlagsAndWidth(openParenToken);
            this.openParenToken = openParenToken;
            this.AdjustFlagsAndWidth(expression);
            this.expression = expression;
            this.AdjustFlagsAndWidth(closeParenToken);
            this.closeParenToken = closeParenToken;
        }

        internal MakeRefExpressionSyntax(SyntaxKind kind, SyntaxToken keyword, SyntaxToken openParenToken, ExpressionSyntax expression, SyntaxToken closeParenToken, SyntaxFactoryContext context)
          : base(kind)
        {
            this.SetFactoryContext(context);
            this.SlotCount = 4;
            this.AdjustFlagsAndWidth(keyword);
            this.keyword = keyword;
            this.AdjustFlagsAndWidth(openParenToken);
            this.openParenToken = openParenToken;
            this.AdjustFlagsAndWidth(expression);
            this.expression = expression;
            this.AdjustFlagsAndWidth(closeParenToken);
            this.closeParenToken = closeParenToken;
        }

        internal MakeRefExpressionSyntax(SyntaxKind kind, SyntaxToken keyword, SyntaxToken openParenToken, ExpressionSyntax expression, SyntaxToken closeParenToken)
          : base(kind)
        {
            this.SlotCount = 4;
            this.AdjustFlagsAndWidth(keyword);
            this.keyword = keyword;
            this.AdjustFlagsAndWidth(openParenToken);
            this.openParenToken = openParenToken;
            this.AdjustFlagsAndWidth(expression);
            this.expression = expression;
            this.AdjustFlagsAndWidth(closeParenToken);
            this.closeParenToken = closeParenToken;
        }

        /// <summary>SyntaxToken representing the MakeRefKeyword.</summary>
        public SyntaxToken Keyword => this.keyword;
        /// <summary>SyntaxToken representing open parenthesis.</summary>
        public SyntaxToken OpenParenToken => this.openParenToken;
        /// <summary>Argument of the primary function.</summary>
        public ExpressionSyntax Expression => this.expression;
        /// <summary>SyntaxToken representing close parenthesis.</summary>
        public SyntaxToken CloseParenToken => this.closeParenToken;

        internal override GreenNode? GetSlot(int index)
            => index switch
            {
                0 => this.keyword,
                1 => this.openParenToken,
                2 => this.expression,
                3 => this.closeParenToken,
                _ => null,
            };

        internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new CSharp.Syntax.MakeRefExpressionSyntax(this, parent, position);

        public override void Accept(CSharpSyntaxVisitor visitor) => visitor.VisitMakeRefExpression(this);
        public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor) => visitor.VisitMakeRefExpression(this);

        public MakeRefExpressionSyntax Update(SyntaxToken keyword, SyntaxToken openParenToken, ExpressionSyntax expression, SyntaxToken closeParenToken)
        {
            if (keyword != this.Keyword || openParenToken != this.OpenParenToken || expression != this.Expression || closeParenToken != this.CloseParenToken)
            {
                var newNode = SyntaxFactory.MakeRefExpression(keyword, openParenToken, expression, closeParenToken);
                var diags = GetDiagnostics();
                if (diags?.Length > 0)
                    newNode = newNode.WithDiagnosticsGreen(diags);
                var annotations = GetAnnotations();
                if (annotations?.Length > 0)
                    newNode = newNode.WithAnnotationsGreen(annotations);
                return newNode;
            }

            return this;
        }

        internal override GreenNode SetDiagnostics(DiagnosticInfo[]? diagnostics)
            => new MakeRefExpressionSyntax(this.Kind, this.keyword, this.openParenToken, this.expression, this.closeParenToken, diagnostics, GetAnnotations());

        internal override GreenNode SetAnnotations(SyntaxAnnotation[]? annotations)
            => new MakeRefExpressionSyntax(this.Kind, this.keyword, this.openParenToken, this.expression, this.closeParenToken, GetDiagnostics(), annotations);

        internal MakeRefExpressionSyntax(ObjectReader reader)
          : base(reader)
        {
            this.SlotCount = 4;
            var keyword = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(keyword);
            this.keyword = keyword;
            var openParenToken = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(openParenToken);
            this.openParenToken = openParenToken;
            var expression = (ExpressionSyntax)reader.ReadValue();
            AdjustFlagsAndWidth(expression);
            this.expression = expression;
            var closeParenToken = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(closeParenToken);
            this.closeParenToken = closeParenToken;
        }

        internal override void WriteTo(ObjectWriter writer)
        {
            base.WriteTo(writer);
            writer.WriteValue(this.keyword);
            writer.WriteValue(this.openParenToken);
            writer.WriteValue(this.expression);
            writer.WriteValue(this.closeParenToken);
        }

        static MakeRefExpressionSyntax()
        {
            ObjectBinder.RegisterTypeReader(typeof(MakeRefExpressionSyntax), r => new MakeRefExpressionSyntax(r));
        }
    }

    /// <summary>Class which represents the syntax node for RefType expression.</summary>
    internal sealed partial class RefTypeExpressionSyntax : ExpressionSyntax
    {
        internal readonly SyntaxToken keyword;
        internal readonly SyntaxToken openParenToken;
        internal readonly ExpressionSyntax expression;
        internal readonly SyntaxToken closeParenToken;

        internal RefTypeExpressionSyntax(SyntaxKind kind, SyntaxToken keyword, SyntaxToken openParenToken, ExpressionSyntax expression, SyntaxToken closeParenToken, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
            this.SlotCount = 4;
            this.AdjustFlagsAndWidth(keyword);
            this.keyword = keyword;
            this.AdjustFlagsAndWidth(openParenToken);
            this.openParenToken = openParenToken;
            this.AdjustFlagsAndWidth(expression);
            this.expression = expression;
            this.AdjustFlagsAndWidth(closeParenToken);
            this.closeParenToken = closeParenToken;
        }

        internal RefTypeExpressionSyntax(SyntaxKind kind, SyntaxToken keyword, SyntaxToken openParenToken, ExpressionSyntax expression, SyntaxToken closeParenToken, SyntaxFactoryContext context)
          : base(kind)
        {
            this.SetFactoryContext(context);
            this.SlotCount = 4;
            this.AdjustFlagsAndWidth(keyword);
            this.keyword = keyword;
            this.AdjustFlagsAndWidth(openParenToken);
            this.openParenToken = openParenToken;
            this.AdjustFlagsAndWidth(expression);
            this.expression = expression;
            this.AdjustFlagsAndWidth(closeParenToken);
            this.closeParenToken = closeParenToken;
        }

        internal RefTypeExpressionSyntax(SyntaxKind kind, SyntaxToken keyword, SyntaxToken openParenToken, ExpressionSyntax expression, SyntaxToken closeParenToken)
          : base(kind)
        {
            this.SlotCount = 4;
            this.AdjustFlagsAndWidth(keyword);
            this.keyword = keyword;
            this.AdjustFlagsAndWidth(openParenToken);
            this.openParenToken = openParenToken;
            this.AdjustFlagsAndWidth(expression);
            this.expression = expression;
            this.AdjustFlagsAndWidth(closeParenToken);
            this.closeParenToken = closeParenToken;
        }

        /// <summary>SyntaxToken representing the RefTypeKeyword.</summary>
        public SyntaxToken Keyword => this.keyword;
        /// <summary>SyntaxToken representing open parenthesis.</summary>
        public SyntaxToken OpenParenToken => this.openParenToken;
        /// <summary>Argument of the primary function.</summary>
        public ExpressionSyntax Expression => this.expression;
        /// <summary>SyntaxToken representing close parenthesis.</summary>
        public SyntaxToken CloseParenToken => this.closeParenToken;

        internal override GreenNode? GetSlot(int index)
            => index switch
            {
                0 => this.keyword,
                1 => this.openParenToken,
                2 => this.expression,
                3 => this.closeParenToken,
                _ => null,
            };

        internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new CSharp.Syntax.RefTypeExpressionSyntax(this, parent, position);

        public override void Accept(CSharpSyntaxVisitor visitor) => visitor.VisitRefTypeExpression(this);
        public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor) => visitor.VisitRefTypeExpression(this);

        public RefTypeExpressionSyntax Update(SyntaxToken keyword, SyntaxToken openParenToken, ExpressionSyntax expression, SyntaxToken closeParenToken)
        {
            if (keyword != this.Keyword || openParenToken != this.OpenParenToken || expression != this.Expression || closeParenToken != this.CloseParenToken)
            {
                var newNode = SyntaxFactory.RefTypeExpression(keyword, openParenToken, expression, closeParenToken);
                var diags = GetDiagnostics();
                if (diags?.Length > 0)
                    newNode = newNode.WithDiagnosticsGreen(diags);
                var annotations = GetAnnotations();
                if (annotations?.Length > 0)
                    newNode = newNode.WithAnnotationsGreen(annotations);
                return newNode;
            }

            return this;
        }

        internal override GreenNode SetDiagnostics(DiagnosticInfo[]? diagnostics)
            => new RefTypeExpressionSyntax(this.Kind, this.keyword, this.openParenToken, this.expression, this.closeParenToken, diagnostics, GetAnnotations());

        internal override GreenNode SetAnnotations(SyntaxAnnotation[]? annotations)
            => new RefTypeExpressionSyntax(this.Kind, this.keyword, this.openParenToken, this.expression, this.closeParenToken, GetDiagnostics(), annotations);

        internal RefTypeExpressionSyntax(ObjectReader reader)
          : base(reader)
        {
            this.SlotCount = 4;
            var keyword = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(keyword);
            this.keyword = keyword;
            var openParenToken = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(openParenToken);
            this.openParenToken = openParenToken;
            var expression = (ExpressionSyntax)reader.ReadValue();
            AdjustFlagsAndWidth(expression);
            this.expression = expression;
            var closeParenToken = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(closeParenToken);
            this.closeParenToken = closeParenToken;
        }

        internal override void WriteTo(ObjectWriter writer)
        {
            base.WriteTo(writer);
            writer.WriteValue(this.keyword);
            writer.WriteValue(this.openParenToken);
            writer.WriteValue(this.expression);
            writer.WriteValue(this.closeParenToken);
        }

        static RefTypeExpressionSyntax()
        {
            ObjectBinder.RegisterTypeReader(typeof(RefTypeExpressionSyntax), r => new RefTypeExpressionSyntax(r));
        }
    }

    /// <summary>Class which represents the syntax node for RefValue expression.</summary>
    internal sealed partial class RefValueExpressionSyntax : ExpressionSyntax
    {
        internal readonly SyntaxToken keyword;
        internal readonly SyntaxToken openParenToken;
        internal readonly ExpressionSyntax expression;
        internal readonly SyntaxToken comma;
        internal readonly TypeSyntax type;
        internal readonly SyntaxToken closeParenToken;

        internal RefValueExpressionSyntax(SyntaxKind kind, SyntaxToken keyword, SyntaxToken openParenToken, ExpressionSyntax expression, SyntaxToken comma, TypeSyntax type, SyntaxToken closeParenToken, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
            this.SlotCount = 6;
            this.AdjustFlagsAndWidth(keyword);
            this.keyword = keyword;
            this.AdjustFlagsAndWidth(openParenToken);
            this.openParenToken = openParenToken;
            this.AdjustFlagsAndWidth(expression);
            this.expression = expression;
            this.AdjustFlagsAndWidth(comma);
            this.comma = comma;
            this.AdjustFlagsAndWidth(type);
            this.type = type;
            this.AdjustFlagsAndWidth(closeParenToken);
            this.closeParenToken = closeParenToken;
        }

        internal RefValueExpressionSyntax(SyntaxKind kind, SyntaxToken keyword, SyntaxToken openParenToken, ExpressionSyntax expression, SyntaxToken comma, TypeSyntax type, SyntaxToken closeParenToken, SyntaxFactoryContext context)
          : base(kind)
        {
            this.SetFactoryContext(context);
            this.SlotCount = 6;
            this.AdjustFlagsAndWidth(keyword);
            this.keyword = keyword;
            this.AdjustFlagsAndWidth(openParenToken);
            this.openParenToken = openParenToken;
            this.AdjustFlagsAndWidth(expression);
            this.expression = expression;
            this.AdjustFlagsAndWidth(comma);
            this.comma = comma;
            this.AdjustFlagsAndWidth(type);
            this.type = type;
            this.AdjustFlagsAndWidth(closeParenToken);
            this.closeParenToken = closeParenToken;
        }

        internal RefValueExpressionSyntax(SyntaxKind kind, SyntaxToken keyword, SyntaxToken openParenToken, ExpressionSyntax expression, SyntaxToken comma, TypeSyntax type, SyntaxToken closeParenToken)
          : base(kind)
        {
            this.SlotCount = 6;
            this.AdjustFlagsAndWidth(keyword);
            this.keyword = keyword;
            this.AdjustFlagsAndWidth(openParenToken);
            this.openParenToken = openParenToken;
            this.AdjustFlagsAndWidth(expression);
            this.expression = expression;
            this.AdjustFlagsAndWidth(comma);
            this.comma = comma;
            this.AdjustFlagsAndWidth(type);
            this.type = type;
            this.AdjustFlagsAndWidth(closeParenToken);
            this.closeParenToken = closeParenToken;
        }

        /// <summary>SyntaxToken representing the RefValueKeyword.</summary>
        public SyntaxToken Keyword => this.keyword;
        /// <summary>SyntaxToken representing open parenthesis.</summary>
        public SyntaxToken OpenParenToken => this.openParenToken;
        /// <summary>Typed reference expression.</summary>
        public ExpressionSyntax Expression => this.expression;
        /// <summary>Comma separating the arguments.</summary>
        public SyntaxToken Comma => this.comma;
        /// <summary>The type of the value.</summary>
        public TypeSyntax Type => this.type;
        /// <summary>SyntaxToken representing close parenthesis.</summary>
        public SyntaxToken CloseParenToken => this.closeParenToken;

        internal override GreenNode? GetSlot(int index)
            => index switch
            {
                0 => this.keyword,
                1 => this.openParenToken,
                2 => this.expression,
                3 => this.comma,
                4 => this.type,
                5 => this.closeParenToken,
                _ => null,
            };

        internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new CSharp.Syntax.RefValueExpressionSyntax(this, parent, position);

        public override void Accept(CSharpSyntaxVisitor visitor) => visitor.VisitRefValueExpression(this);
        public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor) => visitor.VisitRefValueExpression(this);

        public RefValueExpressionSyntax Update(SyntaxToken keyword, SyntaxToken openParenToken, ExpressionSyntax expression, SyntaxToken comma, TypeSyntax type, SyntaxToken closeParenToken)
        {
            if (keyword != this.Keyword || openParenToken != this.OpenParenToken || expression != this.Expression || comma != this.Comma || type != this.Type || closeParenToken != this.CloseParenToken)
            {
                var newNode = SyntaxFactory.RefValueExpression(keyword, openParenToken, expression, comma, type, closeParenToken);
                var diags = GetDiagnostics();
                if (diags?.Length > 0)
                    newNode = newNode.WithDiagnosticsGreen(diags);
                var annotations = GetAnnotations();
                if (annotations?.Length > 0)
                    newNode = newNode.WithAnnotationsGreen(annotations);
                return newNode;
            }

            return this;
        }

        internal override GreenNode SetDiagnostics(DiagnosticInfo[]? diagnostics)
            => new RefValueExpressionSyntax(this.Kind, this.keyword, this.openParenToken, this.expression, this.comma, this.type, this.closeParenToken, diagnostics, GetAnnotations());

        internal override GreenNode SetAnnotations(SyntaxAnnotation[]? annotations)
            => new RefValueExpressionSyntax(this.Kind, this.keyword, this.openParenToken, this.expression, this.comma, this.type, this.closeParenToken, GetDiagnostics(), annotations);

        internal RefValueExpressionSyntax(ObjectReader reader)
          : base(reader)
        {
            this.SlotCount = 6;
            var keyword = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(keyword);
            this.keyword = keyword;
            var openParenToken = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(openParenToken);
            this.openParenToken = openParenToken;
            var expression = (ExpressionSyntax)reader.ReadValue();
            AdjustFlagsAndWidth(expression);
            this.expression = expression;
            var comma = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(comma);
            this.comma = comma;
            var type = (TypeSyntax)reader.ReadValue();
            AdjustFlagsAndWidth(type);
            this.type = type;
            var closeParenToken = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(closeParenToken);
            this.closeParenToken = closeParenToken;
        }

        internal override void WriteTo(ObjectWriter writer)
        {
            base.WriteTo(writer);
            writer.WriteValue(this.keyword);
            writer.WriteValue(this.openParenToken);
            writer.WriteValue(this.expression);
            writer.WriteValue(this.comma);
            writer.WriteValue(this.type);
            writer.WriteValue(this.closeParenToken);
        }

        static RefValueExpressionSyntax()
        {
            ObjectBinder.RegisterTypeReader(typeof(RefValueExpressionSyntax), r => new RefValueExpressionSyntax(r));
        }
    }

    /// <summary>Class which represents the syntax node for Checked or Unchecked expression.</summary>
    internal sealed partial class CheckedExpressionSyntax : ExpressionSyntax
    {
        internal readonly SyntaxToken keyword;
        internal readonly SyntaxToken openParenToken;
        internal readonly ExpressionSyntax expression;
        internal readonly SyntaxToken closeParenToken;

        internal CheckedExpressionSyntax(SyntaxKind kind, SyntaxToken keyword, SyntaxToken openParenToken, ExpressionSyntax expression, SyntaxToken closeParenToken, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
            this.SlotCount = 4;
            this.AdjustFlagsAndWidth(keyword);
            this.keyword = keyword;
            this.AdjustFlagsAndWidth(openParenToken);
            this.openParenToken = openParenToken;
            this.AdjustFlagsAndWidth(expression);
            this.expression = expression;
            this.AdjustFlagsAndWidth(closeParenToken);
            this.closeParenToken = closeParenToken;
        }

        internal CheckedExpressionSyntax(SyntaxKind kind, SyntaxToken keyword, SyntaxToken openParenToken, ExpressionSyntax expression, SyntaxToken closeParenToken, SyntaxFactoryContext context)
          : base(kind)
        {
            this.SetFactoryContext(context);
            this.SlotCount = 4;
            this.AdjustFlagsAndWidth(keyword);
            this.keyword = keyword;
            this.AdjustFlagsAndWidth(openParenToken);
            this.openParenToken = openParenToken;
            this.AdjustFlagsAndWidth(expression);
            this.expression = expression;
            this.AdjustFlagsAndWidth(closeParenToken);
            this.closeParenToken = closeParenToken;
        }

        internal CheckedExpressionSyntax(SyntaxKind kind, SyntaxToken keyword, SyntaxToken openParenToken, ExpressionSyntax expression, SyntaxToken closeParenToken)
          : base(kind)
        {
            this.SlotCount = 4;
            this.AdjustFlagsAndWidth(keyword);
            this.keyword = keyword;
            this.AdjustFlagsAndWidth(openParenToken);
            this.openParenToken = openParenToken;
            this.AdjustFlagsAndWidth(expression);
            this.expression = expression;
            this.AdjustFlagsAndWidth(closeParenToken);
            this.closeParenToken = closeParenToken;
        }

        /// <summary>SyntaxToken representing the checked or unchecked keyword.</summary>
        public SyntaxToken Keyword => this.keyword;
        /// <summary>SyntaxToken representing open parenthesis.</summary>
        public SyntaxToken OpenParenToken => this.openParenToken;
        /// <summary>Argument of the primary function.</summary>
        public ExpressionSyntax Expression => this.expression;
        /// <summary>SyntaxToken representing close parenthesis.</summary>
        public SyntaxToken CloseParenToken => this.closeParenToken;

        internal override GreenNode? GetSlot(int index)
            => index switch
            {
                0 => this.keyword,
                1 => this.openParenToken,
                2 => this.expression,
                3 => this.closeParenToken,
                _ => null,
            };

        internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new CSharp.Syntax.CheckedExpressionSyntax(this, parent, position);

        public override void Accept(CSharpSyntaxVisitor visitor) => visitor.VisitCheckedExpression(this);
        public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor) => visitor.VisitCheckedExpression(this);

        public CheckedExpressionSyntax Update(SyntaxToken keyword, SyntaxToken openParenToken, ExpressionSyntax expression, SyntaxToken closeParenToken)
        {
            if (keyword != this.Keyword || openParenToken != this.OpenParenToken || expression != this.Expression || closeParenToken != this.CloseParenToken)
            {
                var newNode = SyntaxFactory.CheckedExpression(this.Kind, keyword, openParenToken, expression, closeParenToken);
                var diags = GetDiagnostics();
                if (diags?.Length > 0)
                    newNode = newNode.WithDiagnosticsGreen(diags);
                var annotations = GetAnnotations();
                if (annotations?.Length > 0)
                    newNode = newNode.WithAnnotationsGreen(annotations);
                return newNode;
            }

            return this;
        }

        internal override GreenNode SetDiagnostics(DiagnosticInfo[]? diagnostics)
            => new CheckedExpressionSyntax(this.Kind, this.keyword, this.openParenToken, this.expression, this.closeParenToken, diagnostics, GetAnnotations());

        internal override GreenNode SetAnnotations(SyntaxAnnotation[]? annotations)
            => new CheckedExpressionSyntax(this.Kind, this.keyword, this.openParenToken, this.expression, this.closeParenToken, GetDiagnostics(), annotations);

        internal CheckedExpressionSyntax(ObjectReader reader)
          : base(reader)
        {
            this.SlotCount = 4;
            var keyword = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(keyword);
            this.keyword = keyword;
            var openParenToken = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(openParenToken);
            this.openParenToken = openParenToken;
            var expression = (ExpressionSyntax)reader.ReadValue();
            AdjustFlagsAndWidth(expression);
            this.expression = expression;
            var closeParenToken = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(closeParenToken);
            this.closeParenToken = closeParenToken;
        }

        internal override void WriteTo(ObjectWriter writer)
        {
            base.WriteTo(writer);
            writer.WriteValue(this.keyword);
            writer.WriteValue(this.openParenToken);
            writer.WriteValue(this.expression);
            writer.WriteValue(this.closeParenToken);
        }

        static CheckedExpressionSyntax()
        {
            ObjectBinder.RegisterTypeReader(typeof(CheckedExpressionSyntax), r => new CheckedExpressionSyntax(r));
        }
    }

    /// <summary>Class which represents the syntax node for Default expression.</summary>
    internal sealed partial class DefaultExpressionSyntax : ExpressionSyntax
    {
        internal readonly SyntaxToken keyword;
        internal readonly SyntaxToken openParenToken;
        internal readonly TypeSyntax type;
        internal readonly SyntaxToken closeParenToken;

        internal DefaultExpressionSyntax(SyntaxKind kind, SyntaxToken keyword, SyntaxToken openParenToken, TypeSyntax type, SyntaxToken closeParenToken, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
            this.SlotCount = 4;
            this.AdjustFlagsAndWidth(keyword);
            this.keyword = keyword;
            this.AdjustFlagsAndWidth(openParenToken);
            this.openParenToken = openParenToken;
            this.AdjustFlagsAndWidth(type);
            this.type = type;
            this.AdjustFlagsAndWidth(closeParenToken);
            this.closeParenToken = closeParenToken;
        }

        internal DefaultExpressionSyntax(SyntaxKind kind, SyntaxToken keyword, SyntaxToken openParenToken, TypeSyntax type, SyntaxToken closeParenToken, SyntaxFactoryContext context)
          : base(kind)
        {
            this.SetFactoryContext(context);
            this.SlotCount = 4;
            this.AdjustFlagsAndWidth(keyword);
            this.keyword = keyword;
            this.AdjustFlagsAndWidth(openParenToken);
            this.openParenToken = openParenToken;
            this.AdjustFlagsAndWidth(type);
            this.type = type;
            this.AdjustFlagsAndWidth(closeParenToken);
            this.closeParenToken = closeParenToken;
        }

        internal DefaultExpressionSyntax(SyntaxKind kind, SyntaxToken keyword, SyntaxToken openParenToken, TypeSyntax type, SyntaxToken closeParenToken)
          : base(kind)
        {
            this.SlotCount = 4;
            this.AdjustFlagsAndWidth(keyword);
            this.keyword = keyword;
            this.AdjustFlagsAndWidth(openParenToken);
            this.openParenToken = openParenToken;
            this.AdjustFlagsAndWidth(type);
            this.type = type;
            this.AdjustFlagsAndWidth(closeParenToken);
            this.closeParenToken = closeParenToken;
        }

        /// <summary>SyntaxToken representing the DefaultKeyword.</summary>
        public SyntaxToken Keyword => this.keyword;
        /// <summary>SyntaxToken representing open parenthesis.</summary>
        public SyntaxToken OpenParenToken => this.openParenToken;
        /// <summary>Argument of the primary function.</summary>
        public TypeSyntax Type => this.type;
        /// <summary>SyntaxToken representing close parenthesis.</summary>
        public SyntaxToken CloseParenToken => this.closeParenToken;

        internal override GreenNode? GetSlot(int index)
            => index switch
            {
                0 => this.keyword,
                1 => this.openParenToken,
                2 => this.type,
                3 => this.closeParenToken,
                _ => null,
            };

        internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new CSharp.Syntax.DefaultExpressionSyntax(this, parent, position);

        public override void Accept(CSharpSyntaxVisitor visitor) => visitor.VisitDefaultExpression(this);
        public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor) => visitor.VisitDefaultExpression(this);

        public DefaultExpressionSyntax Update(SyntaxToken keyword, SyntaxToken openParenToken, TypeSyntax type, SyntaxToken closeParenToken)
        {
            if (keyword != this.Keyword || openParenToken != this.OpenParenToken || type != this.Type || closeParenToken != this.CloseParenToken)
            {
                var newNode = SyntaxFactory.DefaultExpression(keyword, openParenToken, type, closeParenToken);
                var diags = GetDiagnostics();
                if (diags?.Length > 0)
                    newNode = newNode.WithDiagnosticsGreen(diags);
                var annotations = GetAnnotations();
                if (annotations?.Length > 0)
                    newNode = newNode.WithAnnotationsGreen(annotations);
                return newNode;
            }

            return this;
        }

        internal override GreenNode SetDiagnostics(DiagnosticInfo[]? diagnostics)
            => new DefaultExpressionSyntax(this.Kind, this.keyword, this.openParenToken, this.type, this.closeParenToken, diagnostics, GetAnnotations());

        internal override GreenNode SetAnnotations(SyntaxAnnotation[]? annotations)
            => new DefaultExpressionSyntax(this.Kind, this.keyword, this.openParenToken, this.type, this.closeParenToken, GetDiagnostics(), annotations);

        internal DefaultExpressionSyntax(ObjectReader reader)
          : base(reader)
        {
            this.SlotCount = 4;
            var keyword = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(keyword);
            this.keyword = keyword;
            var openParenToken = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(openParenToken);
            this.openParenToken = openParenToken;
            var type = (TypeSyntax)reader.ReadValue();
            AdjustFlagsAndWidth(type);
            this.type = type;
            var closeParenToken = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(closeParenToken);
            this.closeParenToken = closeParenToken;
        }

        internal override void WriteTo(ObjectWriter writer)
        {
            base.WriteTo(writer);
            writer.WriteValue(this.keyword);
            writer.WriteValue(this.openParenToken);
            writer.WriteValue(this.type);
            writer.WriteValue(this.closeParenToken);
        }

        static DefaultExpressionSyntax()
        {
            ObjectBinder.RegisterTypeReader(typeof(DefaultExpressionSyntax), r => new DefaultExpressionSyntax(r));
        }
    }

    /// <summary>Class which represents the syntax node for TypeOf expression.</summary>
    internal sealed partial class TypeOfExpressionSyntax : ExpressionSyntax
    {
        internal readonly SyntaxToken keyword;
        internal readonly SyntaxToken openParenToken;
        internal readonly TypeSyntax type;
        internal readonly SyntaxToken closeParenToken;

        internal TypeOfExpressionSyntax(SyntaxKind kind, SyntaxToken keyword, SyntaxToken openParenToken, TypeSyntax type, SyntaxToken closeParenToken, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
            this.SlotCount = 4;
            this.AdjustFlagsAndWidth(keyword);
            this.keyword = keyword;
            this.AdjustFlagsAndWidth(openParenToken);
            this.openParenToken = openParenToken;
            this.AdjustFlagsAndWidth(type);
            this.type = type;
            this.AdjustFlagsAndWidth(closeParenToken);
            this.closeParenToken = closeParenToken;
        }

        internal TypeOfExpressionSyntax(SyntaxKind kind, SyntaxToken keyword, SyntaxToken openParenToken, TypeSyntax type, SyntaxToken closeParenToken, SyntaxFactoryContext context)
          : base(kind)
        {
            this.SetFactoryContext(context);
            this.SlotCount = 4;
            this.AdjustFlagsAndWidth(keyword);
            this.keyword = keyword;
            this.AdjustFlagsAndWidth(openParenToken);
            this.openParenToken = openParenToken;
            this.AdjustFlagsAndWidth(type);
            this.type = type;
            this.AdjustFlagsAndWidth(closeParenToken);
            this.closeParenToken = closeParenToken;
        }

        internal TypeOfExpressionSyntax(SyntaxKind kind, SyntaxToken keyword, SyntaxToken openParenToken, TypeSyntax type, SyntaxToken closeParenToken)
          : base(kind)
        {
            this.SlotCount = 4;
            this.AdjustFlagsAndWidth(keyword);
            this.keyword = keyword;
            this.AdjustFlagsAndWidth(openParenToken);
            this.openParenToken = openParenToken;
            this.AdjustFlagsAndWidth(type);
            this.type = type;
            this.AdjustFlagsAndWidth(closeParenToken);
            this.closeParenToken = closeParenToken;
        }

        /// <summary>SyntaxToken representing the TypeOfKeyword.</summary>
        public SyntaxToken Keyword => this.keyword;
        /// <summary>SyntaxToken representing open parenthesis.</summary>
        public SyntaxToken OpenParenToken => this.openParenToken;
        /// <summary>The expression to return type of.</summary>
        public TypeSyntax Type => this.type;
        /// <summary>SyntaxToken representing close parenthesis.</summary>
        public SyntaxToken CloseParenToken => this.closeParenToken;

        internal override GreenNode? GetSlot(int index)
            => index switch
            {
                0 => this.keyword,
                1 => this.openParenToken,
                2 => this.type,
                3 => this.closeParenToken,
                _ => null,
            };

        internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new CSharp.Syntax.TypeOfExpressionSyntax(this, parent, position);

        public override void Accept(CSharpSyntaxVisitor visitor) => visitor.VisitTypeOfExpression(this);
        public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor) => visitor.VisitTypeOfExpression(this);

        public TypeOfExpressionSyntax Update(SyntaxToken keyword, SyntaxToken openParenToken, TypeSyntax type, SyntaxToken closeParenToken)
        {
            if (keyword != this.Keyword || openParenToken != this.OpenParenToken || type != this.Type || closeParenToken != this.CloseParenToken)
            {
                var newNode = SyntaxFactory.TypeOfExpression(keyword, openParenToken, type, closeParenToken);
                var diags = GetDiagnostics();
                if (diags?.Length > 0)
                    newNode = newNode.WithDiagnosticsGreen(diags);
                var annotations = GetAnnotations();
                if (annotations?.Length > 0)
                    newNode = newNode.WithAnnotationsGreen(annotations);
                return newNode;
            }

            return this;
        }

        internal override GreenNode SetDiagnostics(DiagnosticInfo[]? diagnostics)
            => new TypeOfExpressionSyntax(this.Kind, this.keyword, this.openParenToken, this.type, this.closeParenToken, diagnostics, GetAnnotations());

        internal override GreenNode SetAnnotations(SyntaxAnnotation[]? annotations)
            => new TypeOfExpressionSyntax(this.Kind, this.keyword, this.openParenToken, this.type, this.closeParenToken, GetDiagnostics(), annotations);

        internal TypeOfExpressionSyntax(ObjectReader reader)
          : base(reader)
        {
            this.SlotCount = 4;
            var keyword = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(keyword);
            this.keyword = keyword;
            var openParenToken = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(openParenToken);
            this.openParenToken = openParenToken;
            var type = (TypeSyntax)reader.ReadValue();
            AdjustFlagsAndWidth(type);
            this.type = type;
            var closeParenToken = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(closeParenToken);
            this.closeParenToken = closeParenToken;
        }

        internal override void WriteTo(ObjectWriter writer)
        {
            base.WriteTo(writer);
            writer.WriteValue(this.keyword);
            writer.WriteValue(this.openParenToken);
            writer.WriteValue(this.type);
            writer.WriteValue(this.closeParenToken);
        }

        static TypeOfExpressionSyntax()
        {
            ObjectBinder.RegisterTypeReader(typeof(TypeOfExpressionSyntax), r => new TypeOfExpressionSyntax(r));
        }
    }

    /// <summary>Class which represents the syntax node for SizeOf expression.</summary>
    internal sealed partial class SizeOfExpressionSyntax : ExpressionSyntax
    {
        internal readonly SyntaxToken keyword;
        internal readonly SyntaxToken openParenToken;
        internal readonly TypeSyntax type;
        internal readonly SyntaxToken closeParenToken;

        internal SizeOfExpressionSyntax(SyntaxKind kind, SyntaxToken keyword, SyntaxToken openParenToken, TypeSyntax type, SyntaxToken closeParenToken, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
            this.SlotCount = 4;
            this.AdjustFlagsAndWidth(keyword);
            this.keyword = keyword;
            this.AdjustFlagsAndWidth(openParenToken);
            this.openParenToken = openParenToken;
            this.AdjustFlagsAndWidth(type);
            this.type = type;
            this.AdjustFlagsAndWidth(closeParenToken);
            this.closeParenToken = closeParenToken;
        }

        internal SizeOfExpressionSyntax(SyntaxKind kind, SyntaxToken keyword, SyntaxToken openParenToken, TypeSyntax type, SyntaxToken closeParenToken, SyntaxFactoryContext context)
          : base(kind)
        {
            this.SetFactoryContext(context);
            this.SlotCount = 4;
            this.AdjustFlagsAndWidth(keyword);
            this.keyword = keyword;
            this.AdjustFlagsAndWidth(openParenToken);
            this.openParenToken = openParenToken;
            this.AdjustFlagsAndWidth(type);
            this.type = type;
            this.AdjustFlagsAndWidth(closeParenToken);
            this.closeParenToken = closeParenToken;
        }

        internal SizeOfExpressionSyntax(SyntaxKind kind, SyntaxToken keyword, SyntaxToken openParenToken, TypeSyntax type, SyntaxToken closeParenToken)
          : base(kind)
        {
            this.SlotCount = 4;
            this.AdjustFlagsAndWidth(keyword);
            this.keyword = keyword;
            this.AdjustFlagsAndWidth(openParenToken);
            this.openParenToken = openParenToken;
            this.AdjustFlagsAndWidth(type);
            this.type = type;
            this.AdjustFlagsAndWidth(closeParenToken);
            this.closeParenToken = closeParenToken;
        }

        /// <summary>SyntaxToken representing the SizeOfKeyword.</summary>
        public SyntaxToken Keyword => this.keyword;
        /// <summary>SyntaxToken representing open parenthesis.</summary>
        public SyntaxToken OpenParenToken => this.openParenToken;
        /// <summary>Argument of the primary function.</summary>
        public TypeSyntax Type => this.type;
        /// <summary>SyntaxToken representing close parenthesis.</summary>
        public SyntaxToken CloseParenToken => this.closeParenToken;

        internal override GreenNode? GetSlot(int index)
            => index switch
            {
                0 => this.keyword,
                1 => this.openParenToken,
                2 => this.type,
                3 => this.closeParenToken,
                _ => null,
            };

        internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new CSharp.Syntax.SizeOfExpressionSyntax(this, parent, position);

        public override void Accept(CSharpSyntaxVisitor visitor) => visitor.VisitSizeOfExpression(this);
        public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor) => visitor.VisitSizeOfExpression(this);

        public SizeOfExpressionSyntax Update(SyntaxToken keyword, SyntaxToken openParenToken, TypeSyntax type, SyntaxToken closeParenToken)
        {
            if (keyword != this.Keyword || openParenToken != this.OpenParenToken || type != this.Type || closeParenToken != this.CloseParenToken)
            {
                var newNode = SyntaxFactory.SizeOfExpression(keyword, openParenToken, type, closeParenToken);
                var diags = GetDiagnostics();
                if (diags?.Length > 0)
                    newNode = newNode.WithDiagnosticsGreen(diags);
                var annotations = GetAnnotations();
                if (annotations?.Length > 0)
                    newNode = newNode.WithAnnotationsGreen(annotations);
                return newNode;
            }

            return this;
        }

        internal override GreenNode SetDiagnostics(DiagnosticInfo[]? diagnostics)
            => new SizeOfExpressionSyntax(this.Kind, this.keyword, this.openParenToken, this.type, this.closeParenToken, diagnostics, GetAnnotations());

        internal override GreenNode SetAnnotations(SyntaxAnnotation[]? annotations)
            => new SizeOfExpressionSyntax(this.Kind, this.keyword, this.openParenToken, this.type, this.closeParenToken, GetDiagnostics(), annotations);

        internal SizeOfExpressionSyntax(ObjectReader reader)
          : base(reader)
        {
            this.SlotCount = 4;
            var keyword = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(keyword);
            this.keyword = keyword;
            var openParenToken = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(openParenToken);
            this.openParenToken = openParenToken;
            var type = (TypeSyntax)reader.ReadValue();
            AdjustFlagsAndWidth(type);
            this.type = type;
            var closeParenToken = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(closeParenToken);
            this.closeParenToken = closeParenToken;
        }

        internal override void WriteTo(ObjectWriter writer)
        {
            base.WriteTo(writer);
            writer.WriteValue(this.keyword);
            writer.WriteValue(this.openParenToken);
            writer.WriteValue(this.type);
            writer.WriteValue(this.closeParenToken);
        }

        static SizeOfExpressionSyntax()
        {
            ObjectBinder.RegisterTypeReader(typeof(SizeOfExpressionSyntax), r => new SizeOfExpressionSyntax(r));
        }
    }

    /// <summary>Class which represents the syntax node for invocation expression.</summary>
    internal sealed partial class InvocationExpressionSyntax : ExpressionSyntax
    {
        internal readonly ExpressionSyntax expression;
        internal readonly ArgumentListSyntax argumentList;

        internal InvocationExpressionSyntax(SyntaxKind kind, ExpressionSyntax expression, ArgumentListSyntax argumentList, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
            this.SlotCount = 2;
            this.AdjustFlagsAndWidth(expression);
            this.expression = expression;
            this.AdjustFlagsAndWidth(argumentList);
            this.argumentList = argumentList;
        }

        internal InvocationExpressionSyntax(SyntaxKind kind, ExpressionSyntax expression, ArgumentListSyntax argumentList, SyntaxFactoryContext context)
          : base(kind)
        {
            this.SetFactoryContext(context);
            this.SlotCount = 2;
            this.AdjustFlagsAndWidth(expression);
            this.expression = expression;
            this.AdjustFlagsAndWidth(argumentList);
            this.argumentList = argumentList;
        }

        internal InvocationExpressionSyntax(SyntaxKind kind, ExpressionSyntax expression, ArgumentListSyntax argumentList)
          : base(kind)
        {
            this.SlotCount = 2;
            this.AdjustFlagsAndWidth(expression);
            this.expression = expression;
            this.AdjustFlagsAndWidth(argumentList);
            this.argumentList = argumentList;
        }

        /// <summary>ExpressionSyntax node representing the expression part of the invocation.</summary>
        public ExpressionSyntax Expression => this.expression;
        /// <summary>ArgumentListSyntax node representing the list of arguments of the invocation expression.</summary>
        public ArgumentListSyntax ArgumentList => this.argumentList;

        internal override GreenNode? GetSlot(int index)
            => index switch
            {
                0 => this.expression,
                1 => this.argumentList,
                _ => null,
            };

        internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new CSharp.Syntax.InvocationExpressionSyntax(this, parent, position);

        public override void Accept(CSharpSyntaxVisitor visitor) => visitor.VisitInvocationExpression(this);
        public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor) => visitor.VisitInvocationExpression(this);

        public InvocationExpressionSyntax Update(ExpressionSyntax expression, ArgumentListSyntax argumentList)
        {
            if (expression != this.Expression || argumentList != this.ArgumentList)
            {
                var newNode = SyntaxFactory.InvocationExpression(expression, argumentList);
                var diags = GetDiagnostics();
                if (diags?.Length > 0)
                    newNode = newNode.WithDiagnosticsGreen(diags);
                var annotations = GetAnnotations();
                if (annotations?.Length > 0)
                    newNode = newNode.WithAnnotationsGreen(annotations);
                return newNode;
            }

            return this;
        }

        internal override GreenNode SetDiagnostics(DiagnosticInfo[]? diagnostics)
            => new InvocationExpressionSyntax(this.Kind, this.expression, this.argumentList, diagnostics, GetAnnotations());

        internal override GreenNode SetAnnotations(SyntaxAnnotation[]? annotations)
            => new InvocationExpressionSyntax(this.Kind, this.expression, this.argumentList, GetDiagnostics(), annotations);

        internal InvocationExpressionSyntax(ObjectReader reader)
          : base(reader)
        {
            this.SlotCount = 2;
            var expression = (ExpressionSyntax)reader.ReadValue();
            AdjustFlagsAndWidth(expression);
            this.expression = expression;
            var argumentList = (ArgumentListSyntax)reader.ReadValue();
            AdjustFlagsAndWidth(argumentList);
            this.argumentList = argumentList;
        }

        internal override void WriteTo(ObjectWriter writer)
        {
            base.WriteTo(writer);
            writer.WriteValue(this.expression);
            writer.WriteValue(this.argumentList);
        }

        static InvocationExpressionSyntax()
        {
            ObjectBinder.RegisterTypeReader(typeof(InvocationExpressionSyntax), r => new InvocationExpressionSyntax(r));
        }
    }

    /// <summary>Class which represents the syntax node for element access expression.</summary>
    internal sealed partial class ElementAccessExpressionSyntax : ExpressionSyntax
    {
        internal readonly ExpressionSyntax expression;
        internal readonly BracketedArgumentListSyntax argumentList;

        internal ElementAccessExpressionSyntax(SyntaxKind kind, ExpressionSyntax expression, BracketedArgumentListSyntax argumentList, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
            this.SlotCount = 2;
            this.AdjustFlagsAndWidth(expression);
            this.expression = expression;
            this.AdjustFlagsAndWidth(argumentList);
            this.argumentList = argumentList;
        }

        internal ElementAccessExpressionSyntax(SyntaxKind kind, ExpressionSyntax expression, BracketedArgumentListSyntax argumentList, SyntaxFactoryContext context)
          : base(kind)
        {
            this.SetFactoryContext(context);
            this.SlotCount = 2;
            this.AdjustFlagsAndWidth(expression);
            this.expression = expression;
            this.AdjustFlagsAndWidth(argumentList);
            this.argumentList = argumentList;
        }

        internal ElementAccessExpressionSyntax(SyntaxKind kind, ExpressionSyntax expression, BracketedArgumentListSyntax argumentList)
          : base(kind)
        {
            this.SlotCount = 2;
            this.AdjustFlagsAndWidth(expression);
            this.expression = expression;
            this.AdjustFlagsAndWidth(argumentList);
            this.argumentList = argumentList;
        }

        /// <summary>ExpressionSyntax node representing the expression which is accessing the element.</summary>
        public ExpressionSyntax Expression => this.expression;
        /// <summary>BracketedArgumentListSyntax node representing the list of arguments of the element access expression.</summary>
        public BracketedArgumentListSyntax ArgumentList => this.argumentList;

        internal override GreenNode? GetSlot(int index)
            => index switch
            {
                0 => this.expression,
                1 => this.argumentList,
                _ => null,
            };

        internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new CSharp.Syntax.ElementAccessExpressionSyntax(this, parent, position);

        public override void Accept(CSharpSyntaxVisitor visitor) => visitor.VisitElementAccessExpression(this);
        public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor) => visitor.VisitElementAccessExpression(this);

        public ElementAccessExpressionSyntax Update(ExpressionSyntax expression, BracketedArgumentListSyntax argumentList)
        {
            if (expression != this.Expression || argumentList != this.ArgumentList)
            {
                var newNode = SyntaxFactory.ElementAccessExpression(expression, argumentList);
                var diags = GetDiagnostics();
                if (diags?.Length > 0)
                    newNode = newNode.WithDiagnosticsGreen(diags);
                var annotations = GetAnnotations();
                if (annotations?.Length > 0)
                    newNode = newNode.WithAnnotationsGreen(annotations);
                return newNode;
            }

            return this;
        }

        internal override GreenNode SetDiagnostics(DiagnosticInfo[]? diagnostics)
            => new ElementAccessExpressionSyntax(this.Kind, this.expression, this.argumentList, diagnostics, GetAnnotations());

        internal override GreenNode SetAnnotations(SyntaxAnnotation[]? annotations)
            => new ElementAccessExpressionSyntax(this.Kind, this.expression, this.argumentList, GetDiagnostics(), annotations);

        internal ElementAccessExpressionSyntax(ObjectReader reader)
          : base(reader)
        {
            this.SlotCount = 2;
            var expression = (ExpressionSyntax)reader.ReadValue();
            AdjustFlagsAndWidth(expression);
            this.expression = expression;
            var argumentList = (BracketedArgumentListSyntax)reader.ReadValue();
            AdjustFlagsAndWidth(argumentList);
            this.argumentList = argumentList;
        }

        internal override void WriteTo(ObjectWriter writer)
        {
            base.WriteTo(writer);
            writer.WriteValue(this.expression);
            writer.WriteValue(this.argumentList);
        }

        static ElementAccessExpressionSyntax()
        {
            ObjectBinder.RegisterTypeReader(typeof(ElementAccessExpressionSyntax), r => new ElementAccessExpressionSyntax(r));
        }
    }

    /// <summary>Provides the base class from which the classes that represent argument list syntax nodes are derived. This is an abstract class.</summary>
    internal abstract partial class BaseArgumentListSyntax : CSharpSyntaxNode
    {
        internal BaseArgumentListSyntax(SyntaxKind kind, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
        }

        internal BaseArgumentListSyntax(SyntaxKind kind)
          : base(kind)
        {
        }

        protected BaseArgumentListSyntax(ObjectReader reader)
          : base(reader)
        {
        }

        /// <summary>SeparatedSyntaxList of ArgumentSyntax nodes representing the list of arguments.</summary>
        public abstract Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<ArgumentSyntax> Arguments { get; }
    }

    /// <summary>Class which represents the syntax node for the list of arguments.</summary>
    internal sealed partial class ArgumentListSyntax : BaseArgumentListSyntax
    {
        internal readonly SyntaxToken openParenToken;
        internal readonly GreenNode? arguments;
        internal readonly SyntaxToken closeParenToken;

        internal ArgumentListSyntax(SyntaxKind kind, SyntaxToken openParenToken, GreenNode? arguments, SyntaxToken closeParenToken, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
            this.SlotCount = 3;
            this.AdjustFlagsAndWidth(openParenToken);
            this.openParenToken = openParenToken;
            if (arguments != null)
            {
                this.AdjustFlagsAndWidth(arguments);
                this.arguments = arguments;
            }
            this.AdjustFlagsAndWidth(closeParenToken);
            this.closeParenToken = closeParenToken;
        }

        internal ArgumentListSyntax(SyntaxKind kind, SyntaxToken openParenToken, GreenNode? arguments, SyntaxToken closeParenToken, SyntaxFactoryContext context)
          : base(kind)
        {
            this.SetFactoryContext(context);
            this.SlotCount = 3;
            this.AdjustFlagsAndWidth(openParenToken);
            this.openParenToken = openParenToken;
            if (arguments != null)
            {
                this.AdjustFlagsAndWidth(arguments);
                this.arguments = arguments;
            }
            this.AdjustFlagsAndWidth(closeParenToken);
            this.closeParenToken = closeParenToken;
        }

        internal ArgumentListSyntax(SyntaxKind kind, SyntaxToken openParenToken, GreenNode? arguments, SyntaxToken closeParenToken)
          : base(kind)
        {
            this.SlotCount = 3;
            this.AdjustFlagsAndWidth(openParenToken);
            this.openParenToken = openParenToken;
            if (arguments != null)
            {
                this.AdjustFlagsAndWidth(arguments);
                this.arguments = arguments;
            }
            this.AdjustFlagsAndWidth(closeParenToken);
            this.closeParenToken = closeParenToken;
        }

        /// <summary>SyntaxToken representing open parenthesis.</summary>
        public SyntaxToken OpenParenToken => this.openParenToken;
        /// <summary>SeparatedSyntaxList of ArgumentSyntax representing the list of arguments.</summary>
        public override Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<ArgumentSyntax> Arguments => new Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<ArgumentSyntax>(new Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<CSharpSyntaxNode>(this.arguments));
        /// <summary>SyntaxToken representing close parenthesis.</summary>
        public SyntaxToken CloseParenToken => this.closeParenToken;

        internal override GreenNode? GetSlot(int index)
            => index switch
            {
                0 => this.openParenToken,
                1 => this.arguments,
                2 => this.closeParenToken,
                _ => null,
            };

        internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new CSharp.Syntax.ArgumentListSyntax(this, parent, position);

        public override void Accept(CSharpSyntaxVisitor visitor) => visitor.VisitArgumentList(this);
        public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor) => visitor.VisitArgumentList(this);

        public ArgumentListSyntax Update(SyntaxToken openParenToken, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<ArgumentSyntax> arguments, SyntaxToken closeParenToken)
        {
            if (openParenToken != this.OpenParenToken || arguments != this.Arguments || closeParenToken != this.CloseParenToken)
            {
                var newNode = SyntaxFactory.ArgumentList(openParenToken, arguments, closeParenToken);
                var diags = GetDiagnostics();
                if (diags?.Length > 0)
                    newNode = newNode.WithDiagnosticsGreen(diags);
                var annotations = GetAnnotations();
                if (annotations?.Length > 0)
                    newNode = newNode.WithAnnotationsGreen(annotations);
                return newNode;
            }

            return this;
        }

        internal override GreenNode SetDiagnostics(DiagnosticInfo[]? diagnostics)
            => new ArgumentListSyntax(this.Kind, this.openParenToken, this.arguments, this.closeParenToken, diagnostics, GetAnnotations());

        internal override GreenNode SetAnnotations(SyntaxAnnotation[]? annotations)
            => new ArgumentListSyntax(this.Kind, this.openParenToken, this.arguments, this.closeParenToken, GetDiagnostics(), annotations);

        internal ArgumentListSyntax(ObjectReader reader)
          : base(reader)
        {
            this.SlotCount = 3;
            var openParenToken = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(openParenToken);
            this.openParenToken = openParenToken;
            var arguments = (GreenNode?)reader.ReadValue();
            if (arguments != null)
            {
                AdjustFlagsAndWidth(arguments);
                this.arguments = arguments;
            }
            var closeParenToken = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(closeParenToken);
            this.closeParenToken = closeParenToken;
        }

        internal override void WriteTo(ObjectWriter writer)
        {
            base.WriteTo(writer);
            writer.WriteValue(this.openParenToken);
            writer.WriteValue(this.arguments);
            writer.WriteValue(this.closeParenToken);
        }

        static ArgumentListSyntax()
        {
            ObjectBinder.RegisterTypeReader(typeof(ArgumentListSyntax), r => new ArgumentListSyntax(r));
        }
    }

    /// <summary>Class which represents the syntax node for bracketed argument list.</summary>
    internal sealed partial class BracketedArgumentListSyntax : BaseArgumentListSyntax
    {
        internal readonly SyntaxToken openBracketToken;
        internal readonly GreenNode? arguments;
        internal readonly SyntaxToken closeBracketToken;

        internal BracketedArgumentListSyntax(SyntaxKind kind, SyntaxToken openBracketToken, GreenNode? arguments, SyntaxToken closeBracketToken, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
            this.SlotCount = 3;
            this.AdjustFlagsAndWidth(openBracketToken);
            this.openBracketToken = openBracketToken;
            if (arguments != null)
            {
                this.AdjustFlagsAndWidth(arguments);
                this.arguments = arguments;
            }
            this.AdjustFlagsAndWidth(closeBracketToken);
            this.closeBracketToken = closeBracketToken;
        }

        internal BracketedArgumentListSyntax(SyntaxKind kind, SyntaxToken openBracketToken, GreenNode? arguments, SyntaxToken closeBracketToken, SyntaxFactoryContext context)
          : base(kind)
        {
            this.SetFactoryContext(context);
            this.SlotCount = 3;
            this.AdjustFlagsAndWidth(openBracketToken);
            this.openBracketToken = openBracketToken;
            if (arguments != null)
            {
                this.AdjustFlagsAndWidth(arguments);
                this.arguments = arguments;
            }
            this.AdjustFlagsAndWidth(closeBracketToken);
            this.closeBracketToken = closeBracketToken;
        }

        internal BracketedArgumentListSyntax(SyntaxKind kind, SyntaxToken openBracketToken, GreenNode? arguments, SyntaxToken closeBracketToken)
          : base(kind)
        {
            this.SlotCount = 3;
            this.AdjustFlagsAndWidth(openBracketToken);
            this.openBracketToken = openBracketToken;
            if (arguments != null)
            {
                this.AdjustFlagsAndWidth(arguments);
                this.arguments = arguments;
            }
            this.AdjustFlagsAndWidth(closeBracketToken);
            this.closeBracketToken = closeBracketToken;
        }

        /// <summary>SyntaxToken representing open bracket.</summary>
        public SyntaxToken OpenBracketToken => this.openBracketToken;
        /// <summary>SeparatedSyntaxList of ArgumentSyntax representing the list of arguments.</summary>
        public override Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<ArgumentSyntax> Arguments => new Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<ArgumentSyntax>(new Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<CSharpSyntaxNode>(this.arguments));
        /// <summary>SyntaxToken representing close bracket.</summary>
        public SyntaxToken CloseBracketToken => this.closeBracketToken;

        internal override GreenNode? GetSlot(int index)
            => index switch
            {
                0 => this.openBracketToken,
                1 => this.arguments,
                2 => this.closeBracketToken,
                _ => null,
            };

        internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new CSharp.Syntax.BracketedArgumentListSyntax(this, parent, position);

        public override void Accept(CSharpSyntaxVisitor visitor) => visitor.VisitBracketedArgumentList(this);
        public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor) => visitor.VisitBracketedArgumentList(this);

        public BracketedArgumentListSyntax Update(SyntaxToken openBracketToken, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<ArgumentSyntax> arguments, SyntaxToken closeBracketToken)
        {
            if (openBracketToken != this.OpenBracketToken || arguments != this.Arguments || closeBracketToken != this.CloseBracketToken)
            {
                var newNode = SyntaxFactory.BracketedArgumentList(openBracketToken, arguments, closeBracketToken);
                var diags = GetDiagnostics();
                if (diags?.Length > 0)
                    newNode = newNode.WithDiagnosticsGreen(diags);
                var annotations = GetAnnotations();
                if (annotations?.Length > 0)
                    newNode = newNode.WithAnnotationsGreen(annotations);
                return newNode;
            }

            return this;
        }

        internal override GreenNode SetDiagnostics(DiagnosticInfo[]? diagnostics)
            => new BracketedArgumentListSyntax(this.Kind, this.openBracketToken, this.arguments, this.closeBracketToken, diagnostics, GetAnnotations());

        internal override GreenNode SetAnnotations(SyntaxAnnotation[]? annotations)
            => new BracketedArgumentListSyntax(this.Kind, this.openBracketToken, this.arguments, this.closeBracketToken, GetDiagnostics(), annotations);

        internal BracketedArgumentListSyntax(ObjectReader reader)
          : base(reader)
        {
            this.SlotCount = 3;
            var openBracketToken = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(openBracketToken);
            this.openBracketToken = openBracketToken;
            var arguments = (GreenNode?)reader.ReadValue();
            if (arguments != null)
            {
                AdjustFlagsAndWidth(arguments);
                this.arguments = arguments;
            }
            var closeBracketToken = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(closeBracketToken);
            this.closeBracketToken = closeBracketToken;
        }

        internal override void WriteTo(ObjectWriter writer)
        {
            base.WriteTo(writer);
            writer.WriteValue(this.openBracketToken);
            writer.WriteValue(this.arguments);
            writer.WriteValue(this.closeBracketToken);
        }

        static BracketedArgumentListSyntax()
        {
            ObjectBinder.RegisterTypeReader(typeof(BracketedArgumentListSyntax), r => new BracketedArgumentListSyntax(r));
        }
    }

    /// <summary>Class which represents the syntax node for argument.</summary>
    internal sealed partial class ArgumentSyntax : CSharpSyntaxNode
    {
        internal readonly NameColonSyntax? nameColon;
        internal readonly SyntaxToken? refKindKeyword;
        internal readonly ExpressionSyntax expression;

        internal ArgumentSyntax(SyntaxKind kind, NameColonSyntax? nameColon, SyntaxToken? refKindKeyword, ExpressionSyntax expression, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
            this.SlotCount = 3;
            if (nameColon != null)
            {
                this.AdjustFlagsAndWidth(nameColon);
                this.nameColon = nameColon;
            }
            if (refKindKeyword != null)
            {
                this.AdjustFlagsAndWidth(refKindKeyword);
                this.refKindKeyword = refKindKeyword;
            }
            this.AdjustFlagsAndWidth(expression);
            this.expression = expression;
        }

        internal ArgumentSyntax(SyntaxKind kind, NameColonSyntax? nameColon, SyntaxToken? refKindKeyword, ExpressionSyntax expression, SyntaxFactoryContext context)
          : base(kind)
        {
            this.SetFactoryContext(context);
            this.SlotCount = 3;
            if (nameColon != null)
            {
                this.AdjustFlagsAndWidth(nameColon);
                this.nameColon = nameColon;
            }
            if (refKindKeyword != null)
            {
                this.AdjustFlagsAndWidth(refKindKeyword);
                this.refKindKeyword = refKindKeyword;
            }
            this.AdjustFlagsAndWidth(expression);
            this.expression = expression;
        }

        internal ArgumentSyntax(SyntaxKind kind, NameColonSyntax? nameColon, SyntaxToken? refKindKeyword, ExpressionSyntax expression)
          : base(kind)
        {
            this.SlotCount = 3;
            if (nameColon != null)
            {
                this.AdjustFlagsAndWidth(nameColon);
                this.nameColon = nameColon;
            }
            if (refKindKeyword != null)
            {
                this.AdjustFlagsAndWidth(refKindKeyword);
                this.refKindKeyword = refKindKeyword;
            }
            this.AdjustFlagsAndWidth(expression);
            this.expression = expression;
        }

        /// <summary>NameColonSyntax node representing the optional name arguments.</summary>
        public NameColonSyntax? NameColon => this.nameColon;
        /// <summary>SyntaxToken representing the optional ref or out keyword.</summary>
        public SyntaxToken? RefKindKeyword => this.refKindKeyword;
        /// <summary>ExpressionSyntax node representing the argument.</summary>
        public ExpressionSyntax Expression => this.expression;

        internal override GreenNode? GetSlot(int index)
            => index switch
            {
                0 => this.nameColon,
                1 => this.refKindKeyword,
                2 => this.expression,
                _ => null,
            };

        internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new CSharp.Syntax.ArgumentSyntax(this, parent, position);

        public override void Accept(CSharpSyntaxVisitor visitor) => visitor.VisitArgument(this);
        public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor) => visitor.VisitArgument(this);

        public ArgumentSyntax Update(NameColonSyntax nameColon, SyntaxToken refKindKeyword, ExpressionSyntax expression)
        {
            if (nameColon != this.NameColon || refKindKeyword != this.RefKindKeyword || expression != this.Expression)
            {
                var newNode = SyntaxFactory.Argument(nameColon, refKindKeyword, expression);
                var diags = GetDiagnostics();
                if (diags?.Length > 0)
                    newNode = newNode.WithDiagnosticsGreen(diags);
                var annotations = GetAnnotations();
                if (annotations?.Length > 0)
                    newNode = newNode.WithAnnotationsGreen(annotations);
                return newNode;
            }

            return this;
        }

        internal override GreenNode SetDiagnostics(DiagnosticInfo[]? diagnostics)
            => new ArgumentSyntax(this.Kind, this.nameColon, this.refKindKeyword, this.expression, diagnostics, GetAnnotations());

        internal override GreenNode SetAnnotations(SyntaxAnnotation[]? annotations)
            => new ArgumentSyntax(this.Kind, this.nameColon, this.refKindKeyword, this.expression, GetDiagnostics(), annotations);

        internal ArgumentSyntax(ObjectReader reader)
          : base(reader)
        {
            this.SlotCount = 3;
            var nameColon = (NameColonSyntax?)reader.ReadValue();
            if (nameColon != null)
            {
                AdjustFlagsAndWidth(nameColon);
                this.nameColon = nameColon;
            }
            var refKindKeyword = (SyntaxToken?)reader.ReadValue();
            if (refKindKeyword != null)
            {
                AdjustFlagsAndWidth(refKindKeyword);
                this.refKindKeyword = refKindKeyword;
            }
            var expression = (ExpressionSyntax)reader.ReadValue();
            AdjustFlagsAndWidth(expression);
            this.expression = expression;
        }

        internal override void WriteTo(ObjectWriter writer)
        {
            base.WriteTo(writer);
            writer.WriteValue(this.nameColon);
            writer.WriteValue(this.refKindKeyword);
            writer.WriteValue(this.expression);
        }

        static ArgumentSyntax()
        {
            ObjectBinder.RegisterTypeReader(typeof(ArgumentSyntax), r => new ArgumentSyntax(r));
        }
    }

    /// <summary>Class which represents the syntax node for name colon syntax.</summary>
    internal sealed partial class NameColonSyntax : CSharpSyntaxNode
    {
        internal readonly IdentifierNameSyntax name;
        internal readonly SyntaxToken colonToken;

        internal NameColonSyntax(SyntaxKind kind, IdentifierNameSyntax name, SyntaxToken colonToken, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
            this.SlotCount = 2;
            this.AdjustFlagsAndWidth(name);
            this.name = name;
            this.AdjustFlagsAndWidth(colonToken);
            this.colonToken = colonToken;
        }

        internal NameColonSyntax(SyntaxKind kind, IdentifierNameSyntax name, SyntaxToken colonToken, SyntaxFactoryContext context)
          : base(kind)
        {
            this.SetFactoryContext(context);
            this.SlotCount = 2;
            this.AdjustFlagsAndWidth(name);
            this.name = name;
            this.AdjustFlagsAndWidth(colonToken);
            this.colonToken = colonToken;
        }

        internal NameColonSyntax(SyntaxKind kind, IdentifierNameSyntax name, SyntaxToken colonToken)
          : base(kind)
        {
            this.SlotCount = 2;
            this.AdjustFlagsAndWidth(name);
            this.name = name;
            this.AdjustFlagsAndWidth(colonToken);
            this.colonToken = colonToken;
        }

        /// <summary>IdentifierNameSyntax representing the identifier name.</summary>
        public IdentifierNameSyntax Name => this.name;
        /// <summary>SyntaxToken representing colon.</summary>
        public SyntaxToken ColonToken => this.colonToken;

        internal override GreenNode? GetSlot(int index)
            => index switch
            {
                0 => this.name,
                1 => this.colonToken,
                _ => null,
            };

        internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new CSharp.Syntax.NameColonSyntax(this, parent, position);

        public override void Accept(CSharpSyntaxVisitor visitor) => visitor.VisitNameColon(this);
        public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor) => visitor.VisitNameColon(this);

        public NameColonSyntax Update(IdentifierNameSyntax name, SyntaxToken colonToken)
        {
            if (name != this.Name || colonToken != this.ColonToken)
            {
                var newNode = SyntaxFactory.NameColon(name, colonToken);
                var diags = GetDiagnostics();
                if (diags?.Length > 0)
                    newNode = newNode.WithDiagnosticsGreen(diags);
                var annotations = GetAnnotations();
                if (annotations?.Length > 0)
                    newNode = newNode.WithAnnotationsGreen(annotations);
                return newNode;
            }

            return this;
        }

        internal override GreenNode SetDiagnostics(DiagnosticInfo[]? diagnostics)
            => new NameColonSyntax(this.Kind, this.name, this.colonToken, diagnostics, GetAnnotations());

        internal override GreenNode SetAnnotations(SyntaxAnnotation[]? annotations)
            => new NameColonSyntax(this.Kind, this.name, this.colonToken, GetDiagnostics(), annotations);

        internal NameColonSyntax(ObjectReader reader)
          : base(reader)
        {
            this.SlotCount = 2;
            var name = (IdentifierNameSyntax)reader.ReadValue();
            AdjustFlagsAndWidth(name);
            this.name = name;
            var colonToken = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(colonToken);
            this.colonToken = colonToken;
        }

        internal override void WriteTo(ObjectWriter writer)
        {
            base.WriteTo(writer);
            writer.WriteValue(this.name);
            writer.WriteValue(this.colonToken);
        }

        static NameColonSyntax()
        {
            ObjectBinder.RegisterTypeReader(typeof(NameColonSyntax), r => new NameColonSyntax(r));
        }
    }

    /// <summary>Class which represents the syntax node for the variable declaration in an out var declaration or a deconstruction declaration.</summary>
    internal sealed partial class DeclarationExpressionSyntax : ExpressionSyntax
    {
        internal readonly TypeSyntax type;
        internal readonly VariableDesignationSyntax designation;

        internal DeclarationExpressionSyntax(SyntaxKind kind, TypeSyntax type, VariableDesignationSyntax designation, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
            this.SlotCount = 2;
            this.AdjustFlagsAndWidth(type);
            this.type = type;
            this.AdjustFlagsAndWidth(designation);
            this.designation = designation;
        }

        internal DeclarationExpressionSyntax(SyntaxKind kind, TypeSyntax type, VariableDesignationSyntax designation, SyntaxFactoryContext context)
          : base(kind)
        {
            this.SetFactoryContext(context);
            this.SlotCount = 2;
            this.AdjustFlagsAndWidth(type);
            this.type = type;
            this.AdjustFlagsAndWidth(designation);
            this.designation = designation;
        }

        internal DeclarationExpressionSyntax(SyntaxKind kind, TypeSyntax type, VariableDesignationSyntax designation)
          : base(kind)
        {
            this.SlotCount = 2;
            this.AdjustFlagsAndWidth(type);
            this.type = type;
            this.AdjustFlagsAndWidth(designation);
            this.designation = designation;
        }

        public TypeSyntax Type => this.type;
        /// <summary>Declaration representing the variable declared in an out parameter or deconstruction.</summary>
        public VariableDesignationSyntax Designation => this.designation;

        internal override GreenNode? GetSlot(int index)
            => index switch
            {
                0 => this.type,
                1 => this.designation,
                _ => null,
            };

        internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new CSharp.Syntax.DeclarationExpressionSyntax(this, parent, position);

        public override void Accept(CSharpSyntaxVisitor visitor) => visitor.VisitDeclarationExpression(this);
        public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor) => visitor.VisitDeclarationExpression(this);

        public DeclarationExpressionSyntax Update(TypeSyntax type, VariableDesignationSyntax designation)
        {
            if (type != this.Type || designation != this.Designation)
            {
                var newNode = SyntaxFactory.DeclarationExpression(type, designation);
                var diags = GetDiagnostics();
                if (diags?.Length > 0)
                    newNode = newNode.WithDiagnosticsGreen(diags);
                var annotations = GetAnnotations();
                if (annotations?.Length > 0)
                    newNode = newNode.WithAnnotationsGreen(annotations);
                return newNode;
            }

            return this;
        }

        internal override GreenNode SetDiagnostics(DiagnosticInfo[]? diagnostics)
            => new DeclarationExpressionSyntax(this.Kind, this.type, this.designation, diagnostics, GetAnnotations());

        internal override GreenNode SetAnnotations(SyntaxAnnotation[]? annotations)
            => new DeclarationExpressionSyntax(this.Kind, this.type, this.designation, GetDiagnostics(), annotations);

        internal DeclarationExpressionSyntax(ObjectReader reader)
          : base(reader)
        {
            this.SlotCount = 2;
            var type = (TypeSyntax)reader.ReadValue();
            AdjustFlagsAndWidth(type);
            this.type = type;
            var designation = (VariableDesignationSyntax)reader.ReadValue();
            AdjustFlagsAndWidth(designation);
            this.designation = designation;
        }

        internal override void WriteTo(ObjectWriter writer)
        {
            base.WriteTo(writer);
            writer.WriteValue(this.type);
            writer.WriteValue(this.designation);
        }

        static DeclarationExpressionSyntax()
        {
            ObjectBinder.RegisterTypeReader(typeof(DeclarationExpressionSyntax), r => new DeclarationExpressionSyntax(r));
        }
    }

    /// <summary>Class which represents the syntax node for cast expression.</summary>
    internal sealed partial class CastExpressionSyntax : ExpressionSyntax
    {
        internal readonly SyntaxToken openParenToken;
        internal readonly TypeSyntax type;
        internal readonly SyntaxToken closeParenToken;
        internal readonly ExpressionSyntax expression;

        internal CastExpressionSyntax(SyntaxKind kind, SyntaxToken openParenToken, TypeSyntax type, SyntaxToken closeParenToken, ExpressionSyntax expression, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
            this.SlotCount = 4;
            this.AdjustFlagsAndWidth(openParenToken);
            this.openParenToken = openParenToken;
            this.AdjustFlagsAndWidth(type);
            this.type = type;
            this.AdjustFlagsAndWidth(closeParenToken);
            this.closeParenToken = closeParenToken;
            this.AdjustFlagsAndWidth(expression);
            this.expression = expression;
        }

        internal CastExpressionSyntax(SyntaxKind kind, SyntaxToken openParenToken, TypeSyntax type, SyntaxToken closeParenToken, ExpressionSyntax expression, SyntaxFactoryContext context)
          : base(kind)
        {
            this.SetFactoryContext(context);
            this.SlotCount = 4;
            this.AdjustFlagsAndWidth(openParenToken);
            this.openParenToken = openParenToken;
            this.AdjustFlagsAndWidth(type);
            this.type = type;
            this.AdjustFlagsAndWidth(closeParenToken);
            this.closeParenToken = closeParenToken;
            this.AdjustFlagsAndWidth(expression);
            this.expression = expression;
        }

        internal CastExpressionSyntax(SyntaxKind kind, SyntaxToken openParenToken, TypeSyntax type, SyntaxToken closeParenToken, ExpressionSyntax expression)
          : base(kind)
        {
            this.SlotCount = 4;
            this.AdjustFlagsAndWidth(openParenToken);
            this.openParenToken = openParenToken;
            this.AdjustFlagsAndWidth(type);
            this.type = type;
            this.AdjustFlagsAndWidth(closeParenToken);
            this.closeParenToken = closeParenToken;
            this.AdjustFlagsAndWidth(expression);
            this.expression = expression;
        }

        /// <summary>SyntaxToken representing the open parenthesis.</summary>
        public SyntaxToken OpenParenToken => this.openParenToken;
        /// <summary>TypeSyntax node representing the type to which the expression is being cast.</summary>
        public TypeSyntax Type => this.type;
        /// <summary>SyntaxToken representing the close parenthesis.</summary>
        public SyntaxToken CloseParenToken => this.closeParenToken;
        /// <summary>ExpressionSyntax node representing the expression that is being casted.</summary>
        public ExpressionSyntax Expression => this.expression;

        internal override GreenNode? GetSlot(int index)
            => index switch
            {
                0 => this.openParenToken,
                1 => this.type,
                2 => this.closeParenToken,
                3 => this.expression,
                _ => null,
            };

        internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new CSharp.Syntax.CastExpressionSyntax(this, parent, position);

        public override void Accept(CSharpSyntaxVisitor visitor) => visitor.VisitCastExpression(this);
        public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor) => visitor.VisitCastExpression(this);

        public CastExpressionSyntax Update(SyntaxToken openParenToken, TypeSyntax type, SyntaxToken closeParenToken, ExpressionSyntax expression)
        {
            if (openParenToken != this.OpenParenToken || type != this.Type || closeParenToken != this.CloseParenToken || expression != this.Expression)
            {
                var newNode = SyntaxFactory.CastExpression(openParenToken, type, closeParenToken, expression);
                var diags = GetDiagnostics();
                if (diags?.Length > 0)
                    newNode = newNode.WithDiagnosticsGreen(diags);
                var annotations = GetAnnotations();
                if (annotations?.Length > 0)
                    newNode = newNode.WithAnnotationsGreen(annotations);
                return newNode;
            }

            return this;
        }

        internal override GreenNode SetDiagnostics(DiagnosticInfo[]? diagnostics)
            => new CastExpressionSyntax(this.Kind, this.openParenToken, this.type, this.closeParenToken, this.expression, diagnostics, GetAnnotations());

        internal override GreenNode SetAnnotations(SyntaxAnnotation[]? annotations)
            => new CastExpressionSyntax(this.Kind, this.openParenToken, this.type, this.closeParenToken, this.expression, GetDiagnostics(), annotations);

        internal CastExpressionSyntax(ObjectReader reader)
          : base(reader)
        {
            this.SlotCount = 4;
            var openParenToken = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(openParenToken);
            this.openParenToken = openParenToken;
            var type = (TypeSyntax)reader.ReadValue();
            AdjustFlagsAndWidth(type);
            this.type = type;
            var closeParenToken = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(closeParenToken);
            this.closeParenToken = closeParenToken;
            var expression = (ExpressionSyntax)reader.ReadValue();
            AdjustFlagsAndWidth(expression);
            this.expression = expression;
        }

        internal override void WriteTo(ObjectWriter writer)
        {
            base.WriteTo(writer);
            writer.WriteValue(this.openParenToken);
            writer.WriteValue(this.type);
            writer.WriteValue(this.closeParenToken);
            writer.WriteValue(this.expression);
        }

        static CastExpressionSyntax()
        {
            ObjectBinder.RegisterTypeReader(typeof(CastExpressionSyntax), r => new CastExpressionSyntax(r));
        }
    }

    /// <summary>Provides the base class from which the classes that represent anonymous function expressions are derived.</summary>
    internal abstract partial class AnonymousFunctionExpressionSyntax : ExpressionSyntax
    {
        internal AnonymousFunctionExpressionSyntax(SyntaxKind kind, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
        }

        internal AnonymousFunctionExpressionSyntax(SyntaxKind kind)
          : base(kind)
        {
        }

        protected AnonymousFunctionExpressionSyntax(ObjectReader reader)
          : base(reader)
        {
        }

        public abstract Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SyntaxToken> Modifiers { get; }

        /// <summary>
        /// BlockSyntax node representing the body of the anonymous function.
        /// Only one of Block or ExpressionBody will be non-null.
        /// </summary>
        public abstract BlockSyntax? Block { get; }

        /// <summary>
        /// ExpressionSyntax node representing the body of the anonymous function.
        /// Only one of Block or ExpressionBody will be non-null.
        /// </summary>
        public abstract ExpressionSyntax? ExpressionBody { get; }
    }

    /// <summary>Class which represents the syntax node for anonymous method expression.</summary>
    internal sealed partial class AnonymousMethodExpressionSyntax : AnonymousFunctionExpressionSyntax
    {
        internal readonly GreenNode? modifiers;
        internal readonly SyntaxToken delegateKeyword;
        internal readonly ParameterListSyntax? parameterList;
        internal readonly BlockSyntax block;
        internal readonly ExpressionSyntax? expressionBody;

        internal AnonymousMethodExpressionSyntax(SyntaxKind kind, GreenNode? modifiers, SyntaxToken delegateKeyword, ParameterListSyntax? parameterList, BlockSyntax block, ExpressionSyntax? expressionBody, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
            this.SlotCount = 5;
            if (modifiers != null)
            {
                this.AdjustFlagsAndWidth(modifiers);
                this.modifiers = modifiers;
            }
            this.AdjustFlagsAndWidth(delegateKeyword);
            this.delegateKeyword = delegateKeyword;
            if (parameterList != null)
            {
                this.AdjustFlagsAndWidth(parameterList);
                this.parameterList = parameterList;
            }
            this.AdjustFlagsAndWidth(block);
            this.block = block;
            if (expressionBody != null)
            {
                this.AdjustFlagsAndWidth(expressionBody);
                this.expressionBody = expressionBody;
            }
        }

        internal AnonymousMethodExpressionSyntax(SyntaxKind kind, GreenNode? modifiers, SyntaxToken delegateKeyword, ParameterListSyntax? parameterList, BlockSyntax block, ExpressionSyntax? expressionBody, SyntaxFactoryContext context)
          : base(kind)
        {
            this.SetFactoryContext(context);
            this.SlotCount = 5;
            if (modifiers != null)
            {
                this.AdjustFlagsAndWidth(modifiers);
                this.modifiers = modifiers;
            }
            this.AdjustFlagsAndWidth(delegateKeyword);
            this.delegateKeyword = delegateKeyword;
            if (parameterList != null)
            {
                this.AdjustFlagsAndWidth(parameterList);
                this.parameterList = parameterList;
            }
            this.AdjustFlagsAndWidth(block);
            this.block = block;
            if (expressionBody != null)
            {
                this.AdjustFlagsAndWidth(expressionBody);
                this.expressionBody = expressionBody;
            }
        }

        internal AnonymousMethodExpressionSyntax(SyntaxKind kind, GreenNode? modifiers, SyntaxToken delegateKeyword, ParameterListSyntax? parameterList, BlockSyntax block, ExpressionSyntax? expressionBody)
          : base(kind)
        {
            this.SlotCount = 5;
            if (modifiers != null)
            {
                this.AdjustFlagsAndWidth(modifiers);
                this.modifiers = modifiers;
            }
            this.AdjustFlagsAndWidth(delegateKeyword);
            this.delegateKeyword = delegateKeyword;
            if (parameterList != null)
            {
                this.AdjustFlagsAndWidth(parameterList);
                this.parameterList = parameterList;
            }
            this.AdjustFlagsAndWidth(block);
            this.block = block;
            if (expressionBody != null)
            {
                this.AdjustFlagsAndWidth(expressionBody);
                this.expressionBody = expressionBody;
            }
        }

        public override Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SyntaxToken> Modifiers => new Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SyntaxToken>(this.modifiers);
        /// <summary>SyntaxToken representing the delegate keyword.</summary>
        public SyntaxToken DelegateKeyword => this.delegateKeyword;
        /// <summary>List of parameters of the anonymous method expression, or null if there no parameters are specified.</summary>
        public ParameterListSyntax? ParameterList => this.parameterList;
        /// <summary>
        /// BlockSyntax node representing the body of the anonymous function.
        /// This will never be null.
        /// </summary>
        public override BlockSyntax Block => this.block;
        /// <summary>
        /// Inherited from AnonymousFunctionExpressionSyntax, but not used for
        /// AnonymousMethodExpressionSyntax.  This will always be null.
        /// </summary>
        public override ExpressionSyntax? ExpressionBody => this.expressionBody;

        internal override GreenNode? GetSlot(int index)
            => index switch
            {
                0 => this.modifiers,
                1 => this.delegateKeyword,
                2 => this.parameterList,
                3 => this.block,
                4 => this.expressionBody,
                _ => null,
            };

        internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new CSharp.Syntax.AnonymousMethodExpressionSyntax(this, parent, position);

        public override void Accept(CSharpSyntaxVisitor visitor) => visitor.VisitAnonymousMethodExpression(this);
        public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor) => visitor.VisitAnonymousMethodExpression(this);

        public AnonymousMethodExpressionSyntax Update(Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SyntaxToken> modifiers, SyntaxToken delegateKeyword, ParameterListSyntax parameterList, BlockSyntax block, ExpressionSyntax expressionBody)
        {
            if (modifiers != this.Modifiers || delegateKeyword != this.DelegateKeyword || parameterList != this.ParameterList || block != this.Block || expressionBody != this.ExpressionBody)
            {
                var newNode = SyntaxFactory.AnonymousMethodExpression(modifiers, delegateKeyword, parameterList, block, expressionBody);
                var diags = GetDiagnostics();
                if (diags?.Length > 0)
                    newNode = newNode.WithDiagnosticsGreen(diags);
                var annotations = GetAnnotations();
                if (annotations?.Length > 0)
                    newNode = newNode.WithAnnotationsGreen(annotations);
                return newNode;
            }

            return this;
        }

        internal override GreenNode SetDiagnostics(DiagnosticInfo[]? diagnostics)
            => new AnonymousMethodExpressionSyntax(this.Kind, this.modifiers, this.delegateKeyword, this.parameterList, this.block, this.expressionBody, diagnostics, GetAnnotations());

        internal override GreenNode SetAnnotations(SyntaxAnnotation[]? annotations)
            => new AnonymousMethodExpressionSyntax(this.Kind, this.modifiers, this.delegateKeyword, this.parameterList, this.block, this.expressionBody, GetDiagnostics(), annotations);

        internal AnonymousMethodExpressionSyntax(ObjectReader reader)
          : base(reader)
        {
            this.SlotCount = 5;
            var modifiers = (GreenNode?)reader.ReadValue();
            if (modifiers != null)
            {
                AdjustFlagsAndWidth(modifiers);
                this.modifiers = modifiers;
            }
            var delegateKeyword = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(delegateKeyword);
            this.delegateKeyword = delegateKeyword;
            var parameterList = (ParameterListSyntax?)reader.ReadValue();
            if (parameterList != null)
            {
                AdjustFlagsAndWidth(parameterList);
                this.parameterList = parameterList;
            }
            var block = (BlockSyntax)reader.ReadValue();
            AdjustFlagsAndWidth(block);
            this.block = block;
            var expressionBody = (ExpressionSyntax?)reader.ReadValue();
            if (expressionBody != null)
            {
                AdjustFlagsAndWidth(expressionBody);
                this.expressionBody = expressionBody;
            }
        }

        internal override void WriteTo(ObjectWriter writer)
        {
            base.WriteTo(writer);
            writer.WriteValue(this.modifiers);
            writer.WriteValue(this.delegateKeyword);
            writer.WriteValue(this.parameterList);
            writer.WriteValue(this.block);
            writer.WriteValue(this.expressionBody);
        }

        static AnonymousMethodExpressionSyntax()
        {
            ObjectBinder.RegisterTypeReader(typeof(AnonymousMethodExpressionSyntax), r => new AnonymousMethodExpressionSyntax(r));
        }
    }

    /// <summary>Provides the base class from which the classes that represent lambda expressions are derived.</summary>
    internal abstract partial class LambdaExpressionSyntax : AnonymousFunctionExpressionSyntax
    {
        internal LambdaExpressionSyntax(SyntaxKind kind, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
        }

        internal LambdaExpressionSyntax(SyntaxKind kind)
          : base(kind)
        {
        }

        protected LambdaExpressionSyntax(ObjectReader reader)
          : base(reader)
        {
        }

        /// <summary>SyntaxToken representing equals greater than.</summary>
        public abstract SyntaxToken ArrowToken { get; }
    }

    /// <summary>Class which represents the syntax node for a simple lambda expression.</summary>
    internal sealed partial class SimpleLambdaExpressionSyntax : LambdaExpressionSyntax
    {
        internal readonly GreenNode? modifiers;
        internal readonly ParameterSyntax parameter;
        internal readonly SyntaxToken arrowToken;
        internal readonly BlockSyntax? block;
        internal readonly ExpressionSyntax? expressionBody;

        internal SimpleLambdaExpressionSyntax(SyntaxKind kind, GreenNode? modifiers, ParameterSyntax parameter, SyntaxToken arrowToken, BlockSyntax? block, ExpressionSyntax? expressionBody, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
            this.SlotCount = 5;
            if (modifiers != null)
            {
                this.AdjustFlagsAndWidth(modifiers);
                this.modifiers = modifiers;
            }
            this.AdjustFlagsAndWidth(parameter);
            this.parameter = parameter;
            this.AdjustFlagsAndWidth(arrowToken);
            this.arrowToken = arrowToken;
            if (block != null)
            {
                this.AdjustFlagsAndWidth(block);
                this.block = block;
            }
            if (expressionBody != null)
            {
                this.AdjustFlagsAndWidth(expressionBody);
                this.expressionBody = expressionBody;
            }
        }

        internal SimpleLambdaExpressionSyntax(SyntaxKind kind, GreenNode? modifiers, ParameterSyntax parameter, SyntaxToken arrowToken, BlockSyntax? block, ExpressionSyntax? expressionBody, SyntaxFactoryContext context)
          : base(kind)
        {
            this.SetFactoryContext(context);
            this.SlotCount = 5;
            if (modifiers != null)
            {
                this.AdjustFlagsAndWidth(modifiers);
                this.modifiers = modifiers;
            }
            this.AdjustFlagsAndWidth(parameter);
            this.parameter = parameter;
            this.AdjustFlagsAndWidth(arrowToken);
            this.arrowToken = arrowToken;
            if (block != null)
            {
                this.AdjustFlagsAndWidth(block);
                this.block = block;
            }
            if (expressionBody != null)
            {
                this.AdjustFlagsAndWidth(expressionBody);
                this.expressionBody = expressionBody;
            }
        }

        internal SimpleLambdaExpressionSyntax(SyntaxKind kind, GreenNode? modifiers, ParameterSyntax parameter, SyntaxToken arrowToken, BlockSyntax? block, ExpressionSyntax? expressionBody)
          : base(kind)
        {
            this.SlotCount = 5;
            if (modifiers != null)
            {
                this.AdjustFlagsAndWidth(modifiers);
                this.modifiers = modifiers;
            }
            this.AdjustFlagsAndWidth(parameter);
            this.parameter = parameter;
            this.AdjustFlagsAndWidth(arrowToken);
            this.arrowToken = arrowToken;
            if (block != null)
            {
                this.AdjustFlagsAndWidth(block);
                this.block = block;
            }
            if (expressionBody != null)
            {
                this.AdjustFlagsAndWidth(expressionBody);
                this.expressionBody = expressionBody;
            }
        }

        public override Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SyntaxToken> Modifiers => new Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SyntaxToken>(this.modifiers);
        /// <summary>ParameterSyntax node representing the parameter of the lambda expression.</summary>
        public ParameterSyntax Parameter => this.parameter;
        /// <summary>SyntaxToken representing equals greater than.</summary>
        public override SyntaxToken ArrowToken => this.arrowToken;
        /// <summary>
        /// BlockSyntax node representing the body of the lambda.
        /// Only one of Block or ExpressionBody will be non-null.
        /// </summary>
        public override BlockSyntax? Block => this.block;
        /// <summary>
        /// ExpressionSyntax node representing the body of the lambda.
        /// Only one of Block or ExpressionBody will be non-null.
        /// </summary>
        public override ExpressionSyntax? ExpressionBody => this.expressionBody;

        internal override GreenNode? GetSlot(int index)
            => index switch
            {
                0 => this.modifiers,
                1 => this.parameter,
                2 => this.arrowToken,
                3 => this.block,
                4 => this.expressionBody,
                _ => null,
            };

        internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new CSharp.Syntax.SimpleLambdaExpressionSyntax(this, parent, position);

        public override void Accept(CSharpSyntaxVisitor visitor) => visitor.VisitSimpleLambdaExpression(this);
        public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor) => visitor.VisitSimpleLambdaExpression(this);

        public SimpleLambdaExpressionSyntax Update(Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SyntaxToken> modifiers, ParameterSyntax parameter, SyntaxToken arrowToken, BlockSyntax block, ExpressionSyntax expressionBody)
        {
            if (modifiers != this.Modifiers || parameter != this.Parameter || arrowToken != this.ArrowToken || block != this.Block || expressionBody != this.ExpressionBody)
            {
                var newNode = SyntaxFactory.SimpleLambdaExpression(modifiers, parameter, arrowToken, block, expressionBody);
                var diags = GetDiagnostics();
                if (diags?.Length > 0)
                    newNode = newNode.WithDiagnosticsGreen(diags);
                var annotations = GetAnnotations();
                if (annotations?.Length > 0)
                    newNode = newNode.WithAnnotationsGreen(annotations);
                return newNode;
            }

            return this;
        }

        internal override GreenNode SetDiagnostics(DiagnosticInfo[]? diagnostics)
            => new SimpleLambdaExpressionSyntax(this.Kind, this.modifiers, this.parameter, this.arrowToken, this.block, this.expressionBody, diagnostics, GetAnnotations());

        internal override GreenNode SetAnnotations(SyntaxAnnotation[]? annotations)
            => new SimpleLambdaExpressionSyntax(this.Kind, this.modifiers, this.parameter, this.arrowToken, this.block, this.expressionBody, GetDiagnostics(), annotations);

        internal SimpleLambdaExpressionSyntax(ObjectReader reader)
          : base(reader)
        {
            this.SlotCount = 5;
            var modifiers = (GreenNode?)reader.ReadValue();
            if (modifiers != null)
            {
                AdjustFlagsAndWidth(modifiers);
                this.modifiers = modifiers;
            }
            var parameter = (ParameterSyntax)reader.ReadValue();
            AdjustFlagsAndWidth(parameter);
            this.parameter = parameter;
            var arrowToken = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(arrowToken);
            this.arrowToken = arrowToken;
            var block = (BlockSyntax?)reader.ReadValue();
            if (block != null)
            {
                AdjustFlagsAndWidth(block);
                this.block = block;
            }
            var expressionBody = (ExpressionSyntax?)reader.ReadValue();
            if (expressionBody != null)
            {
                AdjustFlagsAndWidth(expressionBody);
                this.expressionBody = expressionBody;
            }
        }

        internal override void WriteTo(ObjectWriter writer)
        {
            base.WriteTo(writer);
            writer.WriteValue(this.modifiers);
            writer.WriteValue(this.parameter);
            writer.WriteValue(this.arrowToken);
            writer.WriteValue(this.block);
            writer.WriteValue(this.expressionBody);
        }

        static SimpleLambdaExpressionSyntax()
        {
            ObjectBinder.RegisterTypeReader(typeof(SimpleLambdaExpressionSyntax), r => new SimpleLambdaExpressionSyntax(r));
        }
    }

    internal sealed partial class RefExpressionSyntax : ExpressionSyntax
    {
        internal readonly SyntaxToken refKeyword;
        internal readonly ExpressionSyntax expression;

        internal RefExpressionSyntax(SyntaxKind kind, SyntaxToken refKeyword, ExpressionSyntax expression, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
            this.SlotCount = 2;
            this.AdjustFlagsAndWidth(refKeyword);
            this.refKeyword = refKeyword;
            this.AdjustFlagsAndWidth(expression);
            this.expression = expression;
        }

        internal RefExpressionSyntax(SyntaxKind kind, SyntaxToken refKeyword, ExpressionSyntax expression, SyntaxFactoryContext context)
          : base(kind)
        {
            this.SetFactoryContext(context);
            this.SlotCount = 2;
            this.AdjustFlagsAndWidth(refKeyword);
            this.refKeyword = refKeyword;
            this.AdjustFlagsAndWidth(expression);
            this.expression = expression;
        }

        internal RefExpressionSyntax(SyntaxKind kind, SyntaxToken refKeyword, ExpressionSyntax expression)
          : base(kind)
        {
            this.SlotCount = 2;
            this.AdjustFlagsAndWidth(refKeyword);
            this.refKeyword = refKeyword;
            this.AdjustFlagsAndWidth(expression);
            this.expression = expression;
        }

        public SyntaxToken RefKeyword => this.refKeyword;
        public ExpressionSyntax Expression => this.expression;

        internal override GreenNode? GetSlot(int index)
            => index switch
            {
                0 => this.refKeyword,
                1 => this.expression,
                _ => null,
            };

        internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new CSharp.Syntax.RefExpressionSyntax(this, parent, position);

        public override void Accept(CSharpSyntaxVisitor visitor) => visitor.VisitRefExpression(this);
        public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor) => visitor.VisitRefExpression(this);

        public RefExpressionSyntax Update(SyntaxToken refKeyword, ExpressionSyntax expression)
        {
            if (refKeyword != this.RefKeyword || expression != this.Expression)
            {
                var newNode = SyntaxFactory.RefExpression(refKeyword, expression);
                var diags = GetDiagnostics();
                if (diags?.Length > 0)
                    newNode = newNode.WithDiagnosticsGreen(diags);
                var annotations = GetAnnotations();
                if (annotations?.Length > 0)
                    newNode = newNode.WithAnnotationsGreen(annotations);
                return newNode;
            }

            return this;
        }

        internal override GreenNode SetDiagnostics(DiagnosticInfo[]? diagnostics)
            => new RefExpressionSyntax(this.Kind, this.refKeyword, this.expression, diagnostics, GetAnnotations());

        internal override GreenNode SetAnnotations(SyntaxAnnotation[]? annotations)
            => new RefExpressionSyntax(this.Kind, this.refKeyword, this.expression, GetDiagnostics(), annotations);

        internal RefExpressionSyntax(ObjectReader reader)
          : base(reader)
        {
            this.SlotCount = 2;
            var refKeyword = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(refKeyword);
            this.refKeyword = refKeyword;
            var expression = (ExpressionSyntax)reader.ReadValue();
            AdjustFlagsAndWidth(expression);
            this.expression = expression;
        }

        internal override void WriteTo(ObjectWriter writer)
        {
            base.WriteTo(writer);
            writer.WriteValue(this.refKeyword);
            writer.WriteValue(this.expression);
        }

        static RefExpressionSyntax()
        {
            ObjectBinder.RegisterTypeReader(typeof(RefExpressionSyntax), r => new RefExpressionSyntax(r));
        }
    }

    /// <summary>Class which represents the syntax node for parenthesized lambda expression.</summary>
    internal sealed partial class ParenthesizedLambdaExpressionSyntax : LambdaExpressionSyntax
    {
        internal readonly GreenNode? modifiers;
        internal readonly ParameterListSyntax parameterList;
        internal readonly SyntaxToken arrowToken;
        internal readonly BlockSyntax? block;
        internal readonly ExpressionSyntax? expressionBody;

        internal ParenthesizedLambdaExpressionSyntax(SyntaxKind kind, GreenNode? modifiers, ParameterListSyntax parameterList, SyntaxToken arrowToken, BlockSyntax? block, ExpressionSyntax? expressionBody, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
            this.SlotCount = 5;
            if (modifiers != null)
            {
                this.AdjustFlagsAndWidth(modifiers);
                this.modifiers = modifiers;
            }
            this.AdjustFlagsAndWidth(parameterList);
            this.parameterList = parameterList;
            this.AdjustFlagsAndWidth(arrowToken);
            this.arrowToken = arrowToken;
            if (block != null)
            {
                this.AdjustFlagsAndWidth(block);
                this.block = block;
            }
            if (expressionBody != null)
            {
                this.AdjustFlagsAndWidth(expressionBody);
                this.expressionBody = expressionBody;
            }
        }

        internal ParenthesizedLambdaExpressionSyntax(SyntaxKind kind, GreenNode? modifiers, ParameterListSyntax parameterList, SyntaxToken arrowToken, BlockSyntax? block, ExpressionSyntax? expressionBody, SyntaxFactoryContext context)
          : base(kind)
        {
            this.SetFactoryContext(context);
            this.SlotCount = 5;
            if (modifiers != null)
            {
                this.AdjustFlagsAndWidth(modifiers);
                this.modifiers = modifiers;
            }
            this.AdjustFlagsAndWidth(parameterList);
            this.parameterList = parameterList;
            this.AdjustFlagsAndWidth(arrowToken);
            this.arrowToken = arrowToken;
            if (block != null)
            {
                this.AdjustFlagsAndWidth(block);
                this.block = block;
            }
            if (expressionBody != null)
            {
                this.AdjustFlagsAndWidth(expressionBody);
                this.expressionBody = expressionBody;
            }
        }

        internal ParenthesizedLambdaExpressionSyntax(SyntaxKind kind, GreenNode? modifiers, ParameterListSyntax parameterList, SyntaxToken arrowToken, BlockSyntax? block, ExpressionSyntax? expressionBody)
          : base(kind)
        {
            this.SlotCount = 5;
            if (modifiers != null)
            {
                this.AdjustFlagsAndWidth(modifiers);
                this.modifiers = modifiers;
            }
            this.AdjustFlagsAndWidth(parameterList);
            this.parameterList = parameterList;
            this.AdjustFlagsAndWidth(arrowToken);
            this.arrowToken = arrowToken;
            if (block != null)
            {
                this.AdjustFlagsAndWidth(block);
                this.block = block;
            }
            if (expressionBody != null)
            {
                this.AdjustFlagsAndWidth(expressionBody);
                this.expressionBody = expressionBody;
            }
        }

        public override Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SyntaxToken> Modifiers => new Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SyntaxToken>(this.modifiers);
        /// <summary>ParameterListSyntax node representing the list of parameters for the lambda expression.</summary>
        public ParameterListSyntax ParameterList => this.parameterList;
        /// <summary>SyntaxToken representing equals greater than.</summary>
        public override SyntaxToken ArrowToken => this.arrowToken;
        /// <summary>
        /// BlockSyntax node representing the body of the lambda.
        /// Only one of Block or ExpressionBody will be non-null.
        /// </summary>
        public override BlockSyntax? Block => this.block;
        /// <summary>
        /// ExpressionSyntax node representing the body of the lambda.
        /// Only one of Block or ExpressionBody will be non-null.
        /// </summary>
        public override ExpressionSyntax? ExpressionBody => this.expressionBody;

        internal override GreenNode? GetSlot(int index)
            => index switch
            {
                0 => this.modifiers,
                1 => this.parameterList,
                2 => this.arrowToken,
                3 => this.block,
                4 => this.expressionBody,
                _ => null,
            };

        internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new CSharp.Syntax.ParenthesizedLambdaExpressionSyntax(this, parent, position);

        public override void Accept(CSharpSyntaxVisitor visitor) => visitor.VisitParenthesizedLambdaExpression(this);
        public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor) => visitor.VisitParenthesizedLambdaExpression(this);

        public ParenthesizedLambdaExpressionSyntax Update(Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SyntaxToken> modifiers, ParameterListSyntax parameterList, SyntaxToken arrowToken, BlockSyntax block, ExpressionSyntax expressionBody)
        {
            if (modifiers != this.Modifiers || parameterList != this.ParameterList || arrowToken != this.ArrowToken || block != this.Block || expressionBody != this.ExpressionBody)
            {
                var newNode = SyntaxFactory.ParenthesizedLambdaExpression(modifiers, parameterList, arrowToken, block, expressionBody);
                var diags = GetDiagnostics();
                if (diags?.Length > 0)
                    newNode = newNode.WithDiagnosticsGreen(diags);
                var annotations = GetAnnotations();
                if (annotations?.Length > 0)
                    newNode = newNode.WithAnnotationsGreen(annotations);
                return newNode;
            }

            return this;
        }

        internal override GreenNode SetDiagnostics(DiagnosticInfo[]? diagnostics)
            => new ParenthesizedLambdaExpressionSyntax(this.Kind, this.modifiers, this.parameterList, this.arrowToken, this.block, this.expressionBody, diagnostics, GetAnnotations());

        internal override GreenNode SetAnnotations(SyntaxAnnotation[]? annotations)
            => new ParenthesizedLambdaExpressionSyntax(this.Kind, this.modifiers, this.parameterList, this.arrowToken, this.block, this.expressionBody, GetDiagnostics(), annotations);

        internal ParenthesizedLambdaExpressionSyntax(ObjectReader reader)
          : base(reader)
        {
            this.SlotCount = 5;
            var modifiers = (GreenNode?)reader.ReadValue();
            if (modifiers != null)
            {
                AdjustFlagsAndWidth(modifiers);
                this.modifiers = modifiers;
            }
            var parameterList = (ParameterListSyntax)reader.ReadValue();
            AdjustFlagsAndWidth(parameterList);
            this.parameterList = parameterList;
            var arrowToken = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(arrowToken);
            this.arrowToken = arrowToken;
            var block = (BlockSyntax?)reader.ReadValue();
            if (block != null)
            {
                AdjustFlagsAndWidth(block);
                this.block = block;
            }
            var expressionBody = (ExpressionSyntax?)reader.ReadValue();
            if (expressionBody != null)
            {
                AdjustFlagsAndWidth(expressionBody);
                this.expressionBody = expressionBody;
            }
        }

        internal override void WriteTo(ObjectWriter writer)
        {
            base.WriteTo(writer);
            writer.WriteValue(this.modifiers);
            writer.WriteValue(this.parameterList);
            writer.WriteValue(this.arrowToken);
            writer.WriteValue(this.block);
            writer.WriteValue(this.expressionBody);
        }

        static ParenthesizedLambdaExpressionSyntax()
        {
            ObjectBinder.RegisterTypeReader(typeof(ParenthesizedLambdaExpressionSyntax), r => new ParenthesizedLambdaExpressionSyntax(r));
        }
    }

    /// <summary>Class which represents the syntax node for initializer expression.</summary>
    internal sealed partial class InitializerExpressionSyntax : ExpressionSyntax
    {
        internal readonly SyntaxToken openBraceToken;
        internal readonly GreenNode? expressions;
        internal readonly SyntaxToken closeBraceToken;

        internal InitializerExpressionSyntax(SyntaxKind kind, SyntaxToken openBraceToken, GreenNode? expressions, SyntaxToken closeBraceToken, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
            this.SlotCount = 3;
            this.AdjustFlagsAndWidth(openBraceToken);
            this.openBraceToken = openBraceToken;
            if (expressions != null)
            {
                this.AdjustFlagsAndWidth(expressions);
                this.expressions = expressions;
            }
            this.AdjustFlagsAndWidth(closeBraceToken);
            this.closeBraceToken = closeBraceToken;
        }

        internal InitializerExpressionSyntax(SyntaxKind kind, SyntaxToken openBraceToken, GreenNode? expressions, SyntaxToken closeBraceToken, SyntaxFactoryContext context)
          : base(kind)
        {
            this.SetFactoryContext(context);
            this.SlotCount = 3;
            this.AdjustFlagsAndWidth(openBraceToken);
            this.openBraceToken = openBraceToken;
            if (expressions != null)
            {
                this.AdjustFlagsAndWidth(expressions);
                this.expressions = expressions;
            }
            this.AdjustFlagsAndWidth(closeBraceToken);
            this.closeBraceToken = closeBraceToken;
        }

        internal InitializerExpressionSyntax(SyntaxKind kind, SyntaxToken openBraceToken, GreenNode? expressions, SyntaxToken closeBraceToken)
          : base(kind)
        {
            this.SlotCount = 3;
            this.AdjustFlagsAndWidth(openBraceToken);
            this.openBraceToken = openBraceToken;
            if (expressions != null)
            {
                this.AdjustFlagsAndWidth(expressions);
                this.expressions = expressions;
            }
            this.AdjustFlagsAndWidth(closeBraceToken);
            this.closeBraceToken = closeBraceToken;
        }

        /// <summary>SyntaxToken representing the open brace.</summary>
        public SyntaxToken OpenBraceToken => this.openBraceToken;
        /// <summary>SeparatedSyntaxList of ExpressionSyntax representing the list of expressions in the initializer expression.</summary>
        public Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<ExpressionSyntax> Expressions => new Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<ExpressionSyntax>(new Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<CSharpSyntaxNode>(this.expressions));
        /// <summary>SyntaxToken representing the close brace.</summary>
        public SyntaxToken CloseBraceToken => this.closeBraceToken;

        internal override GreenNode? GetSlot(int index)
            => index switch
            {
                0 => this.openBraceToken,
                1 => this.expressions,
                2 => this.closeBraceToken,
                _ => null,
            };

        internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new CSharp.Syntax.InitializerExpressionSyntax(this, parent, position);

        public override void Accept(CSharpSyntaxVisitor visitor) => visitor.VisitInitializerExpression(this);
        public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor) => visitor.VisitInitializerExpression(this);

        public InitializerExpressionSyntax Update(SyntaxToken openBraceToken, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<ExpressionSyntax> expressions, SyntaxToken closeBraceToken)
        {
            if (openBraceToken != this.OpenBraceToken || expressions != this.Expressions || closeBraceToken != this.CloseBraceToken)
            {
                var newNode = SyntaxFactory.InitializerExpression(this.Kind, openBraceToken, expressions, closeBraceToken);
                var diags = GetDiagnostics();
                if (diags?.Length > 0)
                    newNode = newNode.WithDiagnosticsGreen(diags);
                var annotations = GetAnnotations();
                if (annotations?.Length > 0)
                    newNode = newNode.WithAnnotationsGreen(annotations);
                return newNode;
            }

            return this;
        }

        internal override GreenNode SetDiagnostics(DiagnosticInfo[]? diagnostics)
            => new InitializerExpressionSyntax(this.Kind, this.openBraceToken, this.expressions, this.closeBraceToken, diagnostics, GetAnnotations());

        internal override GreenNode SetAnnotations(SyntaxAnnotation[]? annotations)
            => new InitializerExpressionSyntax(this.Kind, this.openBraceToken, this.expressions, this.closeBraceToken, GetDiagnostics(), annotations);

        internal InitializerExpressionSyntax(ObjectReader reader)
          : base(reader)
        {
            this.SlotCount = 3;
            var openBraceToken = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(openBraceToken);
            this.openBraceToken = openBraceToken;
            var expressions = (GreenNode?)reader.ReadValue();
            if (expressions != null)
            {
                AdjustFlagsAndWidth(expressions);
                this.expressions = expressions;
            }
            var closeBraceToken = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(closeBraceToken);
            this.closeBraceToken = closeBraceToken;
        }

        internal override void WriteTo(ObjectWriter writer)
        {
            base.WriteTo(writer);
            writer.WriteValue(this.openBraceToken);
            writer.WriteValue(this.expressions);
            writer.WriteValue(this.closeBraceToken);
        }

        static InitializerExpressionSyntax()
        {
            ObjectBinder.RegisterTypeReader(typeof(InitializerExpressionSyntax), r => new InitializerExpressionSyntax(r));
        }
    }

    internal abstract partial class BaseObjectCreationExpressionSyntax : ExpressionSyntax
    {
        internal BaseObjectCreationExpressionSyntax(SyntaxKind kind, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
        }

        internal BaseObjectCreationExpressionSyntax(SyntaxKind kind)
          : base(kind)
        {
        }

        protected BaseObjectCreationExpressionSyntax(ObjectReader reader)
          : base(reader)
        {
        }

        /// <summary>SyntaxToken representing the new keyword.</summary>
        public abstract SyntaxToken NewKeyword { get; }

        /// <summary>ArgumentListSyntax representing the list of arguments passed as part of the object creation expression.</summary>
        public abstract ArgumentListSyntax? ArgumentList { get; }

        /// <summary>InitializerExpressionSyntax representing the initializer expression for the object being created.</summary>
        public abstract InitializerExpressionSyntax? Initializer { get; }
    }

    /// <summary>Class which represents the syntax node for implicit object creation expression.</summary>
    internal sealed partial class ImplicitObjectCreationExpressionSyntax : BaseObjectCreationExpressionSyntax
    {
        internal readonly SyntaxToken newKeyword;
        internal readonly ArgumentListSyntax argumentList;
        internal readonly InitializerExpressionSyntax? initializer;

        internal ImplicitObjectCreationExpressionSyntax(SyntaxKind kind, SyntaxToken newKeyword, ArgumentListSyntax argumentList, InitializerExpressionSyntax? initializer, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
            this.SlotCount = 3;
            this.AdjustFlagsAndWidth(newKeyword);
            this.newKeyword = newKeyword;
            this.AdjustFlagsAndWidth(argumentList);
            this.argumentList = argumentList;
            if (initializer != null)
            {
                this.AdjustFlagsAndWidth(initializer);
                this.initializer = initializer;
            }
        }

        internal ImplicitObjectCreationExpressionSyntax(SyntaxKind kind, SyntaxToken newKeyword, ArgumentListSyntax argumentList, InitializerExpressionSyntax? initializer, SyntaxFactoryContext context)
          : base(kind)
        {
            this.SetFactoryContext(context);
            this.SlotCount = 3;
            this.AdjustFlagsAndWidth(newKeyword);
            this.newKeyword = newKeyword;
            this.AdjustFlagsAndWidth(argumentList);
            this.argumentList = argumentList;
            if (initializer != null)
            {
                this.AdjustFlagsAndWidth(initializer);
                this.initializer = initializer;
            }
        }

        internal ImplicitObjectCreationExpressionSyntax(SyntaxKind kind, SyntaxToken newKeyword, ArgumentListSyntax argumentList, InitializerExpressionSyntax? initializer)
          : base(kind)
        {
            this.SlotCount = 3;
            this.AdjustFlagsAndWidth(newKeyword);
            this.newKeyword = newKeyword;
            this.AdjustFlagsAndWidth(argumentList);
            this.argumentList = argumentList;
            if (initializer != null)
            {
                this.AdjustFlagsAndWidth(initializer);
                this.initializer = initializer;
            }
        }

        /// <summary>SyntaxToken representing the new keyword.</summary>
        public override SyntaxToken NewKeyword => this.newKeyword;
        /// <summary>ArgumentListSyntax representing the list of arguments passed as part of the object creation expression.</summary>
        public override ArgumentListSyntax ArgumentList => this.argumentList;
        /// <summary>InitializerExpressionSyntax representing the initializer expression for the object being created.</summary>
        public override InitializerExpressionSyntax? Initializer => this.initializer;

        internal override GreenNode? GetSlot(int index)
            => index switch
            {
                0 => this.newKeyword,
                1 => this.argumentList,
                2 => this.initializer,
                _ => null,
            };

        internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new CSharp.Syntax.ImplicitObjectCreationExpressionSyntax(this, parent, position);

        public override void Accept(CSharpSyntaxVisitor visitor) => visitor.VisitImplicitObjectCreationExpression(this);
        public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor) => visitor.VisitImplicitObjectCreationExpression(this);

        public ImplicitObjectCreationExpressionSyntax Update(SyntaxToken newKeyword, ArgumentListSyntax argumentList, InitializerExpressionSyntax initializer)
        {
            if (newKeyword != this.NewKeyword || argumentList != this.ArgumentList || initializer != this.Initializer)
            {
                var newNode = SyntaxFactory.ImplicitObjectCreationExpression(newKeyword, argumentList, initializer);
                var diags = GetDiagnostics();
                if (diags?.Length > 0)
                    newNode = newNode.WithDiagnosticsGreen(diags);
                var annotations = GetAnnotations();
                if (annotations?.Length > 0)
                    newNode = newNode.WithAnnotationsGreen(annotations);
                return newNode;
            }

            return this;
        }

        internal override GreenNode SetDiagnostics(DiagnosticInfo[]? diagnostics)
            => new ImplicitObjectCreationExpressionSyntax(this.Kind, this.newKeyword, this.argumentList, this.initializer, diagnostics, GetAnnotations());

        internal override GreenNode SetAnnotations(SyntaxAnnotation[]? annotations)
            => new ImplicitObjectCreationExpressionSyntax(this.Kind, this.newKeyword, this.argumentList, this.initializer, GetDiagnostics(), annotations);

        internal ImplicitObjectCreationExpressionSyntax(ObjectReader reader)
          : base(reader)
        {
            this.SlotCount = 3;
            var newKeyword = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(newKeyword);
            this.newKeyword = newKeyword;
            var argumentList = (ArgumentListSyntax)reader.ReadValue();
            AdjustFlagsAndWidth(argumentList);
            this.argumentList = argumentList;
            var initializer = (InitializerExpressionSyntax?)reader.ReadValue();
            if (initializer != null)
            {
                AdjustFlagsAndWidth(initializer);
                this.initializer = initializer;
            }
        }

        internal override void WriteTo(ObjectWriter writer)
        {
            base.WriteTo(writer);
            writer.WriteValue(this.newKeyword);
            writer.WriteValue(this.argumentList);
            writer.WriteValue(this.initializer);
        }

        static ImplicitObjectCreationExpressionSyntax()
        {
            ObjectBinder.RegisterTypeReader(typeof(ImplicitObjectCreationExpressionSyntax), r => new ImplicitObjectCreationExpressionSyntax(r));
        }
    }

    /// <summary>Class which represents the syntax node for object creation expression.</summary>
    internal sealed partial class ObjectCreationExpressionSyntax : BaseObjectCreationExpressionSyntax
    {
        internal readonly SyntaxToken newKeyword;
        internal readonly TypeSyntax type;
        internal readonly ArgumentListSyntax? argumentList;
        internal readonly InitializerExpressionSyntax? initializer;

        internal ObjectCreationExpressionSyntax(SyntaxKind kind, SyntaxToken newKeyword, TypeSyntax type, ArgumentListSyntax? argumentList, InitializerExpressionSyntax? initializer, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
            this.SlotCount = 4;
            this.AdjustFlagsAndWidth(newKeyword);
            this.newKeyword = newKeyword;
            this.AdjustFlagsAndWidth(type);
            this.type = type;
            if (argumentList != null)
            {
                this.AdjustFlagsAndWidth(argumentList);
                this.argumentList = argumentList;
            }
            if (initializer != null)
            {
                this.AdjustFlagsAndWidth(initializer);
                this.initializer = initializer;
            }
        }

        internal ObjectCreationExpressionSyntax(SyntaxKind kind, SyntaxToken newKeyword, TypeSyntax type, ArgumentListSyntax? argumentList, InitializerExpressionSyntax? initializer, SyntaxFactoryContext context)
          : base(kind)
        {
            this.SetFactoryContext(context);
            this.SlotCount = 4;
            this.AdjustFlagsAndWidth(newKeyword);
            this.newKeyword = newKeyword;
            this.AdjustFlagsAndWidth(type);
            this.type = type;
            if (argumentList != null)
            {
                this.AdjustFlagsAndWidth(argumentList);
                this.argumentList = argumentList;
            }
            if (initializer != null)
            {
                this.AdjustFlagsAndWidth(initializer);
                this.initializer = initializer;
            }
        }

        internal ObjectCreationExpressionSyntax(SyntaxKind kind, SyntaxToken newKeyword, TypeSyntax type, ArgumentListSyntax? argumentList, InitializerExpressionSyntax? initializer)
          : base(kind)
        {
            this.SlotCount = 4;
            this.AdjustFlagsAndWidth(newKeyword);
            this.newKeyword = newKeyword;
            this.AdjustFlagsAndWidth(type);
            this.type = type;
            if (argumentList != null)
            {
                this.AdjustFlagsAndWidth(argumentList);
                this.argumentList = argumentList;
            }
            if (initializer != null)
            {
                this.AdjustFlagsAndWidth(initializer);
                this.initializer = initializer;
            }
        }

        /// <summary>SyntaxToken representing the new keyword.</summary>
        public override SyntaxToken NewKeyword => this.newKeyword;
        /// <summary>TypeSyntax representing the type of the object being created.</summary>
        public TypeSyntax Type => this.type;
        /// <summary>ArgumentListSyntax representing the list of arguments passed as part of the object creation expression.</summary>
        public override ArgumentListSyntax? ArgumentList => this.argumentList;
        /// <summary>InitializerExpressionSyntax representing the initializer expression for the object being created.</summary>
        public override InitializerExpressionSyntax? Initializer => this.initializer;

        internal override GreenNode? GetSlot(int index)
            => index switch
            {
                0 => this.newKeyword,
                1 => this.type,
                2 => this.argumentList,
                3 => this.initializer,
                _ => null,
            };

        internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new CSharp.Syntax.ObjectCreationExpressionSyntax(this, parent, position);

        public override void Accept(CSharpSyntaxVisitor visitor) => visitor.VisitObjectCreationExpression(this);
        public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor) => visitor.VisitObjectCreationExpression(this);

        public ObjectCreationExpressionSyntax Update(SyntaxToken newKeyword, TypeSyntax type, ArgumentListSyntax argumentList, InitializerExpressionSyntax initializer)
        {
            if (newKeyword != this.NewKeyword || type != this.Type || argumentList != this.ArgumentList || initializer != this.Initializer)
            {
                var newNode = SyntaxFactory.ObjectCreationExpression(newKeyword, type, argumentList, initializer);
                var diags = GetDiagnostics();
                if (diags?.Length > 0)
                    newNode = newNode.WithDiagnosticsGreen(diags);
                var annotations = GetAnnotations();
                if (annotations?.Length > 0)
                    newNode = newNode.WithAnnotationsGreen(annotations);
                return newNode;
            }

            return this;
        }

        internal override GreenNode SetDiagnostics(DiagnosticInfo[]? diagnostics)
            => new ObjectCreationExpressionSyntax(this.Kind, this.newKeyword, this.type, this.argumentList, this.initializer, diagnostics, GetAnnotations());

        internal override GreenNode SetAnnotations(SyntaxAnnotation[]? annotations)
            => new ObjectCreationExpressionSyntax(this.Kind, this.newKeyword, this.type, this.argumentList, this.initializer, GetDiagnostics(), annotations);

        internal ObjectCreationExpressionSyntax(ObjectReader reader)
          : base(reader)
        {
            this.SlotCount = 4;
            var newKeyword = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(newKeyword);
            this.newKeyword = newKeyword;
            var type = (TypeSyntax)reader.ReadValue();
            AdjustFlagsAndWidth(type);
            this.type = type;
            var argumentList = (ArgumentListSyntax?)reader.ReadValue();
            if (argumentList != null)
            {
                AdjustFlagsAndWidth(argumentList);
                this.argumentList = argumentList;
            }
            var initializer = (InitializerExpressionSyntax?)reader.ReadValue();
            if (initializer != null)
            {
                AdjustFlagsAndWidth(initializer);
                this.initializer = initializer;
            }
        }

        internal override void WriteTo(ObjectWriter writer)
        {
            base.WriteTo(writer);
            writer.WriteValue(this.newKeyword);
            writer.WriteValue(this.type);
            writer.WriteValue(this.argumentList);
            writer.WriteValue(this.initializer);
        }

        static ObjectCreationExpressionSyntax()
        {
            ObjectBinder.RegisterTypeReader(typeof(ObjectCreationExpressionSyntax), r => new ObjectCreationExpressionSyntax(r));
        }
    }

    internal sealed partial class WithExpressionSyntax : ExpressionSyntax
    {
        internal readonly ExpressionSyntax expression;
        internal readonly SyntaxToken withKeyword;
        internal readonly InitializerExpressionSyntax initializer;

        internal WithExpressionSyntax(SyntaxKind kind, ExpressionSyntax expression, SyntaxToken withKeyword, InitializerExpressionSyntax initializer, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
            this.SlotCount = 3;
            this.AdjustFlagsAndWidth(expression);
            this.expression = expression;
            this.AdjustFlagsAndWidth(withKeyword);
            this.withKeyword = withKeyword;
            this.AdjustFlagsAndWidth(initializer);
            this.initializer = initializer;
        }

        internal WithExpressionSyntax(SyntaxKind kind, ExpressionSyntax expression, SyntaxToken withKeyword, InitializerExpressionSyntax initializer, SyntaxFactoryContext context)
          : base(kind)
        {
            this.SetFactoryContext(context);
            this.SlotCount = 3;
            this.AdjustFlagsAndWidth(expression);
            this.expression = expression;
            this.AdjustFlagsAndWidth(withKeyword);
            this.withKeyword = withKeyword;
            this.AdjustFlagsAndWidth(initializer);
            this.initializer = initializer;
        }

        internal WithExpressionSyntax(SyntaxKind kind, ExpressionSyntax expression, SyntaxToken withKeyword, InitializerExpressionSyntax initializer)
          : base(kind)
        {
            this.SlotCount = 3;
            this.AdjustFlagsAndWidth(expression);
            this.expression = expression;
            this.AdjustFlagsAndWidth(withKeyword);
            this.withKeyword = withKeyword;
            this.AdjustFlagsAndWidth(initializer);
            this.initializer = initializer;
        }

        public ExpressionSyntax Expression => this.expression;
        public SyntaxToken WithKeyword => this.withKeyword;
        /// <summary>InitializerExpressionSyntax representing the initializer expression for the with expression.</summary>
        public InitializerExpressionSyntax Initializer => this.initializer;

        internal override GreenNode? GetSlot(int index)
            => index switch
            {
                0 => this.expression,
                1 => this.withKeyword,
                2 => this.initializer,
                _ => null,
            };

        internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new CSharp.Syntax.WithExpressionSyntax(this, parent, position);

        public override void Accept(CSharpSyntaxVisitor visitor) => visitor.VisitWithExpression(this);
        public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor) => visitor.VisitWithExpression(this);

        public WithExpressionSyntax Update(ExpressionSyntax expression, SyntaxToken withKeyword, InitializerExpressionSyntax initializer)
        {
            if (expression != this.Expression || withKeyword != this.WithKeyword || initializer != this.Initializer)
            {
                var newNode = SyntaxFactory.WithExpression(expression, withKeyword, initializer);
                var diags = GetDiagnostics();
                if (diags?.Length > 0)
                    newNode = newNode.WithDiagnosticsGreen(diags);
                var annotations = GetAnnotations();
                if (annotations?.Length > 0)
                    newNode = newNode.WithAnnotationsGreen(annotations);
                return newNode;
            }

            return this;
        }

        internal override GreenNode SetDiagnostics(DiagnosticInfo[]? diagnostics)
            => new WithExpressionSyntax(this.Kind, this.expression, this.withKeyword, this.initializer, diagnostics, GetAnnotations());

        internal override GreenNode SetAnnotations(SyntaxAnnotation[]? annotations)
            => new WithExpressionSyntax(this.Kind, this.expression, this.withKeyword, this.initializer, GetDiagnostics(), annotations);

        internal WithExpressionSyntax(ObjectReader reader)
          : base(reader)
        {
            this.SlotCount = 3;
            var expression = (ExpressionSyntax)reader.ReadValue();
            AdjustFlagsAndWidth(expression);
            this.expression = expression;
            var withKeyword = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(withKeyword);
            this.withKeyword = withKeyword;
            var initializer = (InitializerExpressionSyntax)reader.ReadValue();
            AdjustFlagsAndWidth(initializer);
            this.initializer = initializer;
        }

        internal override void WriteTo(ObjectWriter writer)
        {
            base.WriteTo(writer);
            writer.WriteValue(this.expression);
            writer.WriteValue(this.withKeyword);
            writer.WriteValue(this.initializer);
        }

        static WithExpressionSyntax()
        {
            ObjectBinder.RegisterTypeReader(typeof(WithExpressionSyntax), r => new WithExpressionSyntax(r));
        }
    }

    internal sealed partial class AnonymousObjectMemberDeclaratorSyntax : CSharpSyntaxNode
    {
        internal readonly NameEqualsSyntax? nameEquals;
        internal readonly ExpressionSyntax expression;

        internal AnonymousObjectMemberDeclaratorSyntax(SyntaxKind kind, NameEqualsSyntax? nameEquals, ExpressionSyntax expression, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
            this.SlotCount = 2;
            if (nameEquals != null)
            {
                this.AdjustFlagsAndWidth(nameEquals);
                this.nameEquals = nameEquals;
            }
            this.AdjustFlagsAndWidth(expression);
            this.expression = expression;
        }

        internal AnonymousObjectMemberDeclaratorSyntax(SyntaxKind kind, NameEqualsSyntax? nameEquals, ExpressionSyntax expression, SyntaxFactoryContext context)
          : base(kind)
        {
            this.SetFactoryContext(context);
            this.SlotCount = 2;
            if (nameEquals != null)
            {
                this.AdjustFlagsAndWidth(nameEquals);
                this.nameEquals = nameEquals;
            }
            this.AdjustFlagsAndWidth(expression);
            this.expression = expression;
        }

        internal AnonymousObjectMemberDeclaratorSyntax(SyntaxKind kind, NameEqualsSyntax? nameEquals, ExpressionSyntax expression)
          : base(kind)
        {
            this.SlotCount = 2;
            if (nameEquals != null)
            {
                this.AdjustFlagsAndWidth(nameEquals);
                this.nameEquals = nameEquals;
            }
            this.AdjustFlagsAndWidth(expression);
            this.expression = expression;
        }

        /// <summary>NameEqualsSyntax representing the optional name of the member being initialized.</summary>
        public NameEqualsSyntax? NameEquals => this.nameEquals;
        /// <summary>ExpressionSyntax representing the value the member is initialized with.</summary>
        public ExpressionSyntax Expression => this.expression;

        internal override GreenNode? GetSlot(int index)
            => index switch
            {
                0 => this.nameEquals,
                1 => this.expression,
                _ => null,
            };

        internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new CSharp.Syntax.AnonymousObjectMemberDeclaratorSyntax(this, parent, position);

        public override void Accept(CSharpSyntaxVisitor visitor) => visitor.VisitAnonymousObjectMemberDeclarator(this);
        public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor) => visitor.VisitAnonymousObjectMemberDeclarator(this);

        public AnonymousObjectMemberDeclaratorSyntax Update(NameEqualsSyntax nameEquals, ExpressionSyntax expression)
        {
            if (nameEquals != this.NameEquals || expression != this.Expression)
            {
                var newNode = SyntaxFactory.AnonymousObjectMemberDeclarator(nameEquals, expression);
                var diags = GetDiagnostics();
                if (diags?.Length > 0)
                    newNode = newNode.WithDiagnosticsGreen(diags);
                var annotations = GetAnnotations();
                if (annotations?.Length > 0)
                    newNode = newNode.WithAnnotationsGreen(annotations);
                return newNode;
            }

            return this;
        }

        internal override GreenNode SetDiagnostics(DiagnosticInfo[]? diagnostics)
            => new AnonymousObjectMemberDeclaratorSyntax(this.Kind, this.nameEquals, this.expression, diagnostics, GetAnnotations());

        internal override GreenNode SetAnnotations(SyntaxAnnotation[]? annotations)
            => new AnonymousObjectMemberDeclaratorSyntax(this.Kind, this.nameEquals, this.expression, GetDiagnostics(), annotations);

        internal AnonymousObjectMemberDeclaratorSyntax(ObjectReader reader)
          : base(reader)
        {
            this.SlotCount = 2;
            var nameEquals = (NameEqualsSyntax?)reader.ReadValue();
            if (nameEquals != null)
            {
                AdjustFlagsAndWidth(nameEquals);
                this.nameEquals = nameEquals;
            }
            var expression = (ExpressionSyntax)reader.ReadValue();
            AdjustFlagsAndWidth(expression);
            this.expression = expression;
        }

        internal override void WriteTo(ObjectWriter writer)
        {
            base.WriteTo(writer);
            writer.WriteValue(this.nameEquals);
            writer.WriteValue(this.expression);
        }

        static AnonymousObjectMemberDeclaratorSyntax()
        {
            ObjectBinder.RegisterTypeReader(typeof(AnonymousObjectMemberDeclaratorSyntax), r => new AnonymousObjectMemberDeclaratorSyntax(r));
        }
    }

    /// <summary>Class which represents the syntax node for anonymous object creation expression.</summary>
    internal sealed partial class AnonymousObjectCreationExpressionSyntax : ExpressionSyntax
    {
        internal readonly SyntaxToken newKeyword;
        internal readonly SyntaxToken openBraceToken;
        internal readonly GreenNode? initializers;
        internal readonly SyntaxToken closeBraceToken;

        internal AnonymousObjectCreationExpressionSyntax(SyntaxKind kind, SyntaxToken newKeyword, SyntaxToken openBraceToken, GreenNode? initializers, SyntaxToken closeBraceToken, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
            this.SlotCount = 4;
            this.AdjustFlagsAndWidth(newKeyword);
            this.newKeyword = newKeyword;
            this.AdjustFlagsAndWidth(openBraceToken);
            this.openBraceToken = openBraceToken;
            if (initializers != null)
            {
                this.AdjustFlagsAndWidth(initializers);
                this.initializers = initializers;
            }
            this.AdjustFlagsAndWidth(closeBraceToken);
            this.closeBraceToken = closeBraceToken;
        }

        internal AnonymousObjectCreationExpressionSyntax(SyntaxKind kind, SyntaxToken newKeyword, SyntaxToken openBraceToken, GreenNode? initializers, SyntaxToken closeBraceToken, SyntaxFactoryContext context)
          : base(kind)
        {
            this.SetFactoryContext(context);
            this.SlotCount = 4;
            this.AdjustFlagsAndWidth(newKeyword);
            this.newKeyword = newKeyword;
            this.AdjustFlagsAndWidth(openBraceToken);
            this.openBraceToken = openBraceToken;
            if (initializers != null)
            {
                this.AdjustFlagsAndWidth(initializers);
                this.initializers = initializers;
            }
            this.AdjustFlagsAndWidth(closeBraceToken);
            this.closeBraceToken = closeBraceToken;
        }

        internal AnonymousObjectCreationExpressionSyntax(SyntaxKind kind, SyntaxToken newKeyword, SyntaxToken openBraceToken, GreenNode? initializers, SyntaxToken closeBraceToken)
          : base(kind)
        {
            this.SlotCount = 4;
            this.AdjustFlagsAndWidth(newKeyword);
            this.newKeyword = newKeyword;
            this.AdjustFlagsAndWidth(openBraceToken);
            this.openBraceToken = openBraceToken;
            if (initializers != null)
            {
                this.AdjustFlagsAndWidth(initializers);
                this.initializers = initializers;
            }
            this.AdjustFlagsAndWidth(closeBraceToken);
            this.closeBraceToken = closeBraceToken;
        }

        /// <summary>SyntaxToken representing the new keyword.</summary>
        public SyntaxToken NewKeyword => this.newKeyword;
        /// <summary>SyntaxToken representing the open brace.</summary>
        public SyntaxToken OpenBraceToken => this.openBraceToken;
        /// <summary>SeparatedSyntaxList of AnonymousObjectMemberDeclaratorSyntax representing the list of object member initializers.</summary>
        public Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<AnonymousObjectMemberDeclaratorSyntax> Initializers => new Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<AnonymousObjectMemberDeclaratorSyntax>(new Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<CSharpSyntaxNode>(this.initializers));
        /// <summary>SyntaxToken representing the close brace.</summary>
        public SyntaxToken CloseBraceToken => this.closeBraceToken;

        internal override GreenNode? GetSlot(int index)
            => index switch
            {
                0 => this.newKeyword,
                1 => this.openBraceToken,
                2 => this.initializers,
                3 => this.closeBraceToken,
                _ => null,
            };

        internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new CSharp.Syntax.AnonymousObjectCreationExpressionSyntax(this, parent, position);

        public override void Accept(CSharpSyntaxVisitor visitor) => visitor.VisitAnonymousObjectCreationExpression(this);
        public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor) => visitor.VisitAnonymousObjectCreationExpression(this);

        public AnonymousObjectCreationExpressionSyntax Update(SyntaxToken newKeyword, SyntaxToken openBraceToken, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<AnonymousObjectMemberDeclaratorSyntax> initializers, SyntaxToken closeBraceToken)
        {
            if (newKeyword != this.NewKeyword || openBraceToken != this.OpenBraceToken || initializers != this.Initializers || closeBraceToken != this.CloseBraceToken)
            {
                var newNode = SyntaxFactory.AnonymousObjectCreationExpression(newKeyword, openBraceToken, initializers, closeBraceToken);
                var diags = GetDiagnostics();
                if (diags?.Length > 0)
                    newNode = newNode.WithDiagnosticsGreen(diags);
                var annotations = GetAnnotations();
                if (annotations?.Length > 0)
                    newNode = newNode.WithAnnotationsGreen(annotations);
                return newNode;
            }

            return this;
        }

        internal override GreenNode SetDiagnostics(DiagnosticInfo[]? diagnostics)
            => new AnonymousObjectCreationExpressionSyntax(this.Kind, this.newKeyword, this.openBraceToken, this.initializers, this.closeBraceToken, diagnostics, GetAnnotations());

        internal override GreenNode SetAnnotations(SyntaxAnnotation[]? annotations)
            => new AnonymousObjectCreationExpressionSyntax(this.Kind, this.newKeyword, this.openBraceToken, this.initializers, this.closeBraceToken, GetDiagnostics(), annotations);

        internal AnonymousObjectCreationExpressionSyntax(ObjectReader reader)
          : base(reader)
        {
            this.SlotCount = 4;
            var newKeyword = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(newKeyword);
            this.newKeyword = newKeyword;
            var openBraceToken = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(openBraceToken);
            this.openBraceToken = openBraceToken;
            var initializers = (GreenNode?)reader.ReadValue();
            if (initializers != null)
            {
                AdjustFlagsAndWidth(initializers);
                this.initializers = initializers;
            }
            var closeBraceToken = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(closeBraceToken);
            this.closeBraceToken = closeBraceToken;
        }

        internal override void WriteTo(ObjectWriter writer)
        {
            base.WriteTo(writer);
            writer.WriteValue(this.newKeyword);
            writer.WriteValue(this.openBraceToken);
            writer.WriteValue(this.initializers);
            writer.WriteValue(this.closeBraceToken);
        }

        static AnonymousObjectCreationExpressionSyntax()
        {
            ObjectBinder.RegisterTypeReader(typeof(AnonymousObjectCreationExpressionSyntax), r => new AnonymousObjectCreationExpressionSyntax(r));
        }
    }

    /// <summary>Class which represents the syntax node for array creation expression.</summary>
    internal sealed partial class ArrayCreationExpressionSyntax : ExpressionSyntax
    {
        internal readonly SyntaxToken newKeyword;
        internal readonly ArrayTypeSyntax type;
        internal readonly InitializerExpressionSyntax? initializer;

        internal ArrayCreationExpressionSyntax(SyntaxKind kind, SyntaxToken newKeyword, ArrayTypeSyntax type, InitializerExpressionSyntax? initializer, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
            this.SlotCount = 3;
            this.AdjustFlagsAndWidth(newKeyword);
            this.newKeyword = newKeyword;
            this.AdjustFlagsAndWidth(type);
            this.type = type;
            if (initializer != null)
            {
                this.AdjustFlagsAndWidth(initializer);
                this.initializer = initializer;
            }
        }

        internal ArrayCreationExpressionSyntax(SyntaxKind kind, SyntaxToken newKeyword, ArrayTypeSyntax type, InitializerExpressionSyntax? initializer, SyntaxFactoryContext context)
          : base(kind)
        {
            this.SetFactoryContext(context);
            this.SlotCount = 3;
            this.AdjustFlagsAndWidth(newKeyword);
            this.newKeyword = newKeyword;
            this.AdjustFlagsAndWidth(type);
            this.type = type;
            if (initializer != null)
            {
                this.AdjustFlagsAndWidth(initializer);
                this.initializer = initializer;
            }
        }

        internal ArrayCreationExpressionSyntax(SyntaxKind kind, SyntaxToken newKeyword, ArrayTypeSyntax type, InitializerExpressionSyntax? initializer)
          : base(kind)
        {
            this.SlotCount = 3;
            this.AdjustFlagsAndWidth(newKeyword);
            this.newKeyword = newKeyword;
            this.AdjustFlagsAndWidth(type);
            this.type = type;
            if (initializer != null)
            {
                this.AdjustFlagsAndWidth(initializer);
                this.initializer = initializer;
            }
        }

        /// <summary>SyntaxToken representing the new keyword.</summary>
        public SyntaxToken NewKeyword => this.newKeyword;
        /// <summary>ArrayTypeSyntax node representing the type of the array.</summary>
        public ArrayTypeSyntax Type => this.type;
        /// <summary>InitializerExpressionSyntax node representing the initializer of the array creation expression.</summary>
        public InitializerExpressionSyntax? Initializer => this.initializer;

        internal override GreenNode? GetSlot(int index)
            => index switch
            {
                0 => this.newKeyword,
                1 => this.type,
                2 => this.initializer,
                _ => null,
            };

        internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new CSharp.Syntax.ArrayCreationExpressionSyntax(this, parent, position);

        public override void Accept(CSharpSyntaxVisitor visitor) => visitor.VisitArrayCreationExpression(this);
        public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor) => visitor.VisitArrayCreationExpression(this);

        public ArrayCreationExpressionSyntax Update(SyntaxToken newKeyword, ArrayTypeSyntax type, InitializerExpressionSyntax initializer)
        {
            if (newKeyword != this.NewKeyword || type != this.Type || initializer != this.Initializer)
            {
                var newNode = SyntaxFactory.ArrayCreationExpression(newKeyword, type, initializer);
                var diags = GetDiagnostics();
                if (diags?.Length > 0)
                    newNode = newNode.WithDiagnosticsGreen(diags);
                var annotations = GetAnnotations();
                if (annotations?.Length > 0)
                    newNode = newNode.WithAnnotationsGreen(annotations);
                return newNode;
            }

            return this;
        }

        internal override GreenNode SetDiagnostics(DiagnosticInfo[]? diagnostics)
            => new ArrayCreationExpressionSyntax(this.Kind, this.newKeyword, this.type, this.initializer, diagnostics, GetAnnotations());

        internal override GreenNode SetAnnotations(SyntaxAnnotation[]? annotations)
            => new ArrayCreationExpressionSyntax(this.Kind, this.newKeyword, this.type, this.initializer, GetDiagnostics(), annotations);

        internal ArrayCreationExpressionSyntax(ObjectReader reader)
          : base(reader)
        {
            this.SlotCount = 3;
            var newKeyword = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(newKeyword);
            this.newKeyword = newKeyword;
            var type = (ArrayTypeSyntax)reader.ReadValue();
            AdjustFlagsAndWidth(type);
            this.type = type;
            var initializer = (InitializerExpressionSyntax?)reader.ReadValue();
            if (initializer != null)
            {
                AdjustFlagsAndWidth(initializer);
                this.initializer = initializer;
            }
        }

        internal override void WriteTo(ObjectWriter writer)
        {
            base.WriteTo(writer);
            writer.WriteValue(this.newKeyword);
            writer.WriteValue(this.type);
            writer.WriteValue(this.initializer);
        }

        static ArrayCreationExpressionSyntax()
        {
            ObjectBinder.RegisterTypeReader(typeof(ArrayCreationExpressionSyntax), r => new ArrayCreationExpressionSyntax(r));
        }
    }

    /// <summary>Class which represents the syntax node for implicit array creation expression.</summary>
    internal sealed partial class ImplicitArrayCreationExpressionSyntax : ExpressionSyntax
    {
        internal readonly SyntaxToken newKeyword;
        internal readonly SyntaxToken openBracketToken;
        internal readonly GreenNode? commas;
        internal readonly SyntaxToken closeBracketToken;
        internal readonly InitializerExpressionSyntax initializer;

        internal ImplicitArrayCreationExpressionSyntax(SyntaxKind kind, SyntaxToken newKeyword, SyntaxToken openBracketToken, GreenNode? commas, SyntaxToken closeBracketToken, InitializerExpressionSyntax initializer, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
            this.SlotCount = 5;
            this.AdjustFlagsAndWidth(newKeyword);
            this.newKeyword = newKeyword;
            this.AdjustFlagsAndWidth(openBracketToken);
            this.openBracketToken = openBracketToken;
            if (commas != null)
            {
                this.AdjustFlagsAndWidth(commas);
                this.commas = commas;
            }
            this.AdjustFlagsAndWidth(closeBracketToken);
            this.closeBracketToken = closeBracketToken;
            this.AdjustFlagsAndWidth(initializer);
            this.initializer = initializer;
        }

        internal ImplicitArrayCreationExpressionSyntax(SyntaxKind kind, SyntaxToken newKeyword, SyntaxToken openBracketToken, GreenNode? commas, SyntaxToken closeBracketToken, InitializerExpressionSyntax initializer, SyntaxFactoryContext context)
          : base(kind)
        {
            this.SetFactoryContext(context);
            this.SlotCount = 5;
            this.AdjustFlagsAndWidth(newKeyword);
            this.newKeyword = newKeyword;
            this.AdjustFlagsAndWidth(openBracketToken);
            this.openBracketToken = openBracketToken;
            if (commas != null)
            {
                this.AdjustFlagsAndWidth(commas);
                this.commas = commas;
            }
            this.AdjustFlagsAndWidth(closeBracketToken);
            this.closeBracketToken = closeBracketToken;
            this.AdjustFlagsAndWidth(initializer);
            this.initializer = initializer;
        }

        internal ImplicitArrayCreationExpressionSyntax(SyntaxKind kind, SyntaxToken newKeyword, SyntaxToken openBracketToken, GreenNode? commas, SyntaxToken closeBracketToken, InitializerExpressionSyntax initializer)
          : base(kind)
        {
            this.SlotCount = 5;
            this.AdjustFlagsAndWidth(newKeyword);
            this.newKeyword = newKeyword;
            this.AdjustFlagsAndWidth(openBracketToken);
            this.openBracketToken = openBracketToken;
            if (commas != null)
            {
                this.AdjustFlagsAndWidth(commas);
                this.commas = commas;
            }
            this.AdjustFlagsAndWidth(closeBracketToken);
            this.closeBracketToken = closeBracketToken;
            this.AdjustFlagsAndWidth(initializer);
            this.initializer = initializer;
        }

        /// <summary>SyntaxToken representing the new keyword.</summary>
        public SyntaxToken NewKeyword => this.newKeyword;
        /// <summary>SyntaxToken representing the open bracket.</summary>
        public SyntaxToken OpenBracketToken => this.openBracketToken;
        /// <summary>SyntaxList of SyntaxToken representing the commas in the implicit array creation expression.</summary>
        public Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SyntaxToken> Commas => new Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SyntaxToken>(this.commas);
        /// <summary>SyntaxToken representing the close bracket.</summary>
        public SyntaxToken CloseBracketToken => this.closeBracketToken;
        /// <summary>InitializerExpressionSyntax representing the initializer expression of the implicit array creation expression.</summary>
        public InitializerExpressionSyntax Initializer => this.initializer;

        internal override GreenNode? GetSlot(int index)
            => index switch
            {
                0 => this.newKeyword,
                1 => this.openBracketToken,
                2 => this.commas,
                3 => this.closeBracketToken,
                4 => this.initializer,
                _ => null,
            };

        internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new CSharp.Syntax.ImplicitArrayCreationExpressionSyntax(this, parent, position);

        public override void Accept(CSharpSyntaxVisitor visitor) => visitor.VisitImplicitArrayCreationExpression(this);
        public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor) => visitor.VisitImplicitArrayCreationExpression(this);

        public ImplicitArrayCreationExpressionSyntax Update(SyntaxToken newKeyword, SyntaxToken openBracketToken, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SyntaxToken> commas, SyntaxToken closeBracketToken, InitializerExpressionSyntax initializer)
        {
            if (newKeyword != this.NewKeyword || openBracketToken != this.OpenBracketToken || commas != this.Commas || closeBracketToken != this.CloseBracketToken || initializer != this.Initializer)
            {
                var newNode = SyntaxFactory.ImplicitArrayCreationExpression(newKeyword, openBracketToken, commas, closeBracketToken, initializer);
                var diags = GetDiagnostics();
                if (diags?.Length > 0)
                    newNode = newNode.WithDiagnosticsGreen(diags);
                var annotations = GetAnnotations();
                if (annotations?.Length > 0)
                    newNode = newNode.WithAnnotationsGreen(annotations);
                return newNode;
            }

            return this;
        }

        internal override GreenNode SetDiagnostics(DiagnosticInfo[]? diagnostics)
            => new ImplicitArrayCreationExpressionSyntax(this.Kind, this.newKeyword, this.openBracketToken, this.commas, this.closeBracketToken, this.initializer, diagnostics, GetAnnotations());

        internal override GreenNode SetAnnotations(SyntaxAnnotation[]? annotations)
            => new ImplicitArrayCreationExpressionSyntax(this.Kind, this.newKeyword, this.openBracketToken, this.commas, this.closeBracketToken, this.initializer, GetDiagnostics(), annotations);

        internal ImplicitArrayCreationExpressionSyntax(ObjectReader reader)
          : base(reader)
        {
            this.SlotCount = 5;
            var newKeyword = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(newKeyword);
            this.newKeyword = newKeyword;
            var openBracketToken = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(openBracketToken);
            this.openBracketToken = openBracketToken;
            var commas = (GreenNode?)reader.ReadValue();
            if (commas != null)
            {
                AdjustFlagsAndWidth(commas);
                this.commas = commas;
            }
            var closeBracketToken = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(closeBracketToken);
            this.closeBracketToken = closeBracketToken;
            var initializer = (InitializerExpressionSyntax)reader.ReadValue();
            AdjustFlagsAndWidth(initializer);
            this.initializer = initializer;
        }

        internal override void WriteTo(ObjectWriter writer)
        {
            base.WriteTo(writer);
            writer.WriteValue(this.newKeyword);
            writer.WriteValue(this.openBracketToken);
            writer.WriteValue(this.commas);
            writer.WriteValue(this.closeBracketToken);
            writer.WriteValue(this.initializer);
        }

        static ImplicitArrayCreationExpressionSyntax()
        {
            ObjectBinder.RegisterTypeReader(typeof(ImplicitArrayCreationExpressionSyntax), r => new ImplicitArrayCreationExpressionSyntax(r));
        }
    }

    /// <summary>Class which represents the syntax node for stackalloc array creation expression.</summary>
    internal sealed partial class StackAllocArrayCreationExpressionSyntax : ExpressionSyntax
    {
        internal readonly SyntaxToken stackAllocKeyword;
        internal readonly TypeSyntax type;
        internal readonly InitializerExpressionSyntax? initializer;

        internal StackAllocArrayCreationExpressionSyntax(SyntaxKind kind, SyntaxToken stackAllocKeyword, TypeSyntax type, InitializerExpressionSyntax? initializer, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
            this.SlotCount = 3;
            this.AdjustFlagsAndWidth(stackAllocKeyword);
            this.stackAllocKeyword = stackAllocKeyword;
            this.AdjustFlagsAndWidth(type);
            this.type = type;
            if (initializer != null)
            {
                this.AdjustFlagsAndWidth(initializer);
                this.initializer = initializer;
            }
        }

        internal StackAllocArrayCreationExpressionSyntax(SyntaxKind kind, SyntaxToken stackAllocKeyword, TypeSyntax type, InitializerExpressionSyntax? initializer, SyntaxFactoryContext context)
          : base(kind)
        {
            this.SetFactoryContext(context);
            this.SlotCount = 3;
            this.AdjustFlagsAndWidth(stackAllocKeyword);
            this.stackAllocKeyword = stackAllocKeyword;
            this.AdjustFlagsAndWidth(type);
            this.type = type;
            if (initializer != null)
            {
                this.AdjustFlagsAndWidth(initializer);
                this.initializer = initializer;
            }
        }

        internal StackAllocArrayCreationExpressionSyntax(SyntaxKind kind, SyntaxToken stackAllocKeyword, TypeSyntax type, InitializerExpressionSyntax? initializer)
          : base(kind)
        {
            this.SlotCount = 3;
            this.AdjustFlagsAndWidth(stackAllocKeyword);
            this.stackAllocKeyword = stackAllocKeyword;
            this.AdjustFlagsAndWidth(type);
            this.type = type;
            if (initializer != null)
            {
                this.AdjustFlagsAndWidth(initializer);
                this.initializer = initializer;
            }
        }

        /// <summary>SyntaxToken representing the stackalloc keyword.</summary>
        public SyntaxToken StackAllocKeyword => this.stackAllocKeyword;
        /// <summary>TypeSyntax node representing the type of the stackalloc array.</summary>
        public TypeSyntax Type => this.type;
        /// <summary>InitializerExpressionSyntax node representing the initializer of the stackalloc array creation expression.</summary>
        public InitializerExpressionSyntax? Initializer => this.initializer;

        internal override GreenNode? GetSlot(int index)
            => index switch
            {
                0 => this.stackAllocKeyword,
                1 => this.type,
                2 => this.initializer,
                _ => null,
            };

        internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new CSharp.Syntax.StackAllocArrayCreationExpressionSyntax(this, parent, position);

        public override void Accept(CSharpSyntaxVisitor visitor) => visitor.VisitStackAllocArrayCreationExpression(this);
        public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor) => visitor.VisitStackAllocArrayCreationExpression(this);

        public StackAllocArrayCreationExpressionSyntax Update(SyntaxToken stackAllocKeyword, TypeSyntax type, InitializerExpressionSyntax initializer)
        {
            if (stackAllocKeyword != this.StackAllocKeyword || type != this.Type || initializer != this.Initializer)
            {
                var newNode = SyntaxFactory.StackAllocArrayCreationExpression(stackAllocKeyword, type, initializer);
                var diags = GetDiagnostics();
                if (diags?.Length > 0)
                    newNode = newNode.WithDiagnosticsGreen(diags);
                var annotations = GetAnnotations();
                if (annotations?.Length > 0)
                    newNode = newNode.WithAnnotationsGreen(annotations);
                return newNode;
            }

            return this;
        }

        internal override GreenNode SetDiagnostics(DiagnosticInfo[]? diagnostics)
            => new StackAllocArrayCreationExpressionSyntax(this.Kind, this.stackAllocKeyword, this.type, this.initializer, diagnostics, GetAnnotations());

        internal override GreenNode SetAnnotations(SyntaxAnnotation[]? annotations)
            => new StackAllocArrayCreationExpressionSyntax(this.Kind, this.stackAllocKeyword, this.type, this.initializer, GetDiagnostics(), annotations);

        internal StackAllocArrayCreationExpressionSyntax(ObjectReader reader)
          : base(reader)
        {
            this.SlotCount = 3;
            var stackAllocKeyword = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(stackAllocKeyword);
            this.stackAllocKeyword = stackAllocKeyword;
            var type = (TypeSyntax)reader.ReadValue();
            AdjustFlagsAndWidth(type);
            this.type = type;
            var initializer = (InitializerExpressionSyntax?)reader.ReadValue();
            if (initializer != null)
            {
                AdjustFlagsAndWidth(initializer);
                this.initializer = initializer;
            }
        }

        internal override void WriteTo(ObjectWriter writer)
        {
            base.WriteTo(writer);
            writer.WriteValue(this.stackAllocKeyword);
            writer.WriteValue(this.type);
            writer.WriteValue(this.initializer);
        }

        static StackAllocArrayCreationExpressionSyntax()
        {
            ObjectBinder.RegisterTypeReader(typeof(StackAllocArrayCreationExpressionSyntax), r => new StackAllocArrayCreationExpressionSyntax(r));
        }
    }

    /// <summary>Class which represents the syntax node for implicit stackalloc array creation expression.</summary>
    internal sealed partial class ImplicitStackAllocArrayCreationExpressionSyntax : ExpressionSyntax
    {
        internal readonly SyntaxToken stackAllocKeyword;
        internal readonly SyntaxToken openBracketToken;
        internal readonly SyntaxToken closeBracketToken;
        internal readonly InitializerExpressionSyntax initializer;

        internal ImplicitStackAllocArrayCreationExpressionSyntax(SyntaxKind kind, SyntaxToken stackAllocKeyword, SyntaxToken openBracketToken, SyntaxToken closeBracketToken, InitializerExpressionSyntax initializer, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
            this.SlotCount = 4;
            this.AdjustFlagsAndWidth(stackAllocKeyword);
            this.stackAllocKeyword = stackAllocKeyword;
            this.AdjustFlagsAndWidth(openBracketToken);
            this.openBracketToken = openBracketToken;
            this.AdjustFlagsAndWidth(closeBracketToken);
            this.closeBracketToken = closeBracketToken;
            this.AdjustFlagsAndWidth(initializer);
            this.initializer = initializer;
        }

        internal ImplicitStackAllocArrayCreationExpressionSyntax(SyntaxKind kind, SyntaxToken stackAllocKeyword, SyntaxToken openBracketToken, SyntaxToken closeBracketToken, InitializerExpressionSyntax initializer, SyntaxFactoryContext context)
          : base(kind)
        {
            this.SetFactoryContext(context);
            this.SlotCount = 4;
            this.AdjustFlagsAndWidth(stackAllocKeyword);
            this.stackAllocKeyword = stackAllocKeyword;
            this.AdjustFlagsAndWidth(openBracketToken);
            this.openBracketToken = openBracketToken;
            this.AdjustFlagsAndWidth(closeBracketToken);
            this.closeBracketToken = closeBracketToken;
            this.AdjustFlagsAndWidth(initializer);
            this.initializer = initializer;
        }

        internal ImplicitStackAllocArrayCreationExpressionSyntax(SyntaxKind kind, SyntaxToken stackAllocKeyword, SyntaxToken openBracketToken, SyntaxToken closeBracketToken, InitializerExpressionSyntax initializer)
          : base(kind)
        {
            this.SlotCount = 4;
            this.AdjustFlagsAndWidth(stackAllocKeyword);
            this.stackAllocKeyword = stackAllocKeyword;
            this.AdjustFlagsAndWidth(openBracketToken);
            this.openBracketToken = openBracketToken;
            this.AdjustFlagsAndWidth(closeBracketToken);
            this.closeBracketToken = closeBracketToken;
            this.AdjustFlagsAndWidth(initializer);
            this.initializer = initializer;
        }

        /// <summary>SyntaxToken representing the stackalloc keyword.</summary>
        public SyntaxToken StackAllocKeyword => this.stackAllocKeyword;
        /// <summary>SyntaxToken representing the open bracket.</summary>
        public SyntaxToken OpenBracketToken => this.openBracketToken;
        /// <summary>SyntaxToken representing the close bracket.</summary>
        public SyntaxToken CloseBracketToken => this.closeBracketToken;
        /// <summary>InitializerExpressionSyntax representing the initializer expression of the implicit stackalloc array creation expression.</summary>
        public InitializerExpressionSyntax Initializer => this.initializer;

        internal override GreenNode? GetSlot(int index)
            => index switch
            {
                0 => this.stackAllocKeyword,
                1 => this.openBracketToken,
                2 => this.closeBracketToken,
                3 => this.initializer,
                _ => null,
            };

        internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new CSharp.Syntax.ImplicitStackAllocArrayCreationExpressionSyntax(this, parent, position);

        public override void Accept(CSharpSyntaxVisitor visitor) => visitor.VisitImplicitStackAllocArrayCreationExpression(this);
        public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor) => visitor.VisitImplicitStackAllocArrayCreationExpression(this);

        public ImplicitStackAllocArrayCreationExpressionSyntax Update(SyntaxToken stackAllocKeyword, SyntaxToken openBracketToken, SyntaxToken closeBracketToken, InitializerExpressionSyntax initializer)
        {
            if (stackAllocKeyword != this.StackAllocKeyword || openBracketToken != this.OpenBracketToken || closeBracketToken != this.CloseBracketToken || initializer != this.Initializer)
            {
                var newNode = SyntaxFactory.ImplicitStackAllocArrayCreationExpression(stackAllocKeyword, openBracketToken, closeBracketToken, initializer);
                var diags = GetDiagnostics();
                if (diags?.Length > 0)
                    newNode = newNode.WithDiagnosticsGreen(diags);
                var annotations = GetAnnotations();
                if (annotations?.Length > 0)
                    newNode = newNode.WithAnnotationsGreen(annotations);
                return newNode;
            }

            return this;
        }

        internal override GreenNode SetDiagnostics(DiagnosticInfo[]? diagnostics)
            => new ImplicitStackAllocArrayCreationExpressionSyntax(this.Kind, this.stackAllocKeyword, this.openBracketToken, this.closeBracketToken, this.initializer, diagnostics, GetAnnotations());

        internal override GreenNode SetAnnotations(SyntaxAnnotation[]? annotations)
            => new ImplicitStackAllocArrayCreationExpressionSyntax(this.Kind, this.stackAllocKeyword, this.openBracketToken, this.closeBracketToken, this.initializer, GetDiagnostics(), annotations);

        internal ImplicitStackAllocArrayCreationExpressionSyntax(ObjectReader reader)
          : base(reader)
        {
            this.SlotCount = 4;
            var stackAllocKeyword = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(stackAllocKeyword);
            this.stackAllocKeyword = stackAllocKeyword;
            var openBracketToken = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(openBracketToken);
            this.openBracketToken = openBracketToken;
            var closeBracketToken = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(closeBracketToken);
            this.closeBracketToken = closeBracketToken;
            var initializer = (InitializerExpressionSyntax)reader.ReadValue();
            AdjustFlagsAndWidth(initializer);
            this.initializer = initializer;
        }

        internal override void WriteTo(ObjectWriter writer)
        {
            base.WriteTo(writer);
            writer.WriteValue(this.stackAllocKeyword);
            writer.WriteValue(this.openBracketToken);
            writer.WriteValue(this.closeBracketToken);
            writer.WriteValue(this.initializer);
        }

        static ImplicitStackAllocArrayCreationExpressionSyntax()
        {
            ObjectBinder.RegisterTypeReader(typeof(ImplicitStackAllocArrayCreationExpressionSyntax), r => new ImplicitStackAllocArrayCreationExpressionSyntax(r));
        }
    }

    internal abstract partial class QueryClauseSyntax : CSharpSyntaxNode
    {
        internal QueryClauseSyntax(SyntaxKind kind, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
        }

        internal QueryClauseSyntax(SyntaxKind kind)
          : base(kind)
        {
        }

        protected QueryClauseSyntax(ObjectReader reader)
          : base(reader)
        {
        }
    }

    internal abstract partial class SelectOrGroupClauseSyntax : CSharpSyntaxNode
    {
        internal SelectOrGroupClauseSyntax(SyntaxKind kind, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
        }

        internal SelectOrGroupClauseSyntax(SyntaxKind kind)
          : base(kind)
        {
        }

        protected SelectOrGroupClauseSyntax(ObjectReader reader)
          : base(reader)
        {
        }
    }

    internal sealed partial class QueryExpressionSyntax : ExpressionSyntax
    {
        internal readonly FromClauseSyntax fromClause;
        internal readonly QueryBodySyntax body;

        internal QueryExpressionSyntax(SyntaxKind kind, FromClauseSyntax fromClause, QueryBodySyntax body, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
            this.SlotCount = 2;
            this.AdjustFlagsAndWidth(fromClause);
            this.fromClause = fromClause;
            this.AdjustFlagsAndWidth(body);
            this.body = body;
        }

        internal QueryExpressionSyntax(SyntaxKind kind, FromClauseSyntax fromClause, QueryBodySyntax body, SyntaxFactoryContext context)
          : base(kind)
        {
            this.SetFactoryContext(context);
            this.SlotCount = 2;
            this.AdjustFlagsAndWidth(fromClause);
            this.fromClause = fromClause;
            this.AdjustFlagsAndWidth(body);
            this.body = body;
        }

        internal QueryExpressionSyntax(SyntaxKind kind, FromClauseSyntax fromClause, QueryBodySyntax body)
          : base(kind)
        {
            this.SlotCount = 2;
            this.AdjustFlagsAndWidth(fromClause);
            this.fromClause = fromClause;
            this.AdjustFlagsAndWidth(body);
            this.body = body;
        }

        public FromClauseSyntax FromClause => this.fromClause;
        public QueryBodySyntax Body => this.body;

        internal override GreenNode? GetSlot(int index)
            => index switch
            {
                0 => this.fromClause,
                1 => this.body,
                _ => null,
            };

        internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new CSharp.Syntax.QueryExpressionSyntax(this, parent, position);

        public override void Accept(CSharpSyntaxVisitor visitor) => visitor.VisitQueryExpression(this);
        public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor) => visitor.VisitQueryExpression(this);

        public QueryExpressionSyntax Update(FromClauseSyntax fromClause, QueryBodySyntax body)
        {
            if (fromClause != this.FromClause || body != this.Body)
            {
                var newNode = SyntaxFactory.QueryExpression(fromClause, body);
                var diags = GetDiagnostics();
                if (diags?.Length > 0)
                    newNode = newNode.WithDiagnosticsGreen(diags);
                var annotations = GetAnnotations();
                if (annotations?.Length > 0)
                    newNode = newNode.WithAnnotationsGreen(annotations);
                return newNode;
            }

            return this;
        }

        internal override GreenNode SetDiagnostics(DiagnosticInfo[]? diagnostics)
            => new QueryExpressionSyntax(this.Kind, this.fromClause, this.body, diagnostics, GetAnnotations());

        internal override GreenNode SetAnnotations(SyntaxAnnotation[]? annotations)
            => new QueryExpressionSyntax(this.Kind, this.fromClause, this.body, GetDiagnostics(), annotations);

        internal QueryExpressionSyntax(ObjectReader reader)
          : base(reader)
        {
            this.SlotCount = 2;
            var fromClause = (FromClauseSyntax)reader.ReadValue();
            AdjustFlagsAndWidth(fromClause);
            this.fromClause = fromClause;
            var body = (QueryBodySyntax)reader.ReadValue();
            AdjustFlagsAndWidth(body);
            this.body = body;
        }

        internal override void WriteTo(ObjectWriter writer)
        {
            base.WriteTo(writer);
            writer.WriteValue(this.fromClause);
            writer.WriteValue(this.body);
        }

        static QueryExpressionSyntax()
        {
            ObjectBinder.RegisterTypeReader(typeof(QueryExpressionSyntax), r => new QueryExpressionSyntax(r));
        }
    }

    internal sealed partial class QueryBodySyntax : CSharpSyntaxNode
    {
        internal readonly GreenNode? clauses;
        internal readonly SelectOrGroupClauseSyntax selectOrGroup;
        internal readonly QueryContinuationSyntax? continuation;

        internal QueryBodySyntax(SyntaxKind kind, GreenNode? clauses, SelectOrGroupClauseSyntax selectOrGroup, QueryContinuationSyntax? continuation, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
            this.SlotCount = 3;
            if (clauses != null)
            {
                this.AdjustFlagsAndWidth(clauses);
                this.clauses = clauses;
            }
            this.AdjustFlagsAndWidth(selectOrGroup);
            this.selectOrGroup = selectOrGroup;
            if (continuation != null)
            {
                this.AdjustFlagsAndWidth(continuation);
                this.continuation = continuation;
            }
        }

        internal QueryBodySyntax(SyntaxKind kind, GreenNode? clauses, SelectOrGroupClauseSyntax selectOrGroup, QueryContinuationSyntax? continuation, SyntaxFactoryContext context)
          : base(kind)
        {
            this.SetFactoryContext(context);
            this.SlotCount = 3;
            if (clauses != null)
            {
                this.AdjustFlagsAndWidth(clauses);
                this.clauses = clauses;
            }
            this.AdjustFlagsAndWidth(selectOrGroup);
            this.selectOrGroup = selectOrGroup;
            if (continuation != null)
            {
                this.AdjustFlagsAndWidth(continuation);
                this.continuation = continuation;
            }
        }

        internal QueryBodySyntax(SyntaxKind kind, GreenNode? clauses, SelectOrGroupClauseSyntax selectOrGroup, QueryContinuationSyntax? continuation)
          : base(kind)
        {
            this.SlotCount = 3;
            if (clauses != null)
            {
                this.AdjustFlagsAndWidth(clauses);
                this.clauses = clauses;
            }
            this.AdjustFlagsAndWidth(selectOrGroup);
            this.selectOrGroup = selectOrGroup;
            if (continuation != null)
            {
                this.AdjustFlagsAndWidth(continuation);
                this.continuation = continuation;
            }
        }

        public Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<QueryClauseSyntax> Clauses => new Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<QueryClauseSyntax>(this.clauses);
        public SelectOrGroupClauseSyntax SelectOrGroup => this.selectOrGroup;
        public QueryContinuationSyntax? Continuation => this.continuation;

        internal override GreenNode? GetSlot(int index)
            => index switch
            {
                0 => this.clauses,
                1 => this.selectOrGroup,
                2 => this.continuation,
                _ => null,
            };

        internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new CSharp.Syntax.QueryBodySyntax(this, parent, position);

        public override void Accept(CSharpSyntaxVisitor visitor) => visitor.VisitQueryBody(this);
        public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor) => visitor.VisitQueryBody(this);

        public QueryBodySyntax Update(Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<QueryClauseSyntax> clauses, SelectOrGroupClauseSyntax selectOrGroup, QueryContinuationSyntax continuation)
        {
            if (clauses != this.Clauses || selectOrGroup != this.SelectOrGroup || continuation != this.Continuation)
            {
                var newNode = SyntaxFactory.QueryBody(clauses, selectOrGroup, continuation);
                var diags = GetDiagnostics();
                if (diags?.Length > 0)
                    newNode = newNode.WithDiagnosticsGreen(diags);
                var annotations = GetAnnotations();
                if (annotations?.Length > 0)
                    newNode = newNode.WithAnnotationsGreen(annotations);
                return newNode;
            }

            return this;
        }

        internal override GreenNode SetDiagnostics(DiagnosticInfo[]? diagnostics)
            => new QueryBodySyntax(this.Kind, this.clauses, this.selectOrGroup, this.continuation, diagnostics, GetAnnotations());

        internal override GreenNode SetAnnotations(SyntaxAnnotation[]? annotations)
            => new QueryBodySyntax(this.Kind, this.clauses, this.selectOrGroup, this.continuation, GetDiagnostics(), annotations);

        internal QueryBodySyntax(ObjectReader reader)
          : base(reader)
        {
            this.SlotCount = 3;
            var clauses = (GreenNode?)reader.ReadValue();
            if (clauses != null)
            {
                AdjustFlagsAndWidth(clauses);
                this.clauses = clauses;
            }
            var selectOrGroup = (SelectOrGroupClauseSyntax)reader.ReadValue();
            AdjustFlagsAndWidth(selectOrGroup);
            this.selectOrGroup = selectOrGroup;
            var continuation = (QueryContinuationSyntax?)reader.ReadValue();
            if (continuation != null)
            {
                AdjustFlagsAndWidth(continuation);
                this.continuation = continuation;
            }
        }

        internal override void WriteTo(ObjectWriter writer)
        {
            base.WriteTo(writer);
            writer.WriteValue(this.clauses);
            writer.WriteValue(this.selectOrGroup);
            writer.WriteValue(this.continuation);
        }

        static QueryBodySyntax()
        {
            ObjectBinder.RegisterTypeReader(typeof(QueryBodySyntax), r => new QueryBodySyntax(r));
        }
    }

    internal sealed partial class FromClauseSyntax : QueryClauseSyntax
    {
        internal readonly SyntaxToken fromKeyword;
        internal readonly TypeSyntax? type;
        internal readonly SyntaxToken identifier;
        internal readonly SyntaxToken inKeyword;
        internal readonly ExpressionSyntax expression;

        internal FromClauseSyntax(SyntaxKind kind, SyntaxToken fromKeyword, TypeSyntax? type, SyntaxToken identifier, SyntaxToken inKeyword, ExpressionSyntax expression, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
            this.SlotCount = 5;
            this.AdjustFlagsAndWidth(fromKeyword);
            this.fromKeyword = fromKeyword;
            if (type != null)
            {
                this.AdjustFlagsAndWidth(type);
                this.type = type;
            }
            this.AdjustFlagsAndWidth(identifier);
            this.identifier = identifier;
            this.AdjustFlagsAndWidth(inKeyword);
            this.inKeyword = inKeyword;
            this.AdjustFlagsAndWidth(expression);
            this.expression = expression;
        }

        internal FromClauseSyntax(SyntaxKind kind, SyntaxToken fromKeyword, TypeSyntax? type, SyntaxToken identifier, SyntaxToken inKeyword, ExpressionSyntax expression, SyntaxFactoryContext context)
          : base(kind)
        {
            this.SetFactoryContext(context);
            this.SlotCount = 5;
            this.AdjustFlagsAndWidth(fromKeyword);
            this.fromKeyword = fromKeyword;
            if (type != null)
            {
                this.AdjustFlagsAndWidth(type);
                this.type = type;
            }
            this.AdjustFlagsAndWidth(identifier);
            this.identifier = identifier;
            this.AdjustFlagsAndWidth(inKeyword);
            this.inKeyword = inKeyword;
            this.AdjustFlagsAndWidth(expression);
            this.expression = expression;
        }

        internal FromClauseSyntax(SyntaxKind kind, SyntaxToken fromKeyword, TypeSyntax? type, SyntaxToken identifier, SyntaxToken inKeyword, ExpressionSyntax expression)
          : base(kind)
        {
            this.SlotCount = 5;
            this.AdjustFlagsAndWidth(fromKeyword);
            this.fromKeyword = fromKeyword;
            if (type != null)
            {
                this.AdjustFlagsAndWidth(type);
                this.type = type;
            }
            this.AdjustFlagsAndWidth(identifier);
            this.identifier = identifier;
            this.AdjustFlagsAndWidth(inKeyword);
            this.inKeyword = inKeyword;
            this.AdjustFlagsAndWidth(expression);
            this.expression = expression;
        }

        public SyntaxToken FromKeyword => this.fromKeyword;
        public TypeSyntax? Type => this.type;
        /// <summary>Gets the identifier.</summary>
        public SyntaxToken Identifier => this.identifier;
        public SyntaxToken InKeyword => this.inKeyword;
        public ExpressionSyntax Expression => this.expression;

        internal override GreenNode? GetSlot(int index)
            => index switch
            {
                0 => this.fromKeyword,
                1 => this.type,
                2 => this.identifier,
                3 => this.inKeyword,
                4 => this.expression,
                _ => null,
            };

        internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new CSharp.Syntax.FromClauseSyntax(this, parent, position);

        public override void Accept(CSharpSyntaxVisitor visitor) => visitor.VisitFromClause(this);
        public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor) => visitor.VisitFromClause(this);

        public FromClauseSyntax Update(SyntaxToken fromKeyword, TypeSyntax type, SyntaxToken identifier, SyntaxToken inKeyword, ExpressionSyntax expression)
        {
            if (fromKeyword != this.FromKeyword || type != this.Type || identifier != this.Identifier || inKeyword != this.InKeyword || expression != this.Expression)
            {
                var newNode = SyntaxFactory.FromClause(fromKeyword, type, identifier, inKeyword, expression);
                var diags = GetDiagnostics();
                if (diags?.Length > 0)
                    newNode = newNode.WithDiagnosticsGreen(diags);
                var annotations = GetAnnotations();
                if (annotations?.Length > 0)
                    newNode = newNode.WithAnnotationsGreen(annotations);
                return newNode;
            }

            return this;
        }

        internal override GreenNode SetDiagnostics(DiagnosticInfo[]? diagnostics)
            => new FromClauseSyntax(this.Kind, this.fromKeyword, this.type, this.identifier, this.inKeyword, this.expression, diagnostics, GetAnnotations());

        internal override GreenNode SetAnnotations(SyntaxAnnotation[]? annotations)
            => new FromClauseSyntax(this.Kind, this.fromKeyword, this.type, this.identifier, this.inKeyword, this.expression, GetDiagnostics(), annotations);

        internal FromClauseSyntax(ObjectReader reader)
          : base(reader)
        {
            this.SlotCount = 5;
            var fromKeyword = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(fromKeyword);
            this.fromKeyword = fromKeyword;
            var type = (TypeSyntax?)reader.ReadValue();
            if (type != null)
            {
                AdjustFlagsAndWidth(type);
                this.type = type;
            }
            var identifier = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(identifier);
            this.identifier = identifier;
            var inKeyword = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(inKeyword);
            this.inKeyword = inKeyword;
            var expression = (ExpressionSyntax)reader.ReadValue();
            AdjustFlagsAndWidth(expression);
            this.expression = expression;
        }

        internal override void WriteTo(ObjectWriter writer)
        {
            base.WriteTo(writer);
            writer.WriteValue(this.fromKeyword);
            writer.WriteValue(this.type);
            writer.WriteValue(this.identifier);
            writer.WriteValue(this.inKeyword);
            writer.WriteValue(this.expression);
        }

        static FromClauseSyntax()
        {
            ObjectBinder.RegisterTypeReader(typeof(FromClauseSyntax), r => new FromClauseSyntax(r));
        }
    }

    internal sealed partial class LetClauseSyntax : QueryClauseSyntax
    {
        internal readonly SyntaxToken letKeyword;
        internal readonly SyntaxToken identifier;
        internal readonly SyntaxToken equalsToken;
        internal readonly ExpressionSyntax expression;

        internal LetClauseSyntax(SyntaxKind kind, SyntaxToken letKeyword, SyntaxToken identifier, SyntaxToken equalsToken, ExpressionSyntax expression, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
            this.SlotCount = 4;
            this.AdjustFlagsAndWidth(letKeyword);
            this.letKeyword = letKeyword;
            this.AdjustFlagsAndWidth(identifier);
            this.identifier = identifier;
            this.AdjustFlagsAndWidth(equalsToken);
            this.equalsToken = equalsToken;
            this.AdjustFlagsAndWidth(expression);
            this.expression = expression;
        }

        internal LetClauseSyntax(SyntaxKind kind, SyntaxToken letKeyword, SyntaxToken identifier, SyntaxToken equalsToken, ExpressionSyntax expression, SyntaxFactoryContext context)
          : base(kind)
        {
            this.SetFactoryContext(context);
            this.SlotCount = 4;
            this.AdjustFlagsAndWidth(letKeyword);
            this.letKeyword = letKeyword;
            this.AdjustFlagsAndWidth(identifier);
            this.identifier = identifier;
            this.AdjustFlagsAndWidth(equalsToken);
            this.equalsToken = equalsToken;
            this.AdjustFlagsAndWidth(expression);
            this.expression = expression;
        }

        internal LetClauseSyntax(SyntaxKind kind, SyntaxToken letKeyword, SyntaxToken identifier, SyntaxToken equalsToken, ExpressionSyntax expression)
          : base(kind)
        {
            this.SlotCount = 4;
            this.AdjustFlagsAndWidth(letKeyword);
            this.letKeyword = letKeyword;
            this.AdjustFlagsAndWidth(identifier);
            this.identifier = identifier;
            this.AdjustFlagsAndWidth(equalsToken);
            this.equalsToken = equalsToken;
            this.AdjustFlagsAndWidth(expression);
            this.expression = expression;
        }

        public SyntaxToken LetKeyword => this.letKeyword;
        /// <summary>Gets the identifier.</summary>
        public SyntaxToken Identifier => this.identifier;
        public SyntaxToken EqualsToken => this.equalsToken;
        public ExpressionSyntax Expression => this.expression;

        internal override GreenNode? GetSlot(int index)
            => index switch
            {
                0 => this.letKeyword,
                1 => this.identifier,
                2 => this.equalsToken,
                3 => this.expression,
                _ => null,
            };

        internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new CSharp.Syntax.LetClauseSyntax(this, parent, position);

        public override void Accept(CSharpSyntaxVisitor visitor) => visitor.VisitLetClause(this);
        public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor) => visitor.VisitLetClause(this);

        public LetClauseSyntax Update(SyntaxToken letKeyword, SyntaxToken identifier, SyntaxToken equalsToken, ExpressionSyntax expression)
        {
            if (letKeyword != this.LetKeyword || identifier != this.Identifier || equalsToken != this.EqualsToken || expression != this.Expression)
            {
                var newNode = SyntaxFactory.LetClause(letKeyword, identifier, equalsToken, expression);
                var diags = GetDiagnostics();
                if (diags?.Length > 0)
                    newNode = newNode.WithDiagnosticsGreen(diags);
                var annotations = GetAnnotations();
                if (annotations?.Length > 0)
                    newNode = newNode.WithAnnotationsGreen(annotations);
                return newNode;
            }

            return this;
        }

        internal override GreenNode SetDiagnostics(DiagnosticInfo[]? diagnostics)
            => new LetClauseSyntax(this.Kind, this.letKeyword, this.identifier, this.equalsToken, this.expression, diagnostics, GetAnnotations());

        internal override GreenNode SetAnnotations(SyntaxAnnotation[]? annotations)
            => new LetClauseSyntax(this.Kind, this.letKeyword, this.identifier, this.equalsToken, this.expression, GetDiagnostics(), annotations);

        internal LetClauseSyntax(ObjectReader reader)
          : base(reader)
        {
            this.SlotCount = 4;
            var letKeyword = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(letKeyword);
            this.letKeyword = letKeyword;
            var identifier = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(identifier);
            this.identifier = identifier;
            var equalsToken = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(equalsToken);
            this.equalsToken = equalsToken;
            var expression = (ExpressionSyntax)reader.ReadValue();
            AdjustFlagsAndWidth(expression);
            this.expression = expression;
        }

        internal override void WriteTo(ObjectWriter writer)
        {
            base.WriteTo(writer);
            writer.WriteValue(this.letKeyword);
            writer.WriteValue(this.identifier);
            writer.WriteValue(this.equalsToken);
            writer.WriteValue(this.expression);
        }

        static LetClauseSyntax()
        {
            ObjectBinder.RegisterTypeReader(typeof(LetClauseSyntax), r => new LetClauseSyntax(r));
        }
    }

    internal sealed partial class JoinClauseSyntax : QueryClauseSyntax
    {
        internal readonly SyntaxToken joinKeyword;
        internal readonly TypeSyntax? type;
        internal readonly SyntaxToken identifier;
        internal readonly SyntaxToken inKeyword;
        internal readonly ExpressionSyntax inExpression;
        internal readonly SyntaxToken onKeyword;
        internal readonly ExpressionSyntax leftExpression;
        internal readonly SyntaxToken equalsKeyword;
        internal readonly ExpressionSyntax rightExpression;
        internal readonly JoinIntoClauseSyntax? into;

        internal JoinClauseSyntax(SyntaxKind kind, SyntaxToken joinKeyword, TypeSyntax? type, SyntaxToken identifier, SyntaxToken inKeyword, ExpressionSyntax inExpression, SyntaxToken onKeyword, ExpressionSyntax leftExpression, SyntaxToken equalsKeyword, ExpressionSyntax rightExpression, JoinIntoClauseSyntax? into, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
            this.SlotCount = 10;
            this.AdjustFlagsAndWidth(joinKeyword);
            this.joinKeyword = joinKeyword;
            if (type != null)
            {
                this.AdjustFlagsAndWidth(type);
                this.type = type;
            }
            this.AdjustFlagsAndWidth(identifier);
            this.identifier = identifier;
            this.AdjustFlagsAndWidth(inKeyword);
            this.inKeyword = inKeyword;
            this.AdjustFlagsAndWidth(inExpression);
            this.inExpression = inExpression;
            this.AdjustFlagsAndWidth(onKeyword);
            this.onKeyword = onKeyword;
            this.AdjustFlagsAndWidth(leftExpression);
            this.leftExpression = leftExpression;
            this.AdjustFlagsAndWidth(equalsKeyword);
            this.equalsKeyword = equalsKeyword;
            this.AdjustFlagsAndWidth(rightExpression);
            this.rightExpression = rightExpression;
            if (into != null)
            {
                this.AdjustFlagsAndWidth(into);
                this.into = into;
            }
        }

        internal JoinClauseSyntax(SyntaxKind kind, SyntaxToken joinKeyword, TypeSyntax? type, SyntaxToken identifier, SyntaxToken inKeyword, ExpressionSyntax inExpression, SyntaxToken onKeyword, ExpressionSyntax leftExpression, SyntaxToken equalsKeyword, ExpressionSyntax rightExpression, JoinIntoClauseSyntax? into, SyntaxFactoryContext context)
          : base(kind)
        {
            this.SetFactoryContext(context);
            this.SlotCount = 10;
            this.AdjustFlagsAndWidth(joinKeyword);
            this.joinKeyword = joinKeyword;
            if (type != null)
            {
                this.AdjustFlagsAndWidth(type);
                this.type = type;
            }
            this.AdjustFlagsAndWidth(identifier);
            this.identifier = identifier;
            this.AdjustFlagsAndWidth(inKeyword);
            this.inKeyword = inKeyword;
            this.AdjustFlagsAndWidth(inExpression);
            this.inExpression = inExpression;
            this.AdjustFlagsAndWidth(onKeyword);
            this.onKeyword = onKeyword;
            this.AdjustFlagsAndWidth(leftExpression);
            this.leftExpression = leftExpression;
            this.AdjustFlagsAndWidth(equalsKeyword);
            this.equalsKeyword = equalsKeyword;
            this.AdjustFlagsAndWidth(rightExpression);
            this.rightExpression = rightExpression;
            if (into != null)
            {
                this.AdjustFlagsAndWidth(into);
                this.into = into;
            }
        }

        internal JoinClauseSyntax(SyntaxKind kind, SyntaxToken joinKeyword, TypeSyntax? type, SyntaxToken identifier, SyntaxToken inKeyword, ExpressionSyntax inExpression, SyntaxToken onKeyword, ExpressionSyntax leftExpression, SyntaxToken equalsKeyword, ExpressionSyntax rightExpression, JoinIntoClauseSyntax? into)
          : base(kind)
        {
            this.SlotCount = 10;
            this.AdjustFlagsAndWidth(joinKeyword);
            this.joinKeyword = joinKeyword;
            if (type != null)
            {
                this.AdjustFlagsAndWidth(type);
                this.type = type;
            }
            this.AdjustFlagsAndWidth(identifier);
            this.identifier = identifier;
            this.AdjustFlagsAndWidth(inKeyword);
            this.inKeyword = inKeyword;
            this.AdjustFlagsAndWidth(inExpression);
            this.inExpression = inExpression;
            this.AdjustFlagsAndWidth(onKeyword);
            this.onKeyword = onKeyword;
            this.AdjustFlagsAndWidth(leftExpression);
            this.leftExpression = leftExpression;
            this.AdjustFlagsAndWidth(equalsKeyword);
            this.equalsKeyword = equalsKeyword;
            this.AdjustFlagsAndWidth(rightExpression);
            this.rightExpression = rightExpression;
            if (into != null)
            {
                this.AdjustFlagsAndWidth(into);
                this.into = into;
            }
        }

        public SyntaxToken JoinKeyword => this.joinKeyword;
        public TypeSyntax? Type => this.type;
        /// <summary>Gets the identifier.</summary>
        public SyntaxToken Identifier => this.identifier;
        public SyntaxToken InKeyword => this.inKeyword;
        public ExpressionSyntax InExpression => this.inExpression;
        public SyntaxToken OnKeyword => this.onKeyword;
        public ExpressionSyntax LeftExpression => this.leftExpression;
        public SyntaxToken EqualsKeyword => this.equalsKeyword;
        public ExpressionSyntax RightExpression => this.rightExpression;
        public JoinIntoClauseSyntax? Into => this.into;

        internal override GreenNode? GetSlot(int index)
            => index switch
            {
                0 => this.joinKeyword,
                1 => this.type,
                2 => this.identifier,
                3 => this.inKeyword,
                4 => this.inExpression,
                5 => this.onKeyword,
                6 => this.leftExpression,
                7 => this.equalsKeyword,
                8 => this.rightExpression,
                9 => this.into,
                _ => null,
            };

        internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new CSharp.Syntax.JoinClauseSyntax(this, parent, position);

        public override void Accept(CSharpSyntaxVisitor visitor) => visitor.VisitJoinClause(this);
        public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor) => visitor.VisitJoinClause(this);

        public JoinClauseSyntax Update(SyntaxToken joinKeyword, TypeSyntax type, SyntaxToken identifier, SyntaxToken inKeyword, ExpressionSyntax inExpression, SyntaxToken onKeyword, ExpressionSyntax leftExpression, SyntaxToken equalsKeyword, ExpressionSyntax rightExpression, JoinIntoClauseSyntax into)
        {
            if (joinKeyword != this.JoinKeyword || type != this.Type || identifier != this.Identifier || inKeyword != this.InKeyword || inExpression != this.InExpression || onKeyword != this.OnKeyword || leftExpression != this.LeftExpression || equalsKeyword != this.EqualsKeyword || rightExpression != this.RightExpression || into != this.Into)
            {
                var newNode = SyntaxFactory.JoinClause(joinKeyword, type, identifier, inKeyword, inExpression, onKeyword, leftExpression, equalsKeyword, rightExpression, into);
                var diags = GetDiagnostics();
                if (diags?.Length > 0)
                    newNode = newNode.WithDiagnosticsGreen(diags);
                var annotations = GetAnnotations();
                if (annotations?.Length > 0)
                    newNode = newNode.WithAnnotationsGreen(annotations);
                return newNode;
            }

            return this;
        }

        internal override GreenNode SetDiagnostics(DiagnosticInfo[]? diagnostics)
            => new JoinClauseSyntax(this.Kind, this.joinKeyword, this.type, this.identifier, this.inKeyword, this.inExpression, this.onKeyword, this.leftExpression, this.equalsKeyword, this.rightExpression, this.into, diagnostics, GetAnnotations());

        internal override GreenNode SetAnnotations(SyntaxAnnotation[]? annotations)
            => new JoinClauseSyntax(this.Kind, this.joinKeyword, this.type, this.identifier, this.inKeyword, this.inExpression, this.onKeyword, this.leftExpression, this.equalsKeyword, this.rightExpression, this.into, GetDiagnostics(), annotations);

        internal JoinClauseSyntax(ObjectReader reader)
          : base(reader)
        {
            this.SlotCount = 10;
            var joinKeyword = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(joinKeyword);
            this.joinKeyword = joinKeyword;
            var type = (TypeSyntax?)reader.ReadValue();
            if (type != null)
            {
                AdjustFlagsAndWidth(type);
                this.type = type;
            }
            var identifier = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(identifier);
            this.identifier = identifier;
            var inKeyword = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(inKeyword);
            this.inKeyword = inKeyword;
            var inExpression = (ExpressionSyntax)reader.ReadValue();
            AdjustFlagsAndWidth(inExpression);
            this.inExpression = inExpression;
            var onKeyword = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(onKeyword);
            this.onKeyword = onKeyword;
            var leftExpression = (ExpressionSyntax)reader.ReadValue();
            AdjustFlagsAndWidth(leftExpression);
            this.leftExpression = leftExpression;
            var equalsKeyword = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(equalsKeyword);
            this.equalsKeyword = equalsKeyword;
            var rightExpression = (ExpressionSyntax)reader.ReadValue();
            AdjustFlagsAndWidth(rightExpression);
            this.rightExpression = rightExpression;
            var into = (JoinIntoClauseSyntax?)reader.ReadValue();
            if (into != null)
            {
                AdjustFlagsAndWidth(into);
                this.into = into;
            }
        }

        internal override void WriteTo(ObjectWriter writer)
        {
            base.WriteTo(writer);
            writer.WriteValue(this.joinKeyword);
            writer.WriteValue(this.type);
            writer.WriteValue(this.identifier);
            writer.WriteValue(this.inKeyword);
            writer.WriteValue(this.inExpression);
            writer.WriteValue(this.onKeyword);
            writer.WriteValue(this.leftExpression);
            writer.WriteValue(this.equalsKeyword);
            writer.WriteValue(this.rightExpression);
            writer.WriteValue(this.into);
        }

        static JoinClauseSyntax()
        {
            ObjectBinder.RegisterTypeReader(typeof(JoinClauseSyntax), r => new JoinClauseSyntax(r));
        }
    }

    internal sealed partial class JoinIntoClauseSyntax : CSharpSyntaxNode
    {
        internal readonly SyntaxToken intoKeyword;
        internal readonly SyntaxToken identifier;

        internal JoinIntoClauseSyntax(SyntaxKind kind, SyntaxToken intoKeyword, SyntaxToken identifier, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
            this.SlotCount = 2;
            this.AdjustFlagsAndWidth(intoKeyword);
            this.intoKeyword = intoKeyword;
            this.AdjustFlagsAndWidth(identifier);
            this.identifier = identifier;
        }

        internal JoinIntoClauseSyntax(SyntaxKind kind, SyntaxToken intoKeyword, SyntaxToken identifier, SyntaxFactoryContext context)
          : base(kind)
        {
            this.SetFactoryContext(context);
            this.SlotCount = 2;
            this.AdjustFlagsAndWidth(intoKeyword);
            this.intoKeyword = intoKeyword;
            this.AdjustFlagsAndWidth(identifier);
            this.identifier = identifier;
        }

        internal JoinIntoClauseSyntax(SyntaxKind kind, SyntaxToken intoKeyword, SyntaxToken identifier)
          : base(kind)
        {
            this.SlotCount = 2;
            this.AdjustFlagsAndWidth(intoKeyword);
            this.intoKeyword = intoKeyword;
            this.AdjustFlagsAndWidth(identifier);
            this.identifier = identifier;
        }

        public SyntaxToken IntoKeyword => this.intoKeyword;
        /// <summary>Gets the identifier.</summary>
        public SyntaxToken Identifier => this.identifier;

        internal override GreenNode? GetSlot(int index)
            => index switch
            {
                0 => this.intoKeyword,
                1 => this.identifier,
                _ => null,
            };

        internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new CSharp.Syntax.JoinIntoClauseSyntax(this, parent, position);

        public override void Accept(CSharpSyntaxVisitor visitor) => visitor.VisitJoinIntoClause(this);
        public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor) => visitor.VisitJoinIntoClause(this);

        public JoinIntoClauseSyntax Update(SyntaxToken intoKeyword, SyntaxToken identifier)
        {
            if (intoKeyword != this.IntoKeyword || identifier != this.Identifier)
            {
                var newNode = SyntaxFactory.JoinIntoClause(intoKeyword, identifier);
                var diags = GetDiagnostics();
                if (diags?.Length > 0)
                    newNode = newNode.WithDiagnosticsGreen(diags);
                var annotations = GetAnnotations();
                if (annotations?.Length > 0)
                    newNode = newNode.WithAnnotationsGreen(annotations);
                return newNode;
            }

            return this;
        }

        internal override GreenNode SetDiagnostics(DiagnosticInfo[]? diagnostics)
            => new JoinIntoClauseSyntax(this.Kind, this.intoKeyword, this.identifier, diagnostics, GetAnnotations());

        internal override GreenNode SetAnnotations(SyntaxAnnotation[]? annotations)
            => new JoinIntoClauseSyntax(this.Kind, this.intoKeyword, this.identifier, GetDiagnostics(), annotations);

        internal JoinIntoClauseSyntax(ObjectReader reader)
          : base(reader)
        {
            this.SlotCount = 2;
            var intoKeyword = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(intoKeyword);
            this.intoKeyword = intoKeyword;
            var identifier = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(identifier);
            this.identifier = identifier;
        }

        internal override void WriteTo(ObjectWriter writer)
        {
            base.WriteTo(writer);
            writer.WriteValue(this.intoKeyword);
            writer.WriteValue(this.identifier);
        }

        static JoinIntoClauseSyntax()
        {
            ObjectBinder.RegisterTypeReader(typeof(JoinIntoClauseSyntax), r => new JoinIntoClauseSyntax(r));
        }
    }

    internal sealed partial class WhereClauseSyntax : QueryClauseSyntax
    {
        internal readonly SyntaxToken whereKeyword;
        internal readonly ExpressionSyntax condition;

        internal WhereClauseSyntax(SyntaxKind kind, SyntaxToken whereKeyword, ExpressionSyntax condition, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
            this.SlotCount = 2;
            this.AdjustFlagsAndWidth(whereKeyword);
            this.whereKeyword = whereKeyword;
            this.AdjustFlagsAndWidth(condition);
            this.condition = condition;
        }

        internal WhereClauseSyntax(SyntaxKind kind, SyntaxToken whereKeyword, ExpressionSyntax condition, SyntaxFactoryContext context)
          : base(kind)
        {
            this.SetFactoryContext(context);
            this.SlotCount = 2;
            this.AdjustFlagsAndWidth(whereKeyword);
            this.whereKeyword = whereKeyword;
            this.AdjustFlagsAndWidth(condition);
            this.condition = condition;
        }

        internal WhereClauseSyntax(SyntaxKind kind, SyntaxToken whereKeyword, ExpressionSyntax condition)
          : base(kind)
        {
            this.SlotCount = 2;
            this.AdjustFlagsAndWidth(whereKeyword);
            this.whereKeyword = whereKeyword;
            this.AdjustFlagsAndWidth(condition);
            this.condition = condition;
        }

        public SyntaxToken WhereKeyword => this.whereKeyword;
        public ExpressionSyntax Condition => this.condition;

        internal override GreenNode? GetSlot(int index)
            => index switch
            {
                0 => this.whereKeyword,
                1 => this.condition,
                _ => null,
            };

        internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new CSharp.Syntax.WhereClauseSyntax(this, parent, position);

        public override void Accept(CSharpSyntaxVisitor visitor) => visitor.VisitWhereClause(this);
        public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor) => visitor.VisitWhereClause(this);

        public WhereClauseSyntax Update(SyntaxToken whereKeyword, ExpressionSyntax condition)
        {
            if (whereKeyword != this.WhereKeyword || condition != this.Condition)
            {
                var newNode = SyntaxFactory.WhereClause(whereKeyword, condition);
                var diags = GetDiagnostics();
                if (diags?.Length > 0)
                    newNode = newNode.WithDiagnosticsGreen(diags);
                var annotations = GetAnnotations();
                if (annotations?.Length > 0)
                    newNode = newNode.WithAnnotationsGreen(annotations);
                return newNode;
            }

            return this;
        }

        internal override GreenNode SetDiagnostics(DiagnosticInfo[]? diagnostics)
            => new WhereClauseSyntax(this.Kind, this.whereKeyword, this.condition, diagnostics, GetAnnotations());

        internal override GreenNode SetAnnotations(SyntaxAnnotation[]? annotations)
            => new WhereClauseSyntax(this.Kind, this.whereKeyword, this.condition, GetDiagnostics(), annotations);

        internal WhereClauseSyntax(ObjectReader reader)
          : base(reader)
        {
            this.SlotCount = 2;
            var whereKeyword = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(whereKeyword);
            this.whereKeyword = whereKeyword;
            var condition = (ExpressionSyntax)reader.ReadValue();
            AdjustFlagsAndWidth(condition);
            this.condition = condition;
        }

        internal override void WriteTo(ObjectWriter writer)
        {
            base.WriteTo(writer);
            writer.WriteValue(this.whereKeyword);
            writer.WriteValue(this.condition);
        }

        static WhereClauseSyntax()
        {
            ObjectBinder.RegisterTypeReader(typeof(WhereClauseSyntax), r => new WhereClauseSyntax(r));
        }
    }

    internal sealed partial class OrderByClauseSyntax : QueryClauseSyntax
    {
        internal readonly SyntaxToken orderByKeyword;
        internal readonly GreenNode? orderings;

        internal OrderByClauseSyntax(SyntaxKind kind, SyntaxToken orderByKeyword, GreenNode? orderings, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
            this.SlotCount = 2;
            this.AdjustFlagsAndWidth(orderByKeyword);
            this.orderByKeyword = orderByKeyword;
            if (orderings != null)
            {
                this.AdjustFlagsAndWidth(orderings);
                this.orderings = orderings;
            }
        }

        internal OrderByClauseSyntax(SyntaxKind kind, SyntaxToken orderByKeyword, GreenNode? orderings, SyntaxFactoryContext context)
          : base(kind)
        {
            this.SetFactoryContext(context);
            this.SlotCount = 2;
            this.AdjustFlagsAndWidth(orderByKeyword);
            this.orderByKeyword = orderByKeyword;
            if (orderings != null)
            {
                this.AdjustFlagsAndWidth(orderings);
                this.orderings = orderings;
            }
        }

        internal OrderByClauseSyntax(SyntaxKind kind, SyntaxToken orderByKeyword, GreenNode? orderings)
          : base(kind)
        {
            this.SlotCount = 2;
            this.AdjustFlagsAndWidth(orderByKeyword);
            this.orderByKeyword = orderByKeyword;
            if (orderings != null)
            {
                this.AdjustFlagsAndWidth(orderings);
                this.orderings = orderings;
            }
        }

        public SyntaxToken OrderByKeyword => this.orderByKeyword;
        public Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<OrderingSyntax> Orderings => new Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<OrderingSyntax>(new Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<CSharpSyntaxNode>(this.orderings));

        internal override GreenNode? GetSlot(int index)
            => index switch
            {
                0 => this.orderByKeyword,
                1 => this.orderings,
                _ => null,
            };

        internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new CSharp.Syntax.OrderByClauseSyntax(this, parent, position);

        public override void Accept(CSharpSyntaxVisitor visitor) => visitor.VisitOrderByClause(this);
        public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor) => visitor.VisitOrderByClause(this);

        public OrderByClauseSyntax Update(SyntaxToken orderByKeyword, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<OrderingSyntax> orderings)
        {
            if (orderByKeyword != this.OrderByKeyword || orderings != this.Orderings)
            {
                var newNode = SyntaxFactory.OrderByClause(orderByKeyword, orderings);
                var diags = GetDiagnostics();
                if (diags?.Length > 0)
                    newNode = newNode.WithDiagnosticsGreen(diags);
                var annotations = GetAnnotations();
                if (annotations?.Length > 0)
                    newNode = newNode.WithAnnotationsGreen(annotations);
                return newNode;
            }

            return this;
        }

        internal override GreenNode SetDiagnostics(DiagnosticInfo[]? diagnostics)
            => new OrderByClauseSyntax(this.Kind, this.orderByKeyword, this.orderings, diagnostics, GetAnnotations());

        internal override GreenNode SetAnnotations(SyntaxAnnotation[]? annotations)
            => new OrderByClauseSyntax(this.Kind, this.orderByKeyword, this.orderings, GetDiagnostics(), annotations);

        internal OrderByClauseSyntax(ObjectReader reader)
          : base(reader)
        {
            this.SlotCount = 2;
            var orderByKeyword = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(orderByKeyword);
            this.orderByKeyword = orderByKeyword;
            var orderings = (GreenNode?)reader.ReadValue();
            if (orderings != null)
            {
                AdjustFlagsAndWidth(orderings);
                this.orderings = orderings;
            }
        }

        internal override void WriteTo(ObjectWriter writer)
        {
            base.WriteTo(writer);
            writer.WriteValue(this.orderByKeyword);
            writer.WriteValue(this.orderings);
        }

        static OrderByClauseSyntax()
        {
            ObjectBinder.RegisterTypeReader(typeof(OrderByClauseSyntax), r => new OrderByClauseSyntax(r));
        }
    }

    internal sealed partial class OrderingSyntax : CSharpSyntaxNode
    {
        internal readonly ExpressionSyntax expression;
        internal readonly SyntaxToken? ascendingOrDescendingKeyword;

        internal OrderingSyntax(SyntaxKind kind, ExpressionSyntax expression, SyntaxToken? ascendingOrDescendingKeyword, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
            this.SlotCount = 2;
            this.AdjustFlagsAndWidth(expression);
            this.expression = expression;
            if (ascendingOrDescendingKeyword != null)
            {
                this.AdjustFlagsAndWidth(ascendingOrDescendingKeyword);
                this.ascendingOrDescendingKeyword = ascendingOrDescendingKeyword;
            }
        }

        internal OrderingSyntax(SyntaxKind kind, ExpressionSyntax expression, SyntaxToken? ascendingOrDescendingKeyword, SyntaxFactoryContext context)
          : base(kind)
        {
            this.SetFactoryContext(context);
            this.SlotCount = 2;
            this.AdjustFlagsAndWidth(expression);
            this.expression = expression;
            if (ascendingOrDescendingKeyword != null)
            {
                this.AdjustFlagsAndWidth(ascendingOrDescendingKeyword);
                this.ascendingOrDescendingKeyword = ascendingOrDescendingKeyword;
            }
        }

        internal OrderingSyntax(SyntaxKind kind, ExpressionSyntax expression, SyntaxToken? ascendingOrDescendingKeyword)
          : base(kind)
        {
            this.SlotCount = 2;
            this.AdjustFlagsAndWidth(expression);
            this.expression = expression;
            if (ascendingOrDescendingKeyword != null)
            {
                this.AdjustFlagsAndWidth(ascendingOrDescendingKeyword);
                this.ascendingOrDescendingKeyword = ascendingOrDescendingKeyword;
            }
        }

        public ExpressionSyntax Expression => this.expression;
        public SyntaxToken? AscendingOrDescendingKeyword => this.ascendingOrDescendingKeyword;

        internal override GreenNode? GetSlot(int index)
            => index switch
            {
                0 => this.expression,
                1 => this.ascendingOrDescendingKeyword,
                _ => null,
            };

        internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new CSharp.Syntax.OrderingSyntax(this, parent, position);

        public override void Accept(CSharpSyntaxVisitor visitor) => visitor.VisitOrdering(this);
        public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor) => visitor.VisitOrdering(this);

        public OrderingSyntax Update(ExpressionSyntax expression, SyntaxToken ascendingOrDescendingKeyword)
        {
            if (expression != this.Expression || ascendingOrDescendingKeyword != this.AscendingOrDescendingKeyword)
            {
                var newNode = SyntaxFactory.Ordering(this.Kind, expression, ascendingOrDescendingKeyword);
                var diags = GetDiagnostics();
                if (diags?.Length > 0)
                    newNode = newNode.WithDiagnosticsGreen(diags);
                var annotations = GetAnnotations();
                if (annotations?.Length > 0)
                    newNode = newNode.WithAnnotationsGreen(annotations);
                return newNode;
            }

            return this;
        }

        internal override GreenNode SetDiagnostics(DiagnosticInfo[]? diagnostics)
            => new OrderingSyntax(this.Kind, this.expression, this.ascendingOrDescendingKeyword, diagnostics, GetAnnotations());

        internal override GreenNode SetAnnotations(SyntaxAnnotation[]? annotations)
            => new OrderingSyntax(this.Kind, this.expression, this.ascendingOrDescendingKeyword, GetDiagnostics(), annotations);

        internal OrderingSyntax(ObjectReader reader)
          : base(reader)
        {
            this.SlotCount = 2;
            var expression = (ExpressionSyntax)reader.ReadValue();
            AdjustFlagsAndWidth(expression);
            this.expression = expression;
            var ascendingOrDescendingKeyword = (SyntaxToken?)reader.ReadValue();
            if (ascendingOrDescendingKeyword != null)
            {
                AdjustFlagsAndWidth(ascendingOrDescendingKeyword);
                this.ascendingOrDescendingKeyword = ascendingOrDescendingKeyword;
            }
        }

        internal override void WriteTo(ObjectWriter writer)
        {
            base.WriteTo(writer);
            writer.WriteValue(this.expression);
            writer.WriteValue(this.ascendingOrDescendingKeyword);
        }

        static OrderingSyntax()
        {
            ObjectBinder.RegisterTypeReader(typeof(OrderingSyntax), r => new OrderingSyntax(r));
        }
    }

    internal sealed partial class SelectClauseSyntax : SelectOrGroupClauseSyntax
    {
        internal readonly SyntaxToken selectKeyword;
        internal readonly ExpressionSyntax expression;

        internal SelectClauseSyntax(SyntaxKind kind, SyntaxToken selectKeyword, ExpressionSyntax expression, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
            this.SlotCount = 2;
            this.AdjustFlagsAndWidth(selectKeyword);
            this.selectKeyword = selectKeyword;
            this.AdjustFlagsAndWidth(expression);
            this.expression = expression;
        }

        internal SelectClauseSyntax(SyntaxKind kind, SyntaxToken selectKeyword, ExpressionSyntax expression, SyntaxFactoryContext context)
          : base(kind)
        {
            this.SetFactoryContext(context);
            this.SlotCount = 2;
            this.AdjustFlagsAndWidth(selectKeyword);
            this.selectKeyword = selectKeyword;
            this.AdjustFlagsAndWidth(expression);
            this.expression = expression;
        }

        internal SelectClauseSyntax(SyntaxKind kind, SyntaxToken selectKeyword, ExpressionSyntax expression)
          : base(kind)
        {
            this.SlotCount = 2;
            this.AdjustFlagsAndWidth(selectKeyword);
            this.selectKeyword = selectKeyword;
            this.AdjustFlagsAndWidth(expression);
            this.expression = expression;
        }

        public SyntaxToken SelectKeyword => this.selectKeyword;
        public ExpressionSyntax Expression => this.expression;

        internal override GreenNode? GetSlot(int index)
            => index switch
            {
                0 => this.selectKeyword,
                1 => this.expression,
                _ => null,
            };

        internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new CSharp.Syntax.SelectClauseSyntax(this, parent, position);

        public override void Accept(CSharpSyntaxVisitor visitor) => visitor.VisitSelectClause(this);
        public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor) => visitor.VisitSelectClause(this);

        public SelectClauseSyntax Update(SyntaxToken selectKeyword, ExpressionSyntax expression)
        {
            if (selectKeyword != this.SelectKeyword || expression != this.Expression)
            {
                var newNode = SyntaxFactory.SelectClause(selectKeyword, expression);
                var diags = GetDiagnostics();
                if (diags?.Length > 0)
                    newNode = newNode.WithDiagnosticsGreen(diags);
                var annotations = GetAnnotations();
                if (annotations?.Length > 0)
                    newNode = newNode.WithAnnotationsGreen(annotations);
                return newNode;
            }

            return this;
        }

        internal override GreenNode SetDiagnostics(DiagnosticInfo[]? diagnostics)
            => new SelectClauseSyntax(this.Kind, this.selectKeyword, this.expression, diagnostics, GetAnnotations());

        internal override GreenNode SetAnnotations(SyntaxAnnotation[]? annotations)
            => new SelectClauseSyntax(this.Kind, this.selectKeyword, this.expression, GetDiagnostics(), annotations);

        internal SelectClauseSyntax(ObjectReader reader)
          : base(reader)
        {
            this.SlotCount = 2;
            var selectKeyword = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(selectKeyword);
            this.selectKeyword = selectKeyword;
            var expression = (ExpressionSyntax)reader.ReadValue();
            AdjustFlagsAndWidth(expression);
            this.expression = expression;
        }

        internal override void WriteTo(ObjectWriter writer)
        {
            base.WriteTo(writer);
            writer.WriteValue(this.selectKeyword);
            writer.WriteValue(this.expression);
        }

        static SelectClauseSyntax()
        {
            ObjectBinder.RegisterTypeReader(typeof(SelectClauseSyntax), r => new SelectClauseSyntax(r));
        }
    }

    internal sealed partial class GroupClauseSyntax : SelectOrGroupClauseSyntax
    {
        internal readonly SyntaxToken groupKeyword;
        internal readonly ExpressionSyntax groupExpression;
        internal readonly SyntaxToken byKeyword;
        internal readonly ExpressionSyntax byExpression;

        internal GroupClauseSyntax(SyntaxKind kind, SyntaxToken groupKeyword, ExpressionSyntax groupExpression, SyntaxToken byKeyword, ExpressionSyntax byExpression, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
            this.SlotCount = 4;
            this.AdjustFlagsAndWidth(groupKeyword);
            this.groupKeyword = groupKeyword;
            this.AdjustFlagsAndWidth(groupExpression);
            this.groupExpression = groupExpression;
            this.AdjustFlagsAndWidth(byKeyword);
            this.byKeyword = byKeyword;
            this.AdjustFlagsAndWidth(byExpression);
            this.byExpression = byExpression;
        }

        internal GroupClauseSyntax(SyntaxKind kind, SyntaxToken groupKeyword, ExpressionSyntax groupExpression, SyntaxToken byKeyword, ExpressionSyntax byExpression, SyntaxFactoryContext context)
          : base(kind)
        {
            this.SetFactoryContext(context);
            this.SlotCount = 4;
            this.AdjustFlagsAndWidth(groupKeyword);
            this.groupKeyword = groupKeyword;
            this.AdjustFlagsAndWidth(groupExpression);
            this.groupExpression = groupExpression;
            this.AdjustFlagsAndWidth(byKeyword);
            this.byKeyword = byKeyword;
            this.AdjustFlagsAndWidth(byExpression);
            this.byExpression = byExpression;
        }

        internal GroupClauseSyntax(SyntaxKind kind, SyntaxToken groupKeyword, ExpressionSyntax groupExpression, SyntaxToken byKeyword, ExpressionSyntax byExpression)
          : base(kind)
        {
            this.SlotCount = 4;
            this.AdjustFlagsAndWidth(groupKeyword);
            this.groupKeyword = groupKeyword;
            this.AdjustFlagsAndWidth(groupExpression);
            this.groupExpression = groupExpression;
            this.AdjustFlagsAndWidth(byKeyword);
            this.byKeyword = byKeyword;
            this.AdjustFlagsAndWidth(byExpression);
            this.byExpression = byExpression;
        }

        public SyntaxToken GroupKeyword => this.groupKeyword;
        public ExpressionSyntax GroupExpression => this.groupExpression;
        public SyntaxToken ByKeyword => this.byKeyword;
        public ExpressionSyntax ByExpression => this.byExpression;

        internal override GreenNode? GetSlot(int index)
            => index switch
            {
                0 => this.groupKeyword,
                1 => this.groupExpression,
                2 => this.byKeyword,
                3 => this.byExpression,
                _ => null,
            };

        internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new CSharp.Syntax.GroupClauseSyntax(this, parent, position);

        public override void Accept(CSharpSyntaxVisitor visitor) => visitor.VisitGroupClause(this);
        public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor) => visitor.VisitGroupClause(this);

        public GroupClauseSyntax Update(SyntaxToken groupKeyword, ExpressionSyntax groupExpression, SyntaxToken byKeyword, ExpressionSyntax byExpression)
        {
            if (groupKeyword != this.GroupKeyword || groupExpression != this.GroupExpression || byKeyword != this.ByKeyword || byExpression != this.ByExpression)
            {
                var newNode = SyntaxFactory.GroupClause(groupKeyword, groupExpression, byKeyword, byExpression);
                var diags = GetDiagnostics();
                if (diags?.Length > 0)
                    newNode = newNode.WithDiagnosticsGreen(diags);
                var annotations = GetAnnotations();
                if (annotations?.Length > 0)
                    newNode = newNode.WithAnnotationsGreen(annotations);
                return newNode;
            }

            return this;
        }

        internal override GreenNode SetDiagnostics(DiagnosticInfo[]? diagnostics)
            => new GroupClauseSyntax(this.Kind, this.groupKeyword, this.groupExpression, this.byKeyword, this.byExpression, diagnostics, GetAnnotations());

        internal override GreenNode SetAnnotations(SyntaxAnnotation[]? annotations)
            => new GroupClauseSyntax(this.Kind, this.groupKeyword, this.groupExpression, this.byKeyword, this.byExpression, GetDiagnostics(), annotations);

        internal GroupClauseSyntax(ObjectReader reader)
          : base(reader)
        {
            this.SlotCount = 4;
            var groupKeyword = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(groupKeyword);
            this.groupKeyword = groupKeyword;
            var groupExpression = (ExpressionSyntax)reader.ReadValue();
            AdjustFlagsAndWidth(groupExpression);
            this.groupExpression = groupExpression;
            var byKeyword = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(byKeyword);
            this.byKeyword = byKeyword;
            var byExpression = (ExpressionSyntax)reader.ReadValue();
            AdjustFlagsAndWidth(byExpression);
            this.byExpression = byExpression;
        }

        internal override void WriteTo(ObjectWriter writer)
        {
            base.WriteTo(writer);
            writer.WriteValue(this.groupKeyword);
            writer.WriteValue(this.groupExpression);
            writer.WriteValue(this.byKeyword);
            writer.WriteValue(this.byExpression);
        }

        static GroupClauseSyntax()
        {
            ObjectBinder.RegisterTypeReader(typeof(GroupClauseSyntax), r => new GroupClauseSyntax(r));
        }
    }

    internal sealed partial class QueryContinuationSyntax : CSharpSyntaxNode
    {
        internal readonly SyntaxToken intoKeyword;
        internal readonly SyntaxToken identifier;
        internal readonly QueryBodySyntax body;

        internal QueryContinuationSyntax(SyntaxKind kind, SyntaxToken intoKeyword, SyntaxToken identifier, QueryBodySyntax body, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
            this.SlotCount = 3;
            this.AdjustFlagsAndWidth(intoKeyword);
            this.intoKeyword = intoKeyword;
            this.AdjustFlagsAndWidth(identifier);
            this.identifier = identifier;
            this.AdjustFlagsAndWidth(body);
            this.body = body;
        }

        internal QueryContinuationSyntax(SyntaxKind kind, SyntaxToken intoKeyword, SyntaxToken identifier, QueryBodySyntax body, SyntaxFactoryContext context)
          : base(kind)
        {
            this.SetFactoryContext(context);
            this.SlotCount = 3;
            this.AdjustFlagsAndWidth(intoKeyword);
            this.intoKeyword = intoKeyword;
            this.AdjustFlagsAndWidth(identifier);
            this.identifier = identifier;
            this.AdjustFlagsAndWidth(body);
            this.body = body;
        }

        internal QueryContinuationSyntax(SyntaxKind kind, SyntaxToken intoKeyword, SyntaxToken identifier, QueryBodySyntax body)
          : base(kind)
        {
            this.SlotCount = 3;
            this.AdjustFlagsAndWidth(intoKeyword);
            this.intoKeyword = intoKeyword;
            this.AdjustFlagsAndWidth(identifier);
            this.identifier = identifier;
            this.AdjustFlagsAndWidth(body);
            this.body = body;
        }

        public SyntaxToken IntoKeyword => this.intoKeyword;
        /// <summary>Gets the identifier.</summary>
        public SyntaxToken Identifier => this.identifier;
        public QueryBodySyntax Body => this.body;

        internal override GreenNode? GetSlot(int index)
            => index switch
            {
                0 => this.intoKeyword,
                1 => this.identifier,
                2 => this.body,
                _ => null,
            };

        internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new CSharp.Syntax.QueryContinuationSyntax(this, parent, position);

        public override void Accept(CSharpSyntaxVisitor visitor) => visitor.VisitQueryContinuation(this);
        public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor) => visitor.VisitQueryContinuation(this);

        public QueryContinuationSyntax Update(SyntaxToken intoKeyword, SyntaxToken identifier, QueryBodySyntax body)
        {
            if (intoKeyword != this.IntoKeyword || identifier != this.Identifier || body != this.Body)
            {
                var newNode = SyntaxFactory.QueryContinuation(intoKeyword, identifier, body);
                var diags = GetDiagnostics();
                if (diags?.Length > 0)
                    newNode = newNode.WithDiagnosticsGreen(diags);
                var annotations = GetAnnotations();
                if (annotations?.Length > 0)
                    newNode = newNode.WithAnnotationsGreen(annotations);
                return newNode;
            }

            return this;
        }

        internal override GreenNode SetDiagnostics(DiagnosticInfo[]? diagnostics)
            => new QueryContinuationSyntax(this.Kind, this.intoKeyword, this.identifier, this.body, diagnostics, GetAnnotations());

        internal override GreenNode SetAnnotations(SyntaxAnnotation[]? annotations)
            => new QueryContinuationSyntax(this.Kind, this.intoKeyword, this.identifier, this.body, GetDiagnostics(), annotations);

        internal QueryContinuationSyntax(ObjectReader reader)
          : base(reader)
        {
            this.SlotCount = 3;
            var intoKeyword = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(intoKeyword);
            this.intoKeyword = intoKeyword;
            var identifier = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(identifier);
            this.identifier = identifier;
            var body = (QueryBodySyntax)reader.ReadValue();
            AdjustFlagsAndWidth(body);
            this.body = body;
        }

        internal override void WriteTo(ObjectWriter writer)
        {
            base.WriteTo(writer);
            writer.WriteValue(this.intoKeyword);
            writer.WriteValue(this.identifier);
            writer.WriteValue(this.body);
        }

        static QueryContinuationSyntax()
        {
            ObjectBinder.RegisterTypeReader(typeof(QueryContinuationSyntax), r => new QueryContinuationSyntax(r));
        }
    }

    /// <summary>Class which represents a placeholder in an array size list.</summary>
    internal sealed partial class OmittedArraySizeExpressionSyntax : ExpressionSyntax
    {
        internal readonly SyntaxToken omittedArraySizeExpressionToken;

        internal OmittedArraySizeExpressionSyntax(SyntaxKind kind, SyntaxToken omittedArraySizeExpressionToken, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
            this.SlotCount = 1;
            this.AdjustFlagsAndWidth(omittedArraySizeExpressionToken);
            this.omittedArraySizeExpressionToken = omittedArraySizeExpressionToken;
        }

        internal OmittedArraySizeExpressionSyntax(SyntaxKind kind, SyntaxToken omittedArraySizeExpressionToken, SyntaxFactoryContext context)
          : base(kind)
        {
            this.SetFactoryContext(context);
            this.SlotCount = 1;
            this.AdjustFlagsAndWidth(omittedArraySizeExpressionToken);
            this.omittedArraySizeExpressionToken = omittedArraySizeExpressionToken;
        }

        internal OmittedArraySizeExpressionSyntax(SyntaxKind kind, SyntaxToken omittedArraySizeExpressionToken)
          : base(kind)
        {
            this.SlotCount = 1;
            this.AdjustFlagsAndWidth(omittedArraySizeExpressionToken);
            this.omittedArraySizeExpressionToken = omittedArraySizeExpressionToken;
        }

        /// <summary>SyntaxToken representing the omitted array size expression.</summary>
        public SyntaxToken OmittedArraySizeExpressionToken => this.omittedArraySizeExpressionToken;

        internal override GreenNode? GetSlot(int index)
            => index == 0 ? this.omittedArraySizeExpressionToken : null;

        internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new CSharp.Syntax.OmittedArraySizeExpressionSyntax(this, parent, position);

        public override void Accept(CSharpSyntaxVisitor visitor) => visitor.VisitOmittedArraySizeExpression(this);
        public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor) => visitor.VisitOmittedArraySizeExpression(this);

        public OmittedArraySizeExpressionSyntax Update(SyntaxToken omittedArraySizeExpressionToken)
        {
            if (omittedArraySizeExpressionToken != this.OmittedArraySizeExpressionToken)
            {
                var newNode = SyntaxFactory.OmittedArraySizeExpression(omittedArraySizeExpressionToken);
                var diags = GetDiagnostics();
                if (diags?.Length > 0)
                    newNode = newNode.WithDiagnosticsGreen(diags);
                var annotations = GetAnnotations();
                if (annotations?.Length > 0)
                    newNode = newNode.WithAnnotationsGreen(annotations);
                return newNode;
            }

            return this;
        }

        internal override GreenNode SetDiagnostics(DiagnosticInfo[]? diagnostics)
            => new OmittedArraySizeExpressionSyntax(this.Kind, this.omittedArraySizeExpressionToken, diagnostics, GetAnnotations());

        internal override GreenNode SetAnnotations(SyntaxAnnotation[]? annotations)
            => new OmittedArraySizeExpressionSyntax(this.Kind, this.omittedArraySizeExpressionToken, GetDiagnostics(), annotations);

        internal OmittedArraySizeExpressionSyntax(ObjectReader reader)
          : base(reader)
        {
            this.SlotCount = 1;
            var omittedArraySizeExpressionToken = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(omittedArraySizeExpressionToken);
            this.omittedArraySizeExpressionToken = omittedArraySizeExpressionToken;
        }

        internal override void WriteTo(ObjectWriter writer)
        {
            base.WriteTo(writer);
            writer.WriteValue(this.omittedArraySizeExpressionToken);
        }

        static OmittedArraySizeExpressionSyntax()
        {
            ObjectBinder.RegisterTypeReader(typeof(OmittedArraySizeExpressionSyntax), r => new OmittedArraySizeExpressionSyntax(r));
        }
    }

    internal sealed partial class InterpolatedStringExpressionSyntax : ExpressionSyntax
    {
        internal readonly SyntaxToken stringStartToken;
        internal readonly GreenNode? contents;
        internal readonly SyntaxToken stringEndToken;

        internal InterpolatedStringExpressionSyntax(SyntaxKind kind, SyntaxToken stringStartToken, GreenNode? contents, SyntaxToken stringEndToken, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
            this.SlotCount = 3;
            this.AdjustFlagsAndWidth(stringStartToken);
            this.stringStartToken = stringStartToken;
            if (contents != null)
            {
                this.AdjustFlagsAndWidth(contents);
                this.contents = contents;
            }
            this.AdjustFlagsAndWidth(stringEndToken);
            this.stringEndToken = stringEndToken;
        }

        internal InterpolatedStringExpressionSyntax(SyntaxKind kind, SyntaxToken stringStartToken, GreenNode? contents, SyntaxToken stringEndToken, SyntaxFactoryContext context)
          : base(kind)
        {
            this.SetFactoryContext(context);
            this.SlotCount = 3;
            this.AdjustFlagsAndWidth(stringStartToken);
            this.stringStartToken = stringStartToken;
            if (contents != null)
            {
                this.AdjustFlagsAndWidth(contents);
                this.contents = contents;
            }
            this.AdjustFlagsAndWidth(stringEndToken);
            this.stringEndToken = stringEndToken;
        }

        internal InterpolatedStringExpressionSyntax(SyntaxKind kind, SyntaxToken stringStartToken, GreenNode? contents, SyntaxToken stringEndToken)
          : base(kind)
        {
            this.SlotCount = 3;
            this.AdjustFlagsAndWidth(stringStartToken);
            this.stringStartToken = stringStartToken;
            if (contents != null)
            {
                this.AdjustFlagsAndWidth(contents);
                this.contents = contents;
            }
            this.AdjustFlagsAndWidth(stringEndToken);
            this.stringEndToken = stringEndToken;
        }

        /// <summary>The first part of an interpolated string, $" or $@"</summary>
        public SyntaxToken StringStartToken => this.stringStartToken;
        /// <summary>List of parts of the interpolated string, each one is either a literal part or an interpolation.</summary>
        public Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<InterpolatedStringContentSyntax> Contents => new Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<InterpolatedStringContentSyntax>(this.contents);
        /// <summary>The closing quote of the interpolated string.</summary>
        public SyntaxToken StringEndToken => this.stringEndToken;

        internal override GreenNode? GetSlot(int index)
            => index switch
            {
                0 => this.stringStartToken,
                1 => this.contents,
                2 => this.stringEndToken,
                _ => null,
            };

        internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new CSharp.Syntax.InterpolatedStringExpressionSyntax(this, parent, position);

        public override void Accept(CSharpSyntaxVisitor visitor) => visitor.VisitInterpolatedStringExpression(this);
        public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor) => visitor.VisitInterpolatedStringExpression(this);

        public InterpolatedStringExpressionSyntax Update(SyntaxToken stringStartToken, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<InterpolatedStringContentSyntax> contents, SyntaxToken stringEndToken)
        {
            if (stringStartToken != this.StringStartToken || contents != this.Contents || stringEndToken != this.StringEndToken)
            {
                var newNode = SyntaxFactory.InterpolatedStringExpression(stringStartToken, contents, stringEndToken);
                var diags = GetDiagnostics();
                if (diags?.Length > 0)
                    newNode = newNode.WithDiagnosticsGreen(diags);
                var annotations = GetAnnotations();
                if (annotations?.Length > 0)
                    newNode = newNode.WithAnnotationsGreen(annotations);
                return newNode;
            }

            return this;
        }

        internal override GreenNode SetDiagnostics(DiagnosticInfo[]? diagnostics)
            => new InterpolatedStringExpressionSyntax(this.Kind, this.stringStartToken, this.contents, this.stringEndToken, diagnostics, GetAnnotations());

        internal override GreenNode SetAnnotations(SyntaxAnnotation[]? annotations)
            => new InterpolatedStringExpressionSyntax(this.Kind, this.stringStartToken, this.contents, this.stringEndToken, GetDiagnostics(), annotations);

        internal InterpolatedStringExpressionSyntax(ObjectReader reader)
          : base(reader)
        {
            this.SlotCount = 3;
            var stringStartToken = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(stringStartToken);
            this.stringStartToken = stringStartToken;
            var contents = (GreenNode?)reader.ReadValue();
            if (contents != null)
            {
                AdjustFlagsAndWidth(contents);
                this.contents = contents;
            }
            var stringEndToken = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(stringEndToken);
            this.stringEndToken = stringEndToken;
        }

        internal override void WriteTo(ObjectWriter writer)
        {
            base.WriteTo(writer);
            writer.WriteValue(this.stringStartToken);
            writer.WriteValue(this.contents);
            writer.WriteValue(this.stringEndToken);
        }

        static InterpolatedStringExpressionSyntax()
        {
            ObjectBinder.RegisterTypeReader(typeof(InterpolatedStringExpressionSyntax), r => new InterpolatedStringExpressionSyntax(r));
        }
    }

    /// <summary>Class which represents a simple pattern-matching expression using the "is" keyword.</summary>
    internal sealed partial class IsPatternExpressionSyntax : ExpressionSyntax
    {
        internal readonly ExpressionSyntax expression;
        internal readonly SyntaxToken isKeyword;
        internal readonly PatternSyntax pattern;

        internal IsPatternExpressionSyntax(SyntaxKind kind, ExpressionSyntax expression, SyntaxToken isKeyword, PatternSyntax pattern, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
            this.SlotCount = 3;
            this.AdjustFlagsAndWidth(expression);
            this.expression = expression;
            this.AdjustFlagsAndWidth(isKeyword);
            this.isKeyword = isKeyword;
            this.AdjustFlagsAndWidth(pattern);
            this.pattern = pattern;
        }

        internal IsPatternExpressionSyntax(SyntaxKind kind, ExpressionSyntax expression, SyntaxToken isKeyword, PatternSyntax pattern, SyntaxFactoryContext context)
          : base(kind)
        {
            this.SetFactoryContext(context);
            this.SlotCount = 3;
            this.AdjustFlagsAndWidth(expression);
            this.expression = expression;
            this.AdjustFlagsAndWidth(isKeyword);
            this.isKeyword = isKeyword;
            this.AdjustFlagsAndWidth(pattern);
            this.pattern = pattern;
        }

        internal IsPatternExpressionSyntax(SyntaxKind kind, ExpressionSyntax expression, SyntaxToken isKeyword, PatternSyntax pattern)
          : base(kind)
        {
            this.SlotCount = 3;
            this.AdjustFlagsAndWidth(expression);
            this.expression = expression;
            this.AdjustFlagsAndWidth(isKeyword);
            this.isKeyword = isKeyword;
            this.AdjustFlagsAndWidth(pattern);
            this.pattern = pattern;
        }

        /// <summary>ExpressionSyntax node representing the expression on the left of the "is" operator.</summary>
        public ExpressionSyntax Expression => this.expression;
        public SyntaxToken IsKeyword => this.isKeyword;
        /// <summary>PatternSyntax node representing the pattern on the right of the "is" operator.</summary>
        public PatternSyntax Pattern => this.pattern;

        internal override GreenNode? GetSlot(int index)
            => index switch
            {
                0 => this.expression,
                1 => this.isKeyword,
                2 => this.pattern,
                _ => null,
            };

        internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new CSharp.Syntax.IsPatternExpressionSyntax(this, parent, position);

        public override void Accept(CSharpSyntaxVisitor visitor) => visitor.VisitIsPatternExpression(this);
        public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor) => visitor.VisitIsPatternExpression(this);

        public IsPatternExpressionSyntax Update(ExpressionSyntax expression, SyntaxToken isKeyword, PatternSyntax pattern)
        {
            if (expression != this.Expression || isKeyword != this.IsKeyword || pattern != this.Pattern)
            {
                var newNode = SyntaxFactory.IsPatternExpression(expression, isKeyword, pattern);
                var diags = GetDiagnostics();
                if (diags?.Length > 0)
                    newNode = newNode.WithDiagnosticsGreen(diags);
                var annotations = GetAnnotations();
                if (annotations?.Length > 0)
                    newNode = newNode.WithAnnotationsGreen(annotations);
                return newNode;
            }

            return this;
        }

        internal override GreenNode SetDiagnostics(DiagnosticInfo[]? diagnostics)
            => new IsPatternExpressionSyntax(this.Kind, this.expression, this.isKeyword, this.pattern, diagnostics, GetAnnotations());

        internal override GreenNode SetAnnotations(SyntaxAnnotation[]? annotations)
            => new IsPatternExpressionSyntax(this.Kind, this.expression, this.isKeyword, this.pattern, GetDiagnostics(), annotations);

        internal IsPatternExpressionSyntax(ObjectReader reader)
          : base(reader)
        {
            this.SlotCount = 3;
            var expression = (ExpressionSyntax)reader.ReadValue();
            AdjustFlagsAndWidth(expression);
            this.expression = expression;
            var isKeyword = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(isKeyword);
            this.isKeyword = isKeyword;
            var pattern = (PatternSyntax)reader.ReadValue();
            AdjustFlagsAndWidth(pattern);
            this.pattern = pattern;
        }

        internal override void WriteTo(ObjectWriter writer)
        {
            base.WriteTo(writer);
            writer.WriteValue(this.expression);
            writer.WriteValue(this.isKeyword);
            writer.WriteValue(this.pattern);
        }

        static IsPatternExpressionSyntax()
        {
            ObjectBinder.RegisterTypeReader(typeof(IsPatternExpressionSyntax), r => new IsPatternExpressionSyntax(r));
        }
    }

    internal sealed partial class ThrowExpressionSyntax : ExpressionSyntax
    {
        internal readonly SyntaxToken throwKeyword;
        internal readonly ExpressionSyntax expression;

        internal ThrowExpressionSyntax(SyntaxKind kind, SyntaxToken throwKeyword, ExpressionSyntax expression, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
            this.SlotCount = 2;
            this.AdjustFlagsAndWidth(throwKeyword);
            this.throwKeyword = throwKeyword;
            this.AdjustFlagsAndWidth(expression);
            this.expression = expression;
        }

        internal ThrowExpressionSyntax(SyntaxKind kind, SyntaxToken throwKeyword, ExpressionSyntax expression, SyntaxFactoryContext context)
          : base(kind)
        {
            this.SetFactoryContext(context);
            this.SlotCount = 2;
            this.AdjustFlagsAndWidth(throwKeyword);
            this.throwKeyword = throwKeyword;
            this.AdjustFlagsAndWidth(expression);
            this.expression = expression;
        }

        internal ThrowExpressionSyntax(SyntaxKind kind, SyntaxToken throwKeyword, ExpressionSyntax expression)
          : base(kind)
        {
            this.SlotCount = 2;
            this.AdjustFlagsAndWidth(throwKeyword);
            this.throwKeyword = throwKeyword;
            this.AdjustFlagsAndWidth(expression);
            this.expression = expression;
        }

        public SyntaxToken ThrowKeyword => this.throwKeyword;
        public ExpressionSyntax Expression => this.expression;

        internal override GreenNode? GetSlot(int index)
            => index switch
            {
                0 => this.throwKeyword,
                1 => this.expression,
                _ => null,
            };

        internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new CSharp.Syntax.ThrowExpressionSyntax(this, parent, position);

        public override void Accept(CSharpSyntaxVisitor visitor) => visitor.VisitThrowExpression(this);
        public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor) => visitor.VisitThrowExpression(this);

        public ThrowExpressionSyntax Update(SyntaxToken throwKeyword, ExpressionSyntax expression)
        {
            if (throwKeyword != this.ThrowKeyword || expression != this.Expression)
            {
                var newNode = SyntaxFactory.ThrowExpression(throwKeyword, expression);
                var diags = GetDiagnostics();
                if (diags?.Length > 0)
                    newNode = newNode.WithDiagnosticsGreen(diags);
                var annotations = GetAnnotations();
                if (annotations?.Length > 0)
                    newNode = newNode.WithAnnotationsGreen(annotations);
                return newNode;
            }

            return this;
        }

        internal override GreenNode SetDiagnostics(DiagnosticInfo[]? diagnostics)
            => new ThrowExpressionSyntax(this.Kind, this.throwKeyword, this.expression, diagnostics, GetAnnotations());

        internal override GreenNode SetAnnotations(SyntaxAnnotation[]? annotations)
            => new ThrowExpressionSyntax(this.Kind, this.throwKeyword, this.expression, GetDiagnostics(), annotations);

        internal ThrowExpressionSyntax(ObjectReader reader)
          : base(reader)
        {
            this.SlotCount = 2;
            var throwKeyword = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(throwKeyword);
            this.throwKeyword = throwKeyword;
            var expression = (ExpressionSyntax)reader.ReadValue();
            AdjustFlagsAndWidth(expression);
            this.expression = expression;
        }

        internal override void WriteTo(ObjectWriter writer)
        {
            base.WriteTo(writer);
            writer.WriteValue(this.throwKeyword);
            writer.WriteValue(this.expression);
        }

        static ThrowExpressionSyntax()
        {
            ObjectBinder.RegisterTypeReader(typeof(ThrowExpressionSyntax), r => new ThrowExpressionSyntax(r));
        }
    }

    internal sealed partial class WhenClauseSyntax : CSharpSyntaxNode
    {
        internal readonly SyntaxToken whenKeyword;
        internal readonly ExpressionSyntax condition;

        internal WhenClauseSyntax(SyntaxKind kind, SyntaxToken whenKeyword, ExpressionSyntax condition, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
            this.SlotCount = 2;
            this.AdjustFlagsAndWidth(whenKeyword);
            this.whenKeyword = whenKeyword;
            this.AdjustFlagsAndWidth(condition);
            this.condition = condition;
        }

        internal WhenClauseSyntax(SyntaxKind kind, SyntaxToken whenKeyword, ExpressionSyntax condition, SyntaxFactoryContext context)
          : base(kind)
        {
            this.SetFactoryContext(context);
            this.SlotCount = 2;
            this.AdjustFlagsAndWidth(whenKeyword);
            this.whenKeyword = whenKeyword;
            this.AdjustFlagsAndWidth(condition);
            this.condition = condition;
        }

        internal WhenClauseSyntax(SyntaxKind kind, SyntaxToken whenKeyword, ExpressionSyntax condition)
          : base(kind)
        {
            this.SlotCount = 2;
            this.AdjustFlagsAndWidth(whenKeyword);
            this.whenKeyword = whenKeyword;
            this.AdjustFlagsAndWidth(condition);
            this.condition = condition;
        }

        public SyntaxToken WhenKeyword => this.whenKeyword;
        public ExpressionSyntax Condition => this.condition;

        internal override GreenNode? GetSlot(int index)
            => index switch
            {
                0 => this.whenKeyword,
                1 => this.condition,
                _ => null,
            };

        internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new CSharp.Syntax.WhenClauseSyntax(this, parent, position);

        public override void Accept(CSharpSyntaxVisitor visitor) => visitor.VisitWhenClause(this);
        public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor) => visitor.VisitWhenClause(this);

        public WhenClauseSyntax Update(SyntaxToken whenKeyword, ExpressionSyntax condition)
        {
            if (whenKeyword != this.WhenKeyword || condition != this.Condition)
            {
                var newNode = SyntaxFactory.WhenClause(whenKeyword, condition);
                var diags = GetDiagnostics();
                if (diags?.Length > 0)
                    newNode = newNode.WithDiagnosticsGreen(diags);
                var annotations = GetAnnotations();
                if (annotations?.Length > 0)
                    newNode = newNode.WithAnnotationsGreen(annotations);
                return newNode;
            }

            return this;
        }

        internal override GreenNode SetDiagnostics(DiagnosticInfo[]? diagnostics)
            => new WhenClauseSyntax(this.Kind, this.whenKeyword, this.condition, diagnostics, GetAnnotations());

        internal override GreenNode SetAnnotations(SyntaxAnnotation[]? annotations)
            => new WhenClauseSyntax(this.Kind, this.whenKeyword, this.condition, GetDiagnostics(), annotations);

        internal WhenClauseSyntax(ObjectReader reader)
          : base(reader)
        {
            this.SlotCount = 2;
            var whenKeyword = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(whenKeyword);
            this.whenKeyword = whenKeyword;
            var condition = (ExpressionSyntax)reader.ReadValue();
            AdjustFlagsAndWidth(condition);
            this.condition = condition;
        }

        internal override void WriteTo(ObjectWriter writer)
        {
            base.WriteTo(writer);
            writer.WriteValue(this.whenKeyword);
            writer.WriteValue(this.condition);
        }

        static WhenClauseSyntax()
        {
            ObjectBinder.RegisterTypeReader(typeof(WhenClauseSyntax), r => new WhenClauseSyntax(r));
        }
    }

    internal abstract partial class PatternSyntax : ExpressionOrPatternSyntax
    {
        internal PatternSyntax(SyntaxKind kind, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
        }

        internal PatternSyntax(SyntaxKind kind)
          : base(kind)
        {
        }

        protected PatternSyntax(ObjectReader reader)
          : base(reader)
        {
        }
    }

    internal sealed partial class DiscardPatternSyntax : PatternSyntax
    {
        internal readonly SyntaxToken underscoreToken;

        internal DiscardPatternSyntax(SyntaxKind kind, SyntaxToken underscoreToken, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
            this.SlotCount = 1;
            this.AdjustFlagsAndWidth(underscoreToken);
            this.underscoreToken = underscoreToken;
        }

        internal DiscardPatternSyntax(SyntaxKind kind, SyntaxToken underscoreToken, SyntaxFactoryContext context)
          : base(kind)
        {
            this.SetFactoryContext(context);
            this.SlotCount = 1;
            this.AdjustFlagsAndWidth(underscoreToken);
            this.underscoreToken = underscoreToken;
        }

        internal DiscardPatternSyntax(SyntaxKind kind, SyntaxToken underscoreToken)
          : base(kind)
        {
            this.SlotCount = 1;
            this.AdjustFlagsAndWidth(underscoreToken);
            this.underscoreToken = underscoreToken;
        }

        public SyntaxToken UnderscoreToken => this.underscoreToken;

        internal override GreenNode? GetSlot(int index)
            => index == 0 ? this.underscoreToken : null;

        internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new CSharp.Syntax.DiscardPatternSyntax(this, parent, position);

        public override void Accept(CSharpSyntaxVisitor visitor) => visitor.VisitDiscardPattern(this);
        public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor) => visitor.VisitDiscardPattern(this);

        public DiscardPatternSyntax Update(SyntaxToken underscoreToken)
        {
            if (underscoreToken != this.UnderscoreToken)
            {
                var newNode = SyntaxFactory.DiscardPattern(underscoreToken);
                var diags = GetDiagnostics();
                if (diags?.Length > 0)
                    newNode = newNode.WithDiagnosticsGreen(diags);
                var annotations = GetAnnotations();
                if (annotations?.Length > 0)
                    newNode = newNode.WithAnnotationsGreen(annotations);
                return newNode;
            }

            return this;
        }

        internal override GreenNode SetDiagnostics(DiagnosticInfo[]? diagnostics)
            => new DiscardPatternSyntax(this.Kind, this.underscoreToken, diagnostics, GetAnnotations());

        internal override GreenNode SetAnnotations(SyntaxAnnotation[]? annotations)
            => new DiscardPatternSyntax(this.Kind, this.underscoreToken, GetDiagnostics(), annotations);

        internal DiscardPatternSyntax(ObjectReader reader)
          : base(reader)
        {
            this.SlotCount = 1;
            var underscoreToken = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(underscoreToken);
            this.underscoreToken = underscoreToken;
        }

        internal override void WriteTo(ObjectWriter writer)
        {
            base.WriteTo(writer);
            writer.WriteValue(this.underscoreToken);
        }

        static DiscardPatternSyntax()
        {
            ObjectBinder.RegisterTypeReader(typeof(DiscardPatternSyntax), r => new DiscardPatternSyntax(r));
        }
    }

    internal sealed partial class DeclarationPatternSyntax : PatternSyntax
    {
        internal readonly TypeSyntax type;
        internal readonly VariableDesignationSyntax designation;

        internal DeclarationPatternSyntax(SyntaxKind kind, TypeSyntax type, VariableDesignationSyntax designation, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
            this.SlotCount = 2;
            this.AdjustFlagsAndWidth(type);
            this.type = type;
            this.AdjustFlagsAndWidth(designation);
            this.designation = designation;
        }

        internal DeclarationPatternSyntax(SyntaxKind kind, TypeSyntax type, VariableDesignationSyntax designation, SyntaxFactoryContext context)
          : base(kind)
        {
            this.SetFactoryContext(context);
            this.SlotCount = 2;
            this.AdjustFlagsAndWidth(type);
            this.type = type;
            this.AdjustFlagsAndWidth(designation);
            this.designation = designation;
        }

        internal DeclarationPatternSyntax(SyntaxKind kind, TypeSyntax type, VariableDesignationSyntax designation)
          : base(kind)
        {
            this.SlotCount = 2;
            this.AdjustFlagsAndWidth(type);
            this.type = type;
            this.AdjustFlagsAndWidth(designation);
            this.designation = designation;
        }

        public TypeSyntax Type => this.type;
        public VariableDesignationSyntax Designation => this.designation;

        internal override GreenNode? GetSlot(int index)
            => index switch
            {
                0 => this.type,
                1 => this.designation,
                _ => null,
            };

        internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new CSharp.Syntax.DeclarationPatternSyntax(this, parent, position);

        public override void Accept(CSharpSyntaxVisitor visitor) => visitor.VisitDeclarationPattern(this);
        public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor) => visitor.VisitDeclarationPattern(this);

        public DeclarationPatternSyntax Update(TypeSyntax type, VariableDesignationSyntax designation)
        {
            if (type != this.Type || designation != this.Designation)
            {
                var newNode = SyntaxFactory.DeclarationPattern(type, designation);
                var diags = GetDiagnostics();
                if (diags?.Length > 0)
                    newNode = newNode.WithDiagnosticsGreen(diags);
                var annotations = GetAnnotations();
                if (annotations?.Length > 0)
                    newNode = newNode.WithAnnotationsGreen(annotations);
                return newNode;
            }

            return this;
        }

        internal override GreenNode SetDiagnostics(DiagnosticInfo[]? diagnostics)
            => new DeclarationPatternSyntax(this.Kind, this.type, this.designation, diagnostics, GetAnnotations());

        internal override GreenNode SetAnnotations(SyntaxAnnotation[]? annotations)
            => new DeclarationPatternSyntax(this.Kind, this.type, this.designation, GetDiagnostics(), annotations);

        internal DeclarationPatternSyntax(ObjectReader reader)
          : base(reader)
        {
            this.SlotCount = 2;
            var type = (TypeSyntax)reader.ReadValue();
            AdjustFlagsAndWidth(type);
            this.type = type;
            var designation = (VariableDesignationSyntax)reader.ReadValue();
            AdjustFlagsAndWidth(designation);
            this.designation = designation;
        }

        internal override void WriteTo(ObjectWriter writer)
        {
            base.WriteTo(writer);
            writer.WriteValue(this.type);
            writer.WriteValue(this.designation);
        }

        static DeclarationPatternSyntax()
        {
            ObjectBinder.RegisterTypeReader(typeof(DeclarationPatternSyntax), r => new DeclarationPatternSyntax(r));
        }
    }

    internal sealed partial class VarPatternSyntax : PatternSyntax
    {
        internal readonly SyntaxToken varKeyword;
        internal readonly VariableDesignationSyntax designation;

        internal VarPatternSyntax(SyntaxKind kind, SyntaxToken varKeyword, VariableDesignationSyntax designation, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
            this.SlotCount = 2;
            this.AdjustFlagsAndWidth(varKeyword);
            this.varKeyword = varKeyword;
            this.AdjustFlagsAndWidth(designation);
            this.designation = designation;
        }

        internal VarPatternSyntax(SyntaxKind kind, SyntaxToken varKeyword, VariableDesignationSyntax designation, SyntaxFactoryContext context)
          : base(kind)
        {
            this.SetFactoryContext(context);
            this.SlotCount = 2;
            this.AdjustFlagsAndWidth(varKeyword);
            this.varKeyword = varKeyword;
            this.AdjustFlagsAndWidth(designation);
            this.designation = designation;
        }

        internal VarPatternSyntax(SyntaxKind kind, SyntaxToken varKeyword, VariableDesignationSyntax designation)
          : base(kind)
        {
            this.SlotCount = 2;
            this.AdjustFlagsAndWidth(varKeyword);
            this.varKeyword = varKeyword;
            this.AdjustFlagsAndWidth(designation);
            this.designation = designation;
        }

        public SyntaxToken VarKeyword => this.varKeyword;
        public VariableDesignationSyntax Designation => this.designation;

        internal override GreenNode? GetSlot(int index)
            => index switch
            {
                0 => this.varKeyword,
                1 => this.designation,
                _ => null,
            };

        internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new CSharp.Syntax.VarPatternSyntax(this, parent, position);

        public override void Accept(CSharpSyntaxVisitor visitor) => visitor.VisitVarPattern(this);
        public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor) => visitor.VisitVarPattern(this);

        public VarPatternSyntax Update(SyntaxToken varKeyword, VariableDesignationSyntax designation)
        {
            if (varKeyword != this.VarKeyword || designation != this.Designation)
            {
                var newNode = SyntaxFactory.VarPattern(varKeyword, designation);
                var diags = GetDiagnostics();
                if (diags?.Length > 0)
                    newNode = newNode.WithDiagnosticsGreen(diags);
                var annotations = GetAnnotations();
                if (annotations?.Length > 0)
                    newNode = newNode.WithAnnotationsGreen(annotations);
                return newNode;
            }

            return this;
        }

        internal override GreenNode SetDiagnostics(DiagnosticInfo[]? diagnostics)
            => new VarPatternSyntax(this.Kind, this.varKeyword, this.designation, diagnostics, GetAnnotations());

        internal override GreenNode SetAnnotations(SyntaxAnnotation[]? annotations)
            => new VarPatternSyntax(this.Kind, this.varKeyword, this.designation, GetDiagnostics(), annotations);

        internal VarPatternSyntax(ObjectReader reader)
          : base(reader)
        {
            this.SlotCount = 2;
            var varKeyword = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(varKeyword);
            this.varKeyword = varKeyword;
            var designation = (VariableDesignationSyntax)reader.ReadValue();
            AdjustFlagsAndWidth(designation);
            this.designation = designation;
        }

        internal override void WriteTo(ObjectWriter writer)
        {
            base.WriteTo(writer);
            writer.WriteValue(this.varKeyword);
            writer.WriteValue(this.designation);
        }

        static VarPatternSyntax()
        {
            ObjectBinder.RegisterTypeReader(typeof(VarPatternSyntax), r => new VarPatternSyntax(r));
        }
    }

    internal sealed partial class RecursivePatternSyntax : PatternSyntax
    {
        internal readonly TypeSyntax? type;
        internal readonly PositionalPatternClauseSyntax? positionalPatternClause;
        internal readonly PropertyPatternClauseSyntax? propertyPatternClause;
        internal readonly VariableDesignationSyntax? designation;

        internal RecursivePatternSyntax(SyntaxKind kind, TypeSyntax? type, PositionalPatternClauseSyntax? positionalPatternClause, PropertyPatternClauseSyntax? propertyPatternClause, VariableDesignationSyntax? designation, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
            this.SlotCount = 4;
            if (type != null)
            {
                this.AdjustFlagsAndWidth(type);
                this.type = type;
            }
            if (positionalPatternClause != null)
            {
                this.AdjustFlagsAndWidth(positionalPatternClause);
                this.positionalPatternClause = positionalPatternClause;
            }
            if (propertyPatternClause != null)
            {
                this.AdjustFlagsAndWidth(propertyPatternClause);
                this.propertyPatternClause = propertyPatternClause;
            }
            if (designation != null)
            {
                this.AdjustFlagsAndWidth(designation);
                this.designation = designation;
            }
        }

        internal RecursivePatternSyntax(SyntaxKind kind, TypeSyntax? type, PositionalPatternClauseSyntax? positionalPatternClause, PropertyPatternClauseSyntax? propertyPatternClause, VariableDesignationSyntax? designation, SyntaxFactoryContext context)
          : base(kind)
        {
            this.SetFactoryContext(context);
            this.SlotCount = 4;
            if (type != null)
            {
                this.AdjustFlagsAndWidth(type);
                this.type = type;
            }
            if (positionalPatternClause != null)
            {
                this.AdjustFlagsAndWidth(positionalPatternClause);
                this.positionalPatternClause = positionalPatternClause;
            }
            if (propertyPatternClause != null)
            {
                this.AdjustFlagsAndWidth(propertyPatternClause);
                this.propertyPatternClause = propertyPatternClause;
            }
            if (designation != null)
            {
                this.AdjustFlagsAndWidth(designation);
                this.designation = designation;
            }
        }

        internal RecursivePatternSyntax(SyntaxKind kind, TypeSyntax? type, PositionalPatternClauseSyntax? positionalPatternClause, PropertyPatternClauseSyntax? propertyPatternClause, VariableDesignationSyntax? designation)
          : base(kind)
        {
            this.SlotCount = 4;
            if (type != null)
            {
                this.AdjustFlagsAndWidth(type);
                this.type = type;
            }
            if (positionalPatternClause != null)
            {
                this.AdjustFlagsAndWidth(positionalPatternClause);
                this.positionalPatternClause = positionalPatternClause;
            }
            if (propertyPatternClause != null)
            {
                this.AdjustFlagsAndWidth(propertyPatternClause);
                this.propertyPatternClause = propertyPatternClause;
            }
            if (designation != null)
            {
                this.AdjustFlagsAndWidth(designation);
                this.designation = designation;
            }
        }

        public TypeSyntax? Type => this.type;
        public PositionalPatternClauseSyntax? PositionalPatternClause => this.positionalPatternClause;
        public PropertyPatternClauseSyntax? PropertyPatternClause => this.propertyPatternClause;
        public VariableDesignationSyntax? Designation => this.designation;

        internal override GreenNode? GetSlot(int index)
            => index switch
            {
                0 => this.type,
                1 => this.positionalPatternClause,
                2 => this.propertyPatternClause,
                3 => this.designation,
                _ => null,
            };

        internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new CSharp.Syntax.RecursivePatternSyntax(this, parent, position);

        public override void Accept(CSharpSyntaxVisitor visitor) => visitor.VisitRecursivePattern(this);
        public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor) => visitor.VisitRecursivePattern(this);

        public RecursivePatternSyntax Update(TypeSyntax type, PositionalPatternClauseSyntax positionalPatternClause, PropertyPatternClauseSyntax propertyPatternClause, VariableDesignationSyntax designation)
        {
            if (type != this.Type || positionalPatternClause != this.PositionalPatternClause || propertyPatternClause != this.PropertyPatternClause || designation != this.Designation)
            {
                var newNode = SyntaxFactory.RecursivePattern(type, positionalPatternClause, propertyPatternClause, designation);
                var diags = GetDiagnostics();
                if (diags?.Length > 0)
                    newNode = newNode.WithDiagnosticsGreen(diags);
                var annotations = GetAnnotations();
                if (annotations?.Length > 0)
                    newNode = newNode.WithAnnotationsGreen(annotations);
                return newNode;
            }

            return this;
        }

        internal override GreenNode SetDiagnostics(DiagnosticInfo[]? diagnostics)
            => new RecursivePatternSyntax(this.Kind, this.type, this.positionalPatternClause, this.propertyPatternClause, this.designation, diagnostics, GetAnnotations());

        internal override GreenNode SetAnnotations(SyntaxAnnotation[]? annotations)
            => new RecursivePatternSyntax(this.Kind, this.type, this.positionalPatternClause, this.propertyPatternClause, this.designation, GetDiagnostics(), annotations);

        internal RecursivePatternSyntax(ObjectReader reader)
          : base(reader)
        {
            this.SlotCount = 4;
            var type = (TypeSyntax?)reader.ReadValue();
            if (type != null)
            {
                AdjustFlagsAndWidth(type);
                this.type = type;
            }
            var positionalPatternClause = (PositionalPatternClauseSyntax?)reader.ReadValue();
            if (positionalPatternClause != null)
            {
                AdjustFlagsAndWidth(positionalPatternClause);
                this.positionalPatternClause = positionalPatternClause;
            }
            var propertyPatternClause = (PropertyPatternClauseSyntax?)reader.ReadValue();
            if (propertyPatternClause != null)
            {
                AdjustFlagsAndWidth(propertyPatternClause);
                this.propertyPatternClause = propertyPatternClause;
            }
            var designation = (VariableDesignationSyntax?)reader.ReadValue();
            if (designation != null)
            {
                AdjustFlagsAndWidth(designation);
                this.designation = designation;
            }
        }

        internal override void WriteTo(ObjectWriter writer)
        {
            base.WriteTo(writer);
            writer.WriteValue(this.type);
            writer.WriteValue(this.positionalPatternClause);
            writer.WriteValue(this.propertyPatternClause);
            writer.WriteValue(this.designation);
        }

        static RecursivePatternSyntax()
        {
            ObjectBinder.RegisterTypeReader(typeof(RecursivePatternSyntax), r => new RecursivePatternSyntax(r));
        }
    }

    internal sealed partial class PositionalPatternClauseSyntax : CSharpSyntaxNode
    {
        internal readonly SyntaxToken openParenToken;
        internal readonly GreenNode? subpatterns;
        internal readonly SyntaxToken closeParenToken;

        internal PositionalPatternClauseSyntax(SyntaxKind kind, SyntaxToken openParenToken, GreenNode? subpatterns, SyntaxToken closeParenToken, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
            this.SlotCount = 3;
            this.AdjustFlagsAndWidth(openParenToken);
            this.openParenToken = openParenToken;
            if (subpatterns != null)
            {
                this.AdjustFlagsAndWidth(subpatterns);
                this.subpatterns = subpatterns;
            }
            this.AdjustFlagsAndWidth(closeParenToken);
            this.closeParenToken = closeParenToken;
        }

        internal PositionalPatternClauseSyntax(SyntaxKind kind, SyntaxToken openParenToken, GreenNode? subpatterns, SyntaxToken closeParenToken, SyntaxFactoryContext context)
          : base(kind)
        {
            this.SetFactoryContext(context);
            this.SlotCount = 3;
            this.AdjustFlagsAndWidth(openParenToken);
            this.openParenToken = openParenToken;
            if (subpatterns != null)
            {
                this.AdjustFlagsAndWidth(subpatterns);
                this.subpatterns = subpatterns;
            }
            this.AdjustFlagsAndWidth(closeParenToken);
            this.closeParenToken = closeParenToken;
        }

        internal PositionalPatternClauseSyntax(SyntaxKind kind, SyntaxToken openParenToken, GreenNode? subpatterns, SyntaxToken closeParenToken)
          : base(kind)
        {
            this.SlotCount = 3;
            this.AdjustFlagsAndWidth(openParenToken);
            this.openParenToken = openParenToken;
            if (subpatterns != null)
            {
                this.AdjustFlagsAndWidth(subpatterns);
                this.subpatterns = subpatterns;
            }
            this.AdjustFlagsAndWidth(closeParenToken);
            this.closeParenToken = closeParenToken;
        }

        public SyntaxToken OpenParenToken => this.openParenToken;
        public Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<SubpatternSyntax> Subpatterns => new Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<SubpatternSyntax>(new Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<CSharpSyntaxNode>(this.subpatterns));
        public SyntaxToken CloseParenToken => this.closeParenToken;

        internal override GreenNode? GetSlot(int index)
            => index switch
            {
                0 => this.openParenToken,
                1 => this.subpatterns,
                2 => this.closeParenToken,
                _ => null,
            };

        internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new CSharp.Syntax.PositionalPatternClauseSyntax(this, parent, position);

        public override void Accept(CSharpSyntaxVisitor visitor) => visitor.VisitPositionalPatternClause(this);
        public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor) => visitor.VisitPositionalPatternClause(this);

        public PositionalPatternClauseSyntax Update(SyntaxToken openParenToken, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<SubpatternSyntax> subpatterns, SyntaxToken closeParenToken)
        {
            if (openParenToken != this.OpenParenToken || subpatterns != this.Subpatterns || closeParenToken != this.CloseParenToken)
            {
                var newNode = SyntaxFactory.PositionalPatternClause(openParenToken, subpatterns, closeParenToken);
                var diags = GetDiagnostics();
                if (diags?.Length > 0)
                    newNode = newNode.WithDiagnosticsGreen(diags);
                var annotations = GetAnnotations();
                if (annotations?.Length > 0)
                    newNode = newNode.WithAnnotationsGreen(annotations);
                return newNode;
            }

            return this;
        }

        internal override GreenNode SetDiagnostics(DiagnosticInfo[]? diagnostics)
            => new PositionalPatternClauseSyntax(this.Kind, this.openParenToken, this.subpatterns, this.closeParenToken, diagnostics, GetAnnotations());

        internal override GreenNode SetAnnotations(SyntaxAnnotation[]? annotations)
            => new PositionalPatternClauseSyntax(this.Kind, this.openParenToken, this.subpatterns, this.closeParenToken, GetDiagnostics(), annotations);

        internal PositionalPatternClauseSyntax(ObjectReader reader)
          : base(reader)
        {
            this.SlotCount = 3;
            var openParenToken = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(openParenToken);
            this.openParenToken = openParenToken;
            var subpatterns = (GreenNode?)reader.ReadValue();
            if (subpatterns != null)
            {
                AdjustFlagsAndWidth(subpatterns);
                this.subpatterns = subpatterns;
            }
            var closeParenToken = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(closeParenToken);
            this.closeParenToken = closeParenToken;
        }

        internal override void WriteTo(ObjectWriter writer)
        {
            base.WriteTo(writer);
            writer.WriteValue(this.openParenToken);
            writer.WriteValue(this.subpatterns);
            writer.WriteValue(this.closeParenToken);
        }

        static PositionalPatternClauseSyntax()
        {
            ObjectBinder.RegisterTypeReader(typeof(PositionalPatternClauseSyntax), r => new PositionalPatternClauseSyntax(r));
        }
    }

    internal sealed partial class PropertyPatternClauseSyntax : CSharpSyntaxNode
    {
        internal readonly SyntaxToken openBraceToken;
        internal readonly GreenNode? subpatterns;
        internal readonly SyntaxToken closeBraceToken;

        internal PropertyPatternClauseSyntax(SyntaxKind kind, SyntaxToken openBraceToken, GreenNode? subpatterns, SyntaxToken closeBraceToken, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
            this.SlotCount = 3;
            this.AdjustFlagsAndWidth(openBraceToken);
            this.openBraceToken = openBraceToken;
            if (subpatterns != null)
            {
                this.AdjustFlagsAndWidth(subpatterns);
                this.subpatterns = subpatterns;
            }
            this.AdjustFlagsAndWidth(closeBraceToken);
            this.closeBraceToken = closeBraceToken;
        }

        internal PropertyPatternClauseSyntax(SyntaxKind kind, SyntaxToken openBraceToken, GreenNode? subpatterns, SyntaxToken closeBraceToken, SyntaxFactoryContext context)
          : base(kind)
        {
            this.SetFactoryContext(context);
            this.SlotCount = 3;
            this.AdjustFlagsAndWidth(openBraceToken);
            this.openBraceToken = openBraceToken;
            if (subpatterns != null)
            {
                this.AdjustFlagsAndWidth(subpatterns);
                this.subpatterns = subpatterns;
            }
            this.AdjustFlagsAndWidth(closeBraceToken);
            this.closeBraceToken = closeBraceToken;
        }

        internal PropertyPatternClauseSyntax(SyntaxKind kind, SyntaxToken openBraceToken, GreenNode? subpatterns, SyntaxToken closeBraceToken)
          : base(kind)
        {
            this.SlotCount = 3;
            this.AdjustFlagsAndWidth(openBraceToken);
            this.openBraceToken = openBraceToken;
            if (subpatterns != null)
            {
                this.AdjustFlagsAndWidth(subpatterns);
                this.subpatterns = subpatterns;
            }
            this.AdjustFlagsAndWidth(closeBraceToken);
            this.closeBraceToken = closeBraceToken;
        }

        public SyntaxToken OpenBraceToken => this.openBraceToken;
        public Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<SubpatternSyntax> Subpatterns => new Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<SubpatternSyntax>(new Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<CSharpSyntaxNode>(this.subpatterns));
        public SyntaxToken CloseBraceToken => this.closeBraceToken;

        internal override GreenNode? GetSlot(int index)
            => index switch
            {
                0 => this.openBraceToken,
                1 => this.subpatterns,
                2 => this.closeBraceToken,
                _ => null,
            };

        internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new CSharp.Syntax.PropertyPatternClauseSyntax(this, parent, position);

        public override void Accept(CSharpSyntaxVisitor visitor) => visitor.VisitPropertyPatternClause(this);
        public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor) => visitor.VisitPropertyPatternClause(this);

        public PropertyPatternClauseSyntax Update(SyntaxToken openBraceToken, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<SubpatternSyntax> subpatterns, SyntaxToken closeBraceToken)
        {
            if (openBraceToken != this.OpenBraceToken || subpatterns != this.Subpatterns || closeBraceToken != this.CloseBraceToken)
            {
                var newNode = SyntaxFactory.PropertyPatternClause(openBraceToken, subpatterns, closeBraceToken);
                var diags = GetDiagnostics();
                if (diags?.Length > 0)
                    newNode = newNode.WithDiagnosticsGreen(diags);
                var annotations = GetAnnotations();
                if (annotations?.Length > 0)
                    newNode = newNode.WithAnnotationsGreen(annotations);
                return newNode;
            }

            return this;
        }

        internal override GreenNode SetDiagnostics(DiagnosticInfo[]? diagnostics)
            => new PropertyPatternClauseSyntax(this.Kind, this.openBraceToken, this.subpatterns, this.closeBraceToken, diagnostics, GetAnnotations());

        internal override GreenNode SetAnnotations(SyntaxAnnotation[]? annotations)
            => new PropertyPatternClauseSyntax(this.Kind, this.openBraceToken, this.subpatterns, this.closeBraceToken, GetDiagnostics(), annotations);

        internal PropertyPatternClauseSyntax(ObjectReader reader)
          : base(reader)
        {
            this.SlotCount = 3;
            var openBraceToken = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(openBraceToken);
            this.openBraceToken = openBraceToken;
            var subpatterns = (GreenNode?)reader.ReadValue();
            if (subpatterns != null)
            {
                AdjustFlagsAndWidth(subpatterns);
                this.subpatterns = subpatterns;
            }
            var closeBraceToken = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(closeBraceToken);
            this.closeBraceToken = closeBraceToken;
        }

        internal override void WriteTo(ObjectWriter writer)
        {
            base.WriteTo(writer);
            writer.WriteValue(this.openBraceToken);
            writer.WriteValue(this.subpatterns);
            writer.WriteValue(this.closeBraceToken);
        }

        static PropertyPatternClauseSyntax()
        {
            ObjectBinder.RegisterTypeReader(typeof(PropertyPatternClauseSyntax), r => new PropertyPatternClauseSyntax(r));
        }
    }

    internal sealed partial class SubpatternSyntax : CSharpSyntaxNode
    {
        internal readonly NameColonSyntax? nameColon;
        internal readonly PatternSyntax pattern;

        internal SubpatternSyntax(SyntaxKind kind, NameColonSyntax? nameColon, PatternSyntax pattern, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
            this.SlotCount = 2;
            if (nameColon != null)
            {
                this.AdjustFlagsAndWidth(nameColon);
                this.nameColon = nameColon;
            }
            this.AdjustFlagsAndWidth(pattern);
            this.pattern = pattern;
        }

        internal SubpatternSyntax(SyntaxKind kind, NameColonSyntax? nameColon, PatternSyntax pattern, SyntaxFactoryContext context)
          : base(kind)
        {
            this.SetFactoryContext(context);
            this.SlotCount = 2;
            if (nameColon != null)
            {
                this.AdjustFlagsAndWidth(nameColon);
                this.nameColon = nameColon;
            }
            this.AdjustFlagsAndWidth(pattern);
            this.pattern = pattern;
        }

        internal SubpatternSyntax(SyntaxKind kind, NameColonSyntax? nameColon, PatternSyntax pattern)
          : base(kind)
        {
            this.SlotCount = 2;
            if (nameColon != null)
            {
                this.AdjustFlagsAndWidth(nameColon);
                this.nameColon = nameColon;
            }
            this.AdjustFlagsAndWidth(pattern);
            this.pattern = pattern;
        }

        public NameColonSyntax? NameColon => this.nameColon;
        public PatternSyntax Pattern => this.pattern;

        internal override GreenNode? GetSlot(int index)
            => index switch
            {
                0 => this.nameColon,
                1 => this.pattern,
                _ => null,
            };

        internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new CSharp.Syntax.SubpatternSyntax(this, parent, position);

        public override void Accept(CSharpSyntaxVisitor visitor) => visitor.VisitSubpattern(this);
        public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor) => visitor.VisitSubpattern(this);

        public SubpatternSyntax Update(NameColonSyntax nameColon, PatternSyntax pattern)
        {
            if (nameColon != this.NameColon || pattern != this.Pattern)
            {
                var newNode = SyntaxFactory.Subpattern(nameColon, pattern);
                var diags = GetDiagnostics();
                if (diags?.Length > 0)
                    newNode = newNode.WithDiagnosticsGreen(diags);
                var annotations = GetAnnotations();
                if (annotations?.Length > 0)
                    newNode = newNode.WithAnnotationsGreen(annotations);
                return newNode;
            }

            return this;
        }

        internal override GreenNode SetDiagnostics(DiagnosticInfo[]? diagnostics)
            => new SubpatternSyntax(this.Kind, this.nameColon, this.pattern, diagnostics, GetAnnotations());

        internal override GreenNode SetAnnotations(SyntaxAnnotation[]? annotations)
            => new SubpatternSyntax(this.Kind, this.nameColon, this.pattern, GetDiagnostics(), annotations);

        internal SubpatternSyntax(ObjectReader reader)
          : base(reader)
        {
            this.SlotCount = 2;
            var nameColon = (NameColonSyntax?)reader.ReadValue();
            if (nameColon != null)
            {
                AdjustFlagsAndWidth(nameColon);
                this.nameColon = nameColon;
            }
            var pattern = (PatternSyntax)reader.ReadValue();
            AdjustFlagsAndWidth(pattern);
            this.pattern = pattern;
        }

        internal override void WriteTo(ObjectWriter writer)
        {
            base.WriteTo(writer);
            writer.WriteValue(this.nameColon);
            writer.WriteValue(this.pattern);
        }

        static SubpatternSyntax()
        {
            ObjectBinder.RegisterTypeReader(typeof(SubpatternSyntax), r => new SubpatternSyntax(r));
        }
    }

    internal sealed partial class ConstantPatternSyntax : PatternSyntax
    {
        internal readonly ExpressionSyntax expression;

        internal ConstantPatternSyntax(SyntaxKind kind, ExpressionSyntax expression, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
            this.SlotCount = 1;
            this.AdjustFlagsAndWidth(expression);
            this.expression = expression;
        }

        internal ConstantPatternSyntax(SyntaxKind kind, ExpressionSyntax expression, SyntaxFactoryContext context)
          : base(kind)
        {
            this.SetFactoryContext(context);
            this.SlotCount = 1;
            this.AdjustFlagsAndWidth(expression);
            this.expression = expression;
        }

        internal ConstantPatternSyntax(SyntaxKind kind, ExpressionSyntax expression)
          : base(kind)
        {
            this.SlotCount = 1;
            this.AdjustFlagsAndWidth(expression);
            this.expression = expression;
        }

        /// <summary>ExpressionSyntax node representing the constant expression.</summary>
        public ExpressionSyntax Expression => this.expression;

        internal override GreenNode? GetSlot(int index)
            => index == 0 ? this.expression : null;

        internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new CSharp.Syntax.ConstantPatternSyntax(this, parent, position);

        public override void Accept(CSharpSyntaxVisitor visitor) => visitor.VisitConstantPattern(this);
        public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor) => visitor.VisitConstantPattern(this);

        public ConstantPatternSyntax Update(ExpressionSyntax expression)
        {
            if (expression != this.Expression)
            {
                var newNode = SyntaxFactory.ConstantPattern(expression);
                var diags = GetDiagnostics();
                if (diags?.Length > 0)
                    newNode = newNode.WithDiagnosticsGreen(diags);
                var annotations = GetAnnotations();
                if (annotations?.Length > 0)
                    newNode = newNode.WithAnnotationsGreen(annotations);
                return newNode;
            }

            return this;
        }

        internal override GreenNode SetDiagnostics(DiagnosticInfo[]? diagnostics)
            => new ConstantPatternSyntax(this.Kind, this.expression, diagnostics, GetAnnotations());

        internal override GreenNode SetAnnotations(SyntaxAnnotation[]? annotations)
            => new ConstantPatternSyntax(this.Kind, this.expression, GetDiagnostics(), annotations);

        internal ConstantPatternSyntax(ObjectReader reader)
          : base(reader)
        {
            this.SlotCount = 1;
            var expression = (ExpressionSyntax)reader.ReadValue();
            AdjustFlagsAndWidth(expression);
            this.expression = expression;
        }

        internal override void WriteTo(ObjectWriter writer)
        {
            base.WriteTo(writer);
            writer.WriteValue(this.expression);
        }

        static ConstantPatternSyntax()
        {
            ObjectBinder.RegisterTypeReader(typeof(ConstantPatternSyntax), r => new ConstantPatternSyntax(r));
        }
    }

    internal sealed partial class ParenthesizedPatternSyntax : PatternSyntax
    {
        internal readonly SyntaxToken openParenToken;
        internal readonly PatternSyntax pattern;
        internal readonly SyntaxToken closeParenToken;

        internal ParenthesizedPatternSyntax(SyntaxKind kind, SyntaxToken openParenToken, PatternSyntax pattern, SyntaxToken closeParenToken, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
            this.SlotCount = 3;
            this.AdjustFlagsAndWidth(openParenToken);
            this.openParenToken = openParenToken;
            this.AdjustFlagsAndWidth(pattern);
            this.pattern = pattern;
            this.AdjustFlagsAndWidth(closeParenToken);
            this.closeParenToken = closeParenToken;
        }

        internal ParenthesizedPatternSyntax(SyntaxKind kind, SyntaxToken openParenToken, PatternSyntax pattern, SyntaxToken closeParenToken, SyntaxFactoryContext context)
          : base(kind)
        {
            this.SetFactoryContext(context);
            this.SlotCount = 3;
            this.AdjustFlagsAndWidth(openParenToken);
            this.openParenToken = openParenToken;
            this.AdjustFlagsAndWidth(pattern);
            this.pattern = pattern;
            this.AdjustFlagsAndWidth(closeParenToken);
            this.closeParenToken = closeParenToken;
        }

        internal ParenthesizedPatternSyntax(SyntaxKind kind, SyntaxToken openParenToken, PatternSyntax pattern, SyntaxToken closeParenToken)
          : base(kind)
        {
            this.SlotCount = 3;
            this.AdjustFlagsAndWidth(openParenToken);
            this.openParenToken = openParenToken;
            this.AdjustFlagsAndWidth(pattern);
            this.pattern = pattern;
            this.AdjustFlagsAndWidth(closeParenToken);
            this.closeParenToken = closeParenToken;
        }

        public SyntaxToken OpenParenToken => this.openParenToken;
        public PatternSyntax Pattern => this.pattern;
        public SyntaxToken CloseParenToken => this.closeParenToken;

        internal override GreenNode? GetSlot(int index)
            => index switch
            {
                0 => this.openParenToken,
                1 => this.pattern,
                2 => this.closeParenToken,
                _ => null,
            };

        internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new CSharp.Syntax.ParenthesizedPatternSyntax(this, parent, position);

        public override void Accept(CSharpSyntaxVisitor visitor) => visitor.VisitParenthesizedPattern(this);
        public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor) => visitor.VisitParenthesizedPattern(this);

        public ParenthesizedPatternSyntax Update(SyntaxToken openParenToken, PatternSyntax pattern, SyntaxToken closeParenToken)
        {
            if (openParenToken != this.OpenParenToken || pattern != this.Pattern || closeParenToken != this.CloseParenToken)
            {
                var newNode = SyntaxFactory.ParenthesizedPattern(openParenToken, pattern, closeParenToken);
                var diags = GetDiagnostics();
                if (diags?.Length > 0)
                    newNode = newNode.WithDiagnosticsGreen(diags);
                var annotations = GetAnnotations();
                if (annotations?.Length > 0)
                    newNode = newNode.WithAnnotationsGreen(annotations);
                return newNode;
            }

            return this;
        }

        internal override GreenNode SetDiagnostics(DiagnosticInfo[]? diagnostics)
            => new ParenthesizedPatternSyntax(this.Kind, this.openParenToken, this.pattern, this.closeParenToken, diagnostics, GetAnnotations());

        internal override GreenNode SetAnnotations(SyntaxAnnotation[]? annotations)
            => new ParenthesizedPatternSyntax(this.Kind, this.openParenToken, this.pattern, this.closeParenToken, GetDiagnostics(), annotations);

        internal ParenthesizedPatternSyntax(ObjectReader reader)
          : base(reader)
        {
            this.SlotCount = 3;
            var openParenToken = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(openParenToken);
            this.openParenToken = openParenToken;
            var pattern = (PatternSyntax)reader.ReadValue();
            AdjustFlagsAndWidth(pattern);
            this.pattern = pattern;
            var closeParenToken = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(closeParenToken);
            this.closeParenToken = closeParenToken;
        }

        internal override void WriteTo(ObjectWriter writer)
        {
            base.WriteTo(writer);
            writer.WriteValue(this.openParenToken);
            writer.WriteValue(this.pattern);
            writer.WriteValue(this.closeParenToken);
        }

        static ParenthesizedPatternSyntax()
        {
            ObjectBinder.RegisterTypeReader(typeof(ParenthesizedPatternSyntax), r => new ParenthesizedPatternSyntax(r));
        }
    }

    internal sealed partial class RelationalPatternSyntax : PatternSyntax
    {
        internal readonly SyntaxToken operatorToken;
        internal readonly ExpressionSyntax expression;

        internal RelationalPatternSyntax(SyntaxKind kind, SyntaxToken operatorToken, ExpressionSyntax expression, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
            this.SlotCount = 2;
            this.AdjustFlagsAndWidth(operatorToken);
            this.operatorToken = operatorToken;
            this.AdjustFlagsAndWidth(expression);
            this.expression = expression;
        }

        internal RelationalPatternSyntax(SyntaxKind kind, SyntaxToken operatorToken, ExpressionSyntax expression, SyntaxFactoryContext context)
          : base(kind)
        {
            this.SetFactoryContext(context);
            this.SlotCount = 2;
            this.AdjustFlagsAndWidth(operatorToken);
            this.operatorToken = operatorToken;
            this.AdjustFlagsAndWidth(expression);
            this.expression = expression;
        }

        internal RelationalPatternSyntax(SyntaxKind kind, SyntaxToken operatorToken, ExpressionSyntax expression)
          : base(kind)
        {
            this.SlotCount = 2;
            this.AdjustFlagsAndWidth(operatorToken);
            this.operatorToken = operatorToken;
            this.AdjustFlagsAndWidth(expression);
            this.expression = expression;
        }

        /// <summary>SyntaxToken representing the operator of the relational pattern.</summary>
        public SyntaxToken OperatorToken => this.operatorToken;
        public ExpressionSyntax Expression => this.expression;

        internal override GreenNode? GetSlot(int index)
            => index switch
            {
                0 => this.operatorToken,
                1 => this.expression,
                _ => null,
            };

        internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new CSharp.Syntax.RelationalPatternSyntax(this, parent, position);

        public override void Accept(CSharpSyntaxVisitor visitor) => visitor.VisitRelationalPattern(this);
        public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor) => visitor.VisitRelationalPattern(this);

        public RelationalPatternSyntax Update(SyntaxToken operatorToken, ExpressionSyntax expression)
        {
            if (operatorToken != this.OperatorToken || expression != this.Expression)
            {
                var newNode = SyntaxFactory.RelationalPattern(operatorToken, expression);
                var diags = GetDiagnostics();
                if (diags?.Length > 0)
                    newNode = newNode.WithDiagnosticsGreen(diags);
                var annotations = GetAnnotations();
                if (annotations?.Length > 0)
                    newNode = newNode.WithAnnotationsGreen(annotations);
                return newNode;
            }

            return this;
        }

        internal override GreenNode SetDiagnostics(DiagnosticInfo[]? diagnostics)
            => new RelationalPatternSyntax(this.Kind, this.operatorToken, this.expression, diagnostics, GetAnnotations());

        internal override GreenNode SetAnnotations(SyntaxAnnotation[]? annotations)
            => new RelationalPatternSyntax(this.Kind, this.operatorToken, this.expression, GetDiagnostics(), annotations);

        internal RelationalPatternSyntax(ObjectReader reader)
          : base(reader)
        {
            this.SlotCount = 2;
            var operatorToken = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(operatorToken);
            this.operatorToken = operatorToken;
            var expression = (ExpressionSyntax)reader.ReadValue();
            AdjustFlagsAndWidth(expression);
            this.expression = expression;
        }

        internal override void WriteTo(ObjectWriter writer)
        {
            base.WriteTo(writer);
            writer.WriteValue(this.operatorToken);
            writer.WriteValue(this.expression);
        }

        static RelationalPatternSyntax()
        {
            ObjectBinder.RegisterTypeReader(typeof(RelationalPatternSyntax), r => new RelationalPatternSyntax(r));
        }
    }

    internal sealed partial class TypePatternSyntax : PatternSyntax
    {
        internal readonly TypeSyntax type;

        internal TypePatternSyntax(SyntaxKind kind, TypeSyntax type, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
            this.SlotCount = 1;
            this.AdjustFlagsAndWidth(type);
            this.type = type;
        }

        internal TypePatternSyntax(SyntaxKind kind, TypeSyntax type, SyntaxFactoryContext context)
          : base(kind)
        {
            this.SetFactoryContext(context);
            this.SlotCount = 1;
            this.AdjustFlagsAndWidth(type);
            this.type = type;
        }

        internal TypePatternSyntax(SyntaxKind kind, TypeSyntax type)
          : base(kind)
        {
            this.SlotCount = 1;
            this.AdjustFlagsAndWidth(type);
            this.type = type;
        }

        /// <summary>The type for the type pattern.</summary>
        public TypeSyntax Type => this.type;

        internal override GreenNode? GetSlot(int index)
            => index == 0 ? this.type : null;

        internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new CSharp.Syntax.TypePatternSyntax(this, parent, position);

        public override void Accept(CSharpSyntaxVisitor visitor) => visitor.VisitTypePattern(this);
        public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor) => visitor.VisitTypePattern(this);

        public TypePatternSyntax Update(TypeSyntax type)
        {
            if (type != this.Type)
            {
                var newNode = SyntaxFactory.TypePattern(type);
                var diags = GetDiagnostics();
                if (diags?.Length > 0)
                    newNode = newNode.WithDiagnosticsGreen(diags);
                var annotations = GetAnnotations();
                if (annotations?.Length > 0)
                    newNode = newNode.WithAnnotationsGreen(annotations);
                return newNode;
            }

            return this;
        }

        internal override GreenNode SetDiagnostics(DiagnosticInfo[]? diagnostics)
            => new TypePatternSyntax(this.Kind, this.type, diagnostics, GetAnnotations());

        internal override GreenNode SetAnnotations(SyntaxAnnotation[]? annotations)
            => new TypePatternSyntax(this.Kind, this.type, GetDiagnostics(), annotations);

        internal TypePatternSyntax(ObjectReader reader)
          : base(reader)
        {
            this.SlotCount = 1;
            var type = (TypeSyntax)reader.ReadValue();
            AdjustFlagsAndWidth(type);
            this.type = type;
        }

        internal override void WriteTo(ObjectWriter writer)
        {
            base.WriteTo(writer);
            writer.WriteValue(this.type);
        }

        static TypePatternSyntax()
        {
            ObjectBinder.RegisterTypeReader(typeof(TypePatternSyntax), r => new TypePatternSyntax(r));
        }
    }

    internal sealed partial class BinaryPatternSyntax : PatternSyntax
    {
        internal readonly PatternSyntax left;
        internal readonly SyntaxToken operatorToken;
        internal readonly PatternSyntax right;

        internal BinaryPatternSyntax(SyntaxKind kind, PatternSyntax left, SyntaxToken operatorToken, PatternSyntax right, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
            this.SlotCount = 3;
            this.AdjustFlagsAndWidth(left);
            this.left = left;
            this.AdjustFlagsAndWidth(operatorToken);
            this.operatorToken = operatorToken;
            this.AdjustFlagsAndWidth(right);
            this.right = right;
        }

        internal BinaryPatternSyntax(SyntaxKind kind, PatternSyntax left, SyntaxToken operatorToken, PatternSyntax right, SyntaxFactoryContext context)
          : base(kind)
        {
            this.SetFactoryContext(context);
            this.SlotCount = 3;
            this.AdjustFlagsAndWidth(left);
            this.left = left;
            this.AdjustFlagsAndWidth(operatorToken);
            this.operatorToken = operatorToken;
            this.AdjustFlagsAndWidth(right);
            this.right = right;
        }

        internal BinaryPatternSyntax(SyntaxKind kind, PatternSyntax left, SyntaxToken operatorToken, PatternSyntax right)
          : base(kind)
        {
            this.SlotCount = 3;
            this.AdjustFlagsAndWidth(left);
            this.left = left;
            this.AdjustFlagsAndWidth(operatorToken);
            this.operatorToken = operatorToken;
            this.AdjustFlagsAndWidth(right);
            this.right = right;
        }

        public PatternSyntax Left => this.left;
        public SyntaxToken OperatorToken => this.operatorToken;
        public PatternSyntax Right => this.right;

        internal override GreenNode? GetSlot(int index)
            => index switch
            {
                0 => this.left,
                1 => this.operatorToken,
                2 => this.right,
                _ => null,
            };

        internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new CSharp.Syntax.BinaryPatternSyntax(this, parent, position);

        public override void Accept(CSharpSyntaxVisitor visitor) => visitor.VisitBinaryPattern(this);
        public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor) => visitor.VisitBinaryPattern(this);

        public BinaryPatternSyntax Update(PatternSyntax left, SyntaxToken operatorToken, PatternSyntax right)
        {
            if (left != this.Left || operatorToken != this.OperatorToken || right != this.Right)
            {
                var newNode = SyntaxFactory.BinaryPattern(this.Kind, left, operatorToken, right);
                var diags = GetDiagnostics();
                if (diags?.Length > 0)
                    newNode = newNode.WithDiagnosticsGreen(diags);
                var annotations = GetAnnotations();
                if (annotations?.Length > 0)
                    newNode = newNode.WithAnnotationsGreen(annotations);
                return newNode;
            }

            return this;
        }

        internal override GreenNode SetDiagnostics(DiagnosticInfo[]? diagnostics)
            => new BinaryPatternSyntax(this.Kind, this.left, this.operatorToken, this.right, diagnostics, GetAnnotations());

        internal override GreenNode SetAnnotations(SyntaxAnnotation[]? annotations)
            => new BinaryPatternSyntax(this.Kind, this.left, this.operatorToken, this.right, GetDiagnostics(), annotations);

        internal BinaryPatternSyntax(ObjectReader reader)
          : base(reader)
        {
            this.SlotCount = 3;
            var left = (PatternSyntax)reader.ReadValue();
            AdjustFlagsAndWidth(left);
            this.left = left;
            var operatorToken = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(operatorToken);
            this.operatorToken = operatorToken;
            var right = (PatternSyntax)reader.ReadValue();
            AdjustFlagsAndWidth(right);
            this.right = right;
        }

        internal override void WriteTo(ObjectWriter writer)
        {
            base.WriteTo(writer);
            writer.WriteValue(this.left);
            writer.WriteValue(this.operatorToken);
            writer.WriteValue(this.right);
        }

        static BinaryPatternSyntax()
        {
            ObjectBinder.RegisterTypeReader(typeof(BinaryPatternSyntax), r => new BinaryPatternSyntax(r));
        }
    }

    internal sealed partial class UnaryPatternSyntax : PatternSyntax
    {
        internal readonly SyntaxToken operatorToken;
        internal readonly PatternSyntax pattern;

        internal UnaryPatternSyntax(SyntaxKind kind, SyntaxToken operatorToken, PatternSyntax pattern, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
            this.SlotCount = 2;
            this.AdjustFlagsAndWidth(operatorToken);
            this.operatorToken = operatorToken;
            this.AdjustFlagsAndWidth(pattern);
            this.pattern = pattern;
        }

        internal UnaryPatternSyntax(SyntaxKind kind, SyntaxToken operatorToken, PatternSyntax pattern, SyntaxFactoryContext context)
          : base(kind)
        {
            this.SetFactoryContext(context);
            this.SlotCount = 2;
            this.AdjustFlagsAndWidth(operatorToken);
            this.operatorToken = operatorToken;
            this.AdjustFlagsAndWidth(pattern);
            this.pattern = pattern;
        }

        internal UnaryPatternSyntax(SyntaxKind kind, SyntaxToken operatorToken, PatternSyntax pattern)
          : base(kind)
        {
            this.SlotCount = 2;
            this.AdjustFlagsAndWidth(operatorToken);
            this.operatorToken = operatorToken;
            this.AdjustFlagsAndWidth(pattern);
            this.pattern = pattern;
        }

        public SyntaxToken OperatorToken => this.operatorToken;
        public PatternSyntax Pattern => this.pattern;

        internal override GreenNode? GetSlot(int index)
            => index switch
            {
                0 => this.operatorToken,
                1 => this.pattern,
                _ => null,
            };

        internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new CSharp.Syntax.UnaryPatternSyntax(this, parent, position);

        public override void Accept(CSharpSyntaxVisitor visitor) => visitor.VisitUnaryPattern(this);
        public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor) => visitor.VisitUnaryPattern(this);

        public UnaryPatternSyntax Update(SyntaxToken operatorToken, PatternSyntax pattern)
        {
            if (operatorToken != this.OperatorToken || pattern != this.Pattern)
            {
                var newNode = SyntaxFactory.UnaryPattern(operatorToken, pattern);
                var diags = GetDiagnostics();
                if (diags?.Length > 0)
                    newNode = newNode.WithDiagnosticsGreen(diags);
                var annotations = GetAnnotations();
                if (annotations?.Length > 0)
                    newNode = newNode.WithAnnotationsGreen(annotations);
                return newNode;
            }

            return this;
        }

        internal override GreenNode SetDiagnostics(DiagnosticInfo[]? diagnostics)
            => new UnaryPatternSyntax(this.Kind, this.operatorToken, this.pattern, diagnostics, GetAnnotations());

        internal override GreenNode SetAnnotations(SyntaxAnnotation[]? annotations)
            => new UnaryPatternSyntax(this.Kind, this.operatorToken, this.pattern, GetDiagnostics(), annotations);

        internal UnaryPatternSyntax(ObjectReader reader)
          : base(reader)
        {
            this.SlotCount = 2;
            var operatorToken = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(operatorToken);
            this.operatorToken = operatorToken;
            var pattern = (PatternSyntax)reader.ReadValue();
            AdjustFlagsAndWidth(pattern);
            this.pattern = pattern;
        }

        internal override void WriteTo(ObjectWriter writer)
        {
            base.WriteTo(writer);
            writer.WriteValue(this.operatorToken);
            writer.WriteValue(this.pattern);
        }

        static UnaryPatternSyntax()
        {
            ObjectBinder.RegisterTypeReader(typeof(UnaryPatternSyntax), r => new UnaryPatternSyntax(r));
        }
    }

    internal abstract partial class InterpolatedStringContentSyntax : CSharpSyntaxNode
    {
        internal InterpolatedStringContentSyntax(SyntaxKind kind, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
        }

        internal InterpolatedStringContentSyntax(SyntaxKind kind)
          : base(kind)
        {
        }

        protected InterpolatedStringContentSyntax(ObjectReader reader)
          : base(reader)
        {
        }
    }

    internal sealed partial class InterpolatedStringTextSyntax : InterpolatedStringContentSyntax
    {
        internal readonly SyntaxToken textToken;

        internal InterpolatedStringTextSyntax(SyntaxKind kind, SyntaxToken textToken, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
            this.SlotCount = 1;
            this.AdjustFlagsAndWidth(textToken);
            this.textToken = textToken;
        }

        internal InterpolatedStringTextSyntax(SyntaxKind kind, SyntaxToken textToken, SyntaxFactoryContext context)
          : base(kind)
        {
            this.SetFactoryContext(context);
            this.SlotCount = 1;
            this.AdjustFlagsAndWidth(textToken);
            this.textToken = textToken;
        }

        internal InterpolatedStringTextSyntax(SyntaxKind kind, SyntaxToken textToken)
          : base(kind)
        {
            this.SlotCount = 1;
            this.AdjustFlagsAndWidth(textToken);
            this.textToken = textToken;
        }

        /// <summary>The text contents of a part of the interpolated string.</summary>
        public SyntaxToken TextToken => this.textToken;

        internal override GreenNode? GetSlot(int index)
            => index == 0 ? this.textToken : null;

        internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new CSharp.Syntax.InterpolatedStringTextSyntax(this, parent, position);

        public override void Accept(CSharpSyntaxVisitor visitor) => visitor.VisitInterpolatedStringText(this);
        public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor) => visitor.VisitInterpolatedStringText(this);

        public InterpolatedStringTextSyntax Update(SyntaxToken textToken)
        {
            if (textToken != this.TextToken)
            {
                var newNode = SyntaxFactory.InterpolatedStringText(textToken);
                var diags = GetDiagnostics();
                if (diags?.Length > 0)
                    newNode = newNode.WithDiagnosticsGreen(diags);
                var annotations = GetAnnotations();
                if (annotations?.Length > 0)
                    newNode = newNode.WithAnnotationsGreen(annotations);
                return newNode;
            }

            return this;
        }

        internal override GreenNode SetDiagnostics(DiagnosticInfo[]? diagnostics)
            => new InterpolatedStringTextSyntax(this.Kind, this.textToken, diagnostics, GetAnnotations());

        internal override GreenNode SetAnnotations(SyntaxAnnotation[]? annotations)
            => new InterpolatedStringTextSyntax(this.Kind, this.textToken, GetDiagnostics(), annotations);

        internal InterpolatedStringTextSyntax(ObjectReader reader)
          : base(reader)
        {
            this.SlotCount = 1;
            var textToken = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(textToken);
            this.textToken = textToken;
        }

        internal override void WriteTo(ObjectWriter writer)
        {
            base.WriteTo(writer);
            writer.WriteValue(this.textToken);
        }

        static InterpolatedStringTextSyntax()
        {
            ObjectBinder.RegisterTypeReader(typeof(InterpolatedStringTextSyntax), r => new InterpolatedStringTextSyntax(r));
        }
    }

    internal sealed partial class InterpolationSyntax : InterpolatedStringContentSyntax
    {
        internal readonly SyntaxToken openBraceToken;
        internal readonly ExpressionSyntax expression;
        internal readonly InterpolationAlignmentClauseSyntax? alignmentClause;
        internal readonly InterpolationFormatClauseSyntax? formatClause;
        internal readonly SyntaxToken closeBraceToken;

        internal InterpolationSyntax(SyntaxKind kind, SyntaxToken openBraceToken, ExpressionSyntax expression, InterpolationAlignmentClauseSyntax? alignmentClause, InterpolationFormatClauseSyntax? formatClause, SyntaxToken closeBraceToken, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
            this.SlotCount = 5;
            this.AdjustFlagsAndWidth(openBraceToken);
            this.openBraceToken = openBraceToken;
            this.AdjustFlagsAndWidth(expression);
            this.expression = expression;
            if (alignmentClause != null)
            {
                this.AdjustFlagsAndWidth(alignmentClause);
                this.alignmentClause = alignmentClause;
            }
            if (formatClause != null)
            {
                this.AdjustFlagsAndWidth(formatClause);
                this.formatClause = formatClause;
            }
            this.AdjustFlagsAndWidth(closeBraceToken);
            this.closeBraceToken = closeBraceToken;
        }

        internal InterpolationSyntax(SyntaxKind kind, SyntaxToken openBraceToken, ExpressionSyntax expression, InterpolationAlignmentClauseSyntax? alignmentClause, InterpolationFormatClauseSyntax? formatClause, SyntaxToken closeBraceToken, SyntaxFactoryContext context)
          : base(kind)
        {
            this.SetFactoryContext(context);
            this.SlotCount = 5;
            this.AdjustFlagsAndWidth(openBraceToken);
            this.openBraceToken = openBraceToken;
            this.AdjustFlagsAndWidth(expression);
            this.expression = expression;
            if (alignmentClause != null)
            {
                this.AdjustFlagsAndWidth(alignmentClause);
                this.alignmentClause = alignmentClause;
            }
            if (formatClause != null)
            {
                this.AdjustFlagsAndWidth(formatClause);
                this.formatClause = formatClause;
            }
            this.AdjustFlagsAndWidth(closeBraceToken);
            this.closeBraceToken = closeBraceToken;
        }

        internal InterpolationSyntax(SyntaxKind kind, SyntaxToken openBraceToken, ExpressionSyntax expression, InterpolationAlignmentClauseSyntax? alignmentClause, InterpolationFormatClauseSyntax? formatClause, SyntaxToken closeBraceToken)
          : base(kind)
        {
            this.SlotCount = 5;
            this.AdjustFlagsAndWidth(openBraceToken);
            this.openBraceToken = openBraceToken;
            this.AdjustFlagsAndWidth(expression);
            this.expression = expression;
            if (alignmentClause != null)
            {
                this.AdjustFlagsAndWidth(alignmentClause);
                this.alignmentClause = alignmentClause;
            }
            if (formatClause != null)
            {
                this.AdjustFlagsAndWidth(formatClause);
                this.formatClause = formatClause;
            }
            this.AdjustFlagsAndWidth(closeBraceToken);
            this.closeBraceToken = closeBraceToken;
        }

        public SyntaxToken OpenBraceToken => this.openBraceToken;
        public ExpressionSyntax Expression => this.expression;
        public InterpolationAlignmentClauseSyntax? AlignmentClause => this.alignmentClause;
        public InterpolationFormatClauseSyntax? FormatClause => this.formatClause;
        public SyntaxToken CloseBraceToken => this.closeBraceToken;

        internal override GreenNode? GetSlot(int index)
            => index switch
            {
                0 => this.openBraceToken,
                1 => this.expression,
                2 => this.alignmentClause,
                3 => this.formatClause,
                4 => this.closeBraceToken,
                _ => null,
            };

        internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new CSharp.Syntax.InterpolationSyntax(this, parent, position);

        public override void Accept(CSharpSyntaxVisitor visitor) => visitor.VisitInterpolation(this);
        public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor) => visitor.VisitInterpolation(this);

        public InterpolationSyntax Update(SyntaxToken openBraceToken, ExpressionSyntax expression, InterpolationAlignmentClauseSyntax alignmentClause, InterpolationFormatClauseSyntax formatClause, SyntaxToken closeBraceToken)
        {
            if (openBraceToken != this.OpenBraceToken || expression != this.Expression || alignmentClause != this.AlignmentClause || formatClause != this.FormatClause || closeBraceToken != this.CloseBraceToken)
            {
                var newNode = SyntaxFactory.Interpolation(openBraceToken, expression, alignmentClause, formatClause, closeBraceToken);
                var diags = GetDiagnostics();
                if (diags?.Length > 0)
                    newNode = newNode.WithDiagnosticsGreen(diags);
                var annotations = GetAnnotations();
                if (annotations?.Length > 0)
                    newNode = newNode.WithAnnotationsGreen(annotations);
                return newNode;
            }

            return this;
        }

        internal override GreenNode SetDiagnostics(DiagnosticInfo[]? diagnostics)
            => new InterpolationSyntax(this.Kind, this.openBraceToken, this.expression, this.alignmentClause, this.formatClause, this.closeBraceToken, diagnostics, GetAnnotations());

        internal override GreenNode SetAnnotations(SyntaxAnnotation[]? annotations)
            => new InterpolationSyntax(this.Kind, this.openBraceToken, this.expression, this.alignmentClause, this.formatClause, this.closeBraceToken, GetDiagnostics(), annotations);

        internal InterpolationSyntax(ObjectReader reader)
          : base(reader)
        {
            this.SlotCount = 5;
            var openBraceToken = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(openBraceToken);
            this.openBraceToken = openBraceToken;
            var expression = (ExpressionSyntax)reader.ReadValue();
            AdjustFlagsAndWidth(expression);
            this.expression = expression;
            var alignmentClause = (InterpolationAlignmentClauseSyntax?)reader.ReadValue();
            if (alignmentClause != null)
            {
                AdjustFlagsAndWidth(alignmentClause);
                this.alignmentClause = alignmentClause;
            }
            var formatClause = (InterpolationFormatClauseSyntax?)reader.ReadValue();
            if (formatClause != null)
            {
                AdjustFlagsAndWidth(formatClause);
                this.formatClause = formatClause;
            }
            var closeBraceToken = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(closeBraceToken);
            this.closeBraceToken = closeBraceToken;
        }

        internal override void WriteTo(ObjectWriter writer)
        {
            base.WriteTo(writer);
            writer.WriteValue(this.openBraceToken);
            writer.WriteValue(this.expression);
            writer.WriteValue(this.alignmentClause);
            writer.WriteValue(this.formatClause);
            writer.WriteValue(this.closeBraceToken);
        }

        static InterpolationSyntax()
        {
            ObjectBinder.RegisterTypeReader(typeof(InterpolationSyntax), r => new InterpolationSyntax(r));
        }
    }

    internal sealed partial class InterpolationAlignmentClauseSyntax : CSharpSyntaxNode
    {
        internal readonly SyntaxToken commaToken;
        internal readonly ExpressionSyntax value;

        internal InterpolationAlignmentClauseSyntax(SyntaxKind kind, SyntaxToken commaToken, ExpressionSyntax value, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
            this.SlotCount = 2;
            this.AdjustFlagsAndWidth(commaToken);
            this.commaToken = commaToken;
            this.AdjustFlagsAndWidth(value);
            this.value = value;
        }

        internal InterpolationAlignmentClauseSyntax(SyntaxKind kind, SyntaxToken commaToken, ExpressionSyntax value, SyntaxFactoryContext context)
          : base(kind)
        {
            this.SetFactoryContext(context);
            this.SlotCount = 2;
            this.AdjustFlagsAndWidth(commaToken);
            this.commaToken = commaToken;
            this.AdjustFlagsAndWidth(value);
            this.value = value;
        }

        internal InterpolationAlignmentClauseSyntax(SyntaxKind kind, SyntaxToken commaToken, ExpressionSyntax value)
          : base(kind)
        {
            this.SlotCount = 2;
            this.AdjustFlagsAndWidth(commaToken);
            this.commaToken = commaToken;
            this.AdjustFlagsAndWidth(value);
            this.value = value;
        }

        public SyntaxToken CommaToken => this.commaToken;
        public ExpressionSyntax Value => this.value;

        internal override GreenNode? GetSlot(int index)
            => index switch
            {
                0 => this.commaToken,
                1 => this.value,
                _ => null,
            };

        internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new CSharp.Syntax.InterpolationAlignmentClauseSyntax(this, parent, position);

        public override void Accept(CSharpSyntaxVisitor visitor) => visitor.VisitInterpolationAlignmentClause(this);
        public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor) => visitor.VisitInterpolationAlignmentClause(this);

        public InterpolationAlignmentClauseSyntax Update(SyntaxToken commaToken, ExpressionSyntax value)
        {
            if (commaToken != this.CommaToken || value != this.Value)
            {
                var newNode = SyntaxFactory.InterpolationAlignmentClause(commaToken, value);
                var diags = GetDiagnostics();
                if (diags?.Length > 0)
                    newNode = newNode.WithDiagnosticsGreen(diags);
                var annotations = GetAnnotations();
                if (annotations?.Length > 0)
                    newNode = newNode.WithAnnotationsGreen(annotations);
                return newNode;
            }

            return this;
        }

        internal override GreenNode SetDiagnostics(DiagnosticInfo[]? diagnostics)
            => new InterpolationAlignmentClauseSyntax(this.Kind, this.commaToken, this.value, diagnostics, GetAnnotations());

        internal override GreenNode SetAnnotations(SyntaxAnnotation[]? annotations)
            => new InterpolationAlignmentClauseSyntax(this.Kind, this.commaToken, this.value, GetDiagnostics(), annotations);

        internal InterpolationAlignmentClauseSyntax(ObjectReader reader)
          : base(reader)
        {
            this.SlotCount = 2;
            var commaToken = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(commaToken);
            this.commaToken = commaToken;
            var value = (ExpressionSyntax)reader.ReadValue();
            AdjustFlagsAndWidth(value);
            this.value = value;
        }

        internal override void WriteTo(ObjectWriter writer)
        {
            base.WriteTo(writer);
            writer.WriteValue(this.commaToken);
            writer.WriteValue(this.value);
        }

        static InterpolationAlignmentClauseSyntax()
        {
            ObjectBinder.RegisterTypeReader(typeof(InterpolationAlignmentClauseSyntax), r => new InterpolationAlignmentClauseSyntax(r));
        }
    }

    internal sealed partial class InterpolationFormatClauseSyntax : CSharpSyntaxNode
    {
        internal readonly SyntaxToken colonToken;
        internal readonly SyntaxToken formatStringToken;

        internal InterpolationFormatClauseSyntax(SyntaxKind kind, SyntaxToken colonToken, SyntaxToken formatStringToken, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
            this.SlotCount = 2;
            this.AdjustFlagsAndWidth(colonToken);
            this.colonToken = colonToken;
            this.AdjustFlagsAndWidth(formatStringToken);
            this.formatStringToken = formatStringToken;
        }

        internal InterpolationFormatClauseSyntax(SyntaxKind kind, SyntaxToken colonToken, SyntaxToken formatStringToken, SyntaxFactoryContext context)
          : base(kind)
        {
            this.SetFactoryContext(context);
            this.SlotCount = 2;
            this.AdjustFlagsAndWidth(colonToken);
            this.colonToken = colonToken;
            this.AdjustFlagsAndWidth(formatStringToken);
            this.formatStringToken = formatStringToken;
        }

        internal InterpolationFormatClauseSyntax(SyntaxKind kind, SyntaxToken colonToken, SyntaxToken formatStringToken)
          : base(kind)
        {
            this.SlotCount = 2;
            this.AdjustFlagsAndWidth(colonToken);
            this.colonToken = colonToken;
            this.AdjustFlagsAndWidth(formatStringToken);
            this.formatStringToken = formatStringToken;
        }

        public SyntaxToken ColonToken => this.colonToken;
        /// <summary>The text contents of the format specifier for an interpolation.</summary>
        public SyntaxToken FormatStringToken => this.formatStringToken;

        internal override GreenNode? GetSlot(int index)
            => index switch
            {
                0 => this.colonToken,
                1 => this.formatStringToken,
                _ => null,
            };

        internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new CSharp.Syntax.InterpolationFormatClauseSyntax(this, parent, position);

        public override void Accept(CSharpSyntaxVisitor visitor) => visitor.VisitInterpolationFormatClause(this);
        public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor) => visitor.VisitInterpolationFormatClause(this);

        public InterpolationFormatClauseSyntax Update(SyntaxToken colonToken, SyntaxToken formatStringToken)
        {
            if (colonToken != this.ColonToken || formatStringToken != this.FormatStringToken)
            {
                var newNode = SyntaxFactory.InterpolationFormatClause(colonToken, formatStringToken);
                var diags = GetDiagnostics();
                if (diags?.Length > 0)
                    newNode = newNode.WithDiagnosticsGreen(diags);
                var annotations = GetAnnotations();
                if (annotations?.Length > 0)
                    newNode = newNode.WithAnnotationsGreen(annotations);
                return newNode;
            }

            return this;
        }

        internal override GreenNode SetDiagnostics(DiagnosticInfo[]? diagnostics)
            => new InterpolationFormatClauseSyntax(this.Kind, this.colonToken, this.formatStringToken, diagnostics, GetAnnotations());

        internal override GreenNode SetAnnotations(SyntaxAnnotation[]? annotations)
            => new InterpolationFormatClauseSyntax(this.Kind, this.colonToken, this.formatStringToken, GetDiagnostics(), annotations);

        internal InterpolationFormatClauseSyntax(ObjectReader reader)
          : base(reader)
        {
            this.SlotCount = 2;
            var colonToken = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(colonToken);
            this.colonToken = colonToken;
            var formatStringToken = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(formatStringToken);
            this.formatStringToken = formatStringToken;
        }

        internal override void WriteTo(ObjectWriter writer)
        {
            base.WriteTo(writer);
            writer.WriteValue(this.colonToken);
            writer.WriteValue(this.formatStringToken);
        }

        static InterpolationFormatClauseSyntax()
        {
            ObjectBinder.RegisterTypeReader(typeof(InterpolationFormatClauseSyntax), r => new InterpolationFormatClauseSyntax(r));
        }
    }

    internal sealed partial class GlobalStatementSyntax : MemberDeclarationSyntax
    {
        internal readonly GreenNode? attributeLists;
        internal readonly GreenNode? modifiers;
        internal readonly StatementSyntax statement;

        internal GlobalStatementSyntax(SyntaxKind kind, GreenNode? attributeLists, GreenNode? modifiers, StatementSyntax statement, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
            this.SlotCount = 3;
            if (attributeLists != null)
            {
                this.AdjustFlagsAndWidth(attributeLists);
                this.attributeLists = attributeLists;
            }
            if (modifiers != null)
            {
                this.AdjustFlagsAndWidth(modifiers);
                this.modifiers = modifiers;
            }
            this.AdjustFlagsAndWidth(statement);
            this.statement = statement;
        }

        internal GlobalStatementSyntax(SyntaxKind kind, GreenNode? attributeLists, GreenNode? modifiers, StatementSyntax statement, SyntaxFactoryContext context)
          : base(kind)
        {
            this.SetFactoryContext(context);
            this.SlotCount = 3;
            if (attributeLists != null)
            {
                this.AdjustFlagsAndWidth(attributeLists);
                this.attributeLists = attributeLists;
            }
            if (modifiers != null)
            {
                this.AdjustFlagsAndWidth(modifiers);
                this.modifiers = modifiers;
            }
            this.AdjustFlagsAndWidth(statement);
            this.statement = statement;
        }

        internal GlobalStatementSyntax(SyntaxKind kind, GreenNode? attributeLists, GreenNode? modifiers, StatementSyntax statement)
          : base(kind)
        {
            this.SlotCount = 3;
            if (attributeLists != null)
            {
                this.AdjustFlagsAndWidth(attributeLists);
                this.attributeLists = attributeLists;
            }
            if (modifiers != null)
            {
                this.AdjustFlagsAndWidth(modifiers);
                this.modifiers = modifiers;
            }
            this.AdjustFlagsAndWidth(statement);
            this.statement = statement;
        }

        public override Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<AttributeListSyntax> AttributeLists => new Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<AttributeListSyntax>(this.attributeLists);
        public override Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SyntaxToken> Modifiers => new Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SyntaxToken>(this.modifiers);
        public StatementSyntax Statement => this.statement;

        internal override GreenNode? GetSlot(int index)
            => index switch
            {
                0 => this.attributeLists,
                1 => this.modifiers,
                2 => this.statement,
                _ => null,
            };

        internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new CSharp.Syntax.GlobalStatementSyntax(this, parent, position);

        public override void Accept(CSharpSyntaxVisitor visitor) => visitor.VisitGlobalStatement(this);
        public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor) => visitor.VisitGlobalStatement(this);

        public GlobalStatementSyntax Update(Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<AttributeListSyntax> attributeLists, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SyntaxToken> modifiers, StatementSyntax statement)
        {
            if (attributeLists != this.AttributeLists || modifiers != this.Modifiers || statement != this.Statement)
            {
                var newNode = SyntaxFactory.GlobalStatement(attributeLists, modifiers, statement);
                var diags = GetDiagnostics();
                if (diags?.Length > 0)
                    newNode = newNode.WithDiagnosticsGreen(diags);
                var annotations = GetAnnotations();
                if (annotations?.Length > 0)
                    newNode = newNode.WithAnnotationsGreen(annotations);
                return newNode;
            }

            return this;
        }

        internal override GreenNode SetDiagnostics(DiagnosticInfo[]? diagnostics)
            => new GlobalStatementSyntax(this.Kind, this.attributeLists, this.modifiers, this.statement, diagnostics, GetAnnotations());

        internal override GreenNode SetAnnotations(SyntaxAnnotation[]? annotations)
            => new GlobalStatementSyntax(this.Kind, this.attributeLists, this.modifiers, this.statement, GetDiagnostics(), annotations);

        internal GlobalStatementSyntax(ObjectReader reader)
          : base(reader)
        {
            this.SlotCount = 3;
            var attributeLists = (GreenNode?)reader.ReadValue();
            if (attributeLists != null)
            {
                AdjustFlagsAndWidth(attributeLists);
                this.attributeLists = attributeLists;
            }
            var modifiers = (GreenNode?)reader.ReadValue();
            if (modifiers != null)
            {
                AdjustFlagsAndWidth(modifiers);
                this.modifiers = modifiers;
            }
            var statement = (StatementSyntax)reader.ReadValue();
            AdjustFlagsAndWidth(statement);
            this.statement = statement;
        }

        internal override void WriteTo(ObjectWriter writer)
        {
            base.WriteTo(writer);
            writer.WriteValue(this.attributeLists);
            writer.WriteValue(this.modifiers);
            writer.WriteValue(this.statement);
        }

        static GlobalStatementSyntax()
        {
            ObjectBinder.RegisterTypeReader(typeof(GlobalStatementSyntax), r => new GlobalStatementSyntax(r));
        }
    }

    /// <summary>Represents the base class for all statements syntax classes.</summary>
    internal abstract partial class StatementSyntax : CSharpSyntaxNode
    {
        internal StatementSyntax(SyntaxKind kind, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
        }

        internal StatementSyntax(SyntaxKind kind)
          : base(kind)
        {
        }

        protected StatementSyntax(ObjectReader reader)
          : base(reader)
        {
        }

        public abstract Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<AttributeListSyntax> AttributeLists { get; }
    }

    internal sealed partial class BlockSyntax : StatementSyntax
    {
        internal readonly GreenNode? attributeLists;
        internal readonly SyntaxToken openBraceToken;
        internal readonly GreenNode? statements;
        internal readonly SyntaxToken closeBraceToken;

        internal BlockSyntax(SyntaxKind kind, GreenNode? attributeLists, SyntaxToken openBraceToken, GreenNode? statements, SyntaxToken closeBraceToken, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
            this.SlotCount = 4;
            if (attributeLists != null)
            {
                this.AdjustFlagsAndWidth(attributeLists);
                this.attributeLists = attributeLists;
            }
            this.AdjustFlagsAndWidth(openBraceToken);
            this.openBraceToken = openBraceToken;
            if (statements != null)
            {
                this.AdjustFlagsAndWidth(statements);
                this.statements = statements;
            }
            this.AdjustFlagsAndWidth(closeBraceToken);
            this.closeBraceToken = closeBraceToken;
        }

        internal BlockSyntax(SyntaxKind kind, GreenNode? attributeLists, SyntaxToken openBraceToken, GreenNode? statements, SyntaxToken closeBraceToken, SyntaxFactoryContext context)
          : base(kind)
        {
            this.SetFactoryContext(context);
            this.SlotCount = 4;
            if (attributeLists != null)
            {
                this.AdjustFlagsAndWidth(attributeLists);
                this.attributeLists = attributeLists;
            }
            this.AdjustFlagsAndWidth(openBraceToken);
            this.openBraceToken = openBraceToken;
            if (statements != null)
            {
                this.AdjustFlagsAndWidth(statements);
                this.statements = statements;
            }
            this.AdjustFlagsAndWidth(closeBraceToken);
            this.closeBraceToken = closeBraceToken;
        }

        internal BlockSyntax(SyntaxKind kind, GreenNode? attributeLists, SyntaxToken openBraceToken, GreenNode? statements, SyntaxToken closeBraceToken)
          : base(kind)
        {
            this.SlotCount = 4;
            if (attributeLists != null)
            {
                this.AdjustFlagsAndWidth(attributeLists);
                this.attributeLists = attributeLists;
            }
            this.AdjustFlagsAndWidth(openBraceToken);
            this.openBraceToken = openBraceToken;
            if (statements != null)
            {
                this.AdjustFlagsAndWidth(statements);
                this.statements = statements;
            }
            this.AdjustFlagsAndWidth(closeBraceToken);
            this.closeBraceToken = closeBraceToken;
        }

        public override Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<AttributeListSyntax> AttributeLists => new Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<AttributeListSyntax>(this.attributeLists);
        public SyntaxToken OpenBraceToken => this.openBraceToken;
        public Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<StatementSyntax> Statements => new Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<StatementSyntax>(this.statements);
        public SyntaxToken CloseBraceToken => this.closeBraceToken;

        internal override GreenNode? GetSlot(int index)
            => index switch
            {
                0 => this.attributeLists,
                1 => this.openBraceToken,
                2 => this.statements,
                3 => this.closeBraceToken,
                _ => null,
            };

        internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new CSharp.Syntax.BlockSyntax(this, parent, position);

        public override void Accept(CSharpSyntaxVisitor visitor) => visitor.VisitBlock(this);
        public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor) => visitor.VisitBlock(this);

        public BlockSyntax Update(Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<AttributeListSyntax> attributeLists, SyntaxToken openBraceToken, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<StatementSyntax> statements, SyntaxToken closeBraceToken)
        {
            if (attributeLists != this.AttributeLists || openBraceToken != this.OpenBraceToken || statements != this.Statements || closeBraceToken != this.CloseBraceToken)
            {
                var newNode = SyntaxFactory.Block(attributeLists, openBraceToken, statements, closeBraceToken);
                var diags = GetDiagnostics();
                if (diags?.Length > 0)
                    newNode = newNode.WithDiagnosticsGreen(diags);
                var annotations = GetAnnotations();
                if (annotations?.Length > 0)
                    newNode = newNode.WithAnnotationsGreen(annotations);
                return newNode;
            }

            return this;
        }

        internal override GreenNode SetDiagnostics(DiagnosticInfo[]? diagnostics)
            => new BlockSyntax(this.Kind, this.attributeLists, this.openBraceToken, this.statements, this.closeBraceToken, diagnostics, GetAnnotations());

        internal override GreenNode SetAnnotations(SyntaxAnnotation[]? annotations)
            => new BlockSyntax(this.Kind, this.attributeLists, this.openBraceToken, this.statements, this.closeBraceToken, GetDiagnostics(), annotations);

        internal BlockSyntax(ObjectReader reader)
          : base(reader)
        {
            this.SlotCount = 4;
            var attributeLists = (GreenNode?)reader.ReadValue();
            if (attributeLists != null)
            {
                AdjustFlagsAndWidth(attributeLists);
                this.attributeLists = attributeLists;
            }
            var openBraceToken = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(openBraceToken);
            this.openBraceToken = openBraceToken;
            var statements = (GreenNode?)reader.ReadValue();
            if (statements != null)
            {
                AdjustFlagsAndWidth(statements);
                this.statements = statements;
            }
            var closeBraceToken = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(closeBraceToken);
            this.closeBraceToken = closeBraceToken;
        }

        internal override void WriteTo(ObjectWriter writer)
        {
            base.WriteTo(writer);
            writer.WriteValue(this.attributeLists);
            writer.WriteValue(this.openBraceToken);
            writer.WriteValue(this.statements);
            writer.WriteValue(this.closeBraceToken);
        }

        static BlockSyntax()
        {
            ObjectBinder.RegisterTypeReader(typeof(BlockSyntax), r => new BlockSyntax(r));
        }
    }

    internal sealed partial class LocalFunctionStatementSyntax : StatementSyntax
    {
        internal readonly GreenNode? attributeLists;
        internal readonly GreenNode? modifiers;
        internal readonly TypeSyntax returnType;
        internal readonly SyntaxToken identifier;
        internal readonly TypeParameterListSyntax? typeParameterList;
        internal readonly ParameterListSyntax parameterList;
        internal readonly GreenNode? constraintClauses;
        internal readonly BlockSyntax? body;
        internal readonly ArrowExpressionClauseSyntax? expressionBody;
        internal readonly SyntaxToken? semicolonToken;

        internal LocalFunctionStatementSyntax(SyntaxKind kind, GreenNode? attributeLists, GreenNode? modifiers, TypeSyntax returnType, SyntaxToken identifier, TypeParameterListSyntax? typeParameterList, ParameterListSyntax parameterList, GreenNode? constraintClauses, BlockSyntax? body, ArrowExpressionClauseSyntax? expressionBody, SyntaxToken? semicolonToken, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
            this.SlotCount = 10;
            if (attributeLists != null)
            {
                this.AdjustFlagsAndWidth(attributeLists);
                this.attributeLists = attributeLists;
            }
            if (modifiers != null)
            {
                this.AdjustFlagsAndWidth(modifiers);
                this.modifiers = modifiers;
            }
            this.AdjustFlagsAndWidth(returnType);
            this.returnType = returnType;
            this.AdjustFlagsAndWidth(identifier);
            this.identifier = identifier;
            if (typeParameterList != null)
            {
                this.AdjustFlagsAndWidth(typeParameterList);
                this.typeParameterList = typeParameterList;
            }
            this.AdjustFlagsAndWidth(parameterList);
            this.parameterList = parameterList;
            if (constraintClauses != null)
            {
                this.AdjustFlagsAndWidth(constraintClauses);
                this.constraintClauses = constraintClauses;
            }
            if (body != null)
            {
                this.AdjustFlagsAndWidth(body);
                this.body = body;
            }
            if (expressionBody != null)
            {
                this.AdjustFlagsAndWidth(expressionBody);
                this.expressionBody = expressionBody;
            }
            if (semicolonToken != null)
            {
                this.AdjustFlagsAndWidth(semicolonToken);
                this.semicolonToken = semicolonToken;
            }
        }

        internal LocalFunctionStatementSyntax(SyntaxKind kind, GreenNode? attributeLists, GreenNode? modifiers, TypeSyntax returnType, SyntaxToken identifier, TypeParameterListSyntax? typeParameterList, ParameterListSyntax parameterList, GreenNode? constraintClauses, BlockSyntax? body, ArrowExpressionClauseSyntax? expressionBody, SyntaxToken? semicolonToken, SyntaxFactoryContext context)
          : base(kind)
        {
            this.SetFactoryContext(context);
            this.SlotCount = 10;
            if (attributeLists != null)
            {
                this.AdjustFlagsAndWidth(attributeLists);
                this.attributeLists = attributeLists;
            }
            if (modifiers != null)
            {
                this.AdjustFlagsAndWidth(modifiers);
                this.modifiers = modifiers;
            }
            this.AdjustFlagsAndWidth(returnType);
            this.returnType = returnType;
            this.AdjustFlagsAndWidth(identifier);
            this.identifier = identifier;
            if (typeParameterList != null)
            {
                this.AdjustFlagsAndWidth(typeParameterList);
                this.typeParameterList = typeParameterList;
            }
            this.AdjustFlagsAndWidth(parameterList);
            this.parameterList = parameterList;
            if (constraintClauses != null)
            {
                this.AdjustFlagsAndWidth(constraintClauses);
                this.constraintClauses = constraintClauses;
            }
            if (body != null)
            {
                this.AdjustFlagsAndWidth(body);
                this.body = body;
            }
            if (expressionBody != null)
            {
                this.AdjustFlagsAndWidth(expressionBody);
                this.expressionBody = expressionBody;
            }
            if (semicolonToken != null)
            {
                this.AdjustFlagsAndWidth(semicolonToken);
                this.semicolonToken = semicolonToken;
            }
        }

        internal LocalFunctionStatementSyntax(SyntaxKind kind, GreenNode? attributeLists, GreenNode? modifiers, TypeSyntax returnType, SyntaxToken identifier, TypeParameterListSyntax? typeParameterList, ParameterListSyntax parameterList, GreenNode? constraintClauses, BlockSyntax? body, ArrowExpressionClauseSyntax? expressionBody, SyntaxToken? semicolonToken)
          : base(kind)
        {
            this.SlotCount = 10;
            if (attributeLists != null)
            {
                this.AdjustFlagsAndWidth(attributeLists);
                this.attributeLists = attributeLists;
            }
            if (modifiers != null)
            {
                this.AdjustFlagsAndWidth(modifiers);
                this.modifiers = modifiers;
            }
            this.AdjustFlagsAndWidth(returnType);
            this.returnType = returnType;
            this.AdjustFlagsAndWidth(identifier);
            this.identifier = identifier;
            if (typeParameterList != null)
            {
                this.AdjustFlagsAndWidth(typeParameterList);
                this.typeParameterList = typeParameterList;
            }
            this.AdjustFlagsAndWidth(parameterList);
            this.parameterList = parameterList;
            if (constraintClauses != null)
            {
                this.AdjustFlagsAndWidth(constraintClauses);
                this.constraintClauses = constraintClauses;
            }
            if (body != null)
            {
                this.AdjustFlagsAndWidth(body);
                this.body = body;
            }
            if (expressionBody != null)
            {
                this.AdjustFlagsAndWidth(expressionBody);
                this.expressionBody = expressionBody;
            }
            if (semicolonToken != null)
            {
                this.AdjustFlagsAndWidth(semicolonToken);
                this.semicolonToken = semicolonToken;
            }
        }

        public override Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<AttributeListSyntax> AttributeLists => new Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<AttributeListSyntax>(this.attributeLists);
        public Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SyntaxToken> Modifiers => new Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SyntaxToken>(this.modifiers);
        public TypeSyntax ReturnType => this.returnType;
        /// <summary>Gets the identifier.</summary>
        public SyntaxToken Identifier => this.identifier;
        public TypeParameterListSyntax? TypeParameterList => this.typeParameterList;
        public ParameterListSyntax ParameterList => this.parameterList;
        public Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<TypeParameterConstraintClauseSyntax> ConstraintClauses => new Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<TypeParameterConstraintClauseSyntax>(this.constraintClauses);
        public BlockSyntax? Body => this.body;
        public ArrowExpressionClauseSyntax? ExpressionBody => this.expressionBody;
        /// <summary>Gets the optional semicolon token.</summary>
        public SyntaxToken? SemicolonToken => this.semicolonToken;

        internal override GreenNode? GetSlot(int index)
            => index switch
            {
                0 => this.attributeLists,
                1 => this.modifiers,
                2 => this.returnType,
                3 => this.identifier,
                4 => this.typeParameterList,
                5 => this.parameterList,
                6 => this.constraintClauses,
                7 => this.body,
                8 => this.expressionBody,
                9 => this.semicolonToken,
                _ => null,
            };

        internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new CSharp.Syntax.LocalFunctionStatementSyntax(this, parent, position);

        public override void Accept(CSharpSyntaxVisitor visitor) => visitor.VisitLocalFunctionStatement(this);
        public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor) => visitor.VisitLocalFunctionStatement(this);

        public LocalFunctionStatementSyntax Update(Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<AttributeListSyntax> attributeLists, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SyntaxToken> modifiers, TypeSyntax returnType, SyntaxToken identifier, TypeParameterListSyntax typeParameterList, ParameterListSyntax parameterList, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<TypeParameterConstraintClauseSyntax> constraintClauses, BlockSyntax body, ArrowExpressionClauseSyntax expressionBody, SyntaxToken semicolonToken)
        {
            if (attributeLists != this.AttributeLists || modifiers != this.Modifiers || returnType != this.ReturnType || identifier != this.Identifier || typeParameterList != this.TypeParameterList || parameterList != this.ParameterList || constraintClauses != this.ConstraintClauses || body != this.Body || expressionBody != this.ExpressionBody || semicolonToken != this.SemicolonToken)
            {
                var newNode = SyntaxFactory.LocalFunctionStatement(attributeLists, modifiers, returnType, identifier, typeParameterList, parameterList, constraintClauses, body, expressionBody, semicolonToken);
                var diags = GetDiagnostics();
                if (diags?.Length > 0)
                    newNode = newNode.WithDiagnosticsGreen(diags);
                var annotations = GetAnnotations();
                if (annotations?.Length > 0)
                    newNode = newNode.WithAnnotationsGreen(annotations);
                return newNode;
            }

            return this;
        }

        internal override GreenNode SetDiagnostics(DiagnosticInfo[]? diagnostics)
            => new LocalFunctionStatementSyntax(this.Kind, this.attributeLists, this.modifiers, this.returnType, this.identifier, this.typeParameterList, this.parameterList, this.constraintClauses, this.body, this.expressionBody, this.semicolonToken, diagnostics, GetAnnotations());

        internal override GreenNode SetAnnotations(SyntaxAnnotation[]? annotations)
            => new LocalFunctionStatementSyntax(this.Kind, this.attributeLists, this.modifiers, this.returnType, this.identifier, this.typeParameterList, this.parameterList, this.constraintClauses, this.body, this.expressionBody, this.semicolonToken, GetDiagnostics(), annotations);

        internal LocalFunctionStatementSyntax(ObjectReader reader)
          : base(reader)
        {
            this.SlotCount = 10;
            var attributeLists = (GreenNode?)reader.ReadValue();
            if (attributeLists != null)
            {
                AdjustFlagsAndWidth(attributeLists);
                this.attributeLists = attributeLists;
            }
            var modifiers = (GreenNode?)reader.ReadValue();
            if (modifiers != null)
            {
                AdjustFlagsAndWidth(modifiers);
                this.modifiers = modifiers;
            }
            var returnType = (TypeSyntax)reader.ReadValue();
            AdjustFlagsAndWidth(returnType);
            this.returnType = returnType;
            var identifier = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(identifier);
            this.identifier = identifier;
            var typeParameterList = (TypeParameterListSyntax?)reader.ReadValue();
            if (typeParameterList != null)
            {
                AdjustFlagsAndWidth(typeParameterList);
                this.typeParameterList = typeParameterList;
            }
            var parameterList = (ParameterListSyntax)reader.ReadValue();
            AdjustFlagsAndWidth(parameterList);
            this.parameterList = parameterList;
            var constraintClauses = (GreenNode?)reader.ReadValue();
            if (constraintClauses != null)
            {
                AdjustFlagsAndWidth(constraintClauses);
                this.constraintClauses = constraintClauses;
            }
            var body = (BlockSyntax?)reader.ReadValue();
            if (body != null)
            {
                AdjustFlagsAndWidth(body);
                this.body = body;
            }
            var expressionBody = (ArrowExpressionClauseSyntax?)reader.ReadValue();
            if (expressionBody != null)
            {
                AdjustFlagsAndWidth(expressionBody);
                this.expressionBody = expressionBody;
            }
            var semicolonToken = (SyntaxToken?)reader.ReadValue();
            if (semicolonToken != null)
            {
                AdjustFlagsAndWidth(semicolonToken);
                this.semicolonToken = semicolonToken;
            }
        }

        internal override void WriteTo(ObjectWriter writer)
        {
            base.WriteTo(writer);
            writer.WriteValue(this.attributeLists);
            writer.WriteValue(this.modifiers);
            writer.WriteValue(this.returnType);
            writer.WriteValue(this.identifier);
            writer.WriteValue(this.typeParameterList);
            writer.WriteValue(this.parameterList);
            writer.WriteValue(this.constraintClauses);
            writer.WriteValue(this.body);
            writer.WriteValue(this.expressionBody);
            writer.WriteValue(this.semicolonToken);
        }

        static LocalFunctionStatementSyntax()
        {
            ObjectBinder.RegisterTypeReader(typeof(LocalFunctionStatementSyntax), r => new LocalFunctionStatementSyntax(r));
        }
    }

    internal sealed partial class LocalDeclarationStatementSyntax : StatementSyntax
    {
        internal readonly GreenNode? attributeLists;
        internal readonly SyntaxToken? awaitKeyword;
        internal readonly SyntaxToken? usingKeyword;
        internal readonly GreenNode? modifiers;
        internal readonly VariableDeclarationSyntax declaration;
        internal readonly SyntaxToken semicolonToken;

        internal LocalDeclarationStatementSyntax(SyntaxKind kind, GreenNode? attributeLists, SyntaxToken? awaitKeyword, SyntaxToken? usingKeyword, GreenNode? modifiers, VariableDeclarationSyntax declaration, SyntaxToken semicolonToken, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
            this.SlotCount = 6;
            if (attributeLists != null)
            {
                this.AdjustFlagsAndWidth(attributeLists);
                this.attributeLists = attributeLists;
            }
            if (awaitKeyword != null)
            {
                this.AdjustFlagsAndWidth(awaitKeyword);
                this.awaitKeyword = awaitKeyword;
            }
            if (usingKeyword != null)
            {
                this.AdjustFlagsAndWidth(usingKeyword);
                this.usingKeyword = usingKeyword;
            }
            if (modifiers != null)
            {
                this.AdjustFlagsAndWidth(modifiers);
                this.modifiers = modifiers;
            }
            this.AdjustFlagsAndWidth(declaration);
            this.declaration = declaration;
            this.AdjustFlagsAndWidth(semicolonToken);
            this.semicolonToken = semicolonToken;
        }

        internal LocalDeclarationStatementSyntax(SyntaxKind kind, GreenNode? attributeLists, SyntaxToken? awaitKeyword, SyntaxToken? usingKeyword, GreenNode? modifiers, VariableDeclarationSyntax declaration, SyntaxToken semicolonToken, SyntaxFactoryContext context)
          : base(kind)
        {
            this.SetFactoryContext(context);
            this.SlotCount = 6;
            if (attributeLists != null)
            {
                this.AdjustFlagsAndWidth(attributeLists);
                this.attributeLists = attributeLists;
            }
            if (awaitKeyword != null)
            {
                this.AdjustFlagsAndWidth(awaitKeyword);
                this.awaitKeyword = awaitKeyword;
            }
            if (usingKeyword != null)
            {
                this.AdjustFlagsAndWidth(usingKeyword);
                this.usingKeyword = usingKeyword;
            }
            if (modifiers != null)
            {
                this.AdjustFlagsAndWidth(modifiers);
                this.modifiers = modifiers;
            }
            this.AdjustFlagsAndWidth(declaration);
            this.declaration = declaration;
            this.AdjustFlagsAndWidth(semicolonToken);
            this.semicolonToken = semicolonToken;
        }

        internal LocalDeclarationStatementSyntax(SyntaxKind kind, GreenNode? attributeLists, SyntaxToken? awaitKeyword, SyntaxToken? usingKeyword, GreenNode? modifiers, VariableDeclarationSyntax declaration, SyntaxToken semicolonToken)
          : base(kind)
        {
            this.SlotCount = 6;
            if (attributeLists != null)
            {
                this.AdjustFlagsAndWidth(attributeLists);
                this.attributeLists = attributeLists;
            }
            if (awaitKeyword != null)
            {
                this.AdjustFlagsAndWidth(awaitKeyword);
                this.awaitKeyword = awaitKeyword;
            }
            if (usingKeyword != null)
            {
                this.AdjustFlagsAndWidth(usingKeyword);
                this.usingKeyword = usingKeyword;
            }
            if (modifiers != null)
            {
                this.AdjustFlagsAndWidth(modifiers);
                this.modifiers = modifiers;
            }
            this.AdjustFlagsAndWidth(declaration);
            this.declaration = declaration;
            this.AdjustFlagsAndWidth(semicolonToken);
            this.semicolonToken = semicolonToken;
        }

        public override Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<AttributeListSyntax> AttributeLists => new Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<AttributeListSyntax>(this.attributeLists);
        public SyntaxToken? AwaitKeyword => this.awaitKeyword;
        public SyntaxToken? UsingKeyword => this.usingKeyword;
        /// <summary>Gets the modifier list.</summary>
        public Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SyntaxToken> Modifiers => new Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SyntaxToken>(this.modifiers);
        public VariableDeclarationSyntax Declaration => this.declaration;
        public SyntaxToken SemicolonToken => this.semicolonToken;

        internal override GreenNode? GetSlot(int index)
            => index switch
            {
                0 => this.attributeLists,
                1 => this.awaitKeyword,
                2 => this.usingKeyword,
                3 => this.modifiers,
                4 => this.declaration,
                5 => this.semicolonToken,
                _ => null,
            };

        internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new CSharp.Syntax.LocalDeclarationStatementSyntax(this, parent, position);

        public override void Accept(CSharpSyntaxVisitor visitor) => visitor.VisitLocalDeclarationStatement(this);
        public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor) => visitor.VisitLocalDeclarationStatement(this);

        public LocalDeclarationStatementSyntax Update(Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<AttributeListSyntax> attributeLists, SyntaxToken awaitKeyword, SyntaxToken usingKeyword, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SyntaxToken> modifiers, VariableDeclarationSyntax declaration, SyntaxToken semicolonToken)
        {
            if (attributeLists != this.AttributeLists || awaitKeyword != this.AwaitKeyword || usingKeyword != this.UsingKeyword || modifiers != this.Modifiers || declaration != this.Declaration || semicolonToken != this.SemicolonToken)
            {
                var newNode = SyntaxFactory.LocalDeclarationStatement(attributeLists, awaitKeyword, usingKeyword, modifiers, declaration, semicolonToken);
                var diags = GetDiagnostics();
                if (diags?.Length > 0)
                    newNode = newNode.WithDiagnosticsGreen(diags);
                var annotations = GetAnnotations();
                if (annotations?.Length > 0)
                    newNode = newNode.WithAnnotationsGreen(annotations);
                return newNode;
            }

            return this;
        }

        internal override GreenNode SetDiagnostics(DiagnosticInfo[]? diagnostics)
            => new LocalDeclarationStatementSyntax(this.Kind, this.attributeLists, this.awaitKeyword, this.usingKeyword, this.modifiers, this.declaration, this.semicolonToken, diagnostics, GetAnnotations());

        internal override GreenNode SetAnnotations(SyntaxAnnotation[]? annotations)
            => new LocalDeclarationStatementSyntax(this.Kind, this.attributeLists, this.awaitKeyword, this.usingKeyword, this.modifiers, this.declaration, this.semicolonToken, GetDiagnostics(), annotations);

        internal LocalDeclarationStatementSyntax(ObjectReader reader)
          : base(reader)
        {
            this.SlotCount = 6;
            var attributeLists = (GreenNode?)reader.ReadValue();
            if (attributeLists != null)
            {
                AdjustFlagsAndWidth(attributeLists);
                this.attributeLists = attributeLists;
            }
            var awaitKeyword = (SyntaxToken?)reader.ReadValue();
            if (awaitKeyword != null)
            {
                AdjustFlagsAndWidth(awaitKeyword);
                this.awaitKeyword = awaitKeyword;
            }
            var usingKeyword = (SyntaxToken?)reader.ReadValue();
            if (usingKeyword != null)
            {
                AdjustFlagsAndWidth(usingKeyword);
                this.usingKeyword = usingKeyword;
            }
            var modifiers = (GreenNode?)reader.ReadValue();
            if (modifiers != null)
            {
                AdjustFlagsAndWidth(modifiers);
                this.modifiers = modifiers;
            }
            var declaration = (VariableDeclarationSyntax)reader.ReadValue();
            AdjustFlagsAndWidth(declaration);
            this.declaration = declaration;
            var semicolonToken = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(semicolonToken);
            this.semicolonToken = semicolonToken;
        }

        internal override void WriteTo(ObjectWriter writer)
        {
            base.WriteTo(writer);
            writer.WriteValue(this.attributeLists);
            writer.WriteValue(this.awaitKeyword);
            writer.WriteValue(this.usingKeyword);
            writer.WriteValue(this.modifiers);
            writer.WriteValue(this.declaration);
            writer.WriteValue(this.semicolonToken);
        }

        static LocalDeclarationStatementSyntax()
        {
            ObjectBinder.RegisterTypeReader(typeof(LocalDeclarationStatementSyntax), r => new LocalDeclarationStatementSyntax(r));
        }
    }

    internal sealed partial class VariableDeclarationSyntax : CSharpSyntaxNode
    {
        internal readonly TypeSyntax type;
        internal readonly GreenNode? variables;

        internal VariableDeclarationSyntax(SyntaxKind kind, TypeSyntax type, GreenNode? variables, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
            this.SlotCount = 2;
            this.AdjustFlagsAndWidth(type);
            this.type = type;
            if (variables != null)
            {
                this.AdjustFlagsAndWidth(variables);
                this.variables = variables;
            }
        }

        internal VariableDeclarationSyntax(SyntaxKind kind, TypeSyntax type, GreenNode? variables, SyntaxFactoryContext context)
          : base(kind)
        {
            this.SetFactoryContext(context);
            this.SlotCount = 2;
            this.AdjustFlagsAndWidth(type);
            this.type = type;
            if (variables != null)
            {
                this.AdjustFlagsAndWidth(variables);
                this.variables = variables;
            }
        }

        internal VariableDeclarationSyntax(SyntaxKind kind, TypeSyntax type, GreenNode? variables)
          : base(kind)
        {
            this.SlotCount = 2;
            this.AdjustFlagsAndWidth(type);
            this.type = type;
            if (variables != null)
            {
                this.AdjustFlagsAndWidth(variables);
                this.variables = variables;
            }
        }

        public TypeSyntax Type => this.type;
        public Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<VariableDeclaratorSyntax> Variables => new Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<VariableDeclaratorSyntax>(new Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<CSharpSyntaxNode>(this.variables));

        internal override GreenNode? GetSlot(int index)
            => index switch
            {
                0 => this.type,
                1 => this.variables,
                _ => null,
            };

        internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new CSharp.Syntax.VariableDeclarationSyntax(this, parent, position);

        public override void Accept(CSharpSyntaxVisitor visitor) => visitor.VisitVariableDeclaration(this);
        public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor) => visitor.VisitVariableDeclaration(this);

        public VariableDeclarationSyntax Update(TypeSyntax type, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<VariableDeclaratorSyntax> variables)
        {
            if (type != this.Type || variables != this.Variables)
            {
                var newNode = SyntaxFactory.VariableDeclaration(type, variables);
                var diags = GetDiagnostics();
                if (diags?.Length > 0)
                    newNode = newNode.WithDiagnosticsGreen(diags);
                var annotations = GetAnnotations();
                if (annotations?.Length > 0)
                    newNode = newNode.WithAnnotationsGreen(annotations);
                return newNode;
            }

            return this;
        }

        internal override GreenNode SetDiagnostics(DiagnosticInfo[]? diagnostics)
            => new VariableDeclarationSyntax(this.Kind, this.type, this.variables, diagnostics, GetAnnotations());

        internal override GreenNode SetAnnotations(SyntaxAnnotation[]? annotations)
            => new VariableDeclarationSyntax(this.Kind, this.type, this.variables, GetDiagnostics(), annotations);

        internal VariableDeclarationSyntax(ObjectReader reader)
          : base(reader)
        {
            this.SlotCount = 2;
            var type = (TypeSyntax)reader.ReadValue();
            AdjustFlagsAndWidth(type);
            this.type = type;
            var variables = (GreenNode?)reader.ReadValue();
            if (variables != null)
            {
                AdjustFlagsAndWidth(variables);
                this.variables = variables;
            }
        }

        internal override void WriteTo(ObjectWriter writer)
        {
            base.WriteTo(writer);
            writer.WriteValue(this.type);
            writer.WriteValue(this.variables);
        }

        static VariableDeclarationSyntax()
        {
            ObjectBinder.RegisterTypeReader(typeof(VariableDeclarationSyntax), r => new VariableDeclarationSyntax(r));
        }
    }

    internal sealed partial class VariableDeclaratorSyntax : CSharpSyntaxNode
    {
        internal readonly SyntaxToken identifier;
        internal readonly BracketedArgumentListSyntax? argumentList;
        internal readonly EqualsValueClauseSyntax? initializer;

        internal VariableDeclaratorSyntax(SyntaxKind kind, SyntaxToken identifier, BracketedArgumentListSyntax? argumentList, EqualsValueClauseSyntax? initializer, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
            this.SlotCount = 3;
            this.AdjustFlagsAndWidth(identifier);
            this.identifier = identifier;
            if (argumentList != null)
            {
                this.AdjustFlagsAndWidth(argumentList);
                this.argumentList = argumentList;
            }
            if (initializer != null)
            {
                this.AdjustFlagsAndWidth(initializer);
                this.initializer = initializer;
            }
        }

        internal VariableDeclaratorSyntax(SyntaxKind kind, SyntaxToken identifier, BracketedArgumentListSyntax? argumentList, EqualsValueClauseSyntax? initializer, SyntaxFactoryContext context)
          : base(kind)
        {
            this.SetFactoryContext(context);
            this.SlotCount = 3;
            this.AdjustFlagsAndWidth(identifier);
            this.identifier = identifier;
            if (argumentList != null)
            {
                this.AdjustFlagsAndWidth(argumentList);
                this.argumentList = argumentList;
            }
            if (initializer != null)
            {
                this.AdjustFlagsAndWidth(initializer);
                this.initializer = initializer;
            }
        }

        internal VariableDeclaratorSyntax(SyntaxKind kind, SyntaxToken identifier, BracketedArgumentListSyntax? argumentList, EqualsValueClauseSyntax? initializer)
          : base(kind)
        {
            this.SlotCount = 3;
            this.AdjustFlagsAndWidth(identifier);
            this.identifier = identifier;
            if (argumentList != null)
            {
                this.AdjustFlagsAndWidth(argumentList);
                this.argumentList = argumentList;
            }
            if (initializer != null)
            {
                this.AdjustFlagsAndWidth(initializer);
                this.initializer = initializer;
            }
        }

        /// <summary>Gets the identifier.</summary>
        public SyntaxToken Identifier => this.identifier;
        public BracketedArgumentListSyntax? ArgumentList => this.argumentList;
        public EqualsValueClauseSyntax? Initializer => this.initializer;

        internal override GreenNode? GetSlot(int index)
            => index switch
            {
                0 => this.identifier,
                1 => this.argumentList,
                2 => this.initializer,
                _ => null,
            };

        internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new CSharp.Syntax.VariableDeclaratorSyntax(this, parent, position);

        public override void Accept(CSharpSyntaxVisitor visitor) => visitor.VisitVariableDeclarator(this);
        public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor) => visitor.VisitVariableDeclarator(this);

        public VariableDeclaratorSyntax Update(SyntaxToken identifier, BracketedArgumentListSyntax argumentList, EqualsValueClauseSyntax initializer)
        {
            if (identifier != this.Identifier || argumentList != this.ArgumentList || initializer != this.Initializer)
            {
                var newNode = SyntaxFactory.VariableDeclarator(identifier, argumentList, initializer);
                var diags = GetDiagnostics();
                if (diags?.Length > 0)
                    newNode = newNode.WithDiagnosticsGreen(diags);
                var annotations = GetAnnotations();
                if (annotations?.Length > 0)
                    newNode = newNode.WithAnnotationsGreen(annotations);
                return newNode;
            }

            return this;
        }

        internal override GreenNode SetDiagnostics(DiagnosticInfo[]? diagnostics)
            => new VariableDeclaratorSyntax(this.Kind, this.identifier, this.argumentList, this.initializer, diagnostics, GetAnnotations());

        internal override GreenNode SetAnnotations(SyntaxAnnotation[]? annotations)
            => new VariableDeclaratorSyntax(this.Kind, this.identifier, this.argumentList, this.initializer, GetDiagnostics(), annotations);

        internal VariableDeclaratorSyntax(ObjectReader reader)
          : base(reader)
        {
            this.SlotCount = 3;
            var identifier = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(identifier);
            this.identifier = identifier;
            var argumentList = (BracketedArgumentListSyntax?)reader.ReadValue();
            if (argumentList != null)
            {
                AdjustFlagsAndWidth(argumentList);
                this.argumentList = argumentList;
            }
            var initializer = (EqualsValueClauseSyntax?)reader.ReadValue();
            if (initializer != null)
            {
                AdjustFlagsAndWidth(initializer);
                this.initializer = initializer;
            }
        }

        internal override void WriteTo(ObjectWriter writer)
        {
            base.WriteTo(writer);
            writer.WriteValue(this.identifier);
            writer.WriteValue(this.argumentList);
            writer.WriteValue(this.initializer);
        }

        static VariableDeclaratorSyntax()
        {
            ObjectBinder.RegisterTypeReader(typeof(VariableDeclaratorSyntax), r => new VariableDeclaratorSyntax(r));
        }
    }

    internal sealed partial class EqualsValueClauseSyntax : CSharpSyntaxNode
    {
        internal readonly SyntaxToken equalsToken;
        internal readonly ExpressionSyntax value;

        internal EqualsValueClauseSyntax(SyntaxKind kind, SyntaxToken equalsToken, ExpressionSyntax value, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
            this.SlotCount = 2;
            this.AdjustFlagsAndWidth(equalsToken);
            this.equalsToken = equalsToken;
            this.AdjustFlagsAndWidth(value);
            this.value = value;
        }

        internal EqualsValueClauseSyntax(SyntaxKind kind, SyntaxToken equalsToken, ExpressionSyntax value, SyntaxFactoryContext context)
          : base(kind)
        {
            this.SetFactoryContext(context);
            this.SlotCount = 2;
            this.AdjustFlagsAndWidth(equalsToken);
            this.equalsToken = equalsToken;
            this.AdjustFlagsAndWidth(value);
            this.value = value;
        }

        internal EqualsValueClauseSyntax(SyntaxKind kind, SyntaxToken equalsToken, ExpressionSyntax value)
          : base(kind)
        {
            this.SlotCount = 2;
            this.AdjustFlagsAndWidth(equalsToken);
            this.equalsToken = equalsToken;
            this.AdjustFlagsAndWidth(value);
            this.value = value;
        }

        public SyntaxToken EqualsToken => this.equalsToken;
        public ExpressionSyntax Value => this.value;

        internal override GreenNode? GetSlot(int index)
            => index switch
            {
                0 => this.equalsToken,
                1 => this.value,
                _ => null,
            };

        internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new CSharp.Syntax.EqualsValueClauseSyntax(this, parent, position);

        public override void Accept(CSharpSyntaxVisitor visitor) => visitor.VisitEqualsValueClause(this);
        public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor) => visitor.VisitEqualsValueClause(this);

        public EqualsValueClauseSyntax Update(SyntaxToken equalsToken, ExpressionSyntax value)
        {
            if (equalsToken != this.EqualsToken || value != this.Value)
            {
                var newNode = SyntaxFactory.EqualsValueClause(equalsToken, value);
                var diags = GetDiagnostics();
                if (diags?.Length > 0)
                    newNode = newNode.WithDiagnosticsGreen(diags);
                var annotations = GetAnnotations();
                if (annotations?.Length > 0)
                    newNode = newNode.WithAnnotationsGreen(annotations);
                return newNode;
            }

            return this;
        }

        internal override GreenNode SetDiagnostics(DiagnosticInfo[]? diagnostics)
            => new EqualsValueClauseSyntax(this.Kind, this.equalsToken, this.value, diagnostics, GetAnnotations());

        internal override GreenNode SetAnnotations(SyntaxAnnotation[]? annotations)
            => new EqualsValueClauseSyntax(this.Kind, this.equalsToken, this.value, GetDiagnostics(), annotations);

        internal EqualsValueClauseSyntax(ObjectReader reader)
          : base(reader)
        {
            this.SlotCount = 2;
            var equalsToken = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(equalsToken);
            this.equalsToken = equalsToken;
            var value = (ExpressionSyntax)reader.ReadValue();
            AdjustFlagsAndWidth(value);
            this.value = value;
        }

        internal override void WriteTo(ObjectWriter writer)
        {
            base.WriteTo(writer);
            writer.WriteValue(this.equalsToken);
            writer.WriteValue(this.value);
        }

        static EqualsValueClauseSyntax()
        {
            ObjectBinder.RegisterTypeReader(typeof(EqualsValueClauseSyntax), r => new EqualsValueClauseSyntax(r));
        }
    }

    internal abstract partial class VariableDesignationSyntax : CSharpSyntaxNode
    {
        internal VariableDesignationSyntax(SyntaxKind kind, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
        }

        internal VariableDesignationSyntax(SyntaxKind kind)
          : base(kind)
        {
        }

        protected VariableDesignationSyntax(ObjectReader reader)
          : base(reader)
        {
        }
    }

    internal sealed partial class SingleVariableDesignationSyntax : VariableDesignationSyntax
    {
        internal readonly SyntaxToken identifier;

        internal SingleVariableDesignationSyntax(SyntaxKind kind, SyntaxToken identifier, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
            this.SlotCount = 1;
            this.AdjustFlagsAndWidth(identifier);
            this.identifier = identifier;
        }

        internal SingleVariableDesignationSyntax(SyntaxKind kind, SyntaxToken identifier, SyntaxFactoryContext context)
          : base(kind)
        {
            this.SetFactoryContext(context);
            this.SlotCount = 1;
            this.AdjustFlagsAndWidth(identifier);
            this.identifier = identifier;
        }

        internal SingleVariableDesignationSyntax(SyntaxKind kind, SyntaxToken identifier)
          : base(kind)
        {
            this.SlotCount = 1;
            this.AdjustFlagsAndWidth(identifier);
            this.identifier = identifier;
        }

        public SyntaxToken Identifier => this.identifier;

        internal override GreenNode? GetSlot(int index)
            => index == 0 ? this.identifier : null;

        internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new CSharp.Syntax.SingleVariableDesignationSyntax(this, parent, position);

        public override void Accept(CSharpSyntaxVisitor visitor) => visitor.VisitSingleVariableDesignation(this);
        public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor) => visitor.VisitSingleVariableDesignation(this);

        public SingleVariableDesignationSyntax Update(SyntaxToken identifier)
        {
            if (identifier != this.Identifier)
            {
                var newNode = SyntaxFactory.SingleVariableDesignation(identifier);
                var diags = GetDiagnostics();
                if (diags?.Length > 0)
                    newNode = newNode.WithDiagnosticsGreen(diags);
                var annotations = GetAnnotations();
                if (annotations?.Length > 0)
                    newNode = newNode.WithAnnotationsGreen(annotations);
                return newNode;
            }

            return this;
        }

        internal override GreenNode SetDiagnostics(DiagnosticInfo[]? diagnostics)
            => new SingleVariableDesignationSyntax(this.Kind, this.identifier, diagnostics, GetAnnotations());

        internal override GreenNode SetAnnotations(SyntaxAnnotation[]? annotations)
            => new SingleVariableDesignationSyntax(this.Kind, this.identifier, GetDiagnostics(), annotations);

        internal SingleVariableDesignationSyntax(ObjectReader reader)
          : base(reader)
        {
            this.SlotCount = 1;
            var identifier = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(identifier);
            this.identifier = identifier;
        }

        internal override void WriteTo(ObjectWriter writer)
        {
            base.WriteTo(writer);
            writer.WriteValue(this.identifier);
        }

        static SingleVariableDesignationSyntax()
        {
            ObjectBinder.RegisterTypeReader(typeof(SingleVariableDesignationSyntax), r => new SingleVariableDesignationSyntax(r));
        }
    }

    internal sealed partial class DiscardDesignationSyntax : VariableDesignationSyntax
    {
        internal readonly SyntaxToken underscoreToken;

        internal DiscardDesignationSyntax(SyntaxKind kind, SyntaxToken underscoreToken, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
            this.SlotCount = 1;
            this.AdjustFlagsAndWidth(underscoreToken);
            this.underscoreToken = underscoreToken;
        }

        internal DiscardDesignationSyntax(SyntaxKind kind, SyntaxToken underscoreToken, SyntaxFactoryContext context)
          : base(kind)
        {
            this.SetFactoryContext(context);
            this.SlotCount = 1;
            this.AdjustFlagsAndWidth(underscoreToken);
            this.underscoreToken = underscoreToken;
        }

        internal DiscardDesignationSyntax(SyntaxKind kind, SyntaxToken underscoreToken)
          : base(kind)
        {
            this.SlotCount = 1;
            this.AdjustFlagsAndWidth(underscoreToken);
            this.underscoreToken = underscoreToken;
        }

        public SyntaxToken UnderscoreToken => this.underscoreToken;

        internal override GreenNode? GetSlot(int index)
            => index == 0 ? this.underscoreToken : null;

        internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new CSharp.Syntax.DiscardDesignationSyntax(this, parent, position);

        public override void Accept(CSharpSyntaxVisitor visitor) => visitor.VisitDiscardDesignation(this);
        public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor) => visitor.VisitDiscardDesignation(this);

        public DiscardDesignationSyntax Update(SyntaxToken underscoreToken)
        {
            if (underscoreToken != this.UnderscoreToken)
            {
                var newNode = SyntaxFactory.DiscardDesignation(underscoreToken);
                var diags = GetDiagnostics();
                if (diags?.Length > 0)
                    newNode = newNode.WithDiagnosticsGreen(diags);
                var annotations = GetAnnotations();
                if (annotations?.Length > 0)
                    newNode = newNode.WithAnnotationsGreen(annotations);
                return newNode;
            }

            return this;
        }

        internal override GreenNode SetDiagnostics(DiagnosticInfo[]? diagnostics)
            => new DiscardDesignationSyntax(this.Kind, this.underscoreToken, diagnostics, GetAnnotations());

        internal override GreenNode SetAnnotations(SyntaxAnnotation[]? annotations)
            => new DiscardDesignationSyntax(this.Kind, this.underscoreToken, GetDiagnostics(), annotations);

        internal DiscardDesignationSyntax(ObjectReader reader)
          : base(reader)
        {
            this.SlotCount = 1;
            var underscoreToken = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(underscoreToken);
            this.underscoreToken = underscoreToken;
        }

        internal override void WriteTo(ObjectWriter writer)
        {
            base.WriteTo(writer);
            writer.WriteValue(this.underscoreToken);
        }

        static DiscardDesignationSyntax()
        {
            ObjectBinder.RegisterTypeReader(typeof(DiscardDesignationSyntax), r => new DiscardDesignationSyntax(r));
        }
    }

    internal sealed partial class ParenthesizedVariableDesignationSyntax : VariableDesignationSyntax
    {
        internal readonly SyntaxToken openParenToken;
        internal readonly GreenNode? variables;
        internal readonly SyntaxToken closeParenToken;

        internal ParenthesizedVariableDesignationSyntax(SyntaxKind kind, SyntaxToken openParenToken, GreenNode? variables, SyntaxToken closeParenToken, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
            this.SlotCount = 3;
            this.AdjustFlagsAndWidth(openParenToken);
            this.openParenToken = openParenToken;
            if (variables != null)
            {
                this.AdjustFlagsAndWidth(variables);
                this.variables = variables;
            }
            this.AdjustFlagsAndWidth(closeParenToken);
            this.closeParenToken = closeParenToken;
        }

        internal ParenthesizedVariableDesignationSyntax(SyntaxKind kind, SyntaxToken openParenToken, GreenNode? variables, SyntaxToken closeParenToken, SyntaxFactoryContext context)
          : base(kind)
        {
            this.SetFactoryContext(context);
            this.SlotCount = 3;
            this.AdjustFlagsAndWidth(openParenToken);
            this.openParenToken = openParenToken;
            if (variables != null)
            {
                this.AdjustFlagsAndWidth(variables);
                this.variables = variables;
            }
            this.AdjustFlagsAndWidth(closeParenToken);
            this.closeParenToken = closeParenToken;
        }

        internal ParenthesizedVariableDesignationSyntax(SyntaxKind kind, SyntaxToken openParenToken, GreenNode? variables, SyntaxToken closeParenToken)
          : base(kind)
        {
            this.SlotCount = 3;
            this.AdjustFlagsAndWidth(openParenToken);
            this.openParenToken = openParenToken;
            if (variables != null)
            {
                this.AdjustFlagsAndWidth(variables);
                this.variables = variables;
            }
            this.AdjustFlagsAndWidth(closeParenToken);
            this.closeParenToken = closeParenToken;
        }

        public SyntaxToken OpenParenToken => this.openParenToken;
        public Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<VariableDesignationSyntax> Variables => new Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<VariableDesignationSyntax>(new Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<CSharpSyntaxNode>(this.variables));
        public SyntaxToken CloseParenToken => this.closeParenToken;

        internal override GreenNode? GetSlot(int index)
            => index switch
            {
                0 => this.openParenToken,
                1 => this.variables,
                2 => this.closeParenToken,
                _ => null,
            };

        internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new CSharp.Syntax.ParenthesizedVariableDesignationSyntax(this, parent, position);

        public override void Accept(CSharpSyntaxVisitor visitor) => visitor.VisitParenthesizedVariableDesignation(this);
        public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor) => visitor.VisitParenthesizedVariableDesignation(this);

        public ParenthesizedVariableDesignationSyntax Update(SyntaxToken openParenToken, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<VariableDesignationSyntax> variables, SyntaxToken closeParenToken)
        {
            if (openParenToken != this.OpenParenToken || variables != this.Variables || closeParenToken != this.CloseParenToken)
            {
                var newNode = SyntaxFactory.ParenthesizedVariableDesignation(openParenToken, variables, closeParenToken);
                var diags = GetDiagnostics();
                if (diags?.Length > 0)
                    newNode = newNode.WithDiagnosticsGreen(diags);
                var annotations = GetAnnotations();
                if (annotations?.Length > 0)
                    newNode = newNode.WithAnnotationsGreen(annotations);
                return newNode;
            }

            return this;
        }

        internal override GreenNode SetDiagnostics(DiagnosticInfo[]? diagnostics)
            => new ParenthesizedVariableDesignationSyntax(this.Kind, this.openParenToken, this.variables, this.closeParenToken, diagnostics, GetAnnotations());

        internal override GreenNode SetAnnotations(SyntaxAnnotation[]? annotations)
            => new ParenthesizedVariableDesignationSyntax(this.Kind, this.openParenToken, this.variables, this.closeParenToken, GetDiagnostics(), annotations);

        internal ParenthesizedVariableDesignationSyntax(ObjectReader reader)
          : base(reader)
        {
            this.SlotCount = 3;
            var openParenToken = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(openParenToken);
            this.openParenToken = openParenToken;
            var variables = (GreenNode?)reader.ReadValue();
            if (variables != null)
            {
                AdjustFlagsAndWidth(variables);
                this.variables = variables;
            }
            var closeParenToken = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(closeParenToken);
            this.closeParenToken = closeParenToken;
        }

        internal override void WriteTo(ObjectWriter writer)
        {
            base.WriteTo(writer);
            writer.WriteValue(this.openParenToken);
            writer.WriteValue(this.variables);
            writer.WriteValue(this.closeParenToken);
        }

        static ParenthesizedVariableDesignationSyntax()
        {
            ObjectBinder.RegisterTypeReader(typeof(ParenthesizedVariableDesignationSyntax), r => new ParenthesizedVariableDesignationSyntax(r));
        }
    }

    internal sealed partial class ExpressionStatementSyntax : StatementSyntax
    {
        internal readonly GreenNode? attributeLists;
        internal readonly ExpressionSyntax expression;
        internal readonly SyntaxToken semicolonToken;

        internal ExpressionStatementSyntax(SyntaxKind kind, GreenNode? attributeLists, ExpressionSyntax expression, SyntaxToken semicolonToken, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
            this.SlotCount = 3;
            if (attributeLists != null)
            {
                this.AdjustFlagsAndWidth(attributeLists);
                this.attributeLists = attributeLists;
            }
            this.AdjustFlagsAndWidth(expression);
            this.expression = expression;
            this.AdjustFlagsAndWidth(semicolonToken);
            this.semicolonToken = semicolonToken;
        }

        internal ExpressionStatementSyntax(SyntaxKind kind, GreenNode? attributeLists, ExpressionSyntax expression, SyntaxToken semicolonToken, SyntaxFactoryContext context)
          : base(kind)
        {
            this.SetFactoryContext(context);
            this.SlotCount = 3;
            if (attributeLists != null)
            {
                this.AdjustFlagsAndWidth(attributeLists);
                this.attributeLists = attributeLists;
            }
            this.AdjustFlagsAndWidth(expression);
            this.expression = expression;
            this.AdjustFlagsAndWidth(semicolonToken);
            this.semicolonToken = semicolonToken;
        }

        internal ExpressionStatementSyntax(SyntaxKind kind, GreenNode? attributeLists, ExpressionSyntax expression, SyntaxToken semicolonToken)
          : base(kind)
        {
            this.SlotCount = 3;
            if (attributeLists != null)
            {
                this.AdjustFlagsAndWidth(attributeLists);
                this.attributeLists = attributeLists;
            }
            this.AdjustFlagsAndWidth(expression);
            this.expression = expression;
            this.AdjustFlagsAndWidth(semicolonToken);
            this.semicolonToken = semicolonToken;
        }

        public override Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<AttributeListSyntax> AttributeLists => new Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<AttributeListSyntax>(this.attributeLists);
        public ExpressionSyntax Expression => this.expression;
        public SyntaxToken SemicolonToken => this.semicolonToken;

        internal override GreenNode? GetSlot(int index)
            => index switch
            {
                0 => this.attributeLists,
                1 => this.expression,
                2 => this.semicolonToken,
                _ => null,
            };

        internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new CSharp.Syntax.ExpressionStatementSyntax(this, parent, position);

        public override void Accept(CSharpSyntaxVisitor visitor) => visitor.VisitExpressionStatement(this);
        public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor) => visitor.VisitExpressionStatement(this);

        public ExpressionStatementSyntax Update(Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<AttributeListSyntax> attributeLists, ExpressionSyntax expression, SyntaxToken semicolonToken)
        {
            if (attributeLists != this.AttributeLists || expression != this.Expression || semicolonToken != this.SemicolonToken)
            {
                var newNode = SyntaxFactory.ExpressionStatement(attributeLists, expression, semicolonToken);
                var diags = GetDiagnostics();
                if (diags?.Length > 0)
                    newNode = newNode.WithDiagnosticsGreen(diags);
                var annotations = GetAnnotations();
                if (annotations?.Length > 0)
                    newNode = newNode.WithAnnotationsGreen(annotations);
                return newNode;
            }

            return this;
        }

        internal override GreenNode SetDiagnostics(DiagnosticInfo[]? diagnostics)
            => new ExpressionStatementSyntax(this.Kind, this.attributeLists, this.expression, this.semicolonToken, diagnostics, GetAnnotations());

        internal override GreenNode SetAnnotations(SyntaxAnnotation[]? annotations)
            => new ExpressionStatementSyntax(this.Kind, this.attributeLists, this.expression, this.semicolonToken, GetDiagnostics(), annotations);

        internal ExpressionStatementSyntax(ObjectReader reader)
          : base(reader)
        {
            this.SlotCount = 3;
            var attributeLists = (GreenNode?)reader.ReadValue();
            if (attributeLists != null)
            {
                AdjustFlagsAndWidth(attributeLists);
                this.attributeLists = attributeLists;
            }
            var expression = (ExpressionSyntax)reader.ReadValue();
            AdjustFlagsAndWidth(expression);
            this.expression = expression;
            var semicolonToken = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(semicolonToken);
            this.semicolonToken = semicolonToken;
        }

        internal override void WriteTo(ObjectWriter writer)
        {
            base.WriteTo(writer);
            writer.WriteValue(this.attributeLists);
            writer.WriteValue(this.expression);
            writer.WriteValue(this.semicolonToken);
        }

        static ExpressionStatementSyntax()
        {
            ObjectBinder.RegisterTypeReader(typeof(ExpressionStatementSyntax), r => new ExpressionStatementSyntax(r));
        }
    }

    internal sealed partial class EmptyStatementSyntax : StatementSyntax
    {
        internal readonly GreenNode? attributeLists;
        internal readonly SyntaxToken semicolonToken;

        internal EmptyStatementSyntax(SyntaxKind kind, GreenNode? attributeLists, SyntaxToken semicolonToken, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
            this.SlotCount = 2;
            if (attributeLists != null)
            {
                this.AdjustFlagsAndWidth(attributeLists);
                this.attributeLists = attributeLists;
            }
            this.AdjustFlagsAndWidth(semicolonToken);
            this.semicolonToken = semicolonToken;
        }

        internal EmptyStatementSyntax(SyntaxKind kind, GreenNode? attributeLists, SyntaxToken semicolonToken, SyntaxFactoryContext context)
          : base(kind)
        {
            this.SetFactoryContext(context);
            this.SlotCount = 2;
            if (attributeLists != null)
            {
                this.AdjustFlagsAndWidth(attributeLists);
                this.attributeLists = attributeLists;
            }
            this.AdjustFlagsAndWidth(semicolonToken);
            this.semicolonToken = semicolonToken;
        }

        internal EmptyStatementSyntax(SyntaxKind kind, GreenNode? attributeLists, SyntaxToken semicolonToken)
          : base(kind)
        {
            this.SlotCount = 2;
            if (attributeLists != null)
            {
                this.AdjustFlagsAndWidth(attributeLists);
                this.attributeLists = attributeLists;
            }
            this.AdjustFlagsAndWidth(semicolonToken);
            this.semicolonToken = semicolonToken;
        }

        public override Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<AttributeListSyntax> AttributeLists => new Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<AttributeListSyntax>(this.attributeLists);
        public SyntaxToken SemicolonToken => this.semicolonToken;

        internal override GreenNode? GetSlot(int index)
            => index switch
            {
                0 => this.attributeLists,
                1 => this.semicolonToken,
                _ => null,
            };

        internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new CSharp.Syntax.EmptyStatementSyntax(this, parent, position);

        public override void Accept(CSharpSyntaxVisitor visitor) => visitor.VisitEmptyStatement(this);
        public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor) => visitor.VisitEmptyStatement(this);

        public EmptyStatementSyntax Update(Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<AttributeListSyntax> attributeLists, SyntaxToken semicolonToken)
        {
            if (attributeLists != this.AttributeLists || semicolonToken != this.SemicolonToken)
            {
                var newNode = SyntaxFactory.EmptyStatement(attributeLists, semicolonToken);
                var diags = GetDiagnostics();
                if (diags?.Length > 0)
                    newNode = newNode.WithDiagnosticsGreen(diags);
                var annotations = GetAnnotations();
                if (annotations?.Length > 0)
                    newNode = newNode.WithAnnotationsGreen(annotations);
                return newNode;
            }

            return this;
        }

        internal override GreenNode SetDiagnostics(DiagnosticInfo[]? diagnostics)
            => new EmptyStatementSyntax(this.Kind, this.attributeLists, this.semicolonToken, diagnostics, GetAnnotations());

        internal override GreenNode SetAnnotations(SyntaxAnnotation[]? annotations)
            => new EmptyStatementSyntax(this.Kind, this.attributeLists, this.semicolonToken, GetDiagnostics(), annotations);

        internal EmptyStatementSyntax(ObjectReader reader)
          : base(reader)
        {
            this.SlotCount = 2;
            var attributeLists = (GreenNode?)reader.ReadValue();
            if (attributeLists != null)
            {
                AdjustFlagsAndWidth(attributeLists);
                this.attributeLists = attributeLists;
            }
            var semicolonToken = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(semicolonToken);
            this.semicolonToken = semicolonToken;
        }

        internal override void WriteTo(ObjectWriter writer)
        {
            base.WriteTo(writer);
            writer.WriteValue(this.attributeLists);
            writer.WriteValue(this.semicolonToken);
        }

        static EmptyStatementSyntax()
        {
            ObjectBinder.RegisterTypeReader(typeof(EmptyStatementSyntax), r => new EmptyStatementSyntax(r));
        }
    }

    /// <summary>Represents a labeled statement syntax.</summary>
    internal sealed partial class LabeledStatementSyntax : StatementSyntax
    {
        internal readonly GreenNode? attributeLists;
        internal readonly SyntaxToken identifier;
        internal readonly SyntaxToken colonToken;
        internal readonly StatementSyntax statement;

        internal LabeledStatementSyntax(SyntaxKind kind, GreenNode? attributeLists, SyntaxToken identifier, SyntaxToken colonToken, StatementSyntax statement, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
            this.SlotCount = 4;
            if (attributeLists != null)
            {
                this.AdjustFlagsAndWidth(attributeLists);
                this.attributeLists = attributeLists;
            }
            this.AdjustFlagsAndWidth(identifier);
            this.identifier = identifier;
            this.AdjustFlagsAndWidth(colonToken);
            this.colonToken = colonToken;
            this.AdjustFlagsAndWidth(statement);
            this.statement = statement;
        }

        internal LabeledStatementSyntax(SyntaxKind kind, GreenNode? attributeLists, SyntaxToken identifier, SyntaxToken colonToken, StatementSyntax statement, SyntaxFactoryContext context)
          : base(kind)
        {
            this.SetFactoryContext(context);
            this.SlotCount = 4;
            if (attributeLists != null)
            {
                this.AdjustFlagsAndWidth(attributeLists);
                this.attributeLists = attributeLists;
            }
            this.AdjustFlagsAndWidth(identifier);
            this.identifier = identifier;
            this.AdjustFlagsAndWidth(colonToken);
            this.colonToken = colonToken;
            this.AdjustFlagsAndWidth(statement);
            this.statement = statement;
        }

        internal LabeledStatementSyntax(SyntaxKind kind, GreenNode? attributeLists, SyntaxToken identifier, SyntaxToken colonToken, StatementSyntax statement)
          : base(kind)
        {
            this.SlotCount = 4;
            if (attributeLists != null)
            {
                this.AdjustFlagsAndWidth(attributeLists);
                this.attributeLists = attributeLists;
            }
            this.AdjustFlagsAndWidth(identifier);
            this.identifier = identifier;
            this.AdjustFlagsAndWidth(colonToken);
            this.colonToken = colonToken;
            this.AdjustFlagsAndWidth(statement);
            this.statement = statement;
        }

        public override Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<AttributeListSyntax> AttributeLists => new Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<AttributeListSyntax>(this.attributeLists);
        /// <summary>Gets the identifier.</summary>
        public SyntaxToken Identifier => this.identifier;
        /// <summary>Gets a SyntaxToken that represents the colon following the statement's label.</summary>
        public SyntaxToken ColonToken => this.colonToken;
        public StatementSyntax Statement => this.statement;

        internal override GreenNode? GetSlot(int index)
            => index switch
            {
                0 => this.attributeLists,
                1 => this.identifier,
                2 => this.colonToken,
                3 => this.statement,
                _ => null,
            };

        internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new CSharp.Syntax.LabeledStatementSyntax(this, parent, position);

        public override void Accept(CSharpSyntaxVisitor visitor) => visitor.VisitLabeledStatement(this);
        public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor) => visitor.VisitLabeledStatement(this);

        public LabeledStatementSyntax Update(Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<AttributeListSyntax> attributeLists, SyntaxToken identifier, SyntaxToken colonToken, StatementSyntax statement)
        {
            if (attributeLists != this.AttributeLists || identifier != this.Identifier || colonToken != this.ColonToken || statement != this.Statement)
            {
                var newNode = SyntaxFactory.LabeledStatement(attributeLists, identifier, colonToken, statement);
                var diags = GetDiagnostics();
                if (diags?.Length > 0)
                    newNode = newNode.WithDiagnosticsGreen(diags);
                var annotations = GetAnnotations();
                if (annotations?.Length > 0)
                    newNode = newNode.WithAnnotationsGreen(annotations);
                return newNode;
            }

            return this;
        }

        internal override GreenNode SetDiagnostics(DiagnosticInfo[]? diagnostics)
            => new LabeledStatementSyntax(this.Kind, this.attributeLists, this.identifier, this.colonToken, this.statement, diagnostics, GetAnnotations());

        internal override GreenNode SetAnnotations(SyntaxAnnotation[]? annotations)
            => new LabeledStatementSyntax(this.Kind, this.attributeLists, this.identifier, this.colonToken, this.statement, GetDiagnostics(), annotations);

        internal LabeledStatementSyntax(ObjectReader reader)
          : base(reader)
        {
            this.SlotCount = 4;
            var attributeLists = (GreenNode?)reader.ReadValue();
            if (attributeLists != null)
            {
                AdjustFlagsAndWidth(attributeLists);
                this.attributeLists = attributeLists;
            }
            var identifier = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(identifier);
            this.identifier = identifier;
            var colonToken = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(colonToken);
            this.colonToken = colonToken;
            var statement = (StatementSyntax)reader.ReadValue();
            AdjustFlagsAndWidth(statement);
            this.statement = statement;
        }

        internal override void WriteTo(ObjectWriter writer)
        {
            base.WriteTo(writer);
            writer.WriteValue(this.attributeLists);
            writer.WriteValue(this.identifier);
            writer.WriteValue(this.colonToken);
            writer.WriteValue(this.statement);
        }

        static LabeledStatementSyntax()
        {
            ObjectBinder.RegisterTypeReader(typeof(LabeledStatementSyntax), r => new LabeledStatementSyntax(r));
        }
    }

    /// <summary>
    /// Represents a goto statement syntax
    /// </summary>
    internal sealed partial class GotoStatementSyntax : StatementSyntax
    {
        internal readonly GreenNode? attributeLists;
        internal readonly SyntaxToken gotoKeyword;
        internal readonly SyntaxToken? caseOrDefaultKeyword;
        internal readonly ExpressionSyntax? expression;
        internal readonly SyntaxToken semicolonToken;

        internal GotoStatementSyntax(SyntaxKind kind, GreenNode? attributeLists, SyntaxToken gotoKeyword, SyntaxToken? caseOrDefaultKeyword, ExpressionSyntax? expression, SyntaxToken semicolonToken, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
            this.SlotCount = 5;
            if (attributeLists != null)
            {
                this.AdjustFlagsAndWidth(attributeLists);
                this.attributeLists = attributeLists;
            }
            this.AdjustFlagsAndWidth(gotoKeyword);
            this.gotoKeyword = gotoKeyword;
            if (caseOrDefaultKeyword != null)
            {
                this.AdjustFlagsAndWidth(caseOrDefaultKeyword);
                this.caseOrDefaultKeyword = caseOrDefaultKeyword;
            }
            if (expression != null)
            {
                this.AdjustFlagsAndWidth(expression);
                this.expression = expression;
            }
            this.AdjustFlagsAndWidth(semicolonToken);
            this.semicolonToken = semicolonToken;
        }

        internal GotoStatementSyntax(SyntaxKind kind, GreenNode? attributeLists, SyntaxToken gotoKeyword, SyntaxToken? caseOrDefaultKeyword, ExpressionSyntax? expression, SyntaxToken semicolonToken, SyntaxFactoryContext context)
          : base(kind)
        {
            this.SetFactoryContext(context);
            this.SlotCount = 5;
            if (attributeLists != null)
            {
                this.AdjustFlagsAndWidth(attributeLists);
                this.attributeLists = attributeLists;
            }
            this.AdjustFlagsAndWidth(gotoKeyword);
            this.gotoKeyword = gotoKeyword;
            if (caseOrDefaultKeyword != null)
            {
                this.AdjustFlagsAndWidth(caseOrDefaultKeyword);
                this.caseOrDefaultKeyword = caseOrDefaultKeyword;
            }
            if (expression != null)
            {
                this.AdjustFlagsAndWidth(expression);
                this.expression = expression;
            }
            this.AdjustFlagsAndWidth(semicolonToken);
            this.semicolonToken = semicolonToken;
        }

        internal GotoStatementSyntax(SyntaxKind kind, GreenNode? attributeLists, SyntaxToken gotoKeyword, SyntaxToken? caseOrDefaultKeyword, ExpressionSyntax? expression, SyntaxToken semicolonToken)
          : base(kind)
        {
            this.SlotCount = 5;
            if (attributeLists != null)
            {
                this.AdjustFlagsAndWidth(attributeLists);
                this.attributeLists = attributeLists;
            }
            this.AdjustFlagsAndWidth(gotoKeyword);
            this.gotoKeyword = gotoKeyword;
            if (caseOrDefaultKeyword != null)
            {
                this.AdjustFlagsAndWidth(caseOrDefaultKeyword);
                this.caseOrDefaultKeyword = caseOrDefaultKeyword;
            }
            if (expression != null)
            {
                this.AdjustFlagsAndWidth(expression);
                this.expression = expression;
            }
            this.AdjustFlagsAndWidth(semicolonToken);
            this.semicolonToken = semicolonToken;
        }

        public override Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<AttributeListSyntax> AttributeLists => new Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<AttributeListSyntax>(this.attributeLists);
        /// <summary>
        /// Gets a SyntaxToken that represents the goto keyword.
        /// </summary>
        public SyntaxToken GotoKeyword => this.gotoKeyword;
        /// <summary>
        /// Gets a SyntaxToken that represents the case or default keywords if any exists.
        /// </summary>
        public SyntaxToken? CaseOrDefaultKeyword => this.caseOrDefaultKeyword;
        /// <summary>
        /// Gets a constant expression for a goto case statement.
        /// </summary>
        public ExpressionSyntax? Expression => this.expression;
        /// <summary>
        /// Gets a SyntaxToken that represents the semi-colon at the end of the statement.
        /// </summary>
        public SyntaxToken SemicolonToken => this.semicolonToken;

        internal override GreenNode? GetSlot(int index)
            => index switch
            {
                0 => this.attributeLists,
                1 => this.gotoKeyword,
                2 => this.caseOrDefaultKeyword,
                3 => this.expression,
                4 => this.semicolonToken,
                _ => null,
            };

        internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new CSharp.Syntax.GotoStatementSyntax(this, parent, position);

        public override void Accept(CSharpSyntaxVisitor visitor) => visitor.VisitGotoStatement(this);
        public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor) => visitor.VisitGotoStatement(this);

        public GotoStatementSyntax Update(Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<AttributeListSyntax> attributeLists, SyntaxToken gotoKeyword, SyntaxToken caseOrDefaultKeyword, ExpressionSyntax expression, SyntaxToken semicolonToken)
        {
            if (attributeLists != this.AttributeLists || gotoKeyword != this.GotoKeyword || caseOrDefaultKeyword != this.CaseOrDefaultKeyword || expression != this.Expression || semicolonToken != this.SemicolonToken)
            {
                var newNode = SyntaxFactory.GotoStatement(this.Kind, attributeLists, gotoKeyword, caseOrDefaultKeyword, expression, semicolonToken);
                var diags = GetDiagnostics();
                if (diags?.Length > 0)
                    newNode = newNode.WithDiagnosticsGreen(diags);
                var annotations = GetAnnotations();
                if (annotations?.Length > 0)
                    newNode = newNode.WithAnnotationsGreen(annotations);
                return newNode;
            }

            return this;
        }

        internal override GreenNode SetDiagnostics(DiagnosticInfo[]? diagnostics)
            => new GotoStatementSyntax(this.Kind, this.attributeLists, this.gotoKeyword, this.caseOrDefaultKeyword, this.expression, this.semicolonToken, diagnostics, GetAnnotations());

        internal override GreenNode SetAnnotations(SyntaxAnnotation[]? annotations)
            => new GotoStatementSyntax(this.Kind, this.attributeLists, this.gotoKeyword, this.caseOrDefaultKeyword, this.expression, this.semicolonToken, GetDiagnostics(), annotations);

        internal GotoStatementSyntax(ObjectReader reader)
          : base(reader)
        {
            this.SlotCount = 5;
            var attributeLists = (GreenNode?)reader.ReadValue();
            if (attributeLists != null)
            {
                AdjustFlagsAndWidth(attributeLists);
                this.attributeLists = attributeLists;
            }
            var gotoKeyword = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(gotoKeyword);
            this.gotoKeyword = gotoKeyword;
            var caseOrDefaultKeyword = (SyntaxToken?)reader.ReadValue();
            if (caseOrDefaultKeyword != null)
            {
                AdjustFlagsAndWidth(caseOrDefaultKeyword);
                this.caseOrDefaultKeyword = caseOrDefaultKeyword;
            }
            var expression = (ExpressionSyntax?)reader.ReadValue();
            if (expression != null)
            {
                AdjustFlagsAndWidth(expression);
                this.expression = expression;
            }
            var semicolonToken = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(semicolonToken);
            this.semicolonToken = semicolonToken;
        }

        internal override void WriteTo(ObjectWriter writer)
        {
            base.WriteTo(writer);
            writer.WriteValue(this.attributeLists);
            writer.WriteValue(this.gotoKeyword);
            writer.WriteValue(this.caseOrDefaultKeyword);
            writer.WriteValue(this.expression);
            writer.WriteValue(this.semicolonToken);
        }

        static GotoStatementSyntax()
        {
            ObjectBinder.RegisterTypeReader(typeof(GotoStatementSyntax), r => new GotoStatementSyntax(r));
        }
    }

    internal sealed partial class BreakStatementSyntax : StatementSyntax
    {
        internal readonly GreenNode? attributeLists;
        internal readonly SyntaxToken breakKeyword;
        internal readonly SyntaxToken semicolonToken;

        internal BreakStatementSyntax(SyntaxKind kind, GreenNode? attributeLists, SyntaxToken breakKeyword, SyntaxToken semicolonToken, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
            this.SlotCount = 3;
            if (attributeLists != null)
            {
                this.AdjustFlagsAndWidth(attributeLists);
                this.attributeLists = attributeLists;
            }
            this.AdjustFlagsAndWidth(breakKeyword);
            this.breakKeyword = breakKeyword;
            this.AdjustFlagsAndWidth(semicolonToken);
            this.semicolonToken = semicolonToken;
        }

        internal BreakStatementSyntax(SyntaxKind kind, GreenNode? attributeLists, SyntaxToken breakKeyword, SyntaxToken semicolonToken, SyntaxFactoryContext context)
          : base(kind)
        {
            this.SetFactoryContext(context);
            this.SlotCount = 3;
            if (attributeLists != null)
            {
                this.AdjustFlagsAndWidth(attributeLists);
                this.attributeLists = attributeLists;
            }
            this.AdjustFlagsAndWidth(breakKeyword);
            this.breakKeyword = breakKeyword;
            this.AdjustFlagsAndWidth(semicolonToken);
            this.semicolonToken = semicolonToken;
        }

        internal BreakStatementSyntax(SyntaxKind kind, GreenNode? attributeLists, SyntaxToken breakKeyword, SyntaxToken semicolonToken)
          : base(kind)
        {
            this.SlotCount = 3;
            if (attributeLists != null)
            {
                this.AdjustFlagsAndWidth(attributeLists);
                this.attributeLists = attributeLists;
            }
            this.AdjustFlagsAndWidth(breakKeyword);
            this.breakKeyword = breakKeyword;
            this.AdjustFlagsAndWidth(semicolonToken);
            this.semicolonToken = semicolonToken;
        }

        public override Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<AttributeListSyntax> AttributeLists => new Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<AttributeListSyntax>(this.attributeLists);
        public SyntaxToken BreakKeyword => this.breakKeyword;
        public SyntaxToken SemicolonToken => this.semicolonToken;

        internal override GreenNode? GetSlot(int index)
            => index switch
            {
                0 => this.attributeLists,
                1 => this.breakKeyword,
                2 => this.semicolonToken,
                _ => null,
            };

        internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new CSharp.Syntax.BreakStatementSyntax(this, parent, position);

        public override void Accept(CSharpSyntaxVisitor visitor) => visitor.VisitBreakStatement(this);
        public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor) => visitor.VisitBreakStatement(this);

        public BreakStatementSyntax Update(Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<AttributeListSyntax> attributeLists, SyntaxToken breakKeyword, SyntaxToken semicolonToken)
        {
            if (attributeLists != this.AttributeLists || breakKeyword != this.BreakKeyword || semicolonToken != this.SemicolonToken)
            {
                var newNode = SyntaxFactory.BreakStatement(attributeLists, breakKeyword, semicolonToken);
                var diags = GetDiagnostics();
                if (diags?.Length > 0)
                    newNode = newNode.WithDiagnosticsGreen(diags);
                var annotations = GetAnnotations();
                if (annotations?.Length > 0)
                    newNode = newNode.WithAnnotationsGreen(annotations);
                return newNode;
            }

            return this;
        }

        internal override GreenNode SetDiagnostics(DiagnosticInfo[]? diagnostics)
            => new BreakStatementSyntax(this.Kind, this.attributeLists, this.breakKeyword, this.semicolonToken, diagnostics, GetAnnotations());

        internal override GreenNode SetAnnotations(SyntaxAnnotation[]? annotations)
            => new BreakStatementSyntax(this.Kind, this.attributeLists, this.breakKeyword, this.semicolonToken, GetDiagnostics(), annotations);

        internal BreakStatementSyntax(ObjectReader reader)
          : base(reader)
        {
            this.SlotCount = 3;
            var attributeLists = (GreenNode?)reader.ReadValue();
            if (attributeLists != null)
            {
                AdjustFlagsAndWidth(attributeLists);
                this.attributeLists = attributeLists;
            }
            var breakKeyword = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(breakKeyword);
            this.breakKeyword = breakKeyword;
            var semicolonToken = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(semicolonToken);
            this.semicolonToken = semicolonToken;
        }

        internal override void WriteTo(ObjectWriter writer)
        {
            base.WriteTo(writer);
            writer.WriteValue(this.attributeLists);
            writer.WriteValue(this.breakKeyword);
            writer.WriteValue(this.semicolonToken);
        }

        static BreakStatementSyntax()
        {
            ObjectBinder.RegisterTypeReader(typeof(BreakStatementSyntax), r => new BreakStatementSyntax(r));
        }
    }

    internal sealed partial class ContinueStatementSyntax : StatementSyntax
    {
        internal readonly GreenNode? attributeLists;
        internal readonly SyntaxToken continueKeyword;
        internal readonly SyntaxToken semicolonToken;

        internal ContinueStatementSyntax(SyntaxKind kind, GreenNode? attributeLists, SyntaxToken continueKeyword, SyntaxToken semicolonToken, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
            this.SlotCount = 3;
            if (attributeLists != null)
            {
                this.AdjustFlagsAndWidth(attributeLists);
                this.attributeLists = attributeLists;
            }
            this.AdjustFlagsAndWidth(continueKeyword);
            this.continueKeyword = continueKeyword;
            this.AdjustFlagsAndWidth(semicolonToken);
            this.semicolonToken = semicolonToken;
        }

        internal ContinueStatementSyntax(SyntaxKind kind, GreenNode? attributeLists, SyntaxToken continueKeyword, SyntaxToken semicolonToken, SyntaxFactoryContext context)
          : base(kind)
        {
            this.SetFactoryContext(context);
            this.SlotCount = 3;
            if (attributeLists != null)
            {
                this.AdjustFlagsAndWidth(attributeLists);
                this.attributeLists = attributeLists;
            }
            this.AdjustFlagsAndWidth(continueKeyword);
            this.continueKeyword = continueKeyword;
            this.AdjustFlagsAndWidth(semicolonToken);
            this.semicolonToken = semicolonToken;
        }

        internal ContinueStatementSyntax(SyntaxKind kind, GreenNode? attributeLists, SyntaxToken continueKeyword, SyntaxToken semicolonToken)
          : base(kind)
        {
            this.SlotCount = 3;
            if (attributeLists != null)
            {
                this.AdjustFlagsAndWidth(attributeLists);
                this.attributeLists = attributeLists;
            }
            this.AdjustFlagsAndWidth(continueKeyword);
            this.continueKeyword = continueKeyword;
            this.AdjustFlagsAndWidth(semicolonToken);
            this.semicolonToken = semicolonToken;
        }

        public override Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<AttributeListSyntax> AttributeLists => new Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<AttributeListSyntax>(this.attributeLists);
        public SyntaxToken ContinueKeyword => this.continueKeyword;
        public SyntaxToken SemicolonToken => this.semicolonToken;

        internal override GreenNode? GetSlot(int index)
            => index switch
            {
                0 => this.attributeLists,
                1 => this.continueKeyword,
                2 => this.semicolonToken,
                _ => null,
            };

        internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new CSharp.Syntax.ContinueStatementSyntax(this, parent, position);

        public override void Accept(CSharpSyntaxVisitor visitor) => visitor.VisitContinueStatement(this);
        public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor) => visitor.VisitContinueStatement(this);

        public ContinueStatementSyntax Update(Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<AttributeListSyntax> attributeLists, SyntaxToken continueKeyword, SyntaxToken semicolonToken)
        {
            if (attributeLists != this.AttributeLists || continueKeyword != this.ContinueKeyword || semicolonToken != this.SemicolonToken)
            {
                var newNode = SyntaxFactory.ContinueStatement(attributeLists, continueKeyword, semicolonToken);
                var diags = GetDiagnostics();
                if (diags?.Length > 0)
                    newNode = newNode.WithDiagnosticsGreen(diags);
                var annotations = GetAnnotations();
                if (annotations?.Length > 0)
                    newNode = newNode.WithAnnotationsGreen(annotations);
                return newNode;
            }

            return this;
        }

        internal override GreenNode SetDiagnostics(DiagnosticInfo[]? diagnostics)
            => new ContinueStatementSyntax(this.Kind, this.attributeLists, this.continueKeyword, this.semicolonToken, diagnostics, GetAnnotations());

        internal override GreenNode SetAnnotations(SyntaxAnnotation[]? annotations)
            => new ContinueStatementSyntax(this.Kind, this.attributeLists, this.continueKeyword, this.semicolonToken, GetDiagnostics(), annotations);

        internal ContinueStatementSyntax(ObjectReader reader)
          : base(reader)
        {
            this.SlotCount = 3;
            var attributeLists = (GreenNode?)reader.ReadValue();
            if (attributeLists != null)
            {
                AdjustFlagsAndWidth(attributeLists);
                this.attributeLists = attributeLists;
            }
            var continueKeyword = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(continueKeyword);
            this.continueKeyword = continueKeyword;
            var semicolonToken = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(semicolonToken);
            this.semicolonToken = semicolonToken;
        }

        internal override void WriteTo(ObjectWriter writer)
        {
            base.WriteTo(writer);
            writer.WriteValue(this.attributeLists);
            writer.WriteValue(this.continueKeyword);
            writer.WriteValue(this.semicolonToken);
        }

        static ContinueStatementSyntax()
        {
            ObjectBinder.RegisterTypeReader(typeof(ContinueStatementSyntax), r => new ContinueStatementSyntax(r));
        }
    }

    internal sealed partial class ReturnStatementSyntax : StatementSyntax
    {
        internal readonly GreenNode? attributeLists;
        internal readonly SyntaxToken returnKeyword;
        internal readonly ExpressionSyntax? expression;
        internal readonly SyntaxToken semicolonToken;

        internal ReturnStatementSyntax(SyntaxKind kind, GreenNode? attributeLists, SyntaxToken returnKeyword, ExpressionSyntax? expression, SyntaxToken semicolonToken, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
            this.SlotCount = 4;
            if (attributeLists != null)
            {
                this.AdjustFlagsAndWidth(attributeLists);
                this.attributeLists = attributeLists;
            }
            this.AdjustFlagsAndWidth(returnKeyword);
            this.returnKeyword = returnKeyword;
            if (expression != null)
            {
                this.AdjustFlagsAndWidth(expression);
                this.expression = expression;
            }
            this.AdjustFlagsAndWidth(semicolonToken);
            this.semicolonToken = semicolonToken;
        }

        internal ReturnStatementSyntax(SyntaxKind kind, GreenNode? attributeLists, SyntaxToken returnKeyword, ExpressionSyntax? expression, SyntaxToken semicolonToken, SyntaxFactoryContext context)
          : base(kind)
        {
            this.SetFactoryContext(context);
            this.SlotCount = 4;
            if (attributeLists != null)
            {
                this.AdjustFlagsAndWidth(attributeLists);
                this.attributeLists = attributeLists;
            }
            this.AdjustFlagsAndWidth(returnKeyword);
            this.returnKeyword = returnKeyword;
            if (expression != null)
            {
                this.AdjustFlagsAndWidth(expression);
                this.expression = expression;
            }
            this.AdjustFlagsAndWidth(semicolonToken);
            this.semicolonToken = semicolonToken;
        }

        internal ReturnStatementSyntax(SyntaxKind kind, GreenNode? attributeLists, SyntaxToken returnKeyword, ExpressionSyntax? expression, SyntaxToken semicolonToken)
          : base(kind)
        {
            this.SlotCount = 4;
            if (attributeLists != null)
            {
                this.AdjustFlagsAndWidth(attributeLists);
                this.attributeLists = attributeLists;
            }
            this.AdjustFlagsAndWidth(returnKeyword);
            this.returnKeyword = returnKeyword;
            if (expression != null)
            {
                this.AdjustFlagsAndWidth(expression);
                this.expression = expression;
            }
            this.AdjustFlagsAndWidth(semicolonToken);
            this.semicolonToken = semicolonToken;
        }

        public override Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<AttributeListSyntax> AttributeLists => new Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<AttributeListSyntax>(this.attributeLists);
        public SyntaxToken ReturnKeyword => this.returnKeyword;
        public ExpressionSyntax? Expression => this.expression;
        public SyntaxToken SemicolonToken => this.semicolonToken;

        internal override GreenNode? GetSlot(int index)
            => index switch
            {
                0 => this.attributeLists,
                1 => this.returnKeyword,
                2 => this.expression,
                3 => this.semicolonToken,
                _ => null,
            };

        internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new CSharp.Syntax.ReturnStatementSyntax(this, parent, position);

        public override void Accept(CSharpSyntaxVisitor visitor) => visitor.VisitReturnStatement(this);
        public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor) => visitor.VisitReturnStatement(this);

        public ReturnStatementSyntax Update(Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<AttributeListSyntax> attributeLists, SyntaxToken returnKeyword, ExpressionSyntax expression, SyntaxToken semicolonToken)
        {
            if (attributeLists != this.AttributeLists || returnKeyword != this.ReturnKeyword || expression != this.Expression || semicolonToken != this.SemicolonToken)
            {
                var newNode = SyntaxFactory.ReturnStatement(attributeLists, returnKeyword, expression, semicolonToken);
                var diags = GetDiagnostics();
                if (diags?.Length > 0)
                    newNode = newNode.WithDiagnosticsGreen(diags);
                var annotations = GetAnnotations();
                if (annotations?.Length > 0)
                    newNode = newNode.WithAnnotationsGreen(annotations);
                return newNode;
            }

            return this;
        }

        internal override GreenNode SetDiagnostics(DiagnosticInfo[]? diagnostics)
            => new ReturnStatementSyntax(this.Kind, this.attributeLists, this.returnKeyword, this.expression, this.semicolonToken, diagnostics, GetAnnotations());

        internal override GreenNode SetAnnotations(SyntaxAnnotation[]? annotations)
            => new ReturnStatementSyntax(this.Kind, this.attributeLists, this.returnKeyword, this.expression, this.semicolonToken, GetDiagnostics(), annotations);

        internal ReturnStatementSyntax(ObjectReader reader)
          : base(reader)
        {
            this.SlotCount = 4;
            var attributeLists = (GreenNode?)reader.ReadValue();
            if (attributeLists != null)
            {
                AdjustFlagsAndWidth(attributeLists);
                this.attributeLists = attributeLists;
            }
            var returnKeyword = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(returnKeyword);
            this.returnKeyword = returnKeyword;
            var expression = (ExpressionSyntax?)reader.ReadValue();
            if (expression != null)
            {
                AdjustFlagsAndWidth(expression);
                this.expression = expression;
            }
            var semicolonToken = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(semicolonToken);
            this.semicolonToken = semicolonToken;
        }

        internal override void WriteTo(ObjectWriter writer)
        {
            base.WriteTo(writer);
            writer.WriteValue(this.attributeLists);
            writer.WriteValue(this.returnKeyword);
            writer.WriteValue(this.expression);
            writer.WriteValue(this.semicolonToken);
        }

        static ReturnStatementSyntax()
        {
            ObjectBinder.RegisterTypeReader(typeof(ReturnStatementSyntax), r => new ReturnStatementSyntax(r));
        }
    }

    internal sealed partial class ThrowStatementSyntax : StatementSyntax
    {
        internal readonly GreenNode? attributeLists;
        internal readonly SyntaxToken throwKeyword;
        internal readonly ExpressionSyntax? expression;
        internal readonly SyntaxToken semicolonToken;

        internal ThrowStatementSyntax(SyntaxKind kind, GreenNode? attributeLists, SyntaxToken throwKeyword, ExpressionSyntax? expression, SyntaxToken semicolonToken, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
            this.SlotCount = 4;
            if (attributeLists != null)
            {
                this.AdjustFlagsAndWidth(attributeLists);
                this.attributeLists = attributeLists;
            }
            this.AdjustFlagsAndWidth(throwKeyword);
            this.throwKeyword = throwKeyword;
            if (expression != null)
            {
                this.AdjustFlagsAndWidth(expression);
                this.expression = expression;
            }
            this.AdjustFlagsAndWidth(semicolonToken);
            this.semicolonToken = semicolonToken;
        }

        internal ThrowStatementSyntax(SyntaxKind kind, GreenNode? attributeLists, SyntaxToken throwKeyword, ExpressionSyntax? expression, SyntaxToken semicolonToken, SyntaxFactoryContext context)
          : base(kind)
        {
            this.SetFactoryContext(context);
            this.SlotCount = 4;
            if (attributeLists != null)
            {
                this.AdjustFlagsAndWidth(attributeLists);
                this.attributeLists = attributeLists;
            }
            this.AdjustFlagsAndWidth(throwKeyword);
            this.throwKeyword = throwKeyword;
            if (expression != null)
            {
                this.AdjustFlagsAndWidth(expression);
                this.expression = expression;
            }
            this.AdjustFlagsAndWidth(semicolonToken);
            this.semicolonToken = semicolonToken;
        }

        internal ThrowStatementSyntax(SyntaxKind kind, GreenNode? attributeLists, SyntaxToken throwKeyword, ExpressionSyntax? expression, SyntaxToken semicolonToken)
          : base(kind)
        {
            this.SlotCount = 4;
            if (attributeLists != null)
            {
                this.AdjustFlagsAndWidth(attributeLists);
                this.attributeLists = attributeLists;
            }
            this.AdjustFlagsAndWidth(throwKeyword);
            this.throwKeyword = throwKeyword;
            if (expression != null)
            {
                this.AdjustFlagsAndWidth(expression);
                this.expression = expression;
            }
            this.AdjustFlagsAndWidth(semicolonToken);
            this.semicolonToken = semicolonToken;
        }

        public override Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<AttributeListSyntax> AttributeLists => new Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<AttributeListSyntax>(this.attributeLists);
        public SyntaxToken ThrowKeyword => this.throwKeyword;
        public ExpressionSyntax? Expression => this.expression;
        public SyntaxToken SemicolonToken => this.semicolonToken;

        internal override GreenNode? GetSlot(int index)
            => index switch
            {
                0 => this.attributeLists,
                1 => this.throwKeyword,
                2 => this.expression,
                3 => this.semicolonToken,
                _ => null,
            };

        internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new CSharp.Syntax.ThrowStatementSyntax(this, parent, position);

        public override void Accept(CSharpSyntaxVisitor visitor) => visitor.VisitThrowStatement(this);
        public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor) => visitor.VisitThrowStatement(this);

        public ThrowStatementSyntax Update(Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<AttributeListSyntax> attributeLists, SyntaxToken throwKeyword, ExpressionSyntax expression, SyntaxToken semicolonToken)
        {
            if (attributeLists != this.AttributeLists || throwKeyword != this.ThrowKeyword || expression != this.Expression || semicolonToken != this.SemicolonToken)
            {
                var newNode = SyntaxFactory.ThrowStatement(attributeLists, throwKeyword, expression, semicolonToken);
                var diags = GetDiagnostics();
                if (diags?.Length > 0)
                    newNode = newNode.WithDiagnosticsGreen(diags);
                var annotations = GetAnnotations();
                if (annotations?.Length > 0)
                    newNode = newNode.WithAnnotationsGreen(annotations);
                return newNode;
            }

            return this;
        }

        internal override GreenNode SetDiagnostics(DiagnosticInfo[]? diagnostics)
            => new ThrowStatementSyntax(this.Kind, this.attributeLists, this.throwKeyword, this.expression, this.semicolonToken, diagnostics, GetAnnotations());

        internal override GreenNode SetAnnotations(SyntaxAnnotation[]? annotations)
            => new ThrowStatementSyntax(this.Kind, this.attributeLists, this.throwKeyword, this.expression, this.semicolonToken, GetDiagnostics(), annotations);

        internal ThrowStatementSyntax(ObjectReader reader)
          : base(reader)
        {
            this.SlotCount = 4;
            var attributeLists = (GreenNode?)reader.ReadValue();
            if (attributeLists != null)
            {
                AdjustFlagsAndWidth(attributeLists);
                this.attributeLists = attributeLists;
            }
            var throwKeyword = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(throwKeyword);
            this.throwKeyword = throwKeyword;
            var expression = (ExpressionSyntax?)reader.ReadValue();
            if (expression != null)
            {
                AdjustFlagsAndWidth(expression);
                this.expression = expression;
            }
            var semicolonToken = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(semicolonToken);
            this.semicolonToken = semicolonToken;
        }

        internal override void WriteTo(ObjectWriter writer)
        {
            base.WriteTo(writer);
            writer.WriteValue(this.attributeLists);
            writer.WriteValue(this.throwKeyword);
            writer.WriteValue(this.expression);
            writer.WriteValue(this.semicolonToken);
        }

        static ThrowStatementSyntax()
        {
            ObjectBinder.RegisterTypeReader(typeof(ThrowStatementSyntax), r => new ThrowStatementSyntax(r));
        }
    }

    internal sealed partial class YieldStatementSyntax : StatementSyntax
    {
        internal readonly GreenNode? attributeLists;
        internal readonly SyntaxToken yieldKeyword;
        internal readonly SyntaxToken returnOrBreakKeyword;
        internal readonly ExpressionSyntax? expression;
        internal readonly SyntaxToken semicolonToken;

        internal YieldStatementSyntax(SyntaxKind kind, GreenNode? attributeLists, SyntaxToken yieldKeyword, SyntaxToken returnOrBreakKeyword, ExpressionSyntax? expression, SyntaxToken semicolonToken, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
            this.SlotCount = 5;
            if (attributeLists != null)
            {
                this.AdjustFlagsAndWidth(attributeLists);
                this.attributeLists = attributeLists;
            }
            this.AdjustFlagsAndWidth(yieldKeyword);
            this.yieldKeyword = yieldKeyword;
            this.AdjustFlagsAndWidth(returnOrBreakKeyword);
            this.returnOrBreakKeyword = returnOrBreakKeyword;
            if (expression != null)
            {
                this.AdjustFlagsAndWidth(expression);
                this.expression = expression;
            }
            this.AdjustFlagsAndWidth(semicolonToken);
            this.semicolonToken = semicolonToken;
        }

        internal YieldStatementSyntax(SyntaxKind kind, GreenNode? attributeLists, SyntaxToken yieldKeyword, SyntaxToken returnOrBreakKeyword, ExpressionSyntax? expression, SyntaxToken semicolonToken, SyntaxFactoryContext context)
          : base(kind)
        {
            this.SetFactoryContext(context);
            this.SlotCount = 5;
            if (attributeLists != null)
            {
                this.AdjustFlagsAndWidth(attributeLists);
                this.attributeLists = attributeLists;
            }
            this.AdjustFlagsAndWidth(yieldKeyword);
            this.yieldKeyword = yieldKeyword;
            this.AdjustFlagsAndWidth(returnOrBreakKeyword);
            this.returnOrBreakKeyword = returnOrBreakKeyword;
            if (expression != null)
            {
                this.AdjustFlagsAndWidth(expression);
                this.expression = expression;
            }
            this.AdjustFlagsAndWidth(semicolonToken);
            this.semicolonToken = semicolonToken;
        }

        internal YieldStatementSyntax(SyntaxKind kind, GreenNode? attributeLists, SyntaxToken yieldKeyword, SyntaxToken returnOrBreakKeyword, ExpressionSyntax? expression, SyntaxToken semicolonToken)
          : base(kind)
        {
            this.SlotCount = 5;
            if (attributeLists != null)
            {
                this.AdjustFlagsAndWidth(attributeLists);
                this.attributeLists = attributeLists;
            }
            this.AdjustFlagsAndWidth(yieldKeyword);
            this.yieldKeyword = yieldKeyword;
            this.AdjustFlagsAndWidth(returnOrBreakKeyword);
            this.returnOrBreakKeyword = returnOrBreakKeyword;
            if (expression != null)
            {
                this.AdjustFlagsAndWidth(expression);
                this.expression = expression;
            }
            this.AdjustFlagsAndWidth(semicolonToken);
            this.semicolonToken = semicolonToken;
        }

        public override Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<AttributeListSyntax> AttributeLists => new Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<AttributeListSyntax>(this.attributeLists);
        public SyntaxToken YieldKeyword => this.yieldKeyword;
        public SyntaxToken ReturnOrBreakKeyword => this.returnOrBreakKeyword;
        public ExpressionSyntax? Expression => this.expression;
        public SyntaxToken SemicolonToken => this.semicolonToken;

        internal override GreenNode? GetSlot(int index)
            => index switch
            {
                0 => this.attributeLists,
                1 => this.yieldKeyword,
                2 => this.returnOrBreakKeyword,
                3 => this.expression,
                4 => this.semicolonToken,
                _ => null,
            };

        internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new CSharp.Syntax.YieldStatementSyntax(this, parent, position);

        public override void Accept(CSharpSyntaxVisitor visitor) => visitor.VisitYieldStatement(this);
        public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor) => visitor.VisitYieldStatement(this);

        public YieldStatementSyntax Update(Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<AttributeListSyntax> attributeLists, SyntaxToken yieldKeyword, SyntaxToken returnOrBreakKeyword, ExpressionSyntax expression, SyntaxToken semicolonToken)
        {
            if (attributeLists != this.AttributeLists || yieldKeyword != this.YieldKeyword || returnOrBreakKeyword != this.ReturnOrBreakKeyword || expression != this.Expression || semicolonToken != this.SemicolonToken)
            {
                var newNode = SyntaxFactory.YieldStatement(this.Kind, attributeLists, yieldKeyword, returnOrBreakKeyword, expression, semicolonToken);
                var diags = GetDiagnostics();
                if (diags?.Length > 0)
                    newNode = newNode.WithDiagnosticsGreen(diags);
                var annotations = GetAnnotations();
                if (annotations?.Length > 0)
                    newNode = newNode.WithAnnotationsGreen(annotations);
                return newNode;
            }

            return this;
        }

        internal override GreenNode SetDiagnostics(DiagnosticInfo[]? diagnostics)
            => new YieldStatementSyntax(this.Kind, this.attributeLists, this.yieldKeyword, this.returnOrBreakKeyword, this.expression, this.semicolonToken, diagnostics, GetAnnotations());

        internal override GreenNode SetAnnotations(SyntaxAnnotation[]? annotations)
            => new YieldStatementSyntax(this.Kind, this.attributeLists, this.yieldKeyword, this.returnOrBreakKeyword, this.expression, this.semicolonToken, GetDiagnostics(), annotations);

        internal YieldStatementSyntax(ObjectReader reader)
          : base(reader)
        {
            this.SlotCount = 5;
            var attributeLists = (GreenNode?)reader.ReadValue();
            if (attributeLists != null)
            {
                AdjustFlagsAndWidth(attributeLists);
                this.attributeLists = attributeLists;
            }
            var yieldKeyword = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(yieldKeyword);
            this.yieldKeyword = yieldKeyword;
            var returnOrBreakKeyword = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(returnOrBreakKeyword);
            this.returnOrBreakKeyword = returnOrBreakKeyword;
            var expression = (ExpressionSyntax?)reader.ReadValue();
            if (expression != null)
            {
                AdjustFlagsAndWidth(expression);
                this.expression = expression;
            }
            var semicolonToken = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(semicolonToken);
            this.semicolonToken = semicolonToken;
        }

        internal override void WriteTo(ObjectWriter writer)
        {
            base.WriteTo(writer);
            writer.WriteValue(this.attributeLists);
            writer.WriteValue(this.yieldKeyword);
            writer.WriteValue(this.returnOrBreakKeyword);
            writer.WriteValue(this.expression);
            writer.WriteValue(this.semicolonToken);
        }

        static YieldStatementSyntax()
        {
            ObjectBinder.RegisterTypeReader(typeof(YieldStatementSyntax), r => new YieldStatementSyntax(r));
        }
    }

    internal sealed partial class WhileStatementSyntax : StatementSyntax
    {
        internal readonly GreenNode? attributeLists;
        internal readonly SyntaxToken whileKeyword;
        internal readonly SyntaxToken openParenToken;
        internal readonly ExpressionSyntax condition;
        internal readonly SyntaxToken closeParenToken;
        internal readonly StatementSyntax statement;

        internal WhileStatementSyntax(SyntaxKind kind, GreenNode? attributeLists, SyntaxToken whileKeyword, SyntaxToken openParenToken, ExpressionSyntax condition, SyntaxToken closeParenToken, StatementSyntax statement, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
            this.SlotCount = 6;
            if (attributeLists != null)
            {
                this.AdjustFlagsAndWidth(attributeLists);
                this.attributeLists = attributeLists;
            }
            this.AdjustFlagsAndWidth(whileKeyword);
            this.whileKeyword = whileKeyword;
            this.AdjustFlagsAndWidth(openParenToken);
            this.openParenToken = openParenToken;
            this.AdjustFlagsAndWidth(condition);
            this.condition = condition;
            this.AdjustFlagsAndWidth(closeParenToken);
            this.closeParenToken = closeParenToken;
            this.AdjustFlagsAndWidth(statement);
            this.statement = statement;
        }

        internal WhileStatementSyntax(SyntaxKind kind, GreenNode? attributeLists, SyntaxToken whileKeyword, SyntaxToken openParenToken, ExpressionSyntax condition, SyntaxToken closeParenToken, StatementSyntax statement, SyntaxFactoryContext context)
          : base(kind)
        {
            this.SetFactoryContext(context);
            this.SlotCount = 6;
            if (attributeLists != null)
            {
                this.AdjustFlagsAndWidth(attributeLists);
                this.attributeLists = attributeLists;
            }
            this.AdjustFlagsAndWidth(whileKeyword);
            this.whileKeyword = whileKeyword;
            this.AdjustFlagsAndWidth(openParenToken);
            this.openParenToken = openParenToken;
            this.AdjustFlagsAndWidth(condition);
            this.condition = condition;
            this.AdjustFlagsAndWidth(closeParenToken);
            this.closeParenToken = closeParenToken;
            this.AdjustFlagsAndWidth(statement);
            this.statement = statement;
        }

        internal WhileStatementSyntax(SyntaxKind kind, GreenNode? attributeLists, SyntaxToken whileKeyword, SyntaxToken openParenToken, ExpressionSyntax condition, SyntaxToken closeParenToken, StatementSyntax statement)
          : base(kind)
        {
            this.SlotCount = 6;
            if (attributeLists != null)
            {
                this.AdjustFlagsAndWidth(attributeLists);
                this.attributeLists = attributeLists;
            }
            this.AdjustFlagsAndWidth(whileKeyword);
            this.whileKeyword = whileKeyword;
            this.AdjustFlagsAndWidth(openParenToken);
            this.openParenToken = openParenToken;
            this.AdjustFlagsAndWidth(condition);
            this.condition = condition;
            this.AdjustFlagsAndWidth(closeParenToken);
            this.closeParenToken = closeParenToken;
            this.AdjustFlagsAndWidth(statement);
            this.statement = statement;
        }

        public override Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<AttributeListSyntax> AttributeLists => new Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<AttributeListSyntax>(this.attributeLists);
        public SyntaxToken WhileKeyword => this.whileKeyword;
        public SyntaxToken OpenParenToken => this.openParenToken;
        public ExpressionSyntax Condition => this.condition;
        public SyntaxToken CloseParenToken => this.closeParenToken;
        public StatementSyntax Statement => this.statement;

        internal override GreenNode? GetSlot(int index)
            => index switch
            {
                0 => this.attributeLists,
                1 => this.whileKeyword,
                2 => this.openParenToken,
                3 => this.condition,
                4 => this.closeParenToken,
                5 => this.statement,
                _ => null,
            };

        internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new CSharp.Syntax.WhileStatementSyntax(this, parent, position);

        public override void Accept(CSharpSyntaxVisitor visitor) => visitor.VisitWhileStatement(this);
        public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor) => visitor.VisitWhileStatement(this);

        public WhileStatementSyntax Update(Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<AttributeListSyntax> attributeLists, SyntaxToken whileKeyword, SyntaxToken openParenToken, ExpressionSyntax condition, SyntaxToken closeParenToken, StatementSyntax statement)
        {
            if (attributeLists != this.AttributeLists || whileKeyword != this.WhileKeyword || openParenToken != this.OpenParenToken || condition != this.Condition || closeParenToken != this.CloseParenToken || statement != this.Statement)
            {
                var newNode = SyntaxFactory.WhileStatement(attributeLists, whileKeyword, openParenToken, condition, closeParenToken, statement);
                var diags = GetDiagnostics();
                if (diags?.Length > 0)
                    newNode = newNode.WithDiagnosticsGreen(diags);
                var annotations = GetAnnotations();
                if (annotations?.Length > 0)
                    newNode = newNode.WithAnnotationsGreen(annotations);
                return newNode;
            }

            return this;
        }

        internal override GreenNode SetDiagnostics(DiagnosticInfo[]? diagnostics)
            => new WhileStatementSyntax(this.Kind, this.attributeLists, this.whileKeyword, this.openParenToken, this.condition, this.closeParenToken, this.statement, diagnostics, GetAnnotations());

        internal override GreenNode SetAnnotations(SyntaxAnnotation[]? annotations)
            => new WhileStatementSyntax(this.Kind, this.attributeLists, this.whileKeyword, this.openParenToken, this.condition, this.closeParenToken, this.statement, GetDiagnostics(), annotations);

        internal WhileStatementSyntax(ObjectReader reader)
          : base(reader)
        {
            this.SlotCount = 6;
            var attributeLists = (GreenNode?)reader.ReadValue();
            if (attributeLists != null)
            {
                AdjustFlagsAndWidth(attributeLists);
                this.attributeLists = attributeLists;
            }
            var whileKeyword = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(whileKeyword);
            this.whileKeyword = whileKeyword;
            var openParenToken = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(openParenToken);
            this.openParenToken = openParenToken;
            var condition = (ExpressionSyntax)reader.ReadValue();
            AdjustFlagsAndWidth(condition);
            this.condition = condition;
            var closeParenToken = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(closeParenToken);
            this.closeParenToken = closeParenToken;
            var statement = (StatementSyntax)reader.ReadValue();
            AdjustFlagsAndWidth(statement);
            this.statement = statement;
        }

        internal override void WriteTo(ObjectWriter writer)
        {
            base.WriteTo(writer);
            writer.WriteValue(this.attributeLists);
            writer.WriteValue(this.whileKeyword);
            writer.WriteValue(this.openParenToken);
            writer.WriteValue(this.condition);
            writer.WriteValue(this.closeParenToken);
            writer.WriteValue(this.statement);
        }

        static WhileStatementSyntax()
        {
            ObjectBinder.RegisterTypeReader(typeof(WhileStatementSyntax), r => new WhileStatementSyntax(r));
        }
    }

    internal sealed partial class DoStatementSyntax : StatementSyntax
    {
        internal readonly GreenNode? attributeLists;
        internal readonly SyntaxToken doKeyword;
        internal readonly StatementSyntax statement;
        internal readonly SyntaxToken whileKeyword;
        internal readonly SyntaxToken openParenToken;
        internal readonly ExpressionSyntax condition;
        internal readonly SyntaxToken closeParenToken;
        internal readonly SyntaxToken semicolonToken;

        internal DoStatementSyntax(SyntaxKind kind, GreenNode? attributeLists, SyntaxToken doKeyword, StatementSyntax statement, SyntaxToken whileKeyword, SyntaxToken openParenToken, ExpressionSyntax condition, SyntaxToken closeParenToken, SyntaxToken semicolonToken, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
            this.SlotCount = 8;
            if (attributeLists != null)
            {
                this.AdjustFlagsAndWidth(attributeLists);
                this.attributeLists = attributeLists;
            }
            this.AdjustFlagsAndWidth(doKeyword);
            this.doKeyword = doKeyword;
            this.AdjustFlagsAndWidth(statement);
            this.statement = statement;
            this.AdjustFlagsAndWidth(whileKeyword);
            this.whileKeyword = whileKeyword;
            this.AdjustFlagsAndWidth(openParenToken);
            this.openParenToken = openParenToken;
            this.AdjustFlagsAndWidth(condition);
            this.condition = condition;
            this.AdjustFlagsAndWidth(closeParenToken);
            this.closeParenToken = closeParenToken;
            this.AdjustFlagsAndWidth(semicolonToken);
            this.semicolonToken = semicolonToken;
        }

        internal DoStatementSyntax(SyntaxKind kind, GreenNode? attributeLists, SyntaxToken doKeyword, StatementSyntax statement, SyntaxToken whileKeyword, SyntaxToken openParenToken, ExpressionSyntax condition, SyntaxToken closeParenToken, SyntaxToken semicolonToken, SyntaxFactoryContext context)
          : base(kind)
        {
            this.SetFactoryContext(context);
            this.SlotCount = 8;
            if (attributeLists != null)
            {
                this.AdjustFlagsAndWidth(attributeLists);
                this.attributeLists = attributeLists;
            }
            this.AdjustFlagsAndWidth(doKeyword);
            this.doKeyword = doKeyword;
            this.AdjustFlagsAndWidth(statement);
            this.statement = statement;
            this.AdjustFlagsAndWidth(whileKeyword);
            this.whileKeyword = whileKeyword;
            this.AdjustFlagsAndWidth(openParenToken);
            this.openParenToken = openParenToken;
            this.AdjustFlagsAndWidth(condition);
            this.condition = condition;
            this.AdjustFlagsAndWidth(closeParenToken);
            this.closeParenToken = closeParenToken;
            this.AdjustFlagsAndWidth(semicolonToken);
            this.semicolonToken = semicolonToken;
        }

        internal DoStatementSyntax(SyntaxKind kind, GreenNode? attributeLists, SyntaxToken doKeyword, StatementSyntax statement, SyntaxToken whileKeyword, SyntaxToken openParenToken, ExpressionSyntax condition, SyntaxToken closeParenToken, SyntaxToken semicolonToken)
          : base(kind)
        {
            this.SlotCount = 8;
            if (attributeLists != null)
            {
                this.AdjustFlagsAndWidth(attributeLists);
                this.attributeLists = attributeLists;
            }
            this.AdjustFlagsAndWidth(doKeyword);
            this.doKeyword = doKeyword;
            this.AdjustFlagsAndWidth(statement);
            this.statement = statement;
            this.AdjustFlagsAndWidth(whileKeyword);
            this.whileKeyword = whileKeyword;
            this.AdjustFlagsAndWidth(openParenToken);
            this.openParenToken = openParenToken;
            this.AdjustFlagsAndWidth(condition);
            this.condition = condition;
            this.AdjustFlagsAndWidth(closeParenToken);
            this.closeParenToken = closeParenToken;
            this.AdjustFlagsAndWidth(semicolonToken);
            this.semicolonToken = semicolonToken;
        }

        public override Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<AttributeListSyntax> AttributeLists => new Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<AttributeListSyntax>(this.attributeLists);
        public SyntaxToken DoKeyword => this.doKeyword;
        public StatementSyntax Statement => this.statement;
        public SyntaxToken WhileKeyword => this.whileKeyword;
        public SyntaxToken OpenParenToken => this.openParenToken;
        public ExpressionSyntax Condition => this.condition;
        public SyntaxToken CloseParenToken => this.closeParenToken;
        public SyntaxToken SemicolonToken => this.semicolonToken;

        internal override GreenNode? GetSlot(int index)
            => index switch
            {
                0 => this.attributeLists,
                1 => this.doKeyword,
                2 => this.statement,
                3 => this.whileKeyword,
                4 => this.openParenToken,
                5 => this.condition,
                6 => this.closeParenToken,
                7 => this.semicolonToken,
                _ => null,
            };

        internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new CSharp.Syntax.DoStatementSyntax(this, parent, position);

        public override void Accept(CSharpSyntaxVisitor visitor) => visitor.VisitDoStatement(this);
        public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor) => visitor.VisitDoStatement(this);

        public DoStatementSyntax Update(Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<AttributeListSyntax> attributeLists, SyntaxToken doKeyword, StatementSyntax statement, SyntaxToken whileKeyword, SyntaxToken openParenToken, ExpressionSyntax condition, SyntaxToken closeParenToken, SyntaxToken semicolonToken)
        {
            if (attributeLists != this.AttributeLists || doKeyword != this.DoKeyword || statement != this.Statement || whileKeyword != this.WhileKeyword || openParenToken != this.OpenParenToken || condition != this.Condition || closeParenToken != this.CloseParenToken || semicolonToken != this.SemicolonToken)
            {
                var newNode = SyntaxFactory.DoStatement(attributeLists, doKeyword, statement, whileKeyword, openParenToken, condition, closeParenToken, semicolonToken);
                var diags = GetDiagnostics();
                if (diags?.Length > 0)
                    newNode = newNode.WithDiagnosticsGreen(diags);
                var annotations = GetAnnotations();
                if (annotations?.Length > 0)
                    newNode = newNode.WithAnnotationsGreen(annotations);
                return newNode;
            }

            return this;
        }

        internal override GreenNode SetDiagnostics(DiagnosticInfo[]? diagnostics)
            => new DoStatementSyntax(this.Kind, this.attributeLists, this.doKeyword, this.statement, this.whileKeyword, this.openParenToken, this.condition, this.closeParenToken, this.semicolonToken, diagnostics, GetAnnotations());

        internal override GreenNode SetAnnotations(SyntaxAnnotation[]? annotations)
            => new DoStatementSyntax(this.Kind, this.attributeLists, this.doKeyword, this.statement, this.whileKeyword, this.openParenToken, this.condition, this.closeParenToken, this.semicolonToken, GetDiagnostics(), annotations);

        internal DoStatementSyntax(ObjectReader reader)
          : base(reader)
        {
            this.SlotCount = 8;
            var attributeLists = (GreenNode?)reader.ReadValue();
            if (attributeLists != null)
            {
                AdjustFlagsAndWidth(attributeLists);
                this.attributeLists = attributeLists;
            }
            var doKeyword = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(doKeyword);
            this.doKeyword = doKeyword;
            var statement = (StatementSyntax)reader.ReadValue();
            AdjustFlagsAndWidth(statement);
            this.statement = statement;
            var whileKeyword = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(whileKeyword);
            this.whileKeyword = whileKeyword;
            var openParenToken = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(openParenToken);
            this.openParenToken = openParenToken;
            var condition = (ExpressionSyntax)reader.ReadValue();
            AdjustFlagsAndWidth(condition);
            this.condition = condition;
            var closeParenToken = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(closeParenToken);
            this.closeParenToken = closeParenToken;
            var semicolonToken = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(semicolonToken);
            this.semicolonToken = semicolonToken;
        }

        internal override void WriteTo(ObjectWriter writer)
        {
            base.WriteTo(writer);
            writer.WriteValue(this.attributeLists);
            writer.WriteValue(this.doKeyword);
            writer.WriteValue(this.statement);
            writer.WriteValue(this.whileKeyword);
            writer.WriteValue(this.openParenToken);
            writer.WriteValue(this.condition);
            writer.WriteValue(this.closeParenToken);
            writer.WriteValue(this.semicolonToken);
        }

        static DoStatementSyntax()
        {
            ObjectBinder.RegisterTypeReader(typeof(DoStatementSyntax), r => new DoStatementSyntax(r));
        }
    }

    internal sealed partial class ForStatementSyntax : StatementSyntax
    {
        internal readonly GreenNode? attributeLists;
        internal readonly SyntaxToken forKeyword;
        internal readonly SyntaxToken openParenToken;
        internal readonly VariableDeclarationSyntax? declaration;
        internal readonly GreenNode? initializers;
        internal readonly SyntaxToken firstSemicolonToken;
        internal readonly ExpressionSyntax? condition;
        internal readonly SyntaxToken secondSemicolonToken;
        internal readonly GreenNode? incrementors;
        internal readonly SyntaxToken closeParenToken;
        internal readonly StatementSyntax statement;

        internal ForStatementSyntax(SyntaxKind kind, GreenNode? attributeLists, SyntaxToken forKeyword, SyntaxToken openParenToken, VariableDeclarationSyntax? declaration, GreenNode? initializers, SyntaxToken firstSemicolonToken, ExpressionSyntax? condition, SyntaxToken secondSemicolonToken, GreenNode? incrementors, SyntaxToken closeParenToken, StatementSyntax statement, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
            this.SlotCount = 11;
            if (attributeLists != null)
            {
                this.AdjustFlagsAndWidth(attributeLists);
                this.attributeLists = attributeLists;
            }
            this.AdjustFlagsAndWidth(forKeyword);
            this.forKeyword = forKeyword;
            this.AdjustFlagsAndWidth(openParenToken);
            this.openParenToken = openParenToken;
            if (declaration != null)
            {
                this.AdjustFlagsAndWidth(declaration);
                this.declaration = declaration;
            }
            if (initializers != null)
            {
                this.AdjustFlagsAndWidth(initializers);
                this.initializers = initializers;
            }
            this.AdjustFlagsAndWidth(firstSemicolonToken);
            this.firstSemicolonToken = firstSemicolonToken;
            if (condition != null)
            {
                this.AdjustFlagsAndWidth(condition);
                this.condition = condition;
            }
            this.AdjustFlagsAndWidth(secondSemicolonToken);
            this.secondSemicolonToken = secondSemicolonToken;
            if (incrementors != null)
            {
                this.AdjustFlagsAndWidth(incrementors);
                this.incrementors = incrementors;
            }
            this.AdjustFlagsAndWidth(closeParenToken);
            this.closeParenToken = closeParenToken;
            this.AdjustFlagsAndWidth(statement);
            this.statement = statement;
        }

        internal ForStatementSyntax(SyntaxKind kind, GreenNode? attributeLists, SyntaxToken forKeyword, SyntaxToken openParenToken, VariableDeclarationSyntax? declaration, GreenNode? initializers, SyntaxToken firstSemicolonToken, ExpressionSyntax? condition, SyntaxToken secondSemicolonToken, GreenNode? incrementors, SyntaxToken closeParenToken, StatementSyntax statement, SyntaxFactoryContext context)
          : base(kind)
        {
            this.SetFactoryContext(context);
            this.SlotCount = 11;
            if (attributeLists != null)
            {
                this.AdjustFlagsAndWidth(attributeLists);
                this.attributeLists = attributeLists;
            }
            this.AdjustFlagsAndWidth(forKeyword);
            this.forKeyword = forKeyword;
            this.AdjustFlagsAndWidth(openParenToken);
            this.openParenToken = openParenToken;
            if (declaration != null)
            {
                this.AdjustFlagsAndWidth(declaration);
                this.declaration = declaration;
            }
            if (initializers != null)
            {
                this.AdjustFlagsAndWidth(initializers);
                this.initializers = initializers;
            }
            this.AdjustFlagsAndWidth(firstSemicolonToken);
            this.firstSemicolonToken = firstSemicolonToken;
            if (condition != null)
            {
                this.AdjustFlagsAndWidth(condition);
                this.condition = condition;
            }
            this.AdjustFlagsAndWidth(secondSemicolonToken);
            this.secondSemicolonToken = secondSemicolonToken;
            if (incrementors != null)
            {
                this.AdjustFlagsAndWidth(incrementors);
                this.incrementors = incrementors;
            }
            this.AdjustFlagsAndWidth(closeParenToken);
            this.closeParenToken = closeParenToken;
            this.AdjustFlagsAndWidth(statement);
            this.statement = statement;
        }

        internal ForStatementSyntax(SyntaxKind kind, GreenNode? attributeLists, SyntaxToken forKeyword, SyntaxToken openParenToken, VariableDeclarationSyntax? declaration, GreenNode? initializers, SyntaxToken firstSemicolonToken, ExpressionSyntax? condition, SyntaxToken secondSemicolonToken, GreenNode? incrementors, SyntaxToken closeParenToken, StatementSyntax statement)
          : base(kind)
        {
            this.SlotCount = 11;
            if (attributeLists != null)
            {
                this.AdjustFlagsAndWidth(attributeLists);
                this.attributeLists = attributeLists;
            }
            this.AdjustFlagsAndWidth(forKeyword);
            this.forKeyword = forKeyword;
            this.AdjustFlagsAndWidth(openParenToken);
            this.openParenToken = openParenToken;
            if (declaration != null)
            {
                this.AdjustFlagsAndWidth(declaration);
                this.declaration = declaration;
            }
            if (initializers != null)
            {
                this.AdjustFlagsAndWidth(initializers);
                this.initializers = initializers;
            }
            this.AdjustFlagsAndWidth(firstSemicolonToken);
            this.firstSemicolonToken = firstSemicolonToken;
            if (condition != null)
            {
                this.AdjustFlagsAndWidth(condition);
                this.condition = condition;
            }
            this.AdjustFlagsAndWidth(secondSemicolonToken);
            this.secondSemicolonToken = secondSemicolonToken;
            if (incrementors != null)
            {
                this.AdjustFlagsAndWidth(incrementors);
                this.incrementors = incrementors;
            }
            this.AdjustFlagsAndWidth(closeParenToken);
            this.closeParenToken = closeParenToken;
            this.AdjustFlagsAndWidth(statement);
            this.statement = statement;
        }

        public override Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<AttributeListSyntax> AttributeLists => new Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<AttributeListSyntax>(this.attributeLists);
        public SyntaxToken ForKeyword => this.forKeyword;
        public SyntaxToken OpenParenToken => this.openParenToken;
        public VariableDeclarationSyntax? Declaration => this.declaration;
        public Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<ExpressionSyntax> Initializers => new Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<ExpressionSyntax>(new Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<CSharpSyntaxNode>(this.initializers));
        public SyntaxToken FirstSemicolonToken => this.firstSemicolonToken;
        public ExpressionSyntax? Condition => this.condition;
        public SyntaxToken SecondSemicolonToken => this.secondSemicolonToken;
        public Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<ExpressionSyntax> Incrementors => new Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<ExpressionSyntax>(new Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<CSharpSyntaxNode>(this.incrementors));
        public SyntaxToken CloseParenToken => this.closeParenToken;
        public StatementSyntax Statement => this.statement;

        internal override GreenNode? GetSlot(int index)
            => index switch
            {
                0 => this.attributeLists,
                1 => this.forKeyword,
                2 => this.openParenToken,
                3 => this.declaration,
                4 => this.initializers,
                5 => this.firstSemicolonToken,
                6 => this.condition,
                7 => this.secondSemicolonToken,
                8 => this.incrementors,
                9 => this.closeParenToken,
                10 => this.statement,
                _ => null,
            };

        internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new CSharp.Syntax.ForStatementSyntax(this, parent, position);

        public override void Accept(CSharpSyntaxVisitor visitor) => visitor.VisitForStatement(this);
        public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor) => visitor.VisitForStatement(this);

        public ForStatementSyntax Update(Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<AttributeListSyntax> attributeLists, SyntaxToken forKeyword, SyntaxToken openParenToken, VariableDeclarationSyntax declaration, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<ExpressionSyntax> initializers, SyntaxToken firstSemicolonToken, ExpressionSyntax condition, SyntaxToken secondSemicolonToken, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<ExpressionSyntax> incrementors, SyntaxToken closeParenToken, StatementSyntax statement)
        {
            if (attributeLists != this.AttributeLists || forKeyword != this.ForKeyword || openParenToken != this.OpenParenToken || declaration != this.Declaration || initializers != this.Initializers || firstSemicolonToken != this.FirstSemicolonToken || condition != this.Condition || secondSemicolonToken != this.SecondSemicolonToken || incrementors != this.Incrementors || closeParenToken != this.CloseParenToken || statement != this.Statement)
            {
                var newNode = SyntaxFactory.ForStatement(attributeLists, forKeyword, openParenToken, declaration, initializers, firstSemicolonToken, condition, secondSemicolonToken, incrementors, closeParenToken, statement);
                var diags = GetDiagnostics();
                if (diags?.Length > 0)
                    newNode = newNode.WithDiagnosticsGreen(diags);
                var annotations = GetAnnotations();
                if (annotations?.Length > 0)
                    newNode = newNode.WithAnnotationsGreen(annotations);
                return newNode;
            }

            return this;
        }

        internal override GreenNode SetDiagnostics(DiagnosticInfo[]? diagnostics)
            => new ForStatementSyntax(this.Kind, this.attributeLists, this.forKeyword, this.openParenToken, this.declaration, this.initializers, this.firstSemicolonToken, this.condition, this.secondSemicolonToken, this.incrementors, this.closeParenToken, this.statement, diagnostics, GetAnnotations());

        internal override GreenNode SetAnnotations(SyntaxAnnotation[]? annotations)
            => new ForStatementSyntax(this.Kind, this.attributeLists, this.forKeyword, this.openParenToken, this.declaration, this.initializers, this.firstSemicolonToken, this.condition, this.secondSemicolonToken, this.incrementors, this.closeParenToken, this.statement, GetDiagnostics(), annotations);

        internal ForStatementSyntax(ObjectReader reader)
          : base(reader)
        {
            this.SlotCount = 11;
            var attributeLists = (GreenNode?)reader.ReadValue();
            if (attributeLists != null)
            {
                AdjustFlagsAndWidth(attributeLists);
                this.attributeLists = attributeLists;
            }
            var forKeyword = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(forKeyword);
            this.forKeyword = forKeyword;
            var openParenToken = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(openParenToken);
            this.openParenToken = openParenToken;
            var declaration = (VariableDeclarationSyntax?)reader.ReadValue();
            if (declaration != null)
            {
                AdjustFlagsAndWidth(declaration);
                this.declaration = declaration;
            }
            var initializers = (GreenNode?)reader.ReadValue();
            if (initializers != null)
            {
                AdjustFlagsAndWidth(initializers);
                this.initializers = initializers;
            }
            var firstSemicolonToken = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(firstSemicolonToken);
            this.firstSemicolonToken = firstSemicolonToken;
            var condition = (ExpressionSyntax?)reader.ReadValue();
            if (condition != null)
            {
                AdjustFlagsAndWidth(condition);
                this.condition = condition;
            }
            var secondSemicolonToken = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(secondSemicolonToken);
            this.secondSemicolonToken = secondSemicolonToken;
            var incrementors = (GreenNode?)reader.ReadValue();
            if (incrementors != null)
            {
                AdjustFlagsAndWidth(incrementors);
                this.incrementors = incrementors;
            }
            var closeParenToken = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(closeParenToken);
            this.closeParenToken = closeParenToken;
            var statement = (StatementSyntax)reader.ReadValue();
            AdjustFlagsAndWidth(statement);
            this.statement = statement;
        }

        internal override void WriteTo(ObjectWriter writer)
        {
            base.WriteTo(writer);
            writer.WriteValue(this.attributeLists);
            writer.WriteValue(this.forKeyword);
            writer.WriteValue(this.openParenToken);
            writer.WriteValue(this.declaration);
            writer.WriteValue(this.initializers);
            writer.WriteValue(this.firstSemicolonToken);
            writer.WriteValue(this.condition);
            writer.WriteValue(this.secondSemicolonToken);
            writer.WriteValue(this.incrementors);
            writer.WriteValue(this.closeParenToken);
            writer.WriteValue(this.statement);
        }

        static ForStatementSyntax()
        {
            ObjectBinder.RegisterTypeReader(typeof(ForStatementSyntax), r => new ForStatementSyntax(r));
        }
    }

    internal abstract partial class CommonForEachStatementSyntax : StatementSyntax
    {
        internal CommonForEachStatementSyntax(SyntaxKind kind, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
        }

        internal CommonForEachStatementSyntax(SyntaxKind kind)
          : base(kind)
        {
        }

        protected CommonForEachStatementSyntax(ObjectReader reader)
          : base(reader)
        {
        }

        public abstract SyntaxToken? AwaitKeyword { get; }

        public abstract SyntaxToken ForEachKeyword { get; }

        public abstract SyntaxToken OpenParenToken { get; }

        public abstract SyntaxToken InKeyword { get; }

        public abstract ExpressionSyntax Expression { get; }

        public abstract SyntaxToken CloseParenToken { get; }

        public abstract StatementSyntax Statement { get; }
    }

    internal sealed partial class ForEachStatementSyntax : CommonForEachStatementSyntax
    {
        internal readonly GreenNode? attributeLists;
        internal readonly SyntaxToken? awaitKeyword;
        internal readonly SyntaxToken forEachKeyword;
        internal readonly SyntaxToken openParenToken;
        internal readonly TypeSyntax type;
        internal readonly SyntaxToken identifier;
        internal readonly SyntaxToken inKeyword;
        internal readonly ExpressionSyntax expression;
        internal readonly SyntaxToken closeParenToken;
        internal readonly StatementSyntax statement;

        internal ForEachStatementSyntax(SyntaxKind kind, GreenNode? attributeLists, SyntaxToken? awaitKeyword, SyntaxToken forEachKeyword, SyntaxToken openParenToken, TypeSyntax type, SyntaxToken identifier, SyntaxToken inKeyword, ExpressionSyntax expression, SyntaxToken closeParenToken, StatementSyntax statement, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
            this.SlotCount = 10;
            if (attributeLists != null)
            {
                this.AdjustFlagsAndWidth(attributeLists);
                this.attributeLists = attributeLists;
            }
            if (awaitKeyword != null)
            {
                this.AdjustFlagsAndWidth(awaitKeyword);
                this.awaitKeyword = awaitKeyword;
            }
            this.AdjustFlagsAndWidth(forEachKeyword);
            this.forEachKeyword = forEachKeyword;
            this.AdjustFlagsAndWidth(openParenToken);
            this.openParenToken = openParenToken;
            this.AdjustFlagsAndWidth(type);
            this.type = type;
            this.AdjustFlagsAndWidth(identifier);
            this.identifier = identifier;
            this.AdjustFlagsAndWidth(inKeyword);
            this.inKeyword = inKeyword;
            this.AdjustFlagsAndWidth(expression);
            this.expression = expression;
            this.AdjustFlagsAndWidth(closeParenToken);
            this.closeParenToken = closeParenToken;
            this.AdjustFlagsAndWidth(statement);
            this.statement = statement;
        }

        internal ForEachStatementSyntax(SyntaxKind kind, GreenNode? attributeLists, SyntaxToken? awaitKeyword, SyntaxToken forEachKeyword, SyntaxToken openParenToken, TypeSyntax type, SyntaxToken identifier, SyntaxToken inKeyword, ExpressionSyntax expression, SyntaxToken closeParenToken, StatementSyntax statement, SyntaxFactoryContext context)
          : base(kind)
        {
            this.SetFactoryContext(context);
            this.SlotCount = 10;
            if (attributeLists != null)
            {
                this.AdjustFlagsAndWidth(attributeLists);
                this.attributeLists = attributeLists;
            }
            if (awaitKeyword != null)
            {
                this.AdjustFlagsAndWidth(awaitKeyword);
                this.awaitKeyword = awaitKeyword;
            }
            this.AdjustFlagsAndWidth(forEachKeyword);
            this.forEachKeyword = forEachKeyword;
            this.AdjustFlagsAndWidth(openParenToken);
            this.openParenToken = openParenToken;
            this.AdjustFlagsAndWidth(type);
            this.type = type;
            this.AdjustFlagsAndWidth(identifier);
            this.identifier = identifier;
            this.AdjustFlagsAndWidth(inKeyword);
            this.inKeyword = inKeyword;
            this.AdjustFlagsAndWidth(expression);
            this.expression = expression;
            this.AdjustFlagsAndWidth(closeParenToken);
            this.closeParenToken = closeParenToken;
            this.AdjustFlagsAndWidth(statement);
            this.statement = statement;
        }

        internal ForEachStatementSyntax(SyntaxKind kind, GreenNode? attributeLists, SyntaxToken? awaitKeyword, SyntaxToken forEachKeyword, SyntaxToken openParenToken, TypeSyntax type, SyntaxToken identifier, SyntaxToken inKeyword, ExpressionSyntax expression, SyntaxToken closeParenToken, StatementSyntax statement)
          : base(kind)
        {
            this.SlotCount = 10;
            if (attributeLists != null)
            {
                this.AdjustFlagsAndWidth(attributeLists);
                this.attributeLists = attributeLists;
            }
            if (awaitKeyword != null)
            {
                this.AdjustFlagsAndWidth(awaitKeyword);
                this.awaitKeyword = awaitKeyword;
            }
            this.AdjustFlagsAndWidth(forEachKeyword);
            this.forEachKeyword = forEachKeyword;
            this.AdjustFlagsAndWidth(openParenToken);
            this.openParenToken = openParenToken;
            this.AdjustFlagsAndWidth(type);
            this.type = type;
            this.AdjustFlagsAndWidth(identifier);
            this.identifier = identifier;
            this.AdjustFlagsAndWidth(inKeyword);
            this.inKeyword = inKeyword;
            this.AdjustFlagsAndWidth(expression);
            this.expression = expression;
            this.AdjustFlagsAndWidth(closeParenToken);
            this.closeParenToken = closeParenToken;
            this.AdjustFlagsAndWidth(statement);
            this.statement = statement;
        }

        public override Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<AttributeListSyntax> AttributeLists => new Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<AttributeListSyntax>(this.attributeLists);
        public override SyntaxToken? AwaitKeyword => this.awaitKeyword;
        public override SyntaxToken ForEachKeyword => this.forEachKeyword;
        public override SyntaxToken OpenParenToken => this.openParenToken;
        public TypeSyntax Type => this.type;
        /// <summary>Gets the identifier.</summary>
        public SyntaxToken Identifier => this.identifier;
        public override SyntaxToken InKeyword => this.inKeyword;
        public override ExpressionSyntax Expression => this.expression;
        public override SyntaxToken CloseParenToken => this.closeParenToken;
        public override StatementSyntax Statement => this.statement;

        internal override GreenNode? GetSlot(int index)
            => index switch
            {
                0 => this.attributeLists,
                1 => this.awaitKeyword,
                2 => this.forEachKeyword,
                3 => this.openParenToken,
                4 => this.type,
                5 => this.identifier,
                6 => this.inKeyword,
                7 => this.expression,
                8 => this.closeParenToken,
                9 => this.statement,
                _ => null,
            };

        internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new CSharp.Syntax.ForEachStatementSyntax(this, parent, position);

        public override void Accept(CSharpSyntaxVisitor visitor) => visitor.VisitForEachStatement(this);
        public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor) => visitor.VisitForEachStatement(this);

        public ForEachStatementSyntax Update(Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<AttributeListSyntax> attributeLists, SyntaxToken awaitKeyword, SyntaxToken forEachKeyword, SyntaxToken openParenToken, TypeSyntax type, SyntaxToken identifier, SyntaxToken inKeyword, ExpressionSyntax expression, SyntaxToken closeParenToken, StatementSyntax statement)
        {
            if (attributeLists != this.AttributeLists || awaitKeyword != this.AwaitKeyword || forEachKeyword != this.ForEachKeyword || openParenToken != this.OpenParenToken || type != this.Type || identifier != this.Identifier || inKeyword != this.InKeyword || expression != this.Expression || closeParenToken != this.CloseParenToken || statement != this.Statement)
            {
                var newNode = SyntaxFactory.ForEachStatement(attributeLists, awaitKeyword, forEachKeyword, openParenToken, type, identifier, inKeyword, expression, closeParenToken, statement);
                var diags = GetDiagnostics();
                if (diags?.Length > 0)
                    newNode = newNode.WithDiagnosticsGreen(diags);
                var annotations = GetAnnotations();
                if (annotations?.Length > 0)
                    newNode = newNode.WithAnnotationsGreen(annotations);
                return newNode;
            }

            return this;
        }

        internal override GreenNode SetDiagnostics(DiagnosticInfo[]? diagnostics)
            => new ForEachStatementSyntax(this.Kind, this.attributeLists, this.awaitKeyword, this.forEachKeyword, this.openParenToken, this.type, this.identifier, this.inKeyword, this.expression, this.closeParenToken, this.statement, diagnostics, GetAnnotations());

        internal override GreenNode SetAnnotations(SyntaxAnnotation[]? annotations)
            => new ForEachStatementSyntax(this.Kind, this.attributeLists, this.awaitKeyword, this.forEachKeyword, this.openParenToken, this.type, this.identifier, this.inKeyword, this.expression, this.closeParenToken, this.statement, GetDiagnostics(), annotations);

        internal ForEachStatementSyntax(ObjectReader reader)
          : base(reader)
        {
            this.SlotCount = 10;
            var attributeLists = (GreenNode?)reader.ReadValue();
            if (attributeLists != null)
            {
                AdjustFlagsAndWidth(attributeLists);
                this.attributeLists = attributeLists;
            }
            var awaitKeyword = (SyntaxToken?)reader.ReadValue();
            if (awaitKeyword != null)
            {
                AdjustFlagsAndWidth(awaitKeyword);
                this.awaitKeyword = awaitKeyword;
            }
            var forEachKeyword = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(forEachKeyword);
            this.forEachKeyword = forEachKeyword;
            var openParenToken = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(openParenToken);
            this.openParenToken = openParenToken;
            var type = (TypeSyntax)reader.ReadValue();
            AdjustFlagsAndWidth(type);
            this.type = type;
            var identifier = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(identifier);
            this.identifier = identifier;
            var inKeyword = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(inKeyword);
            this.inKeyword = inKeyword;
            var expression = (ExpressionSyntax)reader.ReadValue();
            AdjustFlagsAndWidth(expression);
            this.expression = expression;
            var closeParenToken = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(closeParenToken);
            this.closeParenToken = closeParenToken;
            var statement = (StatementSyntax)reader.ReadValue();
            AdjustFlagsAndWidth(statement);
            this.statement = statement;
        }

        internal override void WriteTo(ObjectWriter writer)
        {
            base.WriteTo(writer);
            writer.WriteValue(this.attributeLists);
            writer.WriteValue(this.awaitKeyword);
            writer.WriteValue(this.forEachKeyword);
            writer.WriteValue(this.openParenToken);
            writer.WriteValue(this.type);
            writer.WriteValue(this.identifier);
            writer.WriteValue(this.inKeyword);
            writer.WriteValue(this.expression);
            writer.WriteValue(this.closeParenToken);
            writer.WriteValue(this.statement);
        }

        static ForEachStatementSyntax()
        {
            ObjectBinder.RegisterTypeReader(typeof(ForEachStatementSyntax), r => new ForEachStatementSyntax(r));
        }
    }

    internal sealed partial class ForEachVariableStatementSyntax : CommonForEachStatementSyntax
    {
        internal readonly GreenNode? attributeLists;
        internal readonly SyntaxToken? awaitKeyword;
        internal readonly SyntaxToken forEachKeyword;
        internal readonly SyntaxToken openParenToken;
        internal readonly ExpressionSyntax variable;
        internal readonly SyntaxToken inKeyword;
        internal readonly ExpressionSyntax expression;
        internal readonly SyntaxToken closeParenToken;
        internal readonly StatementSyntax statement;

        internal ForEachVariableStatementSyntax(SyntaxKind kind, GreenNode? attributeLists, SyntaxToken? awaitKeyword, SyntaxToken forEachKeyword, SyntaxToken openParenToken, ExpressionSyntax variable, SyntaxToken inKeyword, ExpressionSyntax expression, SyntaxToken closeParenToken, StatementSyntax statement, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
            this.SlotCount = 9;
            if (attributeLists != null)
            {
                this.AdjustFlagsAndWidth(attributeLists);
                this.attributeLists = attributeLists;
            }
            if (awaitKeyword != null)
            {
                this.AdjustFlagsAndWidth(awaitKeyword);
                this.awaitKeyword = awaitKeyword;
            }
            this.AdjustFlagsAndWidth(forEachKeyword);
            this.forEachKeyword = forEachKeyword;
            this.AdjustFlagsAndWidth(openParenToken);
            this.openParenToken = openParenToken;
            this.AdjustFlagsAndWidth(variable);
            this.variable = variable;
            this.AdjustFlagsAndWidth(inKeyword);
            this.inKeyword = inKeyword;
            this.AdjustFlagsAndWidth(expression);
            this.expression = expression;
            this.AdjustFlagsAndWidth(closeParenToken);
            this.closeParenToken = closeParenToken;
            this.AdjustFlagsAndWidth(statement);
            this.statement = statement;
        }

        internal ForEachVariableStatementSyntax(SyntaxKind kind, GreenNode? attributeLists, SyntaxToken? awaitKeyword, SyntaxToken forEachKeyword, SyntaxToken openParenToken, ExpressionSyntax variable, SyntaxToken inKeyword, ExpressionSyntax expression, SyntaxToken closeParenToken, StatementSyntax statement, SyntaxFactoryContext context)
          : base(kind)
        {
            this.SetFactoryContext(context);
            this.SlotCount = 9;
            if (attributeLists != null)
            {
                this.AdjustFlagsAndWidth(attributeLists);
                this.attributeLists = attributeLists;
            }
            if (awaitKeyword != null)
            {
                this.AdjustFlagsAndWidth(awaitKeyword);
                this.awaitKeyword = awaitKeyword;
            }
            this.AdjustFlagsAndWidth(forEachKeyword);
            this.forEachKeyword = forEachKeyword;
            this.AdjustFlagsAndWidth(openParenToken);
            this.openParenToken = openParenToken;
            this.AdjustFlagsAndWidth(variable);
            this.variable = variable;
            this.AdjustFlagsAndWidth(inKeyword);
            this.inKeyword = inKeyword;
            this.AdjustFlagsAndWidth(expression);
            this.expression = expression;
            this.AdjustFlagsAndWidth(closeParenToken);
            this.closeParenToken = closeParenToken;
            this.AdjustFlagsAndWidth(statement);
            this.statement = statement;
        }

        internal ForEachVariableStatementSyntax(SyntaxKind kind, GreenNode? attributeLists, SyntaxToken? awaitKeyword, SyntaxToken forEachKeyword, SyntaxToken openParenToken, ExpressionSyntax variable, SyntaxToken inKeyword, ExpressionSyntax expression, SyntaxToken closeParenToken, StatementSyntax statement)
          : base(kind)
        {
            this.SlotCount = 9;
            if (attributeLists != null)
            {
                this.AdjustFlagsAndWidth(attributeLists);
                this.attributeLists = attributeLists;
            }
            if (awaitKeyword != null)
            {
                this.AdjustFlagsAndWidth(awaitKeyword);
                this.awaitKeyword = awaitKeyword;
            }
            this.AdjustFlagsAndWidth(forEachKeyword);
            this.forEachKeyword = forEachKeyword;
            this.AdjustFlagsAndWidth(openParenToken);
            this.openParenToken = openParenToken;
            this.AdjustFlagsAndWidth(variable);
            this.variable = variable;
            this.AdjustFlagsAndWidth(inKeyword);
            this.inKeyword = inKeyword;
            this.AdjustFlagsAndWidth(expression);
            this.expression = expression;
            this.AdjustFlagsAndWidth(closeParenToken);
            this.closeParenToken = closeParenToken;
            this.AdjustFlagsAndWidth(statement);
            this.statement = statement;
        }

        public override Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<AttributeListSyntax> AttributeLists => new Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<AttributeListSyntax>(this.attributeLists);
        public override SyntaxToken? AwaitKeyword => this.awaitKeyword;
        public override SyntaxToken ForEachKeyword => this.forEachKeyword;
        public override SyntaxToken OpenParenToken => this.openParenToken;
        /// <summary>
        /// The variable(s) of the loop. In correct code this is a tuple
        /// literal, declaration expression with a tuple designator, or
        /// a discard syntax in the form of a simple identifier. In broken
        /// code it could be something else.
        /// </summary>
        public ExpressionSyntax Variable => this.variable;
        public override SyntaxToken InKeyword => this.inKeyword;
        public override ExpressionSyntax Expression => this.expression;
        public override SyntaxToken CloseParenToken => this.closeParenToken;
        public override StatementSyntax Statement => this.statement;

        internal override GreenNode? GetSlot(int index)
            => index switch
            {
                0 => this.attributeLists,
                1 => this.awaitKeyword,
                2 => this.forEachKeyword,
                3 => this.openParenToken,
                4 => this.variable,
                5 => this.inKeyword,
                6 => this.expression,
                7 => this.closeParenToken,
                8 => this.statement,
                _ => null,
            };

        internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new CSharp.Syntax.ForEachVariableStatementSyntax(this, parent, position);

        public override void Accept(CSharpSyntaxVisitor visitor) => visitor.VisitForEachVariableStatement(this);
        public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor) => visitor.VisitForEachVariableStatement(this);

        public ForEachVariableStatementSyntax Update(Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<AttributeListSyntax> attributeLists, SyntaxToken awaitKeyword, SyntaxToken forEachKeyword, SyntaxToken openParenToken, ExpressionSyntax variable, SyntaxToken inKeyword, ExpressionSyntax expression, SyntaxToken closeParenToken, StatementSyntax statement)
        {
            if (attributeLists != this.AttributeLists || awaitKeyword != this.AwaitKeyword || forEachKeyword != this.ForEachKeyword || openParenToken != this.OpenParenToken || variable != this.Variable || inKeyword != this.InKeyword || expression != this.Expression || closeParenToken != this.CloseParenToken || statement != this.Statement)
            {
                var newNode = SyntaxFactory.ForEachVariableStatement(attributeLists, awaitKeyword, forEachKeyword, openParenToken, variable, inKeyword, expression, closeParenToken, statement);
                var diags = GetDiagnostics();
                if (diags?.Length > 0)
                    newNode = newNode.WithDiagnosticsGreen(diags);
                var annotations = GetAnnotations();
                if (annotations?.Length > 0)
                    newNode = newNode.WithAnnotationsGreen(annotations);
                return newNode;
            }

            return this;
        }

        internal override GreenNode SetDiagnostics(DiagnosticInfo[]? diagnostics)
            => new ForEachVariableStatementSyntax(this.Kind, this.attributeLists, this.awaitKeyword, this.forEachKeyword, this.openParenToken, this.variable, this.inKeyword, this.expression, this.closeParenToken, this.statement, diagnostics, GetAnnotations());

        internal override GreenNode SetAnnotations(SyntaxAnnotation[]? annotations)
            => new ForEachVariableStatementSyntax(this.Kind, this.attributeLists, this.awaitKeyword, this.forEachKeyword, this.openParenToken, this.variable, this.inKeyword, this.expression, this.closeParenToken, this.statement, GetDiagnostics(), annotations);

        internal ForEachVariableStatementSyntax(ObjectReader reader)
          : base(reader)
        {
            this.SlotCount = 9;
            var attributeLists = (GreenNode?)reader.ReadValue();
            if (attributeLists != null)
            {
                AdjustFlagsAndWidth(attributeLists);
                this.attributeLists = attributeLists;
            }
            var awaitKeyword = (SyntaxToken?)reader.ReadValue();
            if (awaitKeyword != null)
            {
                AdjustFlagsAndWidth(awaitKeyword);
                this.awaitKeyword = awaitKeyword;
            }
            var forEachKeyword = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(forEachKeyword);
            this.forEachKeyword = forEachKeyword;
            var openParenToken = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(openParenToken);
            this.openParenToken = openParenToken;
            var variable = (ExpressionSyntax)reader.ReadValue();
            AdjustFlagsAndWidth(variable);
            this.variable = variable;
            var inKeyword = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(inKeyword);
            this.inKeyword = inKeyword;
            var expression = (ExpressionSyntax)reader.ReadValue();
            AdjustFlagsAndWidth(expression);
            this.expression = expression;
            var closeParenToken = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(closeParenToken);
            this.closeParenToken = closeParenToken;
            var statement = (StatementSyntax)reader.ReadValue();
            AdjustFlagsAndWidth(statement);
            this.statement = statement;
        }

        internal override void WriteTo(ObjectWriter writer)
        {
            base.WriteTo(writer);
            writer.WriteValue(this.attributeLists);
            writer.WriteValue(this.awaitKeyword);
            writer.WriteValue(this.forEachKeyword);
            writer.WriteValue(this.openParenToken);
            writer.WriteValue(this.variable);
            writer.WriteValue(this.inKeyword);
            writer.WriteValue(this.expression);
            writer.WriteValue(this.closeParenToken);
            writer.WriteValue(this.statement);
        }

        static ForEachVariableStatementSyntax()
        {
            ObjectBinder.RegisterTypeReader(typeof(ForEachVariableStatementSyntax), r => new ForEachVariableStatementSyntax(r));
        }
    }

    internal sealed partial class UsingStatementSyntax : StatementSyntax
    {
        internal readonly GreenNode? attributeLists;
        internal readonly SyntaxToken? awaitKeyword;
        internal readonly SyntaxToken usingKeyword;
        internal readonly SyntaxToken openParenToken;
        internal readonly VariableDeclarationSyntax? declaration;
        internal readonly ExpressionSyntax? expression;
        internal readonly SyntaxToken closeParenToken;
        internal readonly StatementSyntax statement;

        internal UsingStatementSyntax(SyntaxKind kind, GreenNode? attributeLists, SyntaxToken? awaitKeyword, SyntaxToken usingKeyword, SyntaxToken openParenToken, VariableDeclarationSyntax? declaration, ExpressionSyntax? expression, SyntaxToken closeParenToken, StatementSyntax statement, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
            this.SlotCount = 8;
            if (attributeLists != null)
            {
                this.AdjustFlagsAndWidth(attributeLists);
                this.attributeLists = attributeLists;
            }
            if (awaitKeyword != null)
            {
                this.AdjustFlagsAndWidth(awaitKeyword);
                this.awaitKeyword = awaitKeyword;
            }
            this.AdjustFlagsAndWidth(usingKeyword);
            this.usingKeyword = usingKeyword;
            this.AdjustFlagsAndWidth(openParenToken);
            this.openParenToken = openParenToken;
            if (declaration != null)
            {
                this.AdjustFlagsAndWidth(declaration);
                this.declaration = declaration;
            }
            if (expression != null)
            {
                this.AdjustFlagsAndWidth(expression);
                this.expression = expression;
            }
            this.AdjustFlagsAndWidth(closeParenToken);
            this.closeParenToken = closeParenToken;
            this.AdjustFlagsAndWidth(statement);
            this.statement = statement;
        }

        internal UsingStatementSyntax(SyntaxKind kind, GreenNode? attributeLists, SyntaxToken? awaitKeyword, SyntaxToken usingKeyword, SyntaxToken openParenToken, VariableDeclarationSyntax? declaration, ExpressionSyntax? expression, SyntaxToken closeParenToken, StatementSyntax statement, SyntaxFactoryContext context)
          : base(kind)
        {
            this.SetFactoryContext(context);
            this.SlotCount = 8;
            if (attributeLists != null)
            {
                this.AdjustFlagsAndWidth(attributeLists);
                this.attributeLists = attributeLists;
            }
            if (awaitKeyword != null)
            {
                this.AdjustFlagsAndWidth(awaitKeyword);
                this.awaitKeyword = awaitKeyword;
            }
            this.AdjustFlagsAndWidth(usingKeyword);
            this.usingKeyword = usingKeyword;
            this.AdjustFlagsAndWidth(openParenToken);
            this.openParenToken = openParenToken;
            if (declaration != null)
            {
                this.AdjustFlagsAndWidth(declaration);
                this.declaration = declaration;
            }
            if (expression != null)
            {
                this.AdjustFlagsAndWidth(expression);
                this.expression = expression;
            }
            this.AdjustFlagsAndWidth(closeParenToken);
            this.closeParenToken = closeParenToken;
            this.AdjustFlagsAndWidth(statement);
            this.statement = statement;
        }

        internal UsingStatementSyntax(SyntaxKind kind, GreenNode? attributeLists, SyntaxToken? awaitKeyword, SyntaxToken usingKeyword, SyntaxToken openParenToken, VariableDeclarationSyntax? declaration, ExpressionSyntax? expression, SyntaxToken closeParenToken, StatementSyntax statement)
          : base(kind)
        {
            this.SlotCount = 8;
            if (attributeLists != null)
            {
                this.AdjustFlagsAndWidth(attributeLists);
                this.attributeLists = attributeLists;
            }
            if (awaitKeyword != null)
            {
                this.AdjustFlagsAndWidth(awaitKeyword);
                this.awaitKeyword = awaitKeyword;
            }
            this.AdjustFlagsAndWidth(usingKeyword);
            this.usingKeyword = usingKeyword;
            this.AdjustFlagsAndWidth(openParenToken);
            this.openParenToken = openParenToken;
            if (declaration != null)
            {
                this.AdjustFlagsAndWidth(declaration);
                this.declaration = declaration;
            }
            if (expression != null)
            {
                this.AdjustFlagsAndWidth(expression);
                this.expression = expression;
            }
            this.AdjustFlagsAndWidth(closeParenToken);
            this.closeParenToken = closeParenToken;
            this.AdjustFlagsAndWidth(statement);
            this.statement = statement;
        }

        public override Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<AttributeListSyntax> AttributeLists => new Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<AttributeListSyntax>(this.attributeLists);
        public SyntaxToken? AwaitKeyword => this.awaitKeyword;
        public SyntaxToken UsingKeyword => this.usingKeyword;
        public SyntaxToken OpenParenToken => this.openParenToken;
        public VariableDeclarationSyntax? Declaration => this.declaration;
        public ExpressionSyntax? Expression => this.expression;
        public SyntaxToken CloseParenToken => this.closeParenToken;
        public StatementSyntax Statement => this.statement;

        internal override GreenNode? GetSlot(int index)
            => index switch
            {
                0 => this.attributeLists,
                1 => this.awaitKeyword,
                2 => this.usingKeyword,
                3 => this.openParenToken,
                4 => this.declaration,
                5 => this.expression,
                6 => this.closeParenToken,
                7 => this.statement,
                _ => null,
            };

        internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new CSharp.Syntax.UsingStatementSyntax(this, parent, position);

        public override void Accept(CSharpSyntaxVisitor visitor) => visitor.VisitUsingStatement(this);
        public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor) => visitor.VisitUsingStatement(this);

        public UsingStatementSyntax Update(Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<AttributeListSyntax> attributeLists, SyntaxToken awaitKeyword, SyntaxToken usingKeyword, SyntaxToken openParenToken, VariableDeclarationSyntax declaration, ExpressionSyntax expression, SyntaxToken closeParenToken, StatementSyntax statement)
        {
            if (attributeLists != this.AttributeLists || awaitKeyword != this.AwaitKeyword || usingKeyword != this.UsingKeyword || openParenToken != this.OpenParenToken || declaration != this.Declaration || expression != this.Expression || closeParenToken != this.CloseParenToken || statement != this.Statement)
            {
                var newNode = SyntaxFactory.UsingStatement(attributeLists, awaitKeyword, usingKeyword, openParenToken, declaration, expression, closeParenToken, statement);
                var diags = GetDiagnostics();
                if (diags?.Length > 0)
                    newNode = newNode.WithDiagnosticsGreen(diags);
                var annotations = GetAnnotations();
                if (annotations?.Length > 0)
                    newNode = newNode.WithAnnotationsGreen(annotations);
                return newNode;
            }

            return this;
        }

        internal override GreenNode SetDiagnostics(DiagnosticInfo[]? diagnostics)
            => new UsingStatementSyntax(this.Kind, this.attributeLists, this.awaitKeyword, this.usingKeyword, this.openParenToken, this.declaration, this.expression, this.closeParenToken, this.statement, diagnostics, GetAnnotations());

        internal override GreenNode SetAnnotations(SyntaxAnnotation[]? annotations)
            => new UsingStatementSyntax(this.Kind, this.attributeLists, this.awaitKeyword, this.usingKeyword, this.openParenToken, this.declaration, this.expression, this.closeParenToken, this.statement, GetDiagnostics(), annotations);

        internal UsingStatementSyntax(ObjectReader reader)
          : base(reader)
        {
            this.SlotCount = 8;
            var attributeLists = (GreenNode?)reader.ReadValue();
            if (attributeLists != null)
            {
                AdjustFlagsAndWidth(attributeLists);
                this.attributeLists = attributeLists;
            }
            var awaitKeyword = (SyntaxToken?)reader.ReadValue();
            if (awaitKeyword != null)
            {
                AdjustFlagsAndWidth(awaitKeyword);
                this.awaitKeyword = awaitKeyword;
            }
            var usingKeyword = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(usingKeyword);
            this.usingKeyword = usingKeyword;
            var openParenToken = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(openParenToken);
            this.openParenToken = openParenToken;
            var declaration = (VariableDeclarationSyntax?)reader.ReadValue();
            if (declaration != null)
            {
                AdjustFlagsAndWidth(declaration);
                this.declaration = declaration;
            }
            var expression = (ExpressionSyntax?)reader.ReadValue();
            if (expression != null)
            {
                AdjustFlagsAndWidth(expression);
                this.expression = expression;
            }
            var closeParenToken = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(closeParenToken);
            this.closeParenToken = closeParenToken;
            var statement = (StatementSyntax)reader.ReadValue();
            AdjustFlagsAndWidth(statement);
            this.statement = statement;
        }

        internal override void WriteTo(ObjectWriter writer)
        {
            base.WriteTo(writer);
            writer.WriteValue(this.attributeLists);
            writer.WriteValue(this.awaitKeyword);
            writer.WriteValue(this.usingKeyword);
            writer.WriteValue(this.openParenToken);
            writer.WriteValue(this.declaration);
            writer.WriteValue(this.expression);
            writer.WriteValue(this.closeParenToken);
            writer.WriteValue(this.statement);
        }

        static UsingStatementSyntax()
        {
            ObjectBinder.RegisterTypeReader(typeof(UsingStatementSyntax), r => new UsingStatementSyntax(r));
        }
    }

    internal sealed partial class FixedStatementSyntax : StatementSyntax
    {
        internal readonly GreenNode? attributeLists;
        internal readonly SyntaxToken fixedKeyword;
        internal readonly SyntaxToken openParenToken;
        internal readonly VariableDeclarationSyntax declaration;
        internal readonly SyntaxToken closeParenToken;
        internal readonly StatementSyntax statement;

        internal FixedStatementSyntax(SyntaxKind kind, GreenNode? attributeLists, SyntaxToken fixedKeyword, SyntaxToken openParenToken, VariableDeclarationSyntax declaration, SyntaxToken closeParenToken, StatementSyntax statement, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
            this.SlotCount = 6;
            if (attributeLists != null)
            {
                this.AdjustFlagsAndWidth(attributeLists);
                this.attributeLists = attributeLists;
            }
            this.AdjustFlagsAndWidth(fixedKeyword);
            this.fixedKeyword = fixedKeyword;
            this.AdjustFlagsAndWidth(openParenToken);
            this.openParenToken = openParenToken;
            this.AdjustFlagsAndWidth(declaration);
            this.declaration = declaration;
            this.AdjustFlagsAndWidth(closeParenToken);
            this.closeParenToken = closeParenToken;
            this.AdjustFlagsAndWidth(statement);
            this.statement = statement;
        }

        internal FixedStatementSyntax(SyntaxKind kind, GreenNode? attributeLists, SyntaxToken fixedKeyword, SyntaxToken openParenToken, VariableDeclarationSyntax declaration, SyntaxToken closeParenToken, StatementSyntax statement, SyntaxFactoryContext context)
          : base(kind)
        {
            this.SetFactoryContext(context);
            this.SlotCount = 6;
            if (attributeLists != null)
            {
                this.AdjustFlagsAndWidth(attributeLists);
                this.attributeLists = attributeLists;
            }
            this.AdjustFlagsAndWidth(fixedKeyword);
            this.fixedKeyword = fixedKeyword;
            this.AdjustFlagsAndWidth(openParenToken);
            this.openParenToken = openParenToken;
            this.AdjustFlagsAndWidth(declaration);
            this.declaration = declaration;
            this.AdjustFlagsAndWidth(closeParenToken);
            this.closeParenToken = closeParenToken;
            this.AdjustFlagsAndWidth(statement);
            this.statement = statement;
        }

        internal FixedStatementSyntax(SyntaxKind kind, GreenNode? attributeLists, SyntaxToken fixedKeyword, SyntaxToken openParenToken, VariableDeclarationSyntax declaration, SyntaxToken closeParenToken, StatementSyntax statement)
          : base(kind)
        {
            this.SlotCount = 6;
            if (attributeLists != null)
            {
                this.AdjustFlagsAndWidth(attributeLists);
                this.attributeLists = attributeLists;
            }
            this.AdjustFlagsAndWidth(fixedKeyword);
            this.fixedKeyword = fixedKeyword;
            this.AdjustFlagsAndWidth(openParenToken);
            this.openParenToken = openParenToken;
            this.AdjustFlagsAndWidth(declaration);
            this.declaration = declaration;
            this.AdjustFlagsAndWidth(closeParenToken);
            this.closeParenToken = closeParenToken;
            this.AdjustFlagsAndWidth(statement);
            this.statement = statement;
        }

        public override Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<AttributeListSyntax> AttributeLists => new Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<AttributeListSyntax>(this.attributeLists);
        public SyntaxToken FixedKeyword => this.fixedKeyword;
        public SyntaxToken OpenParenToken => this.openParenToken;
        public VariableDeclarationSyntax Declaration => this.declaration;
        public SyntaxToken CloseParenToken => this.closeParenToken;
        public StatementSyntax Statement => this.statement;

        internal override GreenNode? GetSlot(int index)
            => index switch
            {
                0 => this.attributeLists,
                1 => this.fixedKeyword,
                2 => this.openParenToken,
                3 => this.declaration,
                4 => this.closeParenToken,
                5 => this.statement,
                _ => null,
            };

        internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new CSharp.Syntax.FixedStatementSyntax(this, parent, position);

        public override void Accept(CSharpSyntaxVisitor visitor) => visitor.VisitFixedStatement(this);
        public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor) => visitor.VisitFixedStatement(this);

        public FixedStatementSyntax Update(Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<AttributeListSyntax> attributeLists, SyntaxToken fixedKeyword, SyntaxToken openParenToken, VariableDeclarationSyntax declaration, SyntaxToken closeParenToken, StatementSyntax statement)
        {
            if (attributeLists != this.AttributeLists || fixedKeyword != this.FixedKeyword || openParenToken != this.OpenParenToken || declaration != this.Declaration || closeParenToken != this.CloseParenToken || statement != this.Statement)
            {
                var newNode = SyntaxFactory.FixedStatement(attributeLists, fixedKeyword, openParenToken, declaration, closeParenToken, statement);
                var diags = GetDiagnostics();
                if (diags?.Length > 0)
                    newNode = newNode.WithDiagnosticsGreen(diags);
                var annotations = GetAnnotations();
                if (annotations?.Length > 0)
                    newNode = newNode.WithAnnotationsGreen(annotations);
                return newNode;
            }

            return this;
        }

        internal override GreenNode SetDiagnostics(DiagnosticInfo[]? diagnostics)
            => new FixedStatementSyntax(this.Kind, this.attributeLists, this.fixedKeyword, this.openParenToken, this.declaration, this.closeParenToken, this.statement, diagnostics, GetAnnotations());

        internal override GreenNode SetAnnotations(SyntaxAnnotation[]? annotations)
            => new FixedStatementSyntax(this.Kind, this.attributeLists, this.fixedKeyword, this.openParenToken, this.declaration, this.closeParenToken, this.statement, GetDiagnostics(), annotations);

        internal FixedStatementSyntax(ObjectReader reader)
          : base(reader)
        {
            this.SlotCount = 6;
            var attributeLists = (GreenNode?)reader.ReadValue();
            if (attributeLists != null)
            {
                AdjustFlagsAndWidth(attributeLists);
                this.attributeLists = attributeLists;
            }
            var fixedKeyword = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(fixedKeyword);
            this.fixedKeyword = fixedKeyword;
            var openParenToken = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(openParenToken);
            this.openParenToken = openParenToken;
            var declaration = (VariableDeclarationSyntax)reader.ReadValue();
            AdjustFlagsAndWidth(declaration);
            this.declaration = declaration;
            var closeParenToken = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(closeParenToken);
            this.closeParenToken = closeParenToken;
            var statement = (StatementSyntax)reader.ReadValue();
            AdjustFlagsAndWidth(statement);
            this.statement = statement;
        }

        internal override void WriteTo(ObjectWriter writer)
        {
            base.WriteTo(writer);
            writer.WriteValue(this.attributeLists);
            writer.WriteValue(this.fixedKeyword);
            writer.WriteValue(this.openParenToken);
            writer.WriteValue(this.declaration);
            writer.WriteValue(this.closeParenToken);
            writer.WriteValue(this.statement);
        }

        static FixedStatementSyntax()
        {
            ObjectBinder.RegisterTypeReader(typeof(FixedStatementSyntax), r => new FixedStatementSyntax(r));
        }
    }

    internal sealed partial class CheckedStatementSyntax : StatementSyntax
    {
        internal readonly GreenNode? attributeLists;
        internal readonly SyntaxToken keyword;
        internal readonly BlockSyntax block;

        internal CheckedStatementSyntax(SyntaxKind kind, GreenNode? attributeLists, SyntaxToken keyword, BlockSyntax block, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
            this.SlotCount = 3;
            if (attributeLists != null)
            {
                this.AdjustFlagsAndWidth(attributeLists);
                this.attributeLists = attributeLists;
            }
            this.AdjustFlagsAndWidth(keyword);
            this.keyword = keyword;
            this.AdjustFlagsAndWidth(block);
            this.block = block;
        }

        internal CheckedStatementSyntax(SyntaxKind kind, GreenNode? attributeLists, SyntaxToken keyword, BlockSyntax block, SyntaxFactoryContext context)
          : base(kind)
        {
            this.SetFactoryContext(context);
            this.SlotCount = 3;
            if (attributeLists != null)
            {
                this.AdjustFlagsAndWidth(attributeLists);
                this.attributeLists = attributeLists;
            }
            this.AdjustFlagsAndWidth(keyword);
            this.keyword = keyword;
            this.AdjustFlagsAndWidth(block);
            this.block = block;
        }

        internal CheckedStatementSyntax(SyntaxKind kind, GreenNode? attributeLists, SyntaxToken keyword, BlockSyntax block)
          : base(kind)
        {
            this.SlotCount = 3;
            if (attributeLists != null)
            {
                this.AdjustFlagsAndWidth(attributeLists);
                this.attributeLists = attributeLists;
            }
            this.AdjustFlagsAndWidth(keyword);
            this.keyword = keyword;
            this.AdjustFlagsAndWidth(block);
            this.block = block;
        }

        public override Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<AttributeListSyntax> AttributeLists => new Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<AttributeListSyntax>(this.attributeLists);
        public SyntaxToken Keyword => this.keyword;
        public BlockSyntax Block => this.block;

        internal override GreenNode? GetSlot(int index)
            => index switch
            {
                0 => this.attributeLists,
                1 => this.keyword,
                2 => this.block,
                _ => null,
            };

        internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new CSharp.Syntax.CheckedStatementSyntax(this, parent, position);

        public override void Accept(CSharpSyntaxVisitor visitor) => visitor.VisitCheckedStatement(this);
        public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor) => visitor.VisitCheckedStatement(this);

        public CheckedStatementSyntax Update(Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<AttributeListSyntax> attributeLists, SyntaxToken keyword, BlockSyntax block)
        {
            if (attributeLists != this.AttributeLists || keyword != this.Keyword || block != this.Block)
            {
                var newNode = SyntaxFactory.CheckedStatement(this.Kind, attributeLists, keyword, block);
                var diags = GetDiagnostics();
                if (diags?.Length > 0)
                    newNode = newNode.WithDiagnosticsGreen(diags);
                var annotations = GetAnnotations();
                if (annotations?.Length > 0)
                    newNode = newNode.WithAnnotationsGreen(annotations);
                return newNode;
            }

            return this;
        }

        internal override GreenNode SetDiagnostics(DiagnosticInfo[]? diagnostics)
            => new CheckedStatementSyntax(this.Kind, this.attributeLists, this.keyword, this.block, diagnostics, GetAnnotations());

        internal override GreenNode SetAnnotations(SyntaxAnnotation[]? annotations)
            => new CheckedStatementSyntax(this.Kind, this.attributeLists, this.keyword, this.block, GetDiagnostics(), annotations);

        internal CheckedStatementSyntax(ObjectReader reader)
          : base(reader)
        {
            this.SlotCount = 3;
            var attributeLists = (GreenNode?)reader.ReadValue();
            if (attributeLists != null)
            {
                AdjustFlagsAndWidth(attributeLists);
                this.attributeLists = attributeLists;
            }
            var keyword = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(keyword);
            this.keyword = keyword;
            var block = (BlockSyntax)reader.ReadValue();
            AdjustFlagsAndWidth(block);
            this.block = block;
        }

        internal override void WriteTo(ObjectWriter writer)
        {
            base.WriteTo(writer);
            writer.WriteValue(this.attributeLists);
            writer.WriteValue(this.keyword);
            writer.WriteValue(this.block);
        }

        static CheckedStatementSyntax()
        {
            ObjectBinder.RegisterTypeReader(typeof(CheckedStatementSyntax), r => new CheckedStatementSyntax(r));
        }
    }

    internal sealed partial class UnsafeStatementSyntax : StatementSyntax
    {
        internal readonly GreenNode? attributeLists;
        internal readonly SyntaxToken unsafeKeyword;
        internal readonly BlockSyntax block;

        internal UnsafeStatementSyntax(SyntaxKind kind, GreenNode? attributeLists, SyntaxToken unsafeKeyword, BlockSyntax block, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
            this.SlotCount = 3;
            if (attributeLists != null)
            {
                this.AdjustFlagsAndWidth(attributeLists);
                this.attributeLists = attributeLists;
            }
            this.AdjustFlagsAndWidth(unsafeKeyword);
            this.unsafeKeyword = unsafeKeyword;
            this.AdjustFlagsAndWidth(block);
            this.block = block;
        }

        internal UnsafeStatementSyntax(SyntaxKind kind, GreenNode? attributeLists, SyntaxToken unsafeKeyword, BlockSyntax block, SyntaxFactoryContext context)
          : base(kind)
        {
            this.SetFactoryContext(context);
            this.SlotCount = 3;
            if (attributeLists != null)
            {
                this.AdjustFlagsAndWidth(attributeLists);
                this.attributeLists = attributeLists;
            }
            this.AdjustFlagsAndWidth(unsafeKeyword);
            this.unsafeKeyword = unsafeKeyword;
            this.AdjustFlagsAndWidth(block);
            this.block = block;
        }

        internal UnsafeStatementSyntax(SyntaxKind kind, GreenNode? attributeLists, SyntaxToken unsafeKeyword, BlockSyntax block)
          : base(kind)
        {
            this.SlotCount = 3;
            if (attributeLists != null)
            {
                this.AdjustFlagsAndWidth(attributeLists);
                this.attributeLists = attributeLists;
            }
            this.AdjustFlagsAndWidth(unsafeKeyword);
            this.unsafeKeyword = unsafeKeyword;
            this.AdjustFlagsAndWidth(block);
            this.block = block;
        }

        public override Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<AttributeListSyntax> AttributeLists => new Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<AttributeListSyntax>(this.attributeLists);
        public SyntaxToken UnsafeKeyword => this.unsafeKeyword;
        public BlockSyntax Block => this.block;

        internal override GreenNode? GetSlot(int index)
            => index switch
            {
                0 => this.attributeLists,
                1 => this.unsafeKeyword,
                2 => this.block,
                _ => null,
            };

        internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new CSharp.Syntax.UnsafeStatementSyntax(this, parent, position);

        public override void Accept(CSharpSyntaxVisitor visitor) => visitor.VisitUnsafeStatement(this);
        public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor) => visitor.VisitUnsafeStatement(this);

        public UnsafeStatementSyntax Update(Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<AttributeListSyntax> attributeLists, SyntaxToken unsafeKeyword, BlockSyntax block)
        {
            if (attributeLists != this.AttributeLists || unsafeKeyword != this.UnsafeKeyword || block != this.Block)
            {
                var newNode = SyntaxFactory.UnsafeStatement(attributeLists, unsafeKeyword, block);
                var diags = GetDiagnostics();
                if (diags?.Length > 0)
                    newNode = newNode.WithDiagnosticsGreen(diags);
                var annotations = GetAnnotations();
                if (annotations?.Length > 0)
                    newNode = newNode.WithAnnotationsGreen(annotations);
                return newNode;
            }

            return this;
        }

        internal override GreenNode SetDiagnostics(DiagnosticInfo[]? diagnostics)
            => new UnsafeStatementSyntax(this.Kind, this.attributeLists, this.unsafeKeyword, this.block, diagnostics, GetAnnotations());

        internal override GreenNode SetAnnotations(SyntaxAnnotation[]? annotations)
            => new UnsafeStatementSyntax(this.Kind, this.attributeLists, this.unsafeKeyword, this.block, GetDiagnostics(), annotations);

        internal UnsafeStatementSyntax(ObjectReader reader)
          : base(reader)
        {
            this.SlotCount = 3;
            var attributeLists = (GreenNode?)reader.ReadValue();
            if (attributeLists != null)
            {
                AdjustFlagsAndWidth(attributeLists);
                this.attributeLists = attributeLists;
            }
            var unsafeKeyword = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(unsafeKeyword);
            this.unsafeKeyword = unsafeKeyword;
            var block = (BlockSyntax)reader.ReadValue();
            AdjustFlagsAndWidth(block);
            this.block = block;
        }

        internal override void WriteTo(ObjectWriter writer)
        {
            base.WriteTo(writer);
            writer.WriteValue(this.attributeLists);
            writer.WriteValue(this.unsafeKeyword);
            writer.WriteValue(this.block);
        }

        static UnsafeStatementSyntax()
        {
            ObjectBinder.RegisterTypeReader(typeof(UnsafeStatementSyntax), r => new UnsafeStatementSyntax(r));
        }
    }

    internal sealed partial class LockStatementSyntax : StatementSyntax
    {
        internal readonly GreenNode? attributeLists;
        internal readonly SyntaxToken lockKeyword;
        internal readonly SyntaxToken openParenToken;
        internal readonly ExpressionSyntax expression;
        internal readonly SyntaxToken closeParenToken;
        internal readonly StatementSyntax statement;

        internal LockStatementSyntax(SyntaxKind kind, GreenNode? attributeLists, SyntaxToken lockKeyword, SyntaxToken openParenToken, ExpressionSyntax expression, SyntaxToken closeParenToken, StatementSyntax statement, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
            this.SlotCount = 6;
            if (attributeLists != null)
            {
                this.AdjustFlagsAndWidth(attributeLists);
                this.attributeLists = attributeLists;
            }
            this.AdjustFlagsAndWidth(lockKeyword);
            this.lockKeyword = lockKeyword;
            this.AdjustFlagsAndWidth(openParenToken);
            this.openParenToken = openParenToken;
            this.AdjustFlagsAndWidth(expression);
            this.expression = expression;
            this.AdjustFlagsAndWidth(closeParenToken);
            this.closeParenToken = closeParenToken;
            this.AdjustFlagsAndWidth(statement);
            this.statement = statement;
        }

        internal LockStatementSyntax(SyntaxKind kind, GreenNode? attributeLists, SyntaxToken lockKeyword, SyntaxToken openParenToken, ExpressionSyntax expression, SyntaxToken closeParenToken, StatementSyntax statement, SyntaxFactoryContext context)
          : base(kind)
        {
            this.SetFactoryContext(context);
            this.SlotCount = 6;
            if (attributeLists != null)
            {
                this.AdjustFlagsAndWidth(attributeLists);
                this.attributeLists = attributeLists;
            }
            this.AdjustFlagsAndWidth(lockKeyword);
            this.lockKeyword = lockKeyword;
            this.AdjustFlagsAndWidth(openParenToken);
            this.openParenToken = openParenToken;
            this.AdjustFlagsAndWidth(expression);
            this.expression = expression;
            this.AdjustFlagsAndWidth(closeParenToken);
            this.closeParenToken = closeParenToken;
            this.AdjustFlagsAndWidth(statement);
            this.statement = statement;
        }

        internal LockStatementSyntax(SyntaxKind kind, GreenNode? attributeLists, SyntaxToken lockKeyword, SyntaxToken openParenToken, ExpressionSyntax expression, SyntaxToken closeParenToken, StatementSyntax statement)
          : base(kind)
        {
            this.SlotCount = 6;
            if (attributeLists != null)
            {
                this.AdjustFlagsAndWidth(attributeLists);
                this.attributeLists = attributeLists;
            }
            this.AdjustFlagsAndWidth(lockKeyword);
            this.lockKeyword = lockKeyword;
            this.AdjustFlagsAndWidth(openParenToken);
            this.openParenToken = openParenToken;
            this.AdjustFlagsAndWidth(expression);
            this.expression = expression;
            this.AdjustFlagsAndWidth(closeParenToken);
            this.closeParenToken = closeParenToken;
            this.AdjustFlagsAndWidth(statement);
            this.statement = statement;
        }

        public override Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<AttributeListSyntax> AttributeLists => new Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<AttributeListSyntax>(this.attributeLists);
        public SyntaxToken LockKeyword => this.lockKeyword;
        public SyntaxToken OpenParenToken => this.openParenToken;
        public ExpressionSyntax Expression => this.expression;
        public SyntaxToken CloseParenToken => this.closeParenToken;
        public StatementSyntax Statement => this.statement;

        internal override GreenNode? GetSlot(int index)
            => index switch
            {
                0 => this.attributeLists,
                1 => this.lockKeyword,
                2 => this.openParenToken,
                3 => this.expression,
                4 => this.closeParenToken,
                5 => this.statement,
                _ => null,
            };

        internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new CSharp.Syntax.LockStatementSyntax(this, parent, position);

        public override void Accept(CSharpSyntaxVisitor visitor) => visitor.VisitLockStatement(this);
        public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor) => visitor.VisitLockStatement(this);

        public LockStatementSyntax Update(Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<AttributeListSyntax> attributeLists, SyntaxToken lockKeyword, SyntaxToken openParenToken, ExpressionSyntax expression, SyntaxToken closeParenToken, StatementSyntax statement)
        {
            if (attributeLists != this.AttributeLists || lockKeyword != this.LockKeyword || openParenToken != this.OpenParenToken || expression != this.Expression || closeParenToken != this.CloseParenToken || statement != this.Statement)
            {
                var newNode = SyntaxFactory.LockStatement(attributeLists, lockKeyword, openParenToken, expression, closeParenToken, statement);
                var diags = GetDiagnostics();
                if (diags?.Length > 0)
                    newNode = newNode.WithDiagnosticsGreen(diags);
                var annotations = GetAnnotations();
                if (annotations?.Length > 0)
                    newNode = newNode.WithAnnotationsGreen(annotations);
                return newNode;
            }

            return this;
        }

        internal override GreenNode SetDiagnostics(DiagnosticInfo[]? diagnostics)
            => new LockStatementSyntax(this.Kind, this.attributeLists, this.lockKeyword, this.openParenToken, this.expression, this.closeParenToken, this.statement, diagnostics, GetAnnotations());

        internal override GreenNode SetAnnotations(SyntaxAnnotation[]? annotations)
            => new LockStatementSyntax(this.Kind, this.attributeLists, this.lockKeyword, this.openParenToken, this.expression, this.closeParenToken, this.statement, GetDiagnostics(), annotations);

        internal LockStatementSyntax(ObjectReader reader)
          : base(reader)
        {
            this.SlotCount = 6;
            var attributeLists = (GreenNode?)reader.ReadValue();
            if (attributeLists != null)
            {
                AdjustFlagsAndWidth(attributeLists);
                this.attributeLists = attributeLists;
            }
            var lockKeyword = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(lockKeyword);
            this.lockKeyword = lockKeyword;
            var openParenToken = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(openParenToken);
            this.openParenToken = openParenToken;
            var expression = (ExpressionSyntax)reader.ReadValue();
            AdjustFlagsAndWidth(expression);
            this.expression = expression;
            var closeParenToken = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(closeParenToken);
            this.closeParenToken = closeParenToken;
            var statement = (StatementSyntax)reader.ReadValue();
            AdjustFlagsAndWidth(statement);
            this.statement = statement;
        }

        internal override void WriteTo(ObjectWriter writer)
        {
            base.WriteTo(writer);
            writer.WriteValue(this.attributeLists);
            writer.WriteValue(this.lockKeyword);
            writer.WriteValue(this.openParenToken);
            writer.WriteValue(this.expression);
            writer.WriteValue(this.closeParenToken);
            writer.WriteValue(this.statement);
        }

        static LockStatementSyntax()
        {
            ObjectBinder.RegisterTypeReader(typeof(LockStatementSyntax), r => new LockStatementSyntax(r));
        }
    }

    /// <summary>
    /// Represents an if statement syntax.
    /// </summary>
    internal sealed partial class IfStatementSyntax : StatementSyntax
    {
        internal readonly GreenNode? attributeLists;
        internal readonly SyntaxToken ifKeyword;
        internal readonly SyntaxToken openParenToken;
        internal readonly ExpressionSyntax condition;
        internal readonly SyntaxToken closeParenToken;
        internal readonly StatementSyntax statement;
        internal readonly ElseClauseSyntax? @else;

        internal IfStatementSyntax(SyntaxKind kind, GreenNode? attributeLists, SyntaxToken ifKeyword, SyntaxToken openParenToken, ExpressionSyntax condition, SyntaxToken closeParenToken, StatementSyntax statement, ElseClauseSyntax? @else, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
            this.SlotCount = 7;
            if (attributeLists != null)
            {
                this.AdjustFlagsAndWidth(attributeLists);
                this.attributeLists = attributeLists;
            }
            this.AdjustFlagsAndWidth(ifKeyword);
            this.ifKeyword = ifKeyword;
            this.AdjustFlagsAndWidth(openParenToken);
            this.openParenToken = openParenToken;
            this.AdjustFlagsAndWidth(condition);
            this.condition = condition;
            this.AdjustFlagsAndWidth(closeParenToken);
            this.closeParenToken = closeParenToken;
            this.AdjustFlagsAndWidth(statement);
            this.statement = statement;
            if (@else != null)
            {
                this.AdjustFlagsAndWidth(@else);
                this.@else = @else;
            }
        }

        internal IfStatementSyntax(SyntaxKind kind, GreenNode? attributeLists, SyntaxToken ifKeyword, SyntaxToken openParenToken, ExpressionSyntax condition, SyntaxToken closeParenToken, StatementSyntax statement, ElseClauseSyntax? @else, SyntaxFactoryContext context)
          : base(kind)
        {
            this.SetFactoryContext(context);
            this.SlotCount = 7;
            if (attributeLists != null)
            {
                this.AdjustFlagsAndWidth(attributeLists);
                this.attributeLists = attributeLists;
            }
            this.AdjustFlagsAndWidth(ifKeyword);
            this.ifKeyword = ifKeyword;
            this.AdjustFlagsAndWidth(openParenToken);
            this.openParenToken = openParenToken;
            this.AdjustFlagsAndWidth(condition);
            this.condition = condition;
            this.AdjustFlagsAndWidth(closeParenToken);
            this.closeParenToken = closeParenToken;
            this.AdjustFlagsAndWidth(statement);
            this.statement = statement;
            if (@else != null)
            {
                this.AdjustFlagsAndWidth(@else);
                this.@else = @else;
            }
        }

        internal IfStatementSyntax(SyntaxKind kind, GreenNode? attributeLists, SyntaxToken ifKeyword, SyntaxToken openParenToken, ExpressionSyntax condition, SyntaxToken closeParenToken, StatementSyntax statement, ElseClauseSyntax? @else)
          : base(kind)
        {
            this.SlotCount = 7;
            if (attributeLists != null)
            {
                this.AdjustFlagsAndWidth(attributeLists);
                this.attributeLists = attributeLists;
            }
            this.AdjustFlagsAndWidth(ifKeyword);
            this.ifKeyword = ifKeyword;
            this.AdjustFlagsAndWidth(openParenToken);
            this.openParenToken = openParenToken;
            this.AdjustFlagsAndWidth(condition);
            this.condition = condition;
            this.AdjustFlagsAndWidth(closeParenToken);
            this.closeParenToken = closeParenToken;
            this.AdjustFlagsAndWidth(statement);
            this.statement = statement;
            if (@else != null)
            {
                this.AdjustFlagsAndWidth(@else);
                this.@else = @else;
            }
        }

        public override Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<AttributeListSyntax> AttributeLists => new Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<AttributeListSyntax>(this.attributeLists);
        /// <summary>
        /// Gets a SyntaxToken that represents the if keyword.
        /// </summary>
        public SyntaxToken IfKeyword => this.ifKeyword;
        /// <summary>
        /// Gets a SyntaxToken that represents the open parenthesis before the if statement's condition expression.
        /// </summary>
        public SyntaxToken OpenParenToken => this.openParenToken;
        /// <summary>
        /// Gets an ExpressionSyntax that represents the condition of the if statement.
        /// </summary>
        public ExpressionSyntax Condition => this.condition;
        /// <summary>
        /// Gets a SyntaxToken that represents the close parenthesis after the if statement's condition expression.
        /// </summary>
        public SyntaxToken CloseParenToken => this.closeParenToken;
        /// <summary>
        /// Gets a StatementSyntax the represents the statement to be executed when the condition is true.
        /// </summary>
        public StatementSyntax Statement => this.statement;
        /// <summary>
        /// Gets an ElseClauseSyntax that represents the statement to be executed when the condition is false if such statement exists.
        /// </summary>
        public ElseClauseSyntax? Else => this.@else;

        internal override GreenNode? GetSlot(int index)
            => index switch
            {
                0 => this.attributeLists,
                1 => this.ifKeyword,
                2 => this.openParenToken,
                3 => this.condition,
                4 => this.closeParenToken,
                5 => this.statement,
                6 => this.@else,
                _ => null,
            };

        internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new CSharp.Syntax.IfStatementSyntax(this, parent, position);

        public override void Accept(CSharpSyntaxVisitor visitor) => visitor.VisitIfStatement(this);
        public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor) => visitor.VisitIfStatement(this);

        public IfStatementSyntax Update(Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<AttributeListSyntax> attributeLists, SyntaxToken ifKeyword, SyntaxToken openParenToken, ExpressionSyntax condition, SyntaxToken closeParenToken, StatementSyntax statement, ElseClauseSyntax @else)
        {
            if (attributeLists != this.AttributeLists || ifKeyword != this.IfKeyword || openParenToken != this.OpenParenToken || condition != this.Condition || closeParenToken != this.CloseParenToken || statement != this.Statement || @else != this.Else)
            {
                var newNode = SyntaxFactory.IfStatement(attributeLists, ifKeyword, openParenToken, condition, closeParenToken, statement, @else);
                var diags = GetDiagnostics();
                if (diags?.Length > 0)
                    newNode = newNode.WithDiagnosticsGreen(diags);
                var annotations = GetAnnotations();
                if (annotations?.Length > 0)
                    newNode = newNode.WithAnnotationsGreen(annotations);
                return newNode;
            }

            return this;
        }

        internal override GreenNode SetDiagnostics(DiagnosticInfo[]? diagnostics)
            => new IfStatementSyntax(this.Kind, this.attributeLists, this.ifKeyword, this.openParenToken, this.condition, this.closeParenToken, this.statement, this.@else, diagnostics, GetAnnotations());

        internal override GreenNode SetAnnotations(SyntaxAnnotation[]? annotations)
            => new IfStatementSyntax(this.Kind, this.attributeLists, this.ifKeyword, this.openParenToken, this.condition, this.closeParenToken, this.statement, this.@else, GetDiagnostics(), annotations);

        internal IfStatementSyntax(ObjectReader reader)
          : base(reader)
        {
            this.SlotCount = 7;
            var attributeLists = (GreenNode?)reader.ReadValue();
            if (attributeLists != null)
            {
                AdjustFlagsAndWidth(attributeLists);
                this.attributeLists = attributeLists;
            }
            var ifKeyword = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(ifKeyword);
            this.ifKeyword = ifKeyword;
            var openParenToken = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(openParenToken);
            this.openParenToken = openParenToken;
            var condition = (ExpressionSyntax)reader.ReadValue();
            AdjustFlagsAndWidth(condition);
            this.condition = condition;
            var closeParenToken = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(closeParenToken);
            this.closeParenToken = closeParenToken;
            var statement = (StatementSyntax)reader.ReadValue();
            AdjustFlagsAndWidth(statement);
            this.statement = statement;
            var @else = (ElseClauseSyntax?)reader.ReadValue();
            if (@else != null)
            {
                AdjustFlagsAndWidth(@else);
                this.@else = @else;
            }
        }

        internal override void WriteTo(ObjectWriter writer)
        {
            base.WriteTo(writer);
            writer.WriteValue(this.attributeLists);
            writer.WriteValue(this.ifKeyword);
            writer.WriteValue(this.openParenToken);
            writer.WriteValue(this.condition);
            writer.WriteValue(this.closeParenToken);
            writer.WriteValue(this.statement);
            writer.WriteValue(this.@else);
        }

        static IfStatementSyntax()
        {
            ObjectBinder.RegisterTypeReader(typeof(IfStatementSyntax), r => new IfStatementSyntax(r));
        }
    }

    /// <summary>Represents an else statement syntax.</summary>
    internal sealed partial class ElseClauseSyntax : CSharpSyntaxNode
    {
        internal readonly SyntaxToken elseKeyword;
        internal readonly StatementSyntax statement;

        internal ElseClauseSyntax(SyntaxKind kind, SyntaxToken elseKeyword, StatementSyntax statement, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
            this.SlotCount = 2;
            this.AdjustFlagsAndWidth(elseKeyword);
            this.elseKeyword = elseKeyword;
            this.AdjustFlagsAndWidth(statement);
            this.statement = statement;
        }

        internal ElseClauseSyntax(SyntaxKind kind, SyntaxToken elseKeyword, StatementSyntax statement, SyntaxFactoryContext context)
          : base(kind)
        {
            this.SetFactoryContext(context);
            this.SlotCount = 2;
            this.AdjustFlagsAndWidth(elseKeyword);
            this.elseKeyword = elseKeyword;
            this.AdjustFlagsAndWidth(statement);
            this.statement = statement;
        }

        internal ElseClauseSyntax(SyntaxKind kind, SyntaxToken elseKeyword, StatementSyntax statement)
          : base(kind)
        {
            this.SlotCount = 2;
            this.AdjustFlagsAndWidth(elseKeyword);
            this.elseKeyword = elseKeyword;
            this.AdjustFlagsAndWidth(statement);
            this.statement = statement;
        }

        /// <summary>
        /// Gets a syntax token
        /// </summary>
        public SyntaxToken ElseKeyword => this.elseKeyword;
        public StatementSyntax Statement => this.statement;

        internal override GreenNode? GetSlot(int index)
            => index switch
            {
                0 => this.elseKeyword,
                1 => this.statement,
                _ => null,
            };

        internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new CSharp.Syntax.ElseClauseSyntax(this, parent, position);

        public override void Accept(CSharpSyntaxVisitor visitor) => visitor.VisitElseClause(this);
        public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor) => visitor.VisitElseClause(this);

        public ElseClauseSyntax Update(SyntaxToken elseKeyword, StatementSyntax statement)
        {
            if (elseKeyword != this.ElseKeyword || statement != this.Statement)
            {
                var newNode = SyntaxFactory.ElseClause(elseKeyword, statement);
                var diags = GetDiagnostics();
                if (diags?.Length > 0)
                    newNode = newNode.WithDiagnosticsGreen(diags);
                var annotations = GetAnnotations();
                if (annotations?.Length > 0)
                    newNode = newNode.WithAnnotationsGreen(annotations);
                return newNode;
            }

            return this;
        }

        internal override GreenNode SetDiagnostics(DiagnosticInfo[]? diagnostics)
            => new ElseClauseSyntax(this.Kind, this.elseKeyword, this.statement, diagnostics, GetAnnotations());

        internal override GreenNode SetAnnotations(SyntaxAnnotation[]? annotations)
            => new ElseClauseSyntax(this.Kind, this.elseKeyword, this.statement, GetDiagnostics(), annotations);

        internal ElseClauseSyntax(ObjectReader reader)
          : base(reader)
        {
            this.SlotCount = 2;
            var elseKeyword = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(elseKeyword);
            this.elseKeyword = elseKeyword;
            var statement = (StatementSyntax)reader.ReadValue();
            AdjustFlagsAndWidth(statement);
            this.statement = statement;
        }

        internal override void WriteTo(ObjectWriter writer)
        {
            base.WriteTo(writer);
            writer.WriteValue(this.elseKeyword);
            writer.WriteValue(this.statement);
        }

        static ElseClauseSyntax()
        {
            ObjectBinder.RegisterTypeReader(typeof(ElseClauseSyntax), r => new ElseClauseSyntax(r));
        }
    }

    /// <summary>Represents a switch statement syntax.</summary>
    internal sealed partial class SwitchStatementSyntax : StatementSyntax
    {
        internal readonly GreenNode? attributeLists;
        internal readonly SyntaxToken switchKeyword;
        internal readonly SyntaxToken? openParenToken;
        internal readonly ExpressionSyntax expression;
        internal readonly SyntaxToken? closeParenToken;
        internal readonly SyntaxToken openBraceToken;
        internal readonly GreenNode? sections;
        internal readonly SyntaxToken closeBraceToken;

        internal SwitchStatementSyntax(SyntaxKind kind, GreenNode? attributeLists, SyntaxToken switchKeyword, SyntaxToken? openParenToken, ExpressionSyntax expression, SyntaxToken? closeParenToken, SyntaxToken openBraceToken, GreenNode? sections, SyntaxToken closeBraceToken, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
            this.SlotCount = 8;
            if (attributeLists != null)
            {
                this.AdjustFlagsAndWidth(attributeLists);
                this.attributeLists = attributeLists;
            }
            this.AdjustFlagsAndWidth(switchKeyword);
            this.switchKeyword = switchKeyword;
            if (openParenToken != null)
            {
                this.AdjustFlagsAndWidth(openParenToken);
                this.openParenToken = openParenToken;
            }
            this.AdjustFlagsAndWidth(expression);
            this.expression = expression;
            if (closeParenToken != null)
            {
                this.AdjustFlagsAndWidth(closeParenToken);
                this.closeParenToken = closeParenToken;
            }
            this.AdjustFlagsAndWidth(openBraceToken);
            this.openBraceToken = openBraceToken;
            if (sections != null)
            {
                this.AdjustFlagsAndWidth(sections);
                this.sections = sections;
            }
            this.AdjustFlagsAndWidth(closeBraceToken);
            this.closeBraceToken = closeBraceToken;
        }

        internal SwitchStatementSyntax(SyntaxKind kind, GreenNode? attributeLists, SyntaxToken switchKeyword, SyntaxToken? openParenToken, ExpressionSyntax expression, SyntaxToken? closeParenToken, SyntaxToken openBraceToken, GreenNode? sections, SyntaxToken closeBraceToken, SyntaxFactoryContext context)
          : base(kind)
        {
            this.SetFactoryContext(context);
            this.SlotCount = 8;
            if (attributeLists != null)
            {
                this.AdjustFlagsAndWidth(attributeLists);
                this.attributeLists = attributeLists;
            }
            this.AdjustFlagsAndWidth(switchKeyword);
            this.switchKeyword = switchKeyword;
            if (openParenToken != null)
            {
                this.AdjustFlagsAndWidth(openParenToken);
                this.openParenToken = openParenToken;
            }
            this.AdjustFlagsAndWidth(expression);
            this.expression = expression;
            if (closeParenToken != null)
            {
                this.AdjustFlagsAndWidth(closeParenToken);
                this.closeParenToken = closeParenToken;
            }
            this.AdjustFlagsAndWidth(openBraceToken);
            this.openBraceToken = openBraceToken;
            if (sections != null)
            {
                this.AdjustFlagsAndWidth(sections);
                this.sections = sections;
            }
            this.AdjustFlagsAndWidth(closeBraceToken);
            this.closeBraceToken = closeBraceToken;
        }

        internal SwitchStatementSyntax(SyntaxKind kind, GreenNode? attributeLists, SyntaxToken switchKeyword, SyntaxToken? openParenToken, ExpressionSyntax expression, SyntaxToken? closeParenToken, SyntaxToken openBraceToken, GreenNode? sections, SyntaxToken closeBraceToken)
          : base(kind)
        {
            this.SlotCount = 8;
            if (attributeLists != null)
            {
                this.AdjustFlagsAndWidth(attributeLists);
                this.attributeLists = attributeLists;
            }
            this.AdjustFlagsAndWidth(switchKeyword);
            this.switchKeyword = switchKeyword;
            if (openParenToken != null)
            {
                this.AdjustFlagsAndWidth(openParenToken);
                this.openParenToken = openParenToken;
            }
            this.AdjustFlagsAndWidth(expression);
            this.expression = expression;
            if (closeParenToken != null)
            {
                this.AdjustFlagsAndWidth(closeParenToken);
                this.closeParenToken = closeParenToken;
            }
            this.AdjustFlagsAndWidth(openBraceToken);
            this.openBraceToken = openBraceToken;
            if (sections != null)
            {
                this.AdjustFlagsAndWidth(sections);
                this.sections = sections;
            }
            this.AdjustFlagsAndWidth(closeBraceToken);
            this.closeBraceToken = closeBraceToken;
        }

        public override Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<AttributeListSyntax> AttributeLists => new Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<AttributeListSyntax>(this.attributeLists);
        /// <summary>
        /// Gets a SyntaxToken that represents the switch keyword.
        /// </summary>
        public SyntaxToken SwitchKeyword => this.switchKeyword;
        /// <summary>
        /// Gets a SyntaxToken that represents the open parenthesis preceding the switch governing expression.
        /// </summary>
        public SyntaxToken? OpenParenToken => this.openParenToken;
        /// <summary>
        /// Gets an ExpressionSyntax representing the expression of the switch statement.
        /// </summary>
        public ExpressionSyntax Expression => this.expression;
        /// <summary>
        /// Gets a SyntaxToken that represents the close parenthesis following the switch governing expression.
        /// </summary>
        public SyntaxToken? CloseParenToken => this.closeParenToken;
        /// <summary>
        /// Gets a SyntaxToken that represents the open braces preceding the switch sections.
        /// </summary>
        public SyntaxToken OpenBraceToken => this.openBraceToken;
        /// <summary>
        /// Gets a SyntaxList of SwitchSectionSyntax's that represents the switch sections of the switch statement.
        /// </summary>
        public Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SwitchSectionSyntax> Sections => new Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SwitchSectionSyntax>(this.sections);
        /// <summary>
        /// Gets a SyntaxToken that represents the open braces following the switch sections.
        /// </summary>
        public SyntaxToken CloseBraceToken => this.closeBraceToken;

        internal override GreenNode? GetSlot(int index)
            => index switch
            {
                0 => this.attributeLists,
                1 => this.switchKeyword,
                2 => this.openParenToken,
                3 => this.expression,
                4 => this.closeParenToken,
                5 => this.openBraceToken,
                6 => this.sections,
                7 => this.closeBraceToken,
                _ => null,
            };

        internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new CSharp.Syntax.SwitchStatementSyntax(this, parent, position);

        public override void Accept(CSharpSyntaxVisitor visitor) => visitor.VisitSwitchStatement(this);
        public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor) => visitor.VisitSwitchStatement(this);

        public SwitchStatementSyntax Update(Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<AttributeListSyntax> attributeLists, SyntaxToken switchKeyword, SyntaxToken openParenToken, ExpressionSyntax expression, SyntaxToken closeParenToken, SyntaxToken openBraceToken, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SwitchSectionSyntax> sections, SyntaxToken closeBraceToken)
        {
            if (attributeLists != this.AttributeLists || switchKeyword != this.SwitchKeyword || openParenToken != this.OpenParenToken || expression != this.Expression || closeParenToken != this.CloseParenToken || openBraceToken != this.OpenBraceToken || sections != this.Sections || closeBraceToken != this.CloseBraceToken)
            {
                var newNode = SyntaxFactory.SwitchStatement(attributeLists, switchKeyword, openParenToken, expression, closeParenToken, openBraceToken, sections, closeBraceToken);
                var diags = GetDiagnostics();
                if (diags?.Length > 0)
                    newNode = newNode.WithDiagnosticsGreen(diags);
                var annotations = GetAnnotations();
                if (annotations?.Length > 0)
                    newNode = newNode.WithAnnotationsGreen(annotations);
                return newNode;
            }

            return this;
        }

        internal override GreenNode SetDiagnostics(DiagnosticInfo[]? diagnostics)
            => new SwitchStatementSyntax(this.Kind, this.attributeLists, this.switchKeyword, this.openParenToken, this.expression, this.closeParenToken, this.openBraceToken, this.sections, this.closeBraceToken, diagnostics, GetAnnotations());

        internal override GreenNode SetAnnotations(SyntaxAnnotation[]? annotations)
            => new SwitchStatementSyntax(this.Kind, this.attributeLists, this.switchKeyword, this.openParenToken, this.expression, this.closeParenToken, this.openBraceToken, this.sections, this.closeBraceToken, GetDiagnostics(), annotations);

        internal SwitchStatementSyntax(ObjectReader reader)
          : base(reader)
        {
            this.SlotCount = 8;
            var attributeLists = (GreenNode?)reader.ReadValue();
            if (attributeLists != null)
            {
                AdjustFlagsAndWidth(attributeLists);
                this.attributeLists = attributeLists;
            }
            var switchKeyword = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(switchKeyword);
            this.switchKeyword = switchKeyword;
            var openParenToken = (SyntaxToken?)reader.ReadValue();
            if (openParenToken != null)
            {
                AdjustFlagsAndWidth(openParenToken);
                this.openParenToken = openParenToken;
            }
            var expression = (ExpressionSyntax)reader.ReadValue();
            AdjustFlagsAndWidth(expression);
            this.expression = expression;
            var closeParenToken = (SyntaxToken?)reader.ReadValue();
            if (closeParenToken != null)
            {
                AdjustFlagsAndWidth(closeParenToken);
                this.closeParenToken = closeParenToken;
            }
            var openBraceToken = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(openBraceToken);
            this.openBraceToken = openBraceToken;
            var sections = (GreenNode?)reader.ReadValue();
            if (sections != null)
            {
                AdjustFlagsAndWidth(sections);
                this.sections = sections;
            }
            var closeBraceToken = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(closeBraceToken);
            this.closeBraceToken = closeBraceToken;
        }

        internal override void WriteTo(ObjectWriter writer)
        {
            base.WriteTo(writer);
            writer.WriteValue(this.attributeLists);
            writer.WriteValue(this.switchKeyword);
            writer.WriteValue(this.openParenToken);
            writer.WriteValue(this.expression);
            writer.WriteValue(this.closeParenToken);
            writer.WriteValue(this.openBraceToken);
            writer.WriteValue(this.sections);
            writer.WriteValue(this.closeBraceToken);
        }

        static SwitchStatementSyntax()
        {
            ObjectBinder.RegisterTypeReader(typeof(SwitchStatementSyntax), r => new SwitchStatementSyntax(r));
        }
    }

    /// <summary>Represents a switch section syntax of a switch statement.</summary>
    internal sealed partial class SwitchSectionSyntax : CSharpSyntaxNode
    {
        internal readonly GreenNode? labels;
        internal readonly GreenNode? statements;

        internal SwitchSectionSyntax(SyntaxKind kind, GreenNode? labels, GreenNode? statements, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
            this.SlotCount = 2;
            if (labels != null)
            {
                this.AdjustFlagsAndWidth(labels);
                this.labels = labels;
            }
            if (statements != null)
            {
                this.AdjustFlagsAndWidth(statements);
                this.statements = statements;
            }
        }

        internal SwitchSectionSyntax(SyntaxKind kind, GreenNode? labels, GreenNode? statements, SyntaxFactoryContext context)
          : base(kind)
        {
            this.SetFactoryContext(context);
            this.SlotCount = 2;
            if (labels != null)
            {
                this.AdjustFlagsAndWidth(labels);
                this.labels = labels;
            }
            if (statements != null)
            {
                this.AdjustFlagsAndWidth(statements);
                this.statements = statements;
            }
        }

        internal SwitchSectionSyntax(SyntaxKind kind, GreenNode? labels, GreenNode? statements)
          : base(kind)
        {
            this.SlotCount = 2;
            if (labels != null)
            {
                this.AdjustFlagsAndWidth(labels);
                this.labels = labels;
            }
            if (statements != null)
            {
                this.AdjustFlagsAndWidth(statements);
                this.statements = statements;
            }
        }

        /// <summary>
        /// Gets a SyntaxList of SwitchLabelSyntax's the represents the possible labels that control can transfer to within the section.
        /// </summary>
        public Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SwitchLabelSyntax> Labels => new Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SwitchLabelSyntax>(this.labels);
        /// <summary>
        /// Gets a SyntaxList of StatementSyntax's the represents the statements to be executed when control transfer to a label the belongs to the section.
        /// </summary>
        public Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<StatementSyntax> Statements => new Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<StatementSyntax>(this.statements);

        internal override GreenNode? GetSlot(int index)
            => index switch
            {
                0 => this.labels,
                1 => this.statements,
                _ => null,
            };

        internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new CSharp.Syntax.SwitchSectionSyntax(this, parent, position);

        public override void Accept(CSharpSyntaxVisitor visitor) => visitor.VisitSwitchSection(this);
        public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor) => visitor.VisitSwitchSection(this);

        public SwitchSectionSyntax Update(Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SwitchLabelSyntax> labels, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<StatementSyntax> statements)
        {
            if (labels != this.Labels || statements != this.Statements)
            {
                var newNode = SyntaxFactory.SwitchSection(labels, statements);
                var diags = GetDiagnostics();
                if (diags?.Length > 0)
                    newNode = newNode.WithDiagnosticsGreen(diags);
                var annotations = GetAnnotations();
                if (annotations?.Length > 0)
                    newNode = newNode.WithAnnotationsGreen(annotations);
                return newNode;
            }

            return this;
        }

        internal override GreenNode SetDiagnostics(DiagnosticInfo[]? diagnostics)
            => new SwitchSectionSyntax(this.Kind, this.labels, this.statements, diagnostics, GetAnnotations());

        internal override GreenNode SetAnnotations(SyntaxAnnotation[]? annotations)
            => new SwitchSectionSyntax(this.Kind, this.labels, this.statements, GetDiagnostics(), annotations);

        internal SwitchSectionSyntax(ObjectReader reader)
          : base(reader)
        {
            this.SlotCount = 2;
            var labels = (GreenNode?)reader.ReadValue();
            if (labels != null)
            {
                AdjustFlagsAndWidth(labels);
                this.labels = labels;
            }
            var statements = (GreenNode?)reader.ReadValue();
            if (statements != null)
            {
                AdjustFlagsAndWidth(statements);
                this.statements = statements;
            }
        }

        internal override void WriteTo(ObjectWriter writer)
        {
            base.WriteTo(writer);
            writer.WriteValue(this.labels);
            writer.WriteValue(this.statements);
        }

        static SwitchSectionSyntax()
        {
            ObjectBinder.RegisterTypeReader(typeof(SwitchSectionSyntax), r => new SwitchSectionSyntax(r));
        }
    }

    /// <summary>Represents a switch label within a switch statement.</summary>
    internal abstract partial class SwitchLabelSyntax : CSharpSyntaxNode
    {
        internal SwitchLabelSyntax(SyntaxKind kind, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
        }

        internal SwitchLabelSyntax(SyntaxKind kind)
          : base(kind)
        {
        }

        protected SwitchLabelSyntax(ObjectReader reader)
          : base(reader)
        {
        }

        /// <summary>
        /// Gets a SyntaxToken that represents a case or default keyword that belongs to a switch label.
        /// </summary>
        public abstract SyntaxToken Keyword { get; }

        /// <summary>
        /// Gets a SyntaxToken that represents the colon that terminates the switch label.
        /// </summary>
        public abstract SyntaxToken ColonToken { get; }
    }

    /// <summary>Represents a case label within a switch statement.</summary>
    internal sealed partial class CasePatternSwitchLabelSyntax : SwitchLabelSyntax
    {
        internal readonly SyntaxToken keyword;
        internal readonly PatternSyntax pattern;
        internal readonly WhenClauseSyntax? whenClause;
        internal readonly SyntaxToken colonToken;

        internal CasePatternSwitchLabelSyntax(SyntaxKind kind, SyntaxToken keyword, PatternSyntax pattern, WhenClauseSyntax? whenClause, SyntaxToken colonToken, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
            this.SlotCount = 4;
            this.AdjustFlagsAndWidth(keyword);
            this.keyword = keyword;
            this.AdjustFlagsAndWidth(pattern);
            this.pattern = pattern;
            if (whenClause != null)
            {
                this.AdjustFlagsAndWidth(whenClause);
                this.whenClause = whenClause;
            }
            this.AdjustFlagsAndWidth(colonToken);
            this.colonToken = colonToken;
        }

        internal CasePatternSwitchLabelSyntax(SyntaxKind kind, SyntaxToken keyword, PatternSyntax pattern, WhenClauseSyntax? whenClause, SyntaxToken colonToken, SyntaxFactoryContext context)
          : base(kind)
        {
            this.SetFactoryContext(context);
            this.SlotCount = 4;
            this.AdjustFlagsAndWidth(keyword);
            this.keyword = keyword;
            this.AdjustFlagsAndWidth(pattern);
            this.pattern = pattern;
            if (whenClause != null)
            {
                this.AdjustFlagsAndWidth(whenClause);
                this.whenClause = whenClause;
            }
            this.AdjustFlagsAndWidth(colonToken);
            this.colonToken = colonToken;
        }

        internal CasePatternSwitchLabelSyntax(SyntaxKind kind, SyntaxToken keyword, PatternSyntax pattern, WhenClauseSyntax? whenClause, SyntaxToken colonToken)
          : base(kind)
        {
            this.SlotCount = 4;
            this.AdjustFlagsAndWidth(keyword);
            this.keyword = keyword;
            this.AdjustFlagsAndWidth(pattern);
            this.pattern = pattern;
            if (whenClause != null)
            {
                this.AdjustFlagsAndWidth(whenClause);
                this.whenClause = whenClause;
            }
            this.AdjustFlagsAndWidth(colonToken);
            this.colonToken = colonToken;
        }

        /// <summary>Gets the case keyword token.</summary>
        public override SyntaxToken Keyword => this.keyword;
        /// <summary>
        /// Gets a PatternSyntax that represents the pattern that gets matched for the case label.
        /// </summary>
        public PatternSyntax Pattern => this.pattern;
        public WhenClauseSyntax? WhenClause => this.whenClause;
        public override SyntaxToken ColonToken => this.colonToken;

        internal override GreenNode? GetSlot(int index)
            => index switch
            {
                0 => this.keyword,
                1 => this.pattern,
                2 => this.whenClause,
                3 => this.colonToken,
                _ => null,
            };

        internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new CSharp.Syntax.CasePatternSwitchLabelSyntax(this, parent, position);

        public override void Accept(CSharpSyntaxVisitor visitor) => visitor.VisitCasePatternSwitchLabel(this);
        public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor) => visitor.VisitCasePatternSwitchLabel(this);

        public CasePatternSwitchLabelSyntax Update(SyntaxToken keyword, PatternSyntax pattern, WhenClauseSyntax whenClause, SyntaxToken colonToken)
        {
            if (keyword != this.Keyword || pattern != this.Pattern || whenClause != this.WhenClause || colonToken != this.ColonToken)
            {
                var newNode = SyntaxFactory.CasePatternSwitchLabel(keyword, pattern, whenClause, colonToken);
                var diags = GetDiagnostics();
                if (diags?.Length > 0)
                    newNode = newNode.WithDiagnosticsGreen(diags);
                var annotations = GetAnnotations();
                if (annotations?.Length > 0)
                    newNode = newNode.WithAnnotationsGreen(annotations);
                return newNode;
            }

            return this;
        }

        internal override GreenNode SetDiagnostics(DiagnosticInfo[]? diagnostics)
            => new CasePatternSwitchLabelSyntax(this.Kind, this.keyword, this.pattern, this.whenClause, this.colonToken, diagnostics, GetAnnotations());

        internal override GreenNode SetAnnotations(SyntaxAnnotation[]? annotations)
            => new CasePatternSwitchLabelSyntax(this.Kind, this.keyword, this.pattern, this.whenClause, this.colonToken, GetDiagnostics(), annotations);

        internal CasePatternSwitchLabelSyntax(ObjectReader reader)
          : base(reader)
        {
            this.SlotCount = 4;
            var keyword = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(keyword);
            this.keyword = keyword;
            var pattern = (PatternSyntax)reader.ReadValue();
            AdjustFlagsAndWidth(pattern);
            this.pattern = pattern;
            var whenClause = (WhenClauseSyntax?)reader.ReadValue();
            if (whenClause != null)
            {
                AdjustFlagsAndWidth(whenClause);
                this.whenClause = whenClause;
            }
            var colonToken = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(colonToken);
            this.colonToken = colonToken;
        }

        internal override void WriteTo(ObjectWriter writer)
        {
            base.WriteTo(writer);
            writer.WriteValue(this.keyword);
            writer.WriteValue(this.pattern);
            writer.WriteValue(this.whenClause);
            writer.WriteValue(this.colonToken);
        }

        static CasePatternSwitchLabelSyntax()
        {
            ObjectBinder.RegisterTypeReader(typeof(CasePatternSwitchLabelSyntax), r => new CasePatternSwitchLabelSyntax(r));
        }
    }

    /// <summary>Represents a case label within a switch statement.</summary>
    internal sealed partial class CaseSwitchLabelSyntax : SwitchLabelSyntax
    {
        internal readonly SyntaxToken keyword;
        internal readonly ExpressionSyntax value;
        internal readonly SyntaxToken colonToken;

        internal CaseSwitchLabelSyntax(SyntaxKind kind, SyntaxToken keyword, ExpressionSyntax value, SyntaxToken colonToken, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
            this.SlotCount = 3;
            this.AdjustFlagsAndWidth(keyword);
            this.keyword = keyword;
            this.AdjustFlagsAndWidth(value);
            this.value = value;
            this.AdjustFlagsAndWidth(colonToken);
            this.colonToken = colonToken;
        }

        internal CaseSwitchLabelSyntax(SyntaxKind kind, SyntaxToken keyword, ExpressionSyntax value, SyntaxToken colonToken, SyntaxFactoryContext context)
          : base(kind)
        {
            this.SetFactoryContext(context);
            this.SlotCount = 3;
            this.AdjustFlagsAndWidth(keyword);
            this.keyword = keyword;
            this.AdjustFlagsAndWidth(value);
            this.value = value;
            this.AdjustFlagsAndWidth(colonToken);
            this.colonToken = colonToken;
        }

        internal CaseSwitchLabelSyntax(SyntaxKind kind, SyntaxToken keyword, ExpressionSyntax value, SyntaxToken colonToken)
          : base(kind)
        {
            this.SlotCount = 3;
            this.AdjustFlagsAndWidth(keyword);
            this.keyword = keyword;
            this.AdjustFlagsAndWidth(value);
            this.value = value;
            this.AdjustFlagsAndWidth(colonToken);
            this.colonToken = colonToken;
        }

        /// <summary>Gets the case keyword token.</summary>
        public override SyntaxToken Keyword => this.keyword;
        /// <summary>
        /// Gets an ExpressionSyntax that represents the constant expression that gets matched for the case label.
        /// </summary>
        public ExpressionSyntax Value => this.value;
        public override SyntaxToken ColonToken => this.colonToken;

        internal override GreenNode? GetSlot(int index)
            => index switch
            {
                0 => this.keyword,
                1 => this.value,
                2 => this.colonToken,
                _ => null,
            };

        internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new CSharp.Syntax.CaseSwitchLabelSyntax(this, parent, position);

        public override void Accept(CSharpSyntaxVisitor visitor) => visitor.VisitCaseSwitchLabel(this);
        public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor) => visitor.VisitCaseSwitchLabel(this);

        public CaseSwitchLabelSyntax Update(SyntaxToken keyword, ExpressionSyntax value, SyntaxToken colonToken)
        {
            if (keyword != this.Keyword || value != this.Value || colonToken != this.ColonToken)
            {
                var newNode = SyntaxFactory.CaseSwitchLabel(keyword, value, colonToken);
                var diags = GetDiagnostics();
                if (diags?.Length > 0)
                    newNode = newNode.WithDiagnosticsGreen(diags);
                var annotations = GetAnnotations();
                if (annotations?.Length > 0)
                    newNode = newNode.WithAnnotationsGreen(annotations);
                return newNode;
            }

            return this;
        }

        internal override GreenNode SetDiagnostics(DiagnosticInfo[]? diagnostics)
            => new CaseSwitchLabelSyntax(this.Kind, this.keyword, this.value, this.colonToken, diagnostics, GetAnnotations());

        internal override GreenNode SetAnnotations(SyntaxAnnotation[]? annotations)
            => new CaseSwitchLabelSyntax(this.Kind, this.keyword, this.value, this.colonToken, GetDiagnostics(), annotations);

        internal CaseSwitchLabelSyntax(ObjectReader reader)
          : base(reader)
        {
            this.SlotCount = 3;
            var keyword = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(keyword);
            this.keyword = keyword;
            var value = (ExpressionSyntax)reader.ReadValue();
            AdjustFlagsAndWidth(value);
            this.value = value;
            var colonToken = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(colonToken);
            this.colonToken = colonToken;
        }

        internal override void WriteTo(ObjectWriter writer)
        {
            base.WriteTo(writer);
            writer.WriteValue(this.keyword);
            writer.WriteValue(this.value);
            writer.WriteValue(this.colonToken);
        }

        static CaseSwitchLabelSyntax()
        {
            ObjectBinder.RegisterTypeReader(typeof(CaseSwitchLabelSyntax), r => new CaseSwitchLabelSyntax(r));
        }
    }

    /// <summary>Represents a default label within a switch statement.</summary>
    internal sealed partial class DefaultSwitchLabelSyntax : SwitchLabelSyntax
    {
        internal readonly SyntaxToken keyword;
        internal readonly SyntaxToken colonToken;

        internal DefaultSwitchLabelSyntax(SyntaxKind kind, SyntaxToken keyword, SyntaxToken colonToken, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
            this.SlotCount = 2;
            this.AdjustFlagsAndWidth(keyword);
            this.keyword = keyword;
            this.AdjustFlagsAndWidth(colonToken);
            this.colonToken = colonToken;
        }

        internal DefaultSwitchLabelSyntax(SyntaxKind kind, SyntaxToken keyword, SyntaxToken colonToken, SyntaxFactoryContext context)
          : base(kind)
        {
            this.SetFactoryContext(context);
            this.SlotCount = 2;
            this.AdjustFlagsAndWidth(keyword);
            this.keyword = keyword;
            this.AdjustFlagsAndWidth(colonToken);
            this.colonToken = colonToken;
        }

        internal DefaultSwitchLabelSyntax(SyntaxKind kind, SyntaxToken keyword, SyntaxToken colonToken)
          : base(kind)
        {
            this.SlotCount = 2;
            this.AdjustFlagsAndWidth(keyword);
            this.keyword = keyword;
            this.AdjustFlagsAndWidth(colonToken);
            this.colonToken = colonToken;
        }

        /// <summary>Gets the default keyword token.</summary>
        public override SyntaxToken Keyword => this.keyword;
        public override SyntaxToken ColonToken => this.colonToken;

        internal override GreenNode? GetSlot(int index)
            => index switch
            {
                0 => this.keyword,
                1 => this.colonToken,
                _ => null,
            };

        internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new CSharp.Syntax.DefaultSwitchLabelSyntax(this, parent, position);

        public override void Accept(CSharpSyntaxVisitor visitor) => visitor.VisitDefaultSwitchLabel(this);
        public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor) => visitor.VisitDefaultSwitchLabel(this);

        public DefaultSwitchLabelSyntax Update(SyntaxToken keyword, SyntaxToken colonToken)
        {
            if (keyword != this.Keyword || colonToken != this.ColonToken)
            {
                var newNode = SyntaxFactory.DefaultSwitchLabel(keyword, colonToken);
                var diags = GetDiagnostics();
                if (diags?.Length > 0)
                    newNode = newNode.WithDiagnosticsGreen(diags);
                var annotations = GetAnnotations();
                if (annotations?.Length > 0)
                    newNode = newNode.WithAnnotationsGreen(annotations);
                return newNode;
            }

            return this;
        }

        internal override GreenNode SetDiagnostics(DiagnosticInfo[]? diagnostics)
            => new DefaultSwitchLabelSyntax(this.Kind, this.keyword, this.colonToken, diagnostics, GetAnnotations());

        internal override GreenNode SetAnnotations(SyntaxAnnotation[]? annotations)
            => new DefaultSwitchLabelSyntax(this.Kind, this.keyword, this.colonToken, GetDiagnostics(), annotations);

        internal DefaultSwitchLabelSyntax(ObjectReader reader)
          : base(reader)
        {
            this.SlotCount = 2;
            var keyword = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(keyword);
            this.keyword = keyword;
            var colonToken = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(colonToken);
            this.colonToken = colonToken;
        }

        internal override void WriteTo(ObjectWriter writer)
        {
            base.WriteTo(writer);
            writer.WriteValue(this.keyword);
            writer.WriteValue(this.colonToken);
        }

        static DefaultSwitchLabelSyntax()
        {
            ObjectBinder.RegisterTypeReader(typeof(DefaultSwitchLabelSyntax), r => new DefaultSwitchLabelSyntax(r));
        }
    }

    internal sealed partial class SwitchExpressionSyntax : ExpressionSyntax
    {
        internal readonly ExpressionSyntax governingExpression;
        internal readonly SyntaxToken switchKeyword;
        internal readonly SyntaxToken openBraceToken;
        internal readonly GreenNode? arms;
        internal readonly SyntaxToken closeBraceToken;

        internal SwitchExpressionSyntax(SyntaxKind kind, ExpressionSyntax governingExpression, SyntaxToken switchKeyword, SyntaxToken openBraceToken, GreenNode? arms, SyntaxToken closeBraceToken, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
            this.SlotCount = 5;
            this.AdjustFlagsAndWidth(governingExpression);
            this.governingExpression = governingExpression;
            this.AdjustFlagsAndWidth(switchKeyword);
            this.switchKeyword = switchKeyword;
            this.AdjustFlagsAndWidth(openBraceToken);
            this.openBraceToken = openBraceToken;
            if (arms != null)
            {
                this.AdjustFlagsAndWidth(arms);
                this.arms = arms;
            }
            this.AdjustFlagsAndWidth(closeBraceToken);
            this.closeBraceToken = closeBraceToken;
        }

        internal SwitchExpressionSyntax(SyntaxKind kind, ExpressionSyntax governingExpression, SyntaxToken switchKeyword, SyntaxToken openBraceToken, GreenNode? arms, SyntaxToken closeBraceToken, SyntaxFactoryContext context)
          : base(kind)
        {
            this.SetFactoryContext(context);
            this.SlotCount = 5;
            this.AdjustFlagsAndWidth(governingExpression);
            this.governingExpression = governingExpression;
            this.AdjustFlagsAndWidth(switchKeyword);
            this.switchKeyword = switchKeyword;
            this.AdjustFlagsAndWidth(openBraceToken);
            this.openBraceToken = openBraceToken;
            if (arms != null)
            {
                this.AdjustFlagsAndWidth(arms);
                this.arms = arms;
            }
            this.AdjustFlagsAndWidth(closeBraceToken);
            this.closeBraceToken = closeBraceToken;
        }

        internal SwitchExpressionSyntax(SyntaxKind kind, ExpressionSyntax governingExpression, SyntaxToken switchKeyword, SyntaxToken openBraceToken, GreenNode? arms, SyntaxToken closeBraceToken)
          : base(kind)
        {
            this.SlotCount = 5;
            this.AdjustFlagsAndWidth(governingExpression);
            this.governingExpression = governingExpression;
            this.AdjustFlagsAndWidth(switchKeyword);
            this.switchKeyword = switchKeyword;
            this.AdjustFlagsAndWidth(openBraceToken);
            this.openBraceToken = openBraceToken;
            if (arms != null)
            {
                this.AdjustFlagsAndWidth(arms);
                this.arms = arms;
            }
            this.AdjustFlagsAndWidth(closeBraceToken);
            this.closeBraceToken = closeBraceToken;
        }

        public ExpressionSyntax GoverningExpression => this.governingExpression;
        public SyntaxToken SwitchKeyword => this.switchKeyword;
        public SyntaxToken OpenBraceToken => this.openBraceToken;
        public Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<SwitchExpressionArmSyntax> Arms => new Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<SwitchExpressionArmSyntax>(new Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<CSharpSyntaxNode>(this.arms));
        public SyntaxToken CloseBraceToken => this.closeBraceToken;

        internal override GreenNode? GetSlot(int index)
            => index switch
            {
                0 => this.governingExpression,
                1 => this.switchKeyword,
                2 => this.openBraceToken,
                3 => this.arms,
                4 => this.closeBraceToken,
                _ => null,
            };

        internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new CSharp.Syntax.SwitchExpressionSyntax(this, parent, position);

        public override void Accept(CSharpSyntaxVisitor visitor) => visitor.VisitSwitchExpression(this);
        public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor) => visitor.VisitSwitchExpression(this);

        public SwitchExpressionSyntax Update(ExpressionSyntax governingExpression, SyntaxToken switchKeyword, SyntaxToken openBraceToken, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<SwitchExpressionArmSyntax> arms, SyntaxToken closeBraceToken)
        {
            if (governingExpression != this.GoverningExpression || switchKeyword != this.SwitchKeyword || openBraceToken != this.OpenBraceToken || arms != this.Arms || closeBraceToken != this.CloseBraceToken)
            {
                var newNode = SyntaxFactory.SwitchExpression(governingExpression, switchKeyword, openBraceToken, arms, closeBraceToken);
                var diags = GetDiagnostics();
                if (diags?.Length > 0)
                    newNode = newNode.WithDiagnosticsGreen(diags);
                var annotations = GetAnnotations();
                if (annotations?.Length > 0)
                    newNode = newNode.WithAnnotationsGreen(annotations);
                return newNode;
            }

            return this;
        }

        internal override GreenNode SetDiagnostics(DiagnosticInfo[]? diagnostics)
            => new SwitchExpressionSyntax(this.Kind, this.governingExpression, this.switchKeyword, this.openBraceToken, this.arms, this.closeBraceToken, diagnostics, GetAnnotations());

        internal override GreenNode SetAnnotations(SyntaxAnnotation[]? annotations)
            => new SwitchExpressionSyntax(this.Kind, this.governingExpression, this.switchKeyword, this.openBraceToken, this.arms, this.closeBraceToken, GetDiagnostics(), annotations);

        internal SwitchExpressionSyntax(ObjectReader reader)
          : base(reader)
        {
            this.SlotCount = 5;
            var governingExpression = (ExpressionSyntax)reader.ReadValue();
            AdjustFlagsAndWidth(governingExpression);
            this.governingExpression = governingExpression;
            var switchKeyword = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(switchKeyword);
            this.switchKeyword = switchKeyword;
            var openBraceToken = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(openBraceToken);
            this.openBraceToken = openBraceToken;
            var arms = (GreenNode?)reader.ReadValue();
            if (arms != null)
            {
                AdjustFlagsAndWidth(arms);
                this.arms = arms;
            }
            var closeBraceToken = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(closeBraceToken);
            this.closeBraceToken = closeBraceToken;
        }

        internal override void WriteTo(ObjectWriter writer)
        {
            base.WriteTo(writer);
            writer.WriteValue(this.governingExpression);
            writer.WriteValue(this.switchKeyword);
            writer.WriteValue(this.openBraceToken);
            writer.WriteValue(this.arms);
            writer.WriteValue(this.closeBraceToken);
        }

        static SwitchExpressionSyntax()
        {
            ObjectBinder.RegisterTypeReader(typeof(SwitchExpressionSyntax), r => new SwitchExpressionSyntax(r));
        }
    }

    internal sealed partial class SwitchExpressionArmSyntax : CSharpSyntaxNode
    {
        internal readonly PatternSyntax pattern;
        internal readonly WhenClauseSyntax? whenClause;
        internal readonly SyntaxToken equalsGreaterThanToken;
        internal readonly ExpressionSyntax expression;

        internal SwitchExpressionArmSyntax(SyntaxKind kind, PatternSyntax pattern, WhenClauseSyntax? whenClause, SyntaxToken equalsGreaterThanToken, ExpressionSyntax expression, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
            this.SlotCount = 4;
            this.AdjustFlagsAndWidth(pattern);
            this.pattern = pattern;
            if (whenClause != null)
            {
                this.AdjustFlagsAndWidth(whenClause);
                this.whenClause = whenClause;
            }
            this.AdjustFlagsAndWidth(equalsGreaterThanToken);
            this.equalsGreaterThanToken = equalsGreaterThanToken;
            this.AdjustFlagsAndWidth(expression);
            this.expression = expression;
        }

        internal SwitchExpressionArmSyntax(SyntaxKind kind, PatternSyntax pattern, WhenClauseSyntax? whenClause, SyntaxToken equalsGreaterThanToken, ExpressionSyntax expression, SyntaxFactoryContext context)
          : base(kind)
        {
            this.SetFactoryContext(context);
            this.SlotCount = 4;
            this.AdjustFlagsAndWidth(pattern);
            this.pattern = pattern;
            if (whenClause != null)
            {
                this.AdjustFlagsAndWidth(whenClause);
                this.whenClause = whenClause;
            }
            this.AdjustFlagsAndWidth(equalsGreaterThanToken);
            this.equalsGreaterThanToken = equalsGreaterThanToken;
            this.AdjustFlagsAndWidth(expression);
            this.expression = expression;
        }

        internal SwitchExpressionArmSyntax(SyntaxKind kind, PatternSyntax pattern, WhenClauseSyntax? whenClause, SyntaxToken equalsGreaterThanToken, ExpressionSyntax expression)
          : base(kind)
        {
            this.SlotCount = 4;
            this.AdjustFlagsAndWidth(pattern);
            this.pattern = pattern;
            if (whenClause != null)
            {
                this.AdjustFlagsAndWidth(whenClause);
                this.whenClause = whenClause;
            }
            this.AdjustFlagsAndWidth(equalsGreaterThanToken);
            this.equalsGreaterThanToken = equalsGreaterThanToken;
            this.AdjustFlagsAndWidth(expression);
            this.expression = expression;
        }

        public PatternSyntax Pattern => this.pattern;
        public WhenClauseSyntax? WhenClause => this.whenClause;
        public SyntaxToken EqualsGreaterThanToken => this.equalsGreaterThanToken;
        public ExpressionSyntax Expression => this.expression;

        internal override GreenNode? GetSlot(int index)
            => index switch
            {
                0 => this.pattern,
                1 => this.whenClause,
                2 => this.equalsGreaterThanToken,
                3 => this.expression,
                _ => null,
            };

        internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new CSharp.Syntax.SwitchExpressionArmSyntax(this, parent, position);

        public override void Accept(CSharpSyntaxVisitor visitor) => visitor.VisitSwitchExpressionArm(this);
        public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor) => visitor.VisitSwitchExpressionArm(this);

        public SwitchExpressionArmSyntax Update(PatternSyntax pattern, WhenClauseSyntax whenClause, SyntaxToken equalsGreaterThanToken, ExpressionSyntax expression)
        {
            if (pattern != this.Pattern || whenClause != this.WhenClause || equalsGreaterThanToken != this.EqualsGreaterThanToken || expression != this.Expression)
            {
                var newNode = SyntaxFactory.SwitchExpressionArm(pattern, whenClause, equalsGreaterThanToken, expression);
                var diags = GetDiagnostics();
                if (diags?.Length > 0)
                    newNode = newNode.WithDiagnosticsGreen(diags);
                var annotations = GetAnnotations();
                if (annotations?.Length > 0)
                    newNode = newNode.WithAnnotationsGreen(annotations);
                return newNode;
            }

            return this;
        }

        internal override GreenNode SetDiagnostics(DiagnosticInfo[]? diagnostics)
            => new SwitchExpressionArmSyntax(this.Kind, this.pattern, this.whenClause, this.equalsGreaterThanToken, this.expression, diagnostics, GetAnnotations());

        internal override GreenNode SetAnnotations(SyntaxAnnotation[]? annotations)
            => new SwitchExpressionArmSyntax(this.Kind, this.pattern, this.whenClause, this.equalsGreaterThanToken, this.expression, GetDiagnostics(), annotations);

        internal SwitchExpressionArmSyntax(ObjectReader reader)
          : base(reader)
        {
            this.SlotCount = 4;
            var pattern = (PatternSyntax)reader.ReadValue();
            AdjustFlagsAndWidth(pattern);
            this.pattern = pattern;
            var whenClause = (WhenClauseSyntax?)reader.ReadValue();
            if (whenClause != null)
            {
                AdjustFlagsAndWidth(whenClause);
                this.whenClause = whenClause;
            }
            var equalsGreaterThanToken = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(equalsGreaterThanToken);
            this.equalsGreaterThanToken = equalsGreaterThanToken;
            var expression = (ExpressionSyntax)reader.ReadValue();
            AdjustFlagsAndWidth(expression);
            this.expression = expression;
        }

        internal override void WriteTo(ObjectWriter writer)
        {
            base.WriteTo(writer);
            writer.WriteValue(this.pattern);
            writer.WriteValue(this.whenClause);
            writer.WriteValue(this.equalsGreaterThanToken);
            writer.WriteValue(this.expression);
        }

        static SwitchExpressionArmSyntax()
        {
            ObjectBinder.RegisterTypeReader(typeof(SwitchExpressionArmSyntax), r => new SwitchExpressionArmSyntax(r));
        }
    }

    internal sealed partial class TryStatementSyntax : StatementSyntax
    {
        internal readonly GreenNode? attributeLists;
        internal readonly SyntaxToken tryKeyword;
        internal readonly BlockSyntax block;
        internal readonly GreenNode? catches;
        internal readonly FinallyClauseSyntax? @finally;

        internal TryStatementSyntax(SyntaxKind kind, GreenNode? attributeLists, SyntaxToken tryKeyword, BlockSyntax block, GreenNode? catches, FinallyClauseSyntax? @finally, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
            this.SlotCount = 5;
            if (attributeLists != null)
            {
                this.AdjustFlagsAndWidth(attributeLists);
                this.attributeLists = attributeLists;
            }
            this.AdjustFlagsAndWidth(tryKeyword);
            this.tryKeyword = tryKeyword;
            this.AdjustFlagsAndWidth(block);
            this.block = block;
            if (catches != null)
            {
                this.AdjustFlagsAndWidth(catches);
                this.catches = catches;
            }
            if (@finally != null)
            {
                this.AdjustFlagsAndWidth(@finally);
                this.@finally = @finally;
            }
        }

        internal TryStatementSyntax(SyntaxKind kind, GreenNode? attributeLists, SyntaxToken tryKeyword, BlockSyntax block, GreenNode? catches, FinallyClauseSyntax? @finally, SyntaxFactoryContext context)
          : base(kind)
        {
            this.SetFactoryContext(context);
            this.SlotCount = 5;
            if (attributeLists != null)
            {
                this.AdjustFlagsAndWidth(attributeLists);
                this.attributeLists = attributeLists;
            }
            this.AdjustFlagsAndWidth(tryKeyword);
            this.tryKeyword = tryKeyword;
            this.AdjustFlagsAndWidth(block);
            this.block = block;
            if (catches != null)
            {
                this.AdjustFlagsAndWidth(catches);
                this.catches = catches;
            }
            if (@finally != null)
            {
                this.AdjustFlagsAndWidth(@finally);
                this.@finally = @finally;
            }
        }

        internal TryStatementSyntax(SyntaxKind kind, GreenNode? attributeLists, SyntaxToken tryKeyword, BlockSyntax block, GreenNode? catches, FinallyClauseSyntax? @finally)
          : base(kind)
        {
            this.SlotCount = 5;
            if (attributeLists != null)
            {
                this.AdjustFlagsAndWidth(attributeLists);
                this.attributeLists = attributeLists;
            }
            this.AdjustFlagsAndWidth(tryKeyword);
            this.tryKeyword = tryKeyword;
            this.AdjustFlagsAndWidth(block);
            this.block = block;
            if (catches != null)
            {
                this.AdjustFlagsAndWidth(catches);
                this.catches = catches;
            }
            if (@finally != null)
            {
                this.AdjustFlagsAndWidth(@finally);
                this.@finally = @finally;
            }
        }

        public override Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<AttributeListSyntax> AttributeLists => new Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<AttributeListSyntax>(this.attributeLists);
        public SyntaxToken TryKeyword => this.tryKeyword;
        public BlockSyntax Block => this.block;
        public Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<CatchClauseSyntax> Catches => new Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<CatchClauseSyntax>(this.catches);
        public FinallyClauseSyntax? Finally => this.@finally;

        internal override GreenNode? GetSlot(int index)
            => index switch
            {
                0 => this.attributeLists,
                1 => this.tryKeyword,
                2 => this.block,
                3 => this.catches,
                4 => this.@finally,
                _ => null,
            };

        internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new CSharp.Syntax.TryStatementSyntax(this, parent, position);

        public override void Accept(CSharpSyntaxVisitor visitor) => visitor.VisitTryStatement(this);
        public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor) => visitor.VisitTryStatement(this);

        public TryStatementSyntax Update(Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<AttributeListSyntax> attributeLists, SyntaxToken tryKeyword, BlockSyntax block, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<CatchClauseSyntax> catches, FinallyClauseSyntax @finally)
        {
            if (attributeLists != this.AttributeLists || tryKeyword != this.TryKeyword || block != this.Block || catches != this.Catches || @finally != this.Finally)
            {
                var newNode = SyntaxFactory.TryStatement(attributeLists, tryKeyword, block, catches, @finally);
                var diags = GetDiagnostics();
                if (diags?.Length > 0)
                    newNode = newNode.WithDiagnosticsGreen(diags);
                var annotations = GetAnnotations();
                if (annotations?.Length > 0)
                    newNode = newNode.WithAnnotationsGreen(annotations);
                return newNode;
            }

            return this;
        }

        internal override GreenNode SetDiagnostics(DiagnosticInfo[]? diagnostics)
            => new TryStatementSyntax(this.Kind, this.attributeLists, this.tryKeyword, this.block, this.catches, this.@finally, diagnostics, GetAnnotations());

        internal override GreenNode SetAnnotations(SyntaxAnnotation[]? annotations)
            => new TryStatementSyntax(this.Kind, this.attributeLists, this.tryKeyword, this.block, this.catches, this.@finally, GetDiagnostics(), annotations);

        internal TryStatementSyntax(ObjectReader reader)
          : base(reader)
        {
            this.SlotCount = 5;
            var attributeLists = (GreenNode?)reader.ReadValue();
            if (attributeLists != null)
            {
                AdjustFlagsAndWidth(attributeLists);
                this.attributeLists = attributeLists;
            }
            var tryKeyword = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(tryKeyword);
            this.tryKeyword = tryKeyword;
            var block = (BlockSyntax)reader.ReadValue();
            AdjustFlagsAndWidth(block);
            this.block = block;
            var catches = (GreenNode?)reader.ReadValue();
            if (catches != null)
            {
                AdjustFlagsAndWidth(catches);
                this.catches = catches;
            }
            var @finally = (FinallyClauseSyntax?)reader.ReadValue();
            if (@finally != null)
            {
                AdjustFlagsAndWidth(@finally);
                this.@finally = @finally;
            }
        }

        internal override void WriteTo(ObjectWriter writer)
        {
            base.WriteTo(writer);
            writer.WriteValue(this.attributeLists);
            writer.WriteValue(this.tryKeyword);
            writer.WriteValue(this.block);
            writer.WriteValue(this.catches);
            writer.WriteValue(this.@finally);
        }

        static TryStatementSyntax()
        {
            ObjectBinder.RegisterTypeReader(typeof(TryStatementSyntax), r => new TryStatementSyntax(r));
        }
    }

    internal sealed partial class CatchClauseSyntax : CSharpSyntaxNode
    {
        internal readonly SyntaxToken catchKeyword;
        internal readonly CatchDeclarationSyntax? declaration;
        internal readonly CatchFilterClauseSyntax? filter;
        internal readonly BlockSyntax block;

        internal CatchClauseSyntax(SyntaxKind kind, SyntaxToken catchKeyword, CatchDeclarationSyntax? declaration, CatchFilterClauseSyntax? filter, BlockSyntax block, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
            this.SlotCount = 4;
            this.AdjustFlagsAndWidth(catchKeyword);
            this.catchKeyword = catchKeyword;
            if (declaration != null)
            {
                this.AdjustFlagsAndWidth(declaration);
                this.declaration = declaration;
            }
            if (filter != null)
            {
                this.AdjustFlagsAndWidth(filter);
                this.filter = filter;
            }
            this.AdjustFlagsAndWidth(block);
            this.block = block;
        }

        internal CatchClauseSyntax(SyntaxKind kind, SyntaxToken catchKeyword, CatchDeclarationSyntax? declaration, CatchFilterClauseSyntax? filter, BlockSyntax block, SyntaxFactoryContext context)
          : base(kind)
        {
            this.SetFactoryContext(context);
            this.SlotCount = 4;
            this.AdjustFlagsAndWidth(catchKeyword);
            this.catchKeyword = catchKeyword;
            if (declaration != null)
            {
                this.AdjustFlagsAndWidth(declaration);
                this.declaration = declaration;
            }
            if (filter != null)
            {
                this.AdjustFlagsAndWidth(filter);
                this.filter = filter;
            }
            this.AdjustFlagsAndWidth(block);
            this.block = block;
        }

        internal CatchClauseSyntax(SyntaxKind kind, SyntaxToken catchKeyword, CatchDeclarationSyntax? declaration, CatchFilterClauseSyntax? filter, BlockSyntax block)
          : base(kind)
        {
            this.SlotCount = 4;
            this.AdjustFlagsAndWidth(catchKeyword);
            this.catchKeyword = catchKeyword;
            if (declaration != null)
            {
                this.AdjustFlagsAndWidth(declaration);
                this.declaration = declaration;
            }
            if (filter != null)
            {
                this.AdjustFlagsAndWidth(filter);
                this.filter = filter;
            }
            this.AdjustFlagsAndWidth(block);
            this.block = block;
        }

        public SyntaxToken CatchKeyword => this.catchKeyword;
        public CatchDeclarationSyntax? Declaration => this.declaration;
        public CatchFilterClauseSyntax? Filter => this.filter;
        public BlockSyntax Block => this.block;

        internal override GreenNode? GetSlot(int index)
            => index switch
            {
                0 => this.catchKeyword,
                1 => this.declaration,
                2 => this.filter,
                3 => this.block,
                _ => null,
            };

        internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new CSharp.Syntax.CatchClauseSyntax(this, parent, position);

        public override void Accept(CSharpSyntaxVisitor visitor) => visitor.VisitCatchClause(this);
        public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor) => visitor.VisitCatchClause(this);

        public CatchClauseSyntax Update(SyntaxToken catchKeyword, CatchDeclarationSyntax declaration, CatchFilterClauseSyntax filter, BlockSyntax block)
        {
            if (catchKeyword != this.CatchKeyword || declaration != this.Declaration || filter != this.Filter || block != this.Block)
            {
                var newNode = SyntaxFactory.CatchClause(catchKeyword, declaration, filter, block);
                var diags = GetDiagnostics();
                if (diags?.Length > 0)
                    newNode = newNode.WithDiagnosticsGreen(diags);
                var annotations = GetAnnotations();
                if (annotations?.Length > 0)
                    newNode = newNode.WithAnnotationsGreen(annotations);
                return newNode;
            }

            return this;
        }

        internal override GreenNode SetDiagnostics(DiagnosticInfo[]? diagnostics)
            => new CatchClauseSyntax(this.Kind, this.catchKeyword, this.declaration, this.filter, this.block, diagnostics, GetAnnotations());

        internal override GreenNode SetAnnotations(SyntaxAnnotation[]? annotations)
            => new CatchClauseSyntax(this.Kind, this.catchKeyword, this.declaration, this.filter, this.block, GetDiagnostics(), annotations);

        internal CatchClauseSyntax(ObjectReader reader)
          : base(reader)
        {
            this.SlotCount = 4;
            var catchKeyword = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(catchKeyword);
            this.catchKeyword = catchKeyword;
            var declaration = (CatchDeclarationSyntax?)reader.ReadValue();
            if (declaration != null)
            {
                AdjustFlagsAndWidth(declaration);
                this.declaration = declaration;
            }
            var filter = (CatchFilterClauseSyntax?)reader.ReadValue();
            if (filter != null)
            {
                AdjustFlagsAndWidth(filter);
                this.filter = filter;
            }
            var block = (BlockSyntax)reader.ReadValue();
            AdjustFlagsAndWidth(block);
            this.block = block;
        }

        internal override void WriteTo(ObjectWriter writer)
        {
            base.WriteTo(writer);
            writer.WriteValue(this.catchKeyword);
            writer.WriteValue(this.declaration);
            writer.WriteValue(this.filter);
            writer.WriteValue(this.block);
        }

        static CatchClauseSyntax()
        {
            ObjectBinder.RegisterTypeReader(typeof(CatchClauseSyntax), r => new CatchClauseSyntax(r));
        }
    }

    internal sealed partial class CatchDeclarationSyntax : CSharpSyntaxNode
    {
        internal readonly SyntaxToken openParenToken;
        internal readonly TypeSyntax type;
        internal readonly SyntaxToken? identifier;
        internal readonly SyntaxToken closeParenToken;

        internal CatchDeclarationSyntax(SyntaxKind kind, SyntaxToken openParenToken, TypeSyntax type, SyntaxToken? identifier, SyntaxToken closeParenToken, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
            this.SlotCount = 4;
            this.AdjustFlagsAndWidth(openParenToken);
            this.openParenToken = openParenToken;
            this.AdjustFlagsAndWidth(type);
            this.type = type;
            if (identifier != null)
            {
                this.AdjustFlagsAndWidth(identifier);
                this.identifier = identifier;
            }
            this.AdjustFlagsAndWidth(closeParenToken);
            this.closeParenToken = closeParenToken;
        }

        internal CatchDeclarationSyntax(SyntaxKind kind, SyntaxToken openParenToken, TypeSyntax type, SyntaxToken? identifier, SyntaxToken closeParenToken, SyntaxFactoryContext context)
          : base(kind)
        {
            this.SetFactoryContext(context);
            this.SlotCount = 4;
            this.AdjustFlagsAndWidth(openParenToken);
            this.openParenToken = openParenToken;
            this.AdjustFlagsAndWidth(type);
            this.type = type;
            if (identifier != null)
            {
                this.AdjustFlagsAndWidth(identifier);
                this.identifier = identifier;
            }
            this.AdjustFlagsAndWidth(closeParenToken);
            this.closeParenToken = closeParenToken;
        }

        internal CatchDeclarationSyntax(SyntaxKind kind, SyntaxToken openParenToken, TypeSyntax type, SyntaxToken? identifier, SyntaxToken closeParenToken)
          : base(kind)
        {
            this.SlotCount = 4;
            this.AdjustFlagsAndWidth(openParenToken);
            this.openParenToken = openParenToken;
            this.AdjustFlagsAndWidth(type);
            this.type = type;
            if (identifier != null)
            {
                this.AdjustFlagsAndWidth(identifier);
                this.identifier = identifier;
            }
            this.AdjustFlagsAndWidth(closeParenToken);
            this.closeParenToken = closeParenToken;
        }

        public SyntaxToken OpenParenToken => this.openParenToken;
        public TypeSyntax Type => this.type;
        public SyntaxToken? Identifier => this.identifier;
        public SyntaxToken CloseParenToken => this.closeParenToken;

        internal override GreenNode? GetSlot(int index)
            => index switch
            {
                0 => this.openParenToken,
                1 => this.type,
                2 => this.identifier,
                3 => this.closeParenToken,
                _ => null,
            };

        internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new CSharp.Syntax.CatchDeclarationSyntax(this, parent, position);

        public override void Accept(CSharpSyntaxVisitor visitor) => visitor.VisitCatchDeclaration(this);
        public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor) => visitor.VisitCatchDeclaration(this);

        public CatchDeclarationSyntax Update(SyntaxToken openParenToken, TypeSyntax type, SyntaxToken identifier, SyntaxToken closeParenToken)
        {
            if (openParenToken != this.OpenParenToken || type != this.Type || identifier != this.Identifier || closeParenToken != this.CloseParenToken)
            {
                var newNode = SyntaxFactory.CatchDeclaration(openParenToken, type, identifier, closeParenToken);
                var diags = GetDiagnostics();
                if (diags?.Length > 0)
                    newNode = newNode.WithDiagnosticsGreen(diags);
                var annotations = GetAnnotations();
                if (annotations?.Length > 0)
                    newNode = newNode.WithAnnotationsGreen(annotations);
                return newNode;
            }

            return this;
        }

        internal override GreenNode SetDiagnostics(DiagnosticInfo[]? diagnostics)
            => new CatchDeclarationSyntax(this.Kind, this.openParenToken, this.type, this.identifier, this.closeParenToken, diagnostics, GetAnnotations());

        internal override GreenNode SetAnnotations(SyntaxAnnotation[]? annotations)
            => new CatchDeclarationSyntax(this.Kind, this.openParenToken, this.type, this.identifier, this.closeParenToken, GetDiagnostics(), annotations);

        internal CatchDeclarationSyntax(ObjectReader reader)
          : base(reader)
        {
            this.SlotCount = 4;
            var openParenToken = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(openParenToken);
            this.openParenToken = openParenToken;
            var type = (TypeSyntax)reader.ReadValue();
            AdjustFlagsAndWidth(type);
            this.type = type;
            var identifier = (SyntaxToken?)reader.ReadValue();
            if (identifier != null)
            {
                AdjustFlagsAndWidth(identifier);
                this.identifier = identifier;
            }
            var closeParenToken = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(closeParenToken);
            this.closeParenToken = closeParenToken;
        }

        internal override void WriteTo(ObjectWriter writer)
        {
            base.WriteTo(writer);
            writer.WriteValue(this.openParenToken);
            writer.WriteValue(this.type);
            writer.WriteValue(this.identifier);
            writer.WriteValue(this.closeParenToken);
        }

        static CatchDeclarationSyntax()
        {
            ObjectBinder.RegisterTypeReader(typeof(CatchDeclarationSyntax), r => new CatchDeclarationSyntax(r));
        }
    }

    internal sealed partial class CatchFilterClauseSyntax : CSharpSyntaxNode
    {
        internal readonly SyntaxToken whenKeyword;
        internal readonly SyntaxToken openParenToken;
        internal readonly ExpressionSyntax filterExpression;
        internal readonly SyntaxToken closeParenToken;

        internal CatchFilterClauseSyntax(SyntaxKind kind, SyntaxToken whenKeyword, SyntaxToken openParenToken, ExpressionSyntax filterExpression, SyntaxToken closeParenToken, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
            this.SlotCount = 4;
            this.AdjustFlagsAndWidth(whenKeyword);
            this.whenKeyword = whenKeyword;
            this.AdjustFlagsAndWidth(openParenToken);
            this.openParenToken = openParenToken;
            this.AdjustFlagsAndWidth(filterExpression);
            this.filterExpression = filterExpression;
            this.AdjustFlagsAndWidth(closeParenToken);
            this.closeParenToken = closeParenToken;
        }

        internal CatchFilterClauseSyntax(SyntaxKind kind, SyntaxToken whenKeyword, SyntaxToken openParenToken, ExpressionSyntax filterExpression, SyntaxToken closeParenToken, SyntaxFactoryContext context)
          : base(kind)
        {
            this.SetFactoryContext(context);
            this.SlotCount = 4;
            this.AdjustFlagsAndWidth(whenKeyword);
            this.whenKeyword = whenKeyword;
            this.AdjustFlagsAndWidth(openParenToken);
            this.openParenToken = openParenToken;
            this.AdjustFlagsAndWidth(filterExpression);
            this.filterExpression = filterExpression;
            this.AdjustFlagsAndWidth(closeParenToken);
            this.closeParenToken = closeParenToken;
        }

        internal CatchFilterClauseSyntax(SyntaxKind kind, SyntaxToken whenKeyword, SyntaxToken openParenToken, ExpressionSyntax filterExpression, SyntaxToken closeParenToken)
          : base(kind)
        {
            this.SlotCount = 4;
            this.AdjustFlagsAndWidth(whenKeyword);
            this.whenKeyword = whenKeyword;
            this.AdjustFlagsAndWidth(openParenToken);
            this.openParenToken = openParenToken;
            this.AdjustFlagsAndWidth(filterExpression);
            this.filterExpression = filterExpression;
            this.AdjustFlagsAndWidth(closeParenToken);
            this.closeParenToken = closeParenToken;
        }

        public SyntaxToken WhenKeyword => this.whenKeyword;
        public SyntaxToken OpenParenToken => this.openParenToken;
        public ExpressionSyntax FilterExpression => this.filterExpression;
        public SyntaxToken CloseParenToken => this.closeParenToken;

        internal override GreenNode? GetSlot(int index)
            => index switch
            {
                0 => this.whenKeyword,
                1 => this.openParenToken,
                2 => this.filterExpression,
                3 => this.closeParenToken,
                _ => null,
            };

        internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new CSharp.Syntax.CatchFilterClauseSyntax(this, parent, position);

        public override void Accept(CSharpSyntaxVisitor visitor) => visitor.VisitCatchFilterClause(this);
        public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor) => visitor.VisitCatchFilterClause(this);

        public CatchFilterClauseSyntax Update(SyntaxToken whenKeyword, SyntaxToken openParenToken, ExpressionSyntax filterExpression, SyntaxToken closeParenToken)
        {
            if (whenKeyword != this.WhenKeyword || openParenToken != this.OpenParenToken || filterExpression != this.FilterExpression || closeParenToken != this.CloseParenToken)
            {
                var newNode = SyntaxFactory.CatchFilterClause(whenKeyword, openParenToken, filterExpression, closeParenToken);
                var diags = GetDiagnostics();
                if (diags?.Length > 0)
                    newNode = newNode.WithDiagnosticsGreen(diags);
                var annotations = GetAnnotations();
                if (annotations?.Length > 0)
                    newNode = newNode.WithAnnotationsGreen(annotations);
                return newNode;
            }

            return this;
        }

        internal override GreenNode SetDiagnostics(DiagnosticInfo[]? diagnostics)
            => new CatchFilterClauseSyntax(this.Kind, this.whenKeyword, this.openParenToken, this.filterExpression, this.closeParenToken, diagnostics, GetAnnotations());

        internal override GreenNode SetAnnotations(SyntaxAnnotation[]? annotations)
            => new CatchFilterClauseSyntax(this.Kind, this.whenKeyword, this.openParenToken, this.filterExpression, this.closeParenToken, GetDiagnostics(), annotations);

        internal CatchFilterClauseSyntax(ObjectReader reader)
          : base(reader)
        {
            this.SlotCount = 4;
            var whenKeyword = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(whenKeyword);
            this.whenKeyword = whenKeyword;
            var openParenToken = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(openParenToken);
            this.openParenToken = openParenToken;
            var filterExpression = (ExpressionSyntax)reader.ReadValue();
            AdjustFlagsAndWidth(filterExpression);
            this.filterExpression = filterExpression;
            var closeParenToken = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(closeParenToken);
            this.closeParenToken = closeParenToken;
        }

        internal override void WriteTo(ObjectWriter writer)
        {
            base.WriteTo(writer);
            writer.WriteValue(this.whenKeyword);
            writer.WriteValue(this.openParenToken);
            writer.WriteValue(this.filterExpression);
            writer.WriteValue(this.closeParenToken);
        }

        static CatchFilterClauseSyntax()
        {
            ObjectBinder.RegisterTypeReader(typeof(CatchFilterClauseSyntax), r => new CatchFilterClauseSyntax(r));
        }
    }

    internal sealed partial class FinallyClauseSyntax : CSharpSyntaxNode
    {
        internal readonly SyntaxToken finallyKeyword;
        internal readonly BlockSyntax block;

        internal FinallyClauseSyntax(SyntaxKind kind, SyntaxToken finallyKeyword, BlockSyntax block, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
            this.SlotCount = 2;
            this.AdjustFlagsAndWidth(finallyKeyword);
            this.finallyKeyword = finallyKeyword;
            this.AdjustFlagsAndWidth(block);
            this.block = block;
        }

        internal FinallyClauseSyntax(SyntaxKind kind, SyntaxToken finallyKeyword, BlockSyntax block, SyntaxFactoryContext context)
          : base(kind)
        {
            this.SetFactoryContext(context);
            this.SlotCount = 2;
            this.AdjustFlagsAndWidth(finallyKeyword);
            this.finallyKeyword = finallyKeyword;
            this.AdjustFlagsAndWidth(block);
            this.block = block;
        }

        internal FinallyClauseSyntax(SyntaxKind kind, SyntaxToken finallyKeyword, BlockSyntax block)
          : base(kind)
        {
            this.SlotCount = 2;
            this.AdjustFlagsAndWidth(finallyKeyword);
            this.finallyKeyword = finallyKeyword;
            this.AdjustFlagsAndWidth(block);
            this.block = block;
        }

        public SyntaxToken FinallyKeyword => this.finallyKeyword;
        public BlockSyntax Block => this.block;

        internal override GreenNode? GetSlot(int index)
            => index switch
            {
                0 => this.finallyKeyword,
                1 => this.block,
                _ => null,
            };

        internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new CSharp.Syntax.FinallyClauseSyntax(this, parent, position);

        public override void Accept(CSharpSyntaxVisitor visitor) => visitor.VisitFinallyClause(this);
        public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor) => visitor.VisitFinallyClause(this);

        public FinallyClauseSyntax Update(SyntaxToken finallyKeyword, BlockSyntax block)
        {
            if (finallyKeyword != this.FinallyKeyword || block != this.Block)
            {
                var newNode = SyntaxFactory.FinallyClause(finallyKeyword, block);
                var diags = GetDiagnostics();
                if (diags?.Length > 0)
                    newNode = newNode.WithDiagnosticsGreen(diags);
                var annotations = GetAnnotations();
                if (annotations?.Length > 0)
                    newNode = newNode.WithAnnotationsGreen(annotations);
                return newNode;
            }

            return this;
        }

        internal override GreenNode SetDiagnostics(DiagnosticInfo[]? diagnostics)
            => new FinallyClauseSyntax(this.Kind, this.finallyKeyword, this.block, diagnostics, GetAnnotations());

        internal override GreenNode SetAnnotations(SyntaxAnnotation[]? annotations)
            => new FinallyClauseSyntax(this.Kind, this.finallyKeyword, this.block, GetDiagnostics(), annotations);

        internal FinallyClauseSyntax(ObjectReader reader)
          : base(reader)
        {
            this.SlotCount = 2;
            var finallyKeyword = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(finallyKeyword);
            this.finallyKeyword = finallyKeyword;
            var block = (BlockSyntax)reader.ReadValue();
            AdjustFlagsAndWidth(block);
            this.block = block;
        }

        internal override void WriteTo(ObjectWriter writer)
        {
            base.WriteTo(writer);
            writer.WriteValue(this.finallyKeyword);
            writer.WriteValue(this.block);
        }

        static FinallyClauseSyntax()
        {
            ObjectBinder.RegisterTypeReader(typeof(FinallyClauseSyntax), r => new FinallyClauseSyntax(r));
        }
    }

    internal sealed partial class CompilationUnitSyntax : CSharpSyntaxNode
    {
        internal readonly GreenNode? externs;
        internal readonly GreenNode? usings;
        internal readonly GreenNode? attributeLists;
        internal readonly GreenNode? members;
        internal readonly SyntaxToken endOfFileToken;

        internal CompilationUnitSyntax(SyntaxKind kind, GreenNode? externs, GreenNode? usings, GreenNode? attributeLists, GreenNode? members, SyntaxToken endOfFileToken, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
            this.SlotCount = 5;
            if (externs != null)
            {
                this.AdjustFlagsAndWidth(externs);
                this.externs = externs;
            }
            if (usings != null)
            {
                this.AdjustFlagsAndWidth(usings);
                this.usings = usings;
            }
            if (attributeLists != null)
            {
                this.AdjustFlagsAndWidth(attributeLists);
                this.attributeLists = attributeLists;
            }
            if (members != null)
            {
                this.AdjustFlagsAndWidth(members);
                this.members = members;
            }
            this.AdjustFlagsAndWidth(endOfFileToken);
            this.endOfFileToken = endOfFileToken;
        }

        internal CompilationUnitSyntax(SyntaxKind kind, GreenNode? externs, GreenNode? usings, GreenNode? attributeLists, GreenNode? members, SyntaxToken endOfFileToken, SyntaxFactoryContext context)
          : base(kind)
        {
            this.SetFactoryContext(context);
            this.SlotCount = 5;
            if (externs != null)
            {
                this.AdjustFlagsAndWidth(externs);
                this.externs = externs;
            }
            if (usings != null)
            {
                this.AdjustFlagsAndWidth(usings);
                this.usings = usings;
            }
            if (attributeLists != null)
            {
                this.AdjustFlagsAndWidth(attributeLists);
                this.attributeLists = attributeLists;
            }
            if (members != null)
            {
                this.AdjustFlagsAndWidth(members);
                this.members = members;
            }
            this.AdjustFlagsAndWidth(endOfFileToken);
            this.endOfFileToken = endOfFileToken;
        }

        internal CompilationUnitSyntax(SyntaxKind kind, GreenNode? externs, GreenNode? usings, GreenNode? attributeLists, GreenNode? members, SyntaxToken endOfFileToken)
          : base(kind)
        {
            this.SlotCount = 5;
            if (externs != null)
            {
                this.AdjustFlagsAndWidth(externs);
                this.externs = externs;
            }
            if (usings != null)
            {
                this.AdjustFlagsAndWidth(usings);
                this.usings = usings;
            }
            if (attributeLists != null)
            {
                this.AdjustFlagsAndWidth(attributeLists);
                this.attributeLists = attributeLists;
            }
            if (members != null)
            {
                this.AdjustFlagsAndWidth(members);
                this.members = members;
            }
            this.AdjustFlagsAndWidth(endOfFileToken);
            this.endOfFileToken = endOfFileToken;
        }

        public Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<ExternAliasDirectiveSyntax> Externs => new Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<ExternAliasDirectiveSyntax>(this.externs);
        public Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<UsingDirectiveSyntax> Usings => new Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<UsingDirectiveSyntax>(this.usings);
        /// <summary>Gets the attribute declaration list.</summary>
        public Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<AttributeListSyntax> AttributeLists => new Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<AttributeListSyntax>(this.attributeLists);
        public Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<MemberDeclarationSyntax> Members => new Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<MemberDeclarationSyntax>(this.members);
        public SyntaxToken EndOfFileToken => this.endOfFileToken;

        internal override GreenNode? GetSlot(int index)
            => index switch
            {
                0 => this.externs,
                1 => this.usings,
                2 => this.attributeLists,
                3 => this.members,
                4 => this.endOfFileToken,
                _ => null,
            };

        internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new CSharp.Syntax.CompilationUnitSyntax(this, parent, position);

        public override void Accept(CSharpSyntaxVisitor visitor) => visitor.VisitCompilationUnit(this);
        public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor) => visitor.VisitCompilationUnit(this);

        public CompilationUnitSyntax Update(Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<ExternAliasDirectiveSyntax> externs, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<UsingDirectiveSyntax> usings, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<AttributeListSyntax> attributeLists, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<MemberDeclarationSyntax> members, SyntaxToken endOfFileToken)
        {
            if (externs != this.Externs || usings != this.Usings || attributeLists != this.AttributeLists || members != this.Members || endOfFileToken != this.EndOfFileToken)
            {
                var newNode = SyntaxFactory.CompilationUnit(externs, usings, attributeLists, members, endOfFileToken);
                var diags = GetDiagnostics();
                if (diags?.Length > 0)
                    newNode = newNode.WithDiagnosticsGreen(diags);
                var annotations = GetAnnotations();
                if (annotations?.Length > 0)
                    newNode = newNode.WithAnnotationsGreen(annotations);
                return newNode;
            }

            return this;
        }

        internal override GreenNode SetDiagnostics(DiagnosticInfo[]? diagnostics)
            => new CompilationUnitSyntax(this.Kind, this.externs, this.usings, this.attributeLists, this.members, this.endOfFileToken, diagnostics, GetAnnotations());

        internal override GreenNode SetAnnotations(SyntaxAnnotation[]? annotations)
            => new CompilationUnitSyntax(this.Kind, this.externs, this.usings, this.attributeLists, this.members, this.endOfFileToken, GetDiagnostics(), annotations);

        internal CompilationUnitSyntax(ObjectReader reader)
          : base(reader)
        {
            this.SlotCount = 5;
            var externs = (GreenNode?)reader.ReadValue();
            if (externs != null)
            {
                AdjustFlagsAndWidth(externs);
                this.externs = externs;
            }
            var usings = (GreenNode?)reader.ReadValue();
            if (usings != null)
            {
                AdjustFlagsAndWidth(usings);
                this.usings = usings;
            }
            var attributeLists = (GreenNode?)reader.ReadValue();
            if (attributeLists != null)
            {
                AdjustFlagsAndWidth(attributeLists);
                this.attributeLists = attributeLists;
            }
            var members = (GreenNode?)reader.ReadValue();
            if (members != null)
            {
                AdjustFlagsAndWidth(members);
                this.members = members;
            }
            var endOfFileToken = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(endOfFileToken);
            this.endOfFileToken = endOfFileToken;
        }

        internal override void WriteTo(ObjectWriter writer)
        {
            base.WriteTo(writer);
            writer.WriteValue(this.externs);
            writer.WriteValue(this.usings);
            writer.WriteValue(this.attributeLists);
            writer.WriteValue(this.members);
            writer.WriteValue(this.endOfFileToken);
        }

        static CompilationUnitSyntax()
        {
            ObjectBinder.RegisterTypeReader(typeof(CompilationUnitSyntax), r => new CompilationUnitSyntax(r));
        }
    }

    /// <summary>
    /// Represents an ExternAlias directive syntax, e.g. "extern alias MyAlias;" with specifying "/r:MyAlias=SomeAssembly.dll " on the compiler command line.
    /// </summary>
    internal sealed partial class ExternAliasDirectiveSyntax : CSharpSyntaxNode
    {
        internal readonly SyntaxToken externKeyword;
        internal readonly SyntaxToken aliasKeyword;
        internal readonly SyntaxToken identifier;
        internal readonly SyntaxToken semicolonToken;

        internal ExternAliasDirectiveSyntax(SyntaxKind kind, SyntaxToken externKeyword, SyntaxToken aliasKeyword, SyntaxToken identifier, SyntaxToken semicolonToken, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
            this.SlotCount = 4;
            this.AdjustFlagsAndWidth(externKeyword);
            this.externKeyword = externKeyword;
            this.AdjustFlagsAndWidth(aliasKeyword);
            this.aliasKeyword = aliasKeyword;
            this.AdjustFlagsAndWidth(identifier);
            this.identifier = identifier;
            this.AdjustFlagsAndWidth(semicolonToken);
            this.semicolonToken = semicolonToken;
        }

        internal ExternAliasDirectiveSyntax(SyntaxKind kind, SyntaxToken externKeyword, SyntaxToken aliasKeyword, SyntaxToken identifier, SyntaxToken semicolonToken, SyntaxFactoryContext context)
          : base(kind)
        {
            this.SetFactoryContext(context);
            this.SlotCount = 4;
            this.AdjustFlagsAndWidth(externKeyword);
            this.externKeyword = externKeyword;
            this.AdjustFlagsAndWidth(aliasKeyword);
            this.aliasKeyword = aliasKeyword;
            this.AdjustFlagsAndWidth(identifier);
            this.identifier = identifier;
            this.AdjustFlagsAndWidth(semicolonToken);
            this.semicolonToken = semicolonToken;
        }

        internal ExternAliasDirectiveSyntax(SyntaxKind kind, SyntaxToken externKeyword, SyntaxToken aliasKeyword, SyntaxToken identifier, SyntaxToken semicolonToken)
          : base(kind)
        {
            this.SlotCount = 4;
            this.AdjustFlagsAndWidth(externKeyword);
            this.externKeyword = externKeyword;
            this.AdjustFlagsAndWidth(aliasKeyword);
            this.aliasKeyword = aliasKeyword;
            this.AdjustFlagsAndWidth(identifier);
            this.identifier = identifier;
            this.AdjustFlagsAndWidth(semicolonToken);
            this.semicolonToken = semicolonToken;
        }

        /// <summary>SyntaxToken representing the extern keyword.</summary>
        public SyntaxToken ExternKeyword => this.externKeyword;
        /// <summary>SyntaxToken representing the alias keyword.</summary>
        public SyntaxToken AliasKeyword => this.aliasKeyword;
        /// <summary>Gets the identifier.</summary>
        public SyntaxToken Identifier => this.identifier;
        /// <summary>SyntaxToken representing the semicolon token.</summary>
        public SyntaxToken SemicolonToken => this.semicolonToken;

        internal override GreenNode? GetSlot(int index)
            => index switch
            {
                0 => this.externKeyword,
                1 => this.aliasKeyword,
                2 => this.identifier,
                3 => this.semicolonToken,
                _ => null,
            };

        internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new CSharp.Syntax.ExternAliasDirectiveSyntax(this, parent, position);

        public override void Accept(CSharpSyntaxVisitor visitor) => visitor.VisitExternAliasDirective(this);
        public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor) => visitor.VisitExternAliasDirective(this);

        public ExternAliasDirectiveSyntax Update(SyntaxToken externKeyword, SyntaxToken aliasKeyword, SyntaxToken identifier, SyntaxToken semicolonToken)
        {
            if (externKeyword != this.ExternKeyword || aliasKeyword != this.AliasKeyword || identifier != this.Identifier || semicolonToken != this.SemicolonToken)
            {
                var newNode = SyntaxFactory.ExternAliasDirective(externKeyword, aliasKeyword, identifier, semicolonToken);
                var diags = GetDiagnostics();
                if (diags?.Length > 0)
                    newNode = newNode.WithDiagnosticsGreen(diags);
                var annotations = GetAnnotations();
                if (annotations?.Length > 0)
                    newNode = newNode.WithAnnotationsGreen(annotations);
                return newNode;
            }

            return this;
        }

        internal override GreenNode SetDiagnostics(DiagnosticInfo[]? diagnostics)
            => new ExternAliasDirectiveSyntax(this.Kind, this.externKeyword, this.aliasKeyword, this.identifier, this.semicolonToken, diagnostics, GetAnnotations());

        internal override GreenNode SetAnnotations(SyntaxAnnotation[]? annotations)
            => new ExternAliasDirectiveSyntax(this.Kind, this.externKeyword, this.aliasKeyword, this.identifier, this.semicolonToken, GetDiagnostics(), annotations);

        internal ExternAliasDirectiveSyntax(ObjectReader reader)
          : base(reader)
        {
            this.SlotCount = 4;
            var externKeyword = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(externKeyword);
            this.externKeyword = externKeyword;
            var aliasKeyword = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(aliasKeyword);
            this.aliasKeyword = aliasKeyword;
            var identifier = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(identifier);
            this.identifier = identifier;
            var semicolonToken = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(semicolonToken);
            this.semicolonToken = semicolonToken;
        }

        internal override void WriteTo(ObjectWriter writer)
        {
            base.WriteTo(writer);
            writer.WriteValue(this.externKeyword);
            writer.WriteValue(this.aliasKeyword);
            writer.WriteValue(this.identifier);
            writer.WriteValue(this.semicolonToken);
        }

        static ExternAliasDirectiveSyntax()
        {
            ObjectBinder.RegisterTypeReader(typeof(ExternAliasDirectiveSyntax), r => new ExternAliasDirectiveSyntax(r));
        }
    }

    internal sealed partial class UsingDirectiveSyntax : CSharpSyntaxNode
    {
        internal readonly SyntaxToken usingKeyword;
        internal readonly SyntaxToken? staticKeyword;
        internal readonly NameEqualsSyntax? alias;
        internal readonly NameSyntax name;
        internal readonly SyntaxToken semicolonToken;

        internal UsingDirectiveSyntax(SyntaxKind kind, SyntaxToken usingKeyword, SyntaxToken? staticKeyword, NameEqualsSyntax? alias, NameSyntax name, SyntaxToken semicolonToken, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
            this.SlotCount = 5;
            this.AdjustFlagsAndWidth(usingKeyword);
            this.usingKeyword = usingKeyword;
            if (staticKeyword != null)
            {
                this.AdjustFlagsAndWidth(staticKeyword);
                this.staticKeyword = staticKeyword;
            }
            if (alias != null)
            {
                this.AdjustFlagsAndWidth(alias);
                this.alias = alias;
            }
            this.AdjustFlagsAndWidth(name);
            this.name = name;
            this.AdjustFlagsAndWidth(semicolonToken);
            this.semicolonToken = semicolonToken;
        }

        internal UsingDirectiveSyntax(SyntaxKind kind, SyntaxToken usingKeyword, SyntaxToken? staticKeyword, NameEqualsSyntax? alias, NameSyntax name, SyntaxToken semicolonToken, SyntaxFactoryContext context)
          : base(kind)
        {
            this.SetFactoryContext(context);
            this.SlotCount = 5;
            this.AdjustFlagsAndWidth(usingKeyword);
            this.usingKeyword = usingKeyword;
            if (staticKeyword != null)
            {
                this.AdjustFlagsAndWidth(staticKeyword);
                this.staticKeyword = staticKeyword;
            }
            if (alias != null)
            {
                this.AdjustFlagsAndWidth(alias);
                this.alias = alias;
            }
            this.AdjustFlagsAndWidth(name);
            this.name = name;
            this.AdjustFlagsAndWidth(semicolonToken);
            this.semicolonToken = semicolonToken;
        }

        internal UsingDirectiveSyntax(SyntaxKind kind, SyntaxToken usingKeyword, SyntaxToken? staticKeyword, NameEqualsSyntax? alias, NameSyntax name, SyntaxToken semicolonToken)
          : base(kind)
        {
            this.SlotCount = 5;
            this.AdjustFlagsAndWidth(usingKeyword);
            this.usingKeyword = usingKeyword;
            if (staticKeyword != null)
            {
                this.AdjustFlagsAndWidth(staticKeyword);
                this.staticKeyword = staticKeyword;
            }
            if (alias != null)
            {
                this.AdjustFlagsAndWidth(alias);
                this.alias = alias;
            }
            this.AdjustFlagsAndWidth(name);
            this.name = name;
            this.AdjustFlagsAndWidth(semicolonToken);
            this.semicolonToken = semicolonToken;
        }

        public SyntaxToken UsingKeyword => this.usingKeyword;
        public SyntaxToken? StaticKeyword => this.staticKeyword;
        public NameEqualsSyntax? Alias => this.alias;
        public NameSyntax Name => this.name;
        public SyntaxToken SemicolonToken => this.semicolonToken;

        internal override GreenNode? GetSlot(int index)
            => index switch
            {
                0 => this.usingKeyword,
                1 => this.staticKeyword,
                2 => this.alias,
                3 => this.name,
                4 => this.semicolonToken,
                _ => null,
            };

        internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new CSharp.Syntax.UsingDirectiveSyntax(this, parent, position);

        public override void Accept(CSharpSyntaxVisitor visitor) => visitor.VisitUsingDirective(this);
        public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor) => visitor.VisitUsingDirective(this);

        public UsingDirectiveSyntax Update(SyntaxToken usingKeyword, SyntaxToken staticKeyword, NameEqualsSyntax alias, NameSyntax name, SyntaxToken semicolonToken)
        {
            if (usingKeyword != this.UsingKeyword || staticKeyword != this.StaticKeyword || alias != this.Alias || name != this.Name || semicolonToken != this.SemicolonToken)
            {
                var newNode = SyntaxFactory.UsingDirective(usingKeyword, staticKeyword, alias, name, semicolonToken);
                var diags = GetDiagnostics();
                if (diags?.Length > 0)
                    newNode = newNode.WithDiagnosticsGreen(diags);
                var annotations = GetAnnotations();
                if (annotations?.Length > 0)
                    newNode = newNode.WithAnnotationsGreen(annotations);
                return newNode;
            }

            return this;
        }

        internal override GreenNode SetDiagnostics(DiagnosticInfo[]? diagnostics)
            => new UsingDirectiveSyntax(this.Kind, this.usingKeyword, this.staticKeyword, this.alias, this.name, this.semicolonToken, diagnostics, GetAnnotations());

        internal override GreenNode SetAnnotations(SyntaxAnnotation[]? annotations)
            => new UsingDirectiveSyntax(this.Kind, this.usingKeyword, this.staticKeyword, this.alias, this.name, this.semicolonToken, GetDiagnostics(), annotations);

        internal UsingDirectiveSyntax(ObjectReader reader)
          : base(reader)
        {
            this.SlotCount = 5;
            var usingKeyword = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(usingKeyword);
            this.usingKeyword = usingKeyword;
            var staticKeyword = (SyntaxToken?)reader.ReadValue();
            if (staticKeyword != null)
            {
                AdjustFlagsAndWidth(staticKeyword);
                this.staticKeyword = staticKeyword;
            }
            var alias = (NameEqualsSyntax?)reader.ReadValue();
            if (alias != null)
            {
                AdjustFlagsAndWidth(alias);
                this.alias = alias;
            }
            var name = (NameSyntax)reader.ReadValue();
            AdjustFlagsAndWidth(name);
            this.name = name;
            var semicolonToken = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(semicolonToken);
            this.semicolonToken = semicolonToken;
        }

        internal override void WriteTo(ObjectWriter writer)
        {
            base.WriteTo(writer);
            writer.WriteValue(this.usingKeyword);
            writer.WriteValue(this.staticKeyword);
            writer.WriteValue(this.alias);
            writer.WriteValue(this.name);
            writer.WriteValue(this.semicolonToken);
        }

        static UsingDirectiveSyntax()
        {
            ObjectBinder.RegisterTypeReader(typeof(UsingDirectiveSyntax), r => new UsingDirectiveSyntax(r));
        }
    }

    /// <summary>Member declaration syntax.</summary>
    internal abstract partial class MemberDeclarationSyntax : CSharpSyntaxNode
    {
        internal MemberDeclarationSyntax(SyntaxKind kind, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
        }

        internal MemberDeclarationSyntax(SyntaxKind kind)
          : base(kind)
        {
        }

        protected MemberDeclarationSyntax(ObjectReader reader)
          : base(reader)
        {
        }

        /// <summary>Gets the attribute declaration list.</summary>
        public abstract Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<AttributeListSyntax> AttributeLists { get; }

        /// <summary>Gets the modifier list.</summary>
        public abstract Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SyntaxToken> Modifiers { get; }
    }

    internal sealed partial class NamespaceDeclarationSyntax : MemberDeclarationSyntax
    {
        internal readonly GreenNode? attributeLists;
        internal readonly GreenNode? modifiers;
        internal readonly SyntaxToken namespaceKeyword;
        internal readonly NameSyntax name;
        internal readonly SyntaxToken openBraceToken;
        internal readonly GreenNode? externs;
        internal readonly GreenNode? usings;
        internal readonly GreenNode? members;
        internal readonly SyntaxToken closeBraceToken;
        internal readonly SyntaxToken? semicolonToken;

        internal NamespaceDeclarationSyntax(SyntaxKind kind, GreenNode? attributeLists, GreenNode? modifiers, SyntaxToken namespaceKeyword, NameSyntax name, SyntaxToken openBraceToken, GreenNode? externs, GreenNode? usings, GreenNode? members, SyntaxToken closeBraceToken, SyntaxToken? semicolonToken, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
            this.SlotCount = 10;
            if (attributeLists != null)
            {
                this.AdjustFlagsAndWidth(attributeLists);
                this.attributeLists = attributeLists;
            }
            if (modifiers != null)
            {
                this.AdjustFlagsAndWidth(modifiers);
                this.modifiers = modifiers;
            }
            this.AdjustFlagsAndWidth(namespaceKeyword);
            this.namespaceKeyword = namespaceKeyword;
            this.AdjustFlagsAndWidth(name);
            this.name = name;
            this.AdjustFlagsAndWidth(openBraceToken);
            this.openBraceToken = openBraceToken;
            if (externs != null)
            {
                this.AdjustFlagsAndWidth(externs);
                this.externs = externs;
            }
            if (usings != null)
            {
                this.AdjustFlagsAndWidth(usings);
                this.usings = usings;
            }
            if (members != null)
            {
                this.AdjustFlagsAndWidth(members);
                this.members = members;
            }
            this.AdjustFlagsAndWidth(closeBraceToken);
            this.closeBraceToken = closeBraceToken;
            if (semicolonToken != null)
            {
                this.AdjustFlagsAndWidth(semicolonToken);
                this.semicolonToken = semicolonToken;
            }
        }

        internal NamespaceDeclarationSyntax(SyntaxKind kind, GreenNode? attributeLists, GreenNode? modifiers, SyntaxToken namespaceKeyword, NameSyntax name, SyntaxToken openBraceToken, GreenNode? externs, GreenNode? usings, GreenNode? members, SyntaxToken closeBraceToken, SyntaxToken? semicolonToken, SyntaxFactoryContext context)
          : base(kind)
        {
            this.SetFactoryContext(context);
            this.SlotCount = 10;
            if (attributeLists != null)
            {
                this.AdjustFlagsAndWidth(attributeLists);
                this.attributeLists = attributeLists;
            }
            if (modifiers != null)
            {
                this.AdjustFlagsAndWidth(modifiers);
                this.modifiers = modifiers;
            }
            this.AdjustFlagsAndWidth(namespaceKeyword);
            this.namespaceKeyword = namespaceKeyword;
            this.AdjustFlagsAndWidth(name);
            this.name = name;
            this.AdjustFlagsAndWidth(openBraceToken);
            this.openBraceToken = openBraceToken;
            if (externs != null)
            {
                this.AdjustFlagsAndWidth(externs);
                this.externs = externs;
            }
            if (usings != null)
            {
                this.AdjustFlagsAndWidth(usings);
                this.usings = usings;
            }
            if (members != null)
            {
                this.AdjustFlagsAndWidth(members);
                this.members = members;
            }
            this.AdjustFlagsAndWidth(closeBraceToken);
            this.closeBraceToken = closeBraceToken;
            if (semicolonToken != null)
            {
                this.AdjustFlagsAndWidth(semicolonToken);
                this.semicolonToken = semicolonToken;
            }
        }

        internal NamespaceDeclarationSyntax(SyntaxKind kind, GreenNode? attributeLists, GreenNode? modifiers, SyntaxToken namespaceKeyword, NameSyntax name, SyntaxToken openBraceToken, GreenNode? externs, GreenNode? usings, GreenNode? members, SyntaxToken closeBraceToken, SyntaxToken? semicolonToken)
          : base(kind)
        {
            this.SlotCount = 10;
            if (attributeLists != null)
            {
                this.AdjustFlagsAndWidth(attributeLists);
                this.attributeLists = attributeLists;
            }
            if (modifiers != null)
            {
                this.AdjustFlagsAndWidth(modifiers);
                this.modifiers = modifiers;
            }
            this.AdjustFlagsAndWidth(namespaceKeyword);
            this.namespaceKeyword = namespaceKeyword;
            this.AdjustFlagsAndWidth(name);
            this.name = name;
            this.AdjustFlagsAndWidth(openBraceToken);
            this.openBraceToken = openBraceToken;
            if (externs != null)
            {
                this.AdjustFlagsAndWidth(externs);
                this.externs = externs;
            }
            if (usings != null)
            {
                this.AdjustFlagsAndWidth(usings);
                this.usings = usings;
            }
            if (members != null)
            {
                this.AdjustFlagsAndWidth(members);
                this.members = members;
            }
            this.AdjustFlagsAndWidth(closeBraceToken);
            this.closeBraceToken = closeBraceToken;
            if (semicolonToken != null)
            {
                this.AdjustFlagsAndWidth(semicolonToken);
                this.semicolonToken = semicolonToken;
            }
        }

        public override Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<AttributeListSyntax> AttributeLists => new Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<AttributeListSyntax>(this.attributeLists);
        public override Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SyntaxToken> Modifiers => new Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SyntaxToken>(this.modifiers);
        public SyntaxToken NamespaceKeyword => this.namespaceKeyword;
        public NameSyntax Name => this.name;
        public SyntaxToken OpenBraceToken => this.openBraceToken;
        public Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<ExternAliasDirectiveSyntax> Externs => new Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<ExternAliasDirectiveSyntax>(this.externs);
        public Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<UsingDirectiveSyntax> Usings => new Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<UsingDirectiveSyntax>(this.usings);
        public Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<MemberDeclarationSyntax> Members => new Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<MemberDeclarationSyntax>(this.members);
        public SyntaxToken CloseBraceToken => this.closeBraceToken;
        /// <summary>Gets the optional semicolon token.</summary>
        public SyntaxToken? SemicolonToken => this.semicolonToken;

        internal override GreenNode? GetSlot(int index)
            => index switch
            {
                0 => this.attributeLists,
                1 => this.modifiers,
                2 => this.namespaceKeyword,
                3 => this.name,
                4 => this.openBraceToken,
                5 => this.externs,
                6 => this.usings,
                7 => this.members,
                8 => this.closeBraceToken,
                9 => this.semicolonToken,
                _ => null,
            };

        internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new CSharp.Syntax.NamespaceDeclarationSyntax(this, parent, position);

        public override void Accept(CSharpSyntaxVisitor visitor) => visitor.VisitNamespaceDeclaration(this);
        public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor) => visitor.VisitNamespaceDeclaration(this);

        public NamespaceDeclarationSyntax Update(Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<AttributeListSyntax> attributeLists, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SyntaxToken> modifiers, SyntaxToken namespaceKeyword, NameSyntax name, SyntaxToken openBraceToken, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<ExternAliasDirectiveSyntax> externs, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<UsingDirectiveSyntax> usings, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<MemberDeclarationSyntax> members, SyntaxToken closeBraceToken, SyntaxToken semicolonToken)
        {
            if (attributeLists != this.AttributeLists || modifiers != this.Modifiers || namespaceKeyword != this.NamespaceKeyword || name != this.Name || openBraceToken != this.OpenBraceToken || externs != this.Externs || usings != this.Usings || members != this.Members || closeBraceToken != this.CloseBraceToken || semicolonToken != this.SemicolonToken)
            {
                var newNode = SyntaxFactory.NamespaceDeclaration(attributeLists, modifiers, namespaceKeyword, name, openBraceToken, externs, usings, members, closeBraceToken, semicolonToken);
                var diags = GetDiagnostics();
                if (diags?.Length > 0)
                    newNode = newNode.WithDiagnosticsGreen(diags);
                var annotations = GetAnnotations();
                if (annotations?.Length > 0)
                    newNode = newNode.WithAnnotationsGreen(annotations);
                return newNode;
            }

            return this;
        }

        internal override GreenNode SetDiagnostics(DiagnosticInfo[]? diagnostics)
            => new NamespaceDeclarationSyntax(this.Kind, this.attributeLists, this.modifiers, this.namespaceKeyword, this.name, this.openBraceToken, this.externs, this.usings, this.members, this.closeBraceToken, this.semicolonToken, diagnostics, GetAnnotations());

        internal override GreenNode SetAnnotations(SyntaxAnnotation[]? annotations)
            => new NamespaceDeclarationSyntax(this.Kind, this.attributeLists, this.modifiers, this.namespaceKeyword, this.name, this.openBraceToken, this.externs, this.usings, this.members, this.closeBraceToken, this.semicolonToken, GetDiagnostics(), annotations);

        internal NamespaceDeclarationSyntax(ObjectReader reader)
          : base(reader)
        {
            this.SlotCount = 10;
            var attributeLists = (GreenNode?)reader.ReadValue();
            if (attributeLists != null)
            {
                AdjustFlagsAndWidth(attributeLists);
                this.attributeLists = attributeLists;
            }
            var modifiers = (GreenNode?)reader.ReadValue();
            if (modifiers != null)
            {
                AdjustFlagsAndWidth(modifiers);
                this.modifiers = modifiers;
            }
            var namespaceKeyword = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(namespaceKeyword);
            this.namespaceKeyword = namespaceKeyword;
            var name = (NameSyntax)reader.ReadValue();
            AdjustFlagsAndWidth(name);
            this.name = name;
            var openBraceToken = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(openBraceToken);
            this.openBraceToken = openBraceToken;
            var externs = (GreenNode?)reader.ReadValue();
            if (externs != null)
            {
                AdjustFlagsAndWidth(externs);
                this.externs = externs;
            }
            var usings = (GreenNode?)reader.ReadValue();
            if (usings != null)
            {
                AdjustFlagsAndWidth(usings);
                this.usings = usings;
            }
            var members = (GreenNode?)reader.ReadValue();
            if (members != null)
            {
                AdjustFlagsAndWidth(members);
                this.members = members;
            }
            var closeBraceToken = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(closeBraceToken);
            this.closeBraceToken = closeBraceToken;
            var semicolonToken = (SyntaxToken?)reader.ReadValue();
            if (semicolonToken != null)
            {
                AdjustFlagsAndWidth(semicolonToken);
                this.semicolonToken = semicolonToken;
            }
        }

        internal override void WriteTo(ObjectWriter writer)
        {
            base.WriteTo(writer);
            writer.WriteValue(this.attributeLists);
            writer.WriteValue(this.modifiers);
            writer.WriteValue(this.namespaceKeyword);
            writer.WriteValue(this.name);
            writer.WriteValue(this.openBraceToken);
            writer.WriteValue(this.externs);
            writer.WriteValue(this.usings);
            writer.WriteValue(this.members);
            writer.WriteValue(this.closeBraceToken);
            writer.WriteValue(this.semicolonToken);
        }

        static NamespaceDeclarationSyntax()
        {
            ObjectBinder.RegisterTypeReader(typeof(NamespaceDeclarationSyntax), r => new NamespaceDeclarationSyntax(r));
        }
    }

    /// <summary>Class representing one or more attributes applied to a language construct.</summary>
    internal sealed partial class AttributeListSyntax : CSharpSyntaxNode
    {
        internal readonly SyntaxToken openBracketToken;
        internal readonly AttributeTargetSpecifierSyntax? target;
        internal readonly GreenNode? attributes;
        internal readonly SyntaxToken closeBracketToken;

        internal AttributeListSyntax(SyntaxKind kind, SyntaxToken openBracketToken, AttributeTargetSpecifierSyntax? target, GreenNode? attributes, SyntaxToken closeBracketToken, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
            this.SlotCount = 4;
            this.AdjustFlagsAndWidth(openBracketToken);
            this.openBracketToken = openBracketToken;
            if (target != null)
            {
                this.AdjustFlagsAndWidth(target);
                this.target = target;
            }
            if (attributes != null)
            {
                this.AdjustFlagsAndWidth(attributes);
                this.attributes = attributes;
            }
            this.AdjustFlagsAndWidth(closeBracketToken);
            this.closeBracketToken = closeBracketToken;
        }

        internal AttributeListSyntax(SyntaxKind kind, SyntaxToken openBracketToken, AttributeTargetSpecifierSyntax? target, GreenNode? attributes, SyntaxToken closeBracketToken, SyntaxFactoryContext context)
          : base(kind)
        {
            this.SetFactoryContext(context);
            this.SlotCount = 4;
            this.AdjustFlagsAndWidth(openBracketToken);
            this.openBracketToken = openBracketToken;
            if (target != null)
            {
                this.AdjustFlagsAndWidth(target);
                this.target = target;
            }
            if (attributes != null)
            {
                this.AdjustFlagsAndWidth(attributes);
                this.attributes = attributes;
            }
            this.AdjustFlagsAndWidth(closeBracketToken);
            this.closeBracketToken = closeBracketToken;
        }

        internal AttributeListSyntax(SyntaxKind kind, SyntaxToken openBracketToken, AttributeTargetSpecifierSyntax? target, GreenNode? attributes, SyntaxToken closeBracketToken)
          : base(kind)
        {
            this.SlotCount = 4;
            this.AdjustFlagsAndWidth(openBracketToken);
            this.openBracketToken = openBracketToken;
            if (target != null)
            {
                this.AdjustFlagsAndWidth(target);
                this.target = target;
            }
            if (attributes != null)
            {
                this.AdjustFlagsAndWidth(attributes);
                this.attributes = attributes;
            }
            this.AdjustFlagsAndWidth(closeBracketToken);
            this.closeBracketToken = closeBracketToken;
        }

        /// <summary>Gets the open bracket token.</summary>
        public SyntaxToken OpenBracketToken => this.openBracketToken;
        /// <summary>Gets the optional construct targeted by the attribute.</summary>
        public AttributeTargetSpecifierSyntax? Target => this.target;
        /// <summary>Gets the attribute declaration list.</summary>
        public Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<AttributeSyntax> Attributes => new Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<AttributeSyntax>(new Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<CSharpSyntaxNode>(this.attributes));
        /// <summary>Gets the close bracket token.</summary>
        public SyntaxToken CloseBracketToken => this.closeBracketToken;

        internal override GreenNode? GetSlot(int index)
            => index switch
            {
                0 => this.openBracketToken,
                1 => this.target,
                2 => this.attributes,
                3 => this.closeBracketToken,
                _ => null,
            };

        internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new CSharp.Syntax.AttributeListSyntax(this, parent, position);

        public override void Accept(CSharpSyntaxVisitor visitor) => visitor.VisitAttributeList(this);
        public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor) => visitor.VisitAttributeList(this);

        public AttributeListSyntax Update(SyntaxToken openBracketToken, AttributeTargetSpecifierSyntax target, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<AttributeSyntax> attributes, SyntaxToken closeBracketToken)
        {
            if (openBracketToken != this.OpenBracketToken || target != this.Target || attributes != this.Attributes || closeBracketToken != this.CloseBracketToken)
            {
                var newNode = SyntaxFactory.AttributeList(openBracketToken, target, attributes, closeBracketToken);
                var diags = GetDiagnostics();
                if (diags?.Length > 0)
                    newNode = newNode.WithDiagnosticsGreen(diags);
                var annotations = GetAnnotations();
                if (annotations?.Length > 0)
                    newNode = newNode.WithAnnotationsGreen(annotations);
                return newNode;
            }

            return this;
        }

        internal override GreenNode SetDiagnostics(DiagnosticInfo[]? diagnostics)
            => new AttributeListSyntax(this.Kind, this.openBracketToken, this.target, this.attributes, this.closeBracketToken, diagnostics, GetAnnotations());

        internal override GreenNode SetAnnotations(SyntaxAnnotation[]? annotations)
            => new AttributeListSyntax(this.Kind, this.openBracketToken, this.target, this.attributes, this.closeBracketToken, GetDiagnostics(), annotations);

        internal AttributeListSyntax(ObjectReader reader)
          : base(reader)
        {
            this.SlotCount = 4;
            var openBracketToken = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(openBracketToken);
            this.openBracketToken = openBracketToken;
            var target = (AttributeTargetSpecifierSyntax?)reader.ReadValue();
            if (target != null)
            {
                AdjustFlagsAndWidth(target);
                this.target = target;
            }
            var attributes = (GreenNode?)reader.ReadValue();
            if (attributes != null)
            {
                AdjustFlagsAndWidth(attributes);
                this.attributes = attributes;
            }
            var closeBracketToken = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(closeBracketToken);
            this.closeBracketToken = closeBracketToken;
        }

        internal override void WriteTo(ObjectWriter writer)
        {
            base.WriteTo(writer);
            writer.WriteValue(this.openBracketToken);
            writer.WriteValue(this.target);
            writer.WriteValue(this.attributes);
            writer.WriteValue(this.closeBracketToken);
        }

        static AttributeListSyntax()
        {
            ObjectBinder.RegisterTypeReader(typeof(AttributeListSyntax), r => new AttributeListSyntax(r));
        }
    }

    /// <summary>Class representing what language construct an attribute targets.</summary>
    internal sealed partial class AttributeTargetSpecifierSyntax : CSharpSyntaxNode
    {
        internal readonly SyntaxToken identifier;
        internal readonly SyntaxToken colonToken;

        internal AttributeTargetSpecifierSyntax(SyntaxKind kind, SyntaxToken identifier, SyntaxToken colonToken, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
            this.SlotCount = 2;
            this.AdjustFlagsAndWidth(identifier);
            this.identifier = identifier;
            this.AdjustFlagsAndWidth(colonToken);
            this.colonToken = colonToken;
        }

        internal AttributeTargetSpecifierSyntax(SyntaxKind kind, SyntaxToken identifier, SyntaxToken colonToken, SyntaxFactoryContext context)
          : base(kind)
        {
            this.SetFactoryContext(context);
            this.SlotCount = 2;
            this.AdjustFlagsAndWidth(identifier);
            this.identifier = identifier;
            this.AdjustFlagsAndWidth(colonToken);
            this.colonToken = colonToken;
        }

        internal AttributeTargetSpecifierSyntax(SyntaxKind kind, SyntaxToken identifier, SyntaxToken colonToken)
          : base(kind)
        {
            this.SlotCount = 2;
            this.AdjustFlagsAndWidth(identifier);
            this.identifier = identifier;
            this.AdjustFlagsAndWidth(colonToken);
            this.colonToken = colonToken;
        }

        /// <summary>Gets the identifier.</summary>
        public SyntaxToken Identifier => this.identifier;
        /// <summary>Gets the colon token.</summary>
        public SyntaxToken ColonToken => this.colonToken;

        internal override GreenNode? GetSlot(int index)
            => index switch
            {
                0 => this.identifier,
                1 => this.colonToken,
                _ => null,
            };

        internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new CSharp.Syntax.AttributeTargetSpecifierSyntax(this, parent, position);

        public override void Accept(CSharpSyntaxVisitor visitor) => visitor.VisitAttributeTargetSpecifier(this);
        public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor) => visitor.VisitAttributeTargetSpecifier(this);

        public AttributeTargetSpecifierSyntax Update(SyntaxToken identifier, SyntaxToken colonToken)
        {
            if (identifier != this.Identifier || colonToken != this.ColonToken)
            {
                var newNode = SyntaxFactory.AttributeTargetSpecifier(identifier, colonToken);
                var diags = GetDiagnostics();
                if (diags?.Length > 0)
                    newNode = newNode.WithDiagnosticsGreen(diags);
                var annotations = GetAnnotations();
                if (annotations?.Length > 0)
                    newNode = newNode.WithAnnotationsGreen(annotations);
                return newNode;
            }

            return this;
        }

        internal override GreenNode SetDiagnostics(DiagnosticInfo[]? diagnostics)
            => new AttributeTargetSpecifierSyntax(this.Kind, this.identifier, this.colonToken, diagnostics, GetAnnotations());

        internal override GreenNode SetAnnotations(SyntaxAnnotation[]? annotations)
            => new AttributeTargetSpecifierSyntax(this.Kind, this.identifier, this.colonToken, GetDiagnostics(), annotations);

        internal AttributeTargetSpecifierSyntax(ObjectReader reader)
          : base(reader)
        {
            this.SlotCount = 2;
            var identifier = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(identifier);
            this.identifier = identifier;
            var colonToken = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(colonToken);
            this.colonToken = colonToken;
        }

        internal override void WriteTo(ObjectWriter writer)
        {
            base.WriteTo(writer);
            writer.WriteValue(this.identifier);
            writer.WriteValue(this.colonToken);
        }

        static AttributeTargetSpecifierSyntax()
        {
            ObjectBinder.RegisterTypeReader(typeof(AttributeTargetSpecifierSyntax), r => new AttributeTargetSpecifierSyntax(r));
        }
    }

    /// <summary>Attribute syntax.</summary>
    internal sealed partial class AttributeSyntax : CSharpSyntaxNode
    {
        internal readonly NameSyntax name;
        internal readonly AttributeArgumentListSyntax? argumentList;

        internal AttributeSyntax(SyntaxKind kind, NameSyntax name, AttributeArgumentListSyntax? argumentList, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
            this.SlotCount = 2;
            this.AdjustFlagsAndWidth(name);
            this.name = name;
            if (argumentList != null)
            {
                this.AdjustFlagsAndWidth(argumentList);
                this.argumentList = argumentList;
            }
        }

        internal AttributeSyntax(SyntaxKind kind, NameSyntax name, AttributeArgumentListSyntax? argumentList, SyntaxFactoryContext context)
          : base(kind)
        {
            this.SetFactoryContext(context);
            this.SlotCount = 2;
            this.AdjustFlagsAndWidth(name);
            this.name = name;
            if (argumentList != null)
            {
                this.AdjustFlagsAndWidth(argumentList);
                this.argumentList = argumentList;
            }
        }

        internal AttributeSyntax(SyntaxKind kind, NameSyntax name, AttributeArgumentListSyntax? argumentList)
          : base(kind)
        {
            this.SlotCount = 2;
            this.AdjustFlagsAndWidth(name);
            this.name = name;
            if (argumentList != null)
            {
                this.AdjustFlagsAndWidth(argumentList);
                this.argumentList = argumentList;
            }
        }

        /// <summary>Gets the name.</summary>
        public NameSyntax Name => this.name;
        public AttributeArgumentListSyntax? ArgumentList => this.argumentList;

        internal override GreenNode? GetSlot(int index)
            => index switch
            {
                0 => this.name,
                1 => this.argumentList,
                _ => null,
            };

        internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new CSharp.Syntax.AttributeSyntax(this, parent, position);

        public override void Accept(CSharpSyntaxVisitor visitor) => visitor.VisitAttribute(this);
        public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor) => visitor.VisitAttribute(this);

        public AttributeSyntax Update(NameSyntax name, AttributeArgumentListSyntax argumentList)
        {
            if (name != this.Name || argumentList != this.ArgumentList)
            {
                var newNode = SyntaxFactory.Attribute(name, argumentList);
                var diags = GetDiagnostics();
                if (diags?.Length > 0)
                    newNode = newNode.WithDiagnosticsGreen(diags);
                var annotations = GetAnnotations();
                if (annotations?.Length > 0)
                    newNode = newNode.WithAnnotationsGreen(annotations);
                return newNode;
            }

            return this;
        }

        internal override GreenNode SetDiagnostics(DiagnosticInfo[]? diagnostics)
            => new AttributeSyntax(this.Kind, this.name, this.argumentList, diagnostics, GetAnnotations());

        internal override GreenNode SetAnnotations(SyntaxAnnotation[]? annotations)
            => new AttributeSyntax(this.Kind, this.name, this.argumentList, GetDiagnostics(), annotations);

        internal AttributeSyntax(ObjectReader reader)
          : base(reader)
        {
            this.SlotCount = 2;
            var name = (NameSyntax)reader.ReadValue();
            AdjustFlagsAndWidth(name);
            this.name = name;
            var argumentList = (AttributeArgumentListSyntax?)reader.ReadValue();
            if (argumentList != null)
            {
                AdjustFlagsAndWidth(argumentList);
                this.argumentList = argumentList;
            }
        }

        internal override void WriteTo(ObjectWriter writer)
        {
            base.WriteTo(writer);
            writer.WriteValue(this.name);
            writer.WriteValue(this.argumentList);
        }

        static AttributeSyntax()
        {
            ObjectBinder.RegisterTypeReader(typeof(AttributeSyntax), r => new AttributeSyntax(r));
        }
    }

    /// <summary>Attribute argument list syntax.</summary>
    internal sealed partial class AttributeArgumentListSyntax : CSharpSyntaxNode
    {
        internal readonly SyntaxToken openParenToken;
        internal readonly GreenNode? arguments;
        internal readonly SyntaxToken closeParenToken;

        internal AttributeArgumentListSyntax(SyntaxKind kind, SyntaxToken openParenToken, GreenNode? arguments, SyntaxToken closeParenToken, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
            this.SlotCount = 3;
            this.AdjustFlagsAndWidth(openParenToken);
            this.openParenToken = openParenToken;
            if (arguments != null)
            {
                this.AdjustFlagsAndWidth(arguments);
                this.arguments = arguments;
            }
            this.AdjustFlagsAndWidth(closeParenToken);
            this.closeParenToken = closeParenToken;
        }

        internal AttributeArgumentListSyntax(SyntaxKind kind, SyntaxToken openParenToken, GreenNode? arguments, SyntaxToken closeParenToken, SyntaxFactoryContext context)
          : base(kind)
        {
            this.SetFactoryContext(context);
            this.SlotCount = 3;
            this.AdjustFlagsAndWidth(openParenToken);
            this.openParenToken = openParenToken;
            if (arguments != null)
            {
                this.AdjustFlagsAndWidth(arguments);
                this.arguments = arguments;
            }
            this.AdjustFlagsAndWidth(closeParenToken);
            this.closeParenToken = closeParenToken;
        }

        internal AttributeArgumentListSyntax(SyntaxKind kind, SyntaxToken openParenToken, GreenNode? arguments, SyntaxToken closeParenToken)
          : base(kind)
        {
            this.SlotCount = 3;
            this.AdjustFlagsAndWidth(openParenToken);
            this.openParenToken = openParenToken;
            if (arguments != null)
            {
                this.AdjustFlagsAndWidth(arguments);
                this.arguments = arguments;
            }
            this.AdjustFlagsAndWidth(closeParenToken);
            this.closeParenToken = closeParenToken;
        }

        /// <summary>Gets the open paren token.</summary>
        public SyntaxToken OpenParenToken => this.openParenToken;
        /// <summary>Gets the arguments syntax list.</summary>
        public Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<AttributeArgumentSyntax> Arguments => new Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<AttributeArgumentSyntax>(new Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<CSharpSyntaxNode>(this.arguments));
        /// <summary>Gets the close paren token.</summary>
        public SyntaxToken CloseParenToken => this.closeParenToken;

        internal override GreenNode? GetSlot(int index)
            => index switch
            {
                0 => this.openParenToken,
                1 => this.arguments,
                2 => this.closeParenToken,
                _ => null,
            };

        internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new CSharp.Syntax.AttributeArgumentListSyntax(this, parent, position);

        public override void Accept(CSharpSyntaxVisitor visitor) => visitor.VisitAttributeArgumentList(this);
        public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor) => visitor.VisitAttributeArgumentList(this);

        public AttributeArgumentListSyntax Update(SyntaxToken openParenToken, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<AttributeArgumentSyntax> arguments, SyntaxToken closeParenToken)
        {
            if (openParenToken != this.OpenParenToken || arguments != this.Arguments || closeParenToken != this.CloseParenToken)
            {
                var newNode = SyntaxFactory.AttributeArgumentList(openParenToken, arguments, closeParenToken);
                var diags = GetDiagnostics();
                if (diags?.Length > 0)
                    newNode = newNode.WithDiagnosticsGreen(diags);
                var annotations = GetAnnotations();
                if (annotations?.Length > 0)
                    newNode = newNode.WithAnnotationsGreen(annotations);
                return newNode;
            }

            return this;
        }

        internal override GreenNode SetDiagnostics(DiagnosticInfo[]? diagnostics)
            => new AttributeArgumentListSyntax(this.Kind, this.openParenToken, this.arguments, this.closeParenToken, diagnostics, GetAnnotations());

        internal override GreenNode SetAnnotations(SyntaxAnnotation[]? annotations)
            => new AttributeArgumentListSyntax(this.Kind, this.openParenToken, this.arguments, this.closeParenToken, GetDiagnostics(), annotations);

        internal AttributeArgumentListSyntax(ObjectReader reader)
          : base(reader)
        {
            this.SlotCount = 3;
            var openParenToken = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(openParenToken);
            this.openParenToken = openParenToken;
            var arguments = (GreenNode?)reader.ReadValue();
            if (arguments != null)
            {
                AdjustFlagsAndWidth(arguments);
                this.arguments = arguments;
            }
            var closeParenToken = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(closeParenToken);
            this.closeParenToken = closeParenToken;
        }

        internal override void WriteTo(ObjectWriter writer)
        {
            base.WriteTo(writer);
            writer.WriteValue(this.openParenToken);
            writer.WriteValue(this.arguments);
            writer.WriteValue(this.closeParenToken);
        }

        static AttributeArgumentListSyntax()
        {
            ObjectBinder.RegisterTypeReader(typeof(AttributeArgumentListSyntax), r => new AttributeArgumentListSyntax(r));
        }
    }

    /// <summary>Attribute argument syntax.</summary>
    internal sealed partial class AttributeArgumentSyntax : CSharpSyntaxNode
    {
        internal readonly NameEqualsSyntax? nameEquals;
        internal readonly NameColonSyntax? nameColon;
        internal readonly ExpressionSyntax expression;

        internal AttributeArgumentSyntax(SyntaxKind kind, NameEqualsSyntax? nameEquals, NameColonSyntax? nameColon, ExpressionSyntax expression, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
            this.SlotCount = 3;
            if (nameEquals != null)
            {
                this.AdjustFlagsAndWidth(nameEquals);
                this.nameEquals = nameEquals;
            }
            if (nameColon != null)
            {
                this.AdjustFlagsAndWidth(nameColon);
                this.nameColon = nameColon;
            }
            this.AdjustFlagsAndWidth(expression);
            this.expression = expression;
        }

        internal AttributeArgumentSyntax(SyntaxKind kind, NameEqualsSyntax? nameEquals, NameColonSyntax? nameColon, ExpressionSyntax expression, SyntaxFactoryContext context)
          : base(kind)
        {
            this.SetFactoryContext(context);
            this.SlotCount = 3;
            if (nameEquals != null)
            {
                this.AdjustFlagsAndWidth(nameEquals);
                this.nameEquals = nameEquals;
            }
            if (nameColon != null)
            {
                this.AdjustFlagsAndWidth(nameColon);
                this.nameColon = nameColon;
            }
            this.AdjustFlagsAndWidth(expression);
            this.expression = expression;
        }

        internal AttributeArgumentSyntax(SyntaxKind kind, NameEqualsSyntax? nameEquals, NameColonSyntax? nameColon, ExpressionSyntax expression)
          : base(kind)
        {
            this.SlotCount = 3;
            if (nameEquals != null)
            {
                this.AdjustFlagsAndWidth(nameEquals);
                this.nameEquals = nameEquals;
            }
            if (nameColon != null)
            {
                this.AdjustFlagsAndWidth(nameColon);
                this.nameColon = nameColon;
            }
            this.AdjustFlagsAndWidth(expression);
            this.expression = expression;
        }

        public NameEqualsSyntax? NameEquals => this.nameEquals;
        public NameColonSyntax? NameColon => this.nameColon;
        /// <summary>Gets the expression.</summary>
        public ExpressionSyntax Expression => this.expression;

        internal override GreenNode? GetSlot(int index)
            => index switch
            {
                0 => this.nameEquals,
                1 => this.nameColon,
                2 => this.expression,
                _ => null,
            };

        internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new CSharp.Syntax.AttributeArgumentSyntax(this, parent, position);

        public override void Accept(CSharpSyntaxVisitor visitor) => visitor.VisitAttributeArgument(this);
        public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor) => visitor.VisitAttributeArgument(this);

        public AttributeArgumentSyntax Update(NameEqualsSyntax nameEquals, NameColonSyntax nameColon, ExpressionSyntax expression)
        {
            if (nameEquals != this.NameEquals || nameColon != this.NameColon || expression != this.Expression)
            {
                var newNode = SyntaxFactory.AttributeArgument(nameEquals, nameColon, expression);
                var diags = GetDiagnostics();
                if (diags?.Length > 0)
                    newNode = newNode.WithDiagnosticsGreen(diags);
                var annotations = GetAnnotations();
                if (annotations?.Length > 0)
                    newNode = newNode.WithAnnotationsGreen(annotations);
                return newNode;
            }

            return this;
        }

        internal override GreenNode SetDiagnostics(DiagnosticInfo[]? diagnostics)
            => new AttributeArgumentSyntax(this.Kind, this.nameEquals, this.nameColon, this.expression, diagnostics, GetAnnotations());

        internal override GreenNode SetAnnotations(SyntaxAnnotation[]? annotations)
            => new AttributeArgumentSyntax(this.Kind, this.nameEquals, this.nameColon, this.expression, GetDiagnostics(), annotations);

        internal AttributeArgumentSyntax(ObjectReader reader)
          : base(reader)
        {
            this.SlotCount = 3;
            var nameEquals = (NameEqualsSyntax?)reader.ReadValue();
            if (nameEquals != null)
            {
                AdjustFlagsAndWidth(nameEquals);
                this.nameEquals = nameEquals;
            }
            var nameColon = (NameColonSyntax?)reader.ReadValue();
            if (nameColon != null)
            {
                AdjustFlagsAndWidth(nameColon);
                this.nameColon = nameColon;
            }
            var expression = (ExpressionSyntax)reader.ReadValue();
            AdjustFlagsAndWidth(expression);
            this.expression = expression;
        }

        internal override void WriteTo(ObjectWriter writer)
        {
            base.WriteTo(writer);
            writer.WriteValue(this.nameEquals);
            writer.WriteValue(this.nameColon);
            writer.WriteValue(this.expression);
        }

        static AttributeArgumentSyntax()
        {
            ObjectBinder.RegisterTypeReader(typeof(AttributeArgumentSyntax), r => new AttributeArgumentSyntax(r));
        }
    }

    /// <summary>Class representing an identifier name followed by an equals token.</summary>
    internal sealed partial class NameEqualsSyntax : CSharpSyntaxNode
    {
        internal readonly IdentifierNameSyntax name;
        internal readonly SyntaxToken equalsToken;

        internal NameEqualsSyntax(SyntaxKind kind, IdentifierNameSyntax name, SyntaxToken equalsToken, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
            this.SlotCount = 2;
            this.AdjustFlagsAndWidth(name);
            this.name = name;
            this.AdjustFlagsAndWidth(equalsToken);
            this.equalsToken = equalsToken;
        }

        internal NameEqualsSyntax(SyntaxKind kind, IdentifierNameSyntax name, SyntaxToken equalsToken, SyntaxFactoryContext context)
          : base(kind)
        {
            this.SetFactoryContext(context);
            this.SlotCount = 2;
            this.AdjustFlagsAndWidth(name);
            this.name = name;
            this.AdjustFlagsAndWidth(equalsToken);
            this.equalsToken = equalsToken;
        }

        internal NameEqualsSyntax(SyntaxKind kind, IdentifierNameSyntax name, SyntaxToken equalsToken)
          : base(kind)
        {
            this.SlotCount = 2;
            this.AdjustFlagsAndWidth(name);
            this.name = name;
            this.AdjustFlagsAndWidth(equalsToken);
            this.equalsToken = equalsToken;
        }

        /// <summary>Gets the identifier name.</summary>
        public IdentifierNameSyntax Name => this.name;
        public SyntaxToken EqualsToken => this.equalsToken;

        internal override GreenNode? GetSlot(int index)
            => index switch
            {
                0 => this.name,
                1 => this.equalsToken,
                _ => null,
            };

        internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new CSharp.Syntax.NameEqualsSyntax(this, parent, position);

        public override void Accept(CSharpSyntaxVisitor visitor) => visitor.VisitNameEquals(this);
        public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor) => visitor.VisitNameEquals(this);

        public NameEqualsSyntax Update(IdentifierNameSyntax name, SyntaxToken equalsToken)
        {
            if (name != this.Name || equalsToken != this.EqualsToken)
            {
                var newNode = SyntaxFactory.NameEquals(name, equalsToken);
                var diags = GetDiagnostics();
                if (diags?.Length > 0)
                    newNode = newNode.WithDiagnosticsGreen(diags);
                var annotations = GetAnnotations();
                if (annotations?.Length > 0)
                    newNode = newNode.WithAnnotationsGreen(annotations);
                return newNode;
            }

            return this;
        }

        internal override GreenNode SetDiagnostics(DiagnosticInfo[]? diagnostics)
            => new NameEqualsSyntax(this.Kind, this.name, this.equalsToken, diagnostics, GetAnnotations());

        internal override GreenNode SetAnnotations(SyntaxAnnotation[]? annotations)
            => new NameEqualsSyntax(this.Kind, this.name, this.equalsToken, GetDiagnostics(), annotations);

        internal NameEqualsSyntax(ObjectReader reader)
          : base(reader)
        {
            this.SlotCount = 2;
            var name = (IdentifierNameSyntax)reader.ReadValue();
            AdjustFlagsAndWidth(name);
            this.name = name;
            var equalsToken = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(equalsToken);
            this.equalsToken = equalsToken;
        }

        internal override void WriteTo(ObjectWriter writer)
        {
            base.WriteTo(writer);
            writer.WriteValue(this.name);
            writer.WriteValue(this.equalsToken);
        }

        static NameEqualsSyntax()
        {
            ObjectBinder.RegisterTypeReader(typeof(NameEqualsSyntax), r => new NameEqualsSyntax(r));
        }
    }

    /// <summary>Type parameter list syntax.</summary>
    internal sealed partial class TypeParameterListSyntax : CSharpSyntaxNode
    {
        internal readonly SyntaxToken lessThanToken;
        internal readonly GreenNode? parameters;
        internal readonly SyntaxToken greaterThanToken;

        internal TypeParameterListSyntax(SyntaxKind kind, SyntaxToken lessThanToken, GreenNode? parameters, SyntaxToken greaterThanToken, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
            this.SlotCount = 3;
            this.AdjustFlagsAndWidth(lessThanToken);
            this.lessThanToken = lessThanToken;
            if (parameters != null)
            {
                this.AdjustFlagsAndWidth(parameters);
                this.parameters = parameters;
            }
            this.AdjustFlagsAndWidth(greaterThanToken);
            this.greaterThanToken = greaterThanToken;
        }

        internal TypeParameterListSyntax(SyntaxKind kind, SyntaxToken lessThanToken, GreenNode? parameters, SyntaxToken greaterThanToken, SyntaxFactoryContext context)
          : base(kind)
        {
            this.SetFactoryContext(context);
            this.SlotCount = 3;
            this.AdjustFlagsAndWidth(lessThanToken);
            this.lessThanToken = lessThanToken;
            if (parameters != null)
            {
                this.AdjustFlagsAndWidth(parameters);
                this.parameters = parameters;
            }
            this.AdjustFlagsAndWidth(greaterThanToken);
            this.greaterThanToken = greaterThanToken;
        }

        internal TypeParameterListSyntax(SyntaxKind kind, SyntaxToken lessThanToken, GreenNode? parameters, SyntaxToken greaterThanToken)
          : base(kind)
        {
            this.SlotCount = 3;
            this.AdjustFlagsAndWidth(lessThanToken);
            this.lessThanToken = lessThanToken;
            if (parameters != null)
            {
                this.AdjustFlagsAndWidth(parameters);
                this.parameters = parameters;
            }
            this.AdjustFlagsAndWidth(greaterThanToken);
            this.greaterThanToken = greaterThanToken;
        }

        /// <summary>Gets the &lt; token.</summary>
        public SyntaxToken LessThanToken => this.lessThanToken;
        /// <summary>Gets the parameter list.</summary>
        public Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<TypeParameterSyntax> Parameters => new Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<TypeParameterSyntax>(new Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<CSharpSyntaxNode>(this.parameters));
        /// <summary>Gets the &gt; token.</summary>
        public SyntaxToken GreaterThanToken => this.greaterThanToken;

        internal override GreenNode? GetSlot(int index)
            => index switch
            {
                0 => this.lessThanToken,
                1 => this.parameters,
                2 => this.greaterThanToken,
                _ => null,
            };

        internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new CSharp.Syntax.TypeParameterListSyntax(this, parent, position);

        public override void Accept(CSharpSyntaxVisitor visitor) => visitor.VisitTypeParameterList(this);
        public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor) => visitor.VisitTypeParameterList(this);

        public TypeParameterListSyntax Update(SyntaxToken lessThanToken, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<TypeParameterSyntax> parameters, SyntaxToken greaterThanToken)
        {
            if (lessThanToken != this.LessThanToken || parameters != this.Parameters || greaterThanToken != this.GreaterThanToken)
            {
                var newNode = SyntaxFactory.TypeParameterList(lessThanToken, parameters, greaterThanToken);
                var diags = GetDiagnostics();
                if (diags?.Length > 0)
                    newNode = newNode.WithDiagnosticsGreen(diags);
                var annotations = GetAnnotations();
                if (annotations?.Length > 0)
                    newNode = newNode.WithAnnotationsGreen(annotations);
                return newNode;
            }

            return this;
        }

        internal override GreenNode SetDiagnostics(DiagnosticInfo[]? diagnostics)
            => new TypeParameterListSyntax(this.Kind, this.lessThanToken, this.parameters, this.greaterThanToken, diagnostics, GetAnnotations());

        internal override GreenNode SetAnnotations(SyntaxAnnotation[]? annotations)
            => new TypeParameterListSyntax(this.Kind, this.lessThanToken, this.parameters, this.greaterThanToken, GetDiagnostics(), annotations);

        internal TypeParameterListSyntax(ObjectReader reader)
          : base(reader)
        {
            this.SlotCount = 3;
            var lessThanToken = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(lessThanToken);
            this.lessThanToken = lessThanToken;
            var parameters = (GreenNode?)reader.ReadValue();
            if (parameters != null)
            {
                AdjustFlagsAndWidth(parameters);
                this.parameters = parameters;
            }
            var greaterThanToken = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(greaterThanToken);
            this.greaterThanToken = greaterThanToken;
        }

        internal override void WriteTo(ObjectWriter writer)
        {
            base.WriteTo(writer);
            writer.WriteValue(this.lessThanToken);
            writer.WriteValue(this.parameters);
            writer.WriteValue(this.greaterThanToken);
        }

        static TypeParameterListSyntax()
        {
            ObjectBinder.RegisterTypeReader(typeof(TypeParameterListSyntax), r => new TypeParameterListSyntax(r));
        }
    }

    /// <summary>Type parameter syntax.</summary>
    internal sealed partial class TypeParameterSyntax : CSharpSyntaxNode
    {
        internal readonly GreenNode? attributeLists;
        internal readonly SyntaxToken? varianceKeyword;
        internal readonly SyntaxToken identifier;

        internal TypeParameterSyntax(SyntaxKind kind, GreenNode? attributeLists, SyntaxToken? varianceKeyword, SyntaxToken identifier, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
            this.SlotCount = 3;
            if (attributeLists != null)
            {
                this.AdjustFlagsAndWidth(attributeLists);
                this.attributeLists = attributeLists;
            }
            if (varianceKeyword != null)
            {
                this.AdjustFlagsAndWidth(varianceKeyword);
                this.varianceKeyword = varianceKeyword;
            }
            this.AdjustFlagsAndWidth(identifier);
            this.identifier = identifier;
        }

        internal TypeParameterSyntax(SyntaxKind kind, GreenNode? attributeLists, SyntaxToken? varianceKeyword, SyntaxToken identifier, SyntaxFactoryContext context)
          : base(kind)
        {
            this.SetFactoryContext(context);
            this.SlotCount = 3;
            if (attributeLists != null)
            {
                this.AdjustFlagsAndWidth(attributeLists);
                this.attributeLists = attributeLists;
            }
            if (varianceKeyword != null)
            {
                this.AdjustFlagsAndWidth(varianceKeyword);
                this.varianceKeyword = varianceKeyword;
            }
            this.AdjustFlagsAndWidth(identifier);
            this.identifier = identifier;
        }

        internal TypeParameterSyntax(SyntaxKind kind, GreenNode? attributeLists, SyntaxToken? varianceKeyword, SyntaxToken identifier)
          : base(kind)
        {
            this.SlotCount = 3;
            if (attributeLists != null)
            {
                this.AdjustFlagsAndWidth(attributeLists);
                this.attributeLists = attributeLists;
            }
            if (varianceKeyword != null)
            {
                this.AdjustFlagsAndWidth(varianceKeyword);
                this.varianceKeyword = varianceKeyword;
            }
            this.AdjustFlagsAndWidth(identifier);
            this.identifier = identifier;
        }

        /// <summary>Gets the attribute declaration list.</summary>
        public Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<AttributeListSyntax> AttributeLists => new Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<AttributeListSyntax>(this.attributeLists);
        public SyntaxToken? VarianceKeyword => this.varianceKeyword;
        /// <summary>Gets the identifier.</summary>
        public SyntaxToken Identifier => this.identifier;

        internal override GreenNode? GetSlot(int index)
            => index switch
            {
                0 => this.attributeLists,
                1 => this.varianceKeyword,
                2 => this.identifier,
                _ => null,
            };

        internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new CSharp.Syntax.TypeParameterSyntax(this, parent, position);

        public override void Accept(CSharpSyntaxVisitor visitor) => visitor.VisitTypeParameter(this);
        public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor) => visitor.VisitTypeParameter(this);

        public TypeParameterSyntax Update(Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<AttributeListSyntax> attributeLists, SyntaxToken varianceKeyword, SyntaxToken identifier)
        {
            if (attributeLists != this.AttributeLists || varianceKeyword != this.VarianceKeyword || identifier != this.Identifier)
            {
                var newNode = SyntaxFactory.TypeParameter(attributeLists, varianceKeyword, identifier);
                var diags = GetDiagnostics();
                if (diags?.Length > 0)
                    newNode = newNode.WithDiagnosticsGreen(diags);
                var annotations = GetAnnotations();
                if (annotations?.Length > 0)
                    newNode = newNode.WithAnnotationsGreen(annotations);
                return newNode;
            }

            return this;
        }

        internal override GreenNode SetDiagnostics(DiagnosticInfo[]? diagnostics)
            => new TypeParameterSyntax(this.Kind, this.attributeLists, this.varianceKeyword, this.identifier, diagnostics, GetAnnotations());

        internal override GreenNode SetAnnotations(SyntaxAnnotation[]? annotations)
            => new TypeParameterSyntax(this.Kind, this.attributeLists, this.varianceKeyword, this.identifier, GetDiagnostics(), annotations);

        internal TypeParameterSyntax(ObjectReader reader)
          : base(reader)
        {
            this.SlotCount = 3;
            var attributeLists = (GreenNode?)reader.ReadValue();
            if (attributeLists != null)
            {
                AdjustFlagsAndWidth(attributeLists);
                this.attributeLists = attributeLists;
            }
            var varianceKeyword = (SyntaxToken?)reader.ReadValue();
            if (varianceKeyword != null)
            {
                AdjustFlagsAndWidth(varianceKeyword);
                this.varianceKeyword = varianceKeyword;
            }
            var identifier = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(identifier);
            this.identifier = identifier;
        }

        internal override void WriteTo(ObjectWriter writer)
        {
            base.WriteTo(writer);
            writer.WriteValue(this.attributeLists);
            writer.WriteValue(this.varianceKeyword);
            writer.WriteValue(this.identifier);
        }

        static TypeParameterSyntax()
        {
            ObjectBinder.RegisterTypeReader(typeof(TypeParameterSyntax), r => new TypeParameterSyntax(r));
        }
    }

    /// <summary>Base class for type declaration syntax.</summary>
    internal abstract partial class BaseTypeDeclarationSyntax : MemberDeclarationSyntax
    {
        internal BaseTypeDeclarationSyntax(SyntaxKind kind, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
        }

        internal BaseTypeDeclarationSyntax(SyntaxKind kind)
          : base(kind)
        {
        }

        protected BaseTypeDeclarationSyntax(ObjectReader reader)
          : base(reader)
        {
        }

        /// <summary>Gets the identifier.</summary>
        public abstract SyntaxToken Identifier { get; }

        /// <summary>Gets the base type list.</summary>
        public abstract BaseListSyntax? BaseList { get; }

        /// <summary>Gets the open brace token.</summary>
        public abstract SyntaxToken? OpenBraceToken { get; }

        /// <summary>Gets the close brace token.</summary>
        public abstract SyntaxToken? CloseBraceToken { get; }

        /// <summary>Gets the optional semicolon token.</summary>
        public abstract SyntaxToken? SemicolonToken { get; }
    }

    /// <summary>Base class for type declaration syntax (class, struct, interface, record).</summary>
    internal abstract partial class TypeDeclarationSyntax : BaseTypeDeclarationSyntax
    {
        internal TypeDeclarationSyntax(SyntaxKind kind, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
        }

        internal TypeDeclarationSyntax(SyntaxKind kind)
          : base(kind)
        {
        }

        protected TypeDeclarationSyntax(ObjectReader reader)
          : base(reader)
        {
        }

        /// <summary>Gets the type keyword token ("class", "struct", "interface", "record").</summary>
        public abstract SyntaxToken Keyword { get; }

        public abstract TypeParameterListSyntax? TypeParameterList { get; }

        /// <summary>Gets the type constraint list.</summary>
        public abstract Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<TypeParameterConstraintClauseSyntax> ConstraintClauses { get; }

        /// <summary>Gets the member declarations.</summary>
        public abstract Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<MemberDeclarationSyntax> Members { get; }
    }

    /// <summary>Class type declaration syntax.</summary>
    internal sealed partial class ClassDeclarationSyntax : TypeDeclarationSyntax
    {
        internal readonly GreenNode? attributeLists;
        internal readonly GreenNode? modifiers;
        internal readonly SyntaxToken keyword;
        internal readonly SyntaxToken identifier;
        internal readonly TypeParameterListSyntax? typeParameterList;
        internal readonly BaseListSyntax? baseList;
        internal readonly GreenNode? constraintClauses;
        internal readonly SyntaxToken openBraceToken;
        internal readonly GreenNode? members;
        internal readonly SyntaxToken closeBraceToken;
        internal readonly SyntaxToken? semicolonToken;

        internal ClassDeclarationSyntax(SyntaxKind kind, GreenNode? attributeLists, GreenNode? modifiers, SyntaxToken keyword, SyntaxToken identifier, TypeParameterListSyntax? typeParameterList, BaseListSyntax? baseList, GreenNode? constraintClauses, SyntaxToken openBraceToken, GreenNode? members, SyntaxToken closeBraceToken, SyntaxToken? semicolonToken, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
            this.SlotCount = 11;
            if (attributeLists != null)
            {
                this.AdjustFlagsAndWidth(attributeLists);
                this.attributeLists = attributeLists;
            }
            if (modifiers != null)
            {
                this.AdjustFlagsAndWidth(modifiers);
                this.modifiers = modifiers;
            }
            this.AdjustFlagsAndWidth(keyword);
            this.keyword = keyword;
            this.AdjustFlagsAndWidth(identifier);
            this.identifier = identifier;
            if (typeParameterList != null)
            {
                this.AdjustFlagsAndWidth(typeParameterList);
                this.typeParameterList = typeParameterList;
            }
            if (baseList != null)
            {
                this.AdjustFlagsAndWidth(baseList);
                this.baseList = baseList;
            }
            if (constraintClauses != null)
            {
                this.AdjustFlagsAndWidth(constraintClauses);
                this.constraintClauses = constraintClauses;
            }
            this.AdjustFlagsAndWidth(openBraceToken);
            this.openBraceToken = openBraceToken;
            if (members != null)
            {
                this.AdjustFlagsAndWidth(members);
                this.members = members;
            }
            this.AdjustFlagsAndWidth(closeBraceToken);
            this.closeBraceToken = closeBraceToken;
            if (semicolonToken != null)
            {
                this.AdjustFlagsAndWidth(semicolonToken);
                this.semicolonToken = semicolonToken;
            }
        }

        internal ClassDeclarationSyntax(SyntaxKind kind, GreenNode? attributeLists, GreenNode? modifiers, SyntaxToken keyword, SyntaxToken identifier, TypeParameterListSyntax? typeParameterList, BaseListSyntax? baseList, GreenNode? constraintClauses, SyntaxToken openBraceToken, GreenNode? members, SyntaxToken closeBraceToken, SyntaxToken? semicolonToken, SyntaxFactoryContext context)
          : base(kind)
        {
            this.SetFactoryContext(context);
            this.SlotCount = 11;
            if (attributeLists != null)
            {
                this.AdjustFlagsAndWidth(attributeLists);
                this.attributeLists = attributeLists;
            }
            if (modifiers != null)
            {
                this.AdjustFlagsAndWidth(modifiers);
                this.modifiers = modifiers;
            }
            this.AdjustFlagsAndWidth(keyword);
            this.keyword = keyword;
            this.AdjustFlagsAndWidth(identifier);
            this.identifier = identifier;
            if (typeParameterList != null)
            {
                this.AdjustFlagsAndWidth(typeParameterList);
                this.typeParameterList = typeParameterList;
            }
            if (baseList != null)
            {
                this.AdjustFlagsAndWidth(baseList);
                this.baseList = baseList;
            }
            if (constraintClauses != null)
            {
                this.AdjustFlagsAndWidth(constraintClauses);
                this.constraintClauses = constraintClauses;
            }
            this.AdjustFlagsAndWidth(openBraceToken);
            this.openBraceToken = openBraceToken;
            if (members != null)
            {
                this.AdjustFlagsAndWidth(members);
                this.members = members;
            }
            this.AdjustFlagsAndWidth(closeBraceToken);
            this.closeBraceToken = closeBraceToken;
            if (semicolonToken != null)
            {
                this.AdjustFlagsAndWidth(semicolonToken);
                this.semicolonToken = semicolonToken;
            }
        }

        internal ClassDeclarationSyntax(SyntaxKind kind, GreenNode? attributeLists, GreenNode? modifiers, SyntaxToken keyword, SyntaxToken identifier, TypeParameterListSyntax? typeParameterList, BaseListSyntax? baseList, GreenNode? constraintClauses, SyntaxToken openBraceToken, GreenNode? members, SyntaxToken closeBraceToken, SyntaxToken? semicolonToken)
          : base(kind)
        {
            this.SlotCount = 11;
            if (attributeLists != null)
            {
                this.AdjustFlagsAndWidth(attributeLists);
                this.attributeLists = attributeLists;
            }
            if (modifiers != null)
            {
                this.AdjustFlagsAndWidth(modifiers);
                this.modifiers = modifiers;
            }
            this.AdjustFlagsAndWidth(keyword);
            this.keyword = keyword;
            this.AdjustFlagsAndWidth(identifier);
            this.identifier = identifier;
            if (typeParameterList != null)
            {
                this.AdjustFlagsAndWidth(typeParameterList);
                this.typeParameterList = typeParameterList;
            }
            if (baseList != null)
            {
                this.AdjustFlagsAndWidth(baseList);
                this.baseList = baseList;
            }
            if (constraintClauses != null)
            {
                this.AdjustFlagsAndWidth(constraintClauses);
                this.constraintClauses = constraintClauses;
            }
            this.AdjustFlagsAndWidth(openBraceToken);
            this.openBraceToken = openBraceToken;
            if (members != null)
            {
                this.AdjustFlagsAndWidth(members);
                this.members = members;
            }
            this.AdjustFlagsAndWidth(closeBraceToken);
            this.closeBraceToken = closeBraceToken;
            if (semicolonToken != null)
            {
                this.AdjustFlagsAndWidth(semicolonToken);
                this.semicolonToken = semicolonToken;
            }
        }

        public override Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<AttributeListSyntax> AttributeLists => new Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<AttributeListSyntax>(this.attributeLists);
        public override Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SyntaxToken> Modifiers => new Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SyntaxToken>(this.modifiers);
        /// <summary>Gets the class keyword token.</summary>
        public override SyntaxToken Keyword => this.keyword;
        public override SyntaxToken Identifier => this.identifier;
        public override TypeParameterListSyntax? TypeParameterList => this.typeParameterList;
        public override BaseListSyntax? BaseList => this.baseList;
        public override Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<TypeParameterConstraintClauseSyntax> ConstraintClauses => new Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<TypeParameterConstraintClauseSyntax>(this.constraintClauses);
        public override SyntaxToken OpenBraceToken => this.openBraceToken;
        public override Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<MemberDeclarationSyntax> Members => new Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<MemberDeclarationSyntax>(this.members);
        public override SyntaxToken CloseBraceToken => this.closeBraceToken;
        public override SyntaxToken? SemicolonToken => this.semicolonToken;

        internal override GreenNode? GetSlot(int index)
            => index switch
            {
                0 => this.attributeLists,
                1 => this.modifiers,
                2 => this.keyword,
                3 => this.identifier,
                4 => this.typeParameterList,
                5 => this.baseList,
                6 => this.constraintClauses,
                7 => this.openBraceToken,
                8 => this.members,
                9 => this.closeBraceToken,
                10 => this.semicolonToken,
                _ => null,
            };

        internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new CSharp.Syntax.ClassDeclarationSyntax(this, parent, position);

        public override void Accept(CSharpSyntaxVisitor visitor) => visitor.VisitClassDeclaration(this);
        public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor) => visitor.VisitClassDeclaration(this);

        public ClassDeclarationSyntax Update(Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<AttributeListSyntax> attributeLists, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SyntaxToken> modifiers, SyntaxToken keyword, SyntaxToken identifier, TypeParameterListSyntax typeParameterList, BaseListSyntax baseList, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<TypeParameterConstraintClauseSyntax> constraintClauses, SyntaxToken openBraceToken, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<MemberDeclarationSyntax> members, SyntaxToken closeBraceToken, SyntaxToken semicolonToken)
        {
            if (attributeLists != this.AttributeLists || modifiers != this.Modifiers || keyword != this.Keyword || identifier != this.Identifier || typeParameterList != this.TypeParameterList || baseList != this.BaseList || constraintClauses != this.ConstraintClauses || openBraceToken != this.OpenBraceToken || members != this.Members || closeBraceToken != this.CloseBraceToken || semicolonToken != this.SemicolonToken)
            {
                var newNode = SyntaxFactory.ClassDeclaration(attributeLists, modifiers, keyword, identifier, typeParameterList, baseList, constraintClauses, openBraceToken, members, closeBraceToken, semicolonToken);
                var diags = GetDiagnostics();
                if (diags?.Length > 0)
                    newNode = newNode.WithDiagnosticsGreen(diags);
                var annotations = GetAnnotations();
                if (annotations?.Length > 0)
                    newNode = newNode.WithAnnotationsGreen(annotations);
                return newNode;
            }

            return this;
        }

        internal override GreenNode SetDiagnostics(DiagnosticInfo[]? diagnostics)
            => new ClassDeclarationSyntax(this.Kind, this.attributeLists, this.modifiers, this.keyword, this.identifier, this.typeParameterList, this.baseList, this.constraintClauses, this.openBraceToken, this.members, this.closeBraceToken, this.semicolonToken, diagnostics, GetAnnotations());

        internal override GreenNode SetAnnotations(SyntaxAnnotation[]? annotations)
            => new ClassDeclarationSyntax(this.Kind, this.attributeLists, this.modifiers, this.keyword, this.identifier, this.typeParameterList, this.baseList, this.constraintClauses, this.openBraceToken, this.members, this.closeBraceToken, this.semicolonToken, GetDiagnostics(), annotations);

        internal ClassDeclarationSyntax(ObjectReader reader)
          : base(reader)
        {
            this.SlotCount = 11;
            var attributeLists = (GreenNode?)reader.ReadValue();
            if (attributeLists != null)
            {
                AdjustFlagsAndWidth(attributeLists);
                this.attributeLists = attributeLists;
            }
            var modifiers = (GreenNode?)reader.ReadValue();
            if (modifiers != null)
            {
                AdjustFlagsAndWidth(modifiers);
                this.modifiers = modifiers;
            }
            var keyword = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(keyword);
            this.keyword = keyword;
            var identifier = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(identifier);
            this.identifier = identifier;
            var typeParameterList = (TypeParameterListSyntax?)reader.ReadValue();
            if (typeParameterList != null)
            {
                AdjustFlagsAndWidth(typeParameterList);
                this.typeParameterList = typeParameterList;
            }
            var baseList = (BaseListSyntax?)reader.ReadValue();
            if (baseList != null)
            {
                AdjustFlagsAndWidth(baseList);
                this.baseList = baseList;
            }
            var constraintClauses = (GreenNode?)reader.ReadValue();
            if (constraintClauses != null)
            {
                AdjustFlagsAndWidth(constraintClauses);
                this.constraintClauses = constraintClauses;
            }
            var openBraceToken = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(openBraceToken);
            this.openBraceToken = openBraceToken;
            var members = (GreenNode?)reader.ReadValue();
            if (members != null)
            {
                AdjustFlagsAndWidth(members);
                this.members = members;
            }
            var closeBraceToken = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(closeBraceToken);
            this.closeBraceToken = closeBraceToken;
            var semicolonToken = (SyntaxToken?)reader.ReadValue();
            if (semicolonToken != null)
            {
                AdjustFlagsAndWidth(semicolonToken);
                this.semicolonToken = semicolonToken;
            }
        }

        internal override void WriteTo(ObjectWriter writer)
        {
            base.WriteTo(writer);
            writer.WriteValue(this.attributeLists);
            writer.WriteValue(this.modifiers);
            writer.WriteValue(this.keyword);
            writer.WriteValue(this.identifier);
            writer.WriteValue(this.typeParameterList);
            writer.WriteValue(this.baseList);
            writer.WriteValue(this.constraintClauses);
            writer.WriteValue(this.openBraceToken);
            writer.WriteValue(this.members);
            writer.WriteValue(this.closeBraceToken);
            writer.WriteValue(this.semicolonToken);
        }

        static ClassDeclarationSyntax()
        {
            ObjectBinder.RegisterTypeReader(typeof(ClassDeclarationSyntax), r => new ClassDeclarationSyntax(r));
        }
    }

    /// <summary>Struct type declaration syntax.</summary>
    internal sealed partial class StructDeclarationSyntax : TypeDeclarationSyntax
    {
        internal readonly GreenNode? attributeLists;
        internal readonly GreenNode? modifiers;
        internal readonly SyntaxToken keyword;
        internal readonly SyntaxToken identifier;
        internal readonly TypeParameterListSyntax? typeParameterList;
        internal readonly BaseListSyntax? baseList;
        internal readonly GreenNode? constraintClauses;
        internal readonly SyntaxToken openBraceToken;
        internal readonly GreenNode? members;
        internal readonly SyntaxToken closeBraceToken;
        internal readonly SyntaxToken? semicolonToken;

        internal StructDeclarationSyntax(SyntaxKind kind, GreenNode? attributeLists, GreenNode? modifiers, SyntaxToken keyword, SyntaxToken identifier, TypeParameterListSyntax? typeParameterList, BaseListSyntax? baseList, GreenNode? constraintClauses, SyntaxToken openBraceToken, GreenNode? members, SyntaxToken closeBraceToken, SyntaxToken? semicolonToken, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
            this.SlotCount = 11;
            if (attributeLists != null)
            {
                this.AdjustFlagsAndWidth(attributeLists);
                this.attributeLists = attributeLists;
            }
            if (modifiers != null)
            {
                this.AdjustFlagsAndWidth(modifiers);
                this.modifiers = modifiers;
            }
            this.AdjustFlagsAndWidth(keyword);
            this.keyword = keyword;
            this.AdjustFlagsAndWidth(identifier);
            this.identifier = identifier;
            if (typeParameterList != null)
            {
                this.AdjustFlagsAndWidth(typeParameterList);
                this.typeParameterList = typeParameterList;
            }
            if (baseList != null)
            {
                this.AdjustFlagsAndWidth(baseList);
                this.baseList = baseList;
            }
            if (constraintClauses != null)
            {
                this.AdjustFlagsAndWidth(constraintClauses);
                this.constraintClauses = constraintClauses;
            }
            this.AdjustFlagsAndWidth(openBraceToken);
            this.openBraceToken = openBraceToken;
            if (members != null)
            {
                this.AdjustFlagsAndWidth(members);
                this.members = members;
            }
            this.AdjustFlagsAndWidth(closeBraceToken);
            this.closeBraceToken = closeBraceToken;
            if (semicolonToken != null)
            {
                this.AdjustFlagsAndWidth(semicolonToken);
                this.semicolonToken = semicolonToken;
            }
        }

        internal StructDeclarationSyntax(SyntaxKind kind, GreenNode? attributeLists, GreenNode? modifiers, SyntaxToken keyword, SyntaxToken identifier, TypeParameterListSyntax? typeParameterList, BaseListSyntax? baseList, GreenNode? constraintClauses, SyntaxToken openBraceToken, GreenNode? members, SyntaxToken closeBraceToken, SyntaxToken? semicolonToken, SyntaxFactoryContext context)
          : base(kind)
        {
            this.SetFactoryContext(context);
            this.SlotCount = 11;
            if (attributeLists != null)
            {
                this.AdjustFlagsAndWidth(attributeLists);
                this.attributeLists = attributeLists;
            }
            if (modifiers != null)
            {
                this.AdjustFlagsAndWidth(modifiers);
                this.modifiers = modifiers;
            }
            this.AdjustFlagsAndWidth(keyword);
            this.keyword = keyword;
            this.AdjustFlagsAndWidth(identifier);
            this.identifier = identifier;
            if (typeParameterList != null)
            {
                this.AdjustFlagsAndWidth(typeParameterList);
                this.typeParameterList = typeParameterList;
            }
            if (baseList != null)
            {
                this.AdjustFlagsAndWidth(baseList);
                this.baseList = baseList;
            }
            if (constraintClauses != null)
            {
                this.AdjustFlagsAndWidth(constraintClauses);
                this.constraintClauses = constraintClauses;
            }
            this.AdjustFlagsAndWidth(openBraceToken);
            this.openBraceToken = openBraceToken;
            if (members != null)
            {
                this.AdjustFlagsAndWidth(members);
                this.members = members;
            }
            this.AdjustFlagsAndWidth(closeBraceToken);
            this.closeBraceToken = closeBraceToken;
            if (semicolonToken != null)
            {
                this.AdjustFlagsAndWidth(semicolonToken);
                this.semicolonToken = semicolonToken;
            }
        }

        internal StructDeclarationSyntax(SyntaxKind kind, GreenNode? attributeLists, GreenNode? modifiers, SyntaxToken keyword, SyntaxToken identifier, TypeParameterListSyntax? typeParameterList, BaseListSyntax? baseList, GreenNode? constraintClauses, SyntaxToken openBraceToken, GreenNode? members, SyntaxToken closeBraceToken, SyntaxToken? semicolonToken)
          : base(kind)
        {
            this.SlotCount = 11;
            if (attributeLists != null)
            {
                this.AdjustFlagsAndWidth(attributeLists);
                this.attributeLists = attributeLists;
            }
            if (modifiers != null)
            {
                this.AdjustFlagsAndWidth(modifiers);
                this.modifiers = modifiers;
            }
            this.AdjustFlagsAndWidth(keyword);
            this.keyword = keyword;
            this.AdjustFlagsAndWidth(identifier);
            this.identifier = identifier;
            if (typeParameterList != null)
            {
                this.AdjustFlagsAndWidth(typeParameterList);
                this.typeParameterList = typeParameterList;
            }
            if (baseList != null)
            {
                this.AdjustFlagsAndWidth(baseList);
                this.baseList = baseList;
            }
            if (constraintClauses != null)
            {
                this.AdjustFlagsAndWidth(constraintClauses);
                this.constraintClauses = constraintClauses;
            }
            this.AdjustFlagsAndWidth(openBraceToken);
            this.openBraceToken = openBraceToken;
            if (members != null)
            {
                this.AdjustFlagsAndWidth(members);
                this.members = members;
            }
            this.AdjustFlagsAndWidth(closeBraceToken);
            this.closeBraceToken = closeBraceToken;
            if (semicolonToken != null)
            {
                this.AdjustFlagsAndWidth(semicolonToken);
                this.semicolonToken = semicolonToken;
            }
        }

        public override Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<AttributeListSyntax> AttributeLists => new Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<AttributeListSyntax>(this.attributeLists);
        public override Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SyntaxToken> Modifiers => new Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SyntaxToken>(this.modifiers);
        /// <summary>Gets the struct keyword token.</summary>
        public override SyntaxToken Keyword => this.keyword;
        public override SyntaxToken Identifier => this.identifier;
        public override TypeParameterListSyntax? TypeParameterList => this.typeParameterList;
        public override BaseListSyntax? BaseList => this.baseList;
        public override Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<TypeParameterConstraintClauseSyntax> ConstraintClauses => new Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<TypeParameterConstraintClauseSyntax>(this.constraintClauses);
        public override SyntaxToken OpenBraceToken => this.openBraceToken;
        public override Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<MemberDeclarationSyntax> Members => new Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<MemberDeclarationSyntax>(this.members);
        public override SyntaxToken CloseBraceToken => this.closeBraceToken;
        public override SyntaxToken? SemicolonToken => this.semicolonToken;

        internal override GreenNode? GetSlot(int index)
            => index switch
            {
                0 => this.attributeLists,
                1 => this.modifiers,
                2 => this.keyword,
                3 => this.identifier,
                4 => this.typeParameterList,
                5 => this.baseList,
                6 => this.constraintClauses,
                7 => this.openBraceToken,
                8 => this.members,
                9 => this.closeBraceToken,
                10 => this.semicolonToken,
                _ => null,
            };

        internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new CSharp.Syntax.StructDeclarationSyntax(this, parent, position);

        public override void Accept(CSharpSyntaxVisitor visitor) => visitor.VisitStructDeclaration(this);
        public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor) => visitor.VisitStructDeclaration(this);

        public StructDeclarationSyntax Update(Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<AttributeListSyntax> attributeLists, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SyntaxToken> modifiers, SyntaxToken keyword, SyntaxToken identifier, TypeParameterListSyntax typeParameterList, BaseListSyntax baseList, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<TypeParameterConstraintClauseSyntax> constraintClauses, SyntaxToken openBraceToken, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<MemberDeclarationSyntax> members, SyntaxToken closeBraceToken, SyntaxToken semicolonToken)
        {
            if (attributeLists != this.AttributeLists || modifiers != this.Modifiers || keyword != this.Keyword || identifier != this.Identifier || typeParameterList != this.TypeParameterList || baseList != this.BaseList || constraintClauses != this.ConstraintClauses || openBraceToken != this.OpenBraceToken || members != this.Members || closeBraceToken != this.CloseBraceToken || semicolonToken != this.SemicolonToken)
            {
                var newNode = SyntaxFactory.StructDeclaration(attributeLists, modifiers, keyword, identifier, typeParameterList, baseList, constraintClauses, openBraceToken, members, closeBraceToken, semicolonToken);
                var diags = GetDiagnostics();
                if (diags?.Length > 0)
                    newNode = newNode.WithDiagnosticsGreen(diags);
                var annotations = GetAnnotations();
                if (annotations?.Length > 0)
                    newNode = newNode.WithAnnotationsGreen(annotations);
                return newNode;
            }

            return this;
        }

        internal override GreenNode SetDiagnostics(DiagnosticInfo[]? diagnostics)
            => new StructDeclarationSyntax(this.Kind, this.attributeLists, this.modifiers, this.keyword, this.identifier, this.typeParameterList, this.baseList, this.constraintClauses, this.openBraceToken, this.members, this.closeBraceToken, this.semicolonToken, diagnostics, GetAnnotations());

        internal override GreenNode SetAnnotations(SyntaxAnnotation[]? annotations)
            => new StructDeclarationSyntax(this.Kind, this.attributeLists, this.modifiers, this.keyword, this.identifier, this.typeParameterList, this.baseList, this.constraintClauses, this.openBraceToken, this.members, this.closeBraceToken, this.semicolonToken, GetDiagnostics(), annotations);

        internal StructDeclarationSyntax(ObjectReader reader)
          : base(reader)
        {
            this.SlotCount = 11;
            var attributeLists = (GreenNode?)reader.ReadValue();
            if (attributeLists != null)
            {
                AdjustFlagsAndWidth(attributeLists);
                this.attributeLists = attributeLists;
            }
            var modifiers = (GreenNode?)reader.ReadValue();
            if (modifiers != null)
            {
                AdjustFlagsAndWidth(modifiers);
                this.modifiers = modifiers;
            }
            var keyword = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(keyword);
            this.keyword = keyword;
            var identifier = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(identifier);
            this.identifier = identifier;
            var typeParameterList = (TypeParameterListSyntax?)reader.ReadValue();
            if (typeParameterList != null)
            {
                AdjustFlagsAndWidth(typeParameterList);
                this.typeParameterList = typeParameterList;
            }
            var baseList = (BaseListSyntax?)reader.ReadValue();
            if (baseList != null)
            {
                AdjustFlagsAndWidth(baseList);
                this.baseList = baseList;
            }
            var constraintClauses = (GreenNode?)reader.ReadValue();
            if (constraintClauses != null)
            {
                AdjustFlagsAndWidth(constraintClauses);
                this.constraintClauses = constraintClauses;
            }
            var openBraceToken = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(openBraceToken);
            this.openBraceToken = openBraceToken;
            var members = (GreenNode?)reader.ReadValue();
            if (members != null)
            {
                AdjustFlagsAndWidth(members);
                this.members = members;
            }
            var closeBraceToken = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(closeBraceToken);
            this.closeBraceToken = closeBraceToken;
            var semicolonToken = (SyntaxToken?)reader.ReadValue();
            if (semicolonToken != null)
            {
                AdjustFlagsAndWidth(semicolonToken);
                this.semicolonToken = semicolonToken;
            }
        }

        internal override void WriteTo(ObjectWriter writer)
        {
            base.WriteTo(writer);
            writer.WriteValue(this.attributeLists);
            writer.WriteValue(this.modifiers);
            writer.WriteValue(this.keyword);
            writer.WriteValue(this.identifier);
            writer.WriteValue(this.typeParameterList);
            writer.WriteValue(this.baseList);
            writer.WriteValue(this.constraintClauses);
            writer.WriteValue(this.openBraceToken);
            writer.WriteValue(this.members);
            writer.WriteValue(this.closeBraceToken);
            writer.WriteValue(this.semicolonToken);
        }

        static StructDeclarationSyntax()
        {
            ObjectBinder.RegisterTypeReader(typeof(StructDeclarationSyntax), r => new StructDeclarationSyntax(r));
        }
    }

    /// <summary>Interface type declaration syntax.</summary>
    internal sealed partial class InterfaceDeclarationSyntax : TypeDeclarationSyntax
    {
        internal readonly GreenNode? attributeLists;
        internal readonly GreenNode? modifiers;
        internal readonly SyntaxToken keyword;
        internal readonly SyntaxToken identifier;
        internal readonly TypeParameterListSyntax? typeParameterList;
        internal readonly BaseListSyntax? baseList;
        internal readonly GreenNode? constraintClauses;
        internal readonly SyntaxToken openBraceToken;
        internal readonly GreenNode? members;
        internal readonly SyntaxToken closeBraceToken;
        internal readonly SyntaxToken? semicolonToken;

        internal InterfaceDeclarationSyntax(SyntaxKind kind, GreenNode? attributeLists, GreenNode? modifiers, SyntaxToken keyword, SyntaxToken identifier, TypeParameterListSyntax? typeParameterList, BaseListSyntax? baseList, GreenNode? constraintClauses, SyntaxToken openBraceToken, GreenNode? members, SyntaxToken closeBraceToken, SyntaxToken? semicolonToken, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
            this.SlotCount = 11;
            if (attributeLists != null)
            {
                this.AdjustFlagsAndWidth(attributeLists);
                this.attributeLists = attributeLists;
            }
            if (modifiers != null)
            {
                this.AdjustFlagsAndWidth(modifiers);
                this.modifiers = modifiers;
            }
            this.AdjustFlagsAndWidth(keyword);
            this.keyword = keyword;
            this.AdjustFlagsAndWidth(identifier);
            this.identifier = identifier;
            if (typeParameterList != null)
            {
                this.AdjustFlagsAndWidth(typeParameterList);
                this.typeParameterList = typeParameterList;
            }
            if (baseList != null)
            {
                this.AdjustFlagsAndWidth(baseList);
                this.baseList = baseList;
            }
            if (constraintClauses != null)
            {
                this.AdjustFlagsAndWidth(constraintClauses);
                this.constraintClauses = constraintClauses;
            }
            this.AdjustFlagsAndWidth(openBraceToken);
            this.openBraceToken = openBraceToken;
            if (members != null)
            {
                this.AdjustFlagsAndWidth(members);
                this.members = members;
            }
            this.AdjustFlagsAndWidth(closeBraceToken);
            this.closeBraceToken = closeBraceToken;
            if (semicolonToken != null)
            {
                this.AdjustFlagsAndWidth(semicolonToken);
                this.semicolonToken = semicolonToken;
            }
        }

        internal InterfaceDeclarationSyntax(SyntaxKind kind, GreenNode? attributeLists, GreenNode? modifiers, SyntaxToken keyword, SyntaxToken identifier, TypeParameterListSyntax? typeParameterList, BaseListSyntax? baseList, GreenNode? constraintClauses, SyntaxToken openBraceToken, GreenNode? members, SyntaxToken closeBraceToken, SyntaxToken? semicolonToken, SyntaxFactoryContext context)
          : base(kind)
        {
            this.SetFactoryContext(context);
            this.SlotCount = 11;
            if (attributeLists != null)
            {
                this.AdjustFlagsAndWidth(attributeLists);
                this.attributeLists = attributeLists;
            }
            if (modifiers != null)
            {
                this.AdjustFlagsAndWidth(modifiers);
                this.modifiers = modifiers;
            }
            this.AdjustFlagsAndWidth(keyword);
            this.keyword = keyword;
            this.AdjustFlagsAndWidth(identifier);
            this.identifier = identifier;
            if (typeParameterList != null)
            {
                this.AdjustFlagsAndWidth(typeParameterList);
                this.typeParameterList = typeParameterList;
            }
            if (baseList != null)
            {
                this.AdjustFlagsAndWidth(baseList);
                this.baseList = baseList;
            }
            if (constraintClauses != null)
            {
                this.AdjustFlagsAndWidth(constraintClauses);
                this.constraintClauses = constraintClauses;
            }
            this.AdjustFlagsAndWidth(openBraceToken);
            this.openBraceToken = openBraceToken;
            if (members != null)
            {
                this.AdjustFlagsAndWidth(members);
                this.members = members;
            }
            this.AdjustFlagsAndWidth(closeBraceToken);
            this.closeBraceToken = closeBraceToken;
            if (semicolonToken != null)
            {
                this.AdjustFlagsAndWidth(semicolonToken);
                this.semicolonToken = semicolonToken;
            }
        }

        internal InterfaceDeclarationSyntax(SyntaxKind kind, GreenNode? attributeLists, GreenNode? modifiers, SyntaxToken keyword, SyntaxToken identifier, TypeParameterListSyntax? typeParameterList, BaseListSyntax? baseList, GreenNode? constraintClauses, SyntaxToken openBraceToken, GreenNode? members, SyntaxToken closeBraceToken, SyntaxToken? semicolonToken)
          : base(kind)
        {
            this.SlotCount = 11;
            if (attributeLists != null)
            {
                this.AdjustFlagsAndWidth(attributeLists);
                this.attributeLists = attributeLists;
            }
            if (modifiers != null)
            {
                this.AdjustFlagsAndWidth(modifiers);
                this.modifiers = modifiers;
            }
            this.AdjustFlagsAndWidth(keyword);
            this.keyword = keyword;
            this.AdjustFlagsAndWidth(identifier);
            this.identifier = identifier;
            if (typeParameterList != null)
            {
                this.AdjustFlagsAndWidth(typeParameterList);
                this.typeParameterList = typeParameterList;
            }
            if (baseList != null)
            {
                this.AdjustFlagsAndWidth(baseList);
                this.baseList = baseList;
            }
            if (constraintClauses != null)
            {
                this.AdjustFlagsAndWidth(constraintClauses);
                this.constraintClauses = constraintClauses;
            }
            this.AdjustFlagsAndWidth(openBraceToken);
            this.openBraceToken = openBraceToken;
            if (members != null)
            {
                this.AdjustFlagsAndWidth(members);
                this.members = members;
            }
            this.AdjustFlagsAndWidth(closeBraceToken);
            this.closeBraceToken = closeBraceToken;
            if (semicolonToken != null)
            {
                this.AdjustFlagsAndWidth(semicolonToken);
                this.semicolonToken = semicolonToken;
            }
        }

        public override Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<AttributeListSyntax> AttributeLists => new Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<AttributeListSyntax>(this.attributeLists);
        public override Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SyntaxToken> Modifiers => new Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SyntaxToken>(this.modifiers);
        /// <summary>Gets the interface keyword token.</summary>
        public override SyntaxToken Keyword => this.keyword;
        public override SyntaxToken Identifier => this.identifier;
        public override TypeParameterListSyntax? TypeParameterList => this.typeParameterList;
        public override BaseListSyntax? BaseList => this.baseList;
        public override Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<TypeParameterConstraintClauseSyntax> ConstraintClauses => new Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<TypeParameterConstraintClauseSyntax>(this.constraintClauses);
        public override SyntaxToken OpenBraceToken => this.openBraceToken;
        public override Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<MemberDeclarationSyntax> Members => new Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<MemberDeclarationSyntax>(this.members);
        public override SyntaxToken CloseBraceToken => this.closeBraceToken;
        public override SyntaxToken? SemicolonToken => this.semicolonToken;

        internal override GreenNode? GetSlot(int index)
            => index switch
            {
                0 => this.attributeLists,
                1 => this.modifiers,
                2 => this.keyword,
                3 => this.identifier,
                4 => this.typeParameterList,
                5 => this.baseList,
                6 => this.constraintClauses,
                7 => this.openBraceToken,
                8 => this.members,
                9 => this.closeBraceToken,
                10 => this.semicolonToken,
                _ => null,
            };

        internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new CSharp.Syntax.InterfaceDeclarationSyntax(this, parent, position);

        public override void Accept(CSharpSyntaxVisitor visitor) => visitor.VisitInterfaceDeclaration(this);
        public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor) => visitor.VisitInterfaceDeclaration(this);

        public InterfaceDeclarationSyntax Update(Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<AttributeListSyntax> attributeLists, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SyntaxToken> modifiers, SyntaxToken keyword, SyntaxToken identifier, TypeParameterListSyntax typeParameterList, BaseListSyntax baseList, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<TypeParameterConstraintClauseSyntax> constraintClauses, SyntaxToken openBraceToken, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<MemberDeclarationSyntax> members, SyntaxToken closeBraceToken, SyntaxToken semicolonToken)
        {
            if (attributeLists != this.AttributeLists || modifiers != this.Modifiers || keyword != this.Keyword || identifier != this.Identifier || typeParameterList != this.TypeParameterList || baseList != this.BaseList || constraintClauses != this.ConstraintClauses || openBraceToken != this.OpenBraceToken || members != this.Members || closeBraceToken != this.CloseBraceToken || semicolonToken != this.SemicolonToken)
            {
                var newNode = SyntaxFactory.InterfaceDeclaration(attributeLists, modifiers, keyword, identifier, typeParameterList, baseList, constraintClauses, openBraceToken, members, closeBraceToken, semicolonToken);
                var diags = GetDiagnostics();
                if (diags?.Length > 0)
                    newNode = newNode.WithDiagnosticsGreen(diags);
                var annotations = GetAnnotations();
                if (annotations?.Length > 0)
                    newNode = newNode.WithAnnotationsGreen(annotations);
                return newNode;
            }

            return this;
        }

        internal override GreenNode SetDiagnostics(DiagnosticInfo[]? diagnostics)
            => new InterfaceDeclarationSyntax(this.Kind, this.attributeLists, this.modifiers, this.keyword, this.identifier, this.typeParameterList, this.baseList, this.constraintClauses, this.openBraceToken, this.members, this.closeBraceToken, this.semicolonToken, diagnostics, GetAnnotations());

        internal override GreenNode SetAnnotations(SyntaxAnnotation[]? annotations)
            => new InterfaceDeclarationSyntax(this.Kind, this.attributeLists, this.modifiers, this.keyword, this.identifier, this.typeParameterList, this.baseList, this.constraintClauses, this.openBraceToken, this.members, this.closeBraceToken, this.semicolonToken, GetDiagnostics(), annotations);

        internal InterfaceDeclarationSyntax(ObjectReader reader)
          : base(reader)
        {
            this.SlotCount = 11;
            var attributeLists = (GreenNode?)reader.ReadValue();
            if (attributeLists != null)
            {
                AdjustFlagsAndWidth(attributeLists);
                this.attributeLists = attributeLists;
            }
            var modifiers = (GreenNode?)reader.ReadValue();
            if (modifiers != null)
            {
                AdjustFlagsAndWidth(modifiers);
                this.modifiers = modifiers;
            }
            var keyword = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(keyword);
            this.keyword = keyword;
            var identifier = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(identifier);
            this.identifier = identifier;
            var typeParameterList = (TypeParameterListSyntax?)reader.ReadValue();
            if (typeParameterList != null)
            {
                AdjustFlagsAndWidth(typeParameterList);
                this.typeParameterList = typeParameterList;
            }
            var baseList = (BaseListSyntax?)reader.ReadValue();
            if (baseList != null)
            {
                AdjustFlagsAndWidth(baseList);
                this.baseList = baseList;
            }
            var constraintClauses = (GreenNode?)reader.ReadValue();
            if (constraintClauses != null)
            {
                AdjustFlagsAndWidth(constraintClauses);
                this.constraintClauses = constraintClauses;
            }
            var openBraceToken = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(openBraceToken);
            this.openBraceToken = openBraceToken;
            var members = (GreenNode?)reader.ReadValue();
            if (members != null)
            {
                AdjustFlagsAndWidth(members);
                this.members = members;
            }
            var closeBraceToken = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(closeBraceToken);
            this.closeBraceToken = closeBraceToken;
            var semicolonToken = (SyntaxToken?)reader.ReadValue();
            if (semicolonToken != null)
            {
                AdjustFlagsAndWidth(semicolonToken);
                this.semicolonToken = semicolonToken;
            }
        }

        internal override void WriteTo(ObjectWriter writer)
        {
            base.WriteTo(writer);
            writer.WriteValue(this.attributeLists);
            writer.WriteValue(this.modifiers);
            writer.WriteValue(this.keyword);
            writer.WriteValue(this.identifier);
            writer.WriteValue(this.typeParameterList);
            writer.WriteValue(this.baseList);
            writer.WriteValue(this.constraintClauses);
            writer.WriteValue(this.openBraceToken);
            writer.WriteValue(this.members);
            writer.WriteValue(this.closeBraceToken);
            writer.WriteValue(this.semicolonToken);
        }

        static InterfaceDeclarationSyntax()
        {
            ObjectBinder.RegisterTypeReader(typeof(InterfaceDeclarationSyntax), r => new InterfaceDeclarationSyntax(r));
        }
    }

    internal sealed partial class RecordDeclarationSyntax : TypeDeclarationSyntax
    {
        internal readonly GreenNode? attributeLists;
        internal readonly GreenNode? modifiers;
        internal readonly SyntaxToken keyword;
        internal readonly SyntaxToken identifier;
        internal readonly TypeParameterListSyntax? typeParameterList;
        internal readonly ParameterListSyntax? parameterList;
        internal readonly BaseListSyntax? baseList;
        internal readonly GreenNode? constraintClauses;
        internal readonly SyntaxToken? openBraceToken;
        internal readonly GreenNode? members;
        internal readonly SyntaxToken? closeBraceToken;
        internal readonly SyntaxToken? semicolonToken;

        internal RecordDeclarationSyntax(SyntaxKind kind, GreenNode? attributeLists, GreenNode? modifiers, SyntaxToken keyword, SyntaxToken identifier, TypeParameterListSyntax? typeParameterList, ParameterListSyntax? parameterList, BaseListSyntax? baseList, GreenNode? constraintClauses, SyntaxToken? openBraceToken, GreenNode? members, SyntaxToken? closeBraceToken, SyntaxToken? semicolonToken, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
            this.SlotCount = 12;
            if (attributeLists != null)
            {
                this.AdjustFlagsAndWidth(attributeLists);
                this.attributeLists = attributeLists;
            }
            if (modifiers != null)
            {
                this.AdjustFlagsAndWidth(modifiers);
                this.modifiers = modifiers;
            }
            this.AdjustFlagsAndWidth(keyword);
            this.keyword = keyword;
            this.AdjustFlagsAndWidth(identifier);
            this.identifier = identifier;
            if (typeParameterList != null)
            {
                this.AdjustFlagsAndWidth(typeParameterList);
                this.typeParameterList = typeParameterList;
            }
            if (parameterList != null)
            {
                this.AdjustFlagsAndWidth(parameterList);
                this.parameterList = parameterList;
            }
            if (baseList != null)
            {
                this.AdjustFlagsAndWidth(baseList);
                this.baseList = baseList;
            }
            if (constraintClauses != null)
            {
                this.AdjustFlagsAndWidth(constraintClauses);
                this.constraintClauses = constraintClauses;
            }
            if (openBraceToken != null)
            {
                this.AdjustFlagsAndWidth(openBraceToken);
                this.openBraceToken = openBraceToken;
            }
            if (members != null)
            {
                this.AdjustFlagsAndWidth(members);
                this.members = members;
            }
            if (closeBraceToken != null)
            {
                this.AdjustFlagsAndWidth(closeBraceToken);
                this.closeBraceToken = closeBraceToken;
            }
            if (semicolonToken != null)
            {
                this.AdjustFlagsAndWidth(semicolonToken);
                this.semicolonToken = semicolonToken;
            }
        }

        internal RecordDeclarationSyntax(SyntaxKind kind, GreenNode? attributeLists, GreenNode? modifiers, SyntaxToken keyword, SyntaxToken identifier, TypeParameterListSyntax? typeParameterList, ParameterListSyntax? parameterList, BaseListSyntax? baseList, GreenNode? constraintClauses, SyntaxToken? openBraceToken, GreenNode? members, SyntaxToken? closeBraceToken, SyntaxToken? semicolonToken, SyntaxFactoryContext context)
          : base(kind)
        {
            this.SetFactoryContext(context);
            this.SlotCount = 12;
            if (attributeLists != null)
            {
                this.AdjustFlagsAndWidth(attributeLists);
                this.attributeLists = attributeLists;
            }
            if (modifiers != null)
            {
                this.AdjustFlagsAndWidth(modifiers);
                this.modifiers = modifiers;
            }
            this.AdjustFlagsAndWidth(keyword);
            this.keyword = keyword;
            this.AdjustFlagsAndWidth(identifier);
            this.identifier = identifier;
            if (typeParameterList != null)
            {
                this.AdjustFlagsAndWidth(typeParameterList);
                this.typeParameterList = typeParameterList;
            }
            if (parameterList != null)
            {
                this.AdjustFlagsAndWidth(parameterList);
                this.parameterList = parameterList;
            }
            if (baseList != null)
            {
                this.AdjustFlagsAndWidth(baseList);
                this.baseList = baseList;
            }
            if (constraintClauses != null)
            {
                this.AdjustFlagsAndWidth(constraintClauses);
                this.constraintClauses = constraintClauses;
            }
            if (openBraceToken != null)
            {
                this.AdjustFlagsAndWidth(openBraceToken);
                this.openBraceToken = openBraceToken;
            }
            if (members != null)
            {
                this.AdjustFlagsAndWidth(members);
                this.members = members;
            }
            if (closeBraceToken != null)
            {
                this.AdjustFlagsAndWidth(closeBraceToken);
                this.closeBraceToken = closeBraceToken;
            }
            if (semicolonToken != null)
            {
                this.AdjustFlagsAndWidth(semicolonToken);
                this.semicolonToken = semicolonToken;
            }
        }

        internal RecordDeclarationSyntax(SyntaxKind kind, GreenNode? attributeLists, GreenNode? modifiers, SyntaxToken keyword, SyntaxToken identifier, TypeParameterListSyntax? typeParameterList, ParameterListSyntax? parameterList, BaseListSyntax? baseList, GreenNode? constraintClauses, SyntaxToken? openBraceToken, GreenNode? members, SyntaxToken? closeBraceToken, SyntaxToken? semicolonToken)
          : base(kind)
        {
            this.SlotCount = 12;
            if (attributeLists != null)
            {
                this.AdjustFlagsAndWidth(attributeLists);
                this.attributeLists = attributeLists;
            }
            if (modifiers != null)
            {
                this.AdjustFlagsAndWidth(modifiers);
                this.modifiers = modifiers;
            }
            this.AdjustFlagsAndWidth(keyword);
            this.keyword = keyword;
            this.AdjustFlagsAndWidth(identifier);
            this.identifier = identifier;
            if (typeParameterList != null)
            {
                this.AdjustFlagsAndWidth(typeParameterList);
                this.typeParameterList = typeParameterList;
            }
            if (parameterList != null)
            {
                this.AdjustFlagsAndWidth(parameterList);
                this.parameterList = parameterList;
            }
            if (baseList != null)
            {
                this.AdjustFlagsAndWidth(baseList);
                this.baseList = baseList;
            }
            if (constraintClauses != null)
            {
                this.AdjustFlagsAndWidth(constraintClauses);
                this.constraintClauses = constraintClauses;
            }
            if (openBraceToken != null)
            {
                this.AdjustFlagsAndWidth(openBraceToken);
                this.openBraceToken = openBraceToken;
            }
            if (members != null)
            {
                this.AdjustFlagsAndWidth(members);
                this.members = members;
            }
            if (closeBraceToken != null)
            {
                this.AdjustFlagsAndWidth(closeBraceToken);
                this.closeBraceToken = closeBraceToken;
            }
            if (semicolonToken != null)
            {
                this.AdjustFlagsAndWidth(semicolonToken);
                this.semicolonToken = semicolonToken;
            }
        }

        public override Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<AttributeListSyntax> AttributeLists => new Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<AttributeListSyntax>(this.attributeLists);
        public override Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SyntaxToken> Modifiers => new Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SyntaxToken>(this.modifiers);
        public override SyntaxToken Keyword => this.keyword;
        public override SyntaxToken Identifier => this.identifier;
        public override TypeParameterListSyntax? TypeParameterList => this.typeParameterList;
        public ParameterListSyntax? ParameterList => this.parameterList;
        public override BaseListSyntax? BaseList => this.baseList;
        public override Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<TypeParameterConstraintClauseSyntax> ConstraintClauses => new Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<TypeParameterConstraintClauseSyntax>(this.constraintClauses);
        public override SyntaxToken? OpenBraceToken => this.openBraceToken;
        public override Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<MemberDeclarationSyntax> Members => new Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<MemberDeclarationSyntax>(this.members);
        public override SyntaxToken? CloseBraceToken => this.closeBraceToken;
        public override SyntaxToken? SemicolonToken => this.semicolonToken;

        internal override GreenNode? GetSlot(int index)
            => index switch
            {
                0 => this.attributeLists,
                1 => this.modifiers,
                2 => this.keyword,
                3 => this.identifier,
                4 => this.typeParameterList,
                5 => this.parameterList,
                6 => this.baseList,
                7 => this.constraintClauses,
                8 => this.openBraceToken,
                9 => this.members,
                10 => this.closeBraceToken,
                11 => this.semicolonToken,
                _ => null,
            };

        internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new CSharp.Syntax.RecordDeclarationSyntax(this, parent, position);

        public override void Accept(CSharpSyntaxVisitor visitor) => visitor.VisitRecordDeclaration(this);
        public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor) => visitor.VisitRecordDeclaration(this);

        public RecordDeclarationSyntax Update(Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<AttributeListSyntax> attributeLists, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SyntaxToken> modifiers, SyntaxToken keyword, SyntaxToken identifier, TypeParameterListSyntax typeParameterList, ParameterListSyntax parameterList, BaseListSyntax baseList, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<TypeParameterConstraintClauseSyntax> constraintClauses, SyntaxToken openBraceToken, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<MemberDeclarationSyntax> members, SyntaxToken closeBraceToken, SyntaxToken semicolonToken)
        {
            if (attributeLists != this.AttributeLists || modifiers != this.Modifiers || keyword != this.Keyword || identifier != this.Identifier || typeParameterList != this.TypeParameterList || parameterList != this.ParameterList || baseList != this.BaseList || constraintClauses != this.ConstraintClauses || openBraceToken != this.OpenBraceToken || members != this.Members || closeBraceToken != this.CloseBraceToken || semicolonToken != this.SemicolonToken)
            {
                var newNode = SyntaxFactory.RecordDeclaration(attributeLists, modifiers, keyword, identifier, typeParameterList, parameterList, baseList, constraintClauses, openBraceToken, members, closeBraceToken, semicolonToken);
                var diags = GetDiagnostics();
                if (diags?.Length > 0)
                    newNode = newNode.WithDiagnosticsGreen(diags);
                var annotations = GetAnnotations();
                if (annotations?.Length > 0)
                    newNode = newNode.WithAnnotationsGreen(annotations);
                return newNode;
            }

            return this;
        }

        internal override GreenNode SetDiagnostics(DiagnosticInfo[]? diagnostics)
            => new RecordDeclarationSyntax(this.Kind, this.attributeLists, this.modifiers, this.keyword, this.identifier, this.typeParameterList, this.parameterList, this.baseList, this.constraintClauses, this.openBraceToken, this.members, this.closeBraceToken, this.semicolonToken, diagnostics, GetAnnotations());

        internal override GreenNode SetAnnotations(SyntaxAnnotation[]? annotations)
            => new RecordDeclarationSyntax(this.Kind, this.attributeLists, this.modifiers, this.keyword, this.identifier, this.typeParameterList, this.parameterList, this.baseList, this.constraintClauses, this.openBraceToken, this.members, this.closeBraceToken, this.semicolonToken, GetDiagnostics(), annotations);

        internal RecordDeclarationSyntax(ObjectReader reader)
          : base(reader)
        {
            this.SlotCount = 12;
            var attributeLists = (GreenNode?)reader.ReadValue();
            if (attributeLists != null)
            {
                AdjustFlagsAndWidth(attributeLists);
                this.attributeLists = attributeLists;
            }
            var modifiers = (GreenNode?)reader.ReadValue();
            if (modifiers != null)
            {
                AdjustFlagsAndWidth(modifiers);
                this.modifiers = modifiers;
            }
            var keyword = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(keyword);
            this.keyword = keyword;
            var identifier = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(identifier);
            this.identifier = identifier;
            var typeParameterList = (TypeParameterListSyntax?)reader.ReadValue();
            if (typeParameterList != null)
            {
                AdjustFlagsAndWidth(typeParameterList);
                this.typeParameterList = typeParameterList;
            }
            var parameterList = (ParameterListSyntax?)reader.ReadValue();
            if (parameterList != null)
            {
                AdjustFlagsAndWidth(parameterList);
                this.parameterList = parameterList;
            }
            var baseList = (BaseListSyntax?)reader.ReadValue();
            if (baseList != null)
            {
                AdjustFlagsAndWidth(baseList);
                this.baseList = baseList;
            }
            var constraintClauses = (GreenNode?)reader.ReadValue();
            if (constraintClauses != null)
            {
                AdjustFlagsAndWidth(constraintClauses);
                this.constraintClauses = constraintClauses;
            }
            var openBraceToken = (SyntaxToken?)reader.ReadValue();
            if (openBraceToken != null)
            {
                AdjustFlagsAndWidth(openBraceToken);
                this.openBraceToken = openBraceToken;
            }
            var members = (GreenNode?)reader.ReadValue();
            if (members != null)
            {
                AdjustFlagsAndWidth(members);
                this.members = members;
            }
            var closeBraceToken = (SyntaxToken?)reader.ReadValue();
            if (closeBraceToken != null)
            {
                AdjustFlagsAndWidth(closeBraceToken);
                this.closeBraceToken = closeBraceToken;
            }
            var semicolonToken = (SyntaxToken?)reader.ReadValue();
            if (semicolonToken != null)
            {
                AdjustFlagsAndWidth(semicolonToken);
                this.semicolonToken = semicolonToken;
            }
        }

        internal override void WriteTo(ObjectWriter writer)
        {
            base.WriteTo(writer);
            writer.WriteValue(this.attributeLists);
            writer.WriteValue(this.modifiers);
            writer.WriteValue(this.keyword);
            writer.WriteValue(this.identifier);
            writer.WriteValue(this.typeParameterList);
            writer.WriteValue(this.parameterList);
            writer.WriteValue(this.baseList);
            writer.WriteValue(this.constraintClauses);
            writer.WriteValue(this.openBraceToken);
            writer.WriteValue(this.members);
            writer.WriteValue(this.closeBraceToken);
            writer.WriteValue(this.semicolonToken);
        }

        static RecordDeclarationSyntax()
        {
            ObjectBinder.RegisterTypeReader(typeof(RecordDeclarationSyntax), r => new RecordDeclarationSyntax(r));
        }
    }

    /// <summary>Enum type declaration syntax.</summary>
    internal sealed partial class EnumDeclarationSyntax : BaseTypeDeclarationSyntax
    {
        internal readonly GreenNode? attributeLists;
        internal readonly GreenNode? modifiers;
        internal readonly SyntaxToken enumKeyword;
        internal readonly SyntaxToken identifier;
        internal readonly BaseListSyntax? baseList;
        internal readonly SyntaxToken openBraceToken;
        internal readonly GreenNode? members;
        internal readonly SyntaxToken closeBraceToken;
        internal readonly SyntaxToken? semicolonToken;

        internal EnumDeclarationSyntax(SyntaxKind kind, GreenNode? attributeLists, GreenNode? modifiers, SyntaxToken enumKeyword, SyntaxToken identifier, BaseListSyntax? baseList, SyntaxToken openBraceToken, GreenNode? members, SyntaxToken closeBraceToken, SyntaxToken? semicolonToken, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
            this.SlotCount = 9;
            if (attributeLists != null)
            {
                this.AdjustFlagsAndWidth(attributeLists);
                this.attributeLists = attributeLists;
            }
            if (modifiers != null)
            {
                this.AdjustFlagsAndWidth(modifiers);
                this.modifiers = modifiers;
            }
            this.AdjustFlagsAndWidth(enumKeyword);
            this.enumKeyword = enumKeyword;
            this.AdjustFlagsAndWidth(identifier);
            this.identifier = identifier;
            if (baseList != null)
            {
                this.AdjustFlagsAndWidth(baseList);
                this.baseList = baseList;
            }
            this.AdjustFlagsAndWidth(openBraceToken);
            this.openBraceToken = openBraceToken;
            if (members != null)
            {
                this.AdjustFlagsAndWidth(members);
                this.members = members;
            }
            this.AdjustFlagsAndWidth(closeBraceToken);
            this.closeBraceToken = closeBraceToken;
            if (semicolonToken != null)
            {
                this.AdjustFlagsAndWidth(semicolonToken);
                this.semicolonToken = semicolonToken;
            }
        }

        internal EnumDeclarationSyntax(SyntaxKind kind, GreenNode? attributeLists, GreenNode? modifiers, SyntaxToken enumKeyword, SyntaxToken identifier, BaseListSyntax? baseList, SyntaxToken openBraceToken, GreenNode? members, SyntaxToken closeBraceToken, SyntaxToken? semicolonToken, SyntaxFactoryContext context)
          : base(kind)
        {
            this.SetFactoryContext(context);
            this.SlotCount = 9;
            if (attributeLists != null)
            {
                this.AdjustFlagsAndWidth(attributeLists);
                this.attributeLists = attributeLists;
            }
            if (modifiers != null)
            {
                this.AdjustFlagsAndWidth(modifiers);
                this.modifiers = modifiers;
            }
            this.AdjustFlagsAndWidth(enumKeyword);
            this.enumKeyword = enumKeyword;
            this.AdjustFlagsAndWidth(identifier);
            this.identifier = identifier;
            if (baseList != null)
            {
                this.AdjustFlagsAndWidth(baseList);
                this.baseList = baseList;
            }
            this.AdjustFlagsAndWidth(openBraceToken);
            this.openBraceToken = openBraceToken;
            if (members != null)
            {
                this.AdjustFlagsAndWidth(members);
                this.members = members;
            }
            this.AdjustFlagsAndWidth(closeBraceToken);
            this.closeBraceToken = closeBraceToken;
            if (semicolonToken != null)
            {
                this.AdjustFlagsAndWidth(semicolonToken);
                this.semicolonToken = semicolonToken;
            }
        }

        internal EnumDeclarationSyntax(SyntaxKind kind, GreenNode? attributeLists, GreenNode? modifiers, SyntaxToken enumKeyword, SyntaxToken identifier, BaseListSyntax? baseList, SyntaxToken openBraceToken, GreenNode? members, SyntaxToken closeBraceToken, SyntaxToken? semicolonToken)
          : base(kind)
        {
            this.SlotCount = 9;
            if (attributeLists != null)
            {
                this.AdjustFlagsAndWidth(attributeLists);
                this.attributeLists = attributeLists;
            }
            if (modifiers != null)
            {
                this.AdjustFlagsAndWidth(modifiers);
                this.modifiers = modifiers;
            }
            this.AdjustFlagsAndWidth(enumKeyword);
            this.enumKeyword = enumKeyword;
            this.AdjustFlagsAndWidth(identifier);
            this.identifier = identifier;
            if (baseList != null)
            {
                this.AdjustFlagsAndWidth(baseList);
                this.baseList = baseList;
            }
            this.AdjustFlagsAndWidth(openBraceToken);
            this.openBraceToken = openBraceToken;
            if (members != null)
            {
                this.AdjustFlagsAndWidth(members);
                this.members = members;
            }
            this.AdjustFlagsAndWidth(closeBraceToken);
            this.closeBraceToken = closeBraceToken;
            if (semicolonToken != null)
            {
                this.AdjustFlagsAndWidth(semicolonToken);
                this.semicolonToken = semicolonToken;
            }
        }

        public override Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<AttributeListSyntax> AttributeLists => new Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<AttributeListSyntax>(this.attributeLists);
        public override Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SyntaxToken> Modifiers => new Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SyntaxToken>(this.modifiers);
        /// <summary>Gets the enum keyword token.</summary>
        public SyntaxToken EnumKeyword => this.enumKeyword;
        public override SyntaxToken Identifier => this.identifier;
        public override BaseListSyntax? BaseList => this.baseList;
        public override SyntaxToken OpenBraceToken => this.openBraceToken;
        /// <summary>Gets the members declaration list.</summary>
        public Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<EnumMemberDeclarationSyntax> Members => new Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<EnumMemberDeclarationSyntax>(new Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<CSharpSyntaxNode>(this.members));
        public override SyntaxToken CloseBraceToken => this.closeBraceToken;
        /// <summary>Gets the optional semicolon token.</summary>
        public override SyntaxToken? SemicolonToken => this.semicolonToken;

        internal override GreenNode? GetSlot(int index)
            => index switch
            {
                0 => this.attributeLists,
                1 => this.modifiers,
                2 => this.enumKeyword,
                3 => this.identifier,
                4 => this.baseList,
                5 => this.openBraceToken,
                6 => this.members,
                7 => this.closeBraceToken,
                8 => this.semicolonToken,
                _ => null,
            };

        internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new CSharp.Syntax.EnumDeclarationSyntax(this, parent, position);

        public override void Accept(CSharpSyntaxVisitor visitor) => visitor.VisitEnumDeclaration(this);
        public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor) => visitor.VisitEnumDeclaration(this);

        public EnumDeclarationSyntax Update(Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<AttributeListSyntax> attributeLists, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SyntaxToken> modifiers, SyntaxToken enumKeyword, SyntaxToken identifier, BaseListSyntax baseList, SyntaxToken openBraceToken, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<EnumMemberDeclarationSyntax> members, SyntaxToken closeBraceToken, SyntaxToken semicolonToken)
        {
            if (attributeLists != this.AttributeLists || modifiers != this.Modifiers || enumKeyword != this.EnumKeyword || identifier != this.Identifier || baseList != this.BaseList || openBraceToken != this.OpenBraceToken || members != this.Members || closeBraceToken != this.CloseBraceToken || semicolonToken != this.SemicolonToken)
            {
                var newNode = SyntaxFactory.EnumDeclaration(attributeLists, modifiers, enumKeyword, identifier, baseList, openBraceToken, members, closeBraceToken, semicolonToken);
                var diags = GetDiagnostics();
                if (diags?.Length > 0)
                    newNode = newNode.WithDiagnosticsGreen(diags);
                var annotations = GetAnnotations();
                if (annotations?.Length > 0)
                    newNode = newNode.WithAnnotationsGreen(annotations);
                return newNode;
            }

            return this;
        }

        internal override GreenNode SetDiagnostics(DiagnosticInfo[]? diagnostics)
            => new EnumDeclarationSyntax(this.Kind, this.attributeLists, this.modifiers, this.enumKeyword, this.identifier, this.baseList, this.openBraceToken, this.members, this.closeBraceToken, this.semicolonToken, diagnostics, GetAnnotations());

        internal override GreenNode SetAnnotations(SyntaxAnnotation[]? annotations)
            => new EnumDeclarationSyntax(this.Kind, this.attributeLists, this.modifiers, this.enumKeyword, this.identifier, this.baseList, this.openBraceToken, this.members, this.closeBraceToken, this.semicolonToken, GetDiagnostics(), annotations);

        internal EnumDeclarationSyntax(ObjectReader reader)
          : base(reader)
        {
            this.SlotCount = 9;
            var attributeLists = (GreenNode?)reader.ReadValue();
            if (attributeLists != null)
            {
                AdjustFlagsAndWidth(attributeLists);
                this.attributeLists = attributeLists;
            }
            var modifiers = (GreenNode?)reader.ReadValue();
            if (modifiers != null)
            {
                AdjustFlagsAndWidth(modifiers);
                this.modifiers = modifiers;
            }
            var enumKeyword = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(enumKeyword);
            this.enumKeyword = enumKeyword;
            var identifier = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(identifier);
            this.identifier = identifier;
            var baseList = (BaseListSyntax?)reader.ReadValue();
            if (baseList != null)
            {
                AdjustFlagsAndWidth(baseList);
                this.baseList = baseList;
            }
            var openBraceToken = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(openBraceToken);
            this.openBraceToken = openBraceToken;
            var members = (GreenNode?)reader.ReadValue();
            if (members != null)
            {
                AdjustFlagsAndWidth(members);
                this.members = members;
            }
            var closeBraceToken = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(closeBraceToken);
            this.closeBraceToken = closeBraceToken;
            var semicolonToken = (SyntaxToken?)reader.ReadValue();
            if (semicolonToken != null)
            {
                AdjustFlagsAndWidth(semicolonToken);
                this.semicolonToken = semicolonToken;
            }
        }

        internal override void WriteTo(ObjectWriter writer)
        {
            base.WriteTo(writer);
            writer.WriteValue(this.attributeLists);
            writer.WriteValue(this.modifiers);
            writer.WriteValue(this.enumKeyword);
            writer.WriteValue(this.identifier);
            writer.WriteValue(this.baseList);
            writer.WriteValue(this.openBraceToken);
            writer.WriteValue(this.members);
            writer.WriteValue(this.closeBraceToken);
            writer.WriteValue(this.semicolonToken);
        }

        static EnumDeclarationSyntax()
        {
            ObjectBinder.RegisterTypeReader(typeof(EnumDeclarationSyntax), r => new EnumDeclarationSyntax(r));
        }
    }

    /// <summary>Delegate declaration syntax.</summary>
    internal sealed partial class DelegateDeclarationSyntax : MemberDeclarationSyntax
    {
        internal readonly GreenNode? attributeLists;
        internal readonly GreenNode? modifiers;
        internal readonly SyntaxToken delegateKeyword;
        internal readonly TypeSyntax returnType;
        internal readonly SyntaxToken identifier;
        internal readonly TypeParameterListSyntax? typeParameterList;
        internal readonly ParameterListSyntax parameterList;
        internal readonly GreenNode? constraintClauses;
        internal readonly SyntaxToken semicolonToken;

        internal DelegateDeclarationSyntax(SyntaxKind kind, GreenNode? attributeLists, GreenNode? modifiers, SyntaxToken delegateKeyword, TypeSyntax returnType, SyntaxToken identifier, TypeParameterListSyntax? typeParameterList, ParameterListSyntax parameterList, GreenNode? constraintClauses, SyntaxToken semicolonToken, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
            this.SlotCount = 9;
            if (attributeLists != null)
            {
                this.AdjustFlagsAndWidth(attributeLists);
                this.attributeLists = attributeLists;
            }
            if (modifiers != null)
            {
                this.AdjustFlagsAndWidth(modifiers);
                this.modifiers = modifiers;
            }
            this.AdjustFlagsAndWidth(delegateKeyword);
            this.delegateKeyword = delegateKeyword;
            this.AdjustFlagsAndWidth(returnType);
            this.returnType = returnType;
            this.AdjustFlagsAndWidth(identifier);
            this.identifier = identifier;
            if (typeParameterList != null)
            {
                this.AdjustFlagsAndWidth(typeParameterList);
                this.typeParameterList = typeParameterList;
            }
            this.AdjustFlagsAndWidth(parameterList);
            this.parameterList = parameterList;
            if (constraintClauses != null)
            {
                this.AdjustFlagsAndWidth(constraintClauses);
                this.constraintClauses = constraintClauses;
            }
            this.AdjustFlagsAndWidth(semicolonToken);
            this.semicolonToken = semicolonToken;
        }

        internal DelegateDeclarationSyntax(SyntaxKind kind, GreenNode? attributeLists, GreenNode? modifiers, SyntaxToken delegateKeyword, TypeSyntax returnType, SyntaxToken identifier, TypeParameterListSyntax? typeParameterList, ParameterListSyntax parameterList, GreenNode? constraintClauses, SyntaxToken semicolonToken, SyntaxFactoryContext context)
          : base(kind)
        {
            this.SetFactoryContext(context);
            this.SlotCount = 9;
            if (attributeLists != null)
            {
                this.AdjustFlagsAndWidth(attributeLists);
                this.attributeLists = attributeLists;
            }
            if (modifiers != null)
            {
                this.AdjustFlagsAndWidth(modifiers);
                this.modifiers = modifiers;
            }
            this.AdjustFlagsAndWidth(delegateKeyword);
            this.delegateKeyword = delegateKeyword;
            this.AdjustFlagsAndWidth(returnType);
            this.returnType = returnType;
            this.AdjustFlagsAndWidth(identifier);
            this.identifier = identifier;
            if (typeParameterList != null)
            {
                this.AdjustFlagsAndWidth(typeParameterList);
                this.typeParameterList = typeParameterList;
            }
            this.AdjustFlagsAndWidth(parameterList);
            this.parameterList = parameterList;
            if (constraintClauses != null)
            {
                this.AdjustFlagsAndWidth(constraintClauses);
                this.constraintClauses = constraintClauses;
            }
            this.AdjustFlagsAndWidth(semicolonToken);
            this.semicolonToken = semicolonToken;
        }

        internal DelegateDeclarationSyntax(SyntaxKind kind, GreenNode? attributeLists, GreenNode? modifiers, SyntaxToken delegateKeyword, TypeSyntax returnType, SyntaxToken identifier, TypeParameterListSyntax? typeParameterList, ParameterListSyntax parameterList, GreenNode? constraintClauses, SyntaxToken semicolonToken)
          : base(kind)
        {
            this.SlotCount = 9;
            if (attributeLists != null)
            {
                this.AdjustFlagsAndWidth(attributeLists);
                this.attributeLists = attributeLists;
            }
            if (modifiers != null)
            {
                this.AdjustFlagsAndWidth(modifiers);
                this.modifiers = modifiers;
            }
            this.AdjustFlagsAndWidth(delegateKeyword);
            this.delegateKeyword = delegateKeyword;
            this.AdjustFlagsAndWidth(returnType);
            this.returnType = returnType;
            this.AdjustFlagsAndWidth(identifier);
            this.identifier = identifier;
            if (typeParameterList != null)
            {
                this.AdjustFlagsAndWidth(typeParameterList);
                this.typeParameterList = typeParameterList;
            }
            this.AdjustFlagsAndWidth(parameterList);
            this.parameterList = parameterList;
            if (constraintClauses != null)
            {
                this.AdjustFlagsAndWidth(constraintClauses);
                this.constraintClauses = constraintClauses;
            }
            this.AdjustFlagsAndWidth(semicolonToken);
            this.semicolonToken = semicolonToken;
        }

        public override Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<AttributeListSyntax> AttributeLists => new Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<AttributeListSyntax>(this.attributeLists);
        public override Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SyntaxToken> Modifiers => new Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SyntaxToken>(this.modifiers);
        /// <summary>Gets the "delegate" keyword.</summary>
        public SyntaxToken DelegateKeyword => this.delegateKeyword;
        /// <summary>Gets the return type.</summary>
        public TypeSyntax ReturnType => this.returnType;
        /// <summary>Gets the identifier.</summary>
        public SyntaxToken Identifier => this.identifier;
        public TypeParameterListSyntax? TypeParameterList => this.typeParameterList;
        /// <summary>Gets the parameter list.</summary>
        public ParameterListSyntax ParameterList => this.parameterList;
        /// <summary>Gets the constraint clause list.</summary>
        public Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<TypeParameterConstraintClauseSyntax> ConstraintClauses => new Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<TypeParameterConstraintClauseSyntax>(this.constraintClauses);
        /// <summary>Gets the semicolon token.</summary>
        public SyntaxToken SemicolonToken => this.semicolonToken;

        internal override GreenNode? GetSlot(int index)
            => index switch
            {
                0 => this.attributeLists,
                1 => this.modifiers,
                2 => this.delegateKeyword,
                3 => this.returnType,
                4 => this.identifier,
                5 => this.typeParameterList,
                6 => this.parameterList,
                7 => this.constraintClauses,
                8 => this.semicolonToken,
                _ => null,
            };

        internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new CSharp.Syntax.DelegateDeclarationSyntax(this, parent, position);

        public override void Accept(CSharpSyntaxVisitor visitor) => visitor.VisitDelegateDeclaration(this);
        public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor) => visitor.VisitDelegateDeclaration(this);

        public DelegateDeclarationSyntax Update(Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<AttributeListSyntax> attributeLists, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SyntaxToken> modifiers, SyntaxToken delegateKeyword, TypeSyntax returnType, SyntaxToken identifier, TypeParameterListSyntax typeParameterList, ParameterListSyntax parameterList, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<TypeParameterConstraintClauseSyntax> constraintClauses, SyntaxToken semicolonToken)
        {
            if (attributeLists != this.AttributeLists || modifiers != this.Modifiers || delegateKeyword != this.DelegateKeyword || returnType != this.ReturnType || identifier != this.Identifier || typeParameterList != this.TypeParameterList || parameterList != this.ParameterList || constraintClauses != this.ConstraintClauses || semicolonToken != this.SemicolonToken)
            {
                var newNode = SyntaxFactory.DelegateDeclaration(attributeLists, modifiers, delegateKeyword, returnType, identifier, typeParameterList, parameterList, constraintClauses, semicolonToken);
                var diags = GetDiagnostics();
                if (diags?.Length > 0)
                    newNode = newNode.WithDiagnosticsGreen(diags);
                var annotations = GetAnnotations();
                if (annotations?.Length > 0)
                    newNode = newNode.WithAnnotationsGreen(annotations);
                return newNode;
            }

            return this;
        }

        internal override GreenNode SetDiagnostics(DiagnosticInfo[]? diagnostics)
            => new DelegateDeclarationSyntax(this.Kind, this.attributeLists, this.modifiers, this.delegateKeyword, this.returnType, this.identifier, this.typeParameterList, this.parameterList, this.constraintClauses, this.semicolonToken, diagnostics, GetAnnotations());

        internal override GreenNode SetAnnotations(SyntaxAnnotation[]? annotations)
            => new DelegateDeclarationSyntax(this.Kind, this.attributeLists, this.modifiers, this.delegateKeyword, this.returnType, this.identifier, this.typeParameterList, this.parameterList, this.constraintClauses, this.semicolonToken, GetDiagnostics(), annotations);

        internal DelegateDeclarationSyntax(ObjectReader reader)
          : base(reader)
        {
            this.SlotCount = 9;
            var attributeLists = (GreenNode?)reader.ReadValue();
            if (attributeLists != null)
            {
                AdjustFlagsAndWidth(attributeLists);
                this.attributeLists = attributeLists;
            }
            var modifiers = (GreenNode?)reader.ReadValue();
            if (modifiers != null)
            {
                AdjustFlagsAndWidth(modifiers);
                this.modifiers = modifiers;
            }
            var delegateKeyword = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(delegateKeyword);
            this.delegateKeyword = delegateKeyword;
            var returnType = (TypeSyntax)reader.ReadValue();
            AdjustFlagsAndWidth(returnType);
            this.returnType = returnType;
            var identifier = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(identifier);
            this.identifier = identifier;
            var typeParameterList = (TypeParameterListSyntax?)reader.ReadValue();
            if (typeParameterList != null)
            {
                AdjustFlagsAndWidth(typeParameterList);
                this.typeParameterList = typeParameterList;
            }
            var parameterList = (ParameterListSyntax)reader.ReadValue();
            AdjustFlagsAndWidth(parameterList);
            this.parameterList = parameterList;
            var constraintClauses = (GreenNode?)reader.ReadValue();
            if (constraintClauses != null)
            {
                AdjustFlagsAndWidth(constraintClauses);
                this.constraintClauses = constraintClauses;
            }
            var semicolonToken = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(semicolonToken);
            this.semicolonToken = semicolonToken;
        }

        internal override void WriteTo(ObjectWriter writer)
        {
            base.WriteTo(writer);
            writer.WriteValue(this.attributeLists);
            writer.WriteValue(this.modifiers);
            writer.WriteValue(this.delegateKeyword);
            writer.WriteValue(this.returnType);
            writer.WriteValue(this.identifier);
            writer.WriteValue(this.typeParameterList);
            writer.WriteValue(this.parameterList);
            writer.WriteValue(this.constraintClauses);
            writer.WriteValue(this.semicolonToken);
        }

        static DelegateDeclarationSyntax()
        {
            ObjectBinder.RegisterTypeReader(typeof(DelegateDeclarationSyntax), r => new DelegateDeclarationSyntax(r));
        }
    }

    internal sealed partial class EnumMemberDeclarationSyntax : MemberDeclarationSyntax
    {
        internal readonly GreenNode? attributeLists;
        internal readonly GreenNode? modifiers;
        internal readonly SyntaxToken identifier;
        internal readonly EqualsValueClauseSyntax? equalsValue;

        internal EnumMemberDeclarationSyntax(SyntaxKind kind, GreenNode? attributeLists, GreenNode? modifiers, SyntaxToken identifier, EqualsValueClauseSyntax? equalsValue, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
            this.SlotCount = 4;
            if (attributeLists != null)
            {
                this.AdjustFlagsAndWidth(attributeLists);
                this.attributeLists = attributeLists;
            }
            if (modifiers != null)
            {
                this.AdjustFlagsAndWidth(modifiers);
                this.modifiers = modifiers;
            }
            this.AdjustFlagsAndWidth(identifier);
            this.identifier = identifier;
            if (equalsValue != null)
            {
                this.AdjustFlagsAndWidth(equalsValue);
                this.equalsValue = equalsValue;
            }
        }

        internal EnumMemberDeclarationSyntax(SyntaxKind kind, GreenNode? attributeLists, GreenNode? modifiers, SyntaxToken identifier, EqualsValueClauseSyntax? equalsValue, SyntaxFactoryContext context)
          : base(kind)
        {
            this.SetFactoryContext(context);
            this.SlotCount = 4;
            if (attributeLists != null)
            {
                this.AdjustFlagsAndWidth(attributeLists);
                this.attributeLists = attributeLists;
            }
            if (modifiers != null)
            {
                this.AdjustFlagsAndWidth(modifiers);
                this.modifiers = modifiers;
            }
            this.AdjustFlagsAndWidth(identifier);
            this.identifier = identifier;
            if (equalsValue != null)
            {
                this.AdjustFlagsAndWidth(equalsValue);
                this.equalsValue = equalsValue;
            }
        }

        internal EnumMemberDeclarationSyntax(SyntaxKind kind, GreenNode? attributeLists, GreenNode? modifiers, SyntaxToken identifier, EqualsValueClauseSyntax? equalsValue)
          : base(kind)
        {
            this.SlotCount = 4;
            if (attributeLists != null)
            {
                this.AdjustFlagsAndWidth(attributeLists);
                this.attributeLists = attributeLists;
            }
            if (modifiers != null)
            {
                this.AdjustFlagsAndWidth(modifiers);
                this.modifiers = modifiers;
            }
            this.AdjustFlagsAndWidth(identifier);
            this.identifier = identifier;
            if (equalsValue != null)
            {
                this.AdjustFlagsAndWidth(equalsValue);
                this.equalsValue = equalsValue;
            }
        }

        public override Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<AttributeListSyntax> AttributeLists => new Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<AttributeListSyntax>(this.attributeLists);
        public override Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SyntaxToken> Modifiers => new Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SyntaxToken>(this.modifiers);
        /// <summary>Gets the identifier.</summary>
        public SyntaxToken Identifier => this.identifier;
        public EqualsValueClauseSyntax? EqualsValue => this.equalsValue;

        internal override GreenNode? GetSlot(int index)
            => index switch
            {
                0 => this.attributeLists,
                1 => this.modifiers,
                2 => this.identifier,
                3 => this.equalsValue,
                _ => null,
            };

        internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new CSharp.Syntax.EnumMemberDeclarationSyntax(this, parent, position);

        public override void Accept(CSharpSyntaxVisitor visitor) => visitor.VisitEnumMemberDeclaration(this);
        public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor) => visitor.VisitEnumMemberDeclaration(this);

        public EnumMemberDeclarationSyntax Update(Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<AttributeListSyntax> attributeLists, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SyntaxToken> modifiers, SyntaxToken identifier, EqualsValueClauseSyntax equalsValue)
        {
            if (attributeLists != this.AttributeLists || modifiers != this.Modifiers || identifier != this.Identifier || equalsValue != this.EqualsValue)
            {
                var newNode = SyntaxFactory.EnumMemberDeclaration(attributeLists, modifiers, identifier, equalsValue);
                var diags = GetDiagnostics();
                if (diags?.Length > 0)
                    newNode = newNode.WithDiagnosticsGreen(diags);
                var annotations = GetAnnotations();
                if (annotations?.Length > 0)
                    newNode = newNode.WithAnnotationsGreen(annotations);
                return newNode;
            }

            return this;
        }

        internal override GreenNode SetDiagnostics(DiagnosticInfo[]? diagnostics)
            => new EnumMemberDeclarationSyntax(this.Kind, this.attributeLists, this.modifiers, this.identifier, this.equalsValue, diagnostics, GetAnnotations());

        internal override GreenNode SetAnnotations(SyntaxAnnotation[]? annotations)
            => new EnumMemberDeclarationSyntax(this.Kind, this.attributeLists, this.modifiers, this.identifier, this.equalsValue, GetDiagnostics(), annotations);

        internal EnumMemberDeclarationSyntax(ObjectReader reader)
          : base(reader)
        {
            this.SlotCount = 4;
            var attributeLists = (GreenNode?)reader.ReadValue();
            if (attributeLists != null)
            {
                AdjustFlagsAndWidth(attributeLists);
                this.attributeLists = attributeLists;
            }
            var modifiers = (GreenNode?)reader.ReadValue();
            if (modifiers != null)
            {
                AdjustFlagsAndWidth(modifiers);
                this.modifiers = modifiers;
            }
            var identifier = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(identifier);
            this.identifier = identifier;
            var equalsValue = (EqualsValueClauseSyntax?)reader.ReadValue();
            if (equalsValue != null)
            {
                AdjustFlagsAndWidth(equalsValue);
                this.equalsValue = equalsValue;
            }
        }

        internal override void WriteTo(ObjectWriter writer)
        {
            base.WriteTo(writer);
            writer.WriteValue(this.attributeLists);
            writer.WriteValue(this.modifiers);
            writer.WriteValue(this.identifier);
            writer.WriteValue(this.equalsValue);
        }

        static EnumMemberDeclarationSyntax()
        {
            ObjectBinder.RegisterTypeReader(typeof(EnumMemberDeclarationSyntax), r => new EnumMemberDeclarationSyntax(r));
        }
    }

    /// <summary>Base list syntax.</summary>
    internal sealed partial class BaseListSyntax : CSharpSyntaxNode
    {
        internal readonly SyntaxToken colonToken;
        internal readonly GreenNode? types;

        internal BaseListSyntax(SyntaxKind kind, SyntaxToken colonToken, GreenNode? types, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
            this.SlotCount = 2;
            this.AdjustFlagsAndWidth(colonToken);
            this.colonToken = colonToken;
            if (types != null)
            {
                this.AdjustFlagsAndWidth(types);
                this.types = types;
            }
        }

        internal BaseListSyntax(SyntaxKind kind, SyntaxToken colonToken, GreenNode? types, SyntaxFactoryContext context)
          : base(kind)
        {
            this.SetFactoryContext(context);
            this.SlotCount = 2;
            this.AdjustFlagsAndWidth(colonToken);
            this.colonToken = colonToken;
            if (types != null)
            {
                this.AdjustFlagsAndWidth(types);
                this.types = types;
            }
        }

        internal BaseListSyntax(SyntaxKind kind, SyntaxToken colonToken, GreenNode? types)
          : base(kind)
        {
            this.SlotCount = 2;
            this.AdjustFlagsAndWidth(colonToken);
            this.colonToken = colonToken;
            if (types != null)
            {
                this.AdjustFlagsAndWidth(types);
                this.types = types;
            }
        }

        /// <summary>Gets the colon token.</summary>
        public SyntaxToken ColonToken => this.colonToken;
        /// <summary>Gets the base type references.</summary>
        public Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<BaseTypeSyntax> Types => new Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<BaseTypeSyntax>(new Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<CSharpSyntaxNode>(this.types));

        internal override GreenNode? GetSlot(int index)
            => index switch
            {
                0 => this.colonToken,
                1 => this.types,
                _ => null,
            };

        internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new CSharp.Syntax.BaseListSyntax(this, parent, position);

        public override void Accept(CSharpSyntaxVisitor visitor) => visitor.VisitBaseList(this);
        public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor) => visitor.VisitBaseList(this);

        public BaseListSyntax Update(SyntaxToken colonToken, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<BaseTypeSyntax> types)
        {
            if (colonToken != this.ColonToken || types != this.Types)
            {
                var newNode = SyntaxFactory.BaseList(colonToken, types);
                var diags = GetDiagnostics();
                if (diags?.Length > 0)
                    newNode = newNode.WithDiagnosticsGreen(diags);
                var annotations = GetAnnotations();
                if (annotations?.Length > 0)
                    newNode = newNode.WithAnnotationsGreen(annotations);
                return newNode;
            }

            return this;
        }

        internal override GreenNode SetDiagnostics(DiagnosticInfo[]? diagnostics)
            => new BaseListSyntax(this.Kind, this.colonToken, this.types, diagnostics, GetAnnotations());

        internal override GreenNode SetAnnotations(SyntaxAnnotation[]? annotations)
            => new BaseListSyntax(this.Kind, this.colonToken, this.types, GetDiagnostics(), annotations);

        internal BaseListSyntax(ObjectReader reader)
          : base(reader)
        {
            this.SlotCount = 2;
            var colonToken = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(colonToken);
            this.colonToken = colonToken;
            var types = (GreenNode?)reader.ReadValue();
            if (types != null)
            {
                AdjustFlagsAndWidth(types);
                this.types = types;
            }
        }

        internal override void WriteTo(ObjectWriter writer)
        {
            base.WriteTo(writer);
            writer.WriteValue(this.colonToken);
            writer.WriteValue(this.types);
        }

        static BaseListSyntax()
        {
            ObjectBinder.RegisterTypeReader(typeof(BaseListSyntax), r => new BaseListSyntax(r));
        }
    }

    /// <summary>Provides the base class from which the classes that represent base type syntax nodes are derived. This is an abstract class.</summary>
    internal abstract partial class BaseTypeSyntax : CSharpSyntaxNode
    {
        internal BaseTypeSyntax(SyntaxKind kind, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
        }

        internal BaseTypeSyntax(SyntaxKind kind)
          : base(kind)
        {
        }

        protected BaseTypeSyntax(ObjectReader reader)
          : base(reader)
        {
        }

        public abstract TypeSyntax Type { get; }
    }

    internal sealed partial class SimpleBaseTypeSyntax : BaseTypeSyntax
    {
        internal readonly TypeSyntax type;

        internal SimpleBaseTypeSyntax(SyntaxKind kind, TypeSyntax type, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
            this.SlotCount = 1;
            this.AdjustFlagsAndWidth(type);
            this.type = type;
        }

        internal SimpleBaseTypeSyntax(SyntaxKind kind, TypeSyntax type, SyntaxFactoryContext context)
          : base(kind)
        {
            this.SetFactoryContext(context);
            this.SlotCount = 1;
            this.AdjustFlagsAndWidth(type);
            this.type = type;
        }

        internal SimpleBaseTypeSyntax(SyntaxKind kind, TypeSyntax type)
          : base(kind)
        {
            this.SlotCount = 1;
            this.AdjustFlagsAndWidth(type);
            this.type = type;
        }

        public override TypeSyntax Type => this.type;

        internal override GreenNode? GetSlot(int index)
            => index == 0 ? this.type : null;

        internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new CSharp.Syntax.SimpleBaseTypeSyntax(this, parent, position);

        public override void Accept(CSharpSyntaxVisitor visitor) => visitor.VisitSimpleBaseType(this);
        public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor) => visitor.VisitSimpleBaseType(this);

        public SimpleBaseTypeSyntax Update(TypeSyntax type)
        {
            if (type != this.Type)
            {
                var newNode = SyntaxFactory.SimpleBaseType(type);
                var diags = GetDiagnostics();
                if (diags?.Length > 0)
                    newNode = newNode.WithDiagnosticsGreen(diags);
                var annotations = GetAnnotations();
                if (annotations?.Length > 0)
                    newNode = newNode.WithAnnotationsGreen(annotations);
                return newNode;
            }

            return this;
        }

        internal override GreenNode SetDiagnostics(DiagnosticInfo[]? diagnostics)
            => new SimpleBaseTypeSyntax(this.Kind, this.type, diagnostics, GetAnnotations());

        internal override GreenNode SetAnnotations(SyntaxAnnotation[]? annotations)
            => new SimpleBaseTypeSyntax(this.Kind, this.type, GetDiagnostics(), annotations);

        internal SimpleBaseTypeSyntax(ObjectReader reader)
          : base(reader)
        {
            this.SlotCount = 1;
            var type = (TypeSyntax)reader.ReadValue();
            AdjustFlagsAndWidth(type);
            this.type = type;
        }

        internal override void WriteTo(ObjectWriter writer)
        {
            base.WriteTo(writer);
            writer.WriteValue(this.type);
        }

        static SimpleBaseTypeSyntax()
        {
            ObjectBinder.RegisterTypeReader(typeof(SimpleBaseTypeSyntax), r => new SimpleBaseTypeSyntax(r));
        }
    }

    internal sealed partial class PrimaryConstructorBaseTypeSyntax : BaseTypeSyntax
    {
        internal readonly TypeSyntax type;
        internal readonly ArgumentListSyntax argumentList;

        internal PrimaryConstructorBaseTypeSyntax(SyntaxKind kind, TypeSyntax type, ArgumentListSyntax argumentList, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
            this.SlotCount = 2;
            this.AdjustFlagsAndWidth(type);
            this.type = type;
            this.AdjustFlagsAndWidth(argumentList);
            this.argumentList = argumentList;
        }

        internal PrimaryConstructorBaseTypeSyntax(SyntaxKind kind, TypeSyntax type, ArgumentListSyntax argumentList, SyntaxFactoryContext context)
          : base(kind)
        {
            this.SetFactoryContext(context);
            this.SlotCount = 2;
            this.AdjustFlagsAndWidth(type);
            this.type = type;
            this.AdjustFlagsAndWidth(argumentList);
            this.argumentList = argumentList;
        }

        internal PrimaryConstructorBaseTypeSyntax(SyntaxKind kind, TypeSyntax type, ArgumentListSyntax argumentList)
          : base(kind)
        {
            this.SlotCount = 2;
            this.AdjustFlagsAndWidth(type);
            this.type = type;
            this.AdjustFlagsAndWidth(argumentList);
            this.argumentList = argumentList;
        }

        public override TypeSyntax Type => this.type;
        public ArgumentListSyntax ArgumentList => this.argumentList;

        internal override GreenNode? GetSlot(int index)
            => index switch
            {
                0 => this.type,
                1 => this.argumentList,
                _ => null,
            };

        internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new CSharp.Syntax.PrimaryConstructorBaseTypeSyntax(this, parent, position);

        public override void Accept(CSharpSyntaxVisitor visitor) => visitor.VisitPrimaryConstructorBaseType(this);
        public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor) => visitor.VisitPrimaryConstructorBaseType(this);

        public PrimaryConstructorBaseTypeSyntax Update(TypeSyntax type, ArgumentListSyntax argumentList)
        {
            if (type != this.Type || argumentList != this.ArgumentList)
            {
                var newNode = SyntaxFactory.PrimaryConstructorBaseType(type, argumentList);
                var diags = GetDiagnostics();
                if (diags?.Length > 0)
                    newNode = newNode.WithDiagnosticsGreen(diags);
                var annotations = GetAnnotations();
                if (annotations?.Length > 0)
                    newNode = newNode.WithAnnotationsGreen(annotations);
                return newNode;
            }

            return this;
        }

        internal override GreenNode SetDiagnostics(DiagnosticInfo[]? diagnostics)
            => new PrimaryConstructorBaseTypeSyntax(this.Kind, this.type, this.argumentList, diagnostics, GetAnnotations());

        internal override GreenNode SetAnnotations(SyntaxAnnotation[]? annotations)
            => new PrimaryConstructorBaseTypeSyntax(this.Kind, this.type, this.argumentList, GetDiagnostics(), annotations);

        internal PrimaryConstructorBaseTypeSyntax(ObjectReader reader)
          : base(reader)
        {
            this.SlotCount = 2;
            var type = (TypeSyntax)reader.ReadValue();
            AdjustFlagsAndWidth(type);
            this.type = type;
            var argumentList = (ArgumentListSyntax)reader.ReadValue();
            AdjustFlagsAndWidth(argumentList);
            this.argumentList = argumentList;
        }

        internal override void WriteTo(ObjectWriter writer)
        {
            base.WriteTo(writer);
            writer.WriteValue(this.type);
            writer.WriteValue(this.argumentList);
        }

        static PrimaryConstructorBaseTypeSyntax()
        {
            ObjectBinder.RegisterTypeReader(typeof(PrimaryConstructorBaseTypeSyntax), r => new PrimaryConstructorBaseTypeSyntax(r));
        }
    }

    /// <summary>Type parameter constraint clause.</summary>
    internal sealed partial class TypeParameterConstraintClauseSyntax : CSharpSyntaxNode
    {
        internal readonly SyntaxToken whereKeyword;
        internal readonly IdentifierNameSyntax name;
        internal readonly SyntaxToken colonToken;
        internal readonly GreenNode? constraints;

        internal TypeParameterConstraintClauseSyntax(SyntaxKind kind, SyntaxToken whereKeyword, IdentifierNameSyntax name, SyntaxToken colonToken, GreenNode? constraints, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
            this.SlotCount = 4;
            this.AdjustFlagsAndWidth(whereKeyword);
            this.whereKeyword = whereKeyword;
            this.AdjustFlagsAndWidth(name);
            this.name = name;
            this.AdjustFlagsAndWidth(colonToken);
            this.colonToken = colonToken;
            if (constraints != null)
            {
                this.AdjustFlagsAndWidth(constraints);
                this.constraints = constraints;
            }
        }

        internal TypeParameterConstraintClauseSyntax(SyntaxKind kind, SyntaxToken whereKeyword, IdentifierNameSyntax name, SyntaxToken colonToken, GreenNode? constraints, SyntaxFactoryContext context)
          : base(kind)
        {
            this.SetFactoryContext(context);
            this.SlotCount = 4;
            this.AdjustFlagsAndWidth(whereKeyword);
            this.whereKeyword = whereKeyword;
            this.AdjustFlagsAndWidth(name);
            this.name = name;
            this.AdjustFlagsAndWidth(colonToken);
            this.colonToken = colonToken;
            if (constraints != null)
            {
                this.AdjustFlagsAndWidth(constraints);
                this.constraints = constraints;
            }
        }

        internal TypeParameterConstraintClauseSyntax(SyntaxKind kind, SyntaxToken whereKeyword, IdentifierNameSyntax name, SyntaxToken colonToken, GreenNode? constraints)
          : base(kind)
        {
            this.SlotCount = 4;
            this.AdjustFlagsAndWidth(whereKeyword);
            this.whereKeyword = whereKeyword;
            this.AdjustFlagsAndWidth(name);
            this.name = name;
            this.AdjustFlagsAndWidth(colonToken);
            this.colonToken = colonToken;
            if (constraints != null)
            {
                this.AdjustFlagsAndWidth(constraints);
                this.constraints = constraints;
            }
        }

        public SyntaxToken WhereKeyword => this.whereKeyword;
        /// <summary>Gets the identifier.</summary>
        public IdentifierNameSyntax Name => this.name;
        /// <summary>Gets the colon token.</summary>
        public SyntaxToken ColonToken => this.colonToken;
        /// <summary>Gets the constraints list.</summary>
        public Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<TypeParameterConstraintSyntax> Constraints => new Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<TypeParameterConstraintSyntax>(new Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<CSharpSyntaxNode>(this.constraints));

        internal override GreenNode? GetSlot(int index)
            => index switch
            {
                0 => this.whereKeyword,
                1 => this.name,
                2 => this.colonToken,
                3 => this.constraints,
                _ => null,
            };

        internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new CSharp.Syntax.TypeParameterConstraintClauseSyntax(this, parent, position);

        public override void Accept(CSharpSyntaxVisitor visitor) => visitor.VisitTypeParameterConstraintClause(this);
        public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor) => visitor.VisitTypeParameterConstraintClause(this);

        public TypeParameterConstraintClauseSyntax Update(SyntaxToken whereKeyword, IdentifierNameSyntax name, SyntaxToken colonToken, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<TypeParameterConstraintSyntax> constraints)
        {
            if (whereKeyword != this.WhereKeyword || name != this.Name || colonToken != this.ColonToken || constraints != this.Constraints)
            {
                var newNode = SyntaxFactory.TypeParameterConstraintClause(whereKeyword, name, colonToken, constraints);
                var diags = GetDiagnostics();
                if (diags?.Length > 0)
                    newNode = newNode.WithDiagnosticsGreen(diags);
                var annotations = GetAnnotations();
                if (annotations?.Length > 0)
                    newNode = newNode.WithAnnotationsGreen(annotations);
                return newNode;
            }

            return this;
        }

        internal override GreenNode SetDiagnostics(DiagnosticInfo[]? diagnostics)
            => new TypeParameterConstraintClauseSyntax(this.Kind, this.whereKeyword, this.name, this.colonToken, this.constraints, diagnostics, GetAnnotations());

        internal override GreenNode SetAnnotations(SyntaxAnnotation[]? annotations)
            => new TypeParameterConstraintClauseSyntax(this.Kind, this.whereKeyword, this.name, this.colonToken, this.constraints, GetDiagnostics(), annotations);

        internal TypeParameterConstraintClauseSyntax(ObjectReader reader)
          : base(reader)
        {
            this.SlotCount = 4;
            var whereKeyword = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(whereKeyword);
            this.whereKeyword = whereKeyword;
            var name = (IdentifierNameSyntax)reader.ReadValue();
            AdjustFlagsAndWidth(name);
            this.name = name;
            var colonToken = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(colonToken);
            this.colonToken = colonToken;
            var constraints = (GreenNode?)reader.ReadValue();
            if (constraints != null)
            {
                AdjustFlagsAndWidth(constraints);
                this.constraints = constraints;
            }
        }

        internal override void WriteTo(ObjectWriter writer)
        {
            base.WriteTo(writer);
            writer.WriteValue(this.whereKeyword);
            writer.WriteValue(this.name);
            writer.WriteValue(this.colonToken);
            writer.WriteValue(this.constraints);
        }

        static TypeParameterConstraintClauseSyntax()
        {
            ObjectBinder.RegisterTypeReader(typeof(TypeParameterConstraintClauseSyntax), r => new TypeParameterConstraintClauseSyntax(r));
        }
    }

    /// <summary>Base type for type parameter constraint syntax.</summary>
    internal abstract partial class TypeParameterConstraintSyntax : CSharpSyntaxNode
    {
        internal TypeParameterConstraintSyntax(SyntaxKind kind, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
        }

        internal TypeParameterConstraintSyntax(SyntaxKind kind)
          : base(kind)
        {
        }

        protected TypeParameterConstraintSyntax(ObjectReader reader)
          : base(reader)
        {
        }
    }

    /// <summary>Constructor constraint syntax.</summary>
    internal sealed partial class ConstructorConstraintSyntax : TypeParameterConstraintSyntax
    {
        internal readonly SyntaxToken newKeyword;
        internal readonly SyntaxToken openParenToken;
        internal readonly SyntaxToken closeParenToken;

        internal ConstructorConstraintSyntax(SyntaxKind kind, SyntaxToken newKeyword, SyntaxToken openParenToken, SyntaxToken closeParenToken, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
            this.SlotCount = 3;
            this.AdjustFlagsAndWidth(newKeyword);
            this.newKeyword = newKeyword;
            this.AdjustFlagsAndWidth(openParenToken);
            this.openParenToken = openParenToken;
            this.AdjustFlagsAndWidth(closeParenToken);
            this.closeParenToken = closeParenToken;
        }

        internal ConstructorConstraintSyntax(SyntaxKind kind, SyntaxToken newKeyword, SyntaxToken openParenToken, SyntaxToken closeParenToken, SyntaxFactoryContext context)
          : base(kind)
        {
            this.SetFactoryContext(context);
            this.SlotCount = 3;
            this.AdjustFlagsAndWidth(newKeyword);
            this.newKeyword = newKeyword;
            this.AdjustFlagsAndWidth(openParenToken);
            this.openParenToken = openParenToken;
            this.AdjustFlagsAndWidth(closeParenToken);
            this.closeParenToken = closeParenToken;
        }

        internal ConstructorConstraintSyntax(SyntaxKind kind, SyntaxToken newKeyword, SyntaxToken openParenToken, SyntaxToken closeParenToken)
          : base(kind)
        {
            this.SlotCount = 3;
            this.AdjustFlagsAndWidth(newKeyword);
            this.newKeyword = newKeyword;
            this.AdjustFlagsAndWidth(openParenToken);
            this.openParenToken = openParenToken;
            this.AdjustFlagsAndWidth(closeParenToken);
            this.closeParenToken = closeParenToken;
        }

        /// <summary>Gets the "new" keyword.</summary>
        public SyntaxToken NewKeyword => this.newKeyword;
        /// <summary>Gets the open paren keyword.</summary>
        public SyntaxToken OpenParenToken => this.openParenToken;
        /// <summary>Gets the close paren keyword.</summary>
        public SyntaxToken CloseParenToken => this.closeParenToken;

        internal override GreenNode? GetSlot(int index)
            => index switch
            {
                0 => this.newKeyword,
                1 => this.openParenToken,
                2 => this.closeParenToken,
                _ => null,
            };

        internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new CSharp.Syntax.ConstructorConstraintSyntax(this, parent, position);

        public override void Accept(CSharpSyntaxVisitor visitor) => visitor.VisitConstructorConstraint(this);
        public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor) => visitor.VisitConstructorConstraint(this);

        public ConstructorConstraintSyntax Update(SyntaxToken newKeyword, SyntaxToken openParenToken, SyntaxToken closeParenToken)
        {
            if (newKeyword != this.NewKeyword || openParenToken != this.OpenParenToken || closeParenToken != this.CloseParenToken)
            {
                var newNode = SyntaxFactory.ConstructorConstraint(newKeyword, openParenToken, closeParenToken);
                var diags = GetDiagnostics();
                if (diags?.Length > 0)
                    newNode = newNode.WithDiagnosticsGreen(diags);
                var annotations = GetAnnotations();
                if (annotations?.Length > 0)
                    newNode = newNode.WithAnnotationsGreen(annotations);
                return newNode;
            }

            return this;
        }

        internal override GreenNode SetDiagnostics(DiagnosticInfo[]? diagnostics)
            => new ConstructorConstraintSyntax(this.Kind, this.newKeyword, this.openParenToken, this.closeParenToken, diagnostics, GetAnnotations());

        internal override GreenNode SetAnnotations(SyntaxAnnotation[]? annotations)
            => new ConstructorConstraintSyntax(this.Kind, this.newKeyword, this.openParenToken, this.closeParenToken, GetDiagnostics(), annotations);

        internal ConstructorConstraintSyntax(ObjectReader reader)
          : base(reader)
        {
            this.SlotCount = 3;
            var newKeyword = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(newKeyword);
            this.newKeyword = newKeyword;
            var openParenToken = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(openParenToken);
            this.openParenToken = openParenToken;
            var closeParenToken = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(closeParenToken);
            this.closeParenToken = closeParenToken;
        }

        internal override void WriteTo(ObjectWriter writer)
        {
            base.WriteTo(writer);
            writer.WriteValue(this.newKeyword);
            writer.WriteValue(this.openParenToken);
            writer.WriteValue(this.closeParenToken);
        }

        static ConstructorConstraintSyntax()
        {
            ObjectBinder.RegisterTypeReader(typeof(ConstructorConstraintSyntax), r => new ConstructorConstraintSyntax(r));
        }
    }

    /// <summary>Class or struct constraint syntax.</summary>
    internal sealed partial class ClassOrStructConstraintSyntax : TypeParameterConstraintSyntax
    {
        internal readonly SyntaxToken classOrStructKeyword;
        internal readonly SyntaxToken? questionToken;

        internal ClassOrStructConstraintSyntax(SyntaxKind kind, SyntaxToken classOrStructKeyword, SyntaxToken? questionToken, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
            this.SlotCount = 2;
            this.AdjustFlagsAndWidth(classOrStructKeyword);
            this.classOrStructKeyword = classOrStructKeyword;
            if (questionToken != null)
            {
                this.AdjustFlagsAndWidth(questionToken);
                this.questionToken = questionToken;
            }
        }

        internal ClassOrStructConstraintSyntax(SyntaxKind kind, SyntaxToken classOrStructKeyword, SyntaxToken? questionToken, SyntaxFactoryContext context)
          : base(kind)
        {
            this.SetFactoryContext(context);
            this.SlotCount = 2;
            this.AdjustFlagsAndWidth(classOrStructKeyword);
            this.classOrStructKeyword = classOrStructKeyword;
            if (questionToken != null)
            {
                this.AdjustFlagsAndWidth(questionToken);
                this.questionToken = questionToken;
            }
        }

        internal ClassOrStructConstraintSyntax(SyntaxKind kind, SyntaxToken classOrStructKeyword, SyntaxToken? questionToken)
          : base(kind)
        {
            this.SlotCount = 2;
            this.AdjustFlagsAndWidth(classOrStructKeyword);
            this.classOrStructKeyword = classOrStructKeyword;
            if (questionToken != null)
            {
                this.AdjustFlagsAndWidth(questionToken);
                this.questionToken = questionToken;
            }
        }

        /// <summary>Gets the constraint keyword ("class" or "struct").</summary>
        public SyntaxToken ClassOrStructKeyword => this.classOrStructKeyword;
        /// <summary>SyntaxToken representing the question mark.</summary>
        public SyntaxToken? QuestionToken => this.questionToken;

        internal override GreenNode? GetSlot(int index)
            => index switch
            {
                0 => this.classOrStructKeyword,
                1 => this.questionToken,
                _ => null,
            };

        internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new CSharp.Syntax.ClassOrStructConstraintSyntax(this, parent, position);

        public override void Accept(CSharpSyntaxVisitor visitor) => visitor.VisitClassOrStructConstraint(this);
        public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor) => visitor.VisitClassOrStructConstraint(this);

        public ClassOrStructConstraintSyntax Update(SyntaxToken classOrStructKeyword, SyntaxToken questionToken)
        {
            if (classOrStructKeyword != this.ClassOrStructKeyword || questionToken != this.QuestionToken)
            {
                var newNode = SyntaxFactory.ClassOrStructConstraint(this.Kind, classOrStructKeyword, questionToken);
                var diags = GetDiagnostics();
                if (diags?.Length > 0)
                    newNode = newNode.WithDiagnosticsGreen(diags);
                var annotations = GetAnnotations();
                if (annotations?.Length > 0)
                    newNode = newNode.WithAnnotationsGreen(annotations);
                return newNode;
            }

            return this;
        }

        internal override GreenNode SetDiagnostics(DiagnosticInfo[]? diagnostics)
            => new ClassOrStructConstraintSyntax(this.Kind, this.classOrStructKeyword, this.questionToken, diagnostics, GetAnnotations());

        internal override GreenNode SetAnnotations(SyntaxAnnotation[]? annotations)
            => new ClassOrStructConstraintSyntax(this.Kind, this.classOrStructKeyword, this.questionToken, GetDiagnostics(), annotations);

        internal ClassOrStructConstraintSyntax(ObjectReader reader)
          : base(reader)
        {
            this.SlotCount = 2;
            var classOrStructKeyword = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(classOrStructKeyword);
            this.classOrStructKeyword = classOrStructKeyword;
            var questionToken = (SyntaxToken?)reader.ReadValue();
            if (questionToken != null)
            {
                AdjustFlagsAndWidth(questionToken);
                this.questionToken = questionToken;
            }
        }

        internal override void WriteTo(ObjectWriter writer)
        {
            base.WriteTo(writer);
            writer.WriteValue(this.classOrStructKeyword);
            writer.WriteValue(this.questionToken);
        }

        static ClassOrStructConstraintSyntax()
        {
            ObjectBinder.RegisterTypeReader(typeof(ClassOrStructConstraintSyntax), r => new ClassOrStructConstraintSyntax(r));
        }
    }

    /// <summary>Type constraint syntax.</summary>
    internal sealed partial class TypeConstraintSyntax : TypeParameterConstraintSyntax
    {
        internal readonly TypeSyntax type;

        internal TypeConstraintSyntax(SyntaxKind kind, TypeSyntax type, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
            this.SlotCount = 1;
            this.AdjustFlagsAndWidth(type);
            this.type = type;
        }

        internal TypeConstraintSyntax(SyntaxKind kind, TypeSyntax type, SyntaxFactoryContext context)
          : base(kind)
        {
            this.SetFactoryContext(context);
            this.SlotCount = 1;
            this.AdjustFlagsAndWidth(type);
            this.type = type;
        }

        internal TypeConstraintSyntax(SyntaxKind kind, TypeSyntax type)
          : base(kind)
        {
            this.SlotCount = 1;
            this.AdjustFlagsAndWidth(type);
            this.type = type;
        }

        /// <summary>Gets the type syntax.</summary>
        public TypeSyntax Type => this.type;

        internal override GreenNode? GetSlot(int index)
            => index == 0 ? this.type : null;

        internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new CSharp.Syntax.TypeConstraintSyntax(this, parent, position);

        public override void Accept(CSharpSyntaxVisitor visitor) => visitor.VisitTypeConstraint(this);
        public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor) => visitor.VisitTypeConstraint(this);

        public TypeConstraintSyntax Update(TypeSyntax type)
        {
            if (type != this.Type)
            {
                var newNode = SyntaxFactory.TypeConstraint(type);
                var diags = GetDiagnostics();
                if (diags?.Length > 0)
                    newNode = newNode.WithDiagnosticsGreen(diags);
                var annotations = GetAnnotations();
                if (annotations?.Length > 0)
                    newNode = newNode.WithAnnotationsGreen(annotations);
                return newNode;
            }

            return this;
        }

        internal override GreenNode SetDiagnostics(DiagnosticInfo[]? diagnostics)
            => new TypeConstraintSyntax(this.Kind, this.type, diagnostics, GetAnnotations());

        internal override GreenNode SetAnnotations(SyntaxAnnotation[]? annotations)
            => new TypeConstraintSyntax(this.Kind, this.type, GetDiagnostics(), annotations);

        internal TypeConstraintSyntax(ObjectReader reader)
          : base(reader)
        {
            this.SlotCount = 1;
            var type = (TypeSyntax)reader.ReadValue();
            AdjustFlagsAndWidth(type);
            this.type = type;
        }

        internal override void WriteTo(ObjectWriter writer)
        {
            base.WriteTo(writer);
            writer.WriteValue(this.type);
        }

        static TypeConstraintSyntax()
        {
            ObjectBinder.RegisterTypeReader(typeof(TypeConstraintSyntax), r => new TypeConstraintSyntax(r));
        }
    }

    /// <summary>Default constraint syntax.</summary>
    internal sealed partial class DefaultConstraintSyntax : TypeParameterConstraintSyntax
    {
        internal readonly SyntaxToken defaultKeyword;

        internal DefaultConstraintSyntax(SyntaxKind kind, SyntaxToken defaultKeyword, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
            this.SlotCount = 1;
            this.AdjustFlagsAndWidth(defaultKeyword);
            this.defaultKeyword = defaultKeyword;
        }

        internal DefaultConstraintSyntax(SyntaxKind kind, SyntaxToken defaultKeyword, SyntaxFactoryContext context)
          : base(kind)
        {
            this.SetFactoryContext(context);
            this.SlotCount = 1;
            this.AdjustFlagsAndWidth(defaultKeyword);
            this.defaultKeyword = defaultKeyword;
        }

        internal DefaultConstraintSyntax(SyntaxKind kind, SyntaxToken defaultKeyword)
          : base(kind)
        {
            this.SlotCount = 1;
            this.AdjustFlagsAndWidth(defaultKeyword);
            this.defaultKeyword = defaultKeyword;
        }

        /// <summary>Gets the "default" keyword.</summary>
        public SyntaxToken DefaultKeyword => this.defaultKeyword;

        internal override GreenNode? GetSlot(int index)
            => index == 0 ? this.defaultKeyword : null;

        internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new CSharp.Syntax.DefaultConstraintSyntax(this, parent, position);

        public override void Accept(CSharpSyntaxVisitor visitor) => visitor.VisitDefaultConstraint(this);
        public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor) => visitor.VisitDefaultConstraint(this);

        public DefaultConstraintSyntax Update(SyntaxToken defaultKeyword)
        {
            if (defaultKeyword != this.DefaultKeyword)
            {
                var newNode = SyntaxFactory.DefaultConstraint(defaultKeyword);
                var diags = GetDiagnostics();
                if (diags?.Length > 0)
                    newNode = newNode.WithDiagnosticsGreen(diags);
                var annotations = GetAnnotations();
                if (annotations?.Length > 0)
                    newNode = newNode.WithAnnotationsGreen(annotations);
                return newNode;
            }

            return this;
        }

        internal override GreenNode SetDiagnostics(DiagnosticInfo[]? diagnostics)
            => new DefaultConstraintSyntax(this.Kind, this.defaultKeyword, diagnostics, GetAnnotations());

        internal override GreenNode SetAnnotations(SyntaxAnnotation[]? annotations)
            => new DefaultConstraintSyntax(this.Kind, this.defaultKeyword, GetDiagnostics(), annotations);

        internal DefaultConstraintSyntax(ObjectReader reader)
          : base(reader)
        {
            this.SlotCount = 1;
            var defaultKeyword = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(defaultKeyword);
            this.defaultKeyword = defaultKeyword;
        }

        internal override void WriteTo(ObjectWriter writer)
        {
            base.WriteTo(writer);
            writer.WriteValue(this.defaultKeyword);
        }

        static DefaultConstraintSyntax()
        {
            ObjectBinder.RegisterTypeReader(typeof(DefaultConstraintSyntax), r => new DefaultConstraintSyntax(r));
        }
    }

    internal abstract partial class BaseFieldDeclarationSyntax : MemberDeclarationSyntax
    {
        internal BaseFieldDeclarationSyntax(SyntaxKind kind, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
        }

        internal BaseFieldDeclarationSyntax(SyntaxKind kind)
          : base(kind)
        {
        }

        protected BaseFieldDeclarationSyntax(ObjectReader reader)
          : base(reader)
        {
        }

        public abstract VariableDeclarationSyntax Declaration { get; }

        public abstract SyntaxToken SemicolonToken { get; }
    }

    internal sealed partial class FieldDeclarationSyntax : BaseFieldDeclarationSyntax
    {
        internal readonly GreenNode? attributeLists;
        internal readonly GreenNode? modifiers;
        internal readonly VariableDeclarationSyntax declaration;
        internal readonly SyntaxToken semicolonToken;

        internal FieldDeclarationSyntax(SyntaxKind kind, GreenNode? attributeLists, GreenNode? modifiers, VariableDeclarationSyntax declaration, SyntaxToken semicolonToken, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
            this.SlotCount = 4;
            if (attributeLists != null)
            {
                this.AdjustFlagsAndWidth(attributeLists);
                this.attributeLists = attributeLists;
            }
            if (modifiers != null)
            {
                this.AdjustFlagsAndWidth(modifiers);
                this.modifiers = modifiers;
            }
            this.AdjustFlagsAndWidth(declaration);
            this.declaration = declaration;
            this.AdjustFlagsAndWidth(semicolonToken);
            this.semicolonToken = semicolonToken;
        }

        internal FieldDeclarationSyntax(SyntaxKind kind, GreenNode? attributeLists, GreenNode? modifiers, VariableDeclarationSyntax declaration, SyntaxToken semicolonToken, SyntaxFactoryContext context)
          : base(kind)
        {
            this.SetFactoryContext(context);
            this.SlotCount = 4;
            if (attributeLists != null)
            {
                this.AdjustFlagsAndWidth(attributeLists);
                this.attributeLists = attributeLists;
            }
            if (modifiers != null)
            {
                this.AdjustFlagsAndWidth(modifiers);
                this.modifiers = modifiers;
            }
            this.AdjustFlagsAndWidth(declaration);
            this.declaration = declaration;
            this.AdjustFlagsAndWidth(semicolonToken);
            this.semicolonToken = semicolonToken;
        }

        internal FieldDeclarationSyntax(SyntaxKind kind, GreenNode? attributeLists, GreenNode? modifiers, VariableDeclarationSyntax declaration, SyntaxToken semicolonToken)
          : base(kind)
        {
            this.SlotCount = 4;
            if (attributeLists != null)
            {
                this.AdjustFlagsAndWidth(attributeLists);
                this.attributeLists = attributeLists;
            }
            if (modifiers != null)
            {
                this.AdjustFlagsAndWidth(modifiers);
                this.modifiers = modifiers;
            }
            this.AdjustFlagsAndWidth(declaration);
            this.declaration = declaration;
            this.AdjustFlagsAndWidth(semicolonToken);
            this.semicolonToken = semicolonToken;
        }

        public override Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<AttributeListSyntax> AttributeLists => new Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<AttributeListSyntax>(this.attributeLists);
        public override Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SyntaxToken> Modifiers => new Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SyntaxToken>(this.modifiers);
        public override VariableDeclarationSyntax Declaration => this.declaration;
        public override SyntaxToken SemicolonToken => this.semicolonToken;

        internal override GreenNode? GetSlot(int index)
            => index switch
            {
                0 => this.attributeLists,
                1 => this.modifiers,
                2 => this.declaration,
                3 => this.semicolonToken,
                _ => null,
            };

        internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new CSharp.Syntax.FieldDeclarationSyntax(this, parent, position);

        public override void Accept(CSharpSyntaxVisitor visitor) => visitor.VisitFieldDeclaration(this);
        public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor) => visitor.VisitFieldDeclaration(this);

        public FieldDeclarationSyntax Update(Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<AttributeListSyntax> attributeLists, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SyntaxToken> modifiers, VariableDeclarationSyntax declaration, SyntaxToken semicolonToken)
        {
            if (attributeLists != this.AttributeLists || modifiers != this.Modifiers || declaration != this.Declaration || semicolonToken != this.SemicolonToken)
            {
                var newNode = SyntaxFactory.FieldDeclaration(attributeLists, modifiers, declaration, semicolonToken);
                var diags = GetDiagnostics();
                if (diags?.Length > 0)
                    newNode = newNode.WithDiagnosticsGreen(diags);
                var annotations = GetAnnotations();
                if (annotations?.Length > 0)
                    newNode = newNode.WithAnnotationsGreen(annotations);
                return newNode;
            }

            return this;
        }

        internal override GreenNode SetDiagnostics(DiagnosticInfo[]? diagnostics)
            => new FieldDeclarationSyntax(this.Kind, this.attributeLists, this.modifiers, this.declaration, this.semicolonToken, diagnostics, GetAnnotations());

        internal override GreenNode SetAnnotations(SyntaxAnnotation[]? annotations)
            => new FieldDeclarationSyntax(this.Kind, this.attributeLists, this.modifiers, this.declaration, this.semicolonToken, GetDiagnostics(), annotations);

        internal FieldDeclarationSyntax(ObjectReader reader)
          : base(reader)
        {
            this.SlotCount = 4;
            var attributeLists = (GreenNode?)reader.ReadValue();
            if (attributeLists != null)
            {
                AdjustFlagsAndWidth(attributeLists);
                this.attributeLists = attributeLists;
            }
            var modifiers = (GreenNode?)reader.ReadValue();
            if (modifiers != null)
            {
                AdjustFlagsAndWidth(modifiers);
                this.modifiers = modifiers;
            }
            var declaration = (VariableDeclarationSyntax)reader.ReadValue();
            AdjustFlagsAndWidth(declaration);
            this.declaration = declaration;
            var semicolonToken = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(semicolonToken);
            this.semicolonToken = semicolonToken;
        }

        internal override void WriteTo(ObjectWriter writer)
        {
            base.WriteTo(writer);
            writer.WriteValue(this.attributeLists);
            writer.WriteValue(this.modifiers);
            writer.WriteValue(this.declaration);
            writer.WriteValue(this.semicolonToken);
        }

        static FieldDeclarationSyntax()
        {
            ObjectBinder.RegisterTypeReader(typeof(FieldDeclarationSyntax), r => new FieldDeclarationSyntax(r));
        }
    }

    internal sealed partial class EventFieldDeclarationSyntax : BaseFieldDeclarationSyntax
    {
        internal readonly GreenNode? attributeLists;
        internal readonly GreenNode? modifiers;
        internal readonly SyntaxToken eventKeyword;
        internal readonly VariableDeclarationSyntax declaration;
        internal readonly SyntaxToken semicolonToken;

        internal EventFieldDeclarationSyntax(SyntaxKind kind, GreenNode? attributeLists, GreenNode? modifiers, SyntaxToken eventKeyword, VariableDeclarationSyntax declaration, SyntaxToken semicolonToken, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
            this.SlotCount = 5;
            if (attributeLists != null)
            {
                this.AdjustFlagsAndWidth(attributeLists);
                this.attributeLists = attributeLists;
            }
            if (modifiers != null)
            {
                this.AdjustFlagsAndWidth(modifiers);
                this.modifiers = modifiers;
            }
            this.AdjustFlagsAndWidth(eventKeyword);
            this.eventKeyword = eventKeyword;
            this.AdjustFlagsAndWidth(declaration);
            this.declaration = declaration;
            this.AdjustFlagsAndWidth(semicolonToken);
            this.semicolonToken = semicolonToken;
        }

        internal EventFieldDeclarationSyntax(SyntaxKind kind, GreenNode? attributeLists, GreenNode? modifiers, SyntaxToken eventKeyword, VariableDeclarationSyntax declaration, SyntaxToken semicolonToken, SyntaxFactoryContext context)
          : base(kind)
        {
            this.SetFactoryContext(context);
            this.SlotCount = 5;
            if (attributeLists != null)
            {
                this.AdjustFlagsAndWidth(attributeLists);
                this.attributeLists = attributeLists;
            }
            if (modifiers != null)
            {
                this.AdjustFlagsAndWidth(modifiers);
                this.modifiers = modifiers;
            }
            this.AdjustFlagsAndWidth(eventKeyword);
            this.eventKeyword = eventKeyword;
            this.AdjustFlagsAndWidth(declaration);
            this.declaration = declaration;
            this.AdjustFlagsAndWidth(semicolonToken);
            this.semicolonToken = semicolonToken;
        }

        internal EventFieldDeclarationSyntax(SyntaxKind kind, GreenNode? attributeLists, GreenNode? modifiers, SyntaxToken eventKeyword, VariableDeclarationSyntax declaration, SyntaxToken semicolonToken)
          : base(kind)
        {
            this.SlotCount = 5;
            if (attributeLists != null)
            {
                this.AdjustFlagsAndWidth(attributeLists);
                this.attributeLists = attributeLists;
            }
            if (modifiers != null)
            {
                this.AdjustFlagsAndWidth(modifiers);
                this.modifiers = modifiers;
            }
            this.AdjustFlagsAndWidth(eventKeyword);
            this.eventKeyword = eventKeyword;
            this.AdjustFlagsAndWidth(declaration);
            this.declaration = declaration;
            this.AdjustFlagsAndWidth(semicolonToken);
            this.semicolonToken = semicolonToken;
        }

        public override Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<AttributeListSyntax> AttributeLists => new Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<AttributeListSyntax>(this.attributeLists);
        public override Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SyntaxToken> Modifiers => new Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SyntaxToken>(this.modifiers);
        public SyntaxToken EventKeyword => this.eventKeyword;
        public override VariableDeclarationSyntax Declaration => this.declaration;
        public override SyntaxToken SemicolonToken => this.semicolonToken;

        internal override GreenNode? GetSlot(int index)
            => index switch
            {
                0 => this.attributeLists,
                1 => this.modifiers,
                2 => this.eventKeyword,
                3 => this.declaration,
                4 => this.semicolonToken,
                _ => null,
            };

        internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new CSharp.Syntax.EventFieldDeclarationSyntax(this, parent, position);

        public override void Accept(CSharpSyntaxVisitor visitor) => visitor.VisitEventFieldDeclaration(this);
        public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor) => visitor.VisitEventFieldDeclaration(this);

        public EventFieldDeclarationSyntax Update(Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<AttributeListSyntax> attributeLists, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SyntaxToken> modifiers, SyntaxToken eventKeyword, VariableDeclarationSyntax declaration, SyntaxToken semicolonToken)
        {
            if (attributeLists != this.AttributeLists || modifiers != this.Modifiers || eventKeyword != this.EventKeyword || declaration != this.Declaration || semicolonToken != this.SemicolonToken)
            {
                var newNode = SyntaxFactory.EventFieldDeclaration(attributeLists, modifiers, eventKeyword, declaration, semicolonToken);
                var diags = GetDiagnostics();
                if (diags?.Length > 0)
                    newNode = newNode.WithDiagnosticsGreen(diags);
                var annotations = GetAnnotations();
                if (annotations?.Length > 0)
                    newNode = newNode.WithAnnotationsGreen(annotations);
                return newNode;
            }

            return this;
        }

        internal override GreenNode SetDiagnostics(DiagnosticInfo[]? diagnostics)
            => new EventFieldDeclarationSyntax(this.Kind, this.attributeLists, this.modifiers, this.eventKeyword, this.declaration, this.semicolonToken, diagnostics, GetAnnotations());

        internal override GreenNode SetAnnotations(SyntaxAnnotation[]? annotations)
            => new EventFieldDeclarationSyntax(this.Kind, this.attributeLists, this.modifiers, this.eventKeyword, this.declaration, this.semicolonToken, GetDiagnostics(), annotations);

        internal EventFieldDeclarationSyntax(ObjectReader reader)
          : base(reader)
        {
            this.SlotCount = 5;
            var attributeLists = (GreenNode?)reader.ReadValue();
            if (attributeLists != null)
            {
                AdjustFlagsAndWidth(attributeLists);
                this.attributeLists = attributeLists;
            }
            var modifiers = (GreenNode?)reader.ReadValue();
            if (modifiers != null)
            {
                AdjustFlagsAndWidth(modifiers);
                this.modifiers = modifiers;
            }
            var eventKeyword = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(eventKeyword);
            this.eventKeyword = eventKeyword;
            var declaration = (VariableDeclarationSyntax)reader.ReadValue();
            AdjustFlagsAndWidth(declaration);
            this.declaration = declaration;
            var semicolonToken = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(semicolonToken);
            this.semicolonToken = semicolonToken;
        }

        internal override void WriteTo(ObjectWriter writer)
        {
            base.WriteTo(writer);
            writer.WriteValue(this.attributeLists);
            writer.WriteValue(this.modifiers);
            writer.WriteValue(this.eventKeyword);
            writer.WriteValue(this.declaration);
            writer.WriteValue(this.semicolonToken);
        }

        static EventFieldDeclarationSyntax()
        {
            ObjectBinder.RegisterTypeReader(typeof(EventFieldDeclarationSyntax), r => new EventFieldDeclarationSyntax(r));
        }
    }

    internal sealed partial class ExplicitInterfaceSpecifierSyntax : CSharpSyntaxNode
    {
        internal readonly NameSyntax name;
        internal readonly SyntaxToken dotToken;

        internal ExplicitInterfaceSpecifierSyntax(SyntaxKind kind, NameSyntax name, SyntaxToken dotToken, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
            this.SlotCount = 2;
            this.AdjustFlagsAndWidth(name);
            this.name = name;
            this.AdjustFlagsAndWidth(dotToken);
            this.dotToken = dotToken;
        }

        internal ExplicitInterfaceSpecifierSyntax(SyntaxKind kind, NameSyntax name, SyntaxToken dotToken, SyntaxFactoryContext context)
          : base(kind)
        {
            this.SetFactoryContext(context);
            this.SlotCount = 2;
            this.AdjustFlagsAndWidth(name);
            this.name = name;
            this.AdjustFlagsAndWidth(dotToken);
            this.dotToken = dotToken;
        }

        internal ExplicitInterfaceSpecifierSyntax(SyntaxKind kind, NameSyntax name, SyntaxToken dotToken)
          : base(kind)
        {
            this.SlotCount = 2;
            this.AdjustFlagsAndWidth(name);
            this.name = name;
            this.AdjustFlagsAndWidth(dotToken);
            this.dotToken = dotToken;
        }

        public NameSyntax Name => this.name;
        public SyntaxToken DotToken => this.dotToken;

        internal override GreenNode? GetSlot(int index)
            => index switch
            {
                0 => this.name,
                1 => this.dotToken,
                _ => null,
            };

        internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new CSharp.Syntax.ExplicitInterfaceSpecifierSyntax(this, parent, position);

        public override void Accept(CSharpSyntaxVisitor visitor) => visitor.VisitExplicitInterfaceSpecifier(this);
        public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor) => visitor.VisitExplicitInterfaceSpecifier(this);

        public ExplicitInterfaceSpecifierSyntax Update(NameSyntax name, SyntaxToken dotToken)
        {
            if (name != this.Name || dotToken != this.DotToken)
            {
                var newNode = SyntaxFactory.ExplicitInterfaceSpecifier(name, dotToken);
                var diags = GetDiagnostics();
                if (diags?.Length > 0)
                    newNode = newNode.WithDiagnosticsGreen(diags);
                var annotations = GetAnnotations();
                if (annotations?.Length > 0)
                    newNode = newNode.WithAnnotationsGreen(annotations);
                return newNode;
            }

            return this;
        }

        internal override GreenNode SetDiagnostics(DiagnosticInfo[]? diagnostics)
            => new ExplicitInterfaceSpecifierSyntax(this.Kind, this.name, this.dotToken, diagnostics, GetAnnotations());

        internal override GreenNode SetAnnotations(SyntaxAnnotation[]? annotations)
            => new ExplicitInterfaceSpecifierSyntax(this.Kind, this.name, this.dotToken, GetDiagnostics(), annotations);

        internal ExplicitInterfaceSpecifierSyntax(ObjectReader reader)
          : base(reader)
        {
            this.SlotCount = 2;
            var name = (NameSyntax)reader.ReadValue();
            AdjustFlagsAndWidth(name);
            this.name = name;
            var dotToken = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(dotToken);
            this.dotToken = dotToken;
        }

        internal override void WriteTo(ObjectWriter writer)
        {
            base.WriteTo(writer);
            writer.WriteValue(this.name);
            writer.WriteValue(this.dotToken);
        }

        static ExplicitInterfaceSpecifierSyntax()
        {
            ObjectBinder.RegisterTypeReader(typeof(ExplicitInterfaceSpecifierSyntax), r => new ExplicitInterfaceSpecifierSyntax(r));
        }
    }

    /// <summary>Base type for method declaration syntax.</summary>
    internal abstract partial class BaseMethodDeclarationSyntax : MemberDeclarationSyntax
    {
        internal BaseMethodDeclarationSyntax(SyntaxKind kind, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
        }

        internal BaseMethodDeclarationSyntax(SyntaxKind kind)
          : base(kind)
        {
        }

        protected BaseMethodDeclarationSyntax(ObjectReader reader)
          : base(reader)
        {
        }

        /// <summary>Gets the parameter list.</summary>
        public abstract ParameterListSyntax ParameterList { get; }

        public abstract BlockSyntax? Body { get; }

        public abstract ArrowExpressionClauseSyntax? ExpressionBody { get; }

        /// <summary>Gets the optional semicolon token.</summary>
        public abstract SyntaxToken? SemicolonToken { get; }
    }

    /// <summary>Method declaration syntax.</summary>
    internal sealed partial class MethodDeclarationSyntax : BaseMethodDeclarationSyntax
    {
        internal readonly GreenNode? attributeLists;
        internal readonly GreenNode? modifiers;
        internal readonly TypeSyntax returnType;
        internal readonly ExplicitInterfaceSpecifierSyntax? explicitInterfaceSpecifier;
        internal readonly SyntaxToken identifier;
        internal readonly TypeParameterListSyntax? typeParameterList;
        internal readonly ParameterListSyntax parameterList;
        internal readonly GreenNode? constraintClauses;
        internal readonly BlockSyntax? body;
        internal readonly ArrowExpressionClauseSyntax? expressionBody;
        internal readonly SyntaxToken? semicolonToken;

        internal MethodDeclarationSyntax(SyntaxKind kind, GreenNode? attributeLists, GreenNode? modifiers, TypeSyntax returnType, ExplicitInterfaceSpecifierSyntax? explicitInterfaceSpecifier, SyntaxToken identifier, TypeParameterListSyntax? typeParameterList, ParameterListSyntax parameterList, GreenNode? constraintClauses, BlockSyntax? body, ArrowExpressionClauseSyntax? expressionBody, SyntaxToken? semicolonToken, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
            this.SlotCount = 11;
            if (attributeLists != null)
            {
                this.AdjustFlagsAndWidth(attributeLists);
                this.attributeLists = attributeLists;
            }
            if (modifiers != null)
            {
                this.AdjustFlagsAndWidth(modifiers);
                this.modifiers = modifiers;
            }
            this.AdjustFlagsAndWidth(returnType);
            this.returnType = returnType;
            if (explicitInterfaceSpecifier != null)
            {
                this.AdjustFlagsAndWidth(explicitInterfaceSpecifier);
                this.explicitInterfaceSpecifier = explicitInterfaceSpecifier;
            }
            this.AdjustFlagsAndWidth(identifier);
            this.identifier = identifier;
            if (typeParameterList != null)
            {
                this.AdjustFlagsAndWidth(typeParameterList);
                this.typeParameterList = typeParameterList;
            }
            this.AdjustFlagsAndWidth(parameterList);
            this.parameterList = parameterList;
            if (constraintClauses != null)
            {
                this.AdjustFlagsAndWidth(constraintClauses);
                this.constraintClauses = constraintClauses;
            }
            if (body != null)
            {
                this.AdjustFlagsAndWidth(body);
                this.body = body;
            }
            if (expressionBody != null)
            {
                this.AdjustFlagsAndWidth(expressionBody);
                this.expressionBody = expressionBody;
            }
            if (semicolonToken != null)
            {
                this.AdjustFlagsAndWidth(semicolonToken);
                this.semicolonToken = semicolonToken;
            }
        }

        internal MethodDeclarationSyntax(SyntaxKind kind, GreenNode? attributeLists, GreenNode? modifiers, TypeSyntax returnType, ExplicitInterfaceSpecifierSyntax? explicitInterfaceSpecifier, SyntaxToken identifier, TypeParameterListSyntax? typeParameterList, ParameterListSyntax parameterList, GreenNode? constraintClauses, BlockSyntax? body, ArrowExpressionClauseSyntax? expressionBody, SyntaxToken? semicolonToken, SyntaxFactoryContext context)
          : base(kind)
        {
            this.SetFactoryContext(context);
            this.SlotCount = 11;
            if (attributeLists != null)
            {
                this.AdjustFlagsAndWidth(attributeLists);
                this.attributeLists = attributeLists;
            }
            if (modifiers != null)
            {
                this.AdjustFlagsAndWidth(modifiers);
                this.modifiers = modifiers;
            }
            this.AdjustFlagsAndWidth(returnType);
            this.returnType = returnType;
            if (explicitInterfaceSpecifier != null)
            {
                this.AdjustFlagsAndWidth(explicitInterfaceSpecifier);
                this.explicitInterfaceSpecifier = explicitInterfaceSpecifier;
            }
            this.AdjustFlagsAndWidth(identifier);
            this.identifier = identifier;
            if (typeParameterList != null)
            {
                this.AdjustFlagsAndWidth(typeParameterList);
                this.typeParameterList = typeParameterList;
            }
            this.AdjustFlagsAndWidth(parameterList);
            this.parameterList = parameterList;
            if (constraintClauses != null)
            {
                this.AdjustFlagsAndWidth(constraintClauses);
                this.constraintClauses = constraintClauses;
            }
            if (body != null)
            {
                this.AdjustFlagsAndWidth(body);
                this.body = body;
            }
            if (expressionBody != null)
            {
                this.AdjustFlagsAndWidth(expressionBody);
                this.expressionBody = expressionBody;
            }
            if (semicolonToken != null)
            {
                this.AdjustFlagsAndWidth(semicolonToken);
                this.semicolonToken = semicolonToken;
            }
        }

        internal MethodDeclarationSyntax(SyntaxKind kind, GreenNode? attributeLists, GreenNode? modifiers, TypeSyntax returnType, ExplicitInterfaceSpecifierSyntax? explicitInterfaceSpecifier, SyntaxToken identifier, TypeParameterListSyntax? typeParameterList, ParameterListSyntax parameterList, GreenNode? constraintClauses, BlockSyntax? body, ArrowExpressionClauseSyntax? expressionBody, SyntaxToken? semicolonToken)
          : base(kind)
        {
            this.SlotCount = 11;
            if (attributeLists != null)
            {
                this.AdjustFlagsAndWidth(attributeLists);
                this.attributeLists = attributeLists;
            }
            if (modifiers != null)
            {
                this.AdjustFlagsAndWidth(modifiers);
                this.modifiers = modifiers;
            }
            this.AdjustFlagsAndWidth(returnType);
            this.returnType = returnType;
            if (explicitInterfaceSpecifier != null)
            {
                this.AdjustFlagsAndWidth(explicitInterfaceSpecifier);
                this.explicitInterfaceSpecifier = explicitInterfaceSpecifier;
            }
            this.AdjustFlagsAndWidth(identifier);
            this.identifier = identifier;
            if (typeParameterList != null)
            {
                this.AdjustFlagsAndWidth(typeParameterList);
                this.typeParameterList = typeParameterList;
            }
            this.AdjustFlagsAndWidth(parameterList);
            this.parameterList = parameterList;
            if (constraintClauses != null)
            {
                this.AdjustFlagsAndWidth(constraintClauses);
                this.constraintClauses = constraintClauses;
            }
            if (body != null)
            {
                this.AdjustFlagsAndWidth(body);
                this.body = body;
            }
            if (expressionBody != null)
            {
                this.AdjustFlagsAndWidth(expressionBody);
                this.expressionBody = expressionBody;
            }
            if (semicolonToken != null)
            {
                this.AdjustFlagsAndWidth(semicolonToken);
                this.semicolonToken = semicolonToken;
            }
        }

        public override Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<AttributeListSyntax> AttributeLists => new Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<AttributeListSyntax>(this.attributeLists);
        public override Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SyntaxToken> Modifiers => new Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SyntaxToken>(this.modifiers);
        /// <summary>Gets the return type syntax.</summary>
        public TypeSyntax ReturnType => this.returnType;
        public ExplicitInterfaceSpecifierSyntax? ExplicitInterfaceSpecifier => this.explicitInterfaceSpecifier;
        /// <summary>Gets the identifier.</summary>
        public SyntaxToken Identifier => this.identifier;
        public TypeParameterListSyntax? TypeParameterList => this.typeParameterList;
        public override ParameterListSyntax ParameterList => this.parameterList;
        /// <summary>Gets the constraint clause list.</summary>
        public Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<TypeParameterConstraintClauseSyntax> ConstraintClauses => new Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<TypeParameterConstraintClauseSyntax>(this.constraintClauses);
        public override BlockSyntax? Body => this.body;
        public override ArrowExpressionClauseSyntax? ExpressionBody => this.expressionBody;
        /// <summary>Gets the optional semicolon token.</summary>
        public override SyntaxToken? SemicolonToken => this.semicolonToken;

        internal override GreenNode? GetSlot(int index)
            => index switch
            {
                0 => this.attributeLists,
                1 => this.modifiers,
                2 => this.returnType,
                3 => this.explicitInterfaceSpecifier,
                4 => this.identifier,
                5 => this.typeParameterList,
                6 => this.parameterList,
                7 => this.constraintClauses,
                8 => this.body,
                9 => this.expressionBody,
                10 => this.semicolonToken,
                _ => null,
            };

        internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new CSharp.Syntax.MethodDeclarationSyntax(this, parent, position);

        public override void Accept(CSharpSyntaxVisitor visitor) => visitor.VisitMethodDeclaration(this);
        public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor) => visitor.VisitMethodDeclaration(this);

        public MethodDeclarationSyntax Update(Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<AttributeListSyntax> attributeLists, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SyntaxToken> modifiers, TypeSyntax returnType, ExplicitInterfaceSpecifierSyntax explicitInterfaceSpecifier, SyntaxToken identifier, TypeParameterListSyntax typeParameterList, ParameterListSyntax parameterList, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<TypeParameterConstraintClauseSyntax> constraintClauses, BlockSyntax body, ArrowExpressionClauseSyntax expressionBody, SyntaxToken semicolonToken)
        {
            if (attributeLists != this.AttributeLists || modifiers != this.Modifiers || returnType != this.ReturnType || explicitInterfaceSpecifier != this.ExplicitInterfaceSpecifier || identifier != this.Identifier || typeParameterList != this.TypeParameterList || parameterList != this.ParameterList || constraintClauses != this.ConstraintClauses || body != this.Body || expressionBody != this.ExpressionBody || semicolonToken != this.SemicolonToken)
            {
                var newNode = SyntaxFactory.MethodDeclaration(attributeLists, modifiers, returnType, explicitInterfaceSpecifier, identifier, typeParameterList, parameterList, constraintClauses, body, expressionBody, semicolonToken);
                var diags = GetDiagnostics();
                if (diags?.Length > 0)
                    newNode = newNode.WithDiagnosticsGreen(diags);
                var annotations = GetAnnotations();
                if (annotations?.Length > 0)
                    newNode = newNode.WithAnnotationsGreen(annotations);
                return newNode;
            }

            return this;
        }

        internal override GreenNode SetDiagnostics(DiagnosticInfo[]? diagnostics)
            => new MethodDeclarationSyntax(this.Kind, this.attributeLists, this.modifiers, this.returnType, this.explicitInterfaceSpecifier, this.identifier, this.typeParameterList, this.parameterList, this.constraintClauses, this.body, this.expressionBody, this.semicolonToken, diagnostics, GetAnnotations());

        internal override GreenNode SetAnnotations(SyntaxAnnotation[]? annotations)
            => new MethodDeclarationSyntax(this.Kind, this.attributeLists, this.modifiers, this.returnType, this.explicitInterfaceSpecifier, this.identifier, this.typeParameterList, this.parameterList, this.constraintClauses, this.body, this.expressionBody, this.semicolonToken, GetDiagnostics(), annotations);

        internal MethodDeclarationSyntax(ObjectReader reader)
          : base(reader)
        {
            this.SlotCount = 11;
            var attributeLists = (GreenNode?)reader.ReadValue();
            if (attributeLists != null)
            {
                AdjustFlagsAndWidth(attributeLists);
                this.attributeLists = attributeLists;
            }
            var modifiers = (GreenNode?)reader.ReadValue();
            if (modifiers != null)
            {
                AdjustFlagsAndWidth(modifiers);
                this.modifiers = modifiers;
            }
            var returnType = (TypeSyntax)reader.ReadValue();
            AdjustFlagsAndWidth(returnType);
            this.returnType = returnType;
            var explicitInterfaceSpecifier = (ExplicitInterfaceSpecifierSyntax?)reader.ReadValue();
            if (explicitInterfaceSpecifier != null)
            {
                AdjustFlagsAndWidth(explicitInterfaceSpecifier);
                this.explicitInterfaceSpecifier = explicitInterfaceSpecifier;
            }
            var identifier = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(identifier);
            this.identifier = identifier;
            var typeParameterList = (TypeParameterListSyntax?)reader.ReadValue();
            if (typeParameterList != null)
            {
                AdjustFlagsAndWidth(typeParameterList);
                this.typeParameterList = typeParameterList;
            }
            var parameterList = (ParameterListSyntax)reader.ReadValue();
            AdjustFlagsAndWidth(parameterList);
            this.parameterList = parameterList;
            var constraintClauses = (GreenNode?)reader.ReadValue();
            if (constraintClauses != null)
            {
                AdjustFlagsAndWidth(constraintClauses);
                this.constraintClauses = constraintClauses;
            }
            var body = (BlockSyntax?)reader.ReadValue();
            if (body != null)
            {
                AdjustFlagsAndWidth(body);
                this.body = body;
            }
            var expressionBody = (ArrowExpressionClauseSyntax?)reader.ReadValue();
            if (expressionBody != null)
            {
                AdjustFlagsAndWidth(expressionBody);
                this.expressionBody = expressionBody;
            }
            var semicolonToken = (SyntaxToken?)reader.ReadValue();
            if (semicolonToken != null)
            {
                AdjustFlagsAndWidth(semicolonToken);
                this.semicolonToken = semicolonToken;
            }
        }

        internal override void WriteTo(ObjectWriter writer)
        {
            base.WriteTo(writer);
            writer.WriteValue(this.attributeLists);
            writer.WriteValue(this.modifiers);
            writer.WriteValue(this.returnType);
            writer.WriteValue(this.explicitInterfaceSpecifier);
            writer.WriteValue(this.identifier);
            writer.WriteValue(this.typeParameterList);
            writer.WriteValue(this.parameterList);
            writer.WriteValue(this.constraintClauses);
            writer.WriteValue(this.body);
            writer.WriteValue(this.expressionBody);
            writer.WriteValue(this.semicolonToken);
        }

        static MethodDeclarationSyntax()
        {
            ObjectBinder.RegisterTypeReader(typeof(MethodDeclarationSyntax), r => new MethodDeclarationSyntax(r));
        }
    }

    /// <summary>Operator declaration syntax.</summary>
    internal sealed partial class OperatorDeclarationSyntax : BaseMethodDeclarationSyntax
    {
        internal readonly GreenNode? attributeLists;
        internal readonly GreenNode? modifiers;
        internal readonly TypeSyntax returnType;
        internal readonly SyntaxToken operatorKeyword;
        internal readonly SyntaxToken operatorToken;
        internal readonly ParameterListSyntax parameterList;
        internal readonly BlockSyntax? body;
        internal readonly ArrowExpressionClauseSyntax? expressionBody;
        internal readonly SyntaxToken? semicolonToken;

        internal OperatorDeclarationSyntax(SyntaxKind kind, GreenNode? attributeLists, GreenNode? modifiers, TypeSyntax returnType, SyntaxToken operatorKeyword, SyntaxToken operatorToken, ParameterListSyntax parameterList, BlockSyntax? body, ArrowExpressionClauseSyntax? expressionBody, SyntaxToken? semicolonToken, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
            this.SlotCount = 9;
            if (attributeLists != null)
            {
                this.AdjustFlagsAndWidth(attributeLists);
                this.attributeLists = attributeLists;
            }
            if (modifiers != null)
            {
                this.AdjustFlagsAndWidth(modifiers);
                this.modifiers = modifiers;
            }
            this.AdjustFlagsAndWidth(returnType);
            this.returnType = returnType;
            this.AdjustFlagsAndWidth(operatorKeyword);
            this.operatorKeyword = operatorKeyword;
            this.AdjustFlagsAndWidth(operatorToken);
            this.operatorToken = operatorToken;
            this.AdjustFlagsAndWidth(parameterList);
            this.parameterList = parameterList;
            if (body != null)
            {
                this.AdjustFlagsAndWidth(body);
                this.body = body;
            }
            if (expressionBody != null)
            {
                this.AdjustFlagsAndWidth(expressionBody);
                this.expressionBody = expressionBody;
            }
            if (semicolonToken != null)
            {
                this.AdjustFlagsAndWidth(semicolonToken);
                this.semicolonToken = semicolonToken;
            }
        }

        internal OperatorDeclarationSyntax(SyntaxKind kind, GreenNode? attributeLists, GreenNode? modifiers, TypeSyntax returnType, SyntaxToken operatorKeyword, SyntaxToken operatorToken, ParameterListSyntax parameterList, BlockSyntax? body, ArrowExpressionClauseSyntax? expressionBody, SyntaxToken? semicolonToken, SyntaxFactoryContext context)
          : base(kind)
        {
            this.SetFactoryContext(context);
            this.SlotCount = 9;
            if (attributeLists != null)
            {
                this.AdjustFlagsAndWidth(attributeLists);
                this.attributeLists = attributeLists;
            }
            if (modifiers != null)
            {
                this.AdjustFlagsAndWidth(modifiers);
                this.modifiers = modifiers;
            }
            this.AdjustFlagsAndWidth(returnType);
            this.returnType = returnType;
            this.AdjustFlagsAndWidth(operatorKeyword);
            this.operatorKeyword = operatorKeyword;
            this.AdjustFlagsAndWidth(operatorToken);
            this.operatorToken = operatorToken;
            this.AdjustFlagsAndWidth(parameterList);
            this.parameterList = parameterList;
            if (body != null)
            {
                this.AdjustFlagsAndWidth(body);
                this.body = body;
            }
            if (expressionBody != null)
            {
                this.AdjustFlagsAndWidth(expressionBody);
                this.expressionBody = expressionBody;
            }
            if (semicolonToken != null)
            {
                this.AdjustFlagsAndWidth(semicolonToken);
                this.semicolonToken = semicolonToken;
            }
        }

        internal OperatorDeclarationSyntax(SyntaxKind kind, GreenNode? attributeLists, GreenNode? modifiers, TypeSyntax returnType, SyntaxToken operatorKeyword, SyntaxToken operatorToken, ParameterListSyntax parameterList, BlockSyntax? body, ArrowExpressionClauseSyntax? expressionBody, SyntaxToken? semicolonToken)
          : base(kind)
        {
            this.SlotCount = 9;
            if (attributeLists != null)
            {
                this.AdjustFlagsAndWidth(attributeLists);
                this.attributeLists = attributeLists;
            }
            if (modifiers != null)
            {
                this.AdjustFlagsAndWidth(modifiers);
                this.modifiers = modifiers;
            }
            this.AdjustFlagsAndWidth(returnType);
            this.returnType = returnType;
            this.AdjustFlagsAndWidth(operatorKeyword);
            this.operatorKeyword = operatorKeyword;
            this.AdjustFlagsAndWidth(operatorToken);
            this.operatorToken = operatorToken;
            this.AdjustFlagsAndWidth(parameterList);
            this.parameterList = parameterList;
            if (body != null)
            {
                this.AdjustFlagsAndWidth(body);
                this.body = body;
            }
            if (expressionBody != null)
            {
                this.AdjustFlagsAndWidth(expressionBody);
                this.expressionBody = expressionBody;
            }
            if (semicolonToken != null)
            {
                this.AdjustFlagsAndWidth(semicolonToken);
                this.semicolonToken = semicolonToken;
            }
        }

        public override Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<AttributeListSyntax> AttributeLists => new Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<AttributeListSyntax>(this.attributeLists);
        public override Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SyntaxToken> Modifiers => new Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SyntaxToken>(this.modifiers);
        /// <summary>Gets the return type.</summary>
        public TypeSyntax ReturnType => this.returnType;
        /// <summary>Gets the "operator" keyword.</summary>
        public SyntaxToken OperatorKeyword => this.operatorKeyword;
        /// <summary>Gets the operator token.</summary>
        public SyntaxToken OperatorToken => this.operatorToken;
        public override ParameterListSyntax ParameterList => this.parameterList;
        public override BlockSyntax? Body => this.body;
        public override ArrowExpressionClauseSyntax? ExpressionBody => this.expressionBody;
        /// <summary>Gets the optional semicolon token.</summary>
        public override SyntaxToken? SemicolonToken => this.semicolonToken;

        internal override GreenNode? GetSlot(int index)
            => index switch
            {
                0 => this.attributeLists,
                1 => this.modifiers,
                2 => this.returnType,
                3 => this.operatorKeyword,
                4 => this.operatorToken,
                5 => this.parameterList,
                6 => this.body,
                7 => this.expressionBody,
                8 => this.semicolonToken,
                _ => null,
            };

        internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new CSharp.Syntax.OperatorDeclarationSyntax(this, parent, position);

        public override void Accept(CSharpSyntaxVisitor visitor) => visitor.VisitOperatorDeclaration(this);
        public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor) => visitor.VisitOperatorDeclaration(this);

        public OperatorDeclarationSyntax Update(Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<AttributeListSyntax> attributeLists, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SyntaxToken> modifiers, TypeSyntax returnType, SyntaxToken operatorKeyword, SyntaxToken operatorToken, ParameterListSyntax parameterList, BlockSyntax body, ArrowExpressionClauseSyntax expressionBody, SyntaxToken semicolonToken)
        {
            if (attributeLists != this.AttributeLists || modifiers != this.Modifiers || returnType != this.ReturnType || operatorKeyword != this.OperatorKeyword || operatorToken != this.OperatorToken || parameterList != this.ParameterList || body != this.Body || expressionBody != this.ExpressionBody || semicolonToken != this.SemicolonToken)
            {
                var newNode = SyntaxFactory.OperatorDeclaration(attributeLists, modifiers, returnType, operatorKeyword, operatorToken, parameterList, body, expressionBody, semicolonToken);
                var diags = GetDiagnostics();
                if (diags?.Length > 0)
                    newNode = newNode.WithDiagnosticsGreen(diags);
                var annotations = GetAnnotations();
                if (annotations?.Length > 0)
                    newNode = newNode.WithAnnotationsGreen(annotations);
                return newNode;
            }

            return this;
        }

        internal override GreenNode SetDiagnostics(DiagnosticInfo[]? diagnostics)
            => new OperatorDeclarationSyntax(this.Kind, this.attributeLists, this.modifiers, this.returnType, this.operatorKeyword, this.operatorToken, this.parameterList, this.body, this.expressionBody, this.semicolonToken, diagnostics, GetAnnotations());

        internal override GreenNode SetAnnotations(SyntaxAnnotation[]? annotations)
            => new OperatorDeclarationSyntax(this.Kind, this.attributeLists, this.modifiers, this.returnType, this.operatorKeyword, this.operatorToken, this.parameterList, this.body, this.expressionBody, this.semicolonToken, GetDiagnostics(), annotations);

        internal OperatorDeclarationSyntax(ObjectReader reader)
          : base(reader)
        {
            this.SlotCount = 9;
            var attributeLists = (GreenNode?)reader.ReadValue();
            if (attributeLists != null)
            {
                AdjustFlagsAndWidth(attributeLists);
                this.attributeLists = attributeLists;
            }
            var modifiers = (GreenNode?)reader.ReadValue();
            if (modifiers != null)
            {
                AdjustFlagsAndWidth(modifiers);
                this.modifiers = modifiers;
            }
            var returnType = (TypeSyntax)reader.ReadValue();
            AdjustFlagsAndWidth(returnType);
            this.returnType = returnType;
            var operatorKeyword = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(operatorKeyword);
            this.operatorKeyword = operatorKeyword;
            var operatorToken = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(operatorToken);
            this.operatorToken = operatorToken;
            var parameterList = (ParameterListSyntax)reader.ReadValue();
            AdjustFlagsAndWidth(parameterList);
            this.parameterList = parameterList;
            var body = (BlockSyntax?)reader.ReadValue();
            if (body != null)
            {
                AdjustFlagsAndWidth(body);
                this.body = body;
            }
            var expressionBody = (ArrowExpressionClauseSyntax?)reader.ReadValue();
            if (expressionBody != null)
            {
                AdjustFlagsAndWidth(expressionBody);
                this.expressionBody = expressionBody;
            }
            var semicolonToken = (SyntaxToken?)reader.ReadValue();
            if (semicolonToken != null)
            {
                AdjustFlagsAndWidth(semicolonToken);
                this.semicolonToken = semicolonToken;
            }
        }

        internal override void WriteTo(ObjectWriter writer)
        {
            base.WriteTo(writer);
            writer.WriteValue(this.attributeLists);
            writer.WriteValue(this.modifiers);
            writer.WriteValue(this.returnType);
            writer.WriteValue(this.operatorKeyword);
            writer.WriteValue(this.operatorToken);
            writer.WriteValue(this.parameterList);
            writer.WriteValue(this.body);
            writer.WriteValue(this.expressionBody);
            writer.WriteValue(this.semicolonToken);
        }

        static OperatorDeclarationSyntax()
        {
            ObjectBinder.RegisterTypeReader(typeof(OperatorDeclarationSyntax), r => new OperatorDeclarationSyntax(r));
        }
    }

    /// <summary>Conversion operator declaration syntax.</summary>
    internal sealed partial class ConversionOperatorDeclarationSyntax : BaseMethodDeclarationSyntax
    {
        internal readonly GreenNode? attributeLists;
        internal readonly GreenNode? modifiers;
        internal readonly SyntaxToken implicitOrExplicitKeyword;
        internal readonly SyntaxToken operatorKeyword;
        internal readonly TypeSyntax type;
        internal readonly ParameterListSyntax parameterList;
        internal readonly BlockSyntax? body;
        internal readonly ArrowExpressionClauseSyntax? expressionBody;
        internal readonly SyntaxToken? semicolonToken;

        internal ConversionOperatorDeclarationSyntax(SyntaxKind kind, GreenNode? attributeLists, GreenNode? modifiers, SyntaxToken implicitOrExplicitKeyword, SyntaxToken operatorKeyword, TypeSyntax type, ParameterListSyntax parameterList, BlockSyntax? body, ArrowExpressionClauseSyntax? expressionBody, SyntaxToken? semicolonToken, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
            this.SlotCount = 9;
            if (attributeLists != null)
            {
                this.AdjustFlagsAndWidth(attributeLists);
                this.attributeLists = attributeLists;
            }
            if (modifiers != null)
            {
                this.AdjustFlagsAndWidth(modifiers);
                this.modifiers = modifiers;
            }
            this.AdjustFlagsAndWidth(implicitOrExplicitKeyword);
            this.implicitOrExplicitKeyword = implicitOrExplicitKeyword;
            this.AdjustFlagsAndWidth(operatorKeyword);
            this.operatorKeyword = operatorKeyword;
            this.AdjustFlagsAndWidth(type);
            this.type = type;
            this.AdjustFlagsAndWidth(parameterList);
            this.parameterList = parameterList;
            if (body != null)
            {
                this.AdjustFlagsAndWidth(body);
                this.body = body;
            }
            if (expressionBody != null)
            {
                this.AdjustFlagsAndWidth(expressionBody);
                this.expressionBody = expressionBody;
            }
            if (semicolonToken != null)
            {
                this.AdjustFlagsAndWidth(semicolonToken);
                this.semicolonToken = semicolonToken;
            }
        }

        internal ConversionOperatorDeclarationSyntax(SyntaxKind kind, GreenNode? attributeLists, GreenNode? modifiers, SyntaxToken implicitOrExplicitKeyword, SyntaxToken operatorKeyword, TypeSyntax type, ParameterListSyntax parameterList, BlockSyntax? body, ArrowExpressionClauseSyntax? expressionBody, SyntaxToken? semicolonToken, SyntaxFactoryContext context)
          : base(kind)
        {
            this.SetFactoryContext(context);
            this.SlotCount = 9;
            if (attributeLists != null)
            {
                this.AdjustFlagsAndWidth(attributeLists);
                this.attributeLists = attributeLists;
            }
            if (modifiers != null)
            {
                this.AdjustFlagsAndWidth(modifiers);
                this.modifiers = modifiers;
            }
            this.AdjustFlagsAndWidth(implicitOrExplicitKeyword);
            this.implicitOrExplicitKeyword = implicitOrExplicitKeyword;
            this.AdjustFlagsAndWidth(operatorKeyword);
            this.operatorKeyword = operatorKeyword;
            this.AdjustFlagsAndWidth(type);
            this.type = type;
            this.AdjustFlagsAndWidth(parameterList);
            this.parameterList = parameterList;
            if (body != null)
            {
                this.AdjustFlagsAndWidth(body);
                this.body = body;
            }
            if (expressionBody != null)
            {
                this.AdjustFlagsAndWidth(expressionBody);
                this.expressionBody = expressionBody;
            }
            if (semicolonToken != null)
            {
                this.AdjustFlagsAndWidth(semicolonToken);
                this.semicolonToken = semicolonToken;
            }
        }

        internal ConversionOperatorDeclarationSyntax(SyntaxKind kind, GreenNode? attributeLists, GreenNode? modifiers, SyntaxToken implicitOrExplicitKeyword, SyntaxToken operatorKeyword, TypeSyntax type, ParameterListSyntax parameterList, BlockSyntax? body, ArrowExpressionClauseSyntax? expressionBody, SyntaxToken? semicolonToken)
          : base(kind)
        {
            this.SlotCount = 9;
            if (attributeLists != null)
            {
                this.AdjustFlagsAndWidth(attributeLists);
                this.attributeLists = attributeLists;
            }
            if (modifiers != null)
            {
                this.AdjustFlagsAndWidth(modifiers);
                this.modifiers = modifiers;
            }
            this.AdjustFlagsAndWidth(implicitOrExplicitKeyword);
            this.implicitOrExplicitKeyword = implicitOrExplicitKeyword;
            this.AdjustFlagsAndWidth(operatorKeyword);
            this.operatorKeyword = operatorKeyword;
            this.AdjustFlagsAndWidth(type);
            this.type = type;
            this.AdjustFlagsAndWidth(parameterList);
            this.parameterList = parameterList;
            if (body != null)
            {
                this.AdjustFlagsAndWidth(body);
                this.body = body;
            }
            if (expressionBody != null)
            {
                this.AdjustFlagsAndWidth(expressionBody);
                this.expressionBody = expressionBody;
            }
            if (semicolonToken != null)
            {
                this.AdjustFlagsAndWidth(semicolonToken);
                this.semicolonToken = semicolonToken;
            }
        }

        public override Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<AttributeListSyntax> AttributeLists => new Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<AttributeListSyntax>(this.attributeLists);
        public override Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SyntaxToken> Modifiers => new Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SyntaxToken>(this.modifiers);
        /// <summary>Gets the "implicit" or "explicit" token.</summary>
        public SyntaxToken ImplicitOrExplicitKeyword => this.implicitOrExplicitKeyword;
        /// <summary>Gets the "operator" token.</summary>
        public SyntaxToken OperatorKeyword => this.operatorKeyword;
        /// <summary>Gets the type.</summary>
        public TypeSyntax Type => this.type;
        public override ParameterListSyntax ParameterList => this.parameterList;
        public override BlockSyntax? Body => this.body;
        public override ArrowExpressionClauseSyntax? ExpressionBody => this.expressionBody;
        /// <summary>Gets the optional semicolon token.</summary>
        public override SyntaxToken? SemicolonToken => this.semicolonToken;

        internal override GreenNode? GetSlot(int index)
            => index switch
            {
                0 => this.attributeLists,
                1 => this.modifiers,
                2 => this.implicitOrExplicitKeyword,
                3 => this.operatorKeyword,
                4 => this.type,
                5 => this.parameterList,
                6 => this.body,
                7 => this.expressionBody,
                8 => this.semicolonToken,
                _ => null,
            };

        internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new CSharp.Syntax.ConversionOperatorDeclarationSyntax(this, parent, position);

        public override void Accept(CSharpSyntaxVisitor visitor) => visitor.VisitConversionOperatorDeclaration(this);
        public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor) => visitor.VisitConversionOperatorDeclaration(this);

        public ConversionOperatorDeclarationSyntax Update(Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<AttributeListSyntax> attributeLists, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SyntaxToken> modifiers, SyntaxToken implicitOrExplicitKeyword, SyntaxToken operatorKeyword, TypeSyntax type, ParameterListSyntax parameterList, BlockSyntax body, ArrowExpressionClauseSyntax expressionBody, SyntaxToken semicolonToken)
        {
            if (attributeLists != this.AttributeLists || modifiers != this.Modifiers || implicitOrExplicitKeyword != this.ImplicitOrExplicitKeyword || operatorKeyword != this.OperatorKeyword || type != this.Type || parameterList != this.ParameterList || body != this.Body || expressionBody != this.ExpressionBody || semicolonToken != this.SemicolonToken)
            {
                var newNode = SyntaxFactory.ConversionOperatorDeclaration(attributeLists, modifiers, implicitOrExplicitKeyword, operatorKeyword, type, parameterList, body, expressionBody, semicolonToken);
                var diags = GetDiagnostics();
                if (diags?.Length > 0)
                    newNode = newNode.WithDiagnosticsGreen(diags);
                var annotations = GetAnnotations();
                if (annotations?.Length > 0)
                    newNode = newNode.WithAnnotationsGreen(annotations);
                return newNode;
            }

            return this;
        }

        internal override GreenNode SetDiagnostics(DiagnosticInfo[]? diagnostics)
            => new ConversionOperatorDeclarationSyntax(this.Kind, this.attributeLists, this.modifiers, this.implicitOrExplicitKeyword, this.operatorKeyword, this.type, this.parameterList, this.body, this.expressionBody, this.semicolonToken, diagnostics, GetAnnotations());

        internal override GreenNode SetAnnotations(SyntaxAnnotation[]? annotations)
            => new ConversionOperatorDeclarationSyntax(this.Kind, this.attributeLists, this.modifiers, this.implicitOrExplicitKeyword, this.operatorKeyword, this.type, this.parameterList, this.body, this.expressionBody, this.semicolonToken, GetDiagnostics(), annotations);

        internal ConversionOperatorDeclarationSyntax(ObjectReader reader)
          : base(reader)
        {
            this.SlotCount = 9;
            var attributeLists = (GreenNode?)reader.ReadValue();
            if (attributeLists != null)
            {
                AdjustFlagsAndWidth(attributeLists);
                this.attributeLists = attributeLists;
            }
            var modifiers = (GreenNode?)reader.ReadValue();
            if (modifiers != null)
            {
                AdjustFlagsAndWidth(modifiers);
                this.modifiers = modifiers;
            }
            var implicitOrExplicitKeyword = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(implicitOrExplicitKeyword);
            this.implicitOrExplicitKeyword = implicitOrExplicitKeyword;
            var operatorKeyword = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(operatorKeyword);
            this.operatorKeyword = operatorKeyword;
            var type = (TypeSyntax)reader.ReadValue();
            AdjustFlagsAndWidth(type);
            this.type = type;
            var parameterList = (ParameterListSyntax)reader.ReadValue();
            AdjustFlagsAndWidth(parameterList);
            this.parameterList = parameterList;
            var body = (BlockSyntax?)reader.ReadValue();
            if (body != null)
            {
                AdjustFlagsAndWidth(body);
                this.body = body;
            }
            var expressionBody = (ArrowExpressionClauseSyntax?)reader.ReadValue();
            if (expressionBody != null)
            {
                AdjustFlagsAndWidth(expressionBody);
                this.expressionBody = expressionBody;
            }
            var semicolonToken = (SyntaxToken?)reader.ReadValue();
            if (semicolonToken != null)
            {
                AdjustFlagsAndWidth(semicolonToken);
                this.semicolonToken = semicolonToken;
            }
        }

        internal override void WriteTo(ObjectWriter writer)
        {
            base.WriteTo(writer);
            writer.WriteValue(this.attributeLists);
            writer.WriteValue(this.modifiers);
            writer.WriteValue(this.implicitOrExplicitKeyword);
            writer.WriteValue(this.operatorKeyword);
            writer.WriteValue(this.type);
            writer.WriteValue(this.parameterList);
            writer.WriteValue(this.body);
            writer.WriteValue(this.expressionBody);
            writer.WriteValue(this.semicolonToken);
        }

        static ConversionOperatorDeclarationSyntax()
        {
            ObjectBinder.RegisterTypeReader(typeof(ConversionOperatorDeclarationSyntax), r => new ConversionOperatorDeclarationSyntax(r));
        }
    }

    /// <summary>Constructor declaration syntax.</summary>
    internal sealed partial class ConstructorDeclarationSyntax : BaseMethodDeclarationSyntax
    {
        internal readonly GreenNode? attributeLists;
        internal readonly GreenNode? modifiers;
        internal readonly SyntaxToken identifier;
        internal readonly ParameterListSyntax parameterList;
        internal readonly ConstructorInitializerSyntax? initializer;
        internal readonly BlockSyntax? body;
        internal readonly ArrowExpressionClauseSyntax? expressionBody;
        internal readonly SyntaxToken? semicolonToken;

        internal ConstructorDeclarationSyntax(SyntaxKind kind, GreenNode? attributeLists, GreenNode? modifiers, SyntaxToken identifier, ParameterListSyntax parameterList, ConstructorInitializerSyntax? initializer, BlockSyntax? body, ArrowExpressionClauseSyntax? expressionBody, SyntaxToken? semicolonToken, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
            this.SlotCount = 8;
            if (attributeLists != null)
            {
                this.AdjustFlagsAndWidth(attributeLists);
                this.attributeLists = attributeLists;
            }
            if (modifiers != null)
            {
                this.AdjustFlagsAndWidth(modifiers);
                this.modifiers = modifiers;
            }
            this.AdjustFlagsAndWidth(identifier);
            this.identifier = identifier;
            this.AdjustFlagsAndWidth(parameterList);
            this.parameterList = parameterList;
            if (initializer != null)
            {
                this.AdjustFlagsAndWidth(initializer);
                this.initializer = initializer;
            }
            if (body != null)
            {
                this.AdjustFlagsAndWidth(body);
                this.body = body;
            }
            if (expressionBody != null)
            {
                this.AdjustFlagsAndWidth(expressionBody);
                this.expressionBody = expressionBody;
            }
            if (semicolonToken != null)
            {
                this.AdjustFlagsAndWidth(semicolonToken);
                this.semicolonToken = semicolonToken;
            }
        }

        internal ConstructorDeclarationSyntax(SyntaxKind kind, GreenNode? attributeLists, GreenNode? modifiers, SyntaxToken identifier, ParameterListSyntax parameterList, ConstructorInitializerSyntax? initializer, BlockSyntax? body, ArrowExpressionClauseSyntax? expressionBody, SyntaxToken? semicolonToken, SyntaxFactoryContext context)
          : base(kind)
        {
            this.SetFactoryContext(context);
            this.SlotCount = 8;
            if (attributeLists != null)
            {
                this.AdjustFlagsAndWidth(attributeLists);
                this.attributeLists = attributeLists;
            }
            if (modifiers != null)
            {
                this.AdjustFlagsAndWidth(modifiers);
                this.modifiers = modifiers;
            }
            this.AdjustFlagsAndWidth(identifier);
            this.identifier = identifier;
            this.AdjustFlagsAndWidth(parameterList);
            this.parameterList = parameterList;
            if (initializer != null)
            {
                this.AdjustFlagsAndWidth(initializer);
                this.initializer = initializer;
            }
            if (body != null)
            {
                this.AdjustFlagsAndWidth(body);
                this.body = body;
            }
            if (expressionBody != null)
            {
                this.AdjustFlagsAndWidth(expressionBody);
                this.expressionBody = expressionBody;
            }
            if (semicolonToken != null)
            {
                this.AdjustFlagsAndWidth(semicolonToken);
                this.semicolonToken = semicolonToken;
            }
        }

        internal ConstructorDeclarationSyntax(SyntaxKind kind, GreenNode? attributeLists, GreenNode? modifiers, SyntaxToken identifier, ParameterListSyntax parameterList, ConstructorInitializerSyntax? initializer, BlockSyntax? body, ArrowExpressionClauseSyntax? expressionBody, SyntaxToken? semicolonToken)
          : base(kind)
        {
            this.SlotCount = 8;
            if (attributeLists != null)
            {
                this.AdjustFlagsAndWidth(attributeLists);
                this.attributeLists = attributeLists;
            }
            if (modifiers != null)
            {
                this.AdjustFlagsAndWidth(modifiers);
                this.modifiers = modifiers;
            }
            this.AdjustFlagsAndWidth(identifier);
            this.identifier = identifier;
            this.AdjustFlagsAndWidth(parameterList);
            this.parameterList = parameterList;
            if (initializer != null)
            {
                this.AdjustFlagsAndWidth(initializer);
                this.initializer = initializer;
            }
            if (body != null)
            {
                this.AdjustFlagsAndWidth(body);
                this.body = body;
            }
            if (expressionBody != null)
            {
                this.AdjustFlagsAndWidth(expressionBody);
                this.expressionBody = expressionBody;
            }
            if (semicolonToken != null)
            {
                this.AdjustFlagsAndWidth(semicolonToken);
                this.semicolonToken = semicolonToken;
            }
        }

        public override Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<AttributeListSyntax> AttributeLists => new Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<AttributeListSyntax>(this.attributeLists);
        public override Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SyntaxToken> Modifiers => new Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SyntaxToken>(this.modifiers);
        /// <summary>Gets the identifier.</summary>
        public SyntaxToken Identifier => this.identifier;
        public override ParameterListSyntax ParameterList => this.parameterList;
        public ConstructorInitializerSyntax? Initializer => this.initializer;
        public override BlockSyntax? Body => this.body;
        public override ArrowExpressionClauseSyntax? ExpressionBody => this.expressionBody;
        /// <summary>Gets the optional semicolon token.</summary>
        public override SyntaxToken? SemicolonToken => this.semicolonToken;

        internal override GreenNode? GetSlot(int index)
            => index switch
            {
                0 => this.attributeLists,
                1 => this.modifiers,
                2 => this.identifier,
                3 => this.parameterList,
                4 => this.initializer,
                5 => this.body,
                6 => this.expressionBody,
                7 => this.semicolonToken,
                _ => null,
            };

        internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new CSharp.Syntax.ConstructorDeclarationSyntax(this, parent, position);

        public override void Accept(CSharpSyntaxVisitor visitor) => visitor.VisitConstructorDeclaration(this);
        public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor) => visitor.VisitConstructorDeclaration(this);

        public ConstructorDeclarationSyntax Update(Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<AttributeListSyntax> attributeLists, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SyntaxToken> modifiers, SyntaxToken identifier, ParameterListSyntax parameterList, ConstructorInitializerSyntax initializer, BlockSyntax body, ArrowExpressionClauseSyntax expressionBody, SyntaxToken semicolonToken)
        {
            if (attributeLists != this.AttributeLists || modifiers != this.Modifiers || identifier != this.Identifier || parameterList != this.ParameterList || initializer != this.Initializer || body != this.Body || expressionBody != this.ExpressionBody || semicolonToken != this.SemicolonToken)
            {
                var newNode = SyntaxFactory.ConstructorDeclaration(attributeLists, modifiers, identifier, parameterList, initializer, body, expressionBody, semicolonToken);
                var diags = GetDiagnostics();
                if (diags?.Length > 0)
                    newNode = newNode.WithDiagnosticsGreen(diags);
                var annotations = GetAnnotations();
                if (annotations?.Length > 0)
                    newNode = newNode.WithAnnotationsGreen(annotations);
                return newNode;
            }

            return this;
        }

        internal override GreenNode SetDiagnostics(DiagnosticInfo[]? diagnostics)
            => new ConstructorDeclarationSyntax(this.Kind, this.attributeLists, this.modifiers, this.identifier, this.parameterList, this.initializer, this.body, this.expressionBody, this.semicolonToken, diagnostics, GetAnnotations());

        internal override GreenNode SetAnnotations(SyntaxAnnotation[]? annotations)
            => new ConstructorDeclarationSyntax(this.Kind, this.attributeLists, this.modifiers, this.identifier, this.parameterList, this.initializer, this.body, this.expressionBody, this.semicolonToken, GetDiagnostics(), annotations);

        internal ConstructorDeclarationSyntax(ObjectReader reader)
          : base(reader)
        {
            this.SlotCount = 8;
            var attributeLists = (GreenNode?)reader.ReadValue();
            if (attributeLists != null)
            {
                AdjustFlagsAndWidth(attributeLists);
                this.attributeLists = attributeLists;
            }
            var modifiers = (GreenNode?)reader.ReadValue();
            if (modifiers != null)
            {
                AdjustFlagsAndWidth(modifiers);
                this.modifiers = modifiers;
            }
            var identifier = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(identifier);
            this.identifier = identifier;
            var parameterList = (ParameterListSyntax)reader.ReadValue();
            AdjustFlagsAndWidth(parameterList);
            this.parameterList = parameterList;
            var initializer = (ConstructorInitializerSyntax?)reader.ReadValue();
            if (initializer != null)
            {
                AdjustFlagsAndWidth(initializer);
                this.initializer = initializer;
            }
            var body = (BlockSyntax?)reader.ReadValue();
            if (body != null)
            {
                AdjustFlagsAndWidth(body);
                this.body = body;
            }
            var expressionBody = (ArrowExpressionClauseSyntax?)reader.ReadValue();
            if (expressionBody != null)
            {
                AdjustFlagsAndWidth(expressionBody);
                this.expressionBody = expressionBody;
            }
            var semicolonToken = (SyntaxToken?)reader.ReadValue();
            if (semicolonToken != null)
            {
                AdjustFlagsAndWidth(semicolonToken);
                this.semicolonToken = semicolonToken;
            }
        }

        internal override void WriteTo(ObjectWriter writer)
        {
            base.WriteTo(writer);
            writer.WriteValue(this.attributeLists);
            writer.WriteValue(this.modifiers);
            writer.WriteValue(this.identifier);
            writer.WriteValue(this.parameterList);
            writer.WriteValue(this.initializer);
            writer.WriteValue(this.body);
            writer.WriteValue(this.expressionBody);
            writer.WriteValue(this.semicolonToken);
        }

        static ConstructorDeclarationSyntax()
        {
            ObjectBinder.RegisterTypeReader(typeof(ConstructorDeclarationSyntax), r => new ConstructorDeclarationSyntax(r));
        }
    }

    /// <summary>Constructor initializer syntax.</summary>
    internal sealed partial class ConstructorInitializerSyntax : CSharpSyntaxNode
    {
        internal readonly SyntaxToken colonToken;
        internal readonly SyntaxToken thisOrBaseKeyword;
        internal readonly ArgumentListSyntax argumentList;

        internal ConstructorInitializerSyntax(SyntaxKind kind, SyntaxToken colonToken, SyntaxToken thisOrBaseKeyword, ArgumentListSyntax argumentList, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
            this.SlotCount = 3;
            this.AdjustFlagsAndWidth(colonToken);
            this.colonToken = colonToken;
            this.AdjustFlagsAndWidth(thisOrBaseKeyword);
            this.thisOrBaseKeyword = thisOrBaseKeyword;
            this.AdjustFlagsAndWidth(argumentList);
            this.argumentList = argumentList;
        }

        internal ConstructorInitializerSyntax(SyntaxKind kind, SyntaxToken colonToken, SyntaxToken thisOrBaseKeyword, ArgumentListSyntax argumentList, SyntaxFactoryContext context)
          : base(kind)
        {
            this.SetFactoryContext(context);
            this.SlotCount = 3;
            this.AdjustFlagsAndWidth(colonToken);
            this.colonToken = colonToken;
            this.AdjustFlagsAndWidth(thisOrBaseKeyword);
            this.thisOrBaseKeyword = thisOrBaseKeyword;
            this.AdjustFlagsAndWidth(argumentList);
            this.argumentList = argumentList;
        }

        internal ConstructorInitializerSyntax(SyntaxKind kind, SyntaxToken colonToken, SyntaxToken thisOrBaseKeyword, ArgumentListSyntax argumentList)
          : base(kind)
        {
            this.SlotCount = 3;
            this.AdjustFlagsAndWidth(colonToken);
            this.colonToken = colonToken;
            this.AdjustFlagsAndWidth(thisOrBaseKeyword);
            this.thisOrBaseKeyword = thisOrBaseKeyword;
            this.AdjustFlagsAndWidth(argumentList);
            this.argumentList = argumentList;
        }

        /// <summary>Gets the colon token.</summary>
        public SyntaxToken ColonToken => this.colonToken;
        /// <summary>Gets the "this" or "base" keyword.</summary>
        public SyntaxToken ThisOrBaseKeyword => this.thisOrBaseKeyword;
        public ArgumentListSyntax ArgumentList => this.argumentList;

        internal override GreenNode? GetSlot(int index)
            => index switch
            {
                0 => this.colonToken,
                1 => this.thisOrBaseKeyword,
                2 => this.argumentList,
                _ => null,
            };

        internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new CSharp.Syntax.ConstructorInitializerSyntax(this, parent, position);

        public override void Accept(CSharpSyntaxVisitor visitor) => visitor.VisitConstructorInitializer(this);
        public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor) => visitor.VisitConstructorInitializer(this);

        public ConstructorInitializerSyntax Update(SyntaxToken colonToken, SyntaxToken thisOrBaseKeyword, ArgumentListSyntax argumentList)
        {
            if (colonToken != this.ColonToken || thisOrBaseKeyword != this.ThisOrBaseKeyword || argumentList != this.ArgumentList)
            {
                var newNode = SyntaxFactory.ConstructorInitializer(this.Kind, colonToken, thisOrBaseKeyword, argumentList);
                var diags = GetDiagnostics();
                if (diags?.Length > 0)
                    newNode = newNode.WithDiagnosticsGreen(diags);
                var annotations = GetAnnotations();
                if (annotations?.Length > 0)
                    newNode = newNode.WithAnnotationsGreen(annotations);
                return newNode;
            }

            return this;
        }

        internal override GreenNode SetDiagnostics(DiagnosticInfo[]? diagnostics)
            => new ConstructorInitializerSyntax(this.Kind, this.colonToken, this.thisOrBaseKeyword, this.argumentList, diagnostics, GetAnnotations());

        internal override GreenNode SetAnnotations(SyntaxAnnotation[]? annotations)
            => new ConstructorInitializerSyntax(this.Kind, this.colonToken, this.thisOrBaseKeyword, this.argumentList, GetDiagnostics(), annotations);

        internal ConstructorInitializerSyntax(ObjectReader reader)
          : base(reader)
        {
            this.SlotCount = 3;
            var colonToken = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(colonToken);
            this.colonToken = colonToken;
            var thisOrBaseKeyword = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(thisOrBaseKeyword);
            this.thisOrBaseKeyword = thisOrBaseKeyword;
            var argumentList = (ArgumentListSyntax)reader.ReadValue();
            AdjustFlagsAndWidth(argumentList);
            this.argumentList = argumentList;
        }

        internal override void WriteTo(ObjectWriter writer)
        {
            base.WriteTo(writer);
            writer.WriteValue(this.colonToken);
            writer.WriteValue(this.thisOrBaseKeyword);
            writer.WriteValue(this.argumentList);
        }

        static ConstructorInitializerSyntax()
        {
            ObjectBinder.RegisterTypeReader(typeof(ConstructorInitializerSyntax), r => new ConstructorInitializerSyntax(r));
        }
    }

    /// <summary>Destructor declaration syntax.</summary>
    internal sealed partial class DestructorDeclarationSyntax : BaseMethodDeclarationSyntax
    {
        internal readonly GreenNode? attributeLists;
        internal readonly GreenNode? modifiers;
        internal readonly SyntaxToken tildeToken;
        internal readonly SyntaxToken identifier;
        internal readonly ParameterListSyntax parameterList;
        internal readonly BlockSyntax? body;
        internal readonly ArrowExpressionClauseSyntax? expressionBody;
        internal readonly SyntaxToken? semicolonToken;

        internal DestructorDeclarationSyntax(SyntaxKind kind, GreenNode? attributeLists, GreenNode? modifiers, SyntaxToken tildeToken, SyntaxToken identifier, ParameterListSyntax parameterList, BlockSyntax? body, ArrowExpressionClauseSyntax? expressionBody, SyntaxToken? semicolonToken, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
            this.SlotCount = 8;
            if (attributeLists != null)
            {
                this.AdjustFlagsAndWidth(attributeLists);
                this.attributeLists = attributeLists;
            }
            if (modifiers != null)
            {
                this.AdjustFlagsAndWidth(modifiers);
                this.modifiers = modifiers;
            }
            this.AdjustFlagsAndWidth(tildeToken);
            this.tildeToken = tildeToken;
            this.AdjustFlagsAndWidth(identifier);
            this.identifier = identifier;
            this.AdjustFlagsAndWidth(parameterList);
            this.parameterList = parameterList;
            if (body != null)
            {
                this.AdjustFlagsAndWidth(body);
                this.body = body;
            }
            if (expressionBody != null)
            {
                this.AdjustFlagsAndWidth(expressionBody);
                this.expressionBody = expressionBody;
            }
            if (semicolonToken != null)
            {
                this.AdjustFlagsAndWidth(semicolonToken);
                this.semicolonToken = semicolonToken;
            }
        }

        internal DestructorDeclarationSyntax(SyntaxKind kind, GreenNode? attributeLists, GreenNode? modifiers, SyntaxToken tildeToken, SyntaxToken identifier, ParameterListSyntax parameterList, BlockSyntax? body, ArrowExpressionClauseSyntax? expressionBody, SyntaxToken? semicolonToken, SyntaxFactoryContext context)
          : base(kind)
        {
            this.SetFactoryContext(context);
            this.SlotCount = 8;
            if (attributeLists != null)
            {
                this.AdjustFlagsAndWidth(attributeLists);
                this.attributeLists = attributeLists;
            }
            if (modifiers != null)
            {
                this.AdjustFlagsAndWidth(modifiers);
                this.modifiers = modifiers;
            }
            this.AdjustFlagsAndWidth(tildeToken);
            this.tildeToken = tildeToken;
            this.AdjustFlagsAndWidth(identifier);
            this.identifier = identifier;
            this.AdjustFlagsAndWidth(parameterList);
            this.parameterList = parameterList;
            if (body != null)
            {
                this.AdjustFlagsAndWidth(body);
                this.body = body;
            }
            if (expressionBody != null)
            {
                this.AdjustFlagsAndWidth(expressionBody);
                this.expressionBody = expressionBody;
            }
            if (semicolonToken != null)
            {
                this.AdjustFlagsAndWidth(semicolonToken);
                this.semicolonToken = semicolonToken;
            }
        }

        internal DestructorDeclarationSyntax(SyntaxKind kind, GreenNode? attributeLists, GreenNode? modifiers, SyntaxToken tildeToken, SyntaxToken identifier, ParameterListSyntax parameterList, BlockSyntax? body, ArrowExpressionClauseSyntax? expressionBody, SyntaxToken? semicolonToken)
          : base(kind)
        {
            this.SlotCount = 8;
            if (attributeLists != null)
            {
                this.AdjustFlagsAndWidth(attributeLists);
                this.attributeLists = attributeLists;
            }
            if (modifiers != null)
            {
                this.AdjustFlagsAndWidth(modifiers);
                this.modifiers = modifiers;
            }
            this.AdjustFlagsAndWidth(tildeToken);
            this.tildeToken = tildeToken;
            this.AdjustFlagsAndWidth(identifier);
            this.identifier = identifier;
            this.AdjustFlagsAndWidth(parameterList);
            this.parameterList = parameterList;
            if (body != null)
            {
                this.AdjustFlagsAndWidth(body);
                this.body = body;
            }
            if (expressionBody != null)
            {
                this.AdjustFlagsAndWidth(expressionBody);
                this.expressionBody = expressionBody;
            }
            if (semicolonToken != null)
            {
                this.AdjustFlagsAndWidth(semicolonToken);
                this.semicolonToken = semicolonToken;
            }
        }

        public override Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<AttributeListSyntax> AttributeLists => new Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<AttributeListSyntax>(this.attributeLists);
        public override Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SyntaxToken> Modifiers => new Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SyntaxToken>(this.modifiers);
        /// <summary>Gets the tilde token.</summary>
        public SyntaxToken TildeToken => this.tildeToken;
        /// <summary>Gets the identifier.</summary>
        public SyntaxToken Identifier => this.identifier;
        public override ParameterListSyntax ParameterList => this.parameterList;
        public override BlockSyntax? Body => this.body;
        public override ArrowExpressionClauseSyntax? ExpressionBody => this.expressionBody;
        /// <summary>Gets the optional semicolon token.</summary>
        public override SyntaxToken? SemicolonToken => this.semicolonToken;

        internal override GreenNode? GetSlot(int index)
            => index switch
            {
                0 => this.attributeLists,
                1 => this.modifiers,
                2 => this.tildeToken,
                3 => this.identifier,
                4 => this.parameterList,
                5 => this.body,
                6 => this.expressionBody,
                7 => this.semicolonToken,
                _ => null,
            };

        internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new CSharp.Syntax.DestructorDeclarationSyntax(this, parent, position);

        public override void Accept(CSharpSyntaxVisitor visitor) => visitor.VisitDestructorDeclaration(this);
        public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor) => visitor.VisitDestructorDeclaration(this);

        public DestructorDeclarationSyntax Update(Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<AttributeListSyntax> attributeLists, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SyntaxToken> modifiers, SyntaxToken tildeToken, SyntaxToken identifier, ParameterListSyntax parameterList, BlockSyntax body, ArrowExpressionClauseSyntax expressionBody, SyntaxToken semicolonToken)
        {
            if (attributeLists != this.AttributeLists || modifiers != this.Modifiers || tildeToken != this.TildeToken || identifier != this.Identifier || parameterList != this.ParameterList || body != this.Body || expressionBody != this.ExpressionBody || semicolonToken != this.SemicolonToken)
            {
                var newNode = SyntaxFactory.DestructorDeclaration(attributeLists, modifiers, tildeToken, identifier, parameterList, body, expressionBody, semicolonToken);
                var diags = GetDiagnostics();
                if (diags?.Length > 0)
                    newNode = newNode.WithDiagnosticsGreen(diags);
                var annotations = GetAnnotations();
                if (annotations?.Length > 0)
                    newNode = newNode.WithAnnotationsGreen(annotations);
                return newNode;
            }

            return this;
        }

        internal override GreenNode SetDiagnostics(DiagnosticInfo[]? diagnostics)
            => new DestructorDeclarationSyntax(this.Kind, this.attributeLists, this.modifiers, this.tildeToken, this.identifier, this.parameterList, this.body, this.expressionBody, this.semicolonToken, diagnostics, GetAnnotations());

        internal override GreenNode SetAnnotations(SyntaxAnnotation[]? annotations)
            => new DestructorDeclarationSyntax(this.Kind, this.attributeLists, this.modifiers, this.tildeToken, this.identifier, this.parameterList, this.body, this.expressionBody, this.semicolonToken, GetDiagnostics(), annotations);

        internal DestructorDeclarationSyntax(ObjectReader reader)
          : base(reader)
        {
            this.SlotCount = 8;
            var attributeLists = (GreenNode?)reader.ReadValue();
            if (attributeLists != null)
            {
                AdjustFlagsAndWidth(attributeLists);
                this.attributeLists = attributeLists;
            }
            var modifiers = (GreenNode?)reader.ReadValue();
            if (modifiers != null)
            {
                AdjustFlagsAndWidth(modifiers);
                this.modifiers = modifiers;
            }
            var tildeToken = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(tildeToken);
            this.tildeToken = tildeToken;
            var identifier = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(identifier);
            this.identifier = identifier;
            var parameterList = (ParameterListSyntax)reader.ReadValue();
            AdjustFlagsAndWidth(parameterList);
            this.parameterList = parameterList;
            var body = (BlockSyntax?)reader.ReadValue();
            if (body != null)
            {
                AdjustFlagsAndWidth(body);
                this.body = body;
            }
            var expressionBody = (ArrowExpressionClauseSyntax?)reader.ReadValue();
            if (expressionBody != null)
            {
                AdjustFlagsAndWidth(expressionBody);
                this.expressionBody = expressionBody;
            }
            var semicolonToken = (SyntaxToken?)reader.ReadValue();
            if (semicolonToken != null)
            {
                AdjustFlagsAndWidth(semicolonToken);
                this.semicolonToken = semicolonToken;
            }
        }

        internal override void WriteTo(ObjectWriter writer)
        {
            base.WriteTo(writer);
            writer.WriteValue(this.attributeLists);
            writer.WriteValue(this.modifiers);
            writer.WriteValue(this.tildeToken);
            writer.WriteValue(this.identifier);
            writer.WriteValue(this.parameterList);
            writer.WriteValue(this.body);
            writer.WriteValue(this.expressionBody);
            writer.WriteValue(this.semicolonToken);
        }

        static DestructorDeclarationSyntax()
        {
            ObjectBinder.RegisterTypeReader(typeof(DestructorDeclarationSyntax), r => new DestructorDeclarationSyntax(r));
        }
    }

    /// <summary>Base type for property declaration syntax.</summary>
    internal abstract partial class BasePropertyDeclarationSyntax : MemberDeclarationSyntax
    {
        internal BasePropertyDeclarationSyntax(SyntaxKind kind, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
        }

        internal BasePropertyDeclarationSyntax(SyntaxKind kind)
          : base(kind)
        {
        }

        protected BasePropertyDeclarationSyntax(ObjectReader reader)
          : base(reader)
        {
        }

        /// <summary>Gets the type syntax.</summary>
        public abstract TypeSyntax Type { get; }

        /// <summary>Gets the optional explicit interface specifier.</summary>
        public abstract ExplicitInterfaceSpecifierSyntax? ExplicitInterfaceSpecifier { get; }

        public abstract AccessorListSyntax? AccessorList { get; }
    }

    internal sealed partial class PropertyDeclarationSyntax : BasePropertyDeclarationSyntax
    {
        internal readonly GreenNode? attributeLists;
        internal readonly GreenNode? modifiers;
        internal readonly TypeSyntax type;
        internal readonly ExplicitInterfaceSpecifierSyntax? explicitInterfaceSpecifier;
        internal readonly SyntaxToken identifier;
        internal readonly AccessorListSyntax? accessorList;
        internal readonly ArrowExpressionClauseSyntax? expressionBody;
        internal readonly EqualsValueClauseSyntax? initializer;
        internal readonly SyntaxToken? semicolonToken;

        internal PropertyDeclarationSyntax(SyntaxKind kind, GreenNode? attributeLists, GreenNode? modifiers, TypeSyntax type, ExplicitInterfaceSpecifierSyntax? explicitInterfaceSpecifier, SyntaxToken identifier, AccessorListSyntax? accessorList, ArrowExpressionClauseSyntax? expressionBody, EqualsValueClauseSyntax? initializer, SyntaxToken? semicolonToken, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
            this.SlotCount = 9;
            if (attributeLists != null)
            {
                this.AdjustFlagsAndWidth(attributeLists);
                this.attributeLists = attributeLists;
            }
            if (modifiers != null)
            {
                this.AdjustFlagsAndWidth(modifiers);
                this.modifiers = modifiers;
            }
            this.AdjustFlagsAndWidth(type);
            this.type = type;
            if (explicitInterfaceSpecifier != null)
            {
                this.AdjustFlagsAndWidth(explicitInterfaceSpecifier);
                this.explicitInterfaceSpecifier = explicitInterfaceSpecifier;
            }
            this.AdjustFlagsAndWidth(identifier);
            this.identifier = identifier;
            if (accessorList != null)
            {
                this.AdjustFlagsAndWidth(accessorList);
                this.accessorList = accessorList;
            }
            if (expressionBody != null)
            {
                this.AdjustFlagsAndWidth(expressionBody);
                this.expressionBody = expressionBody;
            }
            if (initializer != null)
            {
                this.AdjustFlagsAndWidth(initializer);
                this.initializer = initializer;
            }
            if (semicolonToken != null)
            {
                this.AdjustFlagsAndWidth(semicolonToken);
                this.semicolonToken = semicolonToken;
            }
        }

        internal PropertyDeclarationSyntax(SyntaxKind kind, GreenNode? attributeLists, GreenNode? modifiers, TypeSyntax type, ExplicitInterfaceSpecifierSyntax? explicitInterfaceSpecifier, SyntaxToken identifier, AccessorListSyntax? accessorList, ArrowExpressionClauseSyntax? expressionBody, EqualsValueClauseSyntax? initializer, SyntaxToken? semicolonToken, SyntaxFactoryContext context)
          : base(kind)
        {
            this.SetFactoryContext(context);
            this.SlotCount = 9;
            if (attributeLists != null)
            {
                this.AdjustFlagsAndWidth(attributeLists);
                this.attributeLists = attributeLists;
            }
            if (modifiers != null)
            {
                this.AdjustFlagsAndWidth(modifiers);
                this.modifiers = modifiers;
            }
            this.AdjustFlagsAndWidth(type);
            this.type = type;
            if (explicitInterfaceSpecifier != null)
            {
                this.AdjustFlagsAndWidth(explicitInterfaceSpecifier);
                this.explicitInterfaceSpecifier = explicitInterfaceSpecifier;
            }
            this.AdjustFlagsAndWidth(identifier);
            this.identifier = identifier;
            if (accessorList != null)
            {
                this.AdjustFlagsAndWidth(accessorList);
                this.accessorList = accessorList;
            }
            if (expressionBody != null)
            {
                this.AdjustFlagsAndWidth(expressionBody);
                this.expressionBody = expressionBody;
            }
            if (initializer != null)
            {
                this.AdjustFlagsAndWidth(initializer);
                this.initializer = initializer;
            }
            if (semicolonToken != null)
            {
                this.AdjustFlagsAndWidth(semicolonToken);
                this.semicolonToken = semicolonToken;
            }
        }

        internal PropertyDeclarationSyntax(SyntaxKind kind, GreenNode? attributeLists, GreenNode? modifiers, TypeSyntax type, ExplicitInterfaceSpecifierSyntax? explicitInterfaceSpecifier, SyntaxToken identifier, AccessorListSyntax? accessorList, ArrowExpressionClauseSyntax? expressionBody, EqualsValueClauseSyntax? initializer, SyntaxToken? semicolonToken)
          : base(kind)
        {
            this.SlotCount = 9;
            if (attributeLists != null)
            {
                this.AdjustFlagsAndWidth(attributeLists);
                this.attributeLists = attributeLists;
            }
            if (modifiers != null)
            {
                this.AdjustFlagsAndWidth(modifiers);
                this.modifiers = modifiers;
            }
            this.AdjustFlagsAndWidth(type);
            this.type = type;
            if (explicitInterfaceSpecifier != null)
            {
                this.AdjustFlagsAndWidth(explicitInterfaceSpecifier);
                this.explicitInterfaceSpecifier = explicitInterfaceSpecifier;
            }
            this.AdjustFlagsAndWidth(identifier);
            this.identifier = identifier;
            if (accessorList != null)
            {
                this.AdjustFlagsAndWidth(accessorList);
                this.accessorList = accessorList;
            }
            if (expressionBody != null)
            {
                this.AdjustFlagsAndWidth(expressionBody);
                this.expressionBody = expressionBody;
            }
            if (initializer != null)
            {
                this.AdjustFlagsAndWidth(initializer);
                this.initializer = initializer;
            }
            if (semicolonToken != null)
            {
                this.AdjustFlagsAndWidth(semicolonToken);
                this.semicolonToken = semicolonToken;
            }
        }

        public override Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<AttributeListSyntax> AttributeLists => new Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<AttributeListSyntax>(this.attributeLists);
        public override Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SyntaxToken> Modifiers => new Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SyntaxToken>(this.modifiers);
        public override TypeSyntax Type => this.type;
        public override ExplicitInterfaceSpecifierSyntax? ExplicitInterfaceSpecifier => this.explicitInterfaceSpecifier;
        /// <summary>Gets the identifier.</summary>
        public SyntaxToken Identifier => this.identifier;
        public override AccessorListSyntax? AccessorList => this.accessorList;
        public ArrowExpressionClauseSyntax? ExpressionBody => this.expressionBody;
        public EqualsValueClauseSyntax? Initializer => this.initializer;
        public SyntaxToken? SemicolonToken => this.semicolonToken;

        internal override GreenNode? GetSlot(int index)
            => index switch
            {
                0 => this.attributeLists,
                1 => this.modifiers,
                2 => this.type,
                3 => this.explicitInterfaceSpecifier,
                4 => this.identifier,
                5 => this.accessorList,
                6 => this.expressionBody,
                7 => this.initializer,
                8 => this.semicolonToken,
                _ => null,
            };

        internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new CSharp.Syntax.PropertyDeclarationSyntax(this, parent, position);

        public override void Accept(CSharpSyntaxVisitor visitor) => visitor.VisitPropertyDeclaration(this);
        public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor) => visitor.VisitPropertyDeclaration(this);

        public PropertyDeclarationSyntax Update(Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<AttributeListSyntax> attributeLists, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SyntaxToken> modifiers, TypeSyntax type, ExplicitInterfaceSpecifierSyntax explicitInterfaceSpecifier, SyntaxToken identifier, AccessorListSyntax accessorList, ArrowExpressionClauseSyntax expressionBody, EqualsValueClauseSyntax initializer, SyntaxToken semicolonToken)
        {
            if (attributeLists != this.AttributeLists || modifiers != this.Modifiers || type != this.Type || explicitInterfaceSpecifier != this.ExplicitInterfaceSpecifier || identifier != this.Identifier || accessorList != this.AccessorList || expressionBody != this.ExpressionBody || initializer != this.Initializer || semicolonToken != this.SemicolonToken)
            {
                var newNode = SyntaxFactory.PropertyDeclaration(attributeLists, modifiers, type, explicitInterfaceSpecifier, identifier, accessorList, expressionBody, initializer, semicolonToken);
                var diags = GetDiagnostics();
                if (diags?.Length > 0)
                    newNode = newNode.WithDiagnosticsGreen(diags);
                var annotations = GetAnnotations();
                if (annotations?.Length > 0)
                    newNode = newNode.WithAnnotationsGreen(annotations);
                return newNode;
            }

            return this;
        }

        internal override GreenNode SetDiagnostics(DiagnosticInfo[]? diagnostics)
            => new PropertyDeclarationSyntax(this.Kind, this.attributeLists, this.modifiers, this.type, this.explicitInterfaceSpecifier, this.identifier, this.accessorList, this.expressionBody, this.initializer, this.semicolonToken, diagnostics, GetAnnotations());

        internal override GreenNode SetAnnotations(SyntaxAnnotation[]? annotations)
            => new PropertyDeclarationSyntax(this.Kind, this.attributeLists, this.modifiers, this.type, this.explicitInterfaceSpecifier, this.identifier, this.accessorList, this.expressionBody, this.initializer, this.semicolonToken, GetDiagnostics(), annotations);

        internal PropertyDeclarationSyntax(ObjectReader reader)
          : base(reader)
        {
            this.SlotCount = 9;
            var attributeLists = (GreenNode?)reader.ReadValue();
            if (attributeLists != null)
            {
                AdjustFlagsAndWidth(attributeLists);
                this.attributeLists = attributeLists;
            }
            var modifiers = (GreenNode?)reader.ReadValue();
            if (modifiers != null)
            {
                AdjustFlagsAndWidth(modifiers);
                this.modifiers = modifiers;
            }
            var type = (TypeSyntax)reader.ReadValue();
            AdjustFlagsAndWidth(type);
            this.type = type;
            var explicitInterfaceSpecifier = (ExplicitInterfaceSpecifierSyntax?)reader.ReadValue();
            if (explicitInterfaceSpecifier != null)
            {
                AdjustFlagsAndWidth(explicitInterfaceSpecifier);
                this.explicitInterfaceSpecifier = explicitInterfaceSpecifier;
            }
            var identifier = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(identifier);
            this.identifier = identifier;
            var accessorList = (AccessorListSyntax?)reader.ReadValue();
            if (accessorList != null)
            {
                AdjustFlagsAndWidth(accessorList);
                this.accessorList = accessorList;
            }
            var expressionBody = (ArrowExpressionClauseSyntax?)reader.ReadValue();
            if (expressionBody != null)
            {
                AdjustFlagsAndWidth(expressionBody);
                this.expressionBody = expressionBody;
            }
            var initializer = (EqualsValueClauseSyntax?)reader.ReadValue();
            if (initializer != null)
            {
                AdjustFlagsAndWidth(initializer);
                this.initializer = initializer;
            }
            var semicolonToken = (SyntaxToken?)reader.ReadValue();
            if (semicolonToken != null)
            {
                AdjustFlagsAndWidth(semicolonToken);
                this.semicolonToken = semicolonToken;
            }
        }

        internal override void WriteTo(ObjectWriter writer)
        {
            base.WriteTo(writer);
            writer.WriteValue(this.attributeLists);
            writer.WriteValue(this.modifiers);
            writer.WriteValue(this.type);
            writer.WriteValue(this.explicitInterfaceSpecifier);
            writer.WriteValue(this.identifier);
            writer.WriteValue(this.accessorList);
            writer.WriteValue(this.expressionBody);
            writer.WriteValue(this.initializer);
            writer.WriteValue(this.semicolonToken);
        }

        static PropertyDeclarationSyntax()
        {
            ObjectBinder.RegisterTypeReader(typeof(PropertyDeclarationSyntax), r => new PropertyDeclarationSyntax(r));
        }
    }

    /// <summary>The syntax for the expression body of an expression-bodied member.</summary>
    internal sealed partial class ArrowExpressionClauseSyntax : CSharpSyntaxNode
    {
        internal readonly SyntaxToken arrowToken;
        internal readonly ExpressionSyntax expression;

        internal ArrowExpressionClauseSyntax(SyntaxKind kind, SyntaxToken arrowToken, ExpressionSyntax expression, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
            this.SlotCount = 2;
            this.AdjustFlagsAndWidth(arrowToken);
            this.arrowToken = arrowToken;
            this.AdjustFlagsAndWidth(expression);
            this.expression = expression;
        }

        internal ArrowExpressionClauseSyntax(SyntaxKind kind, SyntaxToken arrowToken, ExpressionSyntax expression, SyntaxFactoryContext context)
          : base(kind)
        {
            this.SetFactoryContext(context);
            this.SlotCount = 2;
            this.AdjustFlagsAndWidth(arrowToken);
            this.arrowToken = arrowToken;
            this.AdjustFlagsAndWidth(expression);
            this.expression = expression;
        }

        internal ArrowExpressionClauseSyntax(SyntaxKind kind, SyntaxToken arrowToken, ExpressionSyntax expression)
          : base(kind)
        {
            this.SlotCount = 2;
            this.AdjustFlagsAndWidth(arrowToken);
            this.arrowToken = arrowToken;
            this.AdjustFlagsAndWidth(expression);
            this.expression = expression;
        }

        public SyntaxToken ArrowToken => this.arrowToken;
        public ExpressionSyntax Expression => this.expression;

        internal override GreenNode? GetSlot(int index)
            => index switch
            {
                0 => this.arrowToken,
                1 => this.expression,
                _ => null,
            };

        internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new CSharp.Syntax.ArrowExpressionClauseSyntax(this, parent, position);

        public override void Accept(CSharpSyntaxVisitor visitor) => visitor.VisitArrowExpressionClause(this);
        public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor) => visitor.VisitArrowExpressionClause(this);

        public ArrowExpressionClauseSyntax Update(SyntaxToken arrowToken, ExpressionSyntax expression)
        {
            if (arrowToken != this.ArrowToken || expression != this.Expression)
            {
                var newNode = SyntaxFactory.ArrowExpressionClause(arrowToken, expression);
                var diags = GetDiagnostics();
                if (diags?.Length > 0)
                    newNode = newNode.WithDiagnosticsGreen(diags);
                var annotations = GetAnnotations();
                if (annotations?.Length > 0)
                    newNode = newNode.WithAnnotationsGreen(annotations);
                return newNode;
            }

            return this;
        }

        internal override GreenNode SetDiagnostics(DiagnosticInfo[]? diagnostics)
            => new ArrowExpressionClauseSyntax(this.Kind, this.arrowToken, this.expression, diagnostics, GetAnnotations());

        internal override GreenNode SetAnnotations(SyntaxAnnotation[]? annotations)
            => new ArrowExpressionClauseSyntax(this.Kind, this.arrowToken, this.expression, GetDiagnostics(), annotations);

        internal ArrowExpressionClauseSyntax(ObjectReader reader)
          : base(reader)
        {
            this.SlotCount = 2;
            var arrowToken = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(arrowToken);
            this.arrowToken = arrowToken;
            var expression = (ExpressionSyntax)reader.ReadValue();
            AdjustFlagsAndWidth(expression);
            this.expression = expression;
        }

        internal override void WriteTo(ObjectWriter writer)
        {
            base.WriteTo(writer);
            writer.WriteValue(this.arrowToken);
            writer.WriteValue(this.expression);
        }

        static ArrowExpressionClauseSyntax()
        {
            ObjectBinder.RegisterTypeReader(typeof(ArrowExpressionClauseSyntax), r => new ArrowExpressionClauseSyntax(r));
        }
    }

    internal sealed partial class EventDeclarationSyntax : BasePropertyDeclarationSyntax
    {
        internal readonly GreenNode? attributeLists;
        internal readonly GreenNode? modifiers;
        internal readonly SyntaxToken eventKeyword;
        internal readonly TypeSyntax type;
        internal readonly ExplicitInterfaceSpecifierSyntax? explicitInterfaceSpecifier;
        internal readonly SyntaxToken identifier;
        internal readonly AccessorListSyntax? accessorList;
        internal readonly SyntaxToken? semicolonToken;

        internal EventDeclarationSyntax(SyntaxKind kind, GreenNode? attributeLists, GreenNode? modifiers, SyntaxToken eventKeyword, TypeSyntax type, ExplicitInterfaceSpecifierSyntax? explicitInterfaceSpecifier, SyntaxToken identifier, AccessorListSyntax? accessorList, SyntaxToken? semicolonToken, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
            this.SlotCount = 8;
            if (attributeLists != null)
            {
                this.AdjustFlagsAndWidth(attributeLists);
                this.attributeLists = attributeLists;
            }
            if (modifiers != null)
            {
                this.AdjustFlagsAndWidth(modifiers);
                this.modifiers = modifiers;
            }
            this.AdjustFlagsAndWidth(eventKeyword);
            this.eventKeyword = eventKeyword;
            this.AdjustFlagsAndWidth(type);
            this.type = type;
            if (explicitInterfaceSpecifier != null)
            {
                this.AdjustFlagsAndWidth(explicitInterfaceSpecifier);
                this.explicitInterfaceSpecifier = explicitInterfaceSpecifier;
            }
            this.AdjustFlagsAndWidth(identifier);
            this.identifier = identifier;
            if (accessorList != null)
            {
                this.AdjustFlagsAndWidth(accessorList);
                this.accessorList = accessorList;
            }
            if (semicolonToken != null)
            {
                this.AdjustFlagsAndWidth(semicolonToken);
                this.semicolonToken = semicolonToken;
            }
        }

        internal EventDeclarationSyntax(SyntaxKind kind, GreenNode? attributeLists, GreenNode? modifiers, SyntaxToken eventKeyword, TypeSyntax type, ExplicitInterfaceSpecifierSyntax? explicitInterfaceSpecifier, SyntaxToken identifier, AccessorListSyntax? accessorList, SyntaxToken? semicolonToken, SyntaxFactoryContext context)
          : base(kind)
        {
            this.SetFactoryContext(context);
            this.SlotCount = 8;
            if (attributeLists != null)
            {
                this.AdjustFlagsAndWidth(attributeLists);
                this.attributeLists = attributeLists;
            }
            if (modifiers != null)
            {
                this.AdjustFlagsAndWidth(modifiers);
                this.modifiers = modifiers;
            }
            this.AdjustFlagsAndWidth(eventKeyword);
            this.eventKeyword = eventKeyword;
            this.AdjustFlagsAndWidth(type);
            this.type = type;
            if (explicitInterfaceSpecifier != null)
            {
                this.AdjustFlagsAndWidth(explicitInterfaceSpecifier);
                this.explicitInterfaceSpecifier = explicitInterfaceSpecifier;
            }
            this.AdjustFlagsAndWidth(identifier);
            this.identifier = identifier;
            if (accessorList != null)
            {
                this.AdjustFlagsAndWidth(accessorList);
                this.accessorList = accessorList;
            }
            if (semicolonToken != null)
            {
                this.AdjustFlagsAndWidth(semicolonToken);
                this.semicolonToken = semicolonToken;
            }
        }

        internal EventDeclarationSyntax(SyntaxKind kind, GreenNode? attributeLists, GreenNode? modifiers, SyntaxToken eventKeyword, TypeSyntax type, ExplicitInterfaceSpecifierSyntax? explicitInterfaceSpecifier, SyntaxToken identifier, AccessorListSyntax? accessorList, SyntaxToken? semicolonToken)
          : base(kind)
        {
            this.SlotCount = 8;
            if (attributeLists != null)
            {
                this.AdjustFlagsAndWidth(attributeLists);
                this.attributeLists = attributeLists;
            }
            if (modifiers != null)
            {
                this.AdjustFlagsAndWidth(modifiers);
                this.modifiers = modifiers;
            }
            this.AdjustFlagsAndWidth(eventKeyword);
            this.eventKeyword = eventKeyword;
            this.AdjustFlagsAndWidth(type);
            this.type = type;
            if (explicitInterfaceSpecifier != null)
            {
                this.AdjustFlagsAndWidth(explicitInterfaceSpecifier);
                this.explicitInterfaceSpecifier = explicitInterfaceSpecifier;
            }
            this.AdjustFlagsAndWidth(identifier);
            this.identifier = identifier;
            if (accessorList != null)
            {
                this.AdjustFlagsAndWidth(accessorList);
                this.accessorList = accessorList;
            }
            if (semicolonToken != null)
            {
                this.AdjustFlagsAndWidth(semicolonToken);
                this.semicolonToken = semicolonToken;
            }
        }

        public override Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<AttributeListSyntax> AttributeLists => new Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<AttributeListSyntax>(this.attributeLists);
        public override Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SyntaxToken> Modifiers => new Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SyntaxToken>(this.modifiers);
        public SyntaxToken EventKeyword => this.eventKeyword;
        public override TypeSyntax Type => this.type;
        public override ExplicitInterfaceSpecifierSyntax? ExplicitInterfaceSpecifier => this.explicitInterfaceSpecifier;
        /// <summary>Gets the identifier.</summary>
        public SyntaxToken Identifier => this.identifier;
        public override AccessorListSyntax? AccessorList => this.accessorList;
        public SyntaxToken? SemicolonToken => this.semicolonToken;

        internal override GreenNode? GetSlot(int index)
            => index switch
            {
                0 => this.attributeLists,
                1 => this.modifiers,
                2 => this.eventKeyword,
                3 => this.type,
                4 => this.explicitInterfaceSpecifier,
                5 => this.identifier,
                6 => this.accessorList,
                7 => this.semicolonToken,
                _ => null,
            };

        internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new CSharp.Syntax.EventDeclarationSyntax(this, parent, position);

        public override void Accept(CSharpSyntaxVisitor visitor) => visitor.VisitEventDeclaration(this);
        public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor) => visitor.VisitEventDeclaration(this);

        public EventDeclarationSyntax Update(Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<AttributeListSyntax> attributeLists, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SyntaxToken> modifiers, SyntaxToken eventKeyword, TypeSyntax type, ExplicitInterfaceSpecifierSyntax explicitInterfaceSpecifier, SyntaxToken identifier, AccessorListSyntax accessorList, SyntaxToken semicolonToken)
        {
            if (attributeLists != this.AttributeLists || modifiers != this.Modifiers || eventKeyword != this.EventKeyword || type != this.Type || explicitInterfaceSpecifier != this.ExplicitInterfaceSpecifier || identifier != this.Identifier || accessorList != this.AccessorList || semicolonToken != this.SemicolonToken)
            {
                var newNode = SyntaxFactory.EventDeclaration(attributeLists, modifiers, eventKeyword, type, explicitInterfaceSpecifier, identifier, accessorList, semicolonToken);
                var diags = GetDiagnostics();
                if (diags?.Length > 0)
                    newNode = newNode.WithDiagnosticsGreen(diags);
                var annotations = GetAnnotations();
                if (annotations?.Length > 0)
                    newNode = newNode.WithAnnotationsGreen(annotations);
                return newNode;
            }

            return this;
        }

        internal override GreenNode SetDiagnostics(DiagnosticInfo[]? diagnostics)
            => new EventDeclarationSyntax(this.Kind, this.attributeLists, this.modifiers, this.eventKeyword, this.type, this.explicitInterfaceSpecifier, this.identifier, this.accessorList, this.semicolonToken, diagnostics, GetAnnotations());

        internal override GreenNode SetAnnotations(SyntaxAnnotation[]? annotations)
            => new EventDeclarationSyntax(this.Kind, this.attributeLists, this.modifiers, this.eventKeyword, this.type, this.explicitInterfaceSpecifier, this.identifier, this.accessorList, this.semicolonToken, GetDiagnostics(), annotations);

        internal EventDeclarationSyntax(ObjectReader reader)
          : base(reader)
        {
            this.SlotCount = 8;
            var attributeLists = (GreenNode?)reader.ReadValue();
            if (attributeLists != null)
            {
                AdjustFlagsAndWidth(attributeLists);
                this.attributeLists = attributeLists;
            }
            var modifiers = (GreenNode?)reader.ReadValue();
            if (modifiers != null)
            {
                AdjustFlagsAndWidth(modifiers);
                this.modifiers = modifiers;
            }
            var eventKeyword = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(eventKeyword);
            this.eventKeyword = eventKeyword;
            var type = (TypeSyntax)reader.ReadValue();
            AdjustFlagsAndWidth(type);
            this.type = type;
            var explicitInterfaceSpecifier = (ExplicitInterfaceSpecifierSyntax?)reader.ReadValue();
            if (explicitInterfaceSpecifier != null)
            {
                AdjustFlagsAndWidth(explicitInterfaceSpecifier);
                this.explicitInterfaceSpecifier = explicitInterfaceSpecifier;
            }
            var identifier = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(identifier);
            this.identifier = identifier;
            var accessorList = (AccessorListSyntax?)reader.ReadValue();
            if (accessorList != null)
            {
                AdjustFlagsAndWidth(accessorList);
                this.accessorList = accessorList;
            }
            var semicolonToken = (SyntaxToken?)reader.ReadValue();
            if (semicolonToken != null)
            {
                AdjustFlagsAndWidth(semicolonToken);
                this.semicolonToken = semicolonToken;
            }
        }

        internal override void WriteTo(ObjectWriter writer)
        {
            base.WriteTo(writer);
            writer.WriteValue(this.attributeLists);
            writer.WriteValue(this.modifiers);
            writer.WriteValue(this.eventKeyword);
            writer.WriteValue(this.type);
            writer.WriteValue(this.explicitInterfaceSpecifier);
            writer.WriteValue(this.identifier);
            writer.WriteValue(this.accessorList);
            writer.WriteValue(this.semicolonToken);
        }

        static EventDeclarationSyntax()
        {
            ObjectBinder.RegisterTypeReader(typeof(EventDeclarationSyntax), r => new EventDeclarationSyntax(r));
        }
    }

    internal sealed partial class IndexerDeclarationSyntax : BasePropertyDeclarationSyntax
    {
        internal readonly GreenNode? attributeLists;
        internal readonly GreenNode? modifiers;
        internal readonly TypeSyntax type;
        internal readonly ExplicitInterfaceSpecifierSyntax? explicitInterfaceSpecifier;
        internal readonly SyntaxToken thisKeyword;
        internal readonly BracketedParameterListSyntax parameterList;
        internal readonly AccessorListSyntax? accessorList;
        internal readonly ArrowExpressionClauseSyntax? expressionBody;
        internal readonly SyntaxToken? semicolonToken;

        internal IndexerDeclarationSyntax(SyntaxKind kind, GreenNode? attributeLists, GreenNode? modifiers, TypeSyntax type, ExplicitInterfaceSpecifierSyntax? explicitInterfaceSpecifier, SyntaxToken thisKeyword, BracketedParameterListSyntax parameterList, AccessorListSyntax? accessorList, ArrowExpressionClauseSyntax? expressionBody, SyntaxToken? semicolonToken, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
            this.SlotCount = 9;
            if (attributeLists != null)
            {
                this.AdjustFlagsAndWidth(attributeLists);
                this.attributeLists = attributeLists;
            }
            if (modifiers != null)
            {
                this.AdjustFlagsAndWidth(modifiers);
                this.modifiers = modifiers;
            }
            this.AdjustFlagsAndWidth(type);
            this.type = type;
            if (explicitInterfaceSpecifier != null)
            {
                this.AdjustFlagsAndWidth(explicitInterfaceSpecifier);
                this.explicitInterfaceSpecifier = explicitInterfaceSpecifier;
            }
            this.AdjustFlagsAndWidth(thisKeyword);
            this.thisKeyword = thisKeyword;
            this.AdjustFlagsAndWidth(parameterList);
            this.parameterList = parameterList;
            if (accessorList != null)
            {
                this.AdjustFlagsAndWidth(accessorList);
                this.accessorList = accessorList;
            }
            if (expressionBody != null)
            {
                this.AdjustFlagsAndWidth(expressionBody);
                this.expressionBody = expressionBody;
            }
            if (semicolonToken != null)
            {
                this.AdjustFlagsAndWidth(semicolonToken);
                this.semicolonToken = semicolonToken;
            }
        }

        internal IndexerDeclarationSyntax(SyntaxKind kind, GreenNode? attributeLists, GreenNode? modifiers, TypeSyntax type, ExplicitInterfaceSpecifierSyntax? explicitInterfaceSpecifier, SyntaxToken thisKeyword, BracketedParameterListSyntax parameterList, AccessorListSyntax? accessorList, ArrowExpressionClauseSyntax? expressionBody, SyntaxToken? semicolonToken, SyntaxFactoryContext context)
          : base(kind)
        {
            this.SetFactoryContext(context);
            this.SlotCount = 9;
            if (attributeLists != null)
            {
                this.AdjustFlagsAndWidth(attributeLists);
                this.attributeLists = attributeLists;
            }
            if (modifiers != null)
            {
                this.AdjustFlagsAndWidth(modifiers);
                this.modifiers = modifiers;
            }
            this.AdjustFlagsAndWidth(type);
            this.type = type;
            if (explicitInterfaceSpecifier != null)
            {
                this.AdjustFlagsAndWidth(explicitInterfaceSpecifier);
                this.explicitInterfaceSpecifier = explicitInterfaceSpecifier;
            }
            this.AdjustFlagsAndWidth(thisKeyword);
            this.thisKeyword = thisKeyword;
            this.AdjustFlagsAndWidth(parameterList);
            this.parameterList = parameterList;
            if (accessorList != null)
            {
                this.AdjustFlagsAndWidth(accessorList);
                this.accessorList = accessorList;
            }
            if (expressionBody != null)
            {
                this.AdjustFlagsAndWidth(expressionBody);
                this.expressionBody = expressionBody;
            }
            if (semicolonToken != null)
            {
                this.AdjustFlagsAndWidth(semicolonToken);
                this.semicolonToken = semicolonToken;
            }
        }

        internal IndexerDeclarationSyntax(SyntaxKind kind, GreenNode? attributeLists, GreenNode? modifiers, TypeSyntax type, ExplicitInterfaceSpecifierSyntax? explicitInterfaceSpecifier, SyntaxToken thisKeyword, BracketedParameterListSyntax parameterList, AccessorListSyntax? accessorList, ArrowExpressionClauseSyntax? expressionBody, SyntaxToken? semicolonToken)
          : base(kind)
        {
            this.SlotCount = 9;
            if (attributeLists != null)
            {
                this.AdjustFlagsAndWidth(attributeLists);
                this.attributeLists = attributeLists;
            }
            if (modifiers != null)
            {
                this.AdjustFlagsAndWidth(modifiers);
                this.modifiers = modifiers;
            }
            this.AdjustFlagsAndWidth(type);
            this.type = type;
            if (explicitInterfaceSpecifier != null)
            {
                this.AdjustFlagsAndWidth(explicitInterfaceSpecifier);
                this.explicitInterfaceSpecifier = explicitInterfaceSpecifier;
            }
            this.AdjustFlagsAndWidth(thisKeyword);
            this.thisKeyword = thisKeyword;
            this.AdjustFlagsAndWidth(parameterList);
            this.parameterList = parameterList;
            if (accessorList != null)
            {
                this.AdjustFlagsAndWidth(accessorList);
                this.accessorList = accessorList;
            }
            if (expressionBody != null)
            {
                this.AdjustFlagsAndWidth(expressionBody);
                this.expressionBody = expressionBody;
            }
            if (semicolonToken != null)
            {
                this.AdjustFlagsAndWidth(semicolonToken);
                this.semicolonToken = semicolonToken;
            }
        }

        public override Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<AttributeListSyntax> AttributeLists => new Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<AttributeListSyntax>(this.attributeLists);
        public override Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SyntaxToken> Modifiers => new Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SyntaxToken>(this.modifiers);
        public override TypeSyntax Type => this.type;
        public override ExplicitInterfaceSpecifierSyntax? ExplicitInterfaceSpecifier => this.explicitInterfaceSpecifier;
        public SyntaxToken ThisKeyword => this.thisKeyword;
        /// <summary>Gets the parameter list.</summary>
        public BracketedParameterListSyntax ParameterList => this.parameterList;
        public override AccessorListSyntax? AccessorList => this.accessorList;
        public ArrowExpressionClauseSyntax? ExpressionBody => this.expressionBody;
        public SyntaxToken? SemicolonToken => this.semicolonToken;

        internal override GreenNode? GetSlot(int index)
            => index switch
            {
                0 => this.attributeLists,
                1 => this.modifiers,
                2 => this.type,
                3 => this.explicitInterfaceSpecifier,
                4 => this.thisKeyword,
                5 => this.parameterList,
                6 => this.accessorList,
                7 => this.expressionBody,
                8 => this.semicolonToken,
                _ => null,
            };

        internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new CSharp.Syntax.IndexerDeclarationSyntax(this, parent, position);

        public override void Accept(CSharpSyntaxVisitor visitor) => visitor.VisitIndexerDeclaration(this);
        public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor) => visitor.VisitIndexerDeclaration(this);

        public IndexerDeclarationSyntax Update(Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<AttributeListSyntax> attributeLists, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SyntaxToken> modifiers, TypeSyntax type, ExplicitInterfaceSpecifierSyntax explicitInterfaceSpecifier, SyntaxToken thisKeyword, BracketedParameterListSyntax parameterList, AccessorListSyntax accessorList, ArrowExpressionClauseSyntax expressionBody, SyntaxToken semicolonToken)
        {
            if (attributeLists != this.AttributeLists || modifiers != this.Modifiers || type != this.Type || explicitInterfaceSpecifier != this.ExplicitInterfaceSpecifier || thisKeyword != this.ThisKeyword || parameterList != this.ParameterList || accessorList != this.AccessorList || expressionBody != this.ExpressionBody || semicolonToken != this.SemicolonToken)
            {
                var newNode = SyntaxFactory.IndexerDeclaration(attributeLists, modifiers, type, explicitInterfaceSpecifier, thisKeyword, parameterList, accessorList, expressionBody, semicolonToken);
                var diags = GetDiagnostics();
                if (diags?.Length > 0)
                    newNode = newNode.WithDiagnosticsGreen(diags);
                var annotations = GetAnnotations();
                if (annotations?.Length > 0)
                    newNode = newNode.WithAnnotationsGreen(annotations);
                return newNode;
            }

            return this;
        }

        internal override GreenNode SetDiagnostics(DiagnosticInfo[]? diagnostics)
            => new IndexerDeclarationSyntax(this.Kind, this.attributeLists, this.modifiers, this.type, this.explicitInterfaceSpecifier, this.thisKeyword, this.parameterList, this.accessorList, this.expressionBody, this.semicolonToken, diagnostics, GetAnnotations());

        internal override GreenNode SetAnnotations(SyntaxAnnotation[]? annotations)
            => new IndexerDeclarationSyntax(this.Kind, this.attributeLists, this.modifiers, this.type, this.explicitInterfaceSpecifier, this.thisKeyword, this.parameterList, this.accessorList, this.expressionBody, this.semicolonToken, GetDiagnostics(), annotations);

        internal IndexerDeclarationSyntax(ObjectReader reader)
          : base(reader)
        {
            this.SlotCount = 9;
            var attributeLists = (GreenNode?)reader.ReadValue();
            if (attributeLists != null)
            {
                AdjustFlagsAndWidth(attributeLists);
                this.attributeLists = attributeLists;
            }
            var modifiers = (GreenNode?)reader.ReadValue();
            if (modifiers != null)
            {
                AdjustFlagsAndWidth(modifiers);
                this.modifiers = modifiers;
            }
            var type = (TypeSyntax)reader.ReadValue();
            AdjustFlagsAndWidth(type);
            this.type = type;
            var explicitInterfaceSpecifier = (ExplicitInterfaceSpecifierSyntax?)reader.ReadValue();
            if (explicitInterfaceSpecifier != null)
            {
                AdjustFlagsAndWidth(explicitInterfaceSpecifier);
                this.explicitInterfaceSpecifier = explicitInterfaceSpecifier;
            }
            var thisKeyword = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(thisKeyword);
            this.thisKeyword = thisKeyword;
            var parameterList = (BracketedParameterListSyntax)reader.ReadValue();
            AdjustFlagsAndWidth(parameterList);
            this.parameterList = parameterList;
            var accessorList = (AccessorListSyntax?)reader.ReadValue();
            if (accessorList != null)
            {
                AdjustFlagsAndWidth(accessorList);
                this.accessorList = accessorList;
            }
            var expressionBody = (ArrowExpressionClauseSyntax?)reader.ReadValue();
            if (expressionBody != null)
            {
                AdjustFlagsAndWidth(expressionBody);
                this.expressionBody = expressionBody;
            }
            var semicolonToken = (SyntaxToken?)reader.ReadValue();
            if (semicolonToken != null)
            {
                AdjustFlagsAndWidth(semicolonToken);
                this.semicolonToken = semicolonToken;
            }
        }

        internal override void WriteTo(ObjectWriter writer)
        {
            base.WriteTo(writer);
            writer.WriteValue(this.attributeLists);
            writer.WriteValue(this.modifiers);
            writer.WriteValue(this.type);
            writer.WriteValue(this.explicitInterfaceSpecifier);
            writer.WriteValue(this.thisKeyword);
            writer.WriteValue(this.parameterList);
            writer.WriteValue(this.accessorList);
            writer.WriteValue(this.expressionBody);
            writer.WriteValue(this.semicolonToken);
        }

        static IndexerDeclarationSyntax()
        {
            ObjectBinder.RegisterTypeReader(typeof(IndexerDeclarationSyntax), r => new IndexerDeclarationSyntax(r));
        }
    }

    internal sealed partial class AccessorListSyntax : CSharpSyntaxNode
    {
        internal readonly SyntaxToken openBraceToken;
        internal readonly GreenNode? accessors;
        internal readonly SyntaxToken closeBraceToken;

        internal AccessorListSyntax(SyntaxKind kind, SyntaxToken openBraceToken, GreenNode? accessors, SyntaxToken closeBraceToken, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
            this.SlotCount = 3;
            this.AdjustFlagsAndWidth(openBraceToken);
            this.openBraceToken = openBraceToken;
            if (accessors != null)
            {
                this.AdjustFlagsAndWidth(accessors);
                this.accessors = accessors;
            }
            this.AdjustFlagsAndWidth(closeBraceToken);
            this.closeBraceToken = closeBraceToken;
        }

        internal AccessorListSyntax(SyntaxKind kind, SyntaxToken openBraceToken, GreenNode? accessors, SyntaxToken closeBraceToken, SyntaxFactoryContext context)
          : base(kind)
        {
            this.SetFactoryContext(context);
            this.SlotCount = 3;
            this.AdjustFlagsAndWidth(openBraceToken);
            this.openBraceToken = openBraceToken;
            if (accessors != null)
            {
                this.AdjustFlagsAndWidth(accessors);
                this.accessors = accessors;
            }
            this.AdjustFlagsAndWidth(closeBraceToken);
            this.closeBraceToken = closeBraceToken;
        }

        internal AccessorListSyntax(SyntaxKind kind, SyntaxToken openBraceToken, GreenNode? accessors, SyntaxToken closeBraceToken)
          : base(kind)
        {
            this.SlotCount = 3;
            this.AdjustFlagsAndWidth(openBraceToken);
            this.openBraceToken = openBraceToken;
            if (accessors != null)
            {
                this.AdjustFlagsAndWidth(accessors);
                this.accessors = accessors;
            }
            this.AdjustFlagsAndWidth(closeBraceToken);
            this.closeBraceToken = closeBraceToken;
        }

        public SyntaxToken OpenBraceToken => this.openBraceToken;
        public Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<AccessorDeclarationSyntax> Accessors => new Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<AccessorDeclarationSyntax>(this.accessors);
        public SyntaxToken CloseBraceToken => this.closeBraceToken;

        internal override GreenNode? GetSlot(int index)
            => index switch
            {
                0 => this.openBraceToken,
                1 => this.accessors,
                2 => this.closeBraceToken,
                _ => null,
            };

        internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new CSharp.Syntax.AccessorListSyntax(this, parent, position);

        public override void Accept(CSharpSyntaxVisitor visitor) => visitor.VisitAccessorList(this);
        public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor) => visitor.VisitAccessorList(this);

        public AccessorListSyntax Update(SyntaxToken openBraceToken, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<AccessorDeclarationSyntax> accessors, SyntaxToken closeBraceToken)
        {
            if (openBraceToken != this.OpenBraceToken || accessors != this.Accessors || closeBraceToken != this.CloseBraceToken)
            {
                var newNode = SyntaxFactory.AccessorList(openBraceToken, accessors, closeBraceToken);
                var diags = GetDiagnostics();
                if (diags?.Length > 0)
                    newNode = newNode.WithDiagnosticsGreen(diags);
                var annotations = GetAnnotations();
                if (annotations?.Length > 0)
                    newNode = newNode.WithAnnotationsGreen(annotations);
                return newNode;
            }

            return this;
        }

        internal override GreenNode SetDiagnostics(DiagnosticInfo[]? diagnostics)
            => new AccessorListSyntax(this.Kind, this.openBraceToken, this.accessors, this.closeBraceToken, diagnostics, GetAnnotations());

        internal override GreenNode SetAnnotations(SyntaxAnnotation[]? annotations)
            => new AccessorListSyntax(this.Kind, this.openBraceToken, this.accessors, this.closeBraceToken, GetDiagnostics(), annotations);

        internal AccessorListSyntax(ObjectReader reader)
          : base(reader)
        {
            this.SlotCount = 3;
            var openBraceToken = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(openBraceToken);
            this.openBraceToken = openBraceToken;
            var accessors = (GreenNode?)reader.ReadValue();
            if (accessors != null)
            {
                AdjustFlagsAndWidth(accessors);
                this.accessors = accessors;
            }
            var closeBraceToken = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(closeBraceToken);
            this.closeBraceToken = closeBraceToken;
        }

        internal override void WriteTo(ObjectWriter writer)
        {
            base.WriteTo(writer);
            writer.WriteValue(this.openBraceToken);
            writer.WriteValue(this.accessors);
            writer.WriteValue(this.closeBraceToken);
        }

        static AccessorListSyntax()
        {
            ObjectBinder.RegisterTypeReader(typeof(AccessorListSyntax), r => new AccessorListSyntax(r));
        }
    }

    internal sealed partial class AccessorDeclarationSyntax : CSharpSyntaxNode
    {
        internal readonly GreenNode? attributeLists;
        internal readonly GreenNode? modifiers;
        internal readonly SyntaxToken keyword;
        internal readonly BlockSyntax? body;
        internal readonly ArrowExpressionClauseSyntax? expressionBody;
        internal readonly SyntaxToken? semicolonToken;

        internal AccessorDeclarationSyntax(SyntaxKind kind, GreenNode? attributeLists, GreenNode? modifiers, SyntaxToken keyword, BlockSyntax? body, ArrowExpressionClauseSyntax? expressionBody, SyntaxToken? semicolonToken, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
            this.SlotCount = 6;
            if (attributeLists != null)
            {
                this.AdjustFlagsAndWidth(attributeLists);
                this.attributeLists = attributeLists;
            }
            if (modifiers != null)
            {
                this.AdjustFlagsAndWidth(modifiers);
                this.modifiers = modifiers;
            }
            this.AdjustFlagsAndWidth(keyword);
            this.keyword = keyword;
            if (body != null)
            {
                this.AdjustFlagsAndWidth(body);
                this.body = body;
            }
            if (expressionBody != null)
            {
                this.AdjustFlagsAndWidth(expressionBody);
                this.expressionBody = expressionBody;
            }
            if (semicolonToken != null)
            {
                this.AdjustFlagsAndWidth(semicolonToken);
                this.semicolonToken = semicolonToken;
            }
        }

        internal AccessorDeclarationSyntax(SyntaxKind kind, GreenNode? attributeLists, GreenNode? modifiers, SyntaxToken keyword, BlockSyntax? body, ArrowExpressionClauseSyntax? expressionBody, SyntaxToken? semicolonToken, SyntaxFactoryContext context)
          : base(kind)
        {
            this.SetFactoryContext(context);
            this.SlotCount = 6;
            if (attributeLists != null)
            {
                this.AdjustFlagsAndWidth(attributeLists);
                this.attributeLists = attributeLists;
            }
            if (modifiers != null)
            {
                this.AdjustFlagsAndWidth(modifiers);
                this.modifiers = modifiers;
            }
            this.AdjustFlagsAndWidth(keyword);
            this.keyword = keyword;
            if (body != null)
            {
                this.AdjustFlagsAndWidth(body);
                this.body = body;
            }
            if (expressionBody != null)
            {
                this.AdjustFlagsAndWidth(expressionBody);
                this.expressionBody = expressionBody;
            }
            if (semicolonToken != null)
            {
                this.AdjustFlagsAndWidth(semicolonToken);
                this.semicolonToken = semicolonToken;
            }
        }

        internal AccessorDeclarationSyntax(SyntaxKind kind, GreenNode? attributeLists, GreenNode? modifiers, SyntaxToken keyword, BlockSyntax? body, ArrowExpressionClauseSyntax? expressionBody, SyntaxToken? semicolonToken)
          : base(kind)
        {
            this.SlotCount = 6;
            if (attributeLists != null)
            {
                this.AdjustFlagsAndWidth(attributeLists);
                this.attributeLists = attributeLists;
            }
            if (modifiers != null)
            {
                this.AdjustFlagsAndWidth(modifiers);
                this.modifiers = modifiers;
            }
            this.AdjustFlagsAndWidth(keyword);
            this.keyword = keyword;
            if (body != null)
            {
                this.AdjustFlagsAndWidth(body);
                this.body = body;
            }
            if (expressionBody != null)
            {
                this.AdjustFlagsAndWidth(expressionBody);
                this.expressionBody = expressionBody;
            }
            if (semicolonToken != null)
            {
                this.AdjustFlagsAndWidth(semicolonToken);
                this.semicolonToken = semicolonToken;
            }
        }

        /// <summary>Gets the attribute declaration list.</summary>
        public Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<AttributeListSyntax> AttributeLists => new Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<AttributeListSyntax>(this.attributeLists);
        /// <summary>Gets the modifier list.</summary>
        public Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SyntaxToken> Modifiers => new Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SyntaxToken>(this.modifiers);
        /// <summary>Gets the keyword token, or identifier if an erroneous accessor declaration.</summary>
        public SyntaxToken Keyword => this.keyword;
        /// <summary>Gets the optional body block which may be empty, but it is null if there are no braces.</summary>
        public BlockSyntax? Body => this.body;
        /// <summary>Gets the optional expression body.</summary>
        public ArrowExpressionClauseSyntax? ExpressionBody => this.expressionBody;
        /// <summary>Gets the optional semicolon token.</summary>
        public SyntaxToken? SemicolonToken => this.semicolonToken;

        internal override GreenNode? GetSlot(int index)
            => index switch
            {
                0 => this.attributeLists,
                1 => this.modifiers,
                2 => this.keyword,
                3 => this.body,
                4 => this.expressionBody,
                5 => this.semicolonToken,
                _ => null,
            };

        internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new CSharp.Syntax.AccessorDeclarationSyntax(this, parent, position);

        public override void Accept(CSharpSyntaxVisitor visitor) => visitor.VisitAccessorDeclaration(this);
        public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor) => visitor.VisitAccessorDeclaration(this);

        public AccessorDeclarationSyntax Update(Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<AttributeListSyntax> attributeLists, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SyntaxToken> modifiers, SyntaxToken keyword, BlockSyntax body, ArrowExpressionClauseSyntax expressionBody, SyntaxToken semicolonToken)
        {
            if (attributeLists != this.AttributeLists || modifiers != this.Modifiers || keyword != this.Keyword || body != this.Body || expressionBody != this.ExpressionBody || semicolonToken != this.SemicolonToken)
            {
                var newNode = SyntaxFactory.AccessorDeclaration(this.Kind, attributeLists, modifiers, keyword, body, expressionBody, semicolonToken);
                var diags = GetDiagnostics();
                if (diags?.Length > 0)
                    newNode = newNode.WithDiagnosticsGreen(diags);
                var annotations = GetAnnotations();
                if (annotations?.Length > 0)
                    newNode = newNode.WithAnnotationsGreen(annotations);
                return newNode;
            }

            return this;
        }

        internal override GreenNode SetDiagnostics(DiagnosticInfo[]? diagnostics)
            => new AccessorDeclarationSyntax(this.Kind, this.attributeLists, this.modifiers, this.keyword, this.body, this.expressionBody, this.semicolonToken, diagnostics, GetAnnotations());

        internal override GreenNode SetAnnotations(SyntaxAnnotation[]? annotations)
            => new AccessorDeclarationSyntax(this.Kind, this.attributeLists, this.modifiers, this.keyword, this.body, this.expressionBody, this.semicolonToken, GetDiagnostics(), annotations);

        internal AccessorDeclarationSyntax(ObjectReader reader)
          : base(reader)
        {
            this.SlotCount = 6;
            var attributeLists = (GreenNode?)reader.ReadValue();
            if (attributeLists != null)
            {
                AdjustFlagsAndWidth(attributeLists);
                this.attributeLists = attributeLists;
            }
            var modifiers = (GreenNode?)reader.ReadValue();
            if (modifiers != null)
            {
                AdjustFlagsAndWidth(modifiers);
                this.modifiers = modifiers;
            }
            var keyword = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(keyword);
            this.keyword = keyword;
            var body = (BlockSyntax?)reader.ReadValue();
            if (body != null)
            {
                AdjustFlagsAndWidth(body);
                this.body = body;
            }
            var expressionBody = (ArrowExpressionClauseSyntax?)reader.ReadValue();
            if (expressionBody != null)
            {
                AdjustFlagsAndWidth(expressionBody);
                this.expressionBody = expressionBody;
            }
            var semicolonToken = (SyntaxToken?)reader.ReadValue();
            if (semicolonToken != null)
            {
                AdjustFlagsAndWidth(semicolonToken);
                this.semicolonToken = semicolonToken;
            }
        }

        internal override void WriteTo(ObjectWriter writer)
        {
            base.WriteTo(writer);
            writer.WriteValue(this.attributeLists);
            writer.WriteValue(this.modifiers);
            writer.WriteValue(this.keyword);
            writer.WriteValue(this.body);
            writer.WriteValue(this.expressionBody);
            writer.WriteValue(this.semicolonToken);
        }

        static AccessorDeclarationSyntax()
        {
            ObjectBinder.RegisterTypeReader(typeof(AccessorDeclarationSyntax), r => new AccessorDeclarationSyntax(r));
        }
    }

    /// <summary>Base type for parameter list syntax.</summary>
    internal abstract partial class BaseParameterListSyntax : CSharpSyntaxNode
    {
        internal BaseParameterListSyntax(SyntaxKind kind, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
        }

        internal BaseParameterListSyntax(SyntaxKind kind)
          : base(kind)
        {
        }

        protected BaseParameterListSyntax(ObjectReader reader)
          : base(reader)
        {
        }

        /// <summary>Gets the parameter list.</summary>
        public abstract Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<ParameterSyntax> Parameters { get; }
    }

    /// <summary>Parameter list syntax.</summary>
    internal sealed partial class ParameterListSyntax : BaseParameterListSyntax
    {
        internal readonly SyntaxToken openParenToken;
        internal readonly GreenNode? parameters;
        internal readonly SyntaxToken closeParenToken;

        internal ParameterListSyntax(SyntaxKind kind, SyntaxToken openParenToken, GreenNode? parameters, SyntaxToken closeParenToken, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
            this.SlotCount = 3;
            this.AdjustFlagsAndWidth(openParenToken);
            this.openParenToken = openParenToken;
            if (parameters != null)
            {
                this.AdjustFlagsAndWidth(parameters);
                this.parameters = parameters;
            }
            this.AdjustFlagsAndWidth(closeParenToken);
            this.closeParenToken = closeParenToken;
        }

        internal ParameterListSyntax(SyntaxKind kind, SyntaxToken openParenToken, GreenNode? parameters, SyntaxToken closeParenToken, SyntaxFactoryContext context)
          : base(kind)
        {
            this.SetFactoryContext(context);
            this.SlotCount = 3;
            this.AdjustFlagsAndWidth(openParenToken);
            this.openParenToken = openParenToken;
            if (parameters != null)
            {
                this.AdjustFlagsAndWidth(parameters);
                this.parameters = parameters;
            }
            this.AdjustFlagsAndWidth(closeParenToken);
            this.closeParenToken = closeParenToken;
        }

        internal ParameterListSyntax(SyntaxKind kind, SyntaxToken openParenToken, GreenNode? parameters, SyntaxToken closeParenToken)
          : base(kind)
        {
            this.SlotCount = 3;
            this.AdjustFlagsAndWidth(openParenToken);
            this.openParenToken = openParenToken;
            if (parameters != null)
            {
                this.AdjustFlagsAndWidth(parameters);
                this.parameters = parameters;
            }
            this.AdjustFlagsAndWidth(closeParenToken);
            this.closeParenToken = closeParenToken;
        }

        /// <summary>Gets the open paren token.</summary>
        public SyntaxToken OpenParenToken => this.openParenToken;
        public override Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<ParameterSyntax> Parameters => new Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<ParameterSyntax>(new Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<CSharpSyntaxNode>(this.parameters));
        /// <summary>Gets the close paren token.</summary>
        public SyntaxToken CloseParenToken => this.closeParenToken;

        internal override GreenNode? GetSlot(int index)
            => index switch
            {
                0 => this.openParenToken,
                1 => this.parameters,
                2 => this.closeParenToken,
                _ => null,
            };

        internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new CSharp.Syntax.ParameterListSyntax(this, parent, position);

        public override void Accept(CSharpSyntaxVisitor visitor) => visitor.VisitParameterList(this);
        public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor) => visitor.VisitParameterList(this);

        public ParameterListSyntax Update(SyntaxToken openParenToken, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<ParameterSyntax> parameters, SyntaxToken closeParenToken)
        {
            if (openParenToken != this.OpenParenToken || parameters != this.Parameters || closeParenToken != this.CloseParenToken)
            {
                var newNode = SyntaxFactory.ParameterList(openParenToken, parameters, closeParenToken);
                var diags = GetDiagnostics();
                if (diags?.Length > 0)
                    newNode = newNode.WithDiagnosticsGreen(diags);
                var annotations = GetAnnotations();
                if (annotations?.Length > 0)
                    newNode = newNode.WithAnnotationsGreen(annotations);
                return newNode;
            }

            return this;
        }

        internal override GreenNode SetDiagnostics(DiagnosticInfo[]? diagnostics)
            => new ParameterListSyntax(this.Kind, this.openParenToken, this.parameters, this.closeParenToken, diagnostics, GetAnnotations());

        internal override GreenNode SetAnnotations(SyntaxAnnotation[]? annotations)
            => new ParameterListSyntax(this.Kind, this.openParenToken, this.parameters, this.closeParenToken, GetDiagnostics(), annotations);

        internal ParameterListSyntax(ObjectReader reader)
          : base(reader)
        {
            this.SlotCount = 3;
            var openParenToken = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(openParenToken);
            this.openParenToken = openParenToken;
            var parameters = (GreenNode?)reader.ReadValue();
            if (parameters != null)
            {
                AdjustFlagsAndWidth(parameters);
                this.parameters = parameters;
            }
            var closeParenToken = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(closeParenToken);
            this.closeParenToken = closeParenToken;
        }

        internal override void WriteTo(ObjectWriter writer)
        {
            base.WriteTo(writer);
            writer.WriteValue(this.openParenToken);
            writer.WriteValue(this.parameters);
            writer.WriteValue(this.closeParenToken);
        }

        static ParameterListSyntax()
        {
            ObjectBinder.RegisterTypeReader(typeof(ParameterListSyntax), r => new ParameterListSyntax(r));
        }
    }

    /// <summary>Parameter list syntax with surrounding brackets.</summary>
    internal sealed partial class BracketedParameterListSyntax : BaseParameterListSyntax
    {
        internal readonly SyntaxToken openBracketToken;
        internal readonly GreenNode? parameters;
        internal readonly SyntaxToken closeBracketToken;

        internal BracketedParameterListSyntax(SyntaxKind kind, SyntaxToken openBracketToken, GreenNode? parameters, SyntaxToken closeBracketToken, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
            this.SlotCount = 3;
            this.AdjustFlagsAndWidth(openBracketToken);
            this.openBracketToken = openBracketToken;
            if (parameters != null)
            {
                this.AdjustFlagsAndWidth(parameters);
                this.parameters = parameters;
            }
            this.AdjustFlagsAndWidth(closeBracketToken);
            this.closeBracketToken = closeBracketToken;
        }

        internal BracketedParameterListSyntax(SyntaxKind kind, SyntaxToken openBracketToken, GreenNode? parameters, SyntaxToken closeBracketToken, SyntaxFactoryContext context)
          : base(kind)
        {
            this.SetFactoryContext(context);
            this.SlotCount = 3;
            this.AdjustFlagsAndWidth(openBracketToken);
            this.openBracketToken = openBracketToken;
            if (parameters != null)
            {
                this.AdjustFlagsAndWidth(parameters);
                this.parameters = parameters;
            }
            this.AdjustFlagsAndWidth(closeBracketToken);
            this.closeBracketToken = closeBracketToken;
        }

        internal BracketedParameterListSyntax(SyntaxKind kind, SyntaxToken openBracketToken, GreenNode? parameters, SyntaxToken closeBracketToken)
          : base(kind)
        {
            this.SlotCount = 3;
            this.AdjustFlagsAndWidth(openBracketToken);
            this.openBracketToken = openBracketToken;
            if (parameters != null)
            {
                this.AdjustFlagsAndWidth(parameters);
                this.parameters = parameters;
            }
            this.AdjustFlagsAndWidth(closeBracketToken);
            this.closeBracketToken = closeBracketToken;
        }

        /// <summary>Gets the open bracket token.</summary>
        public SyntaxToken OpenBracketToken => this.openBracketToken;
        public override Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<ParameterSyntax> Parameters => new Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<ParameterSyntax>(new Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<CSharpSyntaxNode>(this.parameters));
        /// <summary>Gets the close bracket token.</summary>
        public SyntaxToken CloseBracketToken => this.closeBracketToken;

        internal override GreenNode? GetSlot(int index)
            => index switch
            {
                0 => this.openBracketToken,
                1 => this.parameters,
                2 => this.closeBracketToken,
                _ => null,
            };

        internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new CSharp.Syntax.BracketedParameterListSyntax(this, parent, position);

        public override void Accept(CSharpSyntaxVisitor visitor) => visitor.VisitBracketedParameterList(this);
        public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor) => visitor.VisitBracketedParameterList(this);

        public BracketedParameterListSyntax Update(SyntaxToken openBracketToken, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<ParameterSyntax> parameters, SyntaxToken closeBracketToken)
        {
            if (openBracketToken != this.OpenBracketToken || parameters != this.Parameters || closeBracketToken != this.CloseBracketToken)
            {
                var newNode = SyntaxFactory.BracketedParameterList(openBracketToken, parameters, closeBracketToken);
                var diags = GetDiagnostics();
                if (diags?.Length > 0)
                    newNode = newNode.WithDiagnosticsGreen(diags);
                var annotations = GetAnnotations();
                if (annotations?.Length > 0)
                    newNode = newNode.WithAnnotationsGreen(annotations);
                return newNode;
            }

            return this;
        }

        internal override GreenNode SetDiagnostics(DiagnosticInfo[]? diagnostics)
            => new BracketedParameterListSyntax(this.Kind, this.openBracketToken, this.parameters, this.closeBracketToken, diagnostics, GetAnnotations());

        internal override GreenNode SetAnnotations(SyntaxAnnotation[]? annotations)
            => new BracketedParameterListSyntax(this.Kind, this.openBracketToken, this.parameters, this.closeBracketToken, GetDiagnostics(), annotations);

        internal BracketedParameterListSyntax(ObjectReader reader)
          : base(reader)
        {
            this.SlotCount = 3;
            var openBracketToken = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(openBracketToken);
            this.openBracketToken = openBracketToken;
            var parameters = (GreenNode?)reader.ReadValue();
            if (parameters != null)
            {
                AdjustFlagsAndWidth(parameters);
                this.parameters = parameters;
            }
            var closeBracketToken = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(closeBracketToken);
            this.closeBracketToken = closeBracketToken;
        }

        internal override void WriteTo(ObjectWriter writer)
        {
            base.WriteTo(writer);
            writer.WriteValue(this.openBracketToken);
            writer.WriteValue(this.parameters);
            writer.WriteValue(this.closeBracketToken);
        }

        static BracketedParameterListSyntax()
        {
            ObjectBinder.RegisterTypeReader(typeof(BracketedParameterListSyntax), r => new BracketedParameterListSyntax(r));
        }
    }

    /// <summary>Base parameter syntax.</summary>
    internal abstract partial class BaseParameterSyntax : CSharpSyntaxNode
    {
        internal BaseParameterSyntax(SyntaxKind kind, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
        }

        internal BaseParameterSyntax(SyntaxKind kind)
          : base(kind)
        {
        }

        protected BaseParameterSyntax(ObjectReader reader)
          : base(reader)
        {
        }

        /// <summary>Gets the attribute declaration list.</summary>
        public abstract Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<AttributeListSyntax> AttributeLists { get; }

        /// <summary>Gets the modifier list.</summary>
        public abstract Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SyntaxToken> Modifiers { get; }

        public abstract TypeSyntax? Type { get; }
    }

    /// <summary>Parameter syntax.</summary>
    internal sealed partial class ParameterSyntax : BaseParameterSyntax
    {
        internal readonly GreenNode? attributeLists;
        internal readonly GreenNode? modifiers;
        internal readonly TypeSyntax? type;
        internal readonly SyntaxToken identifier;
        internal readonly EqualsValueClauseSyntax? @default;

        internal ParameterSyntax(SyntaxKind kind, GreenNode? attributeLists, GreenNode? modifiers, TypeSyntax? type, SyntaxToken identifier, EqualsValueClauseSyntax? @default, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
            this.SlotCount = 5;
            if (attributeLists != null)
            {
                this.AdjustFlagsAndWidth(attributeLists);
                this.attributeLists = attributeLists;
            }
            if (modifiers != null)
            {
                this.AdjustFlagsAndWidth(modifiers);
                this.modifiers = modifiers;
            }
            if (type != null)
            {
                this.AdjustFlagsAndWidth(type);
                this.type = type;
            }
            this.AdjustFlagsAndWidth(identifier);
            this.identifier = identifier;
            if (@default != null)
            {
                this.AdjustFlagsAndWidth(@default);
                this.@default = @default;
            }
        }

        internal ParameterSyntax(SyntaxKind kind, GreenNode? attributeLists, GreenNode? modifiers, TypeSyntax? type, SyntaxToken identifier, EqualsValueClauseSyntax? @default, SyntaxFactoryContext context)
          : base(kind)
        {
            this.SetFactoryContext(context);
            this.SlotCount = 5;
            if (attributeLists != null)
            {
                this.AdjustFlagsAndWidth(attributeLists);
                this.attributeLists = attributeLists;
            }
            if (modifiers != null)
            {
                this.AdjustFlagsAndWidth(modifiers);
                this.modifiers = modifiers;
            }
            if (type != null)
            {
                this.AdjustFlagsAndWidth(type);
                this.type = type;
            }
            this.AdjustFlagsAndWidth(identifier);
            this.identifier = identifier;
            if (@default != null)
            {
                this.AdjustFlagsAndWidth(@default);
                this.@default = @default;
            }
        }

        internal ParameterSyntax(SyntaxKind kind, GreenNode? attributeLists, GreenNode? modifiers, TypeSyntax? type, SyntaxToken identifier, EqualsValueClauseSyntax? @default)
          : base(kind)
        {
            this.SlotCount = 5;
            if (attributeLists != null)
            {
                this.AdjustFlagsAndWidth(attributeLists);
                this.attributeLists = attributeLists;
            }
            if (modifiers != null)
            {
                this.AdjustFlagsAndWidth(modifiers);
                this.modifiers = modifiers;
            }
            if (type != null)
            {
                this.AdjustFlagsAndWidth(type);
                this.type = type;
            }
            this.AdjustFlagsAndWidth(identifier);
            this.identifier = identifier;
            if (@default != null)
            {
                this.AdjustFlagsAndWidth(@default);
                this.@default = @default;
            }
        }

        /// <summary>Gets the attribute declaration list.</summary>
        public override Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<AttributeListSyntax> AttributeLists => new Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<AttributeListSyntax>(this.attributeLists);
        /// <summary>Gets the modifier list.</summary>
        public override Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SyntaxToken> Modifiers => new Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SyntaxToken>(this.modifiers);
        public override TypeSyntax? Type => this.type;
        /// <summary>Gets the identifier.</summary>
        public SyntaxToken Identifier => this.identifier;
        public EqualsValueClauseSyntax? Default => this.@default;

        internal override GreenNode? GetSlot(int index)
            => index switch
            {
                0 => this.attributeLists,
                1 => this.modifiers,
                2 => this.type,
                3 => this.identifier,
                4 => this.@default,
                _ => null,
            };

        internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new CSharp.Syntax.ParameterSyntax(this, parent, position);

        public override void Accept(CSharpSyntaxVisitor visitor) => visitor.VisitParameter(this);
        public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor) => visitor.VisitParameter(this);

        public ParameterSyntax Update(Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<AttributeListSyntax> attributeLists, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SyntaxToken> modifiers, TypeSyntax type, SyntaxToken identifier, EqualsValueClauseSyntax @default)
        {
            if (attributeLists != this.AttributeLists || modifiers != this.Modifiers || type != this.Type || identifier != this.Identifier || @default != this.Default)
            {
                var newNode = SyntaxFactory.Parameter(attributeLists, modifiers, type, identifier, @default);
                var diags = GetDiagnostics();
                if (diags?.Length > 0)
                    newNode = newNode.WithDiagnosticsGreen(diags);
                var annotations = GetAnnotations();
                if (annotations?.Length > 0)
                    newNode = newNode.WithAnnotationsGreen(annotations);
                return newNode;
            }

            return this;
        }

        internal override GreenNode SetDiagnostics(DiagnosticInfo[]? diagnostics)
            => new ParameterSyntax(this.Kind, this.attributeLists, this.modifiers, this.type, this.identifier, this.@default, diagnostics, GetAnnotations());

        internal override GreenNode SetAnnotations(SyntaxAnnotation[]? annotations)
            => new ParameterSyntax(this.Kind, this.attributeLists, this.modifiers, this.type, this.identifier, this.@default, GetDiagnostics(), annotations);

        internal ParameterSyntax(ObjectReader reader)
          : base(reader)
        {
            this.SlotCount = 5;
            var attributeLists = (GreenNode?)reader.ReadValue();
            if (attributeLists != null)
            {
                AdjustFlagsAndWidth(attributeLists);
                this.attributeLists = attributeLists;
            }
            var modifiers = (GreenNode?)reader.ReadValue();
            if (modifiers != null)
            {
                AdjustFlagsAndWidth(modifiers);
                this.modifiers = modifiers;
            }
            var type = (TypeSyntax?)reader.ReadValue();
            if (type != null)
            {
                AdjustFlagsAndWidth(type);
                this.type = type;
            }
            var identifier = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(identifier);
            this.identifier = identifier;
            var @default = (EqualsValueClauseSyntax?)reader.ReadValue();
            if (@default != null)
            {
                AdjustFlagsAndWidth(@default);
                this.@default = @default;
            }
        }

        internal override void WriteTo(ObjectWriter writer)
        {
            base.WriteTo(writer);
            writer.WriteValue(this.attributeLists);
            writer.WriteValue(this.modifiers);
            writer.WriteValue(this.type);
            writer.WriteValue(this.identifier);
            writer.WriteValue(this.@default);
        }

        static ParameterSyntax()
        {
            ObjectBinder.RegisterTypeReader(typeof(ParameterSyntax), r => new ParameterSyntax(r));
        }
    }

    /// <summary>Parameter syntax.</summary>
    internal sealed partial class FunctionPointerParameterSyntax : BaseParameterSyntax
    {
        internal readonly GreenNode? attributeLists;
        internal readonly GreenNode? modifiers;
        internal readonly TypeSyntax type;

        internal FunctionPointerParameterSyntax(SyntaxKind kind, GreenNode? attributeLists, GreenNode? modifiers, TypeSyntax type, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
            this.SlotCount = 3;
            if (attributeLists != null)
            {
                this.AdjustFlagsAndWidth(attributeLists);
                this.attributeLists = attributeLists;
            }
            if (modifiers != null)
            {
                this.AdjustFlagsAndWidth(modifiers);
                this.modifiers = modifiers;
            }
            this.AdjustFlagsAndWidth(type);
            this.type = type;
        }

        internal FunctionPointerParameterSyntax(SyntaxKind kind, GreenNode? attributeLists, GreenNode? modifiers, TypeSyntax type, SyntaxFactoryContext context)
          : base(kind)
        {
            this.SetFactoryContext(context);
            this.SlotCount = 3;
            if (attributeLists != null)
            {
                this.AdjustFlagsAndWidth(attributeLists);
                this.attributeLists = attributeLists;
            }
            if (modifiers != null)
            {
                this.AdjustFlagsAndWidth(modifiers);
                this.modifiers = modifiers;
            }
            this.AdjustFlagsAndWidth(type);
            this.type = type;
        }

        internal FunctionPointerParameterSyntax(SyntaxKind kind, GreenNode? attributeLists, GreenNode? modifiers, TypeSyntax type)
          : base(kind)
        {
            this.SlotCount = 3;
            if (attributeLists != null)
            {
                this.AdjustFlagsAndWidth(attributeLists);
                this.attributeLists = attributeLists;
            }
            if (modifiers != null)
            {
                this.AdjustFlagsAndWidth(modifiers);
                this.modifiers = modifiers;
            }
            this.AdjustFlagsAndWidth(type);
            this.type = type;
        }

        /// <summary>Gets the attribute declaration list.</summary>
        public override Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<AttributeListSyntax> AttributeLists => new Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<AttributeListSyntax>(this.attributeLists);
        /// <summary>Gets the modifier list.</summary>
        public override Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SyntaxToken> Modifiers => new Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SyntaxToken>(this.modifiers);
        public override TypeSyntax Type => this.type;

        internal override GreenNode? GetSlot(int index)
            => index switch
            {
                0 => this.attributeLists,
                1 => this.modifiers,
                2 => this.type,
                _ => null,
            };

        internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new CSharp.Syntax.FunctionPointerParameterSyntax(this, parent, position);

        public override void Accept(CSharpSyntaxVisitor visitor) => visitor.VisitFunctionPointerParameter(this);
        public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor) => visitor.VisitFunctionPointerParameter(this);

        public FunctionPointerParameterSyntax Update(Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<AttributeListSyntax> attributeLists, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SyntaxToken> modifiers, TypeSyntax type)
        {
            if (attributeLists != this.AttributeLists || modifiers != this.Modifiers || type != this.Type)
            {
                var newNode = SyntaxFactory.FunctionPointerParameter(attributeLists, modifiers, type);
                var diags = GetDiagnostics();
                if (diags?.Length > 0)
                    newNode = newNode.WithDiagnosticsGreen(diags);
                var annotations = GetAnnotations();
                if (annotations?.Length > 0)
                    newNode = newNode.WithAnnotationsGreen(annotations);
                return newNode;
            }

            return this;
        }

        internal override GreenNode SetDiagnostics(DiagnosticInfo[]? diagnostics)
            => new FunctionPointerParameterSyntax(this.Kind, this.attributeLists, this.modifiers, this.type, diagnostics, GetAnnotations());

        internal override GreenNode SetAnnotations(SyntaxAnnotation[]? annotations)
            => new FunctionPointerParameterSyntax(this.Kind, this.attributeLists, this.modifiers, this.type, GetDiagnostics(), annotations);

        internal FunctionPointerParameterSyntax(ObjectReader reader)
          : base(reader)
        {
            this.SlotCount = 3;
            var attributeLists = (GreenNode?)reader.ReadValue();
            if (attributeLists != null)
            {
                AdjustFlagsAndWidth(attributeLists);
                this.attributeLists = attributeLists;
            }
            var modifiers = (GreenNode?)reader.ReadValue();
            if (modifiers != null)
            {
                AdjustFlagsAndWidth(modifiers);
                this.modifiers = modifiers;
            }
            var type = (TypeSyntax)reader.ReadValue();
            AdjustFlagsAndWidth(type);
            this.type = type;
        }

        internal override void WriteTo(ObjectWriter writer)
        {
            base.WriteTo(writer);
            writer.WriteValue(this.attributeLists);
            writer.WriteValue(this.modifiers);
            writer.WriteValue(this.type);
        }

        static FunctionPointerParameterSyntax()
        {
            ObjectBinder.RegisterTypeReader(typeof(FunctionPointerParameterSyntax), r => new FunctionPointerParameterSyntax(r));
        }
    }

    internal sealed partial class IncompleteMemberSyntax : MemberDeclarationSyntax
    {
        internal readonly GreenNode? attributeLists;
        internal readonly GreenNode? modifiers;
        internal readonly TypeSyntax? type;

        internal IncompleteMemberSyntax(SyntaxKind kind, GreenNode? attributeLists, GreenNode? modifiers, TypeSyntax? type, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
            this.SlotCount = 3;
            if (attributeLists != null)
            {
                this.AdjustFlagsAndWidth(attributeLists);
                this.attributeLists = attributeLists;
            }
            if (modifiers != null)
            {
                this.AdjustFlagsAndWidth(modifiers);
                this.modifiers = modifiers;
            }
            if (type != null)
            {
                this.AdjustFlagsAndWidth(type);
                this.type = type;
            }
        }

        internal IncompleteMemberSyntax(SyntaxKind kind, GreenNode? attributeLists, GreenNode? modifiers, TypeSyntax? type, SyntaxFactoryContext context)
          : base(kind)
        {
            this.SetFactoryContext(context);
            this.SlotCount = 3;
            if (attributeLists != null)
            {
                this.AdjustFlagsAndWidth(attributeLists);
                this.attributeLists = attributeLists;
            }
            if (modifiers != null)
            {
                this.AdjustFlagsAndWidth(modifiers);
                this.modifiers = modifiers;
            }
            if (type != null)
            {
                this.AdjustFlagsAndWidth(type);
                this.type = type;
            }
        }

        internal IncompleteMemberSyntax(SyntaxKind kind, GreenNode? attributeLists, GreenNode? modifiers, TypeSyntax? type)
          : base(kind)
        {
            this.SlotCount = 3;
            if (attributeLists != null)
            {
                this.AdjustFlagsAndWidth(attributeLists);
                this.attributeLists = attributeLists;
            }
            if (modifiers != null)
            {
                this.AdjustFlagsAndWidth(modifiers);
                this.modifiers = modifiers;
            }
            if (type != null)
            {
                this.AdjustFlagsAndWidth(type);
                this.type = type;
            }
        }

        public override Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<AttributeListSyntax> AttributeLists => new Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<AttributeListSyntax>(this.attributeLists);
        public override Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SyntaxToken> Modifiers => new Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SyntaxToken>(this.modifiers);
        public TypeSyntax? Type => this.type;

        internal override GreenNode? GetSlot(int index)
            => index switch
            {
                0 => this.attributeLists,
                1 => this.modifiers,
                2 => this.type,
                _ => null,
            };

        internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new CSharp.Syntax.IncompleteMemberSyntax(this, parent, position);

        public override void Accept(CSharpSyntaxVisitor visitor) => visitor.VisitIncompleteMember(this);
        public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor) => visitor.VisitIncompleteMember(this);

        public IncompleteMemberSyntax Update(Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<AttributeListSyntax> attributeLists, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SyntaxToken> modifiers, TypeSyntax type)
        {
            if (attributeLists != this.AttributeLists || modifiers != this.Modifiers || type != this.Type)
            {
                var newNode = SyntaxFactory.IncompleteMember(attributeLists, modifiers, type);
                var diags = GetDiagnostics();
                if (diags?.Length > 0)
                    newNode = newNode.WithDiagnosticsGreen(diags);
                var annotations = GetAnnotations();
                if (annotations?.Length > 0)
                    newNode = newNode.WithAnnotationsGreen(annotations);
                return newNode;
            }

            return this;
        }

        internal override GreenNode SetDiagnostics(DiagnosticInfo[]? diagnostics)
            => new IncompleteMemberSyntax(this.Kind, this.attributeLists, this.modifiers, this.type, diagnostics, GetAnnotations());

        internal override GreenNode SetAnnotations(SyntaxAnnotation[]? annotations)
            => new IncompleteMemberSyntax(this.Kind, this.attributeLists, this.modifiers, this.type, GetDiagnostics(), annotations);

        internal IncompleteMemberSyntax(ObjectReader reader)
          : base(reader)
        {
            this.SlotCount = 3;
            var attributeLists = (GreenNode?)reader.ReadValue();
            if (attributeLists != null)
            {
                AdjustFlagsAndWidth(attributeLists);
                this.attributeLists = attributeLists;
            }
            var modifiers = (GreenNode?)reader.ReadValue();
            if (modifiers != null)
            {
                AdjustFlagsAndWidth(modifiers);
                this.modifiers = modifiers;
            }
            var type = (TypeSyntax?)reader.ReadValue();
            if (type != null)
            {
                AdjustFlagsAndWidth(type);
                this.type = type;
            }
        }

        internal override void WriteTo(ObjectWriter writer)
        {
            base.WriteTo(writer);
            writer.WriteValue(this.attributeLists);
            writer.WriteValue(this.modifiers);
            writer.WriteValue(this.type);
        }

        static IncompleteMemberSyntax()
        {
            ObjectBinder.RegisterTypeReader(typeof(IncompleteMemberSyntax), r => new IncompleteMemberSyntax(r));
        }
    }

    internal sealed partial class SkippedTokensTriviaSyntax : StructuredTriviaSyntax
    {
        internal readonly GreenNode? tokens;

        internal SkippedTokensTriviaSyntax(SyntaxKind kind, GreenNode? tokens, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
            this.SlotCount = 1;
            if (tokens != null)
            {
                this.AdjustFlagsAndWidth(tokens);
                this.tokens = tokens;
            }
        }

        internal SkippedTokensTriviaSyntax(SyntaxKind kind, GreenNode? tokens, SyntaxFactoryContext context)
          : base(kind)
        {
            this.SetFactoryContext(context);
            this.SlotCount = 1;
            if (tokens != null)
            {
                this.AdjustFlagsAndWidth(tokens);
                this.tokens = tokens;
            }
        }

        internal SkippedTokensTriviaSyntax(SyntaxKind kind, GreenNode? tokens)
          : base(kind)
        {
            this.SlotCount = 1;
            if (tokens != null)
            {
                this.AdjustFlagsAndWidth(tokens);
                this.tokens = tokens;
            }
        }

        public Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SyntaxToken> Tokens => new Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SyntaxToken>(this.tokens);

        internal override GreenNode? GetSlot(int index)
            => index == 0 ? this.tokens : null;

        internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new CSharp.Syntax.SkippedTokensTriviaSyntax(this, parent, position);

        public override void Accept(CSharpSyntaxVisitor visitor) => visitor.VisitSkippedTokensTrivia(this);
        public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor) => visitor.VisitSkippedTokensTrivia(this);

        public SkippedTokensTriviaSyntax Update(Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SyntaxToken> tokens)
        {
            if (tokens != this.Tokens)
            {
                var newNode = SyntaxFactory.SkippedTokensTrivia(tokens);
                var diags = GetDiagnostics();
                if (diags?.Length > 0)
                    newNode = newNode.WithDiagnosticsGreen(diags);
                var annotations = GetAnnotations();
                if (annotations?.Length > 0)
                    newNode = newNode.WithAnnotationsGreen(annotations);
                return newNode;
            }

            return this;
        }

        internal override GreenNode SetDiagnostics(DiagnosticInfo[]? diagnostics)
            => new SkippedTokensTriviaSyntax(this.Kind, this.tokens, diagnostics, GetAnnotations());

        internal override GreenNode SetAnnotations(SyntaxAnnotation[]? annotations)
            => new SkippedTokensTriviaSyntax(this.Kind, this.tokens, GetDiagnostics(), annotations);

        internal SkippedTokensTriviaSyntax(ObjectReader reader)
          : base(reader)
        {
            this.SlotCount = 1;
            var tokens = (GreenNode?)reader.ReadValue();
            if (tokens != null)
            {
                AdjustFlagsAndWidth(tokens);
                this.tokens = tokens;
            }
        }

        internal override void WriteTo(ObjectWriter writer)
        {
            base.WriteTo(writer);
            writer.WriteValue(this.tokens);
        }

        static SkippedTokensTriviaSyntax()
        {
            ObjectBinder.RegisterTypeReader(typeof(SkippedTokensTriviaSyntax), r => new SkippedTokensTriviaSyntax(r));
        }
    }

    internal sealed partial class DocumentationCommentTriviaSyntax : StructuredTriviaSyntax
    {
        internal readonly GreenNode? content;
        internal readonly SyntaxToken endOfComment;

        internal DocumentationCommentTriviaSyntax(SyntaxKind kind, GreenNode? content, SyntaxToken endOfComment, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
            this.SlotCount = 2;
            if (content != null)
            {
                this.AdjustFlagsAndWidth(content);
                this.content = content;
            }
            this.AdjustFlagsAndWidth(endOfComment);
            this.endOfComment = endOfComment;
        }

        internal DocumentationCommentTriviaSyntax(SyntaxKind kind, GreenNode? content, SyntaxToken endOfComment, SyntaxFactoryContext context)
          : base(kind)
        {
            this.SetFactoryContext(context);
            this.SlotCount = 2;
            if (content != null)
            {
                this.AdjustFlagsAndWidth(content);
                this.content = content;
            }
            this.AdjustFlagsAndWidth(endOfComment);
            this.endOfComment = endOfComment;
        }

        internal DocumentationCommentTriviaSyntax(SyntaxKind kind, GreenNode? content, SyntaxToken endOfComment)
          : base(kind)
        {
            this.SlotCount = 2;
            if (content != null)
            {
                this.AdjustFlagsAndWidth(content);
                this.content = content;
            }
            this.AdjustFlagsAndWidth(endOfComment);
            this.endOfComment = endOfComment;
        }

        public Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<XmlNodeSyntax> Content => new Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<XmlNodeSyntax>(this.content);
        public SyntaxToken EndOfComment => this.endOfComment;

        internal override GreenNode? GetSlot(int index)
            => index switch
            {
                0 => this.content,
                1 => this.endOfComment,
                _ => null,
            };

        internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new CSharp.Syntax.DocumentationCommentTriviaSyntax(this, parent, position);

        public override void Accept(CSharpSyntaxVisitor visitor) => visitor.VisitDocumentationCommentTrivia(this);
        public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor) => visitor.VisitDocumentationCommentTrivia(this);

        public DocumentationCommentTriviaSyntax Update(Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<XmlNodeSyntax> content, SyntaxToken endOfComment)
        {
            if (content != this.Content || endOfComment != this.EndOfComment)
            {
                var newNode = SyntaxFactory.DocumentationCommentTrivia(this.Kind, content, endOfComment);
                var diags = GetDiagnostics();
                if (diags?.Length > 0)
                    newNode = newNode.WithDiagnosticsGreen(diags);
                var annotations = GetAnnotations();
                if (annotations?.Length > 0)
                    newNode = newNode.WithAnnotationsGreen(annotations);
                return newNode;
            }

            return this;
        }

        internal override GreenNode SetDiagnostics(DiagnosticInfo[]? diagnostics)
            => new DocumentationCommentTriviaSyntax(this.Kind, this.content, this.endOfComment, diagnostics, GetAnnotations());

        internal override GreenNode SetAnnotations(SyntaxAnnotation[]? annotations)
            => new DocumentationCommentTriviaSyntax(this.Kind, this.content, this.endOfComment, GetDiagnostics(), annotations);

        internal DocumentationCommentTriviaSyntax(ObjectReader reader)
          : base(reader)
        {
            this.SlotCount = 2;
            var content = (GreenNode?)reader.ReadValue();
            if (content != null)
            {
                AdjustFlagsAndWidth(content);
                this.content = content;
            }
            var endOfComment = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(endOfComment);
            this.endOfComment = endOfComment;
        }

        internal override void WriteTo(ObjectWriter writer)
        {
            base.WriteTo(writer);
            writer.WriteValue(this.content);
            writer.WriteValue(this.endOfComment);
        }

        static DocumentationCommentTriviaSyntax()
        {
            ObjectBinder.RegisterTypeReader(typeof(DocumentationCommentTriviaSyntax), r => new DocumentationCommentTriviaSyntax(r));
        }
    }

    /// <summary>
    /// A symbol referenced by a cref attribute (e.g. in a &lt;see&gt; or &lt;seealso&gt; documentation comment tag).
    /// For example, the M in &lt;see cref="M" /&gt;.
    /// </summary>
    internal abstract partial class CrefSyntax : CSharpSyntaxNode
    {
        internal CrefSyntax(SyntaxKind kind, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
        }

        internal CrefSyntax(SyntaxKind kind)
          : base(kind)
        {
        }

        protected CrefSyntax(ObjectReader reader)
          : base(reader)
        {
        }
    }

    /// <summary>
    /// A symbol reference that definitely refers to a type.
    /// For example, "int", "A::B", "A.B", "A&lt;T&gt;", but not "M()" (has parameter list) or "this" (indexer).
    /// NOTE: TypeCrefSyntax, QualifiedCrefSyntax, and MemberCrefSyntax overlap.  The syntax in a TypeCrefSyntax
    /// will always be bound as type, so it's safer to use QualifiedCrefSyntax or MemberCrefSyntax if the symbol
    /// might be a non-type member.
    /// </summary>
    internal sealed partial class TypeCrefSyntax : CrefSyntax
    {
        internal readonly TypeSyntax type;

        internal TypeCrefSyntax(SyntaxKind kind, TypeSyntax type, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
            this.SlotCount = 1;
            this.AdjustFlagsAndWidth(type);
            this.type = type;
        }

        internal TypeCrefSyntax(SyntaxKind kind, TypeSyntax type, SyntaxFactoryContext context)
          : base(kind)
        {
            this.SetFactoryContext(context);
            this.SlotCount = 1;
            this.AdjustFlagsAndWidth(type);
            this.type = type;
        }

        internal TypeCrefSyntax(SyntaxKind kind, TypeSyntax type)
          : base(kind)
        {
            this.SlotCount = 1;
            this.AdjustFlagsAndWidth(type);
            this.type = type;
        }

        public TypeSyntax Type => this.type;

        internal override GreenNode? GetSlot(int index)
            => index == 0 ? this.type : null;

        internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new CSharp.Syntax.TypeCrefSyntax(this, parent, position);

        public override void Accept(CSharpSyntaxVisitor visitor) => visitor.VisitTypeCref(this);
        public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor) => visitor.VisitTypeCref(this);

        public TypeCrefSyntax Update(TypeSyntax type)
        {
            if (type != this.Type)
            {
                var newNode = SyntaxFactory.TypeCref(type);
                var diags = GetDiagnostics();
                if (diags?.Length > 0)
                    newNode = newNode.WithDiagnosticsGreen(diags);
                var annotations = GetAnnotations();
                if (annotations?.Length > 0)
                    newNode = newNode.WithAnnotationsGreen(annotations);
                return newNode;
            }

            return this;
        }

        internal override GreenNode SetDiagnostics(DiagnosticInfo[]? diagnostics)
            => new TypeCrefSyntax(this.Kind, this.type, diagnostics, GetAnnotations());

        internal override GreenNode SetAnnotations(SyntaxAnnotation[]? annotations)
            => new TypeCrefSyntax(this.Kind, this.type, GetDiagnostics(), annotations);

        internal TypeCrefSyntax(ObjectReader reader)
          : base(reader)
        {
            this.SlotCount = 1;
            var type = (TypeSyntax)reader.ReadValue();
            AdjustFlagsAndWidth(type);
            this.type = type;
        }

        internal override void WriteTo(ObjectWriter writer)
        {
            base.WriteTo(writer);
            writer.WriteValue(this.type);
        }

        static TypeCrefSyntax()
        {
            ObjectBinder.RegisterTypeReader(typeof(TypeCrefSyntax), r => new TypeCrefSyntax(r));
        }
    }

    /// <summary>
    /// A symbol reference to a type or non-type member that is qualified by an enclosing type or namespace.
    /// For example, cref="System.String.ToString()".
    /// NOTE: TypeCrefSyntax, QualifiedCrefSyntax, and MemberCrefSyntax overlap.  The syntax in a TypeCrefSyntax
    /// will always be bound as type, so it's safer to use QualifiedCrefSyntax or MemberCrefSyntax if the symbol
    /// might be a non-type member.
    /// </summary>
    internal sealed partial class QualifiedCrefSyntax : CrefSyntax
    {
        internal readonly TypeSyntax container;
        internal readonly SyntaxToken dotToken;
        internal readonly MemberCrefSyntax member;

        internal QualifiedCrefSyntax(SyntaxKind kind, TypeSyntax container, SyntaxToken dotToken, MemberCrefSyntax member, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
            this.SlotCount = 3;
            this.AdjustFlagsAndWidth(container);
            this.container = container;
            this.AdjustFlagsAndWidth(dotToken);
            this.dotToken = dotToken;
            this.AdjustFlagsAndWidth(member);
            this.member = member;
        }

        internal QualifiedCrefSyntax(SyntaxKind kind, TypeSyntax container, SyntaxToken dotToken, MemberCrefSyntax member, SyntaxFactoryContext context)
          : base(kind)
        {
            this.SetFactoryContext(context);
            this.SlotCount = 3;
            this.AdjustFlagsAndWidth(container);
            this.container = container;
            this.AdjustFlagsAndWidth(dotToken);
            this.dotToken = dotToken;
            this.AdjustFlagsAndWidth(member);
            this.member = member;
        }

        internal QualifiedCrefSyntax(SyntaxKind kind, TypeSyntax container, SyntaxToken dotToken, MemberCrefSyntax member)
          : base(kind)
        {
            this.SlotCount = 3;
            this.AdjustFlagsAndWidth(container);
            this.container = container;
            this.AdjustFlagsAndWidth(dotToken);
            this.dotToken = dotToken;
            this.AdjustFlagsAndWidth(member);
            this.member = member;
        }

        public TypeSyntax Container => this.container;
        public SyntaxToken DotToken => this.dotToken;
        public MemberCrefSyntax Member => this.member;

        internal override GreenNode? GetSlot(int index)
            => index switch
            {
                0 => this.container,
                1 => this.dotToken,
                2 => this.member,
                _ => null,
            };

        internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new CSharp.Syntax.QualifiedCrefSyntax(this, parent, position);

        public override void Accept(CSharpSyntaxVisitor visitor) => visitor.VisitQualifiedCref(this);
        public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor) => visitor.VisitQualifiedCref(this);

        public QualifiedCrefSyntax Update(TypeSyntax container, SyntaxToken dotToken, MemberCrefSyntax member)
        {
            if (container != this.Container || dotToken != this.DotToken || member != this.Member)
            {
                var newNode = SyntaxFactory.QualifiedCref(container, dotToken, member);
                var diags = GetDiagnostics();
                if (diags?.Length > 0)
                    newNode = newNode.WithDiagnosticsGreen(diags);
                var annotations = GetAnnotations();
                if (annotations?.Length > 0)
                    newNode = newNode.WithAnnotationsGreen(annotations);
                return newNode;
            }

            return this;
        }

        internal override GreenNode SetDiagnostics(DiagnosticInfo[]? diagnostics)
            => new QualifiedCrefSyntax(this.Kind, this.container, this.dotToken, this.member, diagnostics, GetAnnotations());

        internal override GreenNode SetAnnotations(SyntaxAnnotation[]? annotations)
            => new QualifiedCrefSyntax(this.Kind, this.container, this.dotToken, this.member, GetDiagnostics(), annotations);

        internal QualifiedCrefSyntax(ObjectReader reader)
          : base(reader)
        {
            this.SlotCount = 3;
            var container = (TypeSyntax)reader.ReadValue();
            AdjustFlagsAndWidth(container);
            this.container = container;
            var dotToken = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(dotToken);
            this.dotToken = dotToken;
            var member = (MemberCrefSyntax)reader.ReadValue();
            AdjustFlagsAndWidth(member);
            this.member = member;
        }

        internal override void WriteTo(ObjectWriter writer)
        {
            base.WriteTo(writer);
            writer.WriteValue(this.container);
            writer.WriteValue(this.dotToken);
            writer.WriteValue(this.member);
        }

        static QualifiedCrefSyntax()
        {
            ObjectBinder.RegisterTypeReader(typeof(QualifiedCrefSyntax), r => new QualifiedCrefSyntax(r));
        }
    }

    /// <summary>
    /// The unqualified part of a CrefSyntax.
    /// For example, "ToString()" in "object.ToString()".
    /// NOTE: TypeCrefSyntax, QualifiedCrefSyntax, and MemberCrefSyntax overlap.  The syntax in a TypeCrefSyntax
    /// will always be bound as type, so it's safer to use QualifiedCrefSyntax or MemberCrefSyntax if the symbol
    /// might be a non-type member.
    /// </summary>
    internal abstract partial class MemberCrefSyntax : CrefSyntax
    {
        internal MemberCrefSyntax(SyntaxKind kind, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
        }

        internal MemberCrefSyntax(SyntaxKind kind)
          : base(kind)
        {
        }

        protected MemberCrefSyntax(ObjectReader reader)
          : base(reader)
        {
        }
    }

    /// <summary>
    /// A MemberCrefSyntax specified by a name (an identifier, predefined type keyword, or an alias-qualified name,
    /// with an optional type parameter list) and an optional parameter list.
    /// For example, "M", "M&lt;T&gt;" or "M(int)".
    /// Also, "A::B()" or "string()".
    /// </summary>
    internal sealed partial class NameMemberCrefSyntax : MemberCrefSyntax
    {
        internal readonly TypeSyntax name;
        internal readonly CrefParameterListSyntax? parameters;

        internal NameMemberCrefSyntax(SyntaxKind kind, TypeSyntax name, CrefParameterListSyntax? parameters, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
            this.SlotCount = 2;
            this.AdjustFlagsAndWidth(name);
            this.name = name;
            if (parameters != null)
            {
                this.AdjustFlagsAndWidth(parameters);
                this.parameters = parameters;
            }
        }

        internal NameMemberCrefSyntax(SyntaxKind kind, TypeSyntax name, CrefParameterListSyntax? parameters, SyntaxFactoryContext context)
          : base(kind)
        {
            this.SetFactoryContext(context);
            this.SlotCount = 2;
            this.AdjustFlagsAndWidth(name);
            this.name = name;
            if (parameters != null)
            {
                this.AdjustFlagsAndWidth(parameters);
                this.parameters = parameters;
            }
        }

        internal NameMemberCrefSyntax(SyntaxKind kind, TypeSyntax name, CrefParameterListSyntax? parameters)
          : base(kind)
        {
            this.SlotCount = 2;
            this.AdjustFlagsAndWidth(name);
            this.name = name;
            if (parameters != null)
            {
                this.AdjustFlagsAndWidth(parameters);
                this.parameters = parameters;
            }
        }

        public TypeSyntax Name => this.name;
        public CrefParameterListSyntax? Parameters => this.parameters;

        internal override GreenNode? GetSlot(int index)
            => index switch
            {
                0 => this.name,
                1 => this.parameters,
                _ => null,
            };

        internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new CSharp.Syntax.NameMemberCrefSyntax(this, parent, position);

        public override void Accept(CSharpSyntaxVisitor visitor) => visitor.VisitNameMemberCref(this);
        public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor) => visitor.VisitNameMemberCref(this);

        public NameMemberCrefSyntax Update(TypeSyntax name, CrefParameterListSyntax parameters)
        {
            if (name != this.Name || parameters != this.Parameters)
            {
                var newNode = SyntaxFactory.NameMemberCref(name, parameters);
                var diags = GetDiagnostics();
                if (diags?.Length > 0)
                    newNode = newNode.WithDiagnosticsGreen(diags);
                var annotations = GetAnnotations();
                if (annotations?.Length > 0)
                    newNode = newNode.WithAnnotationsGreen(annotations);
                return newNode;
            }

            return this;
        }

        internal override GreenNode SetDiagnostics(DiagnosticInfo[]? diagnostics)
            => new NameMemberCrefSyntax(this.Kind, this.name, this.parameters, diagnostics, GetAnnotations());

        internal override GreenNode SetAnnotations(SyntaxAnnotation[]? annotations)
            => new NameMemberCrefSyntax(this.Kind, this.name, this.parameters, GetDiagnostics(), annotations);

        internal NameMemberCrefSyntax(ObjectReader reader)
          : base(reader)
        {
            this.SlotCount = 2;
            var name = (TypeSyntax)reader.ReadValue();
            AdjustFlagsAndWidth(name);
            this.name = name;
            var parameters = (CrefParameterListSyntax?)reader.ReadValue();
            if (parameters != null)
            {
                AdjustFlagsAndWidth(parameters);
                this.parameters = parameters;
            }
        }

        internal override void WriteTo(ObjectWriter writer)
        {
            base.WriteTo(writer);
            writer.WriteValue(this.name);
            writer.WriteValue(this.parameters);
        }

        static NameMemberCrefSyntax()
        {
            ObjectBinder.RegisterTypeReader(typeof(NameMemberCrefSyntax), r => new NameMemberCrefSyntax(r));
        }
    }

    /// <summary>
    /// A MemberCrefSyntax specified by a this keyword and an optional parameter list.
    /// For example, "this" or "this[int]".
    /// </summary>
    internal sealed partial class IndexerMemberCrefSyntax : MemberCrefSyntax
    {
        internal readonly SyntaxToken thisKeyword;
        internal readonly CrefBracketedParameterListSyntax? parameters;

        internal IndexerMemberCrefSyntax(SyntaxKind kind, SyntaxToken thisKeyword, CrefBracketedParameterListSyntax? parameters, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
            this.SlotCount = 2;
            this.AdjustFlagsAndWidth(thisKeyword);
            this.thisKeyword = thisKeyword;
            if (parameters != null)
            {
                this.AdjustFlagsAndWidth(parameters);
                this.parameters = parameters;
            }
        }

        internal IndexerMemberCrefSyntax(SyntaxKind kind, SyntaxToken thisKeyword, CrefBracketedParameterListSyntax? parameters, SyntaxFactoryContext context)
          : base(kind)
        {
            this.SetFactoryContext(context);
            this.SlotCount = 2;
            this.AdjustFlagsAndWidth(thisKeyword);
            this.thisKeyword = thisKeyword;
            if (parameters != null)
            {
                this.AdjustFlagsAndWidth(parameters);
                this.parameters = parameters;
            }
        }

        internal IndexerMemberCrefSyntax(SyntaxKind kind, SyntaxToken thisKeyword, CrefBracketedParameterListSyntax? parameters)
          : base(kind)
        {
            this.SlotCount = 2;
            this.AdjustFlagsAndWidth(thisKeyword);
            this.thisKeyword = thisKeyword;
            if (parameters != null)
            {
                this.AdjustFlagsAndWidth(parameters);
                this.parameters = parameters;
            }
        }

        public SyntaxToken ThisKeyword => this.thisKeyword;
        public CrefBracketedParameterListSyntax? Parameters => this.parameters;

        internal override GreenNode? GetSlot(int index)
            => index switch
            {
                0 => this.thisKeyword,
                1 => this.parameters,
                _ => null,
            };

        internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new CSharp.Syntax.IndexerMemberCrefSyntax(this, parent, position);

        public override void Accept(CSharpSyntaxVisitor visitor) => visitor.VisitIndexerMemberCref(this);
        public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor) => visitor.VisitIndexerMemberCref(this);

        public IndexerMemberCrefSyntax Update(SyntaxToken thisKeyword, CrefBracketedParameterListSyntax parameters)
        {
            if (thisKeyword != this.ThisKeyword || parameters != this.Parameters)
            {
                var newNode = SyntaxFactory.IndexerMemberCref(thisKeyword, parameters);
                var diags = GetDiagnostics();
                if (diags?.Length > 0)
                    newNode = newNode.WithDiagnosticsGreen(diags);
                var annotations = GetAnnotations();
                if (annotations?.Length > 0)
                    newNode = newNode.WithAnnotationsGreen(annotations);
                return newNode;
            }

            return this;
        }

        internal override GreenNode SetDiagnostics(DiagnosticInfo[]? diagnostics)
            => new IndexerMemberCrefSyntax(this.Kind, this.thisKeyword, this.parameters, diagnostics, GetAnnotations());

        internal override GreenNode SetAnnotations(SyntaxAnnotation[]? annotations)
            => new IndexerMemberCrefSyntax(this.Kind, this.thisKeyword, this.parameters, GetDiagnostics(), annotations);

        internal IndexerMemberCrefSyntax(ObjectReader reader)
          : base(reader)
        {
            this.SlotCount = 2;
            var thisKeyword = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(thisKeyword);
            this.thisKeyword = thisKeyword;
            var parameters = (CrefBracketedParameterListSyntax?)reader.ReadValue();
            if (parameters != null)
            {
                AdjustFlagsAndWidth(parameters);
                this.parameters = parameters;
            }
        }

        internal override void WriteTo(ObjectWriter writer)
        {
            base.WriteTo(writer);
            writer.WriteValue(this.thisKeyword);
            writer.WriteValue(this.parameters);
        }

        static IndexerMemberCrefSyntax()
        {
            ObjectBinder.RegisterTypeReader(typeof(IndexerMemberCrefSyntax), r => new IndexerMemberCrefSyntax(r));
        }
    }

    /// <summary>
    /// A MemberCrefSyntax specified by an operator keyword, an operator symbol and an optional parameter list.
    /// For example, "operator +" or "operator -[int]".
    /// NOTE: the operator must be overloadable.
    /// </summary>
    internal sealed partial class OperatorMemberCrefSyntax : MemberCrefSyntax
    {
        internal readonly SyntaxToken operatorKeyword;
        internal readonly SyntaxToken operatorToken;
        internal readonly CrefParameterListSyntax? parameters;

        internal OperatorMemberCrefSyntax(SyntaxKind kind, SyntaxToken operatorKeyword, SyntaxToken operatorToken, CrefParameterListSyntax? parameters, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
            this.SlotCount = 3;
            this.AdjustFlagsAndWidth(operatorKeyword);
            this.operatorKeyword = operatorKeyword;
            this.AdjustFlagsAndWidth(operatorToken);
            this.operatorToken = operatorToken;
            if (parameters != null)
            {
                this.AdjustFlagsAndWidth(parameters);
                this.parameters = parameters;
            }
        }

        internal OperatorMemberCrefSyntax(SyntaxKind kind, SyntaxToken operatorKeyword, SyntaxToken operatorToken, CrefParameterListSyntax? parameters, SyntaxFactoryContext context)
          : base(kind)
        {
            this.SetFactoryContext(context);
            this.SlotCount = 3;
            this.AdjustFlagsAndWidth(operatorKeyword);
            this.operatorKeyword = operatorKeyword;
            this.AdjustFlagsAndWidth(operatorToken);
            this.operatorToken = operatorToken;
            if (parameters != null)
            {
                this.AdjustFlagsAndWidth(parameters);
                this.parameters = parameters;
            }
        }

        internal OperatorMemberCrefSyntax(SyntaxKind kind, SyntaxToken operatorKeyword, SyntaxToken operatorToken, CrefParameterListSyntax? parameters)
          : base(kind)
        {
            this.SlotCount = 3;
            this.AdjustFlagsAndWidth(operatorKeyword);
            this.operatorKeyword = operatorKeyword;
            this.AdjustFlagsAndWidth(operatorToken);
            this.operatorToken = operatorToken;
            if (parameters != null)
            {
                this.AdjustFlagsAndWidth(parameters);
                this.parameters = parameters;
            }
        }

        public SyntaxToken OperatorKeyword => this.operatorKeyword;
        /// <summary>Gets the operator token.</summary>
        public SyntaxToken OperatorToken => this.operatorToken;
        public CrefParameterListSyntax? Parameters => this.parameters;

        internal override GreenNode? GetSlot(int index)
            => index switch
            {
                0 => this.operatorKeyword,
                1 => this.operatorToken,
                2 => this.parameters,
                _ => null,
            };

        internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new CSharp.Syntax.OperatorMemberCrefSyntax(this, parent, position);

        public override void Accept(CSharpSyntaxVisitor visitor) => visitor.VisitOperatorMemberCref(this);
        public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor) => visitor.VisitOperatorMemberCref(this);

        public OperatorMemberCrefSyntax Update(SyntaxToken operatorKeyword, SyntaxToken operatorToken, CrefParameterListSyntax parameters)
        {
            if (operatorKeyword != this.OperatorKeyword || operatorToken != this.OperatorToken || parameters != this.Parameters)
            {
                var newNode = SyntaxFactory.OperatorMemberCref(operatorKeyword, operatorToken, parameters);
                var diags = GetDiagnostics();
                if (diags?.Length > 0)
                    newNode = newNode.WithDiagnosticsGreen(diags);
                var annotations = GetAnnotations();
                if (annotations?.Length > 0)
                    newNode = newNode.WithAnnotationsGreen(annotations);
                return newNode;
            }

            return this;
        }

        internal override GreenNode SetDiagnostics(DiagnosticInfo[]? diagnostics)
            => new OperatorMemberCrefSyntax(this.Kind, this.operatorKeyword, this.operatorToken, this.parameters, diagnostics, GetAnnotations());

        internal override GreenNode SetAnnotations(SyntaxAnnotation[]? annotations)
            => new OperatorMemberCrefSyntax(this.Kind, this.operatorKeyword, this.operatorToken, this.parameters, GetDiagnostics(), annotations);

        internal OperatorMemberCrefSyntax(ObjectReader reader)
          : base(reader)
        {
            this.SlotCount = 3;
            var operatorKeyword = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(operatorKeyword);
            this.operatorKeyword = operatorKeyword;
            var operatorToken = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(operatorToken);
            this.operatorToken = operatorToken;
            var parameters = (CrefParameterListSyntax?)reader.ReadValue();
            if (parameters != null)
            {
                AdjustFlagsAndWidth(parameters);
                this.parameters = parameters;
            }
        }

        internal override void WriteTo(ObjectWriter writer)
        {
            base.WriteTo(writer);
            writer.WriteValue(this.operatorKeyword);
            writer.WriteValue(this.operatorToken);
            writer.WriteValue(this.parameters);
        }

        static OperatorMemberCrefSyntax()
        {
            ObjectBinder.RegisterTypeReader(typeof(OperatorMemberCrefSyntax), r => new OperatorMemberCrefSyntax(r));
        }
    }

    /// <summary>
    /// A MemberCrefSyntax specified by an implicit or explicit keyword, an operator keyword, a destination type, and an optional parameter list.
    /// For example, "implicit operator int" or "explicit operator MyType(int)".
    /// </summary>
    internal sealed partial class ConversionOperatorMemberCrefSyntax : MemberCrefSyntax
    {
        internal readonly SyntaxToken implicitOrExplicitKeyword;
        internal readonly SyntaxToken operatorKeyword;
        internal readonly TypeSyntax type;
        internal readonly CrefParameterListSyntax? parameters;

        internal ConversionOperatorMemberCrefSyntax(SyntaxKind kind, SyntaxToken implicitOrExplicitKeyword, SyntaxToken operatorKeyword, TypeSyntax type, CrefParameterListSyntax? parameters, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
            this.SlotCount = 4;
            this.AdjustFlagsAndWidth(implicitOrExplicitKeyword);
            this.implicitOrExplicitKeyword = implicitOrExplicitKeyword;
            this.AdjustFlagsAndWidth(operatorKeyword);
            this.operatorKeyword = operatorKeyword;
            this.AdjustFlagsAndWidth(type);
            this.type = type;
            if (parameters != null)
            {
                this.AdjustFlagsAndWidth(parameters);
                this.parameters = parameters;
            }
        }

        internal ConversionOperatorMemberCrefSyntax(SyntaxKind kind, SyntaxToken implicitOrExplicitKeyword, SyntaxToken operatorKeyword, TypeSyntax type, CrefParameterListSyntax? parameters, SyntaxFactoryContext context)
          : base(kind)
        {
            this.SetFactoryContext(context);
            this.SlotCount = 4;
            this.AdjustFlagsAndWidth(implicitOrExplicitKeyword);
            this.implicitOrExplicitKeyword = implicitOrExplicitKeyword;
            this.AdjustFlagsAndWidth(operatorKeyword);
            this.operatorKeyword = operatorKeyword;
            this.AdjustFlagsAndWidth(type);
            this.type = type;
            if (parameters != null)
            {
                this.AdjustFlagsAndWidth(parameters);
                this.parameters = parameters;
            }
        }

        internal ConversionOperatorMemberCrefSyntax(SyntaxKind kind, SyntaxToken implicitOrExplicitKeyword, SyntaxToken operatorKeyword, TypeSyntax type, CrefParameterListSyntax? parameters)
          : base(kind)
        {
            this.SlotCount = 4;
            this.AdjustFlagsAndWidth(implicitOrExplicitKeyword);
            this.implicitOrExplicitKeyword = implicitOrExplicitKeyword;
            this.AdjustFlagsAndWidth(operatorKeyword);
            this.operatorKeyword = operatorKeyword;
            this.AdjustFlagsAndWidth(type);
            this.type = type;
            if (parameters != null)
            {
                this.AdjustFlagsAndWidth(parameters);
                this.parameters = parameters;
            }
        }

        public SyntaxToken ImplicitOrExplicitKeyword => this.implicitOrExplicitKeyword;
        public SyntaxToken OperatorKeyword => this.operatorKeyword;
        public TypeSyntax Type => this.type;
        public CrefParameterListSyntax? Parameters => this.parameters;

        internal override GreenNode? GetSlot(int index)
            => index switch
            {
                0 => this.implicitOrExplicitKeyword,
                1 => this.operatorKeyword,
                2 => this.type,
                3 => this.parameters,
                _ => null,
            };

        internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new CSharp.Syntax.ConversionOperatorMemberCrefSyntax(this, parent, position);

        public override void Accept(CSharpSyntaxVisitor visitor) => visitor.VisitConversionOperatorMemberCref(this);
        public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor) => visitor.VisitConversionOperatorMemberCref(this);

        public ConversionOperatorMemberCrefSyntax Update(SyntaxToken implicitOrExplicitKeyword, SyntaxToken operatorKeyword, TypeSyntax type, CrefParameterListSyntax parameters)
        {
            if (implicitOrExplicitKeyword != this.ImplicitOrExplicitKeyword || operatorKeyword != this.OperatorKeyword || type != this.Type || parameters != this.Parameters)
            {
                var newNode = SyntaxFactory.ConversionOperatorMemberCref(implicitOrExplicitKeyword, operatorKeyword, type, parameters);
                var diags = GetDiagnostics();
                if (diags?.Length > 0)
                    newNode = newNode.WithDiagnosticsGreen(diags);
                var annotations = GetAnnotations();
                if (annotations?.Length > 0)
                    newNode = newNode.WithAnnotationsGreen(annotations);
                return newNode;
            }

            return this;
        }

        internal override GreenNode SetDiagnostics(DiagnosticInfo[]? diagnostics)
            => new ConversionOperatorMemberCrefSyntax(this.Kind, this.implicitOrExplicitKeyword, this.operatorKeyword, this.type, this.parameters, diagnostics, GetAnnotations());

        internal override GreenNode SetAnnotations(SyntaxAnnotation[]? annotations)
            => new ConversionOperatorMemberCrefSyntax(this.Kind, this.implicitOrExplicitKeyword, this.operatorKeyword, this.type, this.parameters, GetDiagnostics(), annotations);

        internal ConversionOperatorMemberCrefSyntax(ObjectReader reader)
          : base(reader)
        {
            this.SlotCount = 4;
            var implicitOrExplicitKeyword = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(implicitOrExplicitKeyword);
            this.implicitOrExplicitKeyword = implicitOrExplicitKeyword;
            var operatorKeyword = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(operatorKeyword);
            this.operatorKeyword = operatorKeyword;
            var type = (TypeSyntax)reader.ReadValue();
            AdjustFlagsAndWidth(type);
            this.type = type;
            var parameters = (CrefParameterListSyntax?)reader.ReadValue();
            if (parameters != null)
            {
                AdjustFlagsAndWidth(parameters);
                this.parameters = parameters;
            }
        }

        internal override void WriteTo(ObjectWriter writer)
        {
            base.WriteTo(writer);
            writer.WriteValue(this.implicitOrExplicitKeyword);
            writer.WriteValue(this.operatorKeyword);
            writer.WriteValue(this.type);
            writer.WriteValue(this.parameters);
        }

        static ConversionOperatorMemberCrefSyntax()
        {
            ObjectBinder.RegisterTypeReader(typeof(ConversionOperatorMemberCrefSyntax), r => new ConversionOperatorMemberCrefSyntax(r));
        }
    }

    /// <summary>
    /// A list of cref parameters with surrounding punctuation.
    /// Unlike regular parameters, cref parameters do not have names.
    /// </summary>
    internal abstract partial class BaseCrefParameterListSyntax : CSharpSyntaxNode
    {
        internal BaseCrefParameterListSyntax(SyntaxKind kind, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
        }

        internal BaseCrefParameterListSyntax(SyntaxKind kind)
          : base(kind)
        {
        }

        protected BaseCrefParameterListSyntax(ObjectReader reader)
          : base(reader)
        {
        }

        /// <summary>Gets the parameter list.</summary>
        public abstract Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<CrefParameterSyntax> Parameters { get; }
    }

    /// <summary>
    /// A parenthesized list of cref parameters.
    /// </summary>
    internal sealed partial class CrefParameterListSyntax : BaseCrefParameterListSyntax
    {
        internal readonly SyntaxToken openParenToken;
        internal readonly GreenNode? parameters;
        internal readonly SyntaxToken closeParenToken;

        internal CrefParameterListSyntax(SyntaxKind kind, SyntaxToken openParenToken, GreenNode? parameters, SyntaxToken closeParenToken, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
            this.SlotCount = 3;
            this.AdjustFlagsAndWidth(openParenToken);
            this.openParenToken = openParenToken;
            if (parameters != null)
            {
                this.AdjustFlagsAndWidth(parameters);
                this.parameters = parameters;
            }
            this.AdjustFlagsAndWidth(closeParenToken);
            this.closeParenToken = closeParenToken;
        }

        internal CrefParameterListSyntax(SyntaxKind kind, SyntaxToken openParenToken, GreenNode? parameters, SyntaxToken closeParenToken, SyntaxFactoryContext context)
          : base(kind)
        {
            this.SetFactoryContext(context);
            this.SlotCount = 3;
            this.AdjustFlagsAndWidth(openParenToken);
            this.openParenToken = openParenToken;
            if (parameters != null)
            {
                this.AdjustFlagsAndWidth(parameters);
                this.parameters = parameters;
            }
            this.AdjustFlagsAndWidth(closeParenToken);
            this.closeParenToken = closeParenToken;
        }

        internal CrefParameterListSyntax(SyntaxKind kind, SyntaxToken openParenToken, GreenNode? parameters, SyntaxToken closeParenToken)
          : base(kind)
        {
            this.SlotCount = 3;
            this.AdjustFlagsAndWidth(openParenToken);
            this.openParenToken = openParenToken;
            if (parameters != null)
            {
                this.AdjustFlagsAndWidth(parameters);
                this.parameters = parameters;
            }
            this.AdjustFlagsAndWidth(closeParenToken);
            this.closeParenToken = closeParenToken;
        }

        /// <summary>Gets the open paren token.</summary>
        public SyntaxToken OpenParenToken => this.openParenToken;
        public override Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<CrefParameterSyntax> Parameters => new Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<CrefParameterSyntax>(new Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<CSharpSyntaxNode>(this.parameters));
        /// <summary>Gets the close paren token.</summary>
        public SyntaxToken CloseParenToken => this.closeParenToken;

        internal override GreenNode? GetSlot(int index)
            => index switch
            {
                0 => this.openParenToken,
                1 => this.parameters,
                2 => this.closeParenToken,
                _ => null,
            };

        internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new CSharp.Syntax.CrefParameterListSyntax(this, parent, position);

        public override void Accept(CSharpSyntaxVisitor visitor) => visitor.VisitCrefParameterList(this);
        public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor) => visitor.VisitCrefParameterList(this);

        public CrefParameterListSyntax Update(SyntaxToken openParenToken, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<CrefParameterSyntax> parameters, SyntaxToken closeParenToken)
        {
            if (openParenToken != this.OpenParenToken || parameters != this.Parameters || closeParenToken != this.CloseParenToken)
            {
                var newNode = SyntaxFactory.CrefParameterList(openParenToken, parameters, closeParenToken);
                var diags = GetDiagnostics();
                if (diags?.Length > 0)
                    newNode = newNode.WithDiagnosticsGreen(diags);
                var annotations = GetAnnotations();
                if (annotations?.Length > 0)
                    newNode = newNode.WithAnnotationsGreen(annotations);
                return newNode;
            }

            return this;
        }

        internal override GreenNode SetDiagnostics(DiagnosticInfo[]? diagnostics)
            => new CrefParameterListSyntax(this.Kind, this.openParenToken, this.parameters, this.closeParenToken, diagnostics, GetAnnotations());

        internal override GreenNode SetAnnotations(SyntaxAnnotation[]? annotations)
            => new CrefParameterListSyntax(this.Kind, this.openParenToken, this.parameters, this.closeParenToken, GetDiagnostics(), annotations);

        internal CrefParameterListSyntax(ObjectReader reader)
          : base(reader)
        {
            this.SlotCount = 3;
            var openParenToken = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(openParenToken);
            this.openParenToken = openParenToken;
            var parameters = (GreenNode?)reader.ReadValue();
            if (parameters != null)
            {
                AdjustFlagsAndWidth(parameters);
                this.parameters = parameters;
            }
            var closeParenToken = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(closeParenToken);
            this.closeParenToken = closeParenToken;
        }

        internal override void WriteTo(ObjectWriter writer)
        {
            base.WriteTo(writer);
            writer.WriteValue(this.openParenToken);
            writer.WriteValue(this.parameters);
            writer.WriteValue(this.closeParenToken);
        }

        static CrefParameterListSyntax()
        {
            ObjectBinder.RegisterTypeReader(typeof(CrefParameterListSyntax), r => new CrefParameterListSyntax(r));
        }
    }

    /// <summary>
    /// A bracketed list of cref parameters.
    /// </summary>
    internal sealed partial class CrefBracketedParameterListSyntax : BaseCrefParameterListSyntax
    {
        internal readonly SyntaxToken openBracketToken;
        internal readonly GreenNode? parameters;
        internal readonly SyntaxToken closeBracketToken;

        internal CrefBracketedParameterListSyntax(SyntaxKind kind, SyntaxToken openBracketToken, GreenNode? parameters, SyntaxToken closeBracketToken, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
            this.SlotCount = 3;
            this.AdjustFlagsAndWidth(openBracketToken);
            this.openBracketToken = openBracketToken;
            if (parameters != null)
            {
                this.AdjustFlagsAndWidth(parameters);
                this.parameters = parameters;
            }
            this.AdjustFlagsAndWidth(closeBracketToken);
            this.closeBracketToken = closeBracketToken;
        }

        internal CrefBracketedParameterListSyntax(SyntaxKind kind, SyntaxToken openBracketToken, GreenNode? parameters, SyntaxToken closeBracketToken, SyntaxFactoryContext context)
          : base(kind)
        {
            this.SetFactoryContext(context);
            this.SlotCount = 3;
            this.AdjustFlagsAndWidth(openBracketToken);
            this.openBracketToken = openBracketToken;
            if (parameters != null)
            {
                this.AdjustFlagsAndWidth(parameters);
                this.parameters = parameters;
            }
            this.AdjustFlagsAndWidth(closeBracketToken);
            this.closeBracketToken = closeBracketToken;
        }

        internal CrefBracketedParameterListSyntax(SyntaxKind kind, SyntaxToken openBracketToken, GreenNode? parameters, SyntaxToken closeBracketToken)
          : base(kind)
        {
            this.SlotCount = 3;
            this.AdjustFlagsAndWidth(openBracketToken);
            this.openBracketToken = openBracketToken;
            if (parameters != null)
            {
                this.AdjustFlagsAndWidth(parameters);
                this.parameters = parameters;
            }
            this.AdjustFlagsAndWidth(closeBracketToken);
            this.closeBracketToken = closeBracketToken;
        }

        /// <summary>Gets the open bracket token.</summary>
        public SyntaxToken OpenBracketToken => this.openBracketToken;
        public override Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<CrefParameterSyntax> Parameters => new Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<CrefParameterSyntax>(new Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<CSharpSyntaxNode>(this.parameters));
        /// <summary>Gets the close bracket token.</summary>
        public SyntaxToken CloseBracketToken => this.closeBracketToken;

        internal override GreenNode? GetSlot(int index)
            => index switch
            {
                0 => this.openBracketToken,
                1 => this.parameters,
                2 => this.closeBracketToken,
                _ => null,
            };

        internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new CSharp.Syntax.CrefBracketedParameterListSyntax(this, parent, position);

        public override void Accept(CSharpSyntaxVisitor visitor) => visitor.VisitCrefBracketedParameterList(this);
        public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor) => visitor.VisitCrefBracketedParameterList(this);

        public CrefBracketedParameterListSyntax Update(SyntaxToken openBracketToken, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<CrefParameterSyntax> parameters, SyntaxToken closeBracketToken)
        {
            if (openBracketToken != this.OpenBracketToken || parameters != this.Parameters || closeBracketToken != this.CloseBracketToken)
            {
                var newNode = SyntaxFactory.CrefBracketedParameterList(openBracketToken, parameters, closeBracketToken);
                var diags = GetDiagnostics();
                if (diags?.Length > 0)
                    newNode = newNode.WithDiagnosticsGreen(diags);
                var annotations = GetAnnotations();
                if (annotations?.Length > 0)
                    newNode = newNode.WithAnnotationsGreen(annotations);
                return newNode;
            }

            return this;
        }

        internal override GreenNode SetDiagnostics(DiagnosticInfo[]? diagnostics)
            => new CrefBracketedParameterListSyntax(this.Kind, this.openBracketToken, this.parameters, this.closeBracketToken, diagnostics, GetAnnotations());

        internal override GreenNode SetAnnotations(SyntaxAnnotation[]? annotations)
            => new CrefBracketedParameterListSyntax(this.Kind, this.openBracketToken, this.parameters, this.closeBracketToken, GetDiagnostics(), annotations);

        internal CrefBracketedParameterListSyntax(ObjectReader reader)
          : base(reader)
        {
            this.SlotCount = 3;
            var openBracketToken = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(openBracketToken);
            this.openBracketToken = openBracketToken;
            var parameters = (GreenNode?)reader.ReadValue();
            if (parameters != null)
            {
                AdjustFlagsAndWidth(parameters);
                this.parameters = parameters;
            }
            var closeBracketToken = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(closeBracketToken);
            this.closeBracketToken = closeBracketToken;
        }

        internal override void WriteTo(ObjectWriter writer)
        {
            base.WriteTo(writer);
            writer.WriteValue(this.openBracketToken);
            writer.WriteValue(this.parameters);
            writer.WriteValue(this.closeBracketToken);
        }

        static CrefBracketedParameterListSyntax()
        {
            ObjectBinder.RegisterTypeReader(typeof(CrefBracketedParameterListSyntax), r => new CrefBracketedParameterListSyntax(r));
        }
    }

    /// <summary>
    /// An element of a BaseCrefParameterListSyntax.
    /// Unlike a regular parameter, a cref parameter has only an optional ref or out keyword and a type -
    /// there is no name and there are no attributes or other modifiers.
    /// </summary>
    internal sealed partial class CrefParameterSyntax : CSharpSyntaxNode
    {
        internal readonly SyntaxToken? refKindKeyword;
        internal readonly TypeSyntax type;

        internal CrefParameterSyntax(SyntaxKind kind, SyntaxToken? refKindKeyword, TypeSyntax type, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
            this.SlotCount = 2;
            if (refKindKeyword != null)
            {
                this.AdjustFlagsAndWidth(refKindKeyword);
                this.refKindKeyword = refKindKeyword;
            }
            this.AdjustFlagsAndWidth(type);
            this.type = type;
        }

        internal CrefParameterSyntax(SyntaxKind kind, SyntaxToken? refKindKeyword, TypeSyntax type, SyntaxFactoryContext context)
          : base(kind)
        {
            this.SetFactoryContext(context);
            this.SlotCount = 2;
            if (refKindKeyword != null)
            {
                this.AdjustFlagsAndWidth(refKindKeyword);
                this.refKindKeyword = refKindKeyword;
            }
            this.AdjustFlagsAndWidth(type);
            this.type = type;
        }

        internal CrefParameterSyntax(SyntaxKind kind, SyntaxToken? refKindKeyword, TypeSyntax type)
          : base(kind)
        {
            this.SlotCount = 2;
            if (refKindKeyword != null)
            {
                this.AdjustFlagsAndWidth(refKindKeyword);
                this.refKindKeyword = refKindKeyword;
            }
            this.AdjustFlagsAndWidth(type);
            this.type = type;
        }

        public SyntaxToken? RefKindKeyword => this.refKindKeyword;
        public TypeSyntax Type => this.type;

        internal override GreenNode? GetSlot(int index)
            => index switch
            {
                0 => this.refKindKeyword,
                1 => this.type,
                _ => null,
            };

        internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new CSharp.Syntax.CrefParameterSyntax(this, parent, position);

        public override void Accept(CSharpSyntaxVisitor visitor) => visitor.VisitCrefParameter(this);
        public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor) => visitor.VisitCrefParameter(this);

        public CrefParameterSyntax Update(SyntaxToken refKindKeyword, TypeSyntax type)
        {
            if (refKindKeyword != this.RefKindKeyword || type != this.Type)
            {
                var newNode = SyntaxFactory.CrefParameter(refKindKeyword, type);
                var diags = GetDiagnostics();
                if (diags?.Length > 0)
                    newNode = newNode.WithDiagnosticsGreen(diags);
                var annotations = GetAnnotations();
                if (annotations?.Length > 0)
                    newNode = newNode.WithAnnotationsGreen(annotations);
                return newNode;
            }

            return this;
        }

        internal override GreenNode SetDiagnostics(DiagnosticInfo[]? diagnostics)
            => new CrefParameterSyntax(this.Kind, this.refKindKeyword, this.type, diagnostics, GetAnnotations());

        internal override GreenNode SetAnnotations(SyntaxAnnotation[]? annotations)
            => new CrefParameterSyntax(this.Kind, this.refKindKeyword, this.type, GetDiagnostics(), annotations);

        internal CrefParameterSyntax(ObjectReader reader)
          : base(reader)
        {
            this.SlotCount = 2;
            var refKindKeyword = (SyntaxToken?)reader.ReadValue();
            if (refKindKeyword != null)
            {
                AdjustFlagsAndWidth(refKindKeyword);
                this.refKindKeyword = refKindKeyword;
            }
            var type = (TypeSyntax)reader.ReadValue();
            AdjustFlagsAndWidth(type);
            this.type = type;
        }

        internal override void WriteTo(ObjectWriter writer)
        {
            base.WriteTo(writer);
            writer.WriteValue(this.refKindKeyword);
            writer.WriteValue(this.type);
        }

        static CrefParameterSyntax()
        {
            ObjectBinder.RegisterTypeReader(typeof(CrefParameterSyntax), r => new CrefParameterSyntax(r));
        }
    }

    internal abstract partial class XmlNodeSyntax : CSharpSyntaxNode
    {
        internal XmlNodeSyntax(SyntaxKind kind, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
        }

        internal XmlNodeSyntax(SyntaxKind kind)
          : base(kind)
        {
        }

        protected XmlNodeSyntax(ObjectReader reader)
          : base(reader)
        {
        }
    }

    internal sealed partial class XmlElementSyntax : XmlNodeSyntax
    {
        internal readonly XmlElementStartTagSyntax startTag;
        internal readonly GreenNode? content;
        internal readonly XmlElementEndTagSyntax endTag;

        internal XmlElementSyntax(SyntaxKind kind, XmlElementStartTagSyntax startTag, GreenNode? content, XmlElementEndTagSyntax endTag, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
            this.SlotCount = 3;
            this.AdjustFlagsAndWidth(startTag);
            this.startTag = startTag;
            if (content != null)
            {
                this.AdjustFlagsAndWidth(content);
                this.content = content;
            }
            this.AdjustFlagsAndWidth(endTag);
            this.endTag = endTag;
        }

        internal XmlElementSyntax(SyntaxKind kind, XmlElementStartTagSyntax startTag, GreenNode? content, XmlElementEndTagSyntax endTag, SyntaxFactoryContext context)
          : base(kind)
        {
            this.SetFactoryContext(context);
            this.SlotCount = 3;
            this.AdjustFlagsAndWidth(startTag);
            this.startTag = startTag;
            if (content != null)
            {
                this.AdjustFlagsAndWidth(content);
                this.content = content;
            }
            this.AdjustFlagsAndWidth(endTag);
            this.endTag = endTag;
        }

        internal XmlElementSyntax(SyntaxKind kind, XmlElementStartTagSyntax startTag, GreenNode? content, XmlElementEndTagSyntax endTag)
          : base(kind)
        {
            this.SlotCount = 3;
            this.AdjustFlagsAndWidth(startTag);
            this.startTag = startTag;
            if (content != null)
            {
                this.AdjustFlagsAndWidth(content);
                this.content = content;
            }
            this.AdjustFlagsAndWidth(endTag);
            this.endTag = endTag;
        }

        public XmlElementStartTagSyntax StartTag => this.startTag;
        public Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<XmlNodeSyntax> Content => new Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<XmlNodeSyntax>(this.content);
        public XmlElementEndTagSyntax EndTag => this.endTag;

        internal override GreenNode? GetSlot(int index)
            => index switch
            {
                0 => this.startTag,
                1 => this.content,
                2 => this.endTag,
                _ => null,
            };

        internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new CSharp.Syntax.XmlElementSyntax(this, parent, position);

        public override void Accept(CSharpSyntaxVisitor visitor) => visitor.VisitXmlElement(this);
        public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor) => visitor.VisitXmlElement(this);

        public XmlElementSyntax Update(XmlElementStartTagSyntax startTag, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<XmlNodeSyntax> content, XmlElementEndTagSyntax endTag)
        {
            if (startTag != this.StartTag || content != this.Content || endTag != this.EndTag)
            {
                var newNode = SyntaxFactory.XmlElement(startTag, content, endTag);
                var diags = GetDiagnostics();
                if (diags?.Length > 0)
                    newNode = newNode.WithDiagnosticsGreen(diags);
                var annotations = GetAnnotations();
                if (annotations?.Length > 0)
                    newNode = newNode.WithAnnotationsGreen(annotations);
                return newNode;
            }

            return this;
        }

        internal override GreenNode SetDiagnostics(DiagnosticInfo[]? diagnostics)
            => new XmlElementSyntax(this.Kind, this.startTag, this.content, this.endTag, diagnostics, GetAnnotations());

        internal override GreenNode SetAnnotations(SyntaxAnnotation[]? annotations)
            => new XmlElementSyntax(this.Kind, this.startTag, this.content, this.endTag, GetDiagnostics(), annotations);

        internal XmlElementSyntax(ObjectReader reader)
          : base(reader)
        {
            this.SlotCount = 3;
            var startTag = (XmlElementStartTagSyntax)reader.ReadValue();
            AdjustFlagsAndWidth(startTag);
            this.startTag = startTag;
            var content = (GreenNode?)reader.ReadValue();
            if (content != null)
            {
                AdjustFlagsAndWidth(content);
                this.content = content;
            }
            var endTag = (XmlElementEndTagSyntax)reader.ReadValue();
            AdjustFlagsAndWidth(endTag);
            this.endTag = endTag;
        }

        internal override void WriteTo(ObjectWriter writer)
        {
            base.WriteTo(writer);
            writer.WriteValue(this.startTag);
            writer.WriteValue(this.content);
            writer.WriteValue(this.endTag);
        }

        static XmlElementSyntax()
        {
            ObjectBinder.RegisterTypeReader(typeof(XmlElementSyntax), r => new XmlElementSyntax(r));
        }
    }

    internal sealed partial class XmlElementStartTagSyntax : CSharpSyntaxNode
    {
        internal readonly SyntaxToken lessThanToken;
        internal readonly XmlNameSyntax name;
        internal readonly GreenNode? attributes;
        internal readonly SyntaxToken greaterThanToken;

        internal XmlElementStartTagSyntax(SyntaxKind kind, SyntaxToken lessThanToken, XmlNameSyntax name, GreenNode? attributes, SyntaxToken greaterThanToken, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
            this.SlotCount = 4;
            this.AdjustFlagsAndWidth(lessThanToken);
            this.lessThanToken = lessThanToken;
            this.AdjustFlagsAndWidth(name);
            this.name = name;
            if (attributes != null)
            {
                this.AdjustFlagsAndWidth(attributes);
                this.attributes = attributes;
            }
            this.AdjustFlagsAndWidth(greaterThanToken);
            this.greaterThanToken = greaterThanToken;
        }

        internal XmlElementStartTagSyntax(SyntaxKind kind, SyntaxToken lessThanToken, XmlNameSyntax name, GreenNode? attributes, SyntaxToken greaterThanToken, SyntaxFactoryContext context)
          : base(kind)
        {
            this.SetFactoryContext(context);
            this.SlotCount = 4;
            this.AdjustFlagsAndWidth(lessThanToken);
            this.lessThanToken = lessThanToken;
            this.AdjustFlagsAndWidth(name);
            this.name = name;
            if (attributes != null)
            {
                this.AdjustFlagsAndWidth(attributes);
                this.attributes = attributes;
            }
            this.AdjustFlagsAndWidth(greaterThanToken);
            this.greaterThanToken = greaterThanToken;
        }

        internal XmlElementStartTagSyntax(SyntaxKind kind, SyntaxToken lessThanToken, XmlNameSyntax name, GreenNode? attributes, SyntaxToken greaterThanToken)
          : base(kind)
        {
            this.SlotCount = 4;
            this.AdjustFlagsAndWidth(lessThanToken);
            this.lessThanToken = lessThanToken;
            this.AdjustFlagsAndWidth(name);
            this.name = name;
            if (attributes != null)
            {
                this.AdjustFlagsAndWidth(attributes);
                this.attributes = attributes;
            }
            this.AdjustFlagsAndWidth(greaterThanToken);
            this.greaterThanToken = greaterThanToken;
        }

        public SyntaxToken LessThanToken => this.lessThanToken;
        public XmlNameSyntax Name => this.name;
        public Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<XmlAttributeSyntax> Attributes => new Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<XmlAttributeSyntax>(this.attributes);
        public SyntaxToken GreaterThanToken => this.greaterThanToken;

        internal override GreenNode? GetSlot(int index)
            => index switch
            {
                0 => this.lessThanToken,
                1 => this.name,
                2 => this.attributes,
                3 => this.greaterThanToken,
                _ => null,
            };

        internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new CSharp.Syntax.XmlElementStartTagSyntax(this, parent, position);

        public override void Accept(CSharpSyntaxVisitor visitor) => visitor.VisitXmlElementStartTag(this);
        public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor) => visitor.VisitXmlElementStartTag(this);

        public XmlElementStartTagSyntax Update(SyntaxToken lessThanToken, XmlNameSyntax name, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<XmlAttributeSyntax> attributes, SyntaxToken greaterThanToken)
        {
            if (lessThanToken != this.LessThanToken || name != this.Name || attributes != this.Attributes || greaterThanToken != this.GreaterThanToken)
            {
                var newNode = SyntaxFactory.XmlElementStartTag(lessThanToken, name, attributes, greaterThanToken);
                var diags = GetDiagnostics();
                if (diags?.Length > 0)
                    newNode = newNode.WithDiagnosticsGreen(diags);
                var annotations = GetAnnotations();
                if (annotations?.Length > 0)
                    newNode = newNode.WithAnnotationsGreen(annotations);
                return newNode;
            }

            return this;
        }

        internal override GreenNode SetDiagnostics(DiagnosticInfo[]? diagnostics)
            => new XmlElementStartTagSyntax(this.Kind, this.lessThanToken, this.name, this.attributes, this.greaterThanToken, diagnostics, GetAnnotations());

        internal override GreenNode SetAnnotations(SyntaxAnnotation[]? annotations)
            => new XmlElementStartTagSyntax(this.Kind, this.lessThanToken, this.name, this.attributes, this.greaterThanToken, GetDiagnostics(), annotations);

        internal XmlElementStartTagSyntax(ObjectReader reader)
          : base(reader)
        {
            this.SlotCount = 4;
            var lessThanToken = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(lessThanToken);
            this.lessThanToken = lessThanToken;
            var name = (XmlNameSyntax)reader.ReadValue();
            AdjustFlagsAndWidth(name);
            this.name = name;
            var attributes = (GreenNode?)reader.ReadValue();
            if (attributes != null)
            {
                AdjustFlagsAndWidth(attributes);
                this.attributes = attributes;
            }
            var greaterThanToken = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(greaterThanToken);
            this.greaterThanToken = greaterThanToken;
        }

        internal override void WriteTo(ObjectWriter writer)
        {
            base.WriteTo(writer);
            writer.WriteValue(this.lessThanToken);
            writer.WriteValue(this.name);
            writer.WriteValue(this.attributes);
            writer.WriteValue(this.greaterThanToken);
        }

        static XmlElementStartTagSyntax()
        {
            ObjectBinder.RegisterTypeReader(typeof(XmlElementStartTagSyntax), r => new XmlElementStartTagSyntax(r));
        }
    }

    internal sealed partial class XmlElementEndTagSyntax : CSharpSyntaxNode
    {
        internal readonly SyntaxToken lessThanSlashToken;
        internal readonly XmlNameSyntax name;
        internal readonly SyntaxToken greaterThanToken;

        internal XmlElementEndTagSyntax(SyntaxKind kind, SyntaxToken lessThanSlashToken, XmlNameSyntax name, SyntaxToken greaterThanToken, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
            this.SlotCount = 3;
            this.AdjustFlagsAndWidth(lessThanSlashToken);
            this.lessThanSlashToken = lessThanSlashToken;
            this.AdjustFlagsAndWidth(name);
            this.name = name;
            this.AdjustFlagsAndWidth(greaterThanToken);
            this.greaterThanToken = greaterThanToken;
        }

        internal XmlElementEndTagSyntax(SyntaxKind kind, SyntaxToken lessThanSlashToken, XmlNameSyntax name, SyntaxToken greaterThanToken, SyntaxFactoryContext context)
          : base(kind)
        {
            this.SetFactoryContext(context);
            this.SlotCount = 3;
            this.AdjustFlagsAndWidth(lessThanSlashToken);
            this.lessThanSlashToken = lessThanSlashToken;
            this.AdjustFlagsAndWidth(name);
            this.name = name;
            this.AdjustFlagsAndWidth(greaterThanToken);
            this.greaterThanToken = greaterThanToken;
        }

        internal XmlElementEndTagSyntax(SyntaxKind kind, SyntaxToken lessThanSlashToken, XmlNameSyntax name, SyntaxToken greaterThanToken)
          : base(kind)
        {
            this.SlotCount = 3;
            this.AdjustFlagsAndWidth(lessThanSlashToken);
            this.lessThanSlashToken = lessThanSlashToken;
            this.AdjustFlagsAndWidth(name);
            this.name = name;
            this.AdjustFlagsAndWidth(greaterThanToken);
            this.greaterThanToken = greaterThanToken;
        }

        public SyntaxToken LessThanSlashToken => this.lessThanSlashToken;
        public XmlNameSyntax Name => this.name;
        public SyntaxToken GreaterThanToken => this.greaterThanToken;

        internal override GreenNode? GetSlot(int index)
            => index switch
            {
                0 => this.lessThanSlashToken,
                1 => this.name,
                2 => this.greaterThanToken,
                _ => null,
            };

        internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new CSharp.Syntax.XmlElementEndTagSyntax(this, parent, position);

        public override void Accept(CSharpSyntaxVisitor visitor) => visitor.VisitXmlElementEndTag(this);
        public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor) => visitor.VisitXmlElementEndTag(this);

        public XmlElementEndTagSyntax Update(SyntaxToken lessThanSlashToken, XmlNameSyntax name, SyntaxToken greaterThanToken)
        {
            if (lessThanSlashToken != this.LessThanSlashToken || name != this.Name || greaterThanToken != this.GreaterThanToken)
            {
                var newNode = SyntaxFactory.XmlElementEndTag(lessThanSlashToken, name, greaterThanToken);
                var diags = GetDiagnostics();
                if (diags?.Length > 0)
                    newNode = newNode.WithDiagnosticsGreen(diags);
                var annotations = GetAnnotations();
                if (annotations?.Length > 0)
                    newNode = newNode.WithAnnotationsGreen(annotations);
                return newNode;
            }

            return this;
        }

        internal override GreenNode SetDiagnostics(DiagnosticInfo[]? diagnostics)
            => new XmlElementEndTagSyntax(this.Kind, this.lessThanSlashToken, this.name, this.greaterThanToken, diagnostics, GetAnnotations());

        internal override GreenNode SetAnnotations(SyntaxAnnotation[]? annotations)
            => new XmlElementEndTagSyntax(this.Kind, this.lessThanSlashToken, this.name, this.greaterThanToken, GetDiagnostics(), annotations);

        internal XmlElementEndTagSyntax(ObjectReader reader)
          : base(reader)
        {
            this.SlotCount = 3;
            var lessThanSlashToken = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(lessThanSlashToken);
            this.lessThanSlashToken = lessThanSlashToken;
            var name = (XmlNameSyntax)reader.ReadValue();
            AdjustFlagsAndWidth(name);
            this.name = name;
            var greaterThanToken = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(greaterThanToken);
            this.greaterThanToken = greaterThanToken;
        }

        internal override void WriteTo(ObjectWriter writer)
        {
            base.WriteTo(writer);
            writer.WriteValue(this.lessThanSlashToken);
            writer.WriteValue(this.name);
            writer.WriteValue(this.greaterThanToken);
        }

        static XmlElementEndTagSyntax()
        {
            ObjectBinder.RegisterTypeReader(typeof(XmlElementEndTagSyntax), r => new XmlElementEndTagSyntax(r));
        }
    }

    internal sealed partial class XmlEmptyElementSyntax : XmlNodeSyntax
    {
        internal readonly SyntaxToken lessThanToken;
        internal readonly XmlNameSyntax name;
        internal readonly GreenNode? attributes;
        internal readonly SyntaxToken slashGreaterThanToken;

        internal XmlEmptyElementSyntax(SyntaxKind kind, SyntaxToken lessThanToken, XmlNameSyntax name, GreenNode? attributes, SyntaxToken slashGreaterThanToken, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
            this.SlotCount = 4;
            this.AdjustFlagsAndWidth(lessThanToken);
            this.lessThanToken = lessThanToken;
            this.AdjustFlagsAndWidth(name);
            this.name = name;
            if (attributes != null)
            {
                this.AdjustFlagsAndWidth(attributes);
                this.attributes = attributes;
            }
            this.AdjustFlagsAndWidth(slashGreaterThanToken);
            this.slashGreaterThanToken = slashGreaterThanToken;
        }

        internal XmlEmptyElementSyntax(SyntaxKind kind, SyntaxToken lessThanToken, XmlNameSyntax name, GreenNode? attributes, SyntaxToken slashGreaterThanToken, SyntaxFactoryContext context)
          : base(kind)
        {
            this.SetFactoryContext(context);
            this.SlotCount = 4;
            this.AdjustFlagsAndWidth(lessThanToken);
            this.lessThanToken = lessThanToken;
            this.AdjustFlagsAndWidth(name);
            this.name = name;
            if (attributes != null)
            {
                this.AdjustFlagsAndWidth(attributes);
                this.attributes = attributes;
            }
            this.AdjustFlagsAndWidth(slashGreaterThanToken);
            this.slashGreaterThanToken = slashGreaterThanToken;
        }

        internal XmlEmptyElementSyntax(SyntaxKind kind, SyntaxToken lessThanToken, XmlNameSyntax name, GreenNode? attributes, SyntaxToken slashGreaterThanToken)
          : base(kind)
        {
            this.SlotCount = 4;
            this.AdjustFlagsAndWidth(lessThanToken);
            this.lessThanToken = lessThanToken;
            this.AdjustFlagsAndWidth(name);
            this.name = name;
            if (attributes != null)
            {
                this.AdjustFlagsAndWidth(attributes);
                this.attributes = attributes;
            }
            this.AdjustFlagsAndWidth(slashGreaterThanToken);
            this.slashGreaterThanToken = slashGreaterThanToken;
        }

        public SyntaxToken LessThanToken => this.lessThanToken;
        public XmlNameSyntax Name => this.name;
        public Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<XmlAttributeSyntax> Attributes => new Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<XmlAttributeSyntax>(this.attributes);
        public SyntaxToken SlashGreaterThanToken => this.slashGreaterThanToken;

        internal override GreenNode? GetSlot(int index)
            => index switch
            {
                0 => this.lessThanToken,
                1 => this.name,
                2 => this.attributes,
                3 => this.slashGreaterThanToken,
                _ => null,
            };

        internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new CSharp.Syntax.XmlEmptyElementSyntax(this, parent, position);

        public override void Accept(CSharpSyntaxVisitor visitor) => visitor.VisitXmlEmptyElement(this);
        public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor) => visitor.VisitXmlEmptyElement(this);

        public XmlEmptyElementSyntax Update(SyntaxToken lessThanToken, XmlNameSyntax name, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<XmlAttributeSyntax> attributes, SyntaxToken slashGreaterThanToken)
        {
            if (lessThanToken != this.LessThanToken || name != this.Name || attributes != this.Attributes || slashGreaterThanToken != this.SlashGreaterThanToken)
            {
                var newNode = SyntaxFactory.XmlEmptyElement(lessThanToken, name, attributes, slashGreaterThanToken);
                var diags = GetDiagnostics();
                if (diags?.Length > 0)
                    newNode = newNode.WithDiagnosticsGreen(diags);
                var annotations = GetAnnotations();
                if (annotations?.Length > 0)
                    newNode = newNode.WithAnnotationsGreen(annotations);
                return newNode;
            }

            return this;
        }

        internal override GreenNode SetDiagnostics(DiagnosticInfo[]? diagnostics)
            => new XmlEmptyElementSyntax(this.Kind, this.lessThanToken, this.name, this.attributes, this.slashGreaterThanToken, diagnostics, GetAnnotations());

        internal override GreenNode SetAnnotations(SyntaxAnnotation[]? annotations)
            => new XmlEmptyElementSyntax(this.Kind, this.lessThanToken, this.name, this.attributes, this.slashGreaterThanToken, GetDiagnostics(), annotations);

        internal XmlEmptyElementSyntax(ObjectReader reader)
          : base(reader)
        {
            this.SlotCount = 4;
            var lessThanToken = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(lessThanToken);
            this.lessThanToken = lessThanToken;
            var name = (XmlNameSyntax)reader.ReadValue();
            AdjustFlagsAndWidth(name);
            this.name = name;
            var attributes = (GreenNode?)reader.ReadValue();
            if (attributes != null)
            {
                AdjustFlagsAndWidth(attributes);
                this.attributes = attributes;
            }
            var slashGreaterThanToken = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(slashGreaterThanToken);
            this.slashGreaterThanToken = slashGreaterThanToken;
        }

        internal override void WriteTo(ObjectWriter writer)
        {
            base.WriteTo(writer);
            writer.WriteValue(this.lessThanToken);
            writer.WriteValue(this.name);
            writer.WriteValue(this.attributes);
            writer.WriteValue(this.slashGreaterThanToken);
        }

        static XmlEmptyElementSyntax()
        {
            ObjectBinder.RegisterTypeReader(typeof(XmlEmptyElementSyntax), r => new XmlEmptyElementSyntax(r));
        }
    }

    internal sealed partial class XmlNameSyntax : CSharpSyntaxNode
    {
        internal readonly XmlPrefixSyntax? prefix;
        internal readonly SyntaxToken localName;

        internal XmlNameSyntax(SyntaxKind kind, XmlPrefixSyntax? prefix, SyntaxToken localName, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
            this.SlotCount = 2;
            if (prefix != null)
            {
                this.AdjustFlagsAndWidth(prefix);
                this.prefix = prefix;
            }
            this.AdjustFlagsAndWidth(localName);
            this.localName = localName;
        }

        internal XmlNameSyntax(SyntaxKind kind, XmlPrefixSyntax? prefix, SyntaxToken localName, SyntaxFactoryContext context)
          : base(kind)
        {
            this.SetFactoryContext(context);
            this.SlotCount = 2;
            if (prefix != null)
            {
                this.AdjustFlagsAndWidth(prefix);
                this.prefix = prefix;
            }
            this.AdjustFlagsAndWidth(localName);
            this.localName = localName;
        }

        internal XmlNameSyntax(SyntaxKind kind, XmlPrefixSyntax? prefix, SyntaxToken localName)
          : base(kind)
        {
            this.SlotCount = 2;
            if (prefix != null)
            {
                this.AdjustFlagsAndWidth(prefix);
                this.prefix = prefix;
            }
            this.AdjustFlagsAndWidth(localName);
            this.localName = localName;
        }

        public XmlPrefixSyntax? Prefix => this.prefix;
        public SyntaxToken LocalName => this.localName;

        internal override GreenNode? GetSlot(int index)
            => index switch
            {
                0 => this.prefix,
                1 => this.localName,
                _ => null,
            };

        internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new CSharp.Syntax.XmlNameSyntax(this, parent, position);

        public override void Accept(CSharpSyntaxVisitor visitor) => visitor.VisitXmlName(this);
        public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor) => visitor.VisitXmlName(this);

        public XmlNameSyntax Update(XmlPrefixSyntax prefix, SyntaxToken localName)
        {
            if (prefix != this.Prefix || localName != this.LocalName)
            {
                var newNode = SyntaxFactory.XmlName(prefix, localName);
                var diags = GetDiagnostics();
                if (diags?.Length > 0)
                    newNode = newNode.WithDiagnosticsGreen(diags);
                var annotations = GetAnnotations();
                if (annotations?.Length > 0)
                    newNode = newNode.WithAnnotationsGreen(annotations);
                return newNode;
            }

            return this;
        }

        internal override GreenNode SetDiagnostics(DiagnosticInfo[]? diagnostics)
            => new XmlNameSyntax(this.Kind, this.prefix, this.localName, diagnostics, GetAnnotations());

        internal override GreenNode SetAnnotations(SyntaxAnnotation[]? annotations)
            => new XmlNameSyntax(this.Kind, this.prefix, this.localName, GetDiagnostics(), annotations);

        internal XmlNameSyntax(ObjectReader reader)
          : base(reader)
        {
            this.SlotCount = 2;
            var prefix = (XmlPrefixSyntax?)reader.ReadValue();
            if (prefix != null)
            {
                AdjustFlagsAndWidth(prefix);
                this.prefix = prefix;
            }
            var localName = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(localName);
            this.localName = localName;
        }

        internal override void WriteTo(ObjectWriter writer)
        {
            base.WriteTo(writer);
            writer.WriteValue(this.prefix);
            writer.WriteValue(this.localName);
        }

        static XmlNameSyntax()
        {
            ObjectBinder.RegisterTypeReader(typeof(XmlNameSyntax), r => new XmlNameSyntax(r));
        }
    }

    internal sealed partial class XmlPrefixSyntax : CSharpSyntaxNode
    {
        internal readonly SyntaxToken prefix;
        internal readonly SyntaxToken colonToken;

        internal XmlPrefixSyntax(SyntaxKind kind, SyntaxToken prefix, SyntaxToken colonToken, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
            this.SlotCount = 2;
            this.AdjustFlagsAndWidth(prefix);
            this.prefix = prefix;
            this.AdjustFlagsAndWidth(colonToken);
            this.colonToken = colonToken;
        }

        internal XmlPrefixSyntax(SyntaxKind kind, SyntaxToken prefix, SyntaxToken colonToken, SyntaxFactoryContext context)
          : base(kind)
        {
            this.SetFactoryContext(context);
            this.SlotCount = 2;
            this.AdjustFlagsAndWidth(prefix);
            this.prefix = prefix;
            this.AdjustFlagsAndWidth(colonToken);
            this.colonToken = colonToken;
        }

        internal XmlPrefixSyntax(SyntaxKind kind, SyntaxToken prefix, SyntaxToken colonToken)
          : base(kind)
        {
            this.SlotCount = 2;
            this.AdjustFlagsAndWidth(prefix);
            this.prefix = prefix;
            this.AdjustFlagsAndWidth(colonToken);
            this.colonToken = colonToken;
        }

        public SyntaxToken Prefix => this.prefix;
        public SyntaxToken ColonToken => this.colonToken;

        internal override GreenNode? GetSlot(int index)
            => index switch
            {
                0 => this.prefix,
                1 => this.colonToken,
                _ => null,
            };

        internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new CSharp.Syntax.XmlPrefixSyntax(this, parent, position);

        public override void Accept(CSharpSyntaxVisitor visitor) => visitor.VisitXmlPrefix(this);
        public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor) => visitor.VisitXmlPrefix(this);

        public XmlPrefixSyntax Update(SyntaxToken prefix, SyntaxToken colonToken)
        {
            if (prefix != this.Prefix || colonToken != this.ColonToken)
            {
                var newNode = SyntaxFactory.XmlPrefix(prefix, colonToken);
                var diags = GetDiagnostics();
                if (diags?.Length > 0)
                    newNode = newNode.WithDiagnosticsGreen(diags);
                var annotations = GetAnnotations();
                if (annotations?.Length > 0)
                    newNode = newNode.WithAnnotationsGreen(annotations);
                return newNode;
            }

            return this;
        }

        internal override GreenNode SetDiagnostics(DiagnosticInfo[]? diagnostics)
            => new XmlPrefixSyntax(this.Kind, this.prefix, this.colonToken, diagnostics, GetAnnotations());

        internal override GreenNode SetAnnotations(SyntaxAnnotation[]? annotations)
            => new XmlPrefixSyntax(this.Kind, this.prefix, this.colonToken, GetDiagnostics(), annotations);

        internal XmlPrefixSyntax(ObjectReader reader)
          : base(reader)
        {
            this.SlotCount = 2;
            var prefix = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(prefix);
            this.prefix = prefix;
            var colonToken = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(colonToken);
            this.colonToken = colonToken;
        }

        internal override void WriteTo(ObjectWriter writer)
        {
            base.WriteTo(writer);
            writer.WriteValue(this.prefix);
            writer.WriteValue(this.colonToken);
        }

        static XmlPrefixSyntax()
        {
            ObjectBinder.RegisterTypeReader(typeof(XmlPrefixSyntax), r => new XmlPrefixSyntax(r));
        }
    }

    internal abstract partial class XmlAttributeSyntax : CSharpSyntaxNode
    {
        internal XmlAttributeSyntax(SyntaxKind kind, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
        }

        internal XmlAttributeSyntax(SyntaxKind kind)
          : base(kind)
        {
        }

        protected XmlAttributeSyntax(ObjectReader reader)
          : base(reader)
        {
        }

        public abstract XmlNameSyntax Name { get; }

        public abstract SyntaxToken EqualsToken { get; }

        public abstract SyntaxToken StartQuoteToken { get; }

        public abstract SyntaxToken EndQuoteToken { get; }
    }

    internal sealed partial class XmlTextAttributeSyntax : XmlAttributeSyntax
    {
        internal readonly XmlNameSyntax name;
        internal readonly SyntaxToken equalsToken;
        internal readonly SyntaxToken startQuoteToken;
        internal readonly GreenNode? textTokens;
        internal readonly SyntaxToken endQuoteToken;

        internal XmlTextAttributeSyntax(SyntaxKind kind, XmlNameSyntax name, SyntaxToken equalsToken, SyntaxToken startQuoteToken, GreenNode? textTokens, SyntaxToken endQuoteToken, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
            this.SlotCount = 5;
            this.AdjustFlagsAndWidth(name);
            this.name = name;
            this.AdjustFlagsAndWidth(equalsToken);
            this.equalsToken = equalsToken;
            this.AdjustFlagsAndWidth(startQuoteToken);
            this.startQuoteToken = startQuoteToken;
            if (textTokens != null)
            {
                this.AdjustFlagsAndWidth(textTokens);
                this.textTokens = textTokens;
            }
            this.AdjustFlagsAndWidth(endQuoteToken);
            this.endQuoteToken = endQuoteToken;
        }

        internal XmlTextAttributeSyntax(SyntaxKind kind, XmlNameSyntax name, SyntaxToken equalsToken, SyntaxToken startQuoteToken, GreenNode? textTokens, SyntaxToken endQuoteToken, SyntaxFactoryContext context)
          : base(kind)
        {
            this.SetFactoryContext(context);
            this.SlotCount = 5;
            this.AdjustFlagsAndWidth(name);
            this.name = name;
            this.AdjustFlagsAndWidth(equalsToken);
            this.equalsToken = equalsToken;
            this.AdjustFlagsAndWidth(startQuoteToken);
            this.startQuoteToken = startQuoteToken;
            if (textTokens != null)
            {
                this.AdjustFlagsAndWidth(textTokens);
                this.textTokens = textTokens;
            }
            this.AdjustFlagsAndWidth(endQuoteToken);
            this.endQuoteToken = endQuoteToken;
        }

        internal XmlTextAttributeSyntax(SyntaxKind kind, XmlNameSyntax name, SyntaxToken equalsToken, SyntaxToken startQuoteToken, GreenNode? textTokens, SyntaxToken endQuoteToken)
          : base(kind)
        {
            this.SlotCount = 5;
            this.AdjustFlagsAndWidth(name);
            this.name = name;
            this.AdjustFlagsAndWidth(equalsToken);
            this.equalsToken = equalsToken;
            this.AdjustFlagsAndWidth(startQuoteToken);
            this.startQuoteToken = startQuoteToken;
            if (textTokens != null)
            {
                this.AdjustFlagsAndWidth(textTokens);
                this.textTokens = textTokens;
            }
            this.AdjustFlagsAndWidth(endQuoteToken);
            this.endQuoteToken = endQuoteToken;
        }

        public override XmlNameSyntax Name => this.name;
        public override SyntaxToken EqualsToken => this.equalsToken;
        public override SyntaxToken StartQuoteToken => this.startQuoteToken;
        public Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SyntaxToken> TextTokens => new Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SyntaxToken>(this.textTokens);
        public override SyntaxToken EndQuoteToken => this.endQuoteToken;

        internal override GreenNode? GetSlot(int index)
            => index switch
            {
                0 => this.name,
                1 => this.equalsToken,
                2 => this.startQuoteToken,
                3 => this.textTokens,
                4 => this.endQuoteToken,
                _ => null,
            };

        internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new CSharp.Syntax.XmlTextAttributeSyntax(this, parent, position);

        public override void Accept(CSharpSyntaxVisitor visitor) => visitor.VisitXmlTextAttribute(this);
        public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor) => visitor.VisitXmlTextAttribute(this);

        public XmlTextAttributeSyntax Update(XmlNameSyntax name, SyntaxToken equalsToken, SyntaxToken startQuoteToken, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SyntaxToken> textTokens, SyntaxToken endQuoteToken)
        {
            if (name != this.Name || equalsToken != this.EqualsToken || startQuoteToken != this.StartQuoteToken || textTokens != this.TextTokens || endQuoteToken != this.EndQuoteToken)
            {
                var newNode = SyntaxFactory.XmlTextAttribute(name, equalsToken, startQuoteToken, textTokens, endQuoteToken);
                var diags = GetDiagnostics();
                if (diags?.Length > 0)
                    newNode = newNode.WithDiagnosticsGreen(diags);
                var annotations = GetAnnotations();
                if (annotations?.Length > 0)
                    newNode = newNode.WithAnnotationsGreen(annotations);
                return newNode;
            }

            return this;
        }

        internal override GreenNode SetDiagnostics(DiagnosticInfo[]? diagnostics)
            => new XmlTextAttributeSyntax(this.Kind, this.name, this.equalsToken, this.startQuoteToken, this.textTokens, this.endQuoteToken, diagnostics, GetAnnotations());

        internal override GreenNode SetAnnotations(SyntaxAnnotation[]? annotations)
            => new XmlTextAttributeSyntax(this.Kind, this.name, this.equalsToken, this.startQuoteToken, this.textTokens, this.endQuoteToken, GetDiagnostics(), annotations);

        internal XmlTextAttributeSyntax(ObjectReader reader)
          : base(reader)
        {
            this.SlotCount = 5;
            var name = (XmlNameSyntax)reader.ReadValue();
            AdjustFlagsAndWidth(name);
            this.name = name;
            var equalsToken = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(equalsToken);
            this.equalsToken = equalsToken;
            var startQuoteToken = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(startQuoteToken);
            this.startQuoteToken = startQuoteToken;
            var textTokens = (GreenNode?)reader.ReadValue();
            if (textTokens != null)
            {
                AdjustFlagsAndWidth(textTokens);
                this.textTokens = textTokens;
            }
            var endQuoteToken = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(endQuoteToken);
            this.endQuoteToken = endQuoteToken;
        }

        internal override void WriteTo(ObjectWriter writer)
        {
            base.WriteTo(writer);
            writer.WriteValue(this.name);
            writer.WriteValue(this.equalsToken);
            writer.WriteValue(this.startQuoteToken);
            writer.WriteValue(this.textTokens);
            writer.WriteValue(this.endQuoteToken);
        }

        static XmlTextAttributeSyntax()
        {
            ObjectBinder.RegisterTypeReader(typeof(XmlTextAttributeSyntax), r => new XmlTextAttributeSyntax(r));
        }
    }

    internal sealed partial class XmlCrefAttributeSyntax : XmlAttributeSyntax
    {
        internal readonly XmlNameSyntax name;
        internal readonly SyntaxToken equalsToken;
        internal readonly SyntaxToken startQuoteToken;
        internal readonly CrefSyntax cref;
        internal readonly SyntaxToken endQuoteToken;

        internal XmlCrefAttributeSyntax(SyntaxKind kind, XmlNameSyntax name, SyntaxToken equalsToken, SyntaxToken startQuoteToken, CrefSyntax cref, SyntaxToken endQuoteToken, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
            this.SlotCount = 5;
            this.AdjustFlagsAndWidth(name);
            this.name = name;
            this.AdjustFlagsAndWidth(equalsToken);
            this.equalsToken = equalsToken;
            this.AdjustFlagsAndWidth(startQuoteToken);
            this.startQuoteToken = startQuoteToken;
            this.AdjustFlagsAndWidth(cref);
            this.cref = cref;
            this.AdjustFlagsAndWidth(endQuoteToken);
            this.endQuoteToken = endQuoteToken;
        }

        internal XmlCrefAttributeSyntax(SyntaxKind kind, XmlNameSyntax name, SyntaxToken equalsToken, SyntaxToken startQuoteToken, CrefSyntax cref, SyntaxToken endQuoteToken, SyntaxFactoryContext context)
          : base(kind)
        {
            this.SetFactoryContext(context);
            this.SlotCount = 5;
            this.AdjustFlagsAndWidth(name);
            this.name = name;
            this.AdjustFlagsAndWidth(equalsToken);
            this.equalsToken = equalsToken;
            this.AdjustFlagsAndWidth(startQuoteToken);
            this.startQuoteToken = startQuoteToken;
            this.AdjustFlagsAndWidth(cref);
            this.cref = cref;
            this.AdjustFlagsAndWidth(endQuoteToken);
            this.endQuoteToken = endQuoteToken;
        }

        internal XmlCrefAttributeSyntax(SyntaxKind kind, XmlNameSyntax name, SyntaxToken equalsToken, SyntaxToken startQuoteToken, CrefSyntax cref, SyntaxToken endQuoteToken)
          : base(kind)
        {
            this.SlotCount = 5;
            this.AdjustFlagsAndWidth(name);
            this.name = name;
            this.AdjustFlagsAndWidth(equalsToken);
            this.equalsToken = equalsToken;
            this.AdjustFlagsAndWidth(startQuoteToken);
            this.startQuoteToken = startQuoteToken;
            this.AdjustFlagsAndWidth(cref);
            this.cref = cref;
            this.AdjustFlagsAndWidth(endQuoteToken);
            this.endQuoteToken = endQuoteToken;
        }

        public override XmlNameSyntax Name => this.name;
        public override SyntaxToken EqualsToken => this.equalsToken;
        public override SyntaxToken StartQuoteToken => this.startQuoteToken;
        public CrefSyntax Cref => this.cref;
        public override SyntaxToken EndQuoteToken => this.endQuoteToken;

        internal override GreenNode? GetSlot(int index)
            => index switch
            {
                0 => this.name,
                1 => this.equalsToken,
                2 => this.startQuoteToken,
                3 => this.cref,
                4 => this.endQuoteToken,
                _ => null,
            };

        internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new CSharp.Syntax.XmlCrefAttributeSyntax(this, parent, position);

        public override void Accept(CSharpSyntaxVisitor visitor) => visitor.VisitXmlCrefAttribute(this);
        public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor) => visitor.VisitXmlCrefAttribute(this);

        public XmlCrefAttributeSyntax Update(XmlNameSyntax name, SyntaxToken equalsToken, SyntaxToken startQuoteToken, CrefSyntax cref, SyntaxToken endQuoteToken)
        {
            if (name != this.Name || equalsToken != this.EqualsToken || startQuoteToken != this.StartQuoteToken || cref != this.Cref || endQuoteToken != this.EndQuoteToken)
            {
                var newNode = SyntaxFactory.XmlCrefAttribute(name, equalsToken, startQuoteToken, cref, endQuoteToken);
                var diags = GetDiagnostics();
                if (diags?.Length > 0)
                    newNode = newNode.WithDiagnosticsGreen(diags);
                var annotations = GetAnnotations();
                if (annotations?.Length > 0)
                    newNode = newNode.WithAnnotationsGreen(annotations);
                return newNode;
            }

            return this;
        }

        internal override GreenNode SetDiagnostics(DiagnosticInfo[]? diagnostics)
            => new XmlCrefAttributeSyntax(this.Kind, this.name, this.equalsToken, this.startQuoteToken, this.cref, this.endQuoteToken, diagnostics, GetAnnotations());

        internal override GreenNode SetAnnotations(SyntaxAnnotation[]? annotations)
            => new XmlCrefAttributeSyntax(this.Kind, this.name, this.equalsToken, this.startQuoteToken, this.cref, this.endQuoteToken, GetDiagnostics(), annotations);

        internal XmlCrefAttributeSyntax(ObjectReader reader)
          : base(reader)
        {
            this.SlotCount = 5;
            var name = (XmlNameSyntax)reader.ReadValue();
            AdjustFlagsAndWidth(name);
            this.name = name;
            var equalsToken = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(equalsToken);
            this.equalsToken = equalsToken;
            var startQuoteToken = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(startQuoteToken);
            this.startQuoteToken = startQuoteToken;
            var cref = (CrefSyntax)reader.ReadValue();
            AdjustFlagsAndWidth(cref);
            this.cref = cref;
            var endQuoteToken = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(endQuoteToken);
            this.endQuoteToken = endQuoteToken;
        }

        internal override void WriteTo(ObjectWriter writer)
        {
            base.WriteTo(writer);
            writer.WriteValue(this.name);
            writer.WriteValue(this.equalsToken);
            writer.WriteValue(this.startQuoteToken);
            writer.WriteValue(this.cref);
            writer.WriteValue(this.endQuoteToken);
        }

        static XmlCrefAttributeSyntax()
        {
            ObjectBinder.RegisterTypeReader(typeof(XmlCrefAttributeSyntax), r => new XmlCrefAttributeSyntax(r));
        }
    }

    internal sealed partial class XmlNameAttributeSyntax : XmlAttributeSyntax
    {
        internal readonly XmlNameSyntax name;
        internal readonly SyntaxToken equalsToken;
        internal readonly SyntaxToken startQuoteToken;
        internal readonly IdentifierNameSyntax identifier;
        internal readonly SyntaxToken endQuoteToken;

        internal XmlNameAttributeSyntax(SyntaxKind kind, XmlNameSyntax name, SyntaxToken equalsToken, SyntaxToken startQuoteToken, IdentifierNameSyntax identifier, SyntaxToken endQuoteToken, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
            this.SlotCount = 5;
            this.AdjustFlagsAndWidth(name);
            this.name = name;
            this.AdjustFlagsAndWidth(equalsToken);
            this.equalsToken = equalsToken;
            this.AdjustFlagsAndWidth(startQuoteToken);
            this.startQuoteToken = startQuoteToken;
            this.AdjustFlagsAndWidth(identifier);
            this.identifier = identifier;
            this.AdjustFlagsAndWidth(endQuoteToken);
            this.endQuoteToken = endQuoteToken;
        }

        internal XmlNameAttributeSyntax(SyntaxKind kind, XmlNameSyntax name, SyntaxToken equalsToken, SyntaxToken startQuoteToken, IdentifierNameSyntax identifier, SyntaxToken endQuoteToken, SyntaxFactoryContext context)
          : base(kind)
        {
            this.SetFactoryContext(context);
            this.SlotCount = 5;
            this.AdjustFlagsAndWidth(name);
            this.name = name;
            this.AdjustFlagsAndWidth(equalsToken);
            this.equalsToken = equalsToken;
            this.AdjustFlagsAndWidth(startQuoteToken);
            this.startQuoteToken = startQuoteToken;
            this.AdjustFlagsAndWidth(identifier);
            this.identifier = identifier;
            this.AdjustFlagsAndWidth(endQuoteToken);
            this.endQuoteToken = endQuoteToken;
        }

        internal XmlNameAttributeSyntax(SyntaxKind kind, XmlNameSyntax name, SyntaxToken equalsToken, SyntaxToken startQuoteToken, IdentifierNameSyntax identifier, SyntaxToken endQuoteToken)
          : base(kind)
        {
            this.SlotCount = 5;
            this.AdjustFlagsAndWidth(name);
            this.name = name;
            this.AdjustFlagsAndWidth(equalsToken);
            this.equalsToken = equalsToken;
            this.AdjustFlagsAndWidth(startQuoteToken);
            this.startQuoteToken = startQuoteToken;
            this.AdjustFlagsAndWidth(identifier);
            this.identifier = identifier;
            this.AdjustFlagsAndWidth(endQuoteToken);
            this.endQuoteToken = endQuoteToken;
        }

        public override XmlNameSyntax Name => this.name;
        public override SyntaxToken EqualsToken => this.equalsToken;
        public override SyntaxToken StartQuoteToken => this.startQuoteToken;
        public IdentifierNameSyntax Identifier => this.identifier;
        public override SyntaxToken EndQuoteToken => this.endQuoteToken;

        internal override GreenNode? GetSlot(int index)
            => index switch
            {
                0 => this.name,
                1 => this.equalsToken,
                2 => this.startQuoteToken,
                3 => this.identifier,
                4 => this.endQuoteToken,
                _ => null,
            };

        internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new CSharp.Syntax.XmlNameAttributeSyntax(this, parent, position);

        public override void Accept(CSharpSyntaxVisitor visitor) => visitor.VisitXmlNameAttribute(this);
        public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor) => visitor.VisitXmlNameAttribute(this);

        public XmlNameAttributeSyntax Update(XmlNameSyntax name, SyntaxToken equalsToken, SyntaxToken startQuoteToken, IdentifierNameSyntax identifier, SyntaxToken endQuoteToken)
        {
            if (name != this.Name || equalsToken != this.EqualsToken || startQuoteToken != this.StartQuoteToken || identifier != this.Identifier || endQuoteToken != this.EndQuoteToken)
            {
                var newNode = SyntaxFactory.XmlNameAttribute(name, equalsToken, startQuoteToken, identifier, endQuoteToken);
                var diags = GetDiagnostics();
                if (diags?.Length > 0)
                    newNode = newNode.WithDiagnosticsGreen(diags);
                var annotations = GetAnnotations();
                if (annotations?.Length > 0)
                    newNode = newNode.WithAnnotationsGreen(annotations);
                return newNode;
            }

            return this;
        }

        internal override GreenNode SetDiagnostics(DiagnosticInfo[]? diagnostics)
            => new XmlNameAttributeSyntax(this.Kind, this.name, this.equalsToken, this.startQuoteToken, this.identifier, this.endQuoteToken, diagnostics, GetAnnotations());

        internal override GreenNode SetAnnotations(SyntaxAnnotation[]? annotations)
            => new XmlNameAttributeSyntax(this.Kind, this.name, this.equalsToken, this.startQuoteToken, this.identifier, this.endQuoteToken, GetDiagnostics(), annotations);

        internal XmlNameAttributeSyntax(ObjectReader reader)
          : base(reader)
        {
            this.SlotCount = 5;
            var name = (XmlNameSyntax)reader.ReadValue();
            AdjustFlagsAndWidth(name);
            this.name = name;
            var equalsToken = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(equalsToken);
            this.equalsToken = equalsToken;
            var startQuoteToken = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(startQuoteToken);
            this.startQuoteToken = startQuoteToken;
            var identifier = (IdentifierNameSyntax)reader.ReadValue();
            AdjustFlagsAndWidth(identifier);
            this.identifier = identifier;
            var endQuoteToken = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(endQuoteToken);
            this.endQuoteToken = endQuoteToken;
        }

        internal override void WriteTo(ObjectWriter writer)
        {
            base.WriteTo(writer);
            writer.WriteValue(this.name);
            writer.WriteValue(this.equalsToken);
            writer.WriteValue(this.startQuoteToken);
            writer.WriteValue(this.identifier);
            writer.WriteValue(this.endQuoteToken);
        }

        static XmlNameAttributeSyntax()
        {
            ObjectBinder.RegisterTypeReader(typeof(XmlNameAttributeSyntax), r => new XmlNameAttributeSyntax(r));
        }
    }

    internal sealed partial class XmlTextSyntax : XmlNodeSyntax
    {
        internal readonly GreenNode? textTokens;

        internal XmlTextSyntax(SyntaxKind kind, GreenNode? textTokens, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
            this.SlotCount = 1;
            if (textTokens != null)
            {
                this.AdjustFlagsAndWidth(textTokens);
                this.textTokens = textTokens;
            }
        }

        internal XmlTextSyntax(SyntaxKind kind, GreenNode? textTokens, SyntaxFactoryContext context)
          : base(kind)
        {
            this.SetFactoryContext(context);
            this.SlotCount = 1;
            if (textTokens != null)
            {
                this.AdjustFlagsAndWidth(textTokens);
                this.textTokens = textTokens;
            }
        }

        internal XmlTextSyntax(SyntaxKind kind, GreenNode? textTokens)
          : base(kind)
        {
            this.SlotCount = 1;
            if (textTokens != null)
            {
                this.AdjustFlagsAndWidth(textTokens);
                this.textTokens = textTokens;
            }
        }

        public Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SyntaxToken> TextTokens => new Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SyntaxToken>(this.textTokens);

        internal override GreenNode? GetSlot(int index)
            => index == 0 ? this.textTokens : null;

        internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new CSharp.Syntax.XmlTextSyntax(this, parent, position);

        public override void Accept(CSharpSyntaxVisitor visitor) => visitor.VisitXmlText(this);
        public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor) => visitor.VisitXmlText(this);

        public XmlTextSyntax Update(Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SyntaxToken> textTokens)
        {
            if (textTokens != this.TextTokens)
            {
                var newNode = SyntaxFactory.XmlText(textTokens);
                var diags = GetDiagnostics();
                if (diags?.Length > 0)
                    newNode = newNode.WithDiagnosticsGreen(diags);
                var annotations = GetAnnotations();
                if (annotations?.Length > 0)
                    newNode = newNode.WithAnnotationsGreen(annotations);
                return newNode;
            }

            return this;
        }

        internal override GreenNode SetDiagnostics(DiagnosticInfo[]? diagnostics)
            => new XmlTextSyntax(this.Kind, this.textTokens, diagnostics, GetAnnotations());

        internal override GreenNode SetAnnotations(SyntaxAnnotation[]? annotations)
            => new XmlTextSyntax(this.Kind, this.textTokens, GetDiagnostics(), annotations);

        internal XmlTextSyntax(ObjectReader reader)
          : base(reader)
        {
            this.SlotCount = 1;
            var textTokens = (GreenNode?)reader.ReadValue();
            if (textTokens != null)
            {
                AdjustFlagsAndWidth(textTokens);
                this.textTokens = textTokens;
            }
        }

        internal override void WriteTo(ObjectWriter writer)
        {
            base.WriteTo(writer);
            writer.WriteValue(this.textTokens);
        }

        static XmlTextSyntax()
        {
            ObjectBinder.RegisterTypeReader(typeof(XmlTextSyntax), r => new XmlTextSyntax(r));
        }
    }

    internal sealed partial class XmlCDataSectionSyntax : XmlNodeSyntax
    {
        internal readonly SyntaxToken startCDataToken;
        internal readonly GreenNode? textTokens;
        internal readonly SyntaxToken endCDataToken;

        internal XmlCDataSectionSyntax(SyntaxKind kind, SyntaxToken startCDataToken, GreenNode? textTokens, SyntaxToken endCDataToken, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
            this.SlotCount = 3;
            this.AdjustFlagsAndWidth(startCDataToken);
            this.startCDataToken = startCDataToken;
            if (textTokens != null)
            {
                this.AdjustFlagsAndWidth(textTokens);
                this.textTokens = textTokens;
            }
            this.AdjustFlagsAndWidth(endCDataToken);
            this.endCDataToken = endCDataToken;
        }

        internal XmlCDataSectionSyntax(SyntaxKind kind, SyntaxToken startCDataToken, GreenNode? textTokens, SyntaxToken endCDataToken, SyntaxFactoryContext context)
          : base(kind)
        {
            this.SetFactoryContext(context);
            this.SlotCount = 3;
            this.AdjustFlagsAndWidth(startCDataToken);
            this.startCDataToken = startCDataToken;
            if (textTokens != null)
            {
                this.AdjustFlagsAndWidth(textTokens);
                this.textTokens = textTokens;
            }
            this.AdjustFlagsAndWidth(endCDataToken);
            this.endCDataToken = endCDataToken;
        }

        internal XmlCDataSectionSyntax(SyntaxKind kind, SyntaxToken startCDataToken, GreenNode? textTokens, SyntaxToken endCDataToken)
          : base(kind)
        {
            this.SlotCount = 3;
            this.AdjustFlagsAndWidth(startCDataToken);
            this.startCDataToken = startCDataToken;
            if (textTokens != null)
            {
                this.AdjustFlagsAndWidth(textTokens);
                this.textTokens = textTokens;
            }
            this.AdjustFlagsAndWidth(endCDataToken);
            this.endCDataToken = endCDataToken;
        }

        public SyntaxToken StartCDataToken => this.startCDataToken;
        public Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SyntaxToken> TextTokens => new Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SyntaxToken>(this.textTokens);
        public SyntaxToken EndCDataToken => this.endCDataToken;

        internal override GreenNode? GetSlot(int index)
            => index switch
            {
                0 => this.startCDataToken,
                1 => this.textTokens,
                2 => this.endCDataToken,
                _ => null,
            };

        internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new CSharp.Syntax.XmlCDataSectionSyntax(this, parent, position);

        public override void Accept(CSharpSyntaxVisitor visitor) => visitor.VisitXmlCDataSection(this);
        public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor) => visitor.VisitXmlCDataSection(this);

        public XmlCDataSectionSyntax Update(SyntaxToken startCDataToken, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SyntaxToken> textTokens, SyntaxToken endCDataToken)
        {
            if (startCDataToken != this.StartCDataToken || textTokens != this.TextTokens || endCDataToken != this.EndCDataToken)
            {
                var newNode = SyntaxFactory.XmlCDataSection(startCDataToken, textTokens, endCDataToken);
                var diags = GetDiagnostics();
                if (diags?.Length > 0)
                    newNode = newNode.WithDiagnosticsGreen(diags);
                var annotations = GetAnnotations();
                if (annotations?.Length > 0)
                    newNode = newNode.WithAnnotationsGreen(annotations);
                return newNode;
            }

            return this;
        }

        internal override GreenNode SetDiagnostics(DiagnosticInfo[]? diagnostics)
            => new XmlCDataSectionSyntax(this.Kind, this.startCDataToken, this.textTokens, this.endCDataToken, diagnostics, GetAnnotations());

        internal override GreenNode SetAnnotations(SyntaxAnnotation[]? annotations)
            => new XmlCDataSectionSyntax(this.Kind, this.startCDataToken, this.textTokens, this.endCDataToken, GetDiagnostics(), annotations);

        internal XmlCDataSectionSyntax(ObjectReader reader)
          : base(reader)
        {
            this.SlotCount = 3;
            var startCDataToken = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(startCDataToken);
            this.startCDataToken = startCDataToken;
            var textTokens = (GreenNode?)reader.ReadValue();
            if (textTokens != null)
            {
                AdjustFlagsAndWidth(textTokens);
                this.textTokens = textTokens;
            }
            var endCDataToken = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(endCDataToken);
            this.endCDataToken = endCDataToken;
        }

        internal override void WriteTo(ObjectWriter writer)
        {
            base.WriteTo(writer);
            writer.WriteValue(this.startCDataToken);
            writer.WriteValue(this.textTokens);
            writer.WriteValue(this.endCDataToken);
        }

        static XmlCDataSectionSyntax()
        {
            ObjectBinder.RegisterTypeReader(typeof(XmlCDataSectionSyntax), r => new XmlCDataSectionSyntax(r));
        }
    }

    internal sealed partial class XmlProcessingInstructionSyntax : XmlNodeSyntax
    {
        internal readonly SyntaxToken startProcessingInstructionToken;
        internal readonly XmlNameSyntax name;
        internal readonly GreenNode? textTokens;
        internal readonly SyntaxToken endProcessingInstructionToken;

        internal XmlProcessingInstructionSyntax(SyntaxKind kind, SyntaxToken startProcessingInstructionToken, XmlNameSyntax name, GreenNode? textTokens, SyntaxToken endProcessingInstructionToken, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
            this.SlotCount = 4;
            this.AdjustFlagsAndWidth(startProcessingInstructionToken);
            this.startProcessingInstructionToken = startProcessingInstructionToken;
            this.AdjustFlagsAndWidth(name);
            this.name = name;
            if (textTokens != null)
            {
                this.AdjustFlagsAndWidth(textTokens);
                this.textTokens = textTokens;
            }
            this.AdjustFlagsAndWidth(endProcessingInstructionToken);
            this.endProcessingInstructionToken = endProcessingInstructionToken;
        }

        internal XmlProcessingInstructionSyntax(SyntaxKind kind, SyntaxToken startProcessingInstructionToken, XmlNameSyntax name, GreenNode? textTokens, SyntaxToken endProcessingInstructionToken, SyntaxFactoryContext context)
          : base(kind)
        {
            this.SetFactoryContext(context);
            this.SlotCount = 4;
            this.AdjustFlagsAndWidth(startProcessingInstructionToken);
            this.startProcessingInstructionToken = startProcessingInstructionToken;
            this.AdjustFlagsAndWidth(name);
            this.name = name;
            if (textTokens != null)
            {
                this.AdjustFlagsAndWidth(textTokens);
                this.textTokens = textTokens;
            }
            this.AdjustFlagsAndWidth(endProcessingInstructionToken);
            this.endProcessingInstructionToken = endProcessingInstructionToken;
        }

        internal XmlProcessingInstructionSyntax(SyntaxKind kind, SyntaxToken startProcessingInstructionToken, XmlNameSyntax name, GreenNode? textTokens, SyntaxToken endProcessingInstructionToken)
          : base(kind)
        {
            this.SlotCount = 4;
            this.AdjustFlagsAndWidth(startProcessingInstructionToken);
            this.startProcessingInstructionToken = startProcessingInstructionToken;
            this.AdjustFlagsAndWidth(name);
            this.name = name;
            if (textTokens != null)
            {
                this.AdjustFlagsAndWidth(textTokens);
                this.textTokens = textTokens;
            }
            this.AdjustFlagsAndWidth(endProcessingInstructionToken);
            this.endProcessingInstructionToken = endProcessingInstructionToken;
        }

        public SyntaxToken StartProcessingInstructionToken => this.startProcessingInstructionToken;
        public XmlNameSyntax Name => this.name;
        public Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SyntaxToken> TextTokens => new Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SyntaxToken>(this.textTokens);
        public SyntaxToken EndProcessingInstructionToken => this.endProcessingInstructionToken;

        internal override GreenNode? GetSlot(int index)
            => index switch
            {
                0 => this.startProcessingInstructionToken,
                1 => this.name,
                2 => this.textTokens,
                3 => this.endProcessingInstructionToken,
                _ => null,
            };

        internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new CSharp.Syntax.XmlProcessingInstructionSyntax(this, parent, position);

        public override void Accept(CSharpSyntaxVisitor visitor) => visitor.VisitXmlProcessingInstruction(this);
        public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor) => visitor.VisitXmlProcessingInstruction(this);

        public XmlProcessingInstructionSyntax Update(SyntaxToken startProcessingInstructionToken, XmlNameSyntax name, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SyntaxToken> textTokens, SyntaxToken endProcessingInstructionToken)
        {
            if (startProcessingInstructionToken != this.StartProcessingInstructionToken || name != this.Name || textTokens != this.TextTokens || endProcessingInstructionToken != this.EndProcessingInstructionToken)
            {
                var newNode = SyntaxFactory.XmlProcessingInstruction(startProcessingInstructionToken, name, textTokens, endProcessingInstructionToken);
                var diags = GetDiagnostics();
                if (diags?.Length > 0)
                    newNode = newNode.WithDiagnosticsGreen(diags);
                var annotations = GetAnnotations();
                if (annotations?.Length > 0)
                    newNode = newNode.WithAnnotationsGreen(annotations);
                return newNode;
            }

            return this;
        }

        internal override GreenNode SetDiagnostics(DiagnosticInfo[]? diagnostics)
            => new XmlProcessingInstructionSyntax(this.Kind, this.startProcessingInstructionToken, this.name, this.textTokens, this.endProcessingInstructionToken, diagnostics, GetAnnotations());

        internal override GreenNode SetAnnotations(SyntaxAnnotation[]? annotations)
            => new XmlProcessingInstructionSyntax(this.Kind, this.startProcessingInstructionToken, this.name, this.textTokens, this.endProcessingInstructionToken, GetDiagnostics(), annotations);

        internal XmlProcessingInstructionSyntax(ObjectReader reader)
          : base(reader)
        {
            this.SlotCount = 4;
            var startProcessingInstructionToken = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(startProcessingInstructionToken);
            this.startProcessingInstructionToken = startProcessingInstructionToken;
            var name = (XmlNameSyntax)reader.ReadValue();
            AdjustFlagsAndWidth(name);
            this.name = name;
            var textTokens = (GreenNode?)reader.ReadValue();
            if (textTokens != null)
            {
                AdjustFlagsAndWidth(textTokens);
                this.textTokens = textTokens;
            }
            var endProcessingInstructionToken = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(endProcessingInstructionToken);
            this.endProcessingInstructionToken = endProcessingInstructionToken;
        }

        internal override void WriteTo(ObjectWriter writer)
        {
            base.WriteTo(writer);
            writer.WriteValue(this.startProcessingInstructionToken);
            writer.WriteValue(this.name);
            writer.WriteValue(this.textTokens);
            writer.WriteValue(this.endProcessingInstructionToken);
        }

        static XmlProcessingInstructionSyntax()
        {
            ObjectBinder.RegisterTypeReader(typeof(XmlProcessingInstructionSyntax), r => new XmlProcessingInstructionSyntax(r));
        }
    }

    internal sealed partial class XmlCommentSyntax : XmlNodeSyntax
    {
        internal readonly SyntaxToken lessThanExclamationMinusMinusToken;
        internal readonly GreenNode? textTokens;
        internal readonly SyntaxToken minusMinusGreaterThanToken;

        internal XmlCommentSyntax(SyntaxKind kind, SyntaxToken lessThanExclamationMinusMinusToken, GreenNode? textTokens, SyntaxToken minusMinusGreaterThanToken, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
            this.SlotCount = 3;
            this.AdjustFlagsAndWidth(lessThanExclamationMinusMinusToken);
            this.lessThanExclamationMinusMinusToken = lessThanExclamationMinusMinusToken;
            if (textTokens != null)
            {
                this.AdjustFlagsAndWidth(textTokens);
                this.textTokens = textTokens;
            }
            this.AdjustFlagsAndWidth(minusMinusGreaterThanToken);
            this.minusMinusGreaterThanToken = minusMinusGreaterThanToken;
        }

        internal XmlCommentSyntax(SyntaxKind kind, SyntaxToken lessThanExclamationMinusMinusToken, GreenNode? textTokens, SyntaxToken minusMinusGreaterThanToken, SyntaxFactoryContext context)
          : base(kind)
        {
            this.SetFactoryContext(context);
            this.SlotCount = 3;
            this.AdjustFlagsAndWidth(lessThanExclamationMinusMinusToken);
            this.lessThanExclamationMinusMinusToken = lessThanExclamationMinusMinusToken;
            if (textTokens != null)
            {
                this.AdjustFlagsAndWidth(textTokens);
                this.textTokens = textTokens;
            }
            this.AdjustFlagsAndWidth(minusMinusGreaterThanToken);
            this.minusMinusGreaterThanToken = minusMinusGreaterThanToken;
        }

        internal XmlCommentSyntax(SyntaxKind kind, SyntaxToken lessThanExclamationMinusMinusToken, GreenNode? textTokens, SyntaxToken minusMinusGreaterThanToken)
          : base(kind)
        {
            this.SlotCount = 3;
            this.AdjustFlagsAndWidth(lessThanExclamationMinusMinusToken);
            this.lessThanExclamationMinusMinusToken = lessThanExclamationMinusMinusToken;
            if (textTokens != null)
            {
                this.AdjustFlagsAndWidth(textTokens);
                this.textTokens = textTokens;
            }
            this.AdjustFlagsAndWidth(minusMinusGreaterThanToken);
            this.minusMinusGreaterThanToken = minusMinusGreaterThanToken;
        }

        public SyntaxToken LessThanExclamationMinusMinusToken => this.lessThanExclamationMinusMinusToken;
        public Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SyntaxToken> TextTokens => new Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SyntaxToken>(this.textTokens);
        public SyntaxToken MinusMinusGreaterThanToken => this.minusMinusGreaterThanToken;

        internal override GreenNode? GetSlot(int index)
            => index switch
            {
                0 => this.lessThanExclamationMinusMinusToken,
                1 => this.textTokens,
                2 => this.minusMinusGreaterThanToken,
                _ => null,
            };

        internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new CSharp.Syntax.XmlCommentSyntax(this, parent, position);

        public override void Accept(CSharpSyntaxVisitor visitor) => visitor.VisitXmlComment(this);
        public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor) => visitor.VisitXmlComment(this);

        public XmlCommentSyntax Update(SyntaxToken lessThanExclamationMinusMinusToken, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SyntaxToken> textTokens, SyntaxToken minusMinusGreaterThanToken)
        {
            if (lessThanExclamationMinusMinusToken != this.LessThanExclamationMinusMinusToken || textTokens != this.TextTokens || minusMinusGreaterThanToken != this.MinusMinusGreaterThanToken)
            {
                var newNode = SyntaxFactory.XmlComment(lessThanExclamationMinusMinusToken, textTokens, minusMinusGreaterThanToken);
                var diags = GetDiagnostics();
                if (diags?.Length > 0)
                    newNode = newNode.WithDiagnosticsGreen(diags);
                var annotations = GetAnnotations();
                if (annotations?.Length > 0)
                    newNode = newNode.WithAnnotationsGreen(annotations);
                return newNode;
            }

            return this;
        }

        internal override GreenNode SetDiagnostics(DiagnosticInfo[]? diagnostics)
            => new XmlCommentSyntax(this.Kind, this.lessThanExclamationMinusMinusToken, this.textTokens, this.minusMinusGreaterThanToken, diagnostics, GetAnnotations());

        internal override GreenNode SetAnnotations(SyntaxAnnotation[]? annotations)
            => new XmlCommentSyntax(this.Kind, this.lessThanExclamationMinusMinusToken, this.textTokens, this.minusMinusGreaterThanToken, GetDiagnostics(), annotations);

        internal XmlCommentSyntax(ObjectReader reader)
          : base(reader)
        {
            this.SlotCount = 3;
            var lessThanExclamationMinusMinusToken = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(lessThanExclamationMinusMinusToken);
            this.lessThanExclamationMinusMinusToken = lessThanExclamationMinusMinusToken;
            var textTokens = (GreenNode?)reader.ReadValue();
            if (textTokens != null)
            {
                AdjustFlagsAndWidth(textTokens);
                this.textTokens = textTokens;
            }
            var minusMinusGreaterThanToken = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(minusMinusGreaterThanToken);
            this.minusMinusGreaterThanToken = minusMinusGreaterThanToken;
        }

        internal override void WriteTo(ObjectWriter writer)
        {
            base.WriteTo(writer);
            writer.WriteValue(this.lessThanExclamationMinusMinusToken);
            writer.WriteValue(this.textTokens);
            writer.WriteValue(this.minusMinusGreaterThanToken);
        }

        static XmlCommentSyntax()
        {
            ObjectBinder.RegisterTypeReader(typeof(XmlCommentSyntax), r => new XmlCommentSyntax(r));
        }
    }

    internal abstract partial class DirectiveTriviaSyntax : StructuredTriviaSyntax
    {
        internal DirectiveTriviaSyntax(SyntaxKind kind, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
            this.flags |= NodeFlags.ContainsDirectives;
        }

        internal DirectiveTriviaSyntax(SyntaxKind kind)
          : base(kind)
        {
            this.flags |= NodeFlags.ContainsDirectives;
        }

        protected DirectiveTriviaSyntax(ObjectReader reader)
          : base(reader)
        {
            this.flags |= NodeFlags.ContainsDirectives;
        }

        public abstract SyntaxToken HashToken { get; }

        public abstract SyntaxToken EndOfDirectiveToken { get; }

        public abstract bool IsActive { get; }
    }

    internal abstract partial class BranchingDirectiveTriviaSyntax : DirectiveTriviaSyntax
    {
        internal BranchingDirectiveTriviaSyntax(SyntaxKind kind, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
        }

        internal BranchingDirectiveTriviaSyntax(SyntaxKind kind)
          : base(kind)
        {
        }

        protected BranchingDirectiveTriviaSyntax(ObjectReader reader)
          : base(reader)
        {
        }

        public abstract bool BranchTaken { get; }
    }

    internal abstract partial class ConditionalDirectiveTriviaSyntax : BranchingDirectiveTriviaSyntax
    {
        internal ConditionalDirectiveTriviaSyntax(SyntaxKind kind, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
        }

        internal ConditionalDirectiveTriviaSyntax(SyntaxKind kind)
          : base(kind)
        {
        }

        protected ConditionalDirectiveTriviaSyntax(ObjectReader reader)
          : base(reader)
        {
        }

        public abstract ExpressionSyntax Condition { get; }

        public abstract bool ConditionValue { get; }
    }

    internal sealed partial class IfDirectiveTriviaSyntax : ConditionalDirectiveTriviaSyntax
    {
        internal readonly SyntaxToken hashToken;
        internal readonly SyntaxToken ifKeyword;
        internal readonly ExpressionSyntax condition;
        internal readonly SyntaxToken endOfDirectiveToken;
        internal readonly bool isActive;
        internal readonly bool branchTaken;
        internal readonly bool conditionValue;

        internal IfDirectiveTriviaSyntax(SyntaxKind kind, SyntaxToken hashToken, SyntaxToken ifKeyword, ExpressionSyntax condition, SyntaxToken endOfDirectiveToken, bool isActive, bool branchTaken, bool conditionValue, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
            this.SlotCount = 4;
            this.AdjustFlagsAndWidth(hashToken);
            this.hashToken = hashToken;
            this.AdjustFlagsAndWidth(ifKeyword);
            this.ifKeyword = ifKeyword;
            this.AdjustFlagsAndWidth(condition);
            this.condition = condition;
            this.AdjustFlagsAndWidth(endOfDirectiveToken);
            this.endOfDirectiveToken = endOfDirectiveToken;
            this.isActive = isActive;
            this.branchTaken = branchTaken;
            this.conditionValue = conditionValue;
        }

        internal IfDirectiveTriviaSyntax(SyntaxKind kind, SyntaxToken hashToken, SyntaxToken ifKeyword, ExpressionSyntax condition, SyntaxToken endOfDirectiveToken, bool isActive, bool branchTaken, bool conditionValue, SyntaxFactoryContext context)
          : base(kind)
        {
            this.SetFactoryContext(context);
            this.SlotCount = 4;
            this.AdjustFlagsAndWidth(hashToken);
            this.hashToken = hashToken;
            this.AdjustFlagsAndWidth(ifKeyword);
            this.ifKeyword = ifKeyword;
            this.AdjustFlagsAndWidth(condition);
            this.condition = condition;
            this.AdjustFlagsAndWidth(endOfDirectiveToken);
            this.endOfDirectiveToken = endOfDirectiveToken;
            this.isActive = isActive;
            this.branchTaken = branchTaken;
            this.conditionValue = conditionValue;
        }

        internal IfDirectiveTriviaSyntax(SyntaxKind kind, SyntaxToken hashToken, SyntaxToken ifKeyword, ExpressionSyntax condition, SyntaxToken endOfDirectiveToken, bool isActive, bool branchTaken, bool conditionValue)
          : base(kind)
        {
            this.SlotCount = 4;
            this.AdjustFlagsAndWidth(hashToken);
            this.hashToken = hashToken;
            this.AdjustFlagsAndWidth(ifKeyword);
            this.ifKeyword = ifKeyword;
            this.AdjustFlagsAndWidth(condition);
            this.condition = condition;
            this.AdjustFlagsAndWidth(endOfDirectiveToken);
            this.endOfDirectiveToken = endOfDirectiveToken;
            this.isActive = isActive;
            this.branchTaken = branchTaken;
            this.conditionValue = conditionValue;
        }

        public override SyntaxToken HashToken => this.hashToken;
        public SyntaxToken IfKeyword => this.ifKeyword;
        public override ExpressionSyntax Condition => this.condition;
        public override SyntaxToken EndOfDirectiveToken => this.endOfDirectiveToken;
        public override bool IsActive => this.isActive;
        public override bool BranchTaken => this.branchTaken;
        public override bool ConditionValue => this.conditionValue;

        internal override GreenNode? GetSlot(int index)
            => index switch
            {
                0 => this.hashToken,
                1 => this.ifKeyword,
                2 => this.condition,
                3 => this.endOfDirectiveToken,
                _ => null,
            };

        internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new CSharp.Syntax.IfDirectiveTriviaSyntax(this, parent, position);

        public override void Accept(CSharpSyntaxVisitor visitor) => visitor.VisitIfDirectiveTrivia(this);
        public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor) => visitor.VisitIfDirectiveTrivia(this);

        public IfDirectiveTriviaSyntax Update(SyntaxToken hashToken, SyntaxToken ifKeyword, ExpressionSyntax condition, SyntaxToken endOfDirectiveToken, bool isActive, bool branchTaken, bool conditionValue)
        {
            if (hashToken != this.HashToken || ifKeyword != this.IfKeyword || condition != this.Condition || endOfDirectiveToken != this.EndOfDirectiveToken)
            {
                var newNode = SyntaxFactory.IfDirectiveTrivia(hashToken, ifKeyword, condition, endOfDirectiveToken, isActive, branchTaken, conditionValue);
                var diags = GetDiagnostics();
                if (diags?.Length > 0)
                    newNode = newNode.WithDiagnosticsGreen(diags);
                var annotations = GetAnnotations();
                if (annotations?.Length > 0)
                    newNode = newNode.WithAnnotationsGreen(annotations);
                return newNode;
            }

            return this;
        }

        internal override GreenNode SetDiagnostics(DiagnosticInfo[]? diagnostics)
            => new IfDirectiveTriviaSyntax(this.Kind, this.hashToken, this.ifKeyword, this.condition, this.endOfDirectiveToken, this.isActive, this.branchTaken, this.conditionValue, diagnostics, GetAnnotations());

        internal override GreenNode SetAnnotations(SyntaxAnnotation[]? annotations)
            => new IfDirectiveTriviaSyntax(this.Kind, this.hashToken, this.ifKeyword, this.condition, this.endOfDirectiveToken, this.isActive, this.branchTaken, this.conditionValue, GetDiagnostics(), annotations);

        internal IfDirectiveTriviaSyntax(ObjectReader reader)
          : base(reader)
        {
            this.SlotCount = 4;
            var hashToken = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(hashToken);
            this.hashToken = hashToken;
            var ifKeyword = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(ifKeyword);
            this.ifKeyword = ifKeyword;
            var condition = (ExpressionSyntax)reader.ReadValue();
            AdjustFlagsAndWidth(condition);
            this.condition = condition;
            var endOfDirectiveToken = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(endOfDirectiveToken);
            this.endOfDirectiveToken = endOfDirectiveToken;
            this.isActive = (bool)reader.ReadBoolean();
            this.branchTaken = (bool)reader.ReadBoolean();
            this.conditionValue = (bool)reader.ReadBoolean();
        }

        internal override void WriteTo(ObjectWriter writer)
        {
            base.WriteTo(writer);
            writer.WriteValue(this.hashToken);
            writer.WriteValue(this.ifKeyword);
            writer.WriteValue(this.condition);
            writer.WriteValue(this.endOfDirectiveToken);
            writer.WriteBoolean(this.isActive);
            writer.WriteBoolean(this.branchTaken);
            writer.WriteBoolean(this.conditionValue);
        }

        static IfDirectiveTriviaSyntax()
        {
            ObjectBinder.RegisterTypeReader(typeof(IfDirectiveTriviaSyntax), r => new IfDirectiveTriviaSyntax(r));
        }
    }

    internal sealed partial class ElifDirectiveTriviaSyntax : ConditionalDirectiveTriviaSyntax
    {
        internal readonly SyntaxToken hashToken;
        internal readonly SyntaxToken elifKeyword;
        internal readonly ExpressionSyntax condition;
        internal readonly SyntaxToken endOfDirectiveToken;
        internal readonly bool isActive;
        internal readonly bool branchTaken;
        internal readonly bool conditionValue;

        internal ElifDirectiveTriviaSyntax(SyntaxKind kind, SyntaxToken hashToken, SyntaxToken elifKeyword, ExpressionSyntax condition, SyntaxToken endOfDirectiveToken, bool isActive, bool branchTaken, bool conditionValue, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
            this.SlotCount = 4;
            this.AdjustFlagsAndWidth(hashToken);
            this.hashToken = hashToken;
            this.AdjustFlagsAndWidth(elifKeyword);
            this.elifKeyword = elifKeyword;
            this.AdjustFlagsAndWidth(condition);
            this.condition = condition;
            this.AdjustFlagsAndWidth(endOfDirectiveToken);
            this.endOfDirectiveToken = endOfDirectiveToken;
            this.isActive = isActive;
            this.branchTaken = branchTaken;
            this.conditionValue = conditionValue;
        }

        internal ElifDirectiveTriviaSyntax(SyntaxKind kind, SyntaxToken hashToken, SyntaxToken elifKeyword, ExpressionSyntax condition, SyntaxToken endOfDirectiveToken, bool isActive, bool branchTaken, bool conditionValue, SyntaxFactoryContext context)
          : base(kind)
        {
            this.SetFactoryContext(context);
            this.SlotCount = 4;
            this.AdjustFlagsAndWidth(hashToken);
            this.hashToken = hashToken;
            this.AdjustFlagsAndWidth(elifKeyword);
            this.elifKeyword = elifKeyword;
            this.AdjustFlagsAndWidth(condition);
            this.condition = condition;
            this.AdjustFlagsAndWidth(endOfDirectiveToken);
            this.endOfDirectiveToken = endOfDirectiveToken;
            this.isActive = isActive;
            this.branchTaken = branchTaken;
            this.conditionValue = conditionValue;
        }

        internal ElifDirectiveTriviaSyntax(SyntaxKind kind, SyntaxToken hashToken, SyntaxToken elifKeyword, ExpressionSyntax condition, SyntaxToken endOfDirectiveToken, bool isActive, bool branchTaken, bool conditionValue)
          : base(kind)
        {
            this.SlotCount = 4;
            this.AdjustFlagsAndWidth(hashToken);
            this.hashToken = hashToken;
            this.AdjustFlagsAndWidth(elifKeyword);
            this.elifKeyword = elifKeyword;
            this.AdjustFlagsAndWidth(condition);
            this.condition = condition;
            this.AdjustFlagsAndWidth(endOfDirectiveToken);
            this.endOfDirectiveToken = endOfDirectiveToken;
            this.isActive = isActive;
            this.branchTaken = branchTaken;
            this.conditionValue = conditionValue;
        }

        public override SyntaxToken HashToken => this.hashToken;
        public SyntaxToken ElifKeyword => this.elifKeyword;
        public override ExpressionSyntax Condition => this.condition;
        public override SyntaxToken EndOfDirectiveToken => this.endOfDirectiveToken;
        public override bool IsActive => this.isActive;
        public override bool BranchTaken => this.branchTaken;
        public override bool ConditionValue => this.conditionValue;

        internal override GreenNode? GetSlot(int index)
            => index switch
            {
                0 => this.hashToken,
                1 => this.elifKeyword,
                2 => this.condition,
                3 => this.endOfDirectiveToken,
                _ => null,
            };

        internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new CSharp.Syntax.ElifDirectiveTriviaSyntax(this, parent, position);

        public override void Accept(CSharpSyntaxVisitor visitor) => visitor.VisitElifDirectiveTrivia(this);
        public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor) => visitor.VisitElifDirectiveTrivia(this);

        public ElifDirectiveTriviaSyntax Update(SyntaxToken hashToken, SyntaxToken elifKeyword, ExpressionSyntax condition, SyntaxToken endOfDirectiveToken, bool isActive, bool branchTaken, bool conditionValue)
        {
            if (hashToken != this.HashToken || elifKeyword != this.ElifKeyword || condition != this.Condition || endOfDirectiveToken != this.EndOfDirectiveToken)
            {
                var newNode = SyntaxFactory.ElifDirectiveTrivia(hashToken, elifKeyword, condition, endOfDirectiveToken, isActive, branchTaken, conditionValue);
                var diags = GetDiagnostics();
                if (diags?.Length > 0)
                    newNode = newNode.WithDiagnosticsGreen(diags);
                var annotations = GetAnnotations();
                if (annotations?.Length > 0)
                    newNode = newNode.WithAnnotationsGreen(annotations);
                return newNode;
            }

            return this;
        }

        internal override GreenNode SetDiagnostics(DiagnosticInfo[]? diagnostics)
            => new ElifDirectiveTriviaSyntax(this.Kind, this.hashToken, this.elifKeyword, this.condition, this.endOfDirectiveToken, this.isActive, this.branchTaken, this.conditionValue, diagnostics, GetAnnotations());

        internal override GreenNode SetAnnotations(SyntaxAnnotation[]? annotations)
            => new ElifDirectiveTriviaSyntax(this.Kind, this.hashToken, this.elifKeyword, this.condition, this.endOfDirectiveToken, this.isActive, this.branchTaken, this.conditionValue, GetDiagnostics(), annotations);

        internal ElifDirectiveTriviaSyntax(ObjectReader reader)
          : base(reader)
        {
            this.SlotCount = 4;
            var hashToken = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(hashToken);
            this.hashToken = hashToken;
            var elifKeyword = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(elifKeyword);
            this.elifKeyword = elifKeyword;
            var condition = (ExpressionSyntax)reader.ReadValue();
            AdjustFlagsAndWidth(condition);
            this.condition = condition;
            var endOfDirectiveToken = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(endOfDirectiveToken);
            this.endOfDirectiveToken = endOfDirectiveToken;
            this.isActive = (bool)reader.ReadBoolean();
            this.branchTaken = (bool)reader.ReadBoolean();
            this.conditionValue = (bool)reader.ReadBoolean();
        }

        internal override void WriteTo(ObjectWriter writer)
        {
            base.WriteTo(writer);
            writer.WriteValue(this.hashToken);
            writer.WriteValue(this.elifKeyword);
            writer.WriteValue(this.condition);
            writer.WriteValue(this.endOfDirectiveToken);
            writer.WriteBoolean(this.isActive);
            writer.WriteBoolean(this.branchTaken);
            writer.WriteBoolean(this.conditionValue);
        }

        static ElifDirectiveTriviaSyntax()
        {
            ObjectBinder.RegisterTypeReader(typeof(ElifDirectiveTriviaSyntax), r => new ElifDirectiveTriviaSyntax(r));
        }
    }

    internal sealed partial class ElseDirectiveTriviaSyntax : BranchingDirectiveTriviaSyntax
    {
        internal readonly SyntaxToken hashToken;
        internal readonly SyntaxToken elseKeyword;
        internal readonly SyntaxToken endOfDirectiveToken;
        internal readonly bool isActive;
        internal readonly bool branchTaken;

        internal ElseDirectiveTriviaSyntax(SyntaxKind kind, SyntaxToken hashToken, SyntaxToken elseKeyword, SyntaxToken endOfDirectiveToken, bool isActive, bool branchTaken, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
            this.SlotCount = 3;
            this.AdjustFlagsAndWidth(hashToken);
            this.hashToken = hashToken;
            this.AdjustFlagsAndWidth(elseKeyword);
            this.elseKeyword = elseKeyword;
            this.AdjustFlagsAndWidth(endOfDirectiveToken);
            this.endOfDirectiveToken = endOfDirectiveToken;
            this.isActive = isActive;
            this.branchTaken = branchTaken;
        }

        internal ElseDirectiveTriviaSyntax(SyntaxKind kind, SyntaxToken hashToken, SyntaxToken elseKeyword, SyntaxToken endOfDirectiveToken, bool isActive, bool branchTaken, SyntaxFactoryContext context)
          : base(kind)
        {
            this.SetFactoryContext(context);
            this.SlotCount = 3;
            this.AdjustFlagsAndWidth(hashToken);
            this.hashToken = hashToken;
            this.AdjustFlagsAndWidth(elseKeyword);
            this.elseKeyword = elseKeyword;
            this.AdjustFlagsAndWidth(endOfDirectiveToken);
            this.endOfDirectiveToken = endOfDirectiveToken;
            this.isActive = isActive;
            this.branchTaken = branchTaken;
        }

        internal ElseDirectiveTriviaSyntax(SyntaxKind kind, SyntaxToken hashToken, SyntaxToken elseKeyword, SyntaxToken endOfDirectiveToken, bool isActive, bool branchTaken)
          : base(kind)
        {
            this.SlotCount = 3;
            this.AdjustFlagsAndWidth(hashToken);
            this.hashToken = hashToken;
            this.AdjustFlagsAndWidth(elseKeyword);
            this.elseKeyword = elseKeyword;
            this.AdjustFlagsAndWidth(endOfDirectiveToken);
            this.endOfDirectiveToken = endOfDirectiveToken;
            this.isActive = isActive;
            this.branchTaken = branchTaken;
        }

        public override SyntaxToken HashToken => this.hashToken;
        public SyntaxToken ElseKeyword => this.elseKeyword;
        public override SyntaxToken EndOfDirectiveToken => this.endOfDirectiveToken;
        public override bool IsActive => this.isActive;
        public override bool BranchTaken => this.branchTaken;

        internal override GreenNode? GetSlot(int index)
            => index switch
            {
                0 => this.hashToken,
                1 => this.elseKeyword,
                2 => this.endOfDirectiveToken,
                _ => null,
            };

        internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new CSharp.Syntax.ElseDirectiveTriviaSyntax(this, parent, position);

        public override void Accept(CSharpSyntaxVisitor visitor) => visitor.VisitElseDirectiveTrivia(this);
        public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor) => visitor.VisitElseDirectiveTrivia(this);

        public ElseDirectiveTriviaSyntax Update(SyntaxToken hashToken, SyntaxToken elseKeyword, SyntaxToken endOfDirectiveToken, bool isActive, bool branchTaken)
        {
            if (hashToken != this.HashToken || elseKeyword != this.ElseKeyword || endOfDirectiveToken != this.EndOfDirectiveToken)
            {
                var newNode = SyntaxFactory.ElseDirectiveTrivia(hashToken, elseKeyword, endOfDirectiveToken, isActive, branchTaken);
                var diags = GetDiagnostics();
                if (diags?.Length > 0)
                    newNode = newNode.WithDiagnosticsGreen(diags);
                var annotations = GetAnnotations();
                if (annotations?.Length > 0)
                    newNode = newNode.WithAnnotationsGreen(annotations);
                return newNode;
            }

            return this;
        }

        internal override GreenNode SetDiagnostics(DiagnosticInfo[]? diagnostics)
            => new ElseDirectiveTriviaSyntax(this.Kind, this.hashToken, this.elseKeyword, this.endOfDirectiveToken, this.isActive, this.branchTaken, diagnostics, GetAnnotations());

        internal override GreenNode SetAnnotations(SyntaxAnnotation[]? annotations)
            => new ElseDirectiveTriviaSyntax(this.Kind, this.hashToken, this.elseKeyword, this.endOfDirectiveToken, this.isActive, this.branchTaken, GetDiagnostics(), annotations);

        internal ElseDirectiveTriviaSyntax(ObjectReader reader)
          : base(reader)
        {
            this.SlotCount = 3;
            var hashToken = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(hashToken);
            this.hashToken = hashToken;
            var elseKeyword = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(elseKeyword);
            this.elseKeyword = elseKeyword;
            var endOfDirectiveToken = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(endOfDirectiveToken);
            this.endOfDirectiveToken = endOfDirectiveToken;
            this.isActive = (bool)reader.ReadBoolean();
            this.branchTaken = (bool)reader.ReadBoolean();
        }

        internal override void WriteTo(ObjectWriter writer)
        {
            base.WriteTo(writer);
            writer.WriteValue(this.hashToken);
            writer.WriteValue(this.elseKeyword);
            writer.WriteValue(this.endOfDirectiveToken);
            writer.WriteBoolean(this.isActive);
            writer.WriteBoolean(this.branchTaken);
        }

        static ElseDirectiveTriviaSyntax()
        {
            ObjectBinder.RegisterTypeReader(typeof(ElseDirectiveTriviaSyntax), r => new ElseDirectiveTriviaSyntax(r));
        }
    }

    internal sealed partial class EndIfDirectiveTriviaSyntax : DirectiveTriviaSyntax
    {
        internal readonly SyntaxToken hashToken;
        internal readonly SyntaxToken endIfKeyword;
        internal readonly SyntaxToken endOfDirectiveToken;
        internal readonly bool isActive;

        internal EndIfDirectiveTriviaSyntax(SyntaxKind kind, SyntaxToken hashToken, SyntaxToken endIfKeyword, SyntaxToken endOfDirectiveToken, bool isActive, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
            this.SlotCount = 3;
            this.AdjustFlagsAndWidth(hashToken);
            this.hashToken = hashToken;
            this.AdjustFlagsAndWidth(endIfKeyword);
            this.endIfKeyword = endIfKeyword;
            this.AdjustFlagsAndWidth(endOfDirectiveToken);
            this.endOfDirectiveToken = endOfDirectiveToken;
            this.isActive = isActive;
        }

        internal EndIfDirectiveTriviaSyntax(SyntaxKind kind, SyntaxToken hashToken, SyntaxToken endIfKeyword, SyntaxToken endOfDirectiveToken, bool isActive, SyntaxFactoryContext context)
          : base(kind)
        {
            this.SetFactoryContext(context);
            this.SlotCount = 3;
            this.AdjustFlagsAndWidth(hashToken);
            this.hashToken = hashToken;
            this.AdjustFlagsAndWidth(endIfKeyword);
            this.endIfKeyword = endIfKeyword;
            this.AdjustFlagsAndWidth(endOfDirectiveToken);
            this.endOfDirectiveToken = endOfDirectiveToken;
            this.isActive = isActive;
        }

        internal EndIfDirectiveTriviaSyntax(SyntaxKind kind, SyntaxToken hashToken, SyntaxToken endIfKeyword, SyntaxToken endOfDirectiveToken, bool isActive)
          : base(kind)
        {
            this.SlotCount = 3;
            this.AdjustFlagsAndWidth(hashToken);
            this.hashToken = hashToken;
            this.AdjustFlagsAndWidth(endIfKeyword);
            this.endIfKeyword = endIfKeyword;
            this.AdjustFlagsAndWidth(endOfDirectiveToken);
            this.endOfDirectiveToken = endOfDirectiveToken;
            this.isActive = isActive;
        }

        public override SyntaxToken HashToken => this.hashToken;
        public SyntaxToken EndIfKeyword => this.endIfKeyword;
        public override SyntaxToken EndOfDirectiveToken => this.endOfDirectiveToken;
        public override bool IsActive => this.isActive;

        internal override GreenNode? GetSlot(int index)
            => index switch
            {
                0 => this.hashToken,
                1 => this.endIfKeyword,
                2 => this.endOfDirectiveToken,
                _ => null,
            };

        internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new CSharp.Syntax.EndIfDirectiveTriviaSyntax(this, parent, position);

        public override void Accept(CSharpSyntaxVisitor visitor) => visitor.VisitEndIfDirectiveTrivia(this);
        public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor) => visitor.VisitEndIfDirectiveTrivia(this);

        public EndIfDirectiveTriviaSyntax Update(SyntaxToken hashToken, SyntaxToken endIfKeyword, SyntaxToken endOfDirectiveToken, bool isActive)
        {
            if (hashToken != this.HashToken || endIfKeyword != this.EndIfKeyword || endOfDirectiveToken != this.EndOfDirectiveToken)
            {
                var newNode = SyntaxFactory.EndIfDirectiveTrivia(hashToken, endIfKeyword, endOfDirectiveToken, isActive);
                var diags = GetDiagnostics();
                if (diags?.Length > 0)
                    newNode = newNode.WithDiagnosticsGreen(diags);
                var annotations = GetAnnotations();
                if (annotations?.Length > 0)
                    newNode = newNode.WithAnnotationsGreen(annotations);
                return newNode;
            }

            return this;
        }

        internal override GreenNode SetDiagnostics(DiagnosticInfo[]? diagnostics)
            => new EndIfDirectiveTriviaSyntax(this.Kind, this.hashToken, this.endIfKeyword, this.endOfDirectiveToken, this.isActive, diagnostics, GetAnnotations());

        internal override GreenNode SetAnnotations(SyntaxAnnotation[]? annotations)
            => new EndIfDirectiveTriviaSyntax(this.Kind, this.hashToken, this.endIfKeyword, this.endOfDirectiveToken, this.isActive, GetDiagnostics(), annotations);

        internal EndIfDirectiveTriviaSyntax(ObjectReader reader)
          : base(reader)
        {
            this.SlotCount = 3;
            var hashToken = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(hashToken);
            this.hashToken = hashToken;
            var endIfKeyword = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(endIfKeyword);
            this.endIfKeyword = endIfKeyword;
            var endOfDirectiveToken = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(endOfDirectiveToken);
            this.endOfDirectiveToken = endOfDirectiveToken;
            this.isActive = (bool)reader.ReadBoolean();
        }

        internal override void WriteTo(ObjectWriter writer)
        {
            base.WriteTo(writer);
            writer.WriteValue(this.hashToken);
            writer.WriteValue(this.endIfKeyword);
            writer.WriteValue(this.endOfDirectiveToken);
            writer.WriteBoolean(this.isActive);
        }

        static EndIfDirectiveTriviaSyntax()
        {
            ObjectBinder.RegisterTypeReader(typeof(EndIfDirectiveTriviaSyntax), r => new EndIfDirectiveTriviaSyntax(r));
        }
    }

    internal sealed partial class RegionDirectiveTriviaSyntax : DirectiveTriviaSyntax
    {
        internal readonly SyntaxToken hashToken;
        internal readonly SyntaxToken regionKeyword;
        internal readonly SyntaxToken endOfDirectiveToken;
        internal readonly bool isActive;

        internal RegionDirectiveTriviaSyntax(SyntaxKind kind, SyntaxToken hashToken, SyntaxToken regionKeyword, SyntaxToken endOfDirectiveToken, bool isActive, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
            this.SlotCount = 3;
            this.AdjustFlagsAndWidth(hashToken);
            this.hashToken = hashToken;
            this.AdjustFlagsAndWidth(regionKeyword);
            this.regionKeyword = regionKeyword;
            this.AdjustFlagsAndWidth(endOfDirectiveToken);
            this.endOfDirectiveToken = endOfDirectiveToken;
            this.isActive = isActive;
        }

        internal RegionDirectiveTriviaSyntax(SyntaxKind kind, SyntaxToken hashToken, SyntaxToken regionKeyword, SyntaxToken endOfDirectiveToken, bool isActive, SyntaxFactoryContext context)
          : base(kind)
        {
            this.SetFactoryContext(context);
            this.SlotCount = 3;
            this.AdjustFlagsAndWidth(hashToken);
            this.hashToken = hashToken;
            this.AdjustFlagsAndWidth(regionKeyword);
            this.regionKeyword = regionKeyword;
            this.AdjustFlagsAndWidth(endOfDirectiveToken);
            this.endOfDirectiveToken = endOfDirectiveToken;
            this.isActive = isActive;
        }

        internal RegionDirectiveTriviaSyntax(SyntaxKind kind, SyntaxToken hashToken, SyntaxToken regionKeyword, SyntaxToken endOfDirectiveToken, bool isActive)
          : base(kind)
        {
            this.SlotCount = 3;
            this.AdjustFlagsAndWidth(hashToken);
            this.hashToken = hashToken;
            this.AdjustFlagsAndWidth(regionKeyword);
            this.regionKeyword = regionKeyword;
            this.AdjustFlagsAndWidth(endOfDirectiveToken);
            this.endOfDirectiveToken = endOfDirectiveToken;
            this.isActive = isActive;
        }

        public override SyntaxToken HashToken => this.hashToken;
        public SyntaxToken RegionKeyword => this.regionKeyword;
        public override SyntaxToken EndOfDirectiveToken => this.endOfDirectiveToken;
        public override bool IsActive => this.isActive;

        internal override GreenNode? GetSlot(int index)
            => index switch
            {
                0 => this.hashToken,
                1 => this.regionKeyword,
                2 => this.endOfDirectiveToken,
                _ => null,
            };

        internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new CSharp.Syntax.RegionDirectiveTriviaSyntax(this, parent, position);

        public override void Accept(CSharpSyntaxVisitor visitor) => visitor.VisitRegionDirectiveTrivia(this);
        public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor) => visitor.VisitRegionDirectiveTrivia(this);

        public RegionDirectiveTriviaSyntax Update(SyntaxToken hashToken, SyntaxToken regionKeyword, SyntaxToken endOfDirectiveToken, bool isActive)
        {
            if (hashToken != this.HashToken || regionKeyword != this.RegionKeyword || endOfDirectiveToken != this.EndOfDirectiveToken)
            {
                var newNode = SyntaxFactory.RegionDirectiveTrivia(hashToken, regionKeyword, endOfDirectiveToken, isActive);
                var diags = GetDiagnostics();
                if (diags?.Length > 0)
                    newNode = newNode.WithDiagnosticsGreen(diags);
                var annotations = GetAnnotations();
                if (annotations?.Length > 0)
                    newNode = newNode.WithAnnotationsGreen(annotations);
                return newNode;
            }

            return this;
        }

        internal override GreenNode SetDiagnostics(DiagnosticInfo[]? diagnostics)
            => new RegionDirectiveTriviaSyntax(this.Kind, this.hashToken, this.regionKeyword, this.endOfDirectiveToken, this.isActive, diagnostics, GetAnnotations());

        internal override GreenNode SetAnnotations(SyntaxAnnotation[]? annotations)
            => new RegionDirectiveTriviaSyntax(this.Kind, this.hashToken, this.regionKeyword, this.endOfDirectiveToken, this.isActive, GetDiagnostics(), annotations);

        internal RegionDirectiveTriviaSyntax(ObjectReader reader)
          : base(reader)
        {
            this.SlotCount = 3;
            var hashToken = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(hashToken);
            this.hashToken = hashToken;
            var regionKeyword = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(regionKeyword);
            this.regionKeyword = regionKeyword;
            var endOfDirectiveToken = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(endOfDirectiveToken);
            this.endOfDirectiveToken = endOfDirectiveToken;
            this.isActive = (bool)reader.ReadBoolean();
        }

        internal override void WriteTo(ObjectWriter writer)
        {
            base.WriteTo(writer);
            writer.WriteValue(this.hashToken);
            writer.WriteValue(this.regionKeyword);
            writer.WriteValue(this.endOfDirectiveToken);
            writer.WriteBoolean(this.isActive);
        }

        static RegionDirectiveTriviaSyntax()
        {
            ObjectBinder.RegisterTypeReader(typeof(RegionDirectiveTriviaSyntax), r => new RegionDirectiveTriviaSyntax(r));
        }
    }

    internal sealed partial class EndRegionDirectiveTriviaSyntax : DirectiveTriviaSyntax
    {
        internal readonly SyntaxToken hashToken;
        internal readonly SyntaxToken endRegionKeyword;
        internal readonly SyntaxToken endOfDirectiveToken;
        internal readonly bool isActive;

        internal EndRegionDirectiveTriviaSyntax(SyntaxKind kind, SyntaxToken hashToken, SyntaxToken endRegionKeyword, SyntaxToken endOfDirectiveToken, bool isActive, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
            this.SlotCount = 3;
            this.AdjustFlagsAndWidth(hashToken);
            this.hashToken = hashToken;
            this.AdjustFlagsAndWidth(endRegionKeyword);
            this.endRegionKeyword = endRegionKeyword;
            this.AdjustFlagsAndWidth(endOfDirectiveToken);
            this.endOfDirectiveToken = endOfDirectiveToken;
            this.isActive = isActive;
        }

        internal EndRegionDirectiveTriviaSyntax(SyntaxKind kind, SyntaxToken hashToken, SyntaxToken endRegionKeyword, SyntaxToken endOfDirectiveToken, bool isActive, SyntaxFactoryContext context)
          : base(kind)
        {
            this.SetFactoryContext(context);
            this.SlotCount = 3;
            this.AdjustFlagsAndWidth(hashToken);
            this.hashToken = hashToken;
            this.AdjustFlagsAndWidth(endRegionKeyword);
            this.endRegionKeyword = endRegionKeyword;
            this.AdjustFlagsAndWidth(endOfDirectiveToken);
            this.endOfDirectiveToken = endOfDirectiveToken;
            this.isActive = isActive;
        }

        internal EndRegionDirectiveTriviaSyntax(SyntaxKind kind, SyntaxToken hashToken, SyntaxToken endRegionKeyword, SyntaxToken endOfDirectiveToken, bool isActive)
          : base(kind)
        {
            this.SlotCount = 3;
            this.AdjustFlagsAndWidth(hashToken);
            this.hashToken = hashToken;
            this.AdjustFlagsAndWidth(endRegionKeyword);
            this.endRegionKeyword = endRegionKeyword;
            this.AdjustFlagsAndWidth(endOfDirectiveToken);
            this.endOfDirectiveToken = endOfDirectiveToken;
            this.isActive = isActive;
        }

        public override SyntaxToken HashToken => this.hashToken;
        public SyntaxToken EndRegionKeyword => this.endRegionKeyword;
        public override SyntaxToken EndOfDirectiveToken => this.endOfDirectiveToken;
        public override bool IsActive => this.isActive;

        internal override GreenNode? GetSlot(int index)
            => index switch
            {
                0 => this.hashToken,
                1 => this.endRegionKeyword,
                2 => this.endOfDirectiveToken,
                _ => null,
            };

        internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new CSharp.Syntax.EndRegionDirectiveTriviaSyntax(this, parent, position);

        public override void Accept(CSharpSyntaxVisitor visitor) => visitor.VisitEndRegionDirectiveTrivia(this);
        public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor) => visitor.VisitEndRegionDirectiveTrivia(this);

        public EndRegionDirectiveTriviaSyntax Update(SyntaxToken hashToken, SyntaxToken endRegionKeyword, SyntaxToken endOfDirectiveToken, bool isActive)
        {
            if (hashToken != this.HashToken || endRegionKeyword != this.EndRegionKeyword || endOfDirectiveToken != this.EndOfDirectiveToken)
            {
                var newNode = SyntaxFactory.EndRegionDirectiveTrivia(hashToken, endRegionKeyword, endOfDirectiveToken, isActive);
                var diags = GetDiagnostics();
                if (diags?.Length > 0)
                    newNode = newNode.WithDiagnosticsGreen(diags);
                var annotations = GetAnnotations();
                if (annotations?.Length > 0)
                    newNode = newNode.WithAnnotationsGreen(annotations);
                return newNode;
            }

            return this;
        }

        internal override GreenNode SetDiagnostics(DiagnosticInfo[]? diagnostics)
            => new EndRegionDirectiveTriviaSyntax(this.Kind, this.hashToken, this.endRegionKeyword, this.endOfDirectiveToken, this.isActive, diagnostics, GetAnnotations());

        internal override GreenNode SetAnnotations(SyntaxAnnotation[]? annotations)
            => new EndRegionDirectiveTriviaSyntax(this.Kind, this.hashToken, this.endRegionKeyword, this.endOfDirectiveToken, this.isActive, GetDiagnostics(), annotations);

        internal EndRegionDirectiveTriviaSyntax(ObjectReader reader)
          : base(reader)
        {
            this.SlotCount = 3;
            var hashToken = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(hashToken);
            this.hashToken = hashToken;
            var endRegionKeyword = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(endRegionKeyword);
            this.endRegionKeyword = endRegionKeyword;
            var endOfDirectiveToken = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(endOfDirectiveToken);
            this.endOfDirectiveToken = endOfDirectiveToken;
            this.isActive = (bool)reader.ReadBoolean();
        }

        internal override void WriteTo(ObjectWriter writer)
        {
            base.WriteTo(writer);
            writer.WriteValue(this.hashToken);
            writer.WriteValue(this.endRegionKeyword);
            writer.WriteValue(this.endOfDirectiveToken);
            writer.WriteBoolean(this.isActive);
        }

        static EndRegionDirectiveTriviaSyntax()
        {
            ObjectBinder.RegisterTypeReader(typeof(EndRegionDirectiveTriviaSyntax), r => new EndRegionDirectiveTriviaSyntax(r));
        }
    }

    internal sealed partial class ErrorDirectiveTriviaSyntax : DirectiveTriviaSyntax
    {
        internal readonly SyntaxToken hashToken;
        internal readonly SyntaxToken errorKeyword;
        internal readonly SyntaxToken endOfDirectiveToken;
        internal readonly bool isActive;

        internal ErrorDirectiveTriviaSyntax(SyntaxKind kind, SyntaxToken hashToken, SyntaxToken errorKeyword, SyntaxToken endOfDirectiveToken, bool isActive, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
            this.SlotCount = 3;
            this.AdjustFlagsAndWidth(hashToken);
            this.hashToken = hashToken;
            this.AdjustFlagsAndWidth(errorKeyword);
            this.errorKeyword = errorKeyword;
            this.AdjustFlagsAndWidth(endOfDirectiveToken);
            this.endOfDirectiveToken = endOfDirectiveToken;
            this.isActive = isActive;
        }

        internal ErrorDirectiveTriviaSyntax(SyntaxKind kind, SyntaxToken hashToken, SyntaxToken errorKeyword, SyntaxToken endOfDirectiveToken, bool isActive, SyntaxFactoryContext context)
          : base(kind)
        {
            this.SetFactoryContext(context);
            this.SlotCount = 3;
            this.AdjustFlagsAndWidth(hashToken);
            this.hashToken = hashToken;
            this.AdjustFlagsAndWidth(errorKeyword);
            this.errorKeyword = errorKeyword;
            this.AdjustFlagsAndWidth(endOfDirectiveToken);
            this.endOfDirectiveToken = endOfDirectiveToken;
            this.isActive = isActive;
        }

        internal ErrorDirectiveTriviaSyntax(SyntaxKind kind, SyntaxToken hashToken, SyntaxToken errorKeyword, SyntaxToken endOfDirectiveToken, bool isActive)
          : base(kind)
        {
            this.SlotCount = 3;
            this.AdjustFlagsAndWidth(hashToken);
            this.hashToken = hashToken;
            this.AdjustFlagsAndWidth(errorKeyword);
            this.errorKeyword = errorKeyword;
            this.AdjustFlagsAndWidth(endOfDirectiveToken);
            this.endOfDirectiveToken = endOfDirectiveToken;
            this.isActive = isActive;
        }

        public override SyntaxToken HashToken => this.hashToken;
        public SyntaxToken ErrorKeyword => this.errorKeyword;
        public override SyntaxToken EndOfDirectiveToken => this.endOfDirectiveToken;
        public override bool IsActive => this.isActive;

        internal override GreenNode? GetSlot(int index)
            => index switch
            {
                0 => this.hashToken,
                1 => this.errorKeyword,
                2 => this.endOfDirectiveToken,
                _ => null,
            };

        internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new CSharp.Syntax.ErrorDirectiveTriviaSyntax(this, parent, position);

        public override void Accept(CSharpSyntaxVisitor visitor) => visitor.VisitErrorDirectiveTrivia(this);
        public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor) => visitor.VisitErrorDirectiveTrivia(this);

        public ErrorDirectiveTriviaSyntax Update(SyntaxToken hashToken, SyntaxToken errorKeyword, SyntaxToken endOfDirectiveToken, bool isActive)
        {
            if (hashToken != this.HashToken || errorKeyword != this.ErrorKeyword || endOfDirectiveToken != this.EndOfDirectiveToken)
            {
                var newNode = SyntaxFactory.ErrorDirectiveTrivia(hashToken, errorKeyword, endOfDirectiveToken, isActive);
                var diags = GetDiagnostics();
                if (diags?.Length > 0)
                    newNode = newNode.WithDiagnosticsGreen(diags);
                var annotations = GetAnnotations();
                if (annotations?.Length > 0)
                    newNode = newNode.WithAnnotationsGreen(annotations);
                return newNode;
            }

            return this;
        }

        internal override GreenNode SetDiagnostics(DiagnosticInfo[]? diagnostics)
            => new ErrorDirectiveTriviaSyntax(this.Kind, this.hashToken, this.errorKeyword, this.endOfDirectiveToken, this.isActive, diagnostics, GetAnnotations());

        internal override GreenNode SetAnnotations(SyntaxAnnotation[]? annotations)
            => new ErrorDirectiveTriviaSyntax(this.Kind, this.hashToken, this.errorKeyword, this.endOfDirectiveToken, this.isActive, GetDiagnostics(), annotations);

        internal ErrorDirectiveTriviaSyntax(ObjectReader reader)
          : base(reader)
        {
            this.SlotCount = 3;
            var hashToken = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(hashToken);
            this.hashToken = hashToken;
            var errorKeyword = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(errorKeyword);
            this.errorKeyword = errorKeyword;
            var endOfDirectiveToken = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(endOfDirectiveToken);
            this.endOfDirectiveToken = endOfDirectiveToken;
            this.isActive = (bool)reader.ReadBoolean();
        }

        internal override void WriteTo(ObjectWriter writer)
        {
            base.WriteTo(writer);
            writer.WriteValue(this.hashToken);
            writer.WriteValue(this.errorKeyword);
            writer.WriteValue(this.endOfDirectiveToken);
            writer.WriteBoolean(this.isActive);
        }

        static ErrorDirectiveTriviaSyntax()
        {
            ObjectBinder.RegisterTypeReader(typeof(ErrorDirectiveTriviaSyntax), r => new ErrorDirectiveTriviaSyntax(r));
        }
    }

    internal sealed partial class WarningDirectiveTriviaSyntax : DirectiveTriviaSyntax
    {
        internal readonly SyntaxToken hashToken;
        internal readonly SyntaxToken warningKeyword;
        internal readonly SyntaxToken endOfDirectiveToken;
        internal readonly bool isActive;

        internal WarningDirectiveTriviaSyntax(SyntaxKind kind, SyntaxToken hashToken, SyntaxToken warningKeyword, SyntaxToken endOfDirectiveToken, bool isActive, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
            this.SlotCount = 3;
            this.AdjustFlagsAndWidth(hashToken);
            this.hashToken = hashToken;
            this.AdjustFlagsAndWidth(warningKeyword);
            this.warningKeyword = warningKeyword;
            this.AdjustFlagsAndWidth(endOfDirectiveToken);
            this.endOfDirectiveToken = endOfDirectiveToken;
            this.isActive = isActive;
        }

        internal WarningDirectiveTriviaSyntax(SyntaxKind kind, SyntaxToken hashToken, SyntaxToken warningKeyword, SyntaxToken endOfDirectiveToken, bool isActive, SyntaxFactoryContext context)
          : base(kind)
        {
            this.SetFactoryContext(context);
            this.SlotCount = 3;
            this.AdjustFlagsAndWidth(hashToken);
            this.hashToken = hashToken;
            this.AdjustFlagsAndWidth(warningKeyword);
            this.warningKeyword = warningKeyword;
            this.AdjustFlagsAndWidth(endOfDirectiveToken);
            this.endOfDirectiveToken = endOfDirectiveToken;
            this.isActive = isActive;
        }

        internal WarningDirectiveTriviaSyntax(SyntaxKind kind, SyntaxToken hashToken, SyntaxToken warningKeyword, SyntaxToken endOfDirectiveToken, bool isActive)
          : base(kind)
        {
            this.SlotCount = 3;
            this.AdjustFlagsAndWidth(hashToken);
            this.hashToken = hashToken;
            this.AdjustFlagsAndWidth(warningKeyword);
            this.warningKeyword = warningKeyword;
            this.AdjustFlagsAndWidth(endOfDirectiveToken);
            this.endOfDirectiveToken = endOfDirectiveToken;
            this.isActive = isActive;
        }

        public override SyntaxToken HashToken => this.hashToken;
        public SyntaxToken WarningKeyword => this.warningKeyword;
        public override SyntaxToken EndOfDirectiveToken => this.endOfDirectiveToken;
        public override bool IsActive => this.isActive;

        internal override GreenNode? GetSlot(int index)
            => index switch
            {
                0 => this.hashToken,
                1 => this.warningKeyword,
                2 => this.endOfDirectiveToken,
                _ => null,
            };

        internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new CSharp.Syntax.WarningDirectiveTriviaSyntax(this, parent, position);

        public override void Accept(CSharpSyntaxVisitor visitor) => visitor.VisitWarningDirectiveTrivia(this);
        public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor) => visitor.VisitWarningDirectiveTrivia(this);

        public WarningDirectiveTriviaSyntax Update(SyntaxToken hashToken, SyntaxToken warningKeyword, SyntaxToken endOfDirectiveToken, bool isActive)
        {
            if (hashToken != this.HashToken || warningKeyword != this.WarningKeyword || endOfDirectiveToken != this.EndOfDirectiveToken)
            {
                var newNode = SyntaxFactory.WarningDirectiveTrivia(hashToken, warningKeyword, endOfDirectiveToken, isActive);
                var diags = GetDiagnostics();
                if (diags?.Length > 0)
                    newNode = newNode.WithDiagnosticsGreen(diags);
                var annotations = GetAnnotations();
                if (annotations?.Length > 0)
                    newNode = newNode.WithAnnotationsGreen(annotations);
                return newNode;
            }

            return this;
        }

        internal override GreenNode SetDiagnostics(DiagnosticInfo[]? diagnostics)
            => new WarningDirectiveTriviaSyntax(this.Kind, this.hashToken, this.warningKeyword, this.endOfDirectiveToken, this.isActive, diagnostics, GetAnnotations());

        internal override GreenNode SetAnnotations(SyntaxAnnotation[]? annotations)
            => new WarningDirectiveTriviaSyntax(this.Kind, this.hashToken, this.warningKeyword, this.endOfDirectiveToken, this.isActive, GetDiagnostics(), annotations);

        internal WarningDirectiveTriviaSyntax(ObjectReader reader)
          : base(reader)
        {
            this.SlotCount = 3;
            var hashToken = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(hashToken);
            this.hashToken = hashToken;
            var warningKeyword = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(warningKeyword);
            this.warningKeyword = warningKeyword;
            var endOfDirectiveToken = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(endOfDirectiveToken);
            this.endOfDirectiveToken = endOfDirectiveToken;
            this.isActive = (bool)reader.ReadBoolean();
        }

        internal override void WriteTo(ObjectWriter writer)
        {
            base.WriteTo(writer);
            writer.WriteValue(this.hashToken);
            writer.WriteValue(this.warningKeyword);
            writer.WriteValue(this.endOfDirectiveToken);
            writer.WriteBoolean(this.isActive);
        }

        static WarningDirectiveTriviaSyntax()
        {
            ObjectBinder.RegisterTypeReader(typeof(WarningDirectiveTriviaSyntax), r => new WarningDirectiveTriviaSyntax(r));
        }
    }

    internal sealed partial class BadDirectiveTriviaSyntax : DirectiveTriviaSyntax
    {
        internal readonly SyntaxToken hashToken;
        internal readonly SyntaxToken identifier;
        internal readonly SyntaxToken endOfDirectiveToken;
        internal readonly bool isActive;

        internal BadDirectiveTriviaSyntax(SyntaxKind kind, SyntaxToken hashToken, SyntaxToken identifier, SyntaxToken endOfDirectiveToken, bool isActive, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
            this.SlotCount = 3;
            this.AdjustFlagsAndWidth(hashToken);
            this.hashToken = hashToken;
            this.AdjustFlagsAndWidth(identifier);
            this.identifier = identifier;
            this.AdjustFlagsAndWidth(endOfDirectiveToken);
            this.endOfDirectiveToken = endOfDirectiveToken;
            this.isActive = isActive;
        }

        internal BadDirectiveTriviaSyntax(SyntaxKind kind, SyntaxToken hashToken, SyntaxToken identifier, SyntaxToken endOfDirectiveToken, bool isActive, SyntaxFactoryContext context)
          : base(kind)
        {
            this.SetFactoryContext(context);
            this.SlotCount = 3;
            this.AdjustFlagsAndWidth(hashToken);
            this.hashToken = hashToken;
            this.AdjustFlagsAndWidth(identifier);
            this.identifier = identifier;
            this.AdjustFlagsAndWidth(endOfDirectiveToken);
            this.endOfDirectiveToken = endOfDirectiveToken;
            this.isActive = isActive;
        }

        internal BadDirectiveTriviaSyntax(SyntaxKind kind, SyntaxToken hashToken, SyntaxToken identifier, SyntaxToken endOfDirectiveToken, bool isActive)
          : base(kind)
        {
            this.SlotCount = 3;
            this.AdjustFlagsAndWidth(hashToken);
            this.hashToken = hashToken;
            this.AdjustFlagsAndWidth(identifier);
            this.identifier = identifier;
            this.AdjustFlagsAndWidth(endOfDirectiveToken);
            this.endOfDirectiveToken = endOfDirectiveToken;
            this.isActive = isActive;
        }

        public override SyntaxToken HashToken => this.hashToken;
        public SyntaxToken Identifier => this.identifier;
        public override SyntaxToken EndOfDirectiveToken => this.endOfDirectiveToken;
        public override bool IsActive => this.isActive;

        internal override GreenNode? GetSlot(int index)
            => index switch
            {
                0 => this.hashToken,
                1 => this.identifier,
                2 => this.endOfDirectiveToken,
                _ => null,
            };

        internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new CSharp.Syntax.BadDirectiveTriviaSyntax(this, parent, position);

        public override void Accept(CSharpSyntaxVisitor visitor) => visitor.VisitBadDirectiveTrivia(this);
        public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor) => visitor.VisitBadDirectiveTrivia(this);

        public BadDirectiveTriviaSyntax Update(SyntaxToken hashToken, SyntaxToken identifier, SyntaxToken endOfDirectiveToken, bool isActive)
        {
            if (hashToken != this.HashToken || identifier != this.Identifier || endOfDirectiveToken != this.EndOfDirectiveToken)
            {
                var newNode = SyntaxFactory.BadDirectiveTrivia(hashToken, identifier, endOfDirectiveToken, isActive);
                var diags = GetDiagnostics();
                if (diags?.Length > 0)
                    newNode = newNode.WithDiagnosticsGreen(diags);
                var annotations = GetAnnotations();
                if (annotations?.Length > 0)
                    newNode = newNode.WithAnnotationsGreen(annotations);
                return newNode;
            }

            return this;
        }

        internal override GreenNode SetDiagnostics(DiagnosticInfo[]? diagnostics)
            => new BadDirectiveTriviaSyntax(this.Kind, this.hashToken, this.identifier, this.endOfDirectiveToken, this.isActive, diagnostics, GetAnnotations());

        internal override GreenNode SetAnnotations(SyntaxAnnotation[]? annotations)
            => new BadDirectiveTriviaSyntax(this.Kind, this.hashToken, this.identifier, this.endOfDirectiveToken, this.isActive, GetDiagnostics(), annotations);

        internal BadDirectiveTriviaSyntax(ObjectReader reader)
          : base(reader)
        {
            this.SlotCount = 3;
            var hashToken = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(hashToken);
            this.hashToken = hashToken;
            var identifier = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(identifier);
            this.identifier = identifier;
            var endOfDirectiveToken = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(endOfDirectiveToken);
            this.endOfDirectiveToken = endOfDirectiveToken;
            this.isActive = (bool)reader.ReadBoolean();
        }

        internal override void WriteTo(ObjectWriter writer)
        {
            base.WriteTo(writer);
            writer.WriteValue(this.hashToken);
            writer.WriteValue(this.identifier);
            writer.WriteValue(this.endOfDirectiveToken);
            writer.WriteBoolean(this.isActive);
        }

        static BadDirectiveTriviaSyntax()
        {
            ObjectBinder.RegisterTypeReader(typeof(BadDirectiveTriviaSyntax), r => new BadDirectiveTriviaSyntax(r));
        }
    }

    internal sealed partial class DefineDirectiveTriviaSyntax : DirectiveTriviaSyntax
    {
        internal readonly SyntaxToken hashToken;
        internal readonly SyntaxToken defineKeyword;
        internal readonly SyntaxToken name;
        internal readonly SyntaxToken endOfDirectiveToken;
        internal readonly bool isActive;

        internal DefineDirectiveTriviaSyntax(SyntaxKind kind, SyntaxToken hashToken, SyntaxToken defineKeyword, SyntaxToken name, SyntaxToken endOfDirectiveToken, bool isActive, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
            this.SlotCount = 4;
            this.AdjustFlagsAndWidth(hashToken);
            this.hashToken = hashToken;
            this.AdjustFlagsAndWidth(defineKeyword);
            this.defineKeyword = defineKeyword;
            this.AdjustFlagsAndWidth(name);
            this.name = name;
            this.AdjustFlagsAndWidth(endOfDirectiveToken);
            this.endOfDirectiveToken = endOfDirectiveToken;
            this.isActive = isActive;
        }

        internal DefineDirectiveTriviaSyntax(SyntaxKind kind, SyntaxToken hashToken, SyntaxToken defineKeyword, SyntaxToken name, SyntaxToken endOfDirectiveToken, bool isActive, SyntaxFactoryContext context)
          : base(kind)
        {
            this.SetFactoryContext(context);
            this.SlotCount = 4;
            this.AdjustFlagsAndWidth(hashToken);
            this.hashToken = hashToken;
            this.AdjustFlagsAndWidth(defineKeyword);
            this.defineKeyword = defineKeyword;
            this.AdjustFlagsAndWidth(name);
            this.name = name;
            this.AdjustFlagsAndWidth(endOfDirectiveToken);
            this.endOfDirectiveToken = endOfDirectiveToken;
            this.isActive = isActive;
        }

        internal DefineDirectiveTriviaSyntax(SyntaxKind kind, SyntaxToken hashToken, SyntaxToken defineKeyword, SyntaxToken name, SyntaxToken endOfDirectiveToken, bool isActive)
          : base(kind)
        {
            this.SlotCount = 4;
            this.AdjustFlagsAndWidth(hashToken);
            this.hashToken = hashToken;
            this.AdjustFlagsAndWidth(defineKeyword);
            this.defineKeyword = defineKeyword;
            this.AdjustFlagsAndWidth(name);
            this.name = name;
            this.AdjustFlagsAndWidth(endOfDirectiveToken);
            this.endOfDirectiveToken = endOfDirectiveToken;
            this.isActive = isActive;
        }

        public override SyntaxToken HashToken => this.hashToken;
        public SyntaxToken DefineKeyword => this.defineKeyword;
        public SyntaxToken Name => this.name;
        public override SyntaxToken EndOfDirectiveToken => this.endOfDirectiveToken;
        public override bool IsActive => this.isActive;

        internal override GreenNode? GetSlot(int index)
            => index switch
            {
                0 => this.hashToken,
                1 => this.defineKeyword,
                2 => this.name,
                3 => this.endOfDirectiveToken,
                _ => null,
            };

        internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new CSharp.Syntax.DefineDirectiveTriviaSyntax(this, parent, position);

        public override void Accept(CSharpSyntaxVisitor visitor) => visitor.VisitDefineDirectiveTrivia(this);
        public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor) => visitor.VisitDefineDirectiveTrivia(this);

        public DefineDirectiveTriviaSyntax Update(SyntaxToken hashToken, SyntaxToken defineKeyword, SyntaxToken name, SyntaxToken endOfDirectiveToken, bool isActive)
        {
            if (hashToken != this.HashToken || defineKeyword != this.DefineKeyword || name != this.Name || endOfDirectiveToken != this.EndOfDirectiveToken)
            {
                var newNode = SyntaxFactory.DefineDirectiveTrivia(hashToken, defineKeyword, name, endOfDirectiveToken, isActive);
                var diags = GetDiagnostics();
                if (diags?.Length > 0)
                    newNode = newNode.WithDiagnosticsGreen(diags);
                var annotations = GetAnnotations();
                if (annotations?.Length > 0)
                    newNode = newNode.WithAnnotationsGreen(annotations);
                return newNode;
            }

            return this;
        }

        internal override GreenNode SetDiagnostics(DiagnosticInfo[]? diagnostics)
            => new DefineDirectiveTriviaSyntax(this.Kind, this.hashToken, this.defineKeyword, this.name, this.endOfDirectiveToken, this.isActive, diagnostics, GetAnnotations());

        internal override GreenNode SetAnnotations(SyntaxAnnotation[]? annotations)
            => new DefineDirectiveTriviaSyntax(this.Kind, this.hashToken, this.defineKeyword, this.name, this.endOfDirectiveToken, this.isActive, GetDiagnostics(), annotations);

        internal DefineDirectiveTriviaSyntax(ObjectReader reader)
          : base(reader)
        {
            this.SlotCount = 4;
            var hashToken = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(hashToken);
            this.hashToken = hashToken;
            var defineKeyword = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(defineKeyword);
            this.defineKeyword = defineKeyword;
            var name = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(name);
            this.name = name;
            var endOfDirectiveToken = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(endOfDirectiveToken);
            this.endOfDirectiveToken = endOfDirectiveToken;
            this.isActive = (bool)reader.ReadBoolean();
        }

        internal override void WriteTo(ObjectWriter writer)
        {
            base.WriteTo(writer);
            writer.WriteValue(this.hashToken);
            writer.WriteValue(this.defineKeyword);
            writer.WriteValue(this.name);
            writer.WriteValue(this.endOfDirectiveToken);
            writer.WriteBoolean(this.isActive);
        }

        static DefineDirectiveTriviaSyntax()
        {
            ObjectBinder.RegisterTypeReader(typeof(DefineDirectiveTriviaSyntax), r => new DefineDirectiveTriviaSyntax(r));
        }
    }

    internal sealed partial class UndefDirectiveTriviaSyntax : DirectiveTriviaSyntax
    {
        internal readonly SyntaxToken hashToken;
        internal readonly SyntaxToken undefKeyword;
        internal readonly SyntaxToken name;
        internal readonly SyntaxToken endOfDirectiveToken;
        internal readonly bool isActive;

        internal UndefDirectiveTriviaSyntax(SyntaxKind kind, SyntaxToken hashToken, SyntaxToken undefKeyword, SyntaxToken name, SyntaxToken endOfDirectiveToken, bool isActive, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
            this.SlotCount = 4;
            this.AdjustFlagsAndWidth(hashToken);
            this.hashToken = hashToken;
            this.AdjustFlagsAndWidth(undefKeyword);
            this.undefKeyword = undefKeyword;
            this.AdjustFlagsAndWidth(name);
            this.name = name;
            this.AdjustFlagsAndWidth(endOfDirectiveToken);
            this.endOfDirectiveToken = endOfDirectiveToken;
            this.isActive = isActive;
        }

        internal UndefDirectiveTriviaSyntax(SyntaxKind kind, SyntaxToken hashToken, SyntaxToken undefKeyword, SyntaxToken name, SyntaxToken endOfDirectiveToken, bool isActive, SyntaxFactoryContext context)
          : base(kind)
        {
            this.SetFactoryContext(context);
            this.SlotCount = 4;
            this.AdjustFlagsAndWidth(hashToken);
            this.hashToken = hashToken;
            this.AdjustFlagsAndWidth(undefKeyword);
            this.undefKeyword = undefKeyword;
            this.AdjustFlagsAndWidth(name);
            this.name = name;
            this.AdjustFlagsAndWidth(endOfDirectiveToken);
            this.endOfDirectiveToken = endOfDirectiveToken;
            this.isActive = isActive;
        }

        internal UndefDirectiveTriviaSyntax(SyntaxKind kind, SyntaxToken hashToken, SyntaxToken undefKeyword, SyntaxToken name, SyntaxToken endOfDirectiveToken, bool isActive)
          : base(kind)
        {
            this.SlotCount = 4;
            this.AdjustFlagsAndWidth(hashToken);
            this.hashToken = hashToken;
            this.AdjustFlagsAndWidth(undefKeyword);
            this.undefKeyword = undefKeyword;
            this.AdjustFlagsAndWidth(name);
            this.name = name;
            this.AdjustFlagsAndWidth(endOfDirectiveToken);
            this.endOfDirectiveToken = endOfDirectiveToken;
            this.isActive = isActive;
        }

        public override SyntaxToken HashToken => this.hashToken;
        public SyntaxToken UndefKeyword => this.undefKeyword;
        public SyntaxToken Name => this.name;
        public override SyntaxToken EndOfDirectiveToken => this.endOfDirectiveToken;
        public override bool IsActive => this.isActive;

        internal override GreenNode? GetSlot(int index)
            => index switch
            {
                0 => this.hashToken,
                1 => this.undefKeyword,
                2 => this.name,
                3 => this.endOfDirectiveToken,
                _ => null,
            };

        internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new CSharp.Syntax.UndefDirectiveTriviaSyntax(this, parent, position);

        public override void Accept(CSharpSyntaxVisitor visitor) => visitor.VisitUndefDirectiveTrivia(this);
        public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor) => visitor.VisitUndefDirectiveTrivia(this);

        public UndefDirectiveTriviaSyntax Update(SyntaxToken hashToken, SyntaxToken undefKeyword, SyntaxToken name, SyntaxToken endOfDirectiveToken, bool isActive)
        {
            if (hashToken != this.HashToken || undefKeyword != this.UndefKeyword || name != this.Name || endOfDirectiveToken != this.EndOfDirectiveToken)
            {
                var newNode = SyntaxFactory.UndefDirectiveTrivia(hashToken, undefKeyword, name, endOfDirectiveToken, isActive);
                var diags = GetDiagnostics();
                if (diags?.Length > 0)
                    newNode = newNode.WithDiagnosticsGreen(diags);
                var annotations = GetAnnotations();
                if (annotations?.Length > 0)
                    newNode = newNode.WithAnnotationsGreen(annotations);
                return newNode;
            }

            return this;
        }

        internal override GreenNode SetDiagnostics(DiagnosticInfo[]? diagnostics)
            => new UndefDirectiveTriviaSyntax(this.Kind, this.hashToken, this.undefKeyword, this.name, this.endOfDirectiveToken, this.isActive, diagnostics, GetAnnotations());

        internal override GreenNode SetAnnotations(SyntaxAnnotation[]? annotations)
            => new UndefDirectiveTriviaSyntax(this.Kind, this.hashToken, this.undefKeyword, this.name, this.endOfDirectiveToken, this.isActive, GetDiagnostics(), annotations);

        internal UndefDirectiveTriviaSyntax(ObjectReader reader)
          : base(reader)
        {
            this.SlotCount = 4;
            var hashToken = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(hashToken);
            this.hashToken = hashToken;
            var undefKeyword = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(undefKeyword);
            this.undefKeyword = undefKeyword;
            var name = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(name);
            this.name = name;
            var endOfDirectiveToken = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(endOfDirectiveToken);
            this.endOfDirectiveToken = endOfDirectiveToken;
            this.isActive = (bool)reader.ReadBoolean();
        }

        internal override void WriteTo(ObjectWriter writer)
        {
            base.WriteTo(writer);
            writer.WriteValue(this.hashToken);
            writer.WriteValue(this.undefKeyword);
            writer.WriteValue(this.name);
            writer.WriteValue(this.endOfDirectiveToken);
            writer.WriteBoolean(this.isActive);
        }

        static UndefDirectiveTriviaSyntax()
        {
            ObjectBinder.RegisterTypeReader(typeof(UndefDirectiveTriviaSyntax), r => new UndefDirectiveTriviaSyntax(r));
        }
    }

    internal sealed partial class LineDirectiveTriviaSyntax : DirectiveTriviaSyntax
    {
        internal readonly SyntaxToken hashToken;
        internal readonly SyntaxToken lineKeyword;
        internal readonly SyntaxToken line;
        internal readonly SyntaxToken? file;
        internal readonly SyntaxToken endOfDirectiveToken;
        internal readonly bool isActive;

        internal LineDirectiveTriviaSyntax(SyntaxKind kind, SyntaxToken hashToken, SyntaxToken lineKeyword, SyntaxToken line, SyntaxToken? file, SyntaxToken endOfDirectiveToken, bool isActive, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
            this.SlotCount = 5;
            this.AdjustFlagsAndWidth(hashToken);
            this.hashToken = hashToken;
            this.AdjustFlagsAndWidth(lineKeyword);
            this.lineKeyword = lineKeyword;
            this.AdjustFlagsAndWidth(line);
            this.line = line;
            if (file != null)
            {
                this.AdjustFlagsAndWidth(file);
                this.file = file;
            }
            this.AdjustFlagsAndWidth(endOfDirectiveToken);
            this.endOfDirectiveToken = endOfDirectiveToken;
            this.isActive = isActive;
        }

        internal LineDirectiveTriviaSyntax(SyntaxKind kind, SyntaxToken hashToken, SyntaxToken lineKeyword, SyntaxToken line, SyntaxToken? file, SyntaxToken endOfDirectiveToken, bool isActive, SyntaxFactoryContext context)
          : base(kind)
        {
            this.SetFactoryContext(context);
            this.SlotCount = 5;
            this.AdjustFlagsAndWidth(hashToken);
            this.hashToken = hashToken;
            this.AdjustFlagsAndWidth(lineKeyword);
            this.lineKeyword = lineKeyword;
            this.AdjustFlagsAndWidth(line);
            this.line = line;
            if (file != null)
            {
                this.AdjustFlagsAndWidth(file);
                this.file = file;
            }
            this.AdjustFlagsAndWidth(endOfDirectiveToken);
            this.endOfDirectiveToken = endOfDirectiveToken;
            this.isActive = isActive;
        }

        internal LineDirectiveTriviaSyntax(SyntaxKind kind, SyntaxToken hashToken, SyntaxToken lineKeyword, SyntaxToken line, SyntaxToken? file, SyntaxToken endOfDirectiveToken, bool isActive)
          : base(kind)
        {
            this.SlotCount = 5;
            this.AdjustFlagsAndWidth(hashToken);
            this.hashToken = hashToken;
            this.AdjustFlagsAndWidth(lineKeyword);
            this.lineKeyword = lineKeyword;
            this.AdjustFlagsAndWidth(line);
            this.line = line;
            if (file != null)
            {
                this.AdjustFlagsAndWidth(file);
                this.file = file;
            }
            this.AdjustFlagsAndWidth(endOfDirectiveToken);
            this.endOfDirectiveToken = endOfDirectiveToken;
            this.isActive = isActive;
        }

        public override SyntaxToken HashToken => this.hashToken;
        public SyntaxToken LineKeyword => this.lineKeyword;
        public SyntaxToken Line => this.line;
        public SyntaxToken? File => this.file;
        public override SyntaxToken EndOfDirectiveToken => this.endOfDirectiveToken;
        public override bool IsActive => this.isActive;

        internal override GreenNode? GetSlot(int index)
            => index switch
            {
                0 => this.hashToken,
                1 => this.lineKeyword,
                2 => this.line,
                3 => this.file,
                4 => this.endOfDirectiveToken,
                _ => null,
            };

        internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new CSharp.Syntax.LineDirectiveTriviaSyntax(this, parent, position);

        public override void Accept(CSharpSyntaxVisitor visitor) => visitor.VisitLineDirectiveTrivia(this);
        public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor) => visitor.VisitLineDirectiveTrivia(this);

        public LineDirectiveTriviaSyntax Update(SyntaxToken hashToken, SyntaxToken lineKeyword, SyntaxToken line, SyntaxToken file, SyntaxToken endOfDirectiveToken, bool isActive)
        {
            if (hashToken != this.HashToken || lineKeyword != this.LineKeyword || line != this.Line || file != this.File || endOfDirectiveToken != this.EndOfDirectiveToken)
            {
                var newNode = SyntaxFactory.LineDirectiveTrivia(hashToken, lineKeyword, line, file, endOfDirectiveToken, isActive);
                var diags = GetDiagnostics();
                if (diags?.Length > 0)
                    newNode = newNode.WithDiagnosticsGreen(diags);
                var annotations = GetAnnotations();
                if (annotations?.Length > 0)
                    newNode = newNode.WithAnnotationsGreen(annotations);
                return newNode;
            }

            return this;
        }

        internal override GreenNode SetDiagnostics(DiagnosticInfo[]? diagnostics)
            => new LineDirectiveTriviaSyntax(this.Kind, this.hashToken, this.lineKeyword, this.line, this.file, this.endOfDirectiveToken, this.isActive, diagnostics, GetAnnotations());

        internal override GreenNode SetAnnotations(SyntaxAnnotation[]? annotations)
            => new LineDirectiveTriviaSyntax(this.Kind, this.hashToken, this.lineKeyword, this.line, this.file, this.endOfDirectiveToken, this.isActive, GetDiagnostics(), annotations);

        internal LineDirectiveTriviaSyntax(ObjectReader reader)
          : base(reader)
        {
            this.SlotCount = 5;
            var hashToken = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(hashToken);
            this.hashToken = hashToken;
            var lineKeyword = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(lineKeyword);
            this.lineKeyword = lineKeyword;
            var line = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(line);
            this.line = line;
            var file = (SyntaxToken?)reader.ReadValue();
            if (file != null)
            {
                AdjustFlagsAndWidth(file);
                this.file = file;
            }
            var endOfDirectiveToken = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(endOfDirectiveToken);
            this.endOfDirectiveToken = endOfDirectiveToken;
            this.isActive = (bool)reader.ReadBoolean();
        }

        internal override void WriteTo(ObjectWriter writer)
        {
            base.WriteTo(writer);
            writer.WriteValue(this.hashToken);
            writer.WriteValue(this.lineKeyword);
            writer.WriteValue(this.line);
            writer.WriteValue(this.file);
            writer.WriteValue(this.endOfDirectiveToken);
            writer.WriteBoolean(this.isActive);
        }

        static LineDirectiveTriviaSyntax()
        {
            ObjectBinder.RegisterTypeReader(typeof(LineDirectiveTriviaSyntax), r => new LineDirectiveTriviaSyntax(r));
        }
    }

    internal sealed partial class PragmaWarningDirectiveTriviaSyntax : DirectiveTriviaSyntax
    {
        internal readonly SyntaxToken hashToken;
        internal readonly SyntaxToken pragmaKeyword;
        internal readonly SyntaxToken warningKeyword;
        internal readonly SyntaxToken disableOrRestoreKeyword;
        internal readonly GreenNode? errorCodes;
        internal readonly SyntaxToken endOfDirectiveToken;
        internal readonly bool isActive;

        internal PragmaWarningDirectiveTriviaSyntax(SyntaxKind kind, SyntaxToken hashToken, SyntaxToken pragmaKeyword, SyntaxToken warningKeyword, SyntaxToken disableOrRestoreKeyword, GreenNode? errorCodes, SyntaxToken endOfDirectiveToken, bool isActive, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
            this.SlotCount = 6;
            this.AdjustFlagsAndWidth(hashToken);
            this.hashToken = hashToken;
            this.AdjustFlagsAndWidth(pragmaKeyword);
            this.pragmaKeyword = pragmaKeyword;
            this.AdjustFlagsAndWidth(warningKeyword);
            this.warningKeyword = warningKeyword;
            this.AdjustFlagsAndWidth(disableOrRestoreKeyword);
            this.disableOrRestoreKeyword = disableOrRestoreKeyword;
            if (errorCodes != null)
            {
                this.AdjustFlagsAndWidth(errorCodes);
                this.errorCodes = errorCodes;
            }
            this.AdjustFlagsAndWidth(endOfDirectiveToken);
            this.endOfDirectiveToken = endOfDirectiveToken;
            this.isActive = isActive;
        }

        internal PragmaWarningDirectiveTriviaSyntax(SyntaxKind kind, SyntaxToken hashToken, SyntaxToken pragmaKeyword, SyntaxToken warningKeyword, SyntaxToken disableOrRestoreKeyword, GreenNode? errorCodes, SyntaxToken endOfDirectiveToken, bool isActive, SyntaxFactoryContext context)
          : base(kind)
        {
            this.SetFactoryContext(context);
            this.SlotCount = 6;
            this.AdjustFlagsAndWidth(hashToken);
            this.hashToken = hashToken;
            this.AdjustFlagsAndWidth(pragmaKeyword);
            this.pragmaKeyword = pragmaKeyword;
            this.AdjustFlagsAndWidth(warningKeyword);
            this.warningKeyword = warningKeyword;
            this.AdjustFlagsAndWidth(disableOrRestoreKeyword);
            this.disableOrRestoreKeyword = disableOrRestoreKeyword;
            if (errorCodes != null)
            {
                this.AdjustFlagsAndWidth(errorCodes);
                this.errorCodes = errorCodes;
            }
            this.AdjustFlagsAndWidth(endOfDirectiveToken);
            this.endOfDirectiveToken = endOfDirectiveToken;
            this.isActive = isActive;
        }

        internal PragmaWarningDirectiveTriviaSyntax(SyntaxKind kind, SyntaxToken hashToken, SyntaxToken pragmaKeyword, SyntaxToken warningKeyword, SyntaxToken disableOrRestoreKeyword, GreenNode? errorCodes, SyntaxToken endOfDirectiveToken, bool isActive)
          : base(kind)
        {
            this.SlotCount = 6;
            this.AdjustFlagsAndWidth(hashToken);
            this.hashToken = hashToken;
            this.AdjustFlagsAndWidth(pragmaKeyword);
            this.pragmaKeyword = pragmaKeyword;
            this.AdjustFlagsAndWidth(warningKeyword);
            this.warningKeyword = warningKeyword;
            this.AdjustFlagsAndWidth(disableOrRestoreKeyword);
            this.disableOrRestoreKeyword = disableOrRestoreKeyword;
            if (errorCodes != null)
            {
                this.AdjustFlagsAndWidth(errorCodes);
                this.errorCodes = errorCodes;
            }
            this.AdjustFlagsAndWidth(endOfDirectiveToken);
            this.endOfDirectiveToken = endOfDirectiveToken;
            this.isActive = isActive;
        }

        public override SyntaxToken HashToken => this.hashToken;
        public SyntaxToken PragmaKeyword => this.pragmaKeyword;
        public SyntaxToken WarningKeyword => this.warningKeyword;
        public SyntaxToken DisableOrRestoreKeyword => this.disableOrRestoreKeyword;
        public Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<ExpressionSyntax> ErrorCodes => new Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<ExpressionSyntax>(new Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<CSharpSyntaxNode>(this.errorCodes));
        public override SyntaxToken EndOfDirectiveToken => this.endOfDirectiveToken;
        public override bool IsActive => this.isActive;

        internal override GreenNode? GetSlot(int index)
            => index switch
            {
                0 => this.hashToken,
                1 => this.pragmaKeyword,
                2 => this.warningKeyword,
                3 => this.disableOrRestoreKeyword,
                4 => this.errorCodes,
                5 => this.endOfDirectiveToken,
                _ => null,
            };

        internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new CSharp.Syntax.PragmaWarningDirectiveTriviaSyntax(this, parent, position);

        public override void Accept(CSharpSyntaxVisitor visitor) => visitor.VisitPragmaWarningDirectiveTrivia(this);
        public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor) => visitor.VisitPragmaWarningDirectiveTrivia(this);

        public PragmaWarningDirectiveTriviaSyntax Update(SyntaxToken hashToken, SyntaxToken pragmaKeyword, SyntaxToken warningKeyword, SyntaxToken disableOrRestoreKeyword, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<ExpressionSyntax> errorCodes, SyntaxToken endOfDirectiveToken, bool isActive)
        {
            if (hashToken != this.HashToken || pragmaKeyword != this.PragmaKeyword || warningKeyword != this.WarningKeyword || disableOrRestoreKeyword != this.DisableOrRestoreKeyword || errorCodes != this.ErrorCodes || endOfDirectiveToken != this.EndOfDirectiveToken)
            {
                var newNode = SyntaxFactory.PragmaWarningDirectiveTrivia(hashToken, pragmaKeyword, warningKeyword, disableOrRestoreKeyword, errorCodes, endOfDirectiveToken, isActive);
                var diags = GetDiagnostics();
                if (diags?.Length > 0)
                    newNode = newNode.WithDiagnosticsGreen(diags);
                var annotations = GetAnnotations();
                if (annotations?.Length > 0)
                    newNode = newNode.WithAnnotationsGreen(annotations);
                return newNode;
            }

            return this;
        }

        internal override GreenNode SetDiagnostics(DiagnosticInfo[]? diagnostics)
            => new PragmaWarningDirectiveTriviaSyntax(this.Kind, this.hashToken, this.pragmaKeyword, this.warningKeyword, this.disableOrRestoreKeyword, this.errorCodes, this.endOfDirectiveToken, this.isActive, diagnostics, GetAnnotations());

        internal override GreenNode SetAnnotations(SyntaxAnnotation[]? annotations)
            => new PragmaWarningDirectiveTriviaSyntax(this.Kind, this.hashToken, this.pragmaKeyword, this.warningKeyword, this.disableOrRestoreKeyword, this.errorCodes, this.endOfDirectiveToken, this.isActive, GetDiagnostics(), annotations);

        internal PragmaWarningDirectiveTriviaSyntax(ObjectReader reader)
          : base(reader)
        {
            this.SlotCount = 6;
            var hashToken = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(hashToken);
            this.hashToken = hashToken;
            var pragmaKeyword = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(pragmaKeyword);
            this.pragmaKeyword = pragmaKeyword;
            var warningKeyword = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(warningKeyword);
            this.warningKeyword = warningKeyword;
            var disableOrRestoreKeyword = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(disableOrRestoreKeyword);
            this.disableOrRestoreKeyword = disableOrRestoreKeyword;
            var errorCodes = (GreenNode?)reader.ReadValue();
            if (errorCodes != null)
            {
                AdjustFlagsAndWidth(errorCodes);
                this.errorCodes = errorCodes;
            }
            var endOfDirectiveToken = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(endOfDirectiveToken);
            this.endOfDirectiveToken = endOfDirectiveToken;
            this.isActive = (bool)reader.ReadBoolean();
        }

        internal override void WriteTo(ObjectWriter writer)
        {
            base.WriteTo(writer);
            writer.WriteValue(this.hashToken);
            writer.WriteValue(this.pragmaKeyword);
            writer.WriteValue(this.warningKeyword);
            writer.WriteValue(this.disableOrRestoreKeyword);
            writer.WriteValue(this.errorCodes);
            writer.WriteValue(this.endOfDirectiveToken);
            writer.WriteBoolean(this.isActive);
        }

        static PragmaWarningDirectiveTriviaSyntax()
        {
            ObjectBinder.RegisterTypeReader(typeof(PragmaWarningDirectiveTriviaSyntax), r => new PragmaWarningDirectiveTriviaSyntax(r));
        }
    }

    internal sealed partial class PragmaChecksumDirectiveTriviaSyntax : DirectiveTriviaSyntax
    {
        internal readonly SyntaxToken hashToken;
        internal readonly SyntaxToken pragmaKeyword;
        internal readonly SyntaxToken checksumKeyword;
        internal readonly SyntaxToken file;
        internal readonly SyntaxToken guid;
        internal readonly SyntaxToken bytes;
        internal readonly SyntaxToken endOfDirectiveToken;
        internal readonly bool isActive;

        internal PragmaChecksumDirectiveTriviaSyntax(SyntaxKind kind, SyntaxToken hashToken, SyntaxToken pragmaKeyword, SyntaxToken checksumKeyword, SyntaxToken file, SyntaxToken guid, SyntaxToken bytes, SyntaxToken endOfDirectiveToken, bool isActive, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
            this.SlotCount = 7;
            this.AdjustFlagsAndWidth(hashToken);
            this.hashToken = hashToken;
            this.AdjustFlagsAndWidth(pragmaKeyword);
            this.pragmaKeyword = pragmaKeyword;
            this.AdjustFlagsAndWidth(checksumKeyword);
            this.checksumKeyword = checksumKeyword;
            this.AdjustFlagsAndWidth(file);
            this.file = file;
            this.AdjustFlagsAndWidth(guid);
            this.guid = guid;
            this.AdjustFlagsAndWidth(bytes);
            this.bytes = bytes;
            this.AdjustFlagsAndWidth(endOfDirectiveToken);
            this.endOfDirectiveToken = endOfDirectiveToken;
            this.isActive = isActive;
        }

        internal PragmaChecksumDirectiveTriviaSyntax(SyntaxKind kind, SyntaxToken hashToken, SyntaxToken pragmaKeyword, SyntaxToken checksumKeyword, SyntaxToken file, SyntaxToken guid, SyntaxToken bytes, SyntaxToken endOfDirectiveToken, bool isActive, SyntaxFactoryContext context)
          : base(kind)
        {
            this.SetFactoryContext(context);
            this.SlotCount = 7;
            this.AdjustFlagsAndWidth(hashToken);
            this.hashToken = hashToken;
            this.AdjustFlagsAndWidth(pragmaKeyword);
            this.pragmaKeyword = pragmaKeyword;
            this.AdjustFlagsAndWidth(checksumKeyword);
            this.checksumKeyword = checksumKeyword;
            this.AdjustFlagsAndWidth(file);
            this.file = file;
            this.AdjustFlagsAndWidth(guid);
            this.guid = guid;
            this.AdjustFlagsAndWidth(bytes);
            this.bytes = bytes;
            this.AdjustFlagsAndWidth(endOfDirectiveToken);
            this.endOfDirectiveToken = endOfDirectiveToken;
            this.isActive = isActive;
        }

        internal PragmaChecksumDirectiveTriviaSyntax(SyntaxKind kind, SyntaxToken hashToken, SyntaxToken pragmaKeyword, SyntaxToken checksumKeyword, SyntaxToken file, SyntaxToken guid, SyntaxToken bytes, SyntaxToken endOfDirectiveToken, bool isActive)
          : base(kind)
        {
            this.SlotCount = 7;
            this.AdjustFlagsAndWidth(hashToken);
            this.hashToken = hashToken;
            this.AdjustFlagsAndWidth(pragmaKeyword);
            this.pragmaKeyword = pragmaKeyword;
            this.AdjustFlagsAndWidth(checksumKeyword);
            this.checksumKeyword = checksumKeyword;
            this.AdjustFlagsAndWidth(file);
            this.file = file;
            this.AdjustFlagsAndWidth(guid);
            this.guid = guid;
            this.AdjustFlagsAndWidth(bytes);
            this.bytes = bytes;
            this.AdjustFlagsAndWidth(endOfDirectiveToken);
            this.endOfDirectiveToken = endOfDirectiveToken;
            this.isActive = isActive;
        }

        public override SyntaxToken HashToken => this.hashToken;
        public SyntaxToken PragmaKeyword => this.pragmaKeyword;
        public SyntaxToken ChecksumKeyword => this.checksumKeyword;
        public SyntaxToken File => this.file;
        public SyntaxToken Guid => this.guid;
        public SyntaxToken Bytes => this.bytes;
        public override SyntaxToken EndOfDirectiveToken => this.endOfDirectiveToken;
        public override bool IsActive => this.isActive;

        internal override GreenNode? GetSlot(int index)
            => index switch
            {
                0 => this.hashToken,
                1 => this.pragmaKeyword,
                2 => this.checksumKeyword,
                3 => this.file,
                4 => this.guid,
                5 => this.bytes,
                6 => this.endOfDirectiveToken,
                _ => null,
            };

        internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new CSharp.Syntax.PragmaChecksumDirectiveTriviaSyntax(this, parent, position);

        public override void Accept(CSharpSyntaxVisitor visitor) => visitor.VisitPragmaChecksumDirectiveTrivia(this);
        public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor) => visitor.VisitPragmaChecksumDirectiveTrivia(this);

        public PragmaChecksumDirectiveTriviaSyntax Update(SyntaxToken hashToken, SyntaxToken pragmaKeyword, SyntaxToken checksumKeyword, SyntaxToken file, SyntaxToken guid, SyntaxToken bytes, SyntaxToken endOfDirectiveToken, bool isActive)
        {
            if (hashToken != this.HashToken || pragmaKeyword != this.PragmaKeyword || checksumKeyword != this.ChecksumKeyword || file != this.File || guid != this.Guid || bytes != this.Bytes || endOfDirectiveToken != this.EndOfDirectiveToken)
            {
                var newNode = SyntaxFactory.PragmaChecksumDirectiveTrivia(hashToken, pragmaKeyword, checksumKeyword, file, guid, bytes, endOfDirectiveToken, isActive);
                var diags = GetDiagnostics();
                if (diags?.Length > 0)
                    newNode = newNode.WithDiagnosticsGreen(diags);
                var annotations = GetAnnotations();
                if (annotations?.Length > 0)
                    newNode = newNode.WithAnnotationsGreen(annotations);
                return newNode;
            }

            return this;
        }

        internal override GreenNode SetDiagnostics(DiagnosticInfo[]? diagnostics)
            => new PragmaChecksumDirectiveTriviaSyntax(this.Kind, this.hashToken, this.pragmaKeyword, this.checksumKeyword, this.file, this.guid, this.bytes, this.endOfDirectiveToken, this.isActive, diagnostics, GetAnnotations());

        internal override GreenNode SetAnnotations(SyntaxAnnotation[]? annotations)
            => new PragmaChecksumDirectiveTriviaSyntax(this.Kind, this.hashToken, this.pragmaKeyword, this.checksumKeyword, this.file, this.guid, this.bytes, this.endOfDirectiveToken, this.isActive, GetDiagnostics(), annotations);

        internal PragmaChecksumDirectiveTriviaSyntax(ObjectReader reader)
          : base(reader)
        {
            this.SlotCount = 7;
            var hashToken = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(hashToken);
            this.hashToken = hashToken;
            var pragmaKeyword = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(pragmaKeyword);
            this.pragmaKeyword = pragmaKeyword;
            var checksumKeyword = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(checksumKeyword);
            this.checksumKeyword = checksumKeyword;
            var file = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(file);
            this.file = file;
            var guid = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(guid);
            this.guid = guid;
            var bytes = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(bytes);
            this.bytes = bytes;
            var endOfDirectiveToken = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(endOfDirectiveToken);
            this.endOfDirectiveToken = endOfDirectiveToken;
            this.isActive = (bool)reader.ReadBoolean();
        }

        internal override void WriteTo(ObjectWriter writer)
        {
            base.WriteTo(writer);
            writer.WriteValue(this.hashToken);
            writer.WriteValue(this.pragmaKeyword);
            writer.WriteValue(this.checksumKeyword);
            writer.WriteValue(this.file);
            writer.WriteValue(this.guid);
            writer.WriteValue(this.bytes);
            writer.WriteValue(this.endOfDirectiveToken);
            writer.WriteBoolean(this.isActive);
        }

        static PragmaChecksumDirectiveTriviaSyntax()
        {
            ObjectBinder.RegisterTypeReader(typeof(PragmaChecksumDirectiveTriviaSyntax), r => new PragmaChecksumDirectiveTriviaSyntax(r));
        }
    }

    internal sealed partial class ReferenceDirectiveTriviaSyntax : DirectiveTriviaSyntax
    {
        internal readonly SyntaxToken hashToken;
        internal readonly SyntaxToken referenceKeyword;
        internal readonly SyntaxToken file;
        internal readonly SyntaxToken endOfDirectiveToken;
        internal readonly bool isActive;

        internal ReferenceDirectiveTriviaSyntax(SyntaxKind kind, SyntaxToken hashToken, SyntaxToken referenceKeyword, SyntaxToken file, SyntaxToken endOfDirectiveToken, bool isActive, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
            this.SlotCount = 4;
            this.AdjustFlagsAndWidth(hashToken);
            this.hashToken = hashToken;
            this.AdjustFlagsAndWidth(referenceKeyword);
            this.referenceKeyword = referenceKeyword;
            this.AdjustFlagsAndWidth(file);
            this.file = file;
            this.AdjustFlagsAndWidth(endOfDirectiveToken);
            this.endOfDirectiveToken = endOfDirectiveToken;
            this.isActive = isActive;
        }

        internal ReferenceDirectiveTriviaSyntax(SyntaxKind kind, SyntaxToken hashToken, SyntaxToken referenceKeyword, SyntaxToken file, SyntaxToken endOfDirectiveToken, bool isActive, SyntaxFactoryContext context)
          : base(kind)
        {
            this.SetFactoryContext(context);
            this.SlotCount = 4;
            this.AdjustFlagsAndWidth(hashToken);
            this.hashToken = hashToken;
            this.AdjustFlagsAndWidth(referenceKeyword);
            this.referenceKeyword = referenceKeyword;
            this.AdjustFlagsAndWidth(file);
            this.file = file;
            this.AdjustFlagsAndWidth(endOfDirectiveToken);
            this.endOfDirectiveToken = endOfDirectiveToken;
            this.isActive = isActive;
        }

        internal ReferenceDirectiveTriviaSyntax(SyntaxKind kind, SyntaxToken hashToken, SyntaxToken referenceKeyword, SyntaxToken file, SyntaxToken endOfDirectiveToken, bool isActive)
          : base(kind)
        {
            this.SlotCount = 4;
            this.AdjustFlagsAndWidth(hashToken);
            this.hashToken = hashToken;
            this.AdjustFlagsAndWidth(referenceKeyword);
            this.referenceKeyword = referenceKeyword;
            this.AdjustFlagsAndWidth(file);
            this.file = file;
            this.AdjustFlagsAndWidth(endOfDirectiveToken);
            this.endOfDirectiveToken = endOfDirectiveToken;
            this.isActive = isActive;
        }

        public override SyntaxToken HashToken => this.hashToken;
        public SyntaxToken ReferenceKeyword => this.referenceKeyword;
        public SyntaxToken File => this.file;
        public override SyntaxToken EndOfDirectiveToken => this.endOfDirectiveToken;
        public override bool IsActive => this.isActive;

        internal override GreenNode? GetSlot(int index)
            => index switch
            {
                0 => this.hashToken,
                1 => this.referenceKeyword,
                2 => this.file,
                3 => this.endOfDirectiveToken,
                _ => null,
            };

        internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new CSharp.Syntax.ReferenceDirectiveTriviaSyntax(this, parent, position);

        public override void Accept(CSharpSyntaxVisitor visitor) => visitor.VisitReferenceDirectiveTrivia(this);
        public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor) => visitor.VisitReferenceDirectiveTrivia(this);

        public ReferenceDirectiveTriviaSyntax Update(SyntaxToken hashToken, SyntaxToken referenceKeyword, SyntaxToken file, SyntaxToken endOfDirectiveToken, bool isActive)
        {
            if (hashToken != this.HashToken || referenceKeyword != this.ReferenceKeyword || file != this.File || endOfDirectiveToken != this.EndOfDirectiveToken)
            {
                var newNode = SyntaxFactory.ReferenceDirectiveTrivia(hashToken, referenceKeyword, file, endOfDirectiveToken, isActive);
                var diags = GetDiagnostics();
                if (diags?.Length > 0)
                    newNode = newNode.WithDiagnosticsGreen(diags);
                var annotations = GetAnnotations();
                if (annotations?.Length > 0)
                    newNode = newNode.WithAnnotationsGreen(annotations);
                return newNode;
            }

            return this;
        }

        internal override GreenNode SetDiagnostics(DiagnosticInfo[]? diagnostics)
            => new ReferenceDirectiveTriviaSyntax(this.Kind, this.hashToken, this.referenceKeyword, this.file, this.endOfDirectiveToken, this.isActive, diagnostics, GetAnnotations());

        internal override GreenNode SetAnnotations(SyntaxAnnotation[]? annotations)
            => new ReferenceDirectiveTriviaSyntax(this.Kind, this.hashToken, this.referenceKeyword, this.file, this.endOfDirectiveToken, this.isActive, GetDiagnostics(), annotations);

        internal ReferenceDirectiveTriviaSyntax(ObjectReader reader)
          : base(reader)
        {
            this.SlotCount = 4;
            var hashToken = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(hashToken);
            this.hashToken = hashToken;
            var referenceKeyword = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(referenceKeyword);
            this.referenceKeyword = referenceKeyword;
            var file = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(file);
            this.file = file;
            var endOfDirectiveToken = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(endOfDirectiveToken);
            this.endOfDirectiveToken = endOfDirectiveToken;
            this.isActive = (bool)reader.ReadBoolean();
        }

        internal override void WriteTo(ObjectWriter writer)
        {
            base.WriteTo(writer);
            writer.WriteValue(this.hashToken);
            writer.WriteValue(this.referenceKeyword);
            writer.WriteValue(this.file);
            writer.WriteValue(this.endOfDirectiveToken);
            writer.WriteBoolean(this.isActive);
        }

        static ReferenceDirectiveTriviaSyntax()
        {
            ObjectBinder.RegisterTypeReader(typeof(ReferenceDirectiveTriviaSyntax), r => new ReferenceDirectiveTriviaSyntax(r));
        }
    }

    internal sealed partial class LoadDirectiveTriviaSyntax : DirectiveTriviaSyntax
    {
        internal readonly SyntaxToken hashToken;
        internal readonly SyntaxToken loadKeyword;
        internal readonly SyntaxToken file;
        internal readonly SyntaxToken endOfDirectiveToken;
        internal readonly bool isActive;

        internal LoadDirectiveTriviaSyntax(SyntaxKind kind, SyntaxToken hashToken, SyntaxToken loadKeyword, SyntaxToken file, SyntaxToken endOfDirectiveToken, bool isActive, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
            this.SlotCount = 4;
            this.AdjustFlagsAndWidth(hashToken);
            this.hashToken = hashToken;
            this.AdjustFlagsAndWidth(loadKeyword);
            this.loadKeyword = loadKeyword;
            this.AdjustFlagsAndWidth(file);
            this.file = file;
            this.AdjustFlagsAndWidth(endOfDirectiveToken);
            this.endOfDirectiveToken = endOfDirectiveToken;
            this.isActive = isActive;
        }

        internal LoadDirectiveTriviaSyntax(SyntaxKind kind, SyntaxToken hashToken, SyntaxToken loadKeyword, SyntaxToken file, SyntaxToken endOfDirectiveToken, bool isActive, SyntaxFactoryContext context)
          : base(kind)
        {
            this.SetFactoryContext(context);
            this.SlotCount = 4;
            this.AdjustFlagsAndWidth(hashToken);
            this.hashToken = hashToken;
            this.AdjustFlagsAndWidth(loadKeyword);
            this.loadKeyword = loadKeyword;
            this.AdjustFlagsAndWidth(file);
            this.file = file;
            this.AdjustFlagsAndWidth(endOfDirectiveToken);
            this.endOfDirectiveToken = endOfDirectiveToken;
            this.isActive = isActive;
        }

        internal LoadDirectiveTriviaSyntax(SyntaxKind kind, SyntaxToken hashToken, SyntaxToken loadKeyword, SyntaxToken file, SyntaxToken endOfDirectiveToken, bool isActive)
          : base(kind)
        {
            this.SlotCount = 4;
            this.AdjustFlagsAndWidth(hashToken);
            this.hashToken = hashToken;
            this.AdjustFlagsAndWidth(loadKeyword);
            this.loadKeyword = loadKeyword;
            this.AdjustFlagsAndWidth(file);
            this.file = file;
            this.AdjustFlagsAndWidth(endOfDirectiveToken);
            this.endOfDirectiveToken = endOfDirectiveToken;
            this.isActive = isActive;
        }

        public override SyntaxToken HashToken => this.hashToken;
        public SyntaxToken LoadKeyword => this.loadKeyword;
        public SyntaxToken File => this.file;
        public override SyntaxToken EndOfDirectiveToken => this.endOfDirectiveToken;
        public override bool IsActive => this.isActive;

        internal override GreenNode? GetSlot(int index)
            => index switch
            {
                0 => this.hashToken,
                1 => this.loadKeyword,
                2 => this.file,
                3 => this.endOfDirectiveToken,
                _ => null,
            };

        internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new CSharp.Syntax.LoadDirectiveTriviaSyntax(this, parent, position);

        public override void Accept(CSharpSyntaxVisitor visitor) => visitor.VisitLoadDirectiveTrivia(this);
        public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor) => visitor.VisitLoadDirectiveTrivia(this);

        public LoadDirectiveTriviaSyntax Update(SyntaxToken hashToken, SyntaxToken loadKeyword, SyntaxToken file, SyntaxToken endOfDirectiveToken, bool isActive)
        {
            if (hashToken != this.HashToken || loadKeyword != this.LoadKeyword || file != this.File || endOfDirectiveToken != this.EndOfDirectiveToken)
            {
                var newNode = SyntaxFactory.LoadDirectiveTrivia(hashToken, loadKeyword, file, endOfDirectiveToken, isActive);
                var diags = GetDiagnostics();
                if (diags?.Length > 0)
                    newNode = newNode.WithDiagnosticsGreen(diags);
                var annotations = GetAnnotations();
                if (annotations?.Length > 0)
                    newNode = newNode.WithAnnotationsGreen(annotations);
                return newNode;
            }

            return this;
        }

        internal override GreenNode SetDiagnostics(DiagnosticInfo[]? diagnostics)
            => new LoadDirectiveTriviaSyntax(this.Kind, this.hashToken, this.loadKeyword, this.file, this.endOfDirectiveToken, this.isActive, diagnostics, GetAnnotations());

        internal override GreenNode SetAnnotations(SyntaxAnnotation[]? annotations)
            => new LoadDirectiveTriviaSyntax(this.Kind, this.hashToken, this.loadKeyword, this.file, this.endOfDirectiveToken, this.isActive, GetDiagnostics(), annotations);

        internal LoadDirectiveTriviaSyntax(ObjectReader reader)
          : base(reader)
        {
            this.SlotCount = 4;
            var hashToken = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(hashToken);
            this.hashToken = hashToken;
            var loadKeyword = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(loadKeyword);
            this.loadKeyword = loadKeyword;
            var file = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(file);
            this.file = file;
            var endOfDirectiveToken = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(endOfDirectiveToken);
            this.endOfDirectiveToken = endOfDirectiveToken;
            this.isActive = (bool)reader.ReadBoolean();
        }

        internal override void WriteTo(ObjectWriter writer)
        {
            base.WriteTo(writer);
            writer.WriteValue(this.hashToken);
            writer.WriteValue(this.loadKeyword);
            writer.WriteValue(this.file);
            writer.WriteValue(this.endOfDirectiveToken);
            writer.WriteBoolean(this.isActive);
        }

        static LoadDirectiveTriviaSyntax()
        {
            ObjectBinder.RegisterTypeReader(typeof(LoadDirectiveTriviaSyntax), r => new LoadDirectiveTriviaSyntax(r));
        }
    }

    internal sealed partial class ShebangDirectiveTriviaSyntax : DirectiveTriviaSyntax
    {
        internal readonly SyntaxToken hashToken;
        internal readonly SyntaxToken exclamationToken;
        internal readonly SyntaxToken endOfDirectiveToken;
        internal readonly bool isActive;

        internal ShebangDirectiveTriviaSyntax(SyntaxKind kind, SyntaxToken hashToken, SyntaxToken exclamationToken, SyntaxToken endOfDirectiveToken, bool isActive, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
            this.SlotCount = 3;
            this.AdjustFlagsAndWidth(hashToken);
            this.hashToken = hashToken;
            this.AdjustFlagsAndWidth(exclamationToken);
            this.exclamationToken = exclamationToken;
            this.AdjustFlagsAndWidth(endOfDirectiveToken);
            this.endOfDirectiveToken = endOfDirectiveToken;
            this.isActive = isActive;
        }

        internal ShebangDirectiveTriviaSyntax(SyntaxKind kind, SyntaxToken hashToken, SyntaxToken exclamationToken, SyntaxToken endOfDirectiveToken, bool isActive, SyntaxFactoryContext context)
          : base(kind)
        {
            this.SetFactoryContext(context);
            this.SlotCount = 3;
            this.AdjustFlagsAndWidth(hashToken);
            this.hashToken = hashToken;
            this.AdjustFlagsAndWidth(exclamationToken);
            this.exclamationToken = exclamationToken;
            this.AdjustFlagsAndWidth(endOfDirectiveToken);
            this.endOfDirectiveToken = endOfDirectiveToken;
            this.isActive = isActive;
        }

        internal ShebangDirectiveTriviaSyntax(SyntaxKind kind, SyntaxToken hashToken, SyntaxToken exclamationToken, SyntaxToken endOfDirectiveToken, bool isActive)
          : base(kind)
        {
            this.SlotCount = 3;
            this.AdjustFlagsAndWidth(hashToken);
            this.hashToken = hashToken;
            this.AdjustFlagsAndWidth(exclamationToken);
            this.exclamationToken = exclamationToken;
            this.AdjustFlagsAndWidth(endOfDirectiveToken);
            this.endOfDirectiveToken = endOfDirectiveToken;
            this.isActive = isActive;
        }

        public override SyntaxToken HashToken => this.hashToken;
        public SyntaxToken ExclamationToken => this.exclamationToken;
        public override SyntaxToken EndOfDirectiveToken => this.endOfDirectiveToken;
        public override bool IsActive => this.isActive;

        internal override GreenNode? GetSlot(int index)
            => index switch
            {
                0 => this.hashToken,
                1 => this.exclamationToken,
                2 => this.endOfDirectiveToken,
                _ => null,
            };

        internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new CSharp.Syntax.ShebangDirectiveTriviaSyntax(this, parent, position);

        public override void Accept(CSharpSyntaxVisitor visitor) => visitor.VisitShebangDirectiveTrivia(this);
        public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor) => visitor.VisitShebangDirectiveTrivia(this);

        public ShebangDirectiveTriviaSyntax Update(SyntaxToken hashToken, SyntaxToken exclamationToken, SyntaxToken endOfDirectiveToken, bool isActive)
        {
            if (hashToken != this.HashToken || exclamationToken != this.ExclamationToken || endOfDirectiveToken != this.EndOfDirectiveToken)
            {
                var newNode = SyntaxFactory.ShebangDirectiveTrivia(hashToken, exclamationToken, endOfDirectiveToken, isActive);
                var diags = GetDiagnostics();
                if (diags?.Length > 0)
                    newNode = newNode.WithDiagnosticsGreen(diags);
                var annotations = GetAnnotations();
                if (annotations?.Length > 0)
                    newNode = newNode.WithAnnotationsGreen(annotations);
                return newNode;
            }

            return this;
        }

        internal override GreenNode SetDiagnostics(DiagnosticInfo[]? diagnostics)
            => new ShebangDirectiveTriviaSyntax(this.Kind, this.hashToken, this.exclamationToken, this.endOfDirectiveToken, this.isActive, diagnostics, GetAnnotations());

        internal override GreenNode SetAnnotations(SyntaxAnnotation[]? annotations)
            => new ShebangDirectiveTriviaSyntax(this.Kind, this.hashToken, this.exclamationToken, this.endOfDirectiveToken, this.isActive, GetDiagnostics(), annotations);

        internal ShebangDirectiveTriviaSyntax(ObjectReader reader)
          : base(reader)
        {
            this.SlotCount = 3;
            var hashToken = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(hashToken);
            this.hashToken = hashToken;
            var exclamationToken = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(exclamationToken);
            this.exclamationToken = exclamationToken;
            var endOfDirectiveToken = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(endOfDirectiveToken);
            this.endOfDirectiveToken = endOfDirectiveToken;
            this.isActive = (bool)reader.ReadBoolean();
        }

        internal override void WriteTo(ObjectWriter writer)
        {
            base.WriteTo(writer);
            writer.WriteValue(this.hashToken);
            writer.WriteValue(this.exclamationToken);
            writer.WriteValue(this.endOfDirectiveToken);
            writer.WriteBoolean(this.isActive);
        }

        static ShebangDirectiveTriviaSyntax()
        {
            ObjectBinder.RegisterTypeReader(typeof(ShebangDirectiveTriviaSyntax), r => new ShebangDirectiveTriviaSyntax(r));
        }
    }

    internal sealed partial class NullableDirectiveTriviaSyntax : DirectiveTriviaSyntax
    {
        internal readonly SyntaxToken hashToken;
        internal readonly SyntaxToken nullableKeyword;
        internal readonly SyntaxToken settingToken;
        internal readonly SyntaxToken? targetToken;
        internal readonly SyntaxToken endOfDirectiveToken;
        internal readonly bool isActive;

        internal NullableDirectiveTriviaSyntax(SyntaxKind kind, SyntaxToken hashToken, SyntaxToken nullableKeyword, SyntaxToken settingToken, SyntaxToken? targetToken, SyntaxToken endOfDirectiveToken, bool isActive, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)
          : base(kind, diagnostics, annotations)
        {
            this.SlotCount = 5;
            this.AdjustFlagsAndWidth(hashToken);
            this.hashToken = hashToken;
            this.AdjustFlagsAndWidth(nullableKeyword);
            this.nullableKeyword = nullableKeyword;
            this.AdjustFlagsAndWidth(settingToken);
            this.settingToken = settingToken;
            if (targetToken != null)
            {
                this.AdjustFlagsAndWidth(targetToken);
                this.targetToken = targetToken;
            }
            this.AdjustFlagsAndWidth(endOfDirectiveToken);
            this.endOfDirectiveToken = endOfDirectiveToken;
            this.isActive = isActive;
        }

        internal NullableDirectiveTriviaSyntax(SyntaxKind kind, SyntaxToken hashToken, SyntaxToken nullableKeyword, SyntaxToken settingToken, SyntaxToken? targetToken, SyntaxToken endOfDirectiveToken, bool isActive, SyntaxFactoryContext context)
          : base(kind)
        {
            this.SetFactoryContext(context);
            this.SlotCount = 5;
            this.AdjustFlagsAndWidth(hashToken);
            this.hashToken = hashToken;
            this.AdjustFlagsAndWidth(nullableKeyword);
            this.nullableKeyword = nullableKeyword;
            this.AdjustFlagsAndWidth(settingToken);
            this.settingToken = settingToken;
            if (targetToken != null)
            {
                this.AdjustFlagsAndWidth(targetToken);
                this.targetToken = targetToken;
            }
            this.AdjustFlagsAndWidth(endOfDirectiveToken);
            this.endOfDirectiveToken = endOfDirectiveToken;
            this.isActive = isActive;
        }

        internal NullableDirectiveTriviaSyntax(SyntaxKind kind, SyntaxToken hashToken, SyntaxToken nullableKeyword, SyntaxToken settingToken, SyntaxToken? targetToken, SyntaxToken endOfDirectiveToken, bool isActive)
          : base(kind)
        {
            this.SlotCount = 5;
            this.AdjustFlagsAndWidth(hashToken);
            this.hashToken = hashToken;
            this.AdjustFlagsAndWidth(nullableKeyword);
            this.nullableKeyword = nullableKeyword;
            this.AdjustFlagsAndWidth(settingToken);
            this.settingToken = settingToken;
            if (targetToken != null)
            {
                this.AdjustFlagsAndWidth(targetToken);
                this.targetToken = targetToken;
            }
            this.AdjustFlagsAndWidth(endOfDirectiveToken);
            this.endOfDirectiveToken = endOfDirectiveToken;
            this.isActive = isActive;
        }

        public override SyntaxToken HashToken => this.hashToken;
        public SyntaxToken NullableKeyword => this.nullableKeyword;
        public SyntaxToken SettingToken => this.settingToken;
        public SyntaxToken? TargetToken => this.targetToken;
        public override SyntaxToken EndOfDirectiveToken => this.endOfDirectiveToken;
        public override bool IsActive => this.isActive;

        internal override GreenNode? GetSlot(int index)
            => index switch
            {
                0 => this.hashToken,
                1 => this.nullableKeyword,
                2 => this.settingToken,
                3 => this.targetToken,
                4 => this.endOfDirectiveToken,
                _ => null,
            };

        internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new CSharp.Syntax.NullableDirectiveTriviaSyntax(this, parent, position);

        public override void Accept(CSharpSyntaxVisitor visitor) => visitor.VisitNullableDirectiveTrivia(this);
        public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor) => visitor.VisitNullableDirectiveTrivia(this);

        public NullableDirectiveTriviaSyntax Update(SyntaxToken hashToken, SyntaxToken nullableKeyword, SyntaxToken settingToken, SyntaxToken targetToken, SyntaxToken endOfDirectiveToken, bool isActive)
        {
            if (hashToken != this.HashToken || nullableKeyword != this.NullableKeyword || settingToken != this.SettingToken || targetToken != this.TargetToken || endOfDirectiveToken != this.EndOfDirectiveToken)
            {
                var newNode = SyntaxFactory.NullableDirectiveTrivia(hashToken, nullableKeyword, settingToken, targetToken, endOfDirectiveToken, isActive);
                var diags = GetDiagnostics();
                if (diags?.Length > 0)
                    newNode = newNode.WithDiagnosticsGreen(diags);
                var annotations = GetAnnotations();
                if (annotations?.Length > 0)
                    newNode = newNode.WithAnnotationsGreen(annotations);
                return newNode;
            }

            return this;
        }

        internal override GreenNode SetDiagnostics(DiagnosticInfo[]? diagnostics)
            => new NullableDirectiveTriviaSyntax(this.Kind, this.hashToken, this.nullableKeyword, this.settingToken, this.targetToken, this.endOfDirectiveToken, this.isActive, diagnostics, GetAnnotations());

        internal override GreenNode SetAnnotations(SyntaxAnnotation[]? annotations)
            => new NullableDirectiveTriviaSyntax(this.Kind, this.hashToken, this.nullableKeyword, this.settingToken, this.targetToken, this.endOfDirectiveToken, this.isActive, GetDiagnostics(), annotations);

        internal NullableDirectiveTriviaSyntax(ObjectReader reader)
          : base(reader)
        {
            this.SlotCount = 5;
            var hashToken = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(hashToken);
            this.hashToken = hashToken;
            var nullableKeyword = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(nullableKeyword);
            this.nullableKeyword = nullableKeyword;
            var settingToken = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(settingToken);
            this.settingToken = settingToken;
            var targetToken = (SyntaxToken?)reader.ReadValue();
            if (targetToken != null)
            {
                AdjustFlagsAndWidth(targetToken);
                this.targetToken = targetToken;
            }
            var endOfDirectiveToken = (SyntaxToken)reader.ReadValue();
            AdjustFlagsAndWidth(endOfDirectiveToken);
            this.endOfDirectiveToken = endOfDirectiveToken;
            this.isActive = (bool)reader.ReadBoolean();
        }

        internal override void WriteTo(ObjectWriter writer)
        {
            base.WriteTo(writer);
            writer.WriteValue(this.hashToken);
            writer.WriteValue(this.nullableKeyword);
            writer.WriteValue(this.settingToken);
            writer.WriteValue(this.targetToken);
            writer.WriteValue(this.endOfDirectiveToken);
            writer.WriteBoolean(this.isActive);
        }

        static NullableDirectiveTriviaSyntax()
        {
            ObjectBinder.RegisterTypeReader(typeof(NullableDirectiveTriviaSyntax), r => new NullableDirectiveTriviaSyntax(r));
        }
    }

    internal partial class CSharpSyntaxVisitor<TResult>
    {
        public virtual TResult VisitIdentifierName(IdentifierNameSyntax node) => this.DefaultVisit(node);
        public virtual TResult VisitQualifiedName(QualifiedNameSyntax node) => this.DefaultVisit(node);
        public virtual TResult VisitGenericName(GenericNameSyntax node) => this.DefaultVisit(node);
        public virtual TResult VisitTypeArgumentList(TypeArgumentListSyntax node) => this.DefaultVisit(node);
        public virtual TResult VisitAliasQualifiedName(AliasQualifiedNameSyntax node) => this.DefaultVisit(node);
        public virtual TResult VisitPredefinedType(PredefinedTypeSyntax node) => this.DefaultVisit(node);
        public virtual TResult VisitArrayType(ArrayTypeSyntax node) => this.DefaultVisit(node);
        public virtual TResult VisitArrayRankSpecifier(ArrayRankSpecifierSyntax node) => this.DefaultVisit(node);
        public virtual TResult VisitPointerType(PointerTypeSyntax node) => this.DefaultVisit(node);
        public virtual TResult VisitFunctionPointerType(FunctionPointerTypeSyntax node) => this.DefaultVisit(node);
        public virtual TResult VisitFunctionPointerParameterList(FunctionPointerParameterListSyntax node) => this.DefaultVisit(node);
        public virtual TResult VisitFunctionPointerCallingConvention(FunctionPointerCallingConventionSyntax node) => this.DefaultVisit(node);
        public virtual TResult VisitFunctionPointerUnmanagedCallingConventionList(FunctionPointerUnmanagedCallingConventionListSyntax node) => this.DefaultVisit(node);
        public virtual TResult VisitFunctionPointerUnmanagedCallingConvention(FunctionPointerUnmanagedCallingConventionSyntax node) => this.DefaultVisit(node);
        public virtual TResult VisitNullableType(NullableTypeSyntax node) => this.DefaultVisit(node);
        public virtual TResult VisitTupleType(TupleTypeSyntax node) => this.DefaultVisit(node);
        public virtual TResult VisitTupleElement(TupleElementSyntax node) => this.DefaultVisit(node);
        public virtual TResult VisitOmittedTypeArgument(OmittedTypeArgumentSyntax node) => this.DefaultVisit(node);
        public virtual TResult VisitRefType(RefTypeSyntax node) => this.DefaultVisit(node);
        public virtual TResult VisitParenthesizedExpression(ParenthesizedExpressionSyntax node) => this.DefaultVisit(node);
        public virtual TResult VisitTupleExpression(TupleExpressionSyntax node) => this.DefaultVisit(node);
        public virtual TResult VisitPrefixUnaryExpression(PrefixUnaryExpressionSyntax node) => this.DefaultVisit(node);
        public virtual TResult VisitAwaitExpression(AwaitExpressionSyntax node) => this.DefaultVisit(node);
        public virtual TResult VisitPostfixUnaryExpression(PostfixUnaryExpressionSyntax node) => this.DefaultVisit(node);
        public virtual TResult VisitMemberAccessExpression(MemberAccessExpressionSyntax node) => this.DefaultVisit(node);
        public virtual TResult VisitConditionalAccessExpression(ConditionalAccessExpressionSyntax node) => this.DefaultVisit(node);
        public virtual TResult VisitMemberBindingExpression(MemberBindingExpressionSyntax node) => this.DefaultVisit(node);
        public virtual TResult VisitElementBindingExpression(ElementBindingExpressionSyntax node) => this.DefaultVisit(node);
        public virtual TResult VisitRangeExpression(RangeExpressionSyntax node) => this.DefaultVisit(node);
        public virtual TResult VisitImplicitElementAccess(ImplicitElementAccessSyntax node) => this.DefaultVisit(node);
        public virtual TResult VisitBinaryExpression(BinaryExpressionSyntax node) => this.DefaultVisit(node);
        public virtual TResult VisitAssignmentExpression(AssignmentExpressionSyntax node) => this.DefaultVisit(node);
        public virtual TResult VisitConditionalExpression(ConditionalExpressionSyntax node) => this.DefaultVisit(node);
        public virtual TResult VisitThisExpression(ThisExpressionSyntax node) => this.DefaultVisit(node);
        public virtual TResult VisitBaseExpression(BaseExpressionSyntax node) => this.DefaultVisit(node);
        public virtual TResult VisitLiteralExpression(LiteralExpressionSyntax node) => this.DefaultVisit(node);
        public virtual TResult VisitMakeRefExpression(MakeRefExpressionSyntax node) => this.DefaultVisit(node);
        public virtual TResult VisitRefTypeExpression(RefTypeExpressionSyntax node) => this.DefaultVisit(node);
        public virtual TResult VisitRefValueExpression(RefValueExpressionSyntax node) => this.DefaultVisit(node);
        public virtual TResult VisitCheckedExpression(CheckedExpressionSyntax node) => this.DefaultVisit(node);
        public virtual TResult VisitDefaultExpression(DefaultExpressionSyntax node) => this.DefaultVisit(node);
        public virtual TResult VisitTypeOfExpression(TypeOfExpressionSyntax node) => this.DefaultVisit(node);
        public virtual TResult VisitSizeOfExpression(SizeOfExpressionSyntax node) => this.DefaultVisit(node);
        public virtual TResult VisitInvocationExpression(InvocationExpressionSyntax node) => this.DefaultVisit(node);
        public virtual TResult VisitElementAccessExpression(ElementAccessExpressionSyntax node) => this.DefaultVisit(node);
        public virtual TResult VisitArgumentList(ArgumentListSyntax node) => this.DefaultVisit(node);
        public virtual TResult VisitBracketedArgumentList(BracketedArgumentListSyntax node) => this.DefaultVisit(node);
        public virtual TResult VisitArgument(ArgumentSyntax node) => this.DefaultVisit(node);
        public virtual TResult VisitNameColon(NameColonSyntax node) => this.DefaultVisit(node);
        public virtual TResult VisitDeclarationExpression(DeclarationExpressionSyntax node) => this.DefaultVisit(node);
        public virtual TResult VisitCastExpression(CastExpressionSyntax node) => this.DefaultVisit(node);
        public virtual TResult VisitAnonymousMethodExpression(AnonymousMethodExpressionSyntax node) => this.DefaultVisit(node);
        public virtual TResult VisitSimpleLambdaExpression(SimpleLambdaExpressionSyntax node) => this.DefaultVisit(node);
        public virtual TResult VisitRefExpression(RefExpressionSyntax node) => this.DefaultVisit(node);
        public virtual TResult VisitParenthesizedLambdaExpression(ParenthesizedLambdaExpressionSyntax node) => this.DefaultVisit(node);
        public virtual TResult VisitInitializerExpression(InitializerExpressionSyntax node) => this.DefaultVisit(node);
        public virtual TResult VisitImplicitObjectCreationExpression(ImplicitObjectCreationExpressionSyntax node) => this.DefaultVisit(node);
        public virtual TResult VisitObjectCreationExpression(ObjectCreationExpressionSyntax node) => this.DefaultVisit(node);
        public virtual TResult VisitWithExpression(WithExpressionSyntax node) => this.DefaultVisit(node);
        public virtual TResult VisitAnonymousObjectMemberDeclarator(AnonymousObjectMemberDeclaratorSyntax node) => this.DefaultVisit(node);
        public virtual TResult VisitAnonymousObjectCreationExpression(AnonymousObjectCreationExpressionSyntax node) => this.DefaultVisit(node);
        public virtual TResult VisitArrayCreationExpression(ArrayCreationExpressionSyntax node) => this.DefaultVisit(node);
        public virtual TResult VisitImplicitArrayCreationExpression(ImplicitArrayCreationExpressionSyntax node) => this.DefaultVisit(node);
        public virtual TResult VisitStackAllocArrayCreationExpression(StackAllocArrayCreationExpressionSyntax node) => this.DefaultVisit(node);
        public virtual TResult VisitImplicitStackAllocArrayCreationExpression(ImplicitStackAllocArrayCreationExpressionSyntax node) => this.DefaultVisit(node);
        public virtual TResult VisitQueryExpression(QueryExpressionSyntax node) => this.DefaultVisit(node);
        public virtual TResult VisitQueryBody(QueryBodySyntax node) => this.DefaultVisit(node);
        public virtual TResult VisitFromClause(FromClauseSyntax node) => this.DefaultVisit(node);
        public virtual TResult VisitLetClause(LetClauseSyntax node) => this.DefaultVisit(node);
        public virtual TResult VisitJoinClause(JoinClauseSyntax node) => this.DefaultVisit(node);
        public virtual TResult VisitJoinIntoClause(JoinIntoClauseSyntax node) => this.DefaultVisit(node);
        public virtual TResult VisitWhereClause(WhereClauseSyntax node) => this.DefaultVisit(node);
        public virtual TResult VisitOrderByClause(OrderByClauseSyntax node) => this.DefaultVisit(node);
        public virtual TResult VisitOrdering(OrderingSyntax node) => this.DefaultVisit(node);
        public virtual TResult VisitSelectClause(SelectClauseSyntax node) => this.DefaultVisit(node);
        public virtual TResult VisitGroupClause(GroupClauseSyntax node) => this.DefaultVisit(node);
        public virtual TResult VisitQueryContinuation(QueryContinuationSyntax node) => this.DefaultVisit(node);
        public virtual TResult VisitOmittedArraySizeExpression(OmittedArraySizeExpressionSyntax node) => this.DefaultVisit(node);
        public virtual TResult VisitInterpolatedStringExpression(InterpolatedStringExpressionSyntax node) => this.DefaultVisit(node);
        public virtual TResult VisitIsPatternExpression(IsPatternExpressionSyntax node) => this.DefaultVisit(node);
        public virtual TResult VisitThrowExpression(ThrowExpressionSyntax node) => this.DefaultVisit(node);
        public virtual TResult VisitWhenClause(WhenClauseSyntax node) => this.DefaultVisit(node);
        public virtual TResult VisitDiscardPattern(DiscardPatternSyntax node) => this.DefaultVisit(node);
        public virtual TResult VisitDeclarationPattern(DeclarationPatternSyntax node) => this.DefaultVisit(node);
        public virtual TResult VisitVarPattern(VarPatternSyntax node) => this.DefaultVisit(node);
        public virtual TResult VisitRecursivePattern(RecursivePatternSyntax node) => this.DefaultVisit(node);
        public virtual TResult VisitPositionalPatternClause(PositionalPatternClauseSyntax node) => this.DefaultVisit(node);
        public virtual TResult VisitPropertyPatternClause(PropertyPatternClauseSyntax node) => this.DefaultVisit(node);
        public virtual TResult VisitSubpattern(SubpatternSyntax node) => this.DefaultVisit(node);
        public virtual TResult VisitConstantPattern(ConstantPatternSyntax node) => this.DefaultVisit(node);
        public virtual TResult VisitParenthesizedPattern(ParenthesizedPatternSyntax node) => this.DefaultVisit(node);
        public virtual TResult VisitRelationalPattern(RelationalPatternSyntax node) => this.DefaultVisit(node);
        public virtual TResult VisitTypePattern(TypePatternSyntax node) => this.DefaultVisit(node);
        public virtual TResult VisitBinaryPattern(BinaryPatternSyntax node) => this.DefaultVisit(node);
        public virtual TResult VisitUnaryPattern(UnaryPatternSyntax node) => this.DefaultVisit(node);
        public virtual TResult VisitInterpolatedStringText(InterpolatedStringTextSyntax node) => this.DefaultVisit(node);
        public virtual TResult VisitInterpolation(InterpolationSyntax node) => this.DefaultVisit(node);
        public virtual TResult VisitInterpolationAlignmentClause(InterpolationAlignmentClauseSyntax node) => this.DefaultVisit(node);
        public virtual TResult VisitInterpolationFormatClause(InterpolationFormatClauseSyntax node) => this.DefaultVisit(node);
        public virtual TResult VisitGlobalStatement(GlobalStatementSyntax node) => this.DefaultVisit(node);
        public virtual TResult VisitBlock(BlockSyntax node) => this.DefaultVisit(node);
        public virtual TResult VisitLocalFunctionStatement(LocalFunctionStatementSyntax node) => this.DefaultVisit(node);
        public virtual TResult VisitLocalDeclarationStatement(LocalDeclarationStatementSyntax node) => this.DefaultVisit(node);
        public virtual TResult VisitVariableDeclaration(VariableDeclarationSyntax node) => this.DefaultVisit(node);
        public virtual TResult VisitVariableDeclarator(VariableDeclaratorSyntax node) => this.DefaultVisit(node);
        public virtual TResult VisitEqualsValueClause(EqualsValueClauseSyntax node) => this.DefaultVisit(node);
        public virtual TResult VisitSingleVariableDesignation(SingleVariableDesignationSyntax node) => this.DefaultVisit(node);
        public virtual TResult VisitDiscardDesignation(DiscardDesignationSyntax node) => this.DefaultVisit(node);
        public virtual TResult VisitParenthesizedVariableDesignation(ParenthesizedVariableDesignationSyntax node) => this.DefaultVisit(node);
        public virtual TResult VisitExpressionStatement(ExpressionStatementSyntax node) => this.DefaultVisit(node);
        public virtual TResult VisitEmptyStatement(EmptyStatementSyntax node) => this.DefaultVisit(node);
        public virtual TResult VisitLabeledStatement(LabeledStatementSyntax node) => this.DefaultVisit(node);
        public virtual TResult VisitGotoStatement(GotoStatementSyntax node) => this.DefaultVisit(node);
        public virtual TResult VisitBreakStatement(BreakStatementSyntax node) => this.DefaultVisit(node);
        public virtual TResult VisitContinueStatement(ContinueStatementSyntax node) => this.DefaultVisit(node);
        public virtual TResult VisitReturnStatement(ReturnStatementSyntax node) => this.DefaultVisit(node);
        public virtual TResult VisitThrowStatement(ThrowStatementSyntax node) => this.DefaultVisit(node);
        public virtual TResult VisitYieldStatement(YieldStatementSyntax node) => this.DefaultVisit(node);
        public virtual TResult VisitWhileStatement(WhileStatementSyntax node) => this.DefaultVisit(node);
        public virtual TResult VisitDoStatement(DoStatementSyntax node) => this.DefaultVisit(node);
        public virtual TResult VisitForStatement(ForStatementSyntax node) => this.DefaultVisit(node);
        public virtual TResult VisitForEachStatement(ForEachStatementSyntax node) => this.DefaultVisit(node);
        public virtual TResult VisitForEachVariableStatement(ForEachVariableStatementSyntax node) => this.DefaultVisit(node);
        public virtual TResult VisitUsingStatement(UsingStatementSyntax node) => this.DefaultVisit(node);
        public virtual TResult VisitFixedStatement(FixedStatementSyntax node) => this.DefaultVisit(node);
        public virtual TResult VisitCheckedStatement(CheckedStatementSyntax node) => this.DefaultVisit(node);
        public virtual TResult VisitUnsafeStatement(UnsafeStatementSyntax node) => this.DefaultVisit(node);
        public virtual TResult VisitLockStatement(LockStatementSyntax node) => this.DefaultVisit(node);
        public virtual TResult VisitIfStatement(IfStatementSyntax node) => this.DefaultVisit(node);
        public virtual TResult VisitElseClause(ElseClauseSyntax node) => this.DefaultVisit(node);
        public virtual TResult VisitSwitchStatement(SwitchStatementSyntax node) => this.DefaultVisit(node);
        public virtual TResult VisitSwitchSection(SwitchSectionSyntax node) => this.DefaultVisit(node);
        public virtual TResult VisitCasePatternSwitchLabel(CasePatternSwitchLabelSyntax node) => this.DefaultVisit(node);
        public virtual TResult VisitCaseSwitchLabel(CaseSwitchLabelSyntax node) => this.DefaultVisit(node);
        public virtual TResult VisitDefaultSwitchLabel(DefaultSwitchLabelSyntax node) => this.DefaultVisit(node);
        public virtual TResult VisitSwitchExpression(SwitchExpressionSyntax node) => this.DefaultVisit(node);
        public virtual TResult VisitSwitchExpressionArm(SwitchExpressionArmSyntax node) => this.DefaultVisit(node);
        public virtual TResult VisitTryStatement(TryStatementSyntax node) => this.DefaultVisit(node);
        public virtual TResult VisitCatchClause(CatchClauseSyntax node) => this.DefaultVisit(node);
        public virtual TResult VisitCatchDeclaration(CatchDeclarationSyntax node) => this.DefaultVisit(node);
        public virtual TResult VisitCatchFilterClause(CatchFilterClauseSyntax node) => this.DefaultVisit(node);
        public virtual TResult VisitFinallyClause(FinallyClauseSyntax node) => this.DefaultVisit(node);
        public virtual TResult VisitCompilationUnit(CompilationUnitSyntax node) => this.DefaultVisit(node);
        public virtual TResult VisitExternAliasDirective(ExternAliasDirectiveSyntax node) => this.DefaultVisit(node);
        public virtual TResult VisitUsingDirective(UsingDirectiveSyntax node) => this.DefaultVisit(node);
        public virtual TResult VisitNamespaceDeclaration(NamespaceDeclarationSyntax node) => this.DefaultVisit(node);
        public virtual TResult VisitAttributeList(AttributeListSyntax node) => this.DefaultVisit(node);
        public virtual TResult VisitAttributeTargetSpecifier(AttributeTargetSpecifierSyntax node) => this.DefaultVisit(node);
        public virtual TResult VisitAttribute(AttributeSyntax node) => this.DefaultVisit(node);
        public virtual TResult VisitAttributeArgumentList(AttributeArgumentListSyntax node) => this.DefaultVisit(node);
        public virtual TResult VisitAttributeArgument(AttributeArgumentSyntax node) => this.DefaultVisit(node);
        public virtual TResult VisitNameEquals(NameEqualsSyntax node) => this.DefaultVisit(node);
        public virtual TResult VisitTypeParameterList(TypeParameterListSyntax node) => this.DefaultVisit(node);
        public virtual TResult VisitTypeParameter(TypeParameterSyntax node) => this.DefaultVisit(node);
        public virtual TResult VisitClassDeclaration(ClassDeclarationSyntax node) => this.DefaultVisit(node);
        public virtual TResult VisitStructDeclaration(StructDeclarationSyntax node) => this.DefaultVisit(node);
        public virtual TResult VisitInterfaceDeclaration(InterfaceDeclarationSyntax node) => this.DefaultVisit(node);
        public virtual TResult VisitRecordDeclaration(RecordDeclarationSyntax node) => this.DefaultVisit(node);
        public virtual TResult VisitEnumDeclaration(EnumDeclarationSyntax node) => this.DefaultVisit(node);
        public virtual TResult VisitDelegateDeclaration(DelegateDeclarationSyntax node) => this.DefaultVisit(node);
        public virtual TResult VisitEnumMemberDeclaration(EnumMemberDeclarationSyntax node) => this.DefaultVisit(node);
        public virtual TResult VisitBaseList(BaseListSyntax node) => this.DefaultVisit(node);
        public virtual TResult VisitSimpleBaseType(SimpleBaseTypeSyntax node) => this.DefaultVisit(node);
        public virtual TResult VisitPrimaryConstructorBaseType(PrimaryConstructorBaseTypeSyntax node) => this.DefaultVisit(node);
        public virtual TResult VisitTypeParameterConstraintClause(TypeParameterConstraintClauseSyntax node) => this.DefaultVisit(node);
        public virtual TResult VisitConstructorConstraint(ConstructorConstraintSyntax node) => this.DefaultVisit(node);
        public virtual TResult VisitClassOrStructConstraint(ClassOrStructConstraintSyntax node) => this.DefaultVisit(node);
        public virtual TResult VisitTypeConstraint(TypeConstraintSyntax node) => this.DefaultVisit(node);
        public virtual TResult VisitDefaultConstraint(DefaultConstraintSyntax node) => this.DefaultVisit(node);
        public virtual TResult VisitFieldDeclaration(FieldDeclarationSyntax node) => this.DefaultVisit(node);
        public virtual TResult VisitEventFieldDeclaration(EventFieldDeclarationSyntax node) => this.DefaultVisit(node);
        public virtual TResult VisitExplicitInterfaceSpecifier(ExplicitInterfaceSpecifierSyntax node) => this.DefaultVisit(node);
        public virtual TResult VisitMethodDeclaration(MethodDeclarationSyntax node) => this.DefaultVisit(node);
        public virtual TResult VisitOperatorDeclaration(OperatorDeclarationSyntax node) => this.DefaultVisit(node);
        public virtual TResult VisitConversionOperatorDeclaration(ConversionOperatorDeclarationSyntax node) => this.DefaultVisit(node);
        public virtual TResult VisitConstructorDeclaration(ConstructorDeclarationSyntax node) => this.DefaultVisit(node);
        public virtual TResult VisitConstructorInitializer(ConstructorInitializerSyntax node) => this.DefaultVisit(node);
        public virtual TResult VisitDestructorDeclaration(DestructorDeclarationSyntax node) => this.DefaultVisit(node);
        public virtual TResult VisitPropertyDeclaration(PropertyDeclarationSyntax node) => this.DefaultVisit(node);
        public virtual TResult VisitArrowExpressionClause(ArrowExpressionClauseSyntax node) => this.DefaultVisit(node);
        public virtual TResult VisitEventDeclaration(EventDeclarationSyntax node) => this.DefaultVisit(node);
        public virtual TResult VisitIndexerDeclaration(IndexerDeclarationSyntax node) => this.DefaultVisit(node);
        public virtual TResult VisitAccessorList(AccessorListSyntax node) => this.DefaultVisit(node);
        public virtual TResult VisitAccessorDeclaration(AccessorDeclarationSyntax node) => this.DefaultVisit(node);
        public virtual TResult VisitParameterList(ParameterListSyntax node) => this.DefaultVisit(node);
        public virtual TResult VisitBracketedParameterList(BracketedParameterListSyntax node) => this.DefaultVisit(node);
        public virtual TResult VisitParameter(ParameterSyntax node) => this.DefaultVisit(node);
        public virtual TResult VisitFunctionPointerParameter(FunctionPointerParameterSyntax node) => this.DefaultVisit(node);
        public virtual TResult VisitIncompleteMember(IncompleteMemberSyntax node) => this.DefaultVisit(node);
        public virtual TResult VisitSkippedTokensTrivia(SkippedTokensTriviaSyntax node) => this.DefaultVisit(node);
        public virtual TResult VisitDocumentationCommentTrivia(DocumentationCommentTriviaSyntax node) => this.DefaultVisit(node);
        public virtual TResult VisitTypeCref(TypeCrefSyntax node) => this.DefaultVisit(node);
        public virtual TResult VisitQualifiedCref(QualifiedCrefSyntax node) => this.DefaultVisit(node);
        public virtual TResult VisitNameMemberCref(NameMemberCrefSyntax node) => this.DefaultVisit(node);
        public virtual TResult VisitIndexerMemberCref(IndexerMemberCrefSyntax node) => this.DefaultVisit(node);
        public virtual TResult VisitOperatorMemberCref(OperatorMemberCrefSyntax node) => this.DefaultVisit(node);
        public virtual TResult VisitConversionOperatorMemberCref(ConversionOperatorMemberCrefSyntax node) => this.DefaultVisit(node);
        public virtual TResult VisitCrefParameterList(CrefParameterListSyntax node) => this.DefaultVisit(node);
        public virtual TResult VisitCrefBracketedParameterList(CrefBracketedParameterListSyntax node) => this.DefaultVisit(node);
        public virtual TResult VisitCrefParameter(CrefParameterSyntax node) => this.DefaultVisit(node);
        public virtual TResult VisitXmlElement(XmlElementSyntax node) => this.DefaultVisit(node);
        public virtual TResult VisitXmlElementStartTag(XmlElementStartTagSyntax node) => this.DefaultVisit(node);
        public virtual TResult VisitXmlElementEndTag(XmlElementEndTagSyntax node) => this.DefaultVisit(node);
        public virtual TResult VisitXmlEmptyElement(XmlEmptyElementSyntax node) => this.DefaultVisit(node);
        public virtual TResult VisitXmlName(XmlNameSyntax node) => this.DefaultVisit(node);
        public virtual TResult VisitXmlPrefix(XmlPrefixSyntax node) => this.DefaultVisit(node);
        public virtual TResult VisitXmlTextAttribute(XmlTextAttributeSyntax node) => this.DefaultVisit(node);
        public virtual TResult VisitXmlCrefAttribute(XmlCrefAttributeSyntax node) => this.DefaultVisit(node);
        public virtual TResult VisitXmlNameAttribute(XmlNameAttributeSyntax node) => this.DefaultVisit(node);
        public virtual TResult VisitXmlText(XmlTextSyntax node) => this.DefaultVisit(node);
        public virtual TResult VisitXmlCDataSection(XmlCDataSectionSyntax node) => this.DefaultVisit(node);
        public virtual TResult VisitXmlProcessingInstruction(XmlProcessingInstructionSyntax node) => this.DefaultVisit(node);
        public virtual TResult VisitXmlComment(XmlCommentSyntax node) => this.DefaultVisit(node);
        public virtual TResult VisitIfDirectiveTrivia(IfDirectiveTriviaSyntax node) => this.DefaultVisit(node);
        public virtual TResult VisitElifDirectiveTrivia(ElifDirectiveTriviaSyntax node) => this.DefaultVisit(node);
        public virtual TResult VisitElseDirectiveTrivia(ElseDirectiveTriviaSyntax node) => this.DefaultVisit(node);
        public virtual TResult VisitEndIfDirectiveTrivia(EndIfDirectiveTriviaSyntax node) => this.DefaultVisit(node);
        public virtual TResult VisitRegionDirectiveTrivia(RegionDirectiveTriviaSyntax node) => this.DefaultVisit(node);
        public virtual TResult VisitEndRegionDirectiveTrivia(EndRegionDirectiveTriviaSyntax node) => this.DefaultVisit(node);
        public virtual TResult VisitErrorDirectiveTrivia(ErrorDirectiveTriviaSyntax node) => this.DefaultVisit(node);
        public virtual TResult VisitWarningDirectiveTrivia(WarningDirectiveTriviaSyntax node) => this.DefaultVisit(node);
        public virtual TResult VisitBadDirectiveTrivia(BadDirectiveTriviaSyntax node) => this.DefaultVisit(node);
        public virtual TResult VisitDefineDirectiveTrivia(DefineDirectiveTriviaSyntax node) => this.DefaultVisit(node);
        public virtual TResult VisitUndefDirectiveTrivia(UndefDirectiveTriviaSyntax node) => this.DefaultVisit(node);
        public virtual TResult VisitLineDirectiveTrivia(LineDirectiveTriviaSyntax node) => this.DefaultVisit(node);
        public virtual TResult VisitPragmaWarningDirectiveTrivia(PragmaWarningDirectiveTriviaSyntax node) => this.DefaultVisit(node);
        public virtual TResult VisitPragmaChecksumDirectiveTrivia(PragmaChecksumDirectiveTriviaSyntax node) => this.DefaultVisit(node);
        public virtual TResult VisitReferenceDirectiveTrivia(ReferenceDirectiveTriviaSyntax node) => this.DefaultVisit(node);
        public virtual TResult VisitLoadDirectiveTrivia(LoadDirectiveTriviaSyntax node) => this.DefaultVisit(node);
        public virtual TResult VisitShebangDirectiveTrivia(ShebangDirectiveTriviaSyntax node) => this.DefaultVisit(node);
        public virtual TResult VisitNullableDirectiveTrivia(NullableDirectiveTriviaSyntax node) => this.DefaultVisit(node);
    }

    internal partial class CSharpSyntaxVisitor
    {
        public virtual void VisitIdentifierName(IdentifierNameSyntax node) => this.DefaultVisit(node);
        public virtual void VisitQualifiedName(QualifiedNameSyntax node) => this.DefaultVisit(node);
        public virtual void VisitGenericName(GenericNameSyntax node) => this.DefaultVisit(node);
        public virtual void VisitTypeArgumentList(TypeArgumentListSyntax node) => this.DefaultVisit(node);
        public virtual void VisitAliasQualifiedName(AliasQualifiedNameSyntax node) => this.DefaultVisit(node);
        public virtual void VisitPredefinedType(PredefinedTypeSyntax node) => this.DefaultVisit(node);
        public virtual void VisitArrayType(ArrayTypeSyntax node) => this.DefaultVisit(node);
        public virtual void VisitArrayRankSpecifier(ArrayRankSpecifierSyntax node) => this.DefaultVisit(node);
        public virtual void VisitPointerType(PointerTypeSyntax node) => this.DefaultVisit(node);
        public virtual void VisitFunctionPointerType(FunctionPointerTypeSyntax node) => this.DefaultVisit(node);
        public virtual void VisitFunctionPointerParameterList(FunctionPointerParameterListSyntax node) => this.DefaultVisit(node);
        public virtual void VisitFunctionPointerCallingConvention(FunctionPointerCallingConventionSyntax node) => this.DefaultVisit(node);
        public virtual void VisitFunctionPointerUnmanagedCallingConventionList(FunctionPointerUnmanagedCallingConventionListSyntax node) => this.DefaultVisit(node);
        public virtual void VisitFunctionPointerUnmanagedCallingConvention(FunctionPointerUnmanagedCallingConventionSyntax node) => this.DefaultVisit(node);
        public virtual void VisitNullableType(NullableTypeSyntax node) => this.DefaultVisit(node);
        public virtual void VisitTupleType(TupleTypeSyntax node) => this.DefaultVisit(node);
        public virtual void VisitTupleElement(TupleElementSyntax node) => this.DefaultVisit(node);
        public virtual void VisitOmittedTypeArgument(OmittedTypeArgumentSyntax node) => this.DefaultVisit(node);
        public virtual void VisitRefType(RefTypeSyntax node) => this.DefaultVisit(node);
        public virtual void VisitParenthesizedExpression(ParenthesizedExpressionSyntax node) => this.DefaultVisit(node);
        public virtual void VisitTupleExpression(TupleExpressionSyntax node) => this.DefaultVisit(node);
        public virtual void VisitPrefixUnaryExpression(PrefixUnaryExpressionSyntax node) => this.DefaultVisit(node);
        public virtual void VisitAwaitExpression(AwaitExpressionSyntax node) => this.DefaultVisit(node);
        public virtual void VisitPostfixUnaryExpression(PostfixUnaryExpressionSyntax node) => this.DefaultVisit(node);
        public virtual void VisitMemberAccessExpression(MemberAccessExpressionSyntax node) => this.DefaultVisit(node);
        public virtual void VisitConditionalAccessExpression(ConditionalAccessExpressionSyntax node) => this.DefaultVisit(node);
        public virtual void VisitMemberBindingExpression(MemberBindingExpressionSyntax node) => this.DefaultVisit(node);
        public virtual void VisitElementBindingExpression(ElementBindingExpressionSyntax node) => this.DefaultVisit(node);
        public virtual void VisitRangeExpression(RangeExpressionSyntax node) => this.DefaultVisit(node);
        public virtual void VisitImplicitElementAccess(ImplicitElementAccessSyntax node) => this.DefaultVisit(node);
        public virtual void VisitBinaryExpression(BinaryExpressionSyntax node) => this.DefaultVisit(node);
        public virtual void VisitAssignmentExpression(AssignmentExpressionSyntax node) => this.DefaultVisit(node);
        public virtual void VisitConditionalExpression(ConditionalExpressionSyntax node) => this.DefaultVisit(node);
        public virtual void VisitThisExpression(ThisExpressionSyntax node) => this.DefaultVisit(node);
        public virtual void VisitBaseExpression(BaseExpressionSyntax node) => this.DefaultVisit(node);
        public virtual void VisitLiteralExpression(LiteralExpressionSyntax node) => this.DefaultVisit(node);
        public virtual void VisitMakeRefExpression(MakeRefExpressionSyntax node) => this.DefaultVisit(node);
        public virtual void VisitRefTypeExpression(RefTypeExpressionSyntax node) => this.DefaultVisit(node);
        public virtual void VisitRefValueExpression(RefValueExpressionSyntax node) => this.DefaultVisit(node);
        public virtual void VisitCheckedExpression(CheckedExpressionSyntax node) => this.DefaultVisit(node);
        public virtual void VisitDefaultExpression(DefaultExpressionSyntax node) => this.DefaultVisit(node);
        public virtual void VisitTypeOfExpression(TypeOfExpressionSyntax node) => this.DefaultVisit(node);
        public virtual void VisitSizeOfExpression(SizeOfExpressionSyntax node) => this.DefaultVisit(node);
        public virtual void VisitInvocationExpression(InvocationExpressionSyntax node) => this.DefaultVisit(node);
        public virtual void VisitElementAccessExpression(ElementAccessExpressionSyntax node) => this.DefaultVisit(node);
        public virtual void VisitArgumentList(ArgumentListSyntax node) => this.DefaultVisit(node);
        public virtual void VisitBracketedArgumentList(BracketedArgumentListSyntax node) => this.DefaultVisit(node);
        public virtual void VisitArgument(ArgumentSyntax node) => this.DefaultVisit(node);
        public virtual void VisitNameColon(NameColonSyntax node) => this.DefaultVisit(node);
        public virtual void VisitDeclarationExpression(DeclarationExpressionSyntax node) => this.DefaultVisit(node);
        public virtual void VisitCastExpression(CastExpressionSyntax node) => this.DefaultVisit(node);
        public virtual void VisitAnonymousMethodExpression(AnonymousMethodExpressionSyntax node) => this.DefaultVisit(node);
        public virtual void VisitSimpleLambdaExpression(SimpleLambdaExpressionSyntax node) => this.DefaultVisit(node);
        public virtual void VisitRefExpression(RefExpressionSyntax node) => this.DefaultVisit(node);
        public virtual void VisitParenthesizedLambdaExpression(ParenthesizedLambdaExpressionSyntax node) => this.DefaultVisit(node);
        public virtual void VisitInitializerExpression(InitializerExpressionSyntax node) => this.DefaultVisit(node);
        public virtual void VisitImplicitObjectCreationExpression(ImplicitObjectCreationExpressionSyntax node) => this.DefaultVisit(node);
        public virtual void VisitObjectCreationExpression(ObjectCreationExpressionSyntax node) => this.DefaultVisit(node);
        public virtual void VisitWithExpression(WithExpressionSyntax node) => this.DefaultVisit(node);
        public virtual void VisitAnonymousObjectMemberDeclarator(AnonymousObjectMemberDeclaratorSyntax node) => this.DefaultVisit(node);
        public virtual void VisitAnonymousObjectCreationExpression(AnonymousObjectCreationExpressionSyntax node) => this.DefaultVisit(node);
        public virtual void VisitArrayCreationExpression(ArrayCreationExpressionSyntax node) => this.DefaultVisit(node);
        public virtual void VisitImplicitArrayCreationExpression(ImplicitArrayCreationExpressionSyntax node) => this.DefaultVisit(node);
        public virtual void VisitStackAllocArrayCreationExpression(StackAllocArrayCreationExpressionSyntax node) => this.DefaultVisit(node);
        public virtual void VisitImplicitStackAllocArrayCreationExpression(ImplicitStackAllocArrayCreationExpressionSyntax node) => this.DefaultVisit(node);
        public virtual void VisitQueryExpression(QueryExpressionSyntax node) => this.DefaultVisit(node);
        public virtual void VisitQueryBody(QueryBodySyntax node) => this.DefaultVisit(node);
        public virtual void VisitFromClause(FromClauseSyntax node) => this.DefaultVisit(node);
        public virtual void VisitLetClause(LetClauseSyntax node) => this.DefaultVisit(node);
        public virtual void VisitJoinClause(JoinClauseSyntax node) => this.DefaultVisit(node);
        public virtual void VisitJoinIntoClause(JoinIntoClauseSyntax node) => this.DefaultVisit(node);
        public virtual void VisitWhereClause(WhereClauseSyntax node) => this.DefaultVisit(node);
        public virtual void VisitOrderByClause(OrderByClauseSyntax node) => this.DefaultVisit(node);
        public virtual void VisitOrdering(OrderingSyntax node) => this.DefaultVisit(node);
        public virtual void VisitSelectClause(SelectClauseSyntax node) => this.DefaultVisit(node);
        public virtual void VisitGroupClause(GroupClauseSyntax node) => this.DefaultVisit(node);
        public virtual void VisitQueryContinuation(QueryContinuationSyntax node) => this.DefaultVisit(node);
        public virtual void VisitOmittedArraySizeExpression(OmittedArraySizeExpressionSyntax node) => this.DefaultVisit(node);
        public virtual void VisitInterpolatedStringExpression(InterpolatedStringExpressionSyntax node) => this.DefaultVisit(node);
        public virtual void VisitIsPatternExpression(IsPatternExpressionSyntax node) => this.DefaultVisit(node);
        public virtual void VisitThrowExpression(ThrowExpressionSyntax node) => this.DefaultVisit(node);
        public virtual void VisitWhenClause(WhenClauseSyntax node) => this.DefaultVisit(node);
        public virtual void VisitDiscardPattern(DiscardPatternSyntax node) => this.DefaultVisit(node);
        public virtual void VisitDeclarationPattern(DeclarationPatternSyntax node) => this.DefaultVisit(node);
        public virtual void VisitVarPattern(VarPatternSyntax node) => this.DefaultVisit(node);
        public virtual void VisitRecursivePattern(RecursivePatternSyntax node) => this.DefaultVisit(node);
        public virtual void VisitPositionalPatternClause(PositionalPatternClauseSyntax node) => this.DefaultVisit(node);
        public virtual void VisitPropertyPatternClause(PropertyPatternClauseSyntax node) => this.DefaultVisit(node);
        public virtual void VisitSubpattern(SubpatternSyntax node) => this.DefaultVisit(node);
        public virtual void VisitConstantPattern(ConstantPatternSyntax node) => this.DefaultVisit(node);
        public virtual void VisitParenthesizedPattern(ParenthesizedPatternSyntax node) => this.DefaultVisit(node);
        public virtual void VisitRelationalPattern(RelationalPatternSyntax node) => this.DefaultVisit(node);
        public virtual void VisitTypePattern(TypePatternSyntax node) => this.DefaultVisit(node);
        public virtual void VisitBinaryPattern(BinaryPatternSyntax node) => this.DefaultVisit(node);
        public virtual void VisitUnaryPattern(UnaryPatternSyntax node) => this.DefaultVisit(node);
        public virtual void VisitInterpolatedStringText(InterpolatedStringTextSyntax node) => this.DefaultVisit(node);
        public virtual void VisitInterpolation(InterpolationSyntax node) => this.DefaultVisit(node);
        public virtual void VisitInterpolationAlignmentClause(InterpolationAlignmentClauseSyntax node) => this.DefaultVisit(node);
        public virtual void VisitInterpolationFormatClause(InterpolationFormatClauseSyntax node) => this.DefaultVisit(node);
        public virtual void VisitGlobalStatement(GlobalStatementSyntax node) => this.DefaultVisit(node);
        public virtual void VisitBlock(BlockSyntax node) => this.DefaultVisit(node);
        public virtual void VisitLocalFunctionStatement(LocalFunctionStatementSyntax node) => this.DefaultVisit(node);
        public virtual void VisitLocalDeclarationStatement(LocalDeclarationStatementSyntax node) => this.DefaultVisit(node);
        public virtual void VisitVariableDeclaration(VariableDeclarationSyntax node) => this.DefaultVisit(node);
        public virtual void VisitVariableDeclarator(VariableDeclaratorSyntax node) => this.DefaultVisit(node);
        public virtual void VisitEqualsValueClause(EqualsValueClauseSyntax node) => this.DefaultVisit(node);
        public virtual void VisitSingleVariableDesignation(SingleVariableDesignationSyntax node) => this.DefaultVisit(node);
        public virtual void VisitDiscardDesignation(DiscardDesignationSyntax node) => this.DefaultVisit(node);
        public virtual void VisitParenthesizedVariableDesignation(ParenthesizedVariableDesignationSyntax node) => this.DefaultVisit(node);
        public virtual void VisitExpressionStatement(ExpressionStatementSyntax node) => this.DefaultVisit(node);
        public virtual void VisitEmptyStatement(EmptyStatementSyntax node) => this.DefaultVisit(node);
        public virtual void VisitLabeledStatement(LabeledStatementSyntax node) => this.DefaultVisit(node);
        public virtual void VisitGotoStatement(GotoStatementSyntax node) => this.DefaultVisit(node);
        public virtual void VisitBreakStatement(BreakStatementSyntax node) => this.DefaultVisit(node);
        public virtual void VisitContinueStatement(ContinueStatementSyntax node) => this.DefaultVisit(node);
        public virtual void VisitReturnStatement(ReturnStatementSyntax node) => this.DefaultVisit(node);
        public virtual void VisitThrowStatement(ThrowStatementSyntax node) => this.DefaultVisit(node);
        public virtual void VisitYieldStatement(YieldStatementSyntax node) => this.DefaultVisit(node);
        public virtual void VisitWhileStatement(WhileStatementSyntax node) => this.DefaultVisit(node);
        public virtual void VisitDoStatement(DoStatementSyntax node) => this.DefaultVisit(node);
        public virtual void VisitForStatement(ForStatementSyntax node) => this.DefaultVisit(node);
        public virtual void VisitForEachStatement(ForEachStatementSyntax node) => this.DefaultVisit(node);
        public virtual void VisitForEachVariableStatement(ForEachVariableStatementSyntax node) => this.DefaultVisit(node);
        public virtual void VisitUsingStatement(UsingStatementSyntax node) => this.DefaultVisit(node);
        public virtual void VisitFixedStatement(FixedStatementSyntax node) => this.DefaultVisit(node);
        public virtual void VisitCheckedStatement(CheckedStatementSyntax node) => this.DefaultVisit(node);
        public virtual void VisitUnsafeStatement(UnsafeStatementSyntax node) => this.DefaultVisit(node);
        public virtual void VisitLockStatement(LockStatementSyntax node) => this.DefaultVisit(node);
        public virtual void VisitIfStatement(IfStatementSyntax node) => this.DefaultVisit(node);
        public virtual void VisitElseClause(ElseClauseSyntax node) => this.DefaultVisit(node);
        public virtual void VisitSwitchStatement(SwitchStatementSyntax node) => this.DefaultVisit(node);
        public virtual void VisitSwitchSection(SwitchSectionSyntax node) => this.DefaultVisit(node);
        public virtual void VisitCasePatternSwitchLabel(CasePatternSwitchLabelSyntax node) => this.DefaultVisit(node);
        public virtual void VisitCaseSwitchLabel(CaseSwitchLabelSyntax node) => this.DefaultVisit(node);
        public virtual void VisitDefaultSwitchLabel(DefaultSwitchLabelSyntax node) => this.DefaultVisit(node);
        public virtual void VisitSwitchExpression(SwitchExpressionSyntax node) => this.DefaultVisit(node);
        public virtual void VisitSwitchExpressionArm(SwitchExpressionArmSyntax node) => this.DefaultVisit(node);
        public virtual void VisitTryStatement(TryStatementSyntax node) => this.DefaultVisit(node);
        public virtual void VisitCatchClause(CatchClauseSyntax node) => this.DefaultVisit(node);
        public virtual void VisitCatchDeclaration(CatchDeclarationSyntax node) => this.DefaultVisit(node);
        public virtual void VisitCatchFilterClause(CatchFilterClauseSyntax node) => this.DefaultVisit(node);
        public virtual void VisitFinallyClause(FinallyClauseSyntax node) => this.DefaultVisit(node);
        public virtual void VisitCompilationUnit(CompilationUnitSyntax node) => this.DefaultVisit(node);
        public virtual void VisitExternAliasDirective(ExternAliasDirectiveSyntax node) => this.DefaultVisit(node);
        public virtual void VisitUsingDirective(UsingDirectiveSyntax node) => this.DefaultVisit(node);
        public virtual void VisitNamespaceDeclaration(NamespaceDeclarationSyntax node) => this.DefaultVisit(node);
        public virtual void VisitAttributeList(AttributeListSyntax node) => this.DefaultVisit(node);
        public virtual void VisitAttributeTargetSpecifier(AttributeTargetSpecifierSyntax node) => this.DefaultVisit(node);
        public virtual void VisitAttribute(AttributeSyntax node) => this.DefaultVisit(node);
        public virtual void VisitAttributeArgumentList(AttributeArgumentListSyntax node) => this.DefaultVisit(node);
        public virtual void VisitAttributeArgument(AttributeArgumentSyntax node) => this.DefaultVisit(node);
        public virtual void VisitNameEquals(NameEqualsSyntax node) => this.DefaultVisit(node);
        public virtual void VisitTypeParameterList(TypeParameterListSyntax node) => this.DefaultVisit(node);
        public virtual void VisitTypeParameter(TypeParameterSyntax node) => this.DefaultVisit(node);
        public virtual void VisitClassDeclaration(ClassDeclarationSyntax node) => this.DefaultVisit(node);
        public virtual void VisitStructDeclaration(StructDeclarationSyntax node) => this.DefaultVisit(node);
        public virtual void VisitInterfaceDeclaration(InterfaceDeclarationSyntax node) => this.DefaultVisit(node);
        public virtual void VisitRecordDeclaration(RecordDeclarationSyntax node) => this.DefaultVisit(node);
        public virtual void VisitEnumDeclaration(EnumDeclarationSyntax node) => this.DefaultVisit(node);
        public virtual void VisitDelegateDeclaration(DelegateDeclarationSyntax node) => this.DefaultVisit(node);
        public virtual void VisitEnumMemberDeclaration(EnumMemberDeclarationSyntax node) => this.DefaultVisit(node);
        public virtual void VisitBaseList(BaseListSyntax node) => this.DefaultVisit(node);
        public virtual void VisitSimpleBaseType(SimpleBaseTypeSyntax node) => this.DefaultVisit(node);
        public virtual void VisitPrimaryConstructorBaseType(PrimaryConstructorBaseTypeSyntax node) => this.DefaultVisit(node);
        public virtual void VisitTypeParameterConstraintClause(TypeParameterConstraintClauseSyntax node) => this.DefaultVisit(node);
        public virtual void VisitConstructorConstraint(ConstructorConstraintSyntax node) => this.DefaultVisit(node);
        public virtual void VisitClassOrStructConstraint(ClassOrStructConstraintSyntax node) => this.DefaultVisit(node);
        public virtual void VisitTypeConstraint(TypeConstraintSyntax node) => this.DefaultVisit(node);
        public virtual void VisitDefaultConstraint(DefaultConstraintSyntax node) => this.DefaultVisit(node);
        public virtual void VisitFieldDeclaration(FieldDeclarationSyntax node) => this.DefaultVisit(node);
        public virtual void VisitEventFieldDeclaration(EventFieldDeclarationSyntax node) => this.DefaultVisit(node);
        public virtual void VisitExplicitInterfaceSpecifier(ExplicitInterfaceSpecifierSyntax node) => this.DefaultVisit(node);
        public virtual void VisitMethodDeclaration(MethodDeclarationSyntax node) => this.DefaultVisit(node);
        public virtual void VisitOperatorDeclaration(OperatorDeclarationSyntax node) => this.DefaultVisit(node);
        public virtual void VisitConversionOperatorDeclaration(ConversionOperatorDeclarationSyntax node) => this.DefaultVisit(node);
        public virtual void VisitConstructorDeclaration(ConstructorDeclarationSyntax node) => this.DefaultVisit(node);
        public virtual void VisitConstructorInitializer(ConstructorInitializerSyntax node) => this.DefaultVisit(node);
        public virtual void VisitDestructorDeclaration(DestructorDeclarationSyntax node) => this.DefaultVisit(node);
        public virtual void VisitPropertyDeclaration(PropertyDeclarationSyntax node) => this.DefaultVisit(node);
        public virtual void VisitArrowExpressionClause(ArrowExpressionClauseSyntax node) => this.DefaultVisit(node);
        public virtual void VisitEventDeclaration(EventDeclarationSyntax node) => this.DefaultVisit(node);
        public virtual void VisitIndexerDeclaration(IndexerDeclarationSyntax node) => this.DefaultVisit(node);
        public virtual void VisitAccessorList(AccessorListSyntax node) => this.DefaultVisit(node);
        public virtual void VisitAccessorDeclaration(AccessorDeclarationSyntax node) => this.DefaultVisit(node);
        public virtual void VisitParameterList(ParameterListSyntax node) => this.DefaultVisit(node);
        public virtual void VisitBracketedParameterList(BracketedParameterListSyntax node) => this.DefaultVisit(node);
        public virtual void VisitParameter(ParameterSyntax node) => this.DefaultVisit(node);
        public virtual void VisitFunctionPointerParameter(FunctionPointerParameterSyntax node) => this.DefaultVisit(node);
        public virtual void VisitIncompleteMember(IncompleteMemberSyntax node) => this.DefaultVisit(node);
        public virtual void VisitSkippedTokensTrivia(SkippedTokensTriviaSyntax node) => this.DefaultVisit(node);
        public virtual void VisitDocumentationCommentTrivia(DocumentationCommentTriviaSyntax node) => this.DefaultVisit(node);
        public virtual void VisitTypeCref(TypeCrefSyntax node) => this.DefaultVisit(node);
        public virtual void VisitQualifiedCref(QualifiedCrefSyntax node) => this.DefaultVisit(node);
        public virtual void VisitNameMemberCref(NameMemberCrefSyntax node) => this.DefaultVisit(node);
        public virtual void VisitIndexerMemberCref(IndexerMemberCrefSyntax node) => this.DefaultVisit(node);
        public virtual void VisitOperatorMemberCref(OperatorMemberCrefSyntax node) => this.DefaultVisit(node);
        public virtual void VisitConversionOperatorMemberCref(ConversionOperatorMemberCrefSyntax node) => this.DefaultVisit(node);
        public virtual void VisitCrefParameterList(CrefParameterListSyntax node) => this.DefaultVisit(node);
        public virtual void VisitCrefBracketedParameterList(CrefBracketedParameterListSyntax node) => this.DefaultVisit(node);
        public virtual void VisitCrefParameter(CrefParameterSyntax node) => this.DefaultVisit(node);
        public virtual void VisitXmlElement(XmlElementSyntax node) => this.DefaultVisit(node);
        public virtual void VisitXmlElementStartTag(XmlElementStartTagSyntax node) => this.DefaultVisit(node);
        public virtual void VisitXmlElementEndTag(XmlElementEndTagSyntax node) => this.DefaultVisit(node);
        public virtual void VisitXmlEmptyElement(XmlEmptyElementSyntax node) => this.DefaultVisit(node);
        public virtual void VisitXmlName(XmlNameSyntax node) => this.DefaultVisit(node);
        public virtual void VisitXmlPrefix(XmlPrefixSyntax node) => this.DefaultVisit(node);
        public virtual void VisitXmlTextAttribute(XmlTextAttributeSyntax node) => this.DefaultVisit(node);
        public virtual void VisitXmlCrefAttribute(XmlCrefAttributeSyntax node) => this.DefaultVisit(node);
        public virtual void VisitXmlNameAttribute(XmlNameAttributeSyntax node) => this.DefaultVisit(node);
        public virtual void VisitXmlText(XmlTextSyntax node) => this.DefaultVisit(node);
        public virtual void VisitXmlCDataSection(XmlCDataSectionSyntax node) => this.DefaultVisit(node);
        public virtual void VisitXmlProcessingInstruction(XmlProcessingInstructionSyntax node) => this.DefaultVisit(node);
        public virtual void VisitXmlComment(XmlCommentSyntax node) => this.DefaultVisit(node);
        public virtual void VisitIfDirectiveTrivia(IfDirectiveTriviaSyntax node) => this.DefaultVisit(node);
        public virtual void VisitElifDirectiveTrivia(ElifDirectiveTriviaSyntax node) => this.DefaultVisit(node);
        public virtual void VisitElseDirectiveTrivia(ElseDirectiveTriviaSyntax node) => this.DefaultVisit(node);
        public virtual void VisitEndIfDirectiveTrivia(EndIfDirectiveTriviaSyntax node) => this.DefaultVisit(node);
        public virtual void VisitRegionDirectiveTrivia(RegionDirectiveTriviaSyntax node) => this.DefaultVisit(node);
        public virtual void VisitEndRegionDirectiveTrivia(EndRegionDirectiveTriviaSyntax node) => this.DefaultVisit(node);
        public virtual void VisitErrorDirectiveTrivia(ErrorDirectiveTriviaSyntax node) => this.DefaultVisit(node);
        public virtual void VisitWarningDirectiveTrivia(WarningDirectiveTriviaSyntax node) => this.DefaultVisit(node);
        public virtual void VisitBadDirectiveTrivia(BadDirectiveTriviaSyntax node) => this.DefaultVisit(node);
        public virtual void VisitDefineDirectiveTrivia(DefineDirectiveTriviaSyntax node) => this.DefaultVisit(node);
        public virtual void VisitUndefDirectiveTrivia(UndefDirectiveTriviaSyntax node) => this.DefaultVisit(node);
        public virtual void VisitLineDirectiveTrivia(LineDirectiveTriviaSyntax node) => this.DefaultVisit(node);
        public virtual void VisitPragmaWarningDirectiveTrivia(PragmaWarningDirectiveTriviaSyntax node) => this.DefaultVisit(node);
        public virtual void VisitPragmaChecksumDirectiveTrivia(PragmaChecksumDirectiveTriviaSyntax node) => this.DefaultVisit(node);
        public virtual void VisitReferenceDirectiveTrivia(ReferenceDirectiveTriviaSyntax node) => this.DefaultVisit(node);
        public virtual void VisitLoadDirectiveTrivia(LoadDirectiveTriviaSyntax node) => this.DefaultVisit(node);
        public virtual void VisitShebangDirectiveTrivia(ShebangDirectiveTriviaSyntax node) => this.DefaultVisit(node);
        public virtual void VisitNullableDirectiveTrivia(NullableDirectiveTriviaSyntax node) => this.DefaultVisit(node);
    }

    internal partial class CSharpSyntaxRewriter : CSharpSyntaxVisitor<CSharpSyntaxNode>
    {
        public override CSharpSyntaxNode VisitIdentifierName(IdentifierNameSyntax node)
            => node.Update((SyntaxToken)Visit(node.Identifier));

        public override CSharpSyntaxNode VisitQualifiedName(QualifiedNameSyntax node)
            => node.Update((NameSyntax)Visit(node.Left), (SyntaxToken)Visit(node.DotToken), (SimpleNameSyntax)Visit(node.Right));

        public override CSharpSyntaxNode VisitGenericName(GenericNameSyntax node)
            => node.Update((SyntaxToken)Visit(node.Identifier), (TypeArgumentListSyntax)Visit(node.TypeArgumentList));

        public override CSharpSyntaxNode VisitTypeArgumentList(TypeArgumentListSyntax node)
            => node.Update((SyntaxToken)Visit(node.LessThanToken), VisitList(node.Arguments), (SyntaxToken)Visit(node.GreaterThanToken));

        public override CSharpSyntaxNode VisitAliasQualifiedName(AliasQualifiedNameSyntax node)
            => node.Update((IdentifierNameSyntax)Visit(node.Alias), (SyntaxToken)Visit(node.ColonColonToken), (SimpleNameSyntax)Visit(node.Name));

        public override CSharpSyntaxNode VisitPredefinedType(PredefinedTypeSyntax node)
            => node.Update((SyntaxToken)Visit(node.Keyword));

        public override CSharpSyntaxNode VisitArrayType(ArrayTypeSyntax node)
            => node.Update((TypeSyntax)Visit(node.ElementType), VisitList(node.RankSpecifiers));

        public override CSharpSyntaxNode VisitArrayRankSpecifier(ArrayRankSpecifierSyntax node)
            => node.Update((SyntaxToken)Visit(node.OpenBracketToken), VisitList(node.Sizes), (SyntaxToken)Visit(node.CloseBracketToken));

        public override CSharpSyntaxNode VisitPointerType(PointerTypeSyntax node)
            => node.Update((TypeSyntax)Visit(node.ElementType), (SyntaxToken)Visit(node.AsteriskToken));

        public override CSharpSyntaxNode VisitFunctionPointerType(FunctionPointerTypeSyntax node)
            => node.Update((SyntaxToken)Visit(node.DelegateKeyword), (SyntaxToken)Visit(node.AsteriskToken), (FunctionPointerCallingConventionSyntax)Visit(node.CallingConvention), (FunctionPointerParameterListSyntax)Visit(node.ParameterList));

        public override CSharpSyntaxNode VisitFunctionPointerParameterList(FunctionPointerParameterListSyntax node)
            => node.Update((SyntaxToken)Visit(node.LessThanToken), VisitList(node.Parameters), (SyntaxToken)Visit(node.GreaterThanToken));

        public override CSharpSyntaxNode VisitFunctionPointerCallingConvention(FunctionPointerCallingConventionSyntax node)
            => node.Update((SyntaxToken)Visit(node.ManagedOrUnmanagedKeyword), (FunctionPointerUnmanagedCallingConventionListSyntax)Visit(node.UnmanagedCallingConventionList));

        public override CSharpSyntaxNode VisitFunctionPointerUnmanagedCallingConventionList(FunctionPointerUnmanagedCallingConventionListSyntax node)
            => node.Update((SyntaxToken)Visit(node.OpenBracketToken), VisitList(node.CallingConventions), (SyntaxToken)Visit(node.CloseBracketToken));

        public override CSharpSyntaxNode VisitFunctionPointerUnmanagedCallingConvention(FunctionPointerUnmanagedCallingConventionSyntax node)
            => node.Update((SyntaxToken)Visit(node.Name));

        public override CSharpSyntaxNode VisitNullableType(NullableTypeSyntax node)
            => node.Update((TypeSyntax)Visit(node.ElementType), (SyntaxToken)Visit(node.QuestionToken));

        public override CSharpSyntaxNode VisitTupleType(TupleTypeSyntax node)
            => node.Update((SyntaxToken)Visit(node.OpenParenToken), VisitList(node.Elements), (SyntaxToken)Visit(node.CloseParenToken));

        public override CSharpSyntaxNode VisitTupleElement(TupleElementSyntax node)
            => node.Update((TypeSyntax)Visit(node.Type), (SyntaxToken)Visit(node.Identifier));

        public override CSharpSyntaxNode VisitOmittedTypeArgument(OmittedTypeArgumentSyntax node)
            => node.Update((SyntaxToken)Visit(node.OmittedTypeArgumentToken));

        public override CSharpSyntaxNode VisitRefType(RefTypeSyntax node)
            => node.Update((SyntaxToken)Visit(node.RefKeyword), (SyntaxToken)Visit(node.ReadOnlyKeyword), (TypeSyntax)Visit(node.Type));

        public override CSharpSyntaxNode VisitParenthesizedExpression(ParenthesizedExpressionSyntax node)
            => node.Update((SyntaxToken)Visit(node.OpenParenToken), (ExpressionSyntax)Visit(node.Expression), (SyntaxToken)Visit(node.CloseParenToken));

        public override CSharpSyntaxNode VisitTupleExpression(TupleExpressionSyntax node)
            => node.Update((SyntaxToken)Visit(node.OpenParenToken), VisitList(node.Arguments), (SyntaxToken)Visit(node.CloseParenToken));

        public override CSharpSyntaxNode VisitPrefixUnaryExpression(PrefixUnaryExpressionSyntax node)
            => node.Update((SyntaxToken)Visit(node.OperatorToken), (ExpressionSyntax)Visit(node.Operand));

        public override CSharpSyntaxNode VisitAwaitExpression(AwaitExpressionSyntax node)
            => node.Update((SyntaxToken)Visit(node.AwaitKeyword), (ExpressionSyntax)Visit(node.Expression));

        public override CSharpSyntaxNode VisitPostfixUnaryExpression(PostfixUnaryExpressionSyntax node)
            => node.Update((ExpressionSyntax)Visit(node.Operand), (SyntaxToken)Visit(node.OperatorToken));

        public override CSharpSyntaxNode VisitMemberAccessExpression(MemberAccessExpressionSyntax node)
            => node.Update((ExpressionSyntax)Visit(node.Expression), (SyntaxToken)Visit(node.OperatorToken), (SimpleNameSyntax)Visit(node.Name));

        public override CSharpSyntaxNode VisitConditionalAccessExpression(ConditionalAccessExpressionSyntax node)
            => node.Update((ExpressionSyntax)Visit(node.Expression), (SyntaxToken)Visit(node.OperatorToken), (ExpressionSyntax)Visit(node.WhenNotNull));

        public override CSharpSyntaxNode VisitMemberBindingExpression(MemberBindingExpressionSyntax node)
            => node.Update((SyntaxToken)Visit(node.OperatorToken), (SimpleNameSyntax)Visit(node.Name));

        public override CSharpSyntaxNode VisitElementBindingExpression(ElementBindingExpressionSyntax node)
            => node.Update((BracketedArgumentListSyntax)Visit(node.ArgumentList));

        public override CSharpSyntaxNode VisitRangeExpression(RangeExpressionSyntax node)
            => node.Update((ExpressionSyntax)Visit(node.LeftOperand), (SyntaxToken)Visit(node.OperatorToken), (ExpressionSyntax)Visit(node.RightOperand));

        public override CSharpSyntaxNode VisitImplicitElementAccess(ImplicitElementAccessSyntax node)
            => node.Update((BracketedArgumentListSyntax)Visit(node.ArgumentList));

        public override CSharpSyntaxNode VisitBinaryExpression(BinaryExpressionSyntax node)
            => node.Update((ExpressionSyntax)Visit(node.Left), (SyntaxToken)Visit(node.OperatorToken), (ExpressionSyntax)Visit(node.Right));

        public override CSharpSyntaxNode VisitAssignmentExpression(AssignmentExpressionSyntax node)
            => node.Update((ExpressionSyntax)Visit(node.Left), (SyntaxToken)Visit(node.OperatorToken), (ExpressionSyntax)Visit(node.Right));

        public override CSharpSyntaxNode VisitConditionalExpression(ConditionalExpressionSyntax node)
            => node.Update((ExpressionSyntax)Visit(node.Condition), (SyntaxToken)Visit(node.QuestionToken), (ExpressionSyntax)Visit(node.WhenTrue), (SyntaxToken)Visit(node.ColonToken), (ExpressionSyntax)Visit(node.WhenFalse));

        public override CSharpSyntaxNode VisitThisExpression(ThisExpressionSyntax node)
            => node.Update((SyntaxToken)Visit(node.Token));

        public override CSharpSyntaxNode VisitBaseExpression(BaseExpressionSyntax node)
            => node.Update((SyntaxToken)Visit(node.Token));

        public override CSharpSyntaxNode VisitLiteralExpression(LiteralExpressionSyntax node)
            => node.Update((SyntaxToken)Visit(node.Token));

        public override CSharpSyntaxNode VisitMakeRefExpression(MakeRefExpressionSyntax node)
            => node.Update((SyntaxToken)Visit(node.Keyword), (SyntaxToken)Visit(node.OpenParenToken), (ExpressionSyntax)Visit(node.Expression), (SyntaxToken)Visit(node.CloseParenToken));

        public override CSharpSyntaxNode VisitRefTypeExpression(RefTypeExpressionSyntax node)
            => node.Update((SyntaxToken)Visit(node.Keyword), (SyntaxToken)Visit(node.OpenParenToken), (ExpressionSyntax)Visit(node.Expression), (SyntaxToken)Visit(node.CloseParenToken));

        public override CSharpSyntaxNode VisitRefValueExpression(RefValueExpressionSyntax node)
            => node.Update((SyntaxToken)Visit(node.Keyword), (SyntaxToken)Visit(node.OpenParenToken), (ExpressionSyntax)Visit(node.Expression), (SyntaxToken)Visit(node.Comma), (TypeSyntax)Visit(node.Type), (SyntaxToken)Visit(node.CloseParenToken));

        public override CSharpSyntaxNode VisitCheckedExpression(CheckedExpressionSyntax node)
            => node.Update((SyntaxToken)Visit(node.Keyword), (SyntaxToken)Visit(node.OpenParenToken), (ExpressionSyntax)Visit(node.Expression), (SyntaxToken)Visit(node.CloseParenToken));

        public override CSharpSyntaxNode VisitDefaultExpression(DefaultExpressionSyntax node)
            => node.Update((SyntaxToken)Visit(node.Keyword), (SyntaxToken)Visit(node.OpenParenToken), (TypeSyntax)Visit(node.Type), (SyntaxToken)Visit(node.CloseParenToken));

        public override CSharpSyntaxNode VisitTypeOfExpression(TypeOfExpressionSyntax node)
            => node.Update((SyntaxToken)Visit(node.Keyword), (SyntaxToken)Visit(node.OpenParenToken), (TypeSyntax)Visit(node.Type), (SyntaxToken)Visit(node.CloseParenToken));

        public override CSharpSyntaxNode VisitSizeOfExpression(SizeOfExpressionSyntax node)
            => node.Update((SyntaxToken)Visit(node.Keyword), (SyntaxToken)Visit(node.OpenParenToken), (TypeSyntax)Visit(node.Type), (SyntaxToken)Visit(node.CloseParenToken));

        public override CSharpSyntaxNode VisitInvocationExpression(InvocationExpressionSyntax node)
            => node.Update((ExpressionSyntax)Visit(node.Expression), (ArgumentListSyntax)Visit(node.ArgumentList));

        public override CSharpSyntaxNode VisitElementAccessExpression(ElementAccessExpressionSyntax node)
            => node.Update((ExpressionSyntax)Visit(node.Expression), (BracketedArgumentListSyntax)Visit(node.ArgumentList));

        public override CSharpSyntaxNode VisitArgumentList(ArgumentListSyntax node)
            => node.Update((SyntaxToken)Visit(node.OpenParenToken), VisitList(node.Arguments), (SyntaxToken)Visit(node.CloseParenToken));

        public override CSharpSyntaxNode VisitBracketedArgumentList(BracketedArgumentListSyntax node)
            => node.Update((SyntaxToken)Visit(node.OpenBracketToken), VisitList(node.Arguments), (SyntaxToken)Visit(node.CloseBracketToken));

        public override CSharpSyntaxNode VisitArgument(ArgumentSyntax node)
            => node.Update((NameColonSyntax)Visit(node.NameColon), (SyntaxToken)Visit(node.RefKindKeyword), (ExpressionSyntax)Visit(node.Expression));

        public override CSharpSyntaxNode VisitNameColon(NameColonSyntax node)
            => node.Update((IdentifierNameSyntax)Visit(node.Name), (SyntaxToken)Visit(node.ColonToken));

        public override CSharpSyntaxNode VisitDeclarationExpression(DeclarationExpressionSyntax node)
            => node.Update((TypeSyntax)Visit(node.Type), (VariableDesignationSyntax)Visit(node.Designation));

        public override CSharpSyntaxNode VisitCastExpression(CastExpressionSyntax node)
            => node.Update((SyntaxToken)Visit(node.OpenParenToken), (TypeSyntax)Visit(node.Type), (SyntaxToken)Visit(node.CloseParenToken), (ExpressionSyntax)Visit(node.Expression));

        public override CSharpSyntaxNode VisitAnonymousMethodExpression(AnonymousMethodExpressionSyntax node)
            => node.Update(VisitList(node.Modifiers), (SyntaxToken)Visit(node.DelegateKeyword), (ParameterListSyntax)Visit(node.ParameterList), (BlockSyntax)Visit(node.Block), (ExpressionSyntax)Visit(node.ExpressionBody));

        public override CSharpSyntaxNode VisitSimpleLambdaExpression(SimpleLambdaExpressionSyntax node)
            => node.Update(VisitList(node.Modifiers), (ParameterSyntax)Visit(node.Parameter), (SyntaxToken)Visit(node.ArrowToken), (BlockSyntax)Visit(node.Block), (ExpressionSyntax)Visit(node.ExpressionBody));

        public override CSharpSyntaxNode VisitRefExpression(RefExpressionSyntax node)
            => node.Update((SyntaxToken)Visit(node.RefKeyword), (ExpressionSyntax)Visit(node.Expression));

        public override CSharpSyntaxNode VisitParenthesizedLambdaExpression(ParenthesizedLambdaExpressionSyntax node)
            => node.Update(VisitList(node.Modifiers), (ParameterListSyntax)Visit(node.ParameterList), (SyntaxToken)Visit(node.ArrowToken), (BlockSyntax)Visit(node.Block), (ExpressionSyntax)Visit(node.ExpressionBody));

        public override CSharpSyntaxNode VisitInitializerExpression(InitializerExpressionSyntax node)
            => node.Update((SyntaxToken)Visit(node.OpenBraceToken), VisitList(node.Expressions), (SyntaxToken)Visit(node.CloseBraceToken));

        public override CSharpSyntaxNode VisitImplicitObjectCreationExpression(ImplicitObjectCreationExpressionSyntax node)
            => node.Update((SyntaxToken)Visit(node.NewKeyword), (ArgumentListSyntax)Visit(node.ArgumentList), (InitializerExpressionSyntax)Visit(node.Initializer));

        public override CSharpSyntaxNode VisitObjectCreationExpression(ObjectCreationExpressionSyntax node)
            => node.Update((SyntaxToken)Visit(node.NewKeyword), (TypeSyntax)Visit(node.Type), (ArgumentListSyntax)Visit(node.ArgumentList), (InitializerExpressionSyntax)Visit(node.Initializer));

        public override CSharpSyntaxNode VisitWithExpression(WithExpressionSyntax node)
            => node.Update((ExpressionSyntax)Visit(node.Expression), (SyntaxToken)Visit(node.WithKeyword), (InitializerExpressionSyntax)Visit(node.Initializer));

        public override CSharpSyntaxNode VisitAnonymousObjectMemberDeclarator(AnonymousObjectMemberDeclaratorSyntax node)
            => node.Update((NameEqualsSyntax)Visit(node.NameEquals), (ExpressionSyntax)Visit(node.Expression));

        public override CSharpSyntaxNode VisitAnonymousObjectCreationExpression(AnonymousObjectCreationExpressionSyntax node)
            => node.Update((SyntaxToken)Visit(node.NewKeyword), (SyntaxToken)Visit(node.OpenBraceToken), VisitList(node.Initializers), (SyntaxToken)Visit(node.CloseBraceToken));

        public override CSharpSyntaxNode VisitArrayCreationExpression(ArrayCreationExpressionSyntax node)
            => node.Update((SyntaxToken)Visit(node.NewKeyword), (ArrayTypeSyntax)Visit(node.Type), (InitializerExpressionSyntax)Visit(node.Initializer));

        public override CSharpSyntaxNode VisitImplicitArrayCreationExpression(ImplicitArrayCreationExpressionSyntax node)
            => node.Update((SyntaxToken)Visit(node.NewKeyword), (SyntaxToken)Visit(node.OpenBracketToken), VisitList(node.Commas), (SyntaxToken)Visit(node.CloseBracketToken), (InitializerExpressionSyntax)Visit(node.Initializer));

        public override CSharpSyntaxNode VisitStackAllocArrayCreationExpression(StackAllocArrayCreationExpressionSyntax node)
            => node.Update((SyntaxToken)Visit(node.StackAllocKeyword), (TypeSyntax)Visit(node.Type), (InitializerExpressionSyntax)Visit(node.Initializer));

        public override CSharpSyntaxNode VisitImplicitStackAllocArrayCreationExpression(ImplicitStackAllocArrayCreationExpressionSyntax node)
            => node.Update((SyntaxToken)Visit(node.StackAllocKeyword), (SyntaxToken)Visit(node.OpenBracketToken), (SyntaxToken)Visit(node.CloseBracketToken), (InitializerExpressionSyntax)Visit(node.Initializer));

        public override CSharpSyntaxNode VisitQueryExpression(QueryExpressionSyntax node)
            => node.Update((FromClauseSyntax)Visit(node.FromClause), (QueryBodySyntax)Visit(node.Body));

        public override CSharpSyntaxNode VisitQueryBody(QueryBodySyntax node)
            => node.Update(VisitList(node.Clauses), (SelectOrGroupClauseSyntax)Visit(node.SelectOrGroup), (QueryContinuationSyntax)Visit(node.Continuation));

        public override CSharpSyntaxNode VisitFromClause(FromClauseSyntax node)
            => node.Update((SyntaxToken)Visit(node.FromKeyword), (TypeSyntax)Visit(node.Type), (SyntaxToken)Visit(node.Identifier), (SyntaxToken)Visit(node.InKeyword), (ExpressionSyntax)Visit(node.Expression));

        public override CSharpSyntaxNode VisitLetClause(LetClauseSyntax node)
            => node.Update((SyntaxToken)Visit(node.LetKeyword), (SyntaxToken)Visit(node.Identifier), (SyntaxToken)Visit(node.EqualsToken), (ExpressionSyntax)Visit(node.Expression));

        public override CSharpSyntaxNode VisitJoinClause(JoinClauseSyntax node)
            => node.Update((SyntaxToken)Visit(node.JoinKeyword), (TypeSyntax)Visit(node.Type), (SyntaxToken)Visit(node.Identifier), (SyntaxToken)Visit(node.InKeyword), (ExpressionSyntax)Visit(node.InExpression), (SyntaxToken)Visit(node.OnKeyword), (ExpressionSyntax)Visit(node.LeftExpression), (SyntaxToken)Visit(node.EqualsKeyword), (ExpressionSyntax)Visit(node.RightExpression), (JoinIntoClauseSyntax)Visit(node.Into));

        public override CSharpSyntaxNode VisitJoinIntoClause(JoinIntoClauseSyntax node)
            => node.Update((SyntaxToken)Visit(node.IntoKeyword), (SyntaxToken)Visit(node.Identifier));

        public override CSharpSyntaxNode VisitWhereClause(WhereClauseSyntax node)
            => node.Update((SyntaxToken)Visit(node.WhereKeyword), (ExpressionSyntax)Visit(node.Condition));

        public override CSharpSyntaxNode VisitOrderByClause(OrderByClauseSyntax node)
            => node.Update((SyntaxToken)Visit(node.OrderByKeyword), VisitList(node.Orderings));

        public override CSharpSyntaxNode VisitOrdering(OrderingSyntax node)
            => node.Update((ExpressionSyntax)Visit(node.Expression), (SyntaxToken)Visit(node.AscendingOrDescendingKeyword));

        public override CSharpSyntaxNode VisitSelectClause(SelectClauseSyntax node)
            => node.Update((SyntaxToken)Visit(node.SelectKeyword), (ExpressionSyntax)Visit(node.Expression));

        public override CSharpSyntaxNode VisitGroupClause(GroupClauseSyntax node)
            => node.Update((SyntaxToken)Visit(node.GroupKeyword), (ExpressionSyntax)Visit(node.GroupExpression), (SyntaxToken)Visit(node.ByKeyword), (ExpressionSyntax)Visit(node.ByExpression));

        public override CSharpSyntaxNode VisitQueryContinuation(QueryContinuationSyntax node)
            => node.Update((SyntaxToken)Visit(node.IntoKeyword), (SyntaxToken)Visit(node.Identifier), (QueryBodySyntax)Visit(node.Body));

        public override CSharpSyntaxNode VisitOmittedArraySizeExpression(OmittedArraySizeExpressionSyntax node)
            => node.Update((SyntaxToken)Visit(node.OmittedArraySizeExpressionToken));

        public override CSharpSyntaxNode VisitInterpolatedStringExpression(InterpolatedStringExpressionSyntax node)
            => node.Update((SyntaxToken)Visit(node.StringStartToken), VisitList(node.Contents), (SyntaxToken)Visit(node.StringEndToken));

        public override CSharpSyntaxNode VisitIsPatternExpression(IsPatternExpressionSyntax node)
            => node.Update((ExpressionSyntax)Visit(node.Expression), (SyntaxToken)Visit(node.IsKeyword), (PatternSyntax)Visit(node.Pattern));

        public override CSharpSyntaxNode VisitThrowExpression(ThrowExpressionSyntax node)
            => node.Update((SyntaxToken)Visit(node.ThrowKeyword), (ExpressionSyntax)Visit(node.Expression));

        public override CSharpSyntaxNode VisitWhenClause(WhenClauseSyntax node)
            => node.Update((SyntaxToken)Visit(node.WhenKeyword), (ExpressionSyntax)Visit(node.Condition));

        public override CSharpSyntaxNode VisitDiscardPattern(DiscardPatternSyntax node)
            => node.Update((SyntaxToken)Visit(node.UnderscoreToken));

        public override CSharpSyntaxNode VisitDeclarationPattern(DeclarationPatternSyntax node)
            => node.Update((TypeSyntax)Visit(node.Type), (VariableDesignationSyntax)Visit(node.Designation));

        public override CSharpSyntaxNode VisitVarPattern(VarPatternSyntax node)
            => node.Update((SyntaxToken)Visit(node.VarKeyword), (VariableDesignationSyntax)Visit(node.Designation));

        public override CSharpSyntaxNode VisitRecursivePattern(RecursivePatternSyntax node)
            => node.Update((TypeSyntax)Visit(node.Type), (PositionalPatternClauseSyntax)Visit(node.PositionalPatternClause), (PropertyPatternClauseSyntax)Visit(node.PropertyPatternClause), (VariableDesignationSyntax)Visit(node.Designation));

        public override CSharpSyntaxNode VisitPositionalPatternClause(PositionalPatternClauseSyntax node)
            => node.Update((SyntaxToken)Visit(node.OpenParenToken), VisitList(node.Subpatterns), (SyntaxToken)Visit(node.CloseParenToken));

        public override CSharpSyntaxNode VisitPropertyPatternClause(PropertyPatternClauseSyntax node)
            => node.Update((SyntaxToken)Visit(node.OpenBraceToken), VisitList(node.Subpatterns), (SyntaxToken)Visit(node.CloseBraceToken));

        public override CSharpSyntaxNode VisitSubpattern(SubpatternSyntax node)
            => node.Update((NameColonSyntax)Visit(node.NameColon), (PatternSyntax)Visit(node.Pattern));

        public override CSharpSyntaxNode VisitConstantPattern(ConstantPatternSyntax node)
            => node.Update((ExpressionSyntax)Visit(node.Expression));

        public override CSharpSyntaxNode VisitParenthesizedPattern(ParenthesizedPatternSyntax node)
            => node.Update((SyntaxToken)Visit(node.OpenParenToken), (PatternSyntax)Visit(node.Pattern), (SyntaxToken)Visit(node.CloseParenToken));

        public override CSharpSyntaxNode VisitRelationalPattern(RelationalPatternSyntax node)
            => node.Update((SyntaxToken)Visit(node.OperatorToken), (ExpressionSyntax)Visit(node.Expression));

        public override CSharpSyntaxNode VisitTypePattern(TypePatternSyntax node)
            => node.Update((TypeSyntax)Visit(node.Type));

        public override CSharpSyntaxNode VisitBinaryPattern(BinaryPatternSyntax node)
            => node.Update((PatternSyntax)Visit(node.Left), (SyntaxToken)Visit(node.OperatorToken), (PatternSyntax)Visit(node.Right));

        public override CSharpSyntaxNode VisitUnaryPattern(UnaryPatternSyntax node)
            => node.Update((SyntaxToken)Visit(node.OperatorToken), (PatternSyntax)Visit(node.Pattern));

        public override CSharpSyntaxNode VisitInterpolatedStringText(InterpolatedStringTextSyntax node)
            => node.Update((SyntaxToken)Visit(node.TextToken));

        public override CSharpSyntaxNode VisitInterpolation(InterpolationSyntax node)
            => node.Update((SyntaxToken)Visit(node.OpenBraceToken), (ExpressionSyntax)Visit(node.Expression), (InterpolationAlignmentClauseSyntax)Visit(node.AlignmentClause), (InterpolationFormatClauseSyntax)Visit(node.FormatClause), (SyntaxToken)Visit(node.CloseBraceToken));

        public override CSharpSyntaxNode VisitInterpolationAlignmentClause(InterpolationAlignmentClauseSyntax node)
            => node.Update((SyntaxToken)Visit(node.CommaToken), (ExpressionSyntax)Visit(node.Value));

        public override CSharpSyntaxNode VisitInterpolationFormatClause(InterpolationFormatClauseSyntax node)
            => node.Update((SyntaxToken)Visit(node.ColonToken), (SyntaxToken)Visit(node.FormatStringToken));

        public override CSharpSyntaxNode VisitGlobalStatement(GlobalStatementSyntax node)
            => node.Update(VisitList(node.AttributeLists), VisitList(node.Modifiers), (StatementSyntax)Visit(node.Statement));

        public override CSharpSyntaxNode VisitBlock(BlockSyntax node)
            => node.Update(VisitList(node.AttributeLists), (SyntaxToken)Visit(node.OpenBraceToken), VisitList(node.Statements), (SyntaxToken)Visit(node.CloseBraceToken));

        public override CSharpSyntaxNode VisitLocalFunctionStatement(LocalFunctionStatementSyntax node)
            => node.Update(VisitList(node.AttributeLists), VisitList(node.Modifiers), (TypeSyntax)Visit(node.ReturnType), (SyntaxToken)Visit(node.Identifier), (TypeParameterListSyntax)Visit(node.TypeParameterList), (ParameterListSyntax)Visit(node.ParameterList), VisitList(node.ConstraintClauses), (BlockSyntax)Visit(node.Body), (ArrowExpressionClauseSyntax)Visit(node.ExpressionBody), (SyntaxToken)Visit(node.SemicolonToken));

        public override CSharpSyntaxNode VisitLocalDeclarationStatement(LocalDeclarationStatementSyntax node)
            => node.Update(VisitList(node.AttributeLists), (SyntaxToken)Visit(node.AwaitKeyword), (SyntaxToken)Visit(node.UsingKeyword), VisitList(node.Modifiers), (VariableDeclarationSyntax)Visit(node.Declaration), (SyntaxToken)Visit(node.SemicolonToken));

        public override CSharpSyntaxNode VisitVariableDeclaration(VariableDeclarationSyntax node)
            => node.Update((TypeSyntax)Visit(node.Type), VisitList(node.Variables));

        public override CSharpSyntaxNode VisitVariableDeclarator(VariableDeclaratorSyntax node)
            => node.Update((SyntaxToken)Visit(node.Identifier), (BracketedArgumentListSyntax)Visit(node.ArgumentList), (EqualsValueClauseSyntax)Visit(node.Initializer));

        public override CSharpSyntaxNode VisitEqualsValueClause(EqualsValueClauseSyntax node)
            => node.Update((SyntaxToken)Visit(node.EqualsToken), (ExpressionSyntax)Visit(node.Value));

        public override CSharpSyntaxNode VisitSingleVariableDesignation(SingleVariableDesignationSyntax node)
            => node.Update((SyntaxToken)Visit(node.Identifier));

        public override CSharpSyntaxNode VisitDiscardDesignation(DiscardDesignationSyntax node)
            => node.Update((SyntaxToken)Visit(node.UnderscoreToken));

        public override CSharpSyntaxNode VisitParenthesizedVariableDesignation(ParenthesizedVariableDesignationSyntax node)
            => node.Update((SyntaxToken)Visit(node.OpenParenToken), VisitList(node.Variables), (SyntaxToken)Visit(node.CloseParenToken));

        public override CSharpSyntaxNode VisitExpressionStatement(ExpressionStatementSyntax node)
            => node.Update(VisitList(node.AttributeLists), (ExpressionSyntax)Visit(node.Expression), (SyntaxToken)Visit(node.SemicolonToken));

        public override CSharpSyntaxNode VisitEmptyStatement(EmptyStatementSyntax node)
            => node.Update(VisitList(node.AttributeLists), (SyntaxToken)Visit(node.SemicolonToken));

        public override CSharpSyntaxNode VisitLabeledStatement(LabeledStatementSyntax node)
            => node.Update(VisitList(node.AttributeLists), (SyntaxToken)Visit(node.Identifier), (SyntaxToken)Visit(node.ColonToken), (StatementSyntax)Visit(node.Statement));

        public override CSharpSyntaxNode VisitGotoStatement(GotoStatementSyntax node)
            => node.Update(VisitList(node.AttributeLists), (SyntaxToken)Visit(node.GotoKeyword), (SyntaxToken)Visit(node.CaseOrDefaultKeyword), (ExpressionSyntax)Visit(node.Expression), (SyntaxToken)Visit(node.SemicolonToken));

        public override CSharpSyntaxNode VisitBreakStatement(BreakStatementSyntax node)
            => node.Update(VisitList(node.AttributeLists), (SyntaxToken)Visit(node.BreakKeyword), (SyntaxToken)Visit(node.SemicolonToken));

        public override CSharpSyntaxNode VisitContinueStatement(ContinueStatementSyntax node)
            => node.Update(VisitList(node.AttributeLists), (SyntaxToken)Visit(node.ContinueKeyword), (SyntaxToken)Visit(node.SemicolonToken));

        public override CSharpSyntaxNode VisitReturnStatement(ReturnStatementSyntax node)
            => node.Update(VisitList(node.AttributeLists), (SyntaxToken)Visit(node.ReturnKeyword), (ExpressionSyntax)Visit(node.Expression), (SyntaxToken)Visit(node.SemicolonToken));

        public override CSharpSyntaxNode VisitThrowStatement(ThrowStatementSyntax node)
            => node.Update(VisitList(node.AttributeLists), (SyntaxToken)Visit(node.ThrowKeyword), (ExpressionSyntax)Visit(node.Expression), (SyntaxToken)Visit(node.SemicolonToken));

        public override CSharpSyntaxNode VisitYieldStatement(YieldStatementSyntax node)
            => node.Update(VisitList(node.AttributeLists), (SyntaxToken)Visit(node.YieldKeyword), (SyntaxToken)Visit(node.ReturnOrBreakKeyword), (ExpressionSyntax)Visit(node.Expression), (SyntaxToken)Visit(node.SemicolonToken));

        public override CSharpSyntaxNode VisitWhileStatement(WhileStatementSyntax node)
            => node.Update(VisitList(node.AttributeLists), (SyntaxToken)Visit(node.WhileKeyword), (SyntaxToken)Visit(node.OpenParenToken), (ExpressionSyntax)Visit(node.Condition), (SyntaxToken)Visit(node.CloseParenToken), (StatementSyntax)Visit(node.Statement));

        public override CSharpSyntaxNode VisitDoStatement(DoStatementSyntax node)
            => node.Update(VisitList(node.AttributeLists), (SyntaxToken)Visit(node.DoKeyword), (StatementSyntax)Visit(node.Statement), (SyntaxToken)Visit(node.WhileKeyword), (SyntaxToken)Visit(node.OpenParenToken), (ExpressionSyntax)Visit(node.Condition), (SyntaxToken)Visit(node.CloseParenToken), (SyntaxToken)Visit(node.SemicolonToken));

        public override CSharpSyntaxNode VisitForStatement(ForStatementSyntax node)
            => node.Update(VisitList(node.AttributeLists), (SyntaxToken)Visit(node.ForKeyword), (SyntaxToken)Visit(node.OpenParenToken), (VariableDeclarationSyntax)Visit(node.Declaration), VisitList(node.Initializers), (SyntaxToken)Visit(node.FirstSemicolonToken), (ExpressionSyntax)Visit(node.Condition), (SyntaxToken)Visit(node.SecondSemicolonToken), VisitList(node.Incrementors), (SyntaxToken)Visit(node.CloseParenToken), (StatementSyntax)Visit(node.Statement));

        public override CSharpSyntaxNode VisitForEachStatement(ForEachStatementSyntax node)
            => node.Update(VisitList(node.AttributeLists), (SyntaxToken)Visit(node.AwaitKeyword), (SyntaxToken)Visit(node.ForEachKeyword), (SyntaxToken)Visit(node.OpenParenToken), (TypeSyntax)Visit(node.Type), (SyntaxToken)Visit(node.Identifier), (SyntaxToken)Visit(node.InKeyword), (ExpressionSyntax)Visit(node.Expression), (SyntaxToken)Visit(node.CloseParenToken), (StatementSyntax)Visit(node.Statement));

        public override CSharpSyntaxNode VisitForEachVariableStatement(ForEachVariableStatementSyntax node)
            => node.Update(VisitList(node.AttributeLists), (SyntaxToken)Visit(node.AwaitKeyword), (SyntaxToken)Visit(node.ForEachKeyword), (SyntaxToken)Visit(node.OpenParenToken), (ExpressionSyntax)Visit(node.Variable), (SyntaxToken)Visit(node.InKeyword), (ExpressionSyntax)Visit(node.Expression), (SyntaxToken)Visit(node.CloseParenToken), (StatementSyntax)Visit(node.Statement));

        public override CSharpSyntaxNode VisitUsingStatement(UsingStatementSyntax node)
            => node.Update(VisitList(node.AttributeLists), (SyntaxToken)Visit(node.AwaitKeyword), (SyntaxToken)Visit(node.UsingKeyword), (SyntaxToken)Visit(node.OpenParenToken), (VariableDeclarationSyntax)Visit(node.Declaration), (ExpressionSyntax)Visit(node.Expression), (SyntaxToken)Visit(node.CloseParenToken), (StatementSyntax)Visit(node.Statement));

        public override CSharpSyntaxNode VisitFixedStatement(FixedStatementSyntax node)
            => node.Update(VisitList(node.AttributeLists), (SyntaxToken)Visit(node.FixedKeyword), (SyntaxToken)Visit(node.OpenParenToken), (VariableDeclarationSyntax)Visit(node.Declaration), (SyntaxToken)Visit(node.CloseParenToken), (StatementSyntax)Visit(node.Statement));

        public override CSharpSyntaxNode VisitCheckedStatement(CheckedStatementSyntax node)
            => node.Update(VisitList(node.AttributeLists), (SyntaxToken)Visit(node.Keyword), (BlockSyntax)Visit(node.Block));

        public override CSharpSyntaxNode VisitUnsafeStatement(UnsafeStatementSyntax node)
            => node.Update(VisitList(node.AttributeLists), (SyntaxToken)Visit(node.UnsafeKeyword), (BlockSyntax)Visit(node.Block));

        public override CSharpSyntaxNode VisitLockStatement(LockStatementSyntax node)
            => node.Update(VisitList(node.AttributeLists), (SyntaxToken)Visit(node.LockKeyword), (SyntaxToken)Visit(node.OpenParenToken), (ExpressionSyntax)Visit(node.Expression), (SyntaxToken)Visit(node.CloseParenToken), (StatementSyntax)Visit(node.Statement));

        public override CSharpSyntaxNode VisitIfStatement(IfStatementSyntax node)
            => node.Update(VisitList(node.AttributeLists), (SyntaxToken)Visit(node.IfKeyword), (SyntaxToken)Visit(node.OpenParenToken), (ExpressionSyntax)Visit(node.Condition), (SyntaxToken)Visit(node.CloseParenToken), (StatementSyntax)Visit(node.Statement), (ElseClauseSyntax)Visit(node.Else));

        public override CSharpSyntaxNode VisitElseClause(ElseClauseSyntax node)
            => node.Update((SyntaxToken)Visit(node.ElseKeyword), (StatementSyntax)Visit(node.Statement));

        public override CSharpSyntaxNode VisitSwitchStatement(SwitchStatementSyntax node)
            => node.Update(VisitList(node.AttributeLists), (SyntaxToken)Visit(node.SwitchKeyword), (SyntaxToken)Visit(node.OpenParenToken), (ExpressionSyntax)Visit(node.Expression), (SyntaxToken)Visit(node.CloseParenToken), (SyntaxToken)Visit(node.OpenBraceToken), VisitList(node.Sections), (SyntaxToken)Visit(node.CloseBraceToken));

        public override CSharpSyntaxNode VisitSwitchSection(SwitchSectionSyntax node)
            => node.Update(VisitList(node.Labels), VisitList(node.Statements));

        public override CSharpSyntaxNode VisitCasePatternSwitchLabel(CasePatternSwitchLabelSyntax node)
            => node.Update((SyntaxToken)Visit(node.Keyword), (PatternSyntax)Visit(node.Pattern), (WhenClauseSyntax)Visit(node.WhenClause), (SyntaxToken)Visit(node.ColonToken));

        public override CSharpSyntaxNode VisitCaseSwitchLabel(CaseSwitchLabelSyntax node)
            => node.Update((SyntaxToken)Visit(node.Keyword), (ExpressionSyntax)Visit(node.Value), (SyntaxToken)Visit(node.ColonToken));

        public override CSharpSyntaxNode VisitDefaultSwitchLabel(DefaultSwitchLabelSyntax node)
            => node.Update((SyntaxToken)Visit(node.Keyword), (SyntaxToken)Visit(node.ColonToken));

        public override CSharpSyntaxNode VisitSwitchExpression(SwitchExpressionSyntax node)
            => node.Update((ExpressionSyntax)Visit(node.GoverningExpression), (SyntaxToken)Visit(node.SwitchKeyword), (SyntaxToken)Visit(node.OpenBraceToken), VisitList(node.Arms), (SyntaxToken)Visit(node.CloseBraceToken));

        public override CSharpSyntaxNode VisitSwitchExpressionArm(SwitchExpressionArmSyntax node)
            => node.Update((PatternSyntax)Visit(node.Pattern), (WhenClauseSyntax)Visit(node.WhenClause), (SyntaxToken)Visit(node.EqualsGreaterThanToken), (ExpressionSyntax)Visit(node.Expression));

        public override CSharpSyntaxNode VisitTryStatement(TryStatementSyntax node)
            => node.Update(VisitList(node.AttributeLists), (SyntaxToken)Visit(node.TryKeyword), (BlockSyntax)Visit(node.Block), VisitList(node.Catches), (FinallyClauseSyntax)Visit(node.Finally));

        public override CSharpSyntaxNode VisitCatchClause(CatchClauseSyntax node)
            => node.Update((SyntaxToken)Visit(node.CatchKeyword), (CatchDeclarationSyntax)Visit(node.Declaration), (CatchFilterClauseSyntax)Visit(node.Filter), (BlockSyntax)Visit(node.Block));

        public override CSharpSyntaxNode VisitCatchDeclaration(CatchDeclarationSyntax node)
            => node.Update((SyntaxToken)Visit(node.OpenParenToken), (TypeSyntax)Visit(node.Type), (SyntaxToken)Visit(node.Identifier), (SyntaxToken)Visit(node.CloseParenToken));

        public override CSharpSyntaxNode VisitCatchFilterClause(CatchFilterClauseSyntax node)
            => node.Update((SyntaxToken)Visit(node.WhenKeyword), (SyntaxToken)Visit(node.OpenParenToken), (ExpressionSyntax)Visit(node.FilterExpression), (SyntaxToken)Visit(node.CloseParenToken));

        public override CSharpSyntaxNode VisitFinallyClause(FinallyClauseSyntax node)
            => node.Update((SyntaxToken)Visit(node.FinallyKeyword), (BlockSyntax)Visit(node.Block));

        public override CSharpSyntaxNode VisitCompilationUnit(CompilationUnitSyntax node)
            => node.Update(VisitList(node.Externs), VisitList(node.Usings), VisitList(node.AttributeLists), VisitList(node.Members), (SyntaxToken)Visit(node.EndOfFileToken));

        public override CSharpSyntaxNode VisitExternAliasDirective(ExternAliasDirectiveSyntax node)
            => node.Update((SyntaxToken)Visit(node.ExternKeyword), (SyntaxToken)Visit(node.AliasKeyword), (SyntaxToken)Visit(node.Identifier), (SyntaxToken)Visit(node.SemicolonToken));

        public override CSharpSyntaxNode VisitUsingDirective(UsingDirectiveSyntax node)
            => node.Update((SyntaxToken)Visit(node.UsingKeyword), (SyntaxToken)Visit(node.StaticKeyword), (NameEqualsSyntax)Visit(node.Alias), (NameSyntax)Visit(node.Name), (SyntaxToken)Visit(node.SemicolonToken));

        public override CSharpSyntaxNode VisitNamespaceDeclaration(NamespaceDeclarationSyntax node)
            => node.Update(VisitList(node.AttributeLists), VisitList(node.Modifiers), (SyntaxToken)Visit(node.NamespaceKeyword), (NameSyntax)Visit(node.Name), (SyntaxToken)Visit(node.OpenBraceToken), VisitList(node.Externs), VisitList(node.Usings), VisitList(node.Members), (SyntaxToken)Visit(node.CloseBraceToken), (SyntaxToken)Visit(node.SemicolonToken));

        public override CSharpSyntaxNode VisitAttributeList(AttributeListSyntax node)
            => node.Update((SyntaxToken)Visit(node.OpenBracketToken), (AttributeTargetSpecifierSyntax)Visit(node.Target), VisitList(node.Attributes), (SyntaxToken)Visit(node.CloseBracketToken));

        public override CSharpSyntaxNode VisitAttributeTargetSpecifier(AttributeTargetSpecifierSyntax node)
            => node.Update((SyntaxToken)Visit(node.Identifier), (SyntaxToken)Visit(node.ColonToken));

        public override CSharpSyntaxNode VisitAttribute(AttributeSyntax node)
            => node.Update((NameSyntax)Visit(node.Name), (AttributeArgumentListSyntax)Visit(node.ArgumentList));

        public override CSharpSyntaxNode VisitAttributeArgumentList(AttributeArgumentListSyntax node)
            => node.Update((SyntaxToken)Visit(node.OpenParenToken), VisitList(node.Arguments), (SyntaxToken)Visit(node.CloseParenToken));

        public override CSharpSyntaxNode VisitAttributeArgument(AttributeArgumentSyntax node)
            => node.Update((NameEqualsSyntax)Visit(node.NameEquals), (NameColonSyntax)Visit(node.NameColon), (ExpressionSyntax)Visit(node.Expression));

        public override CSharpSyntaxNode VisitNameEquals(NameEqualsSyntax node)
            => node.Update((IdentifierNameSyntax)Visit(node.Name), (SyntaxToken)Visit(node.EqualsToken));

        public override CSharpSyntaxNode VisitTypeParameterList(TypeParameterListSyntax node)
            => node.Update((SyntaxToken)Visit(node.LessThanToken), VisitList(node.Parameters), (SyntaxToken)Visit(node.GreaterThanToken));

        public override CSharpSyntaxNode VisitTypeParameter(TypeParameterSyntax node)
            => node.Update(VisitList(node.AttributeLists), (SyntaxToken)Visit(node.VarianceKeyword), (SyntaxToken)Visit(node.Identifier));

        public override CSharpSyntaxNode VisitClassDeclaration(ClassDeclarationSyntax node)
            => node.Update(VisitList(node.AttributeLists), VisitList(node.Modifiers), (SyntaxToken)Visit(node.Keyword), (SyntaxToken)Visit(node.Identifier), (TypeParameterListSyntax)Visit(node.TypeParameterList), (BaseListSyntax)Visit(node.BaseList), VisitList(node.ConstraintClauses), (SyntaxToken)Visit(node.OpenBraceToken), VisitList(node.Members), (SyntaxToken)Visit(node.CloseBraceToken), (SyntaxToken)Visit(node.SemicolonToken));

        public override CSharpSyntaxNode VisitStructDeclaration(StructDeclarationSyntax node)
            => node.Update(VisitList(node.AttributeLists), VisitList(node.Modifiers), (SyntaxToken)Visit(node.Keyword), (SyntaxToken)Visit(node.Identifier), (TypeParameterListSyntax)Visit(node.TypeParameterList), (BaseListSyntax)Visit(node.BaseList), VisitList(node.ConstraintClauses), (SyntaxToken)Visit(node.OpenBraceToken), VisitList(node.Members), (SyntaxToken)Visit(node.CloseBraceToken), (SyntaxToken)Visit(node.SemicolonToken));

        public override CSharpSyntaxNode VisitInterfaceDeclaration(InterfaceDeclarationSyntax node)
            => node.Update(VisitList(node.AttributeLists), VisitList(node.Modifiers), (SyntaxToken)Visit(node.Keyword), (SyntaxToken)Visit(node.Identifier), (TypeParameterListSyntax)Visit(node.TypeParameterList), (BaseListSyntax)Visit(node.BaseList), VisitList(node.ConstraintClauses), (SyntaxToken)Visit(node.OpenBraceToken), VisitList(node.Members), (SyntaxToken)Visit(node.CloseBraceToken), (SyntaxToken)Visit(node.SemicolonToken));

        public override CSharpSyntaxNode VisitRecordDeclaration(RecordDeclarationSyntax node)
            => node.Update(VisitList(node.AttributeLists), VisitList(node.Modifiers), (SyntaxToken)Visit(node.Keyword), (SyntaxToken)Visit(node.Identifier), (TypeParameterListSyntax)Visit(node.TypeParameterList), (ParameterListSyntax)Visit(node.ParameterList), (BaseListSyntax)Visit(node.BaseList), VisitList(node.ConstraintClauses), (SyntaxToken)Visit(node.OpenBraceToken), VisitList(node.Members), (SyntaxToken)Visit(node.CloseBraceToken), (SyntaxToken)Visit(node.SemicolonToken));

        public override CSharpSyntaxNode VisitEnumDeclaration(EnumDeclarationSyntax node)
            => node.Update(VisitList(node.AttributeLists), VisitList(node.Modifiers), (SyntaxToken)Visit(node.EnumKeyword), (SyntaxToken)Visit(node.Identifier), (BaseListSyntax)Visit(node.BaseList), (SyntaxToken)Visit(node.OpenBraceToken), VisitList(node.Members), (SyntaxToken)Visit(node.CloseBraceToken), (SyntaxToken)Visit(node.SemicolonToken));

        public override CSharpSyntaxNode VisitDelegateDeclaration(DelegateDeclarationSyntax node)
            => node.Update(VisitList(node.AttributeLists), VisitList(node.Modifiers), (SyntaxToken)Visit(node.DelegateKeyword), (TypeSyntax)Visit(node.ReturnType), (SyntaxToken)Visit(node.Identifier), (TypeParameterListSyntax)Visit(node.TypeParameterList), (ParameterListSyntax)Visit(node.ParameterList), VisitList(node.ConstraintClauses), (SyntaxToken)Visit(node.SemicolonToken));

        public override CSharpSyntaxNode VisitEnumMemberDeclaration(EnumMemberDeclarationSyntax node)
            => node.Update(VisitList(node.AttributeLists), VisitList(node.Modifiers), (SyntaxToken)Visit(node.Identifier), (EqualsValueClauseSyntax)Visit(node.EqualsValue));

        public override CSharpSyntaxNode VisitBaseList(BaseListSyntax node)
            => node.Update((SyntaxToken)Visit(node.ColonToken), VisitList(node.Types));

        public override CSharpSyntaxNode VisitSimpleBaseType(SimpleBaseTypeSyntax node)
            => node.Update((TypeSyntax)Visit(node.Type));

        public override CSharpSyntaxNode VisitPrimaryConstructorBaseType(PrimaryConstructorBaseTypeSyntax node)
            => node.Update((TypeSyntax)Visit(node.Type), (ArgumentListSyntax)Visit(node.ArgumentList));

        public override CSharpSyntaxNode VisitTypeParameterConstraintClause(TypeParameterConstraintClauseSyntax node)
            => node.Update((SyntaxToken)Visit(node.WhereKeyword), (IdentifierNameSyntax)Visit(node.Name), (SyntaxToken)Visit(node.ColonToken), VisitList(node.Constraints));

        public override CSharpSyntaxNode VisitConstructorConstraint(ConstructorConstraintSyntax node)
            => node.Update((SyntaxToken)Visit(node.NewKeyword), (SyntaxToken)Visit(node.OpenParenToken), (SyntaxToken)Visit(node.CloseParenToken));

        public override CSharpSyntaxNode VisitClassOrStructConstraint(ClassOrStructConstraintSyntax node)
            => node.Update((SyntaxToken)Visit(node.ClassOrStructKeyword), (SyntaxToken)Visit(node.QuestionToken));

        public override CSharpSyntaxNode VisitTypeConstraint(TypeConstraintSyntax node)
            => node.Update((TypeSyntax)Visit(node.Type));

        public override CSharpSyntaxNode VisitDefaultConstraint(DefaultConstraintSyntax node)
            => node.Update((SyntaxToken)Visit(node.DefaultKeyword));

        public override CSharpSyntaxNode VisitFieldDeclaration(FieldDeclarationSyntax node)
            => node.Update(VisitList(node.AttributeLists), VisitList(node.Modifiers), (VariableDeclarationSyntax)Visit(node.Declaration), (SyntaxToken)Visit(node.SemicolonToken));

        public override CSharpSyntaxNode VisitEventFieldDeclaration(EventFieldDeclarationSyntax node)
            => node.Update(VisitList(node.AttributeLists), VisitList(node.Modifiers), (SyntaxToken)Visit(node.EventKeyword), (VariableDeclarationSyntax)Visit(node.Declaration), (SyntaxToken)Visit(node.SemicolonToken));

        public override CSharpSyntaxNode VisitExplicitInterfaceSpecifier(ExplicitInterfaceSpecifierSyntax node)
            => node.Update((NameSyntax)Visit(node.Name), (SyntaxToken)Visit(node.DotToken));

        public override CSharpSyntaxNode VisitMethodDeclaration(MethodDeclarationSyntax node)
            => node.Update(VisitList(node.AttributeLists), VisitList(node.Modifiers), (TypeSyntax)Visit(node.ReturnType), (ExplicitInterfaceSpecifierSyntax)Visit(node.ExplicitInterfaceSpecifier), (SyntaxToken)Visit(node.Identifier), (TypeParameterListSyntax)Visit(node.TypeParameterList), (ParameterListSyntax)Visit(node.ParameterList), VisitList(node.ConstraintClauses), (BlockSyntax)Visit(node.Body), (ArrowExpressionClauseSyntax)Visit(node.ExpressionBody), (SyntaxToken)Visit(node.SemicolonToken));

        public override CSharpSyntaxNode VisitOperatorDeclaration(OperatorDeclarationSyntax node)
            => node.Update(VisitList(node.AttributeLists), VisitList(node.Modifiers), (TypeSyntax)Visit(node.ReturnType), (SyntaxToken)Visit(node.OperatorKeyword), (SyntaxToken)Visit(node.OperatorToken), (ParameterListSyntax)Visit(node.ParameterList), (BlockSyntax)Visit(node.Body), (ArrowExpressionClauseSyntax)Visit(node.ExpressionBody), (SyntaxToken)Visit(node.SemicolonToken));

        public override CSharpSyntaxNode VisitConversionOperatorDeclaration(ConversionOperatorDeclarationSyntax node)
            => node.Update(VisitList(node.AttributeLists), VisitList(node.Modifiers), (SyntaxToken)Visit(node.ImplicitOrExplicitKeyword), (SyntaxToken)Visit(node.OperatorKeyword), (TypeSyntax)Visit(node.Type), (ParameterListSyntax)Visit(node.ParameterList), (BlockSyntax)Visit(node.Body), (ArrowExpressionClauseSyntax)Visit(node.ExpressionBody), (SyntaxToken)Visit(node.SemicolonToken));

        public override CSharpSyntaxNode VisitConstructorDeclaration(ConstructorDeclarationSyntax node)
            => node.Update(VisitList(node.AttributeLists), VisitList(node.Modifiers), (SyntaxToken)Visit(node.Identifier), (ParameterListSyntax)Visit(node.ParameterList), (ConstructorInitializerSyntax)Visit(node.Initializer), (BlockSyntax)Visit(node.Body), (ArrowExpressionClauseSyntax)Visit(node.ExpressionBody), (SyntaxToken)Visit(node.SemicolonToken));

        public override CSharpSyntaxNode VisitConstructorInitializer(ConstructorInitializerSyntax node)
            => node.Update((SyntaxToken)Visit(node.ColonToken), (SyntaxToken)Visit(node.ThisOrBaseKeyword), (ArgumentListSyntax)Visit(node.ArgumentList));

        public override CSharpSyntaxNode VisitDestructorDeclaration(DestructorDeclarationSyntax node)
            => node.Update(VisitList(node.AttributeLists), VisitList(node.Modifiers), (SyntaxToken)Visit(node.TildeToken), (SyntaxToken)Visit(node.Identifier), (ParameterListSyntax)Visit(node.ParameterList), (BlockSyntax)Visit(node.Body), (ArrowExpressionClauseSyntax)Visit(node.ExpressionBody), (SyntaxToken)Visit(node.SemicolonToken));

        public override CSharpSyntaxNode VisitPropertyDeclaration(PropertyDeclarationSyntax node)
            => node.Update(VisitList(node.AttributeLists), VisitList(node.Modifiers), (TypeSyntax)Visit(node.Type), (ExplicitInterfaceSpecifierSyntax)Visit(node.ExplicitInterfaceSpecifier), (SyntaxToken)Visit(node.Identifier), (AccessorListSyntax)Visit(node.AccessorList), (ArrowExpressionClauseSyntax)Visit(node.ExpressionBody), (EqualsValueClauseSyntax)Visit(node.Initializer), (SyntaxToken)Visit(node.SemicolonToken));

        public override CSharpSyntaxNode VisitArrowExpressionClause(ArrowExpressionClauseSyntax node)
            => node.Update((SyntaxToken)Visit(node.ArrowToken), (ExpressionSyntax)Visit(node.Expression));

        public override CSharpSyntaxNode VisitEventDeclaration(EventDeclarationSyntax node)
            => node.Update(VisitList(node.AttributeLists), VisitList(node.Modifiers), (SyntaxToken)Visit(node.EventKeyword), (TypeSyntax)Visit(node.Type), (ExplicitInterfaceSpecifierSyntax)Visit(node.ExplicitInterfaceSpecifier), (SyntaxToken)Visit(node.Identifier), (AccessorListSyntax)Visit(node.AccessorList), (SyntaxToken)Visit(node.SemicolonToken));

        public override CSharpSyntaxNode VisitIndexerDeclaration(IndexerDeclarationSyntax node)
            => node.Update(VisitList(node.AttributeLists), VisitList(node.Modifiers), (TypeSyntax)Visit(node.Type), (ExplicitInterfaceSpecifierSyntax)Visit(node.ExplicitInterfaceSpecifier), (SyntaxToken)Visit(node.ThisKeyword), (BracketedParameterListSyntax)Visit(node.ParameterList), (AccessorListSyntax)Visit(node.AccessorList), (ArrowExpressionClauseSyntax)Visit(node.ExpressionBody), (SyntaxToken)Visit(node.SemicolonToken));

        public override CSharpSyntaxNode VisitAccessorList(AccessorListSyntax node)
            => node.Update((SyntaxToken)Visit(node.OpenBraceToken), VisitList(node.Accessors), (SyntaxToken)Visit(node.CloseBraceToken));

        public override CSharpSyntaxNode VisitAccessorDeclaration(AccessorDeclarationSyntax node)
            => node.Update(VisitList(node.AttributeLists), VisitList(node.Modifiers), (SyntaxToken)Visit(node.Keyword), (BlockSyntax)Visit(node.Body), (ArrowExpressionClauseSyntax)Visit(node.ExpressionBody), (SyntaxToken)Visit(node.SemicolonToken));

        public override CSharpSyntaxNode VisitParameterList(ParameterListSyntax node)
            => node.Update((SyntaxToken)Visit(node.OpenParenToken), VisitList(node.Parameters), (SyntaxToken)Visit(node.CloseParenToken));

        public override CSharpSyntaxNode VisitBracketedParameterList(BracketedParameterListSyntax node)
            => node.Update((SyntaxToken)Visit(node.OpenBracketToken), VisitList(node.Parameters), (SyntaxToken)Visit(node.CloseBracketToken));

        public override CSharpSyntaxNode VisitParameter(ParameterSyntax node)
            => node.Update(VisitList(node.AttributeLists), VisitList(node.Modifiers), (TypeSyntax)Visit(node.Type), (SyntaxToken)Visit(node.Identifier), (EqualsValueClauseSyntax)Visit(node.Default));

        public override CSharpSyntaxNode VisitFunctionPointerParameter(FunctionPointerParameterSyntax node)
            => node.Update(VisitList(node.AttributeLists), VisitList(node.Modifiers), (TypeSyntax)Visit(node.Type));

        public override CSharpSyntaxNode VisitIncompleteMember(IncompleteMemberSyntax node)
            => node.Update(VisitList(node.AttributeLists), VisitList(node.Modifiers), (TypeSyntax)Visit(node.Type));

        public override CSharpSyntaxNode VisitSkippedTokensTrivia(SkippedTokensTriviaSyntax node)
            => node.Update(VisitList(node.Tokens));

        public override CSharpSyntaxNode VisitDocumentationCommentTrivia(DocumentationCommentTriviaSyntax node)
            => node.Update(VisitList(node.Content), (SyntaxToken)Visit(node.EndOfComment));

        public override CSharpSyntaxNode VisitTypeCref(TypeCrefSyntax node)
            => node.Update((TypeSyntax)Visit(node.Type));

        public override CSharpSyntaxNode VisitQualifiedCref(QualifiedCrefSyntax node)
            => node.Update((TypeSyntax)Visit(node.Container), (SyntaxToken)Visit(node.DotToken), (MemberCrefSyntax)Visit(node.Member));

        public override CSharpSyntaxNode VisitNameMemberCref(NameMemberCrefSyntax node)
            => node.Update((TypeSyntax)Visit(node.Name), (CrefParameterListSyntax)Visit(node.Parameters));

        public override CSharpSyntaxNode VisitIndexerMemberCref(IndexerMemberCrefSyntax node)
            => node.Update((SyntaxToken)Visit(node.ThisKeyword), (CrefBracketedParameterListSyntax)Visit(node.Parameters));

        public override CSharpSyntaxNode VisitOperatorMemberCref(OperatorMemberCrefSyntax node)
            => node.Update((SyntaxToken)Visit(node.OperatorKeyword), (SyntaxToken)Visit(node.OperatorToken), (CrefParameterListSyntax)Visit(node.Parameters));

        public override CSharpSyntaxNode VisitConversionOperatorMemberCref(ConversionOperatorMemberCrefSyntax node)
            => node.Update((SyntaxToken)Visit(node.ImplicitOrExplicitKeyword), (SyntaxToken)Visit(node.OperatorKeyword), (TypeSyntax)Visit(node.Type), (CrefParameterListSyntax)Visit(node.Parameters));

        public override CSharpSyntaxNode VisitCrefParameterList(CrefParameterListSyntax node)
            => node.Update((SyntaxToken)Visit(node.OpenParenToken), VisitList(node.Parameters), (SyntaxToken)Visit(node.CloseParenToken));

        public override CSharpSyntaxNode VisitCrefBracketedParameterList(CrefBracketedParameterListSyntax node)
            => node.Update((SyntaxToken)Visit(node.OpenBracketToken), VisitList(node.Parameters), (SyntaxToken)Visit(node.CloseBracketToken));

        public override CSharpSyntaxNode VisitCrefParameter(CrefParameterSyntax node)
            => node.Update((SyntaxToken)Visit(node.RefKindKeyword), (TypeSyntax)Visit(node.Type));

        public override CSharpSyntaxNode VisitXmlElement(XmlElementSyntax node)
            => node.Update((XmlElementStartTagSyntax)Visit(node.StartTag), VisitList(node.Content), (XmlElementEndTagSyntax)Visit(node.EndTag));

        public override CSharpSyntaxNode VisitXmlElementStartTag(XmlElementStartTagSyntax node)
            => node.Update((SyntaxToken)Visit(node.LessThanToken), (XmlNameSyntax)Visit(node.Name), VisitList(node.Attributes), (SyntaxToken)Visit(node.GreaterThanToken));

        public override CSharpSyntaxNode VisitXmlElementEndTag(XmlElementEndTagSyntax node)
            => node.Update((SyntaxToken)Visit(node.LessThanSlashToken), (XmlNameSyntax)Visit(node.Name), (SyntaxToken)Visit(node.GreaterThanToken));

        public override CSharpSyntaxNode VisitXmlEmptyElement(XmlEmptyElementSyntax node)
            => node.Update((SyntaxToken)Visit(node.LessThanToken), (XmlNameSyntax)Visit(node.Name), VisitList(node.Attributes), (SyntaxToken)Visit(node.SlashGreaterThanToken));

        public override CSharpSyntaxNode VisitXmlName(XmlNameSyntax node)
            => node.Update((XmlPrefixSyntax)Visit(node.Prefix), (SyntaxToken)Visit(node.LocalName));

        public override CSharpSyntaxNode VisitXmlPrefix(XmlPrefixSyntax node)
            => node.Update((SyntaxToken)Visit(node.Prefix), (SyntaxToken)Visit(node.ColonToken));

        public override CSharpSyntaxNode VisitXmlTextAttribute(XmlTextAttributeSyntax node)
            => node.Update((XmlNameSyntax)Visit(node.Name), (SyntaxToken)Visit(node.EqualsToken), (SyntaxToken)Visit(node.StartQuoteToken), VisitList(node.TextTokens), (SyntaxToken)Visit(node.EndQuoteToken));

        public override CSharpSyntaxNode VisitXmlCrefAttribute(XmlCrefAttributeSyntax node)
            => node.Update((XmlNameSyntax)Visit(node.Name), (SyntaxToken)Visit(node.EqualsToken), (SyntaxToken)Visit(node.StartQuoteToken), (CrefSyntax)Visit(node.Cref), (SyntaxToken)Visit(node.EndQuoteToken));

        public override CSharpSyntaxNode VisitXmlNameAttribute(XmlNameAttributeSyntax node)
            => node.Update((XmlNameSyntax)Visit(node.Name), (SyntaxToken)Visit(node.EqualsToken), (SyntaxToken)Visit(node.StartQuoteToken), (IdentifierNameSyntax)Visit(node.Identifier), (SyntaxToken)Visit(node.EndQuoteToken));

        public override CSharpSyntaxNode VisitXmlText(XmlTextSyntax node)
            => node.Update(VisitList(node.TextTokens));

        public override CSharpSyntaxNode VisitXmlCDataSection(XmlCDataSectionSyntax node)
            => node.Update((SyntaxToken)Visit(node.StartCDataToken), VisitList(node.TextTokens), (SyntaxToken)Visit(node.EndCDataToken));

        public override CSharpSyntaxNode VisitXmlProcessingInstruction(XmlProcessingInstructionSyntax node)
            => node.Update((SyntaxToken)Visit(node.StartProcessingInstructionToken), (XmlNameSyntax)Visit(node.Name), VisitList(node.TextTokens), (SyntaxToken)Visit(node.EndProcessingInstructionToken));

        public override CSharpSyntaxNode VisitXmlComment(XmlCommentSyntax node)
            => node.Update((SyntaxToken)Visit(node.LessThanExclamationMinusMinusToken), VisitList(node.TextTokens), (SyntaxToken)Visit(node.MinusMinusGreaterThanToken));

        public override CSharpSyntaxNode VisitIfDirectiveTrivia(IfDirectiveTriviaSyntax node)
            => node.Update((SyntaxToken)Visit(node.HashToken), (SyntaxToken)Visit(node.IfKeyword), (ExpressionSyntax)Visit(node.Condition), (SyntaxToken)Visit(node.EndOfDirectiveToken), node.IsActive, node.BranchTaken, node.ConditionValue);

        public override CSharpSyntaxNode VisitElifDirectiveTrivia(ElifDirectiveTriviaSyntax node)
            => node.Update((SyntaxToken)Visit(node.HashToken), (SyntaxToken)Visit(node.ElifKeyword), (ExpressionSyntax)Visit(node.Condition), (SyntaxToken)Visit(node.EndOfDirectiveToken), node.IsActive, node.BranchTaken, node.ConditionValue);

        public override CSharpSyntaxNode VisitElseDirectiveTrivia(ElseDirectiveTriviaSyntax node)
            => node.Update((SyntaxToken)Visit(node.HashToken), (SyntaxToken)Visit(node.ElseKeyword), (SyntaxToken)Visit(node.EndOfDirectiveToken), node.IsActive, node.BranchTaken);

        public override CSharpSyntaxNode VisitEndIfDirectiveTrivia(EndIfDirectiveTriviaSyntax node)
            => node.Update((SyntaxToken)Visit(node.HashToken), (SyntaxToken)Visit(node.EndIfKeyword), (SyntaxToken)Visit(node.EndOfDirectiveToken), node.IsActive);

        public override CSharpSyntaxNode VisitRegionDirectiveTrivia(RegionDirectiveTriviaSyntax node)
            => node.Update((SyntaxToken)Visit(node.HashToken), (SyntaxToken)Visit(node.RegionKeyword), (SyntaxToken)Visit(node.EndOfDirectiveToken), node.IsActive);

        public override CSharpSyntaxNode VisitEndRegionDirectiveTrivia(EndRegionDirectiveTriviaSyntax node)
            => node.Update((SyntaxToken)Visit(node.HashToken), (SyntaxToken)Visit(node.EndRegionKeyword), (SyntaxToken)Visit(node.EndOfDirectiveToken), node.IsActive);

        public override CSharpSyntaxNode VisitErrorDirectiveTrivia(ErrorDirectiveTriviaSyntax node)
            => node.Update((SyntaxToken)Visit(node.HashToken), (SyntaxToken)Visit(node.ErrorKeyword), (SyntaxToken)Visit(node.EndOfDirectiveToken), node.IsActive);

        public override CSharpSyntaxNode VisitWarningDirectiveTrivia(WarningDirectiveTriviaSyntax node)
            => node.Update((SyntaxToken)Visit(node.HashToken), (SyntaxToken)Visit(node.WarningKeyword), (SyntaxToken)Visit(node.EndOfDirectiveToken), node.IsActive);

        public override CSharpSyntaxNode VisitBadDirectiveTrivia(BadDirectiveTriviaSyntax node)
            => node.Update((SyntaxToken)Visit(node.HashToken), (SyntaxToken)Visit(node.Identifier), (SyntaxToken)Visit(node.EndOfDirectiveToken), node.IsActive);

        public override CSharpSyntaxNode VisitDefineDirectiveTrivia(DefineDirectiveTriviaSyntax node)
            => node.Update((SyntaxToken)Visit(node.HashToken), (SyntaxToken)Visit(node.DefineKeyword), (SyntaxToken)Visit(node.Name), (SyntaxToken)Visit(node.EndOfDirectiveToken), node.IsActive);

        public override CSharpSyntaxNode VisitUndefDirectiveTrivia(UndefDirectiveTriviaSyntax node)
            => node.Update((SyntaxToken)Visit(node.HashToken), (SyntaxToken)Visit(node.UndefKeyword), (SyntaxToken)Visit(node.Name), (SyntaxToken)Visit(node.EndOfDirectiveToken), node.IsActive);

        public override CSharpSyntaxNode VisitLineDirectiveTrivia(LineDirectiveTriviaSyntax node)
            => node.Update((SyntaxToken)Visit(node.HashToken), (SyntaxToken)Visit(node.LineKeyword), (SyntaxToken)Visit(node.Line), (SyntaxToken)Visit(node.File), (SyntaxToken)Visit(node.EndOfDirectiveToken), node.IsActive);

        public override CSharpSyntaxNode VisitPragmaWarningDirectiveTrivia(PragmaWarningDirectiveTriviaSyntax node)
            => node.Update((SyntaxToken)Visit(node.HashToken), (SyntaxToken)Visit(node.PragmaKeyword), (SyntaxToken)Visit(node.WarningKeyword), (SyntaxToken)Visit(node.DisableOrRestoreKeyword), VisitList(node.ErrorCodes), (SyntaxToken)Visit(node.EndOfDirectiveToken), node.IsActive);

        public override CSharpSyntaxNode VisitPragmaChecksumDirectiveTrivia(PragmaChecksumDirectiveTriviaSyntax node)
            => node.Update((SyntaxToken)Visit(node.HashToken), (SyntaxToken)Visit(node.PragmaKeyword), (SyntaxToken)Visit(node.ChecksumKeyword), (SyntaxToken)Visit(node.File), (SyntaxToken)Visit(node.Guid), (SyntaxToken)Visit(node.Bytes), (SyntaxToken)Visit(node.EndOfDirectiveToken), node.IsActive);

        public override CSharpSyntaxNode VisitReferenceDirectiveTrivia(ReferenceDirectiveTriviaSyntax node)
            => node.Update((SyntaxToken)Visit(node.HashToken), (SyntaxToken)Visit(node.ReferenceKeyword), (SyntaxToken)Visit(node.File), (SyntaxToken)Visit(node.EndOfDirectiveToken), node.IsActive);

        public override CSharpSyntaxNode VisitLoadDirectiveTrivia(LoadDirectiveTriviaSyntax node)
            => node.Update((SyntaxToken)Visit(node.HashToken), (SyntaxToken)Visit(node.LoadKeyword), (SyntaxToken)Visit(node.File), (SyntaxToken)Visit(node.EndOfDirectiveToken), node.IsActive);

        public override CSharpSyntaxNode VisitShebangDirectiveTrivia(ShebangDirectiveTriviaSyntax node)
            => node.Update((SyntaxToken)Visit(node.HashToken), (SyntaxToken)Visit(node.ExclamationToken), (SyntaxToken)Visit(node.EndOfDirectiveToken), node.IsActive);

        public override CSharpSyntaxNode VisitNullableDirectiveTrivia(NullableDirectiveTriviaSyntax node)
            => node.Update((SyntaxToken)Visit(node.HashToken), (SyntaxToken)Visit(node.NullableKeyword), (SyntaxToken)Visit(node.SettingToken), (SyntaxToken)Visit(node.TargetToken), (SyntaxToken)Visit(node.EndOfDirectiveToken), node.IsActive);
    }

    internal partial class ContextAwareSyntax
    {
        private SyntaxFactoryContext context;

        public ContextAwareSyntax(SyntaxFactoryContext context)
            => this.context = context;

        public IdentifierNameSyntax IdentifierName(SyntaxToken identifier)
        {
#if DEBUG
            if (identifier == null) throw new ArgumentNullException(nameof(identifier));
            switch (identifier.Kind)
            {
                case SyntaxKind.IdentifierToken:
                case SyntaxKind.GlobalKeyword: break;
                default: throw new ArgumentException(nameof(identifier));
            }
#endif

            int hash;
            var cached = CSharpSyntaxNodeCache.TryGetNode((int)SyntaxKind.IdentifierName, identifier, this.context, out hash);
            if (cached != null) return (IdentifierNameSyntax)cached;

            var result = new IdentifierNameSyntax(SyntaxKind.IdentifierName, identifier, this.context);
            if (hash >= 0)
            {
                SyntaxNodeCache.AddNode(result, hash);
            }

            return result;
        }

        public QualifiedNameSyntax QualifiedName(NameSyntax left, SyntaxToken dotToken, SimpleNameSyntax right)
        {
#if DEBUG
            if (left == null) throw new ArgumentNullException(nameof(left));
            if (dotToken == null) throw new ArgumentNullException(nameof(dotToken));
            if (dotToken.Kind != SyntaxKind.DotToken) throw new ArgumentException(nameof(dotToken));
            if (right == null) throw new ArgumentNullException(nameof(right));
#endif

            int hash;
            var cached = CSharpSyntaxNodeCache.TryGetNode((int)SyntaxKind.QualifiedName, left, dotToken, right, this.context, out hash);
            if (cached != null) return (QualifiedNameSyntax)cached;

            var result = new QualifiedNameSyntax(SyntaxKind.QualifiedName, left, dotToken, right, this.context);
            if (hash >= 0)
            {
                SyntaxNodeCache.AddNode(result, hash);
            }

            return result;
        }

        public GenericNameSyntax GenericName(SyntaxToken identifier, TypeArgumentListSyntax typeArgumentList)
        {
#if DEBUG
            if (identifier == null) throw new ArgumentNullException(nameof(identifier));
            if (identifier.Kind != SyntaxKind.IdentifierToken) throw new ArgumentException(nameof(identifier));
            if (typeArgumentList == null) throw new ArgumentNullException(nameof(typeArgumentList));
#endif

            int hash;
            var cached = CSharpSyntaxNodeCache.TryGetNode((int)SyntaxKind.GenericName, identifier, typeArgumentList, this.context, out hash);
            if (cached != null) return (GenericNameSyntax)cached;

            var result = new GenericNameSyntax(SyntaxKind.GenericName, identifier, typeArgumentList, this.context);
            if (hash >= 0)
            {
                SyntaxNodeCache.AddNode(result, hash);
            }

            return result;
        }

        public TypeArgumentListSyntax TypeArgumentList(SyntaxToken lessThanToken, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<TypeSyntax> arguments, SyntaxToken greaterThanToken)
        {
#if DEBUG
            if (lessThanToken == null) throw new ArgumentNullException(nameof(lessThanToken));
            if (lessThanToken.Kind != SyntaxKind.LessThanToken) throw new ArgumentException(nameof(lessThanToken));
            if (greaterThanToken == null) throw new ArgumentNullException(nameof(greaterThanToken));
            if (greaterThanToken.Kind != SyntaxKind.GreaterThanToken) throw new ArgumentException(nameof(greaterThanToken));
#endif

            int hash;
            var cached = CSharpSyntaxNodeCache.TryGetNode((int)SyntaxKind.TypeArgumentList, lessThanToken, arguments.Node, greaterThanToken, this.context, out hash);
            if (cached != null) return (TypeArgumentListSyntax)cached;

            var result = new TypeArgumentListSyntax(SyntaxKind.TypeArgumentList, lessThanToken, arguments.Node, greaterThanToken, this.context);
            if (hash >= 0)
            {
                SyntaxNodeCache.AddNode(result, hash);
            }

            return result;
        }

        public AliasQualifiedNameSyntax AliasQualifiedName(IdentifierNameSyntax alias, SyntaxToken colonColonToken, SimpleNameSyntax name)
        {
#if DEBUG
            if (alias == null) throw new ArgumentNullException(nameof(alias));
            if (colonColonToken == null) throw new ArgumentNullException(nameof(colonColonToken));
            if (colonColonToken.Kind != SyntaxKind.ColonColonToken) throw new ArgumentException(nameof(colonColonToken));
            if (name == null) throw new ArgumentNullException(nameof(name));
#endif

            int hash;
            var cached = CSharpSyntaxNodeCache.TryGetNode((int)SyntaxKind.AliasQualifiedName, alias, colonColonToken, name, this.context, out hash);
            if (cached != null) return (AliasQualifiedNameSyntax)cached;

            var result = new AliasQualifiedNameSyntax(SyntaxKind.AliasQualifiedName, alias, colonColonToken, name, this.context);
            if (hash >= 0)
            {
                SyntaxNodeCache.AddNode(result, hash);
            }

            return result;
        }

        public PredefinedTypeSyntax PredefinedType(SyntaxToken keyword)
        {
#if DEBUG
            if (keyword == null) throw new ArgumentNullException(nameof(keyword));
            switch (keyword.Kind)
            {
                case SyntaxKind.BoolKeyword:
                case SyntaxKind.ByteKeyword:
                case SyntaxKind.SByteKeyword:
                case SyntaxKind.IntKeyword:
                case SyntaxKind.UIntKeyword:
                case SyntaxKind.ShortKeyword:
                case SyntaxKind.UShortKeyword:
                case SyntaxKind.LongKeyword:
                case SyntaxKind.ULongKeyword:
                case SyntaxKind.FloatKeyword:
                case SyntaxKind.DoubleKeyword:
                case SyntaxKind.DecimalKeyword:
                case SyntaxKind.StringKeyword:
                case SyntaxKind.CharKeyword:
                case SyntaxKind.ObjectKeyword:
                case SyntaxKind.VoidKeyword: break;
                default: throw new ArgumentException(nameof(keyword));
            }
#endif

            int hash;
            var cached = CSharpSyntaxNodeCache.TryGetNode((int)SyntaxKind.PredefinedType, keyword, this.context, out hash);
            if (cached != null) return (PredefinedTypeSyntax)cached;

            var result = new PredefinedTypeSyntax(SyntaxKind.PredefinedType, keyword, this.context);
            if (hash >= 0)
            {
                SyntaxNodeCache.AddNode(result, hash);
            }

            return result;
        }

        public ArrayTypeSyntax ArrayType(TypeSyntax elementType, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<ArrayRankSpecifierSyntax> rankSpecifiers)
        {
#if DEBUG
            if (elementType == null) throw new ArgumentNullException(nameof(elementType));
#endif

            int hash;
            var cached = CSharpSyntaxNodeCache.TryGetNode((int)SyntaxKind.ArrayType, elementType, rankSpecifiers.Node, this.context, out hash);
            if (cached != null) return (ArrayTypeSyntax)cached;

            var result = new ArrayTypeSyntax(SyntaxKind.ArrayType, elementType, rankSpecifiers.Node, this.context);
            if (hash >= 0)
            {
                SyntaxNodeCache.AddNode(result, hash);
            }

            return result;
        }

        public ArrayRankSpecifierSyntax ArrayRankSpecifier(SyntaxToken openBracketToken, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<ExpressionSyntax> sizes, SyntaxToken closeBracketToken)
        {
#if DEBUG
            if (openBracketToken == null) throw new ArgumentNullException(nameof(openBracketToken));
            if (openBracketToken.Kind != SyntaxKind.OpenBracketToken) throw new ArgumentException(nameof(openBracketToken));
            if (closeBracketToken == null) throw new ArgumentNullException(nameof(closeBracketToken));
            if (closeBracketToken.Kind != SyntaxKind.CloseBracketToken) throw new ArgumentException(nameof(closeBracketToken));
#endif

            int hash;
            var cached = CSharpSyntaxNodeCache.TryGetNode((int)SyntaxKind.ArrayRankSpecifier, openBracketToken, sizes.Node, closeBracketToken, this.context, out hash);
            if (cached != null) return (ArrayRankSpecifierSyntax)cached;

            var result = new ArrayRankSpecifierSyntax(SyntaxKind.ArrayRankSpecifier, openBracketToken, sizes.Node, closeBracketToken, this.context);
            if (hash >= 0)
            {
                SyntaxNodeCache.AddNode(result, hash);
            }

            return result;
        }

        public PointerTypeSyntax PointerType(TypeSyntax elementType, SyntaxToken asteriskToken)
        {
#if DEBUG
            if (elementType == null) throw new ArgumentNullException(nameof(elementType));
            if (asteriskToken == null) throw new ArgumentNullException(nameof(asteriskToken));
            if (asteriskToken.Kind != SyntaxKind.AsteriskToken) throw new ArgumentException(nameof(asteriskToken));
#endif

            int hash;
            var cached = CSharpSyntaxNodeCache.TryGetNode((int)SyntaxKind.PointerType, elementType, asteriskToken, this.context, out hash);
            if (cached != null) return (PointerTypeSyntax)cached;

            var result = new PointerTypeSyntax(SyntaxKind.PointerType, elementType, asteriskToken, this.context);
            if (hash >= 0)
            {
                SyntaxNodeCache.AddNode(result, hash);
            }

            return result;
        }

        public FunctionPointerTypeSyntax FunctionPointerType(SyntaxToken delegateKeyword, SyntaxToken asteriskToken, FunctionPointerCallingConventionSyntax? callingConvention, FunctionPointerParameterListSyntax parameterList)
        {
#if DEBUG
            if (delegateKeyword == null) throw new ArgumentNullException(nameof(delegateKeyword));
            if (delegateKeyword.Kind != SyntaxKind.DelegateKeyword) throw new ArgumentException(nameof(delegateKeyword));
            if (asteriskToken == null) throw new ArgumentNullException(nameof(asteriskToken));
            if (asteriskToken.Kind != SyntaxKind.AsteriskToken) throw new ArgumentException(nameof(asteriskToken));
            if (parameterList == null) throw new ArgumentNullException(nameof(parameterList));
#endif

            return new FunctionPointerTypeSyntax(SyntaxKind.FunctionPointerType, delegateKeyword, asteriskToken, callingConvention, parameterList, this.context);
        }

        public FunctionPointerParameterListSyntax FunctionPointerParameterList(SyntaxToken lessThanToken, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<FunctionPointerParameterSyntax> parameters, SyntaxToken greaterThanToken)
        {
#if DEBUG
            if (lessThanToken == null) throw new ArgumentNullException(nameof(lessThanToken));
            if (lessThanToken.Kind != SyntaxKind.LessThanToken) throw new ArgumentException(nameof(lessThanToken));
            if (greaterThanToken == null) throw new ArgumentNullException(nameof(greaterThanToken));
            if (greaterThanToken.Kind != SyntaxKind.GreaterThanToken) throw new ArgumentException(nameof(greaterThanToken));
#endif

            int hash;
            var cached = CSharpSyntaxNodeCache.TryGetNode((int)SyntaxKind.FunctionPointerParameterList, lessThanToken, parameters.Node, greaterThanToken, this.context, out hash);
            if (cached != null) return (FunctionPointerParameterListSyntax)cached;

            var result = new FunctionPointerParameterListSyntax(SyntaxKind.FunctionPointerParameterList, lessThanToken, parameters.Node, greaterThanToken, this.context);
            if (hash >= 0)
            {
                SyntaxNodeCache.AddNode(result, hash);
            }

            return result;
        }

        public FunctionPointerCallingConventionSyntax FunctionPointerCallingConvention(SyntaxToken managedOrUnmanagedKeyword, FunctionPointerUnmanagedCallingConventionListSyntax? unmanagedCallingConventionList)
        {
#if DEBUG
            if (managedOrUnmanagedKeyword == null) throw new ArgumentNullException(nameof(managedOrUnmanagedKeyword));
            switch (managedOrUnmanagedKeyword.Kind)
            {
                case SyntaxKind.ManagedKeyword:
                case SyntaxKind.UnmanagedKeyword: break;
                default: throw new ArgumentException(nameof(managedOrUnmanagedKeyword));
            }
#endif

            int hash;
            var cached = CSharpSyntaxNodeCache.TryGetNode((int)SyntaxKind.FunctionPointerCallingConvention, managedOrUnmanagedKeyword, unmanagedCallingConventionList, this.context, out hash);
            if (cached != null) return (FunctionPointerCallingConventionSyntax)cached;

            var result = new FunctionPointerCallingConventionSyntax(SyntaxKind.FunctionPointerCallingConvention, managedOrUnmanagedKeyword, unmanagedCallingConventionList, this.context);
            if (hash >= 0)
            {
                SyntaxNodeCache.AddNode(result, hash);
            }

            return result;
        }

        public FunctionPointerUnmanagedCallingConventionListSyntax FunctionPointerUnmanagedCallingConventionList(SyntaxToken openBracketToken, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<FunctionPointerUnmanagedCallingConventionSyntax> callingConventions, SyntaxToken closeBracketToken)
        {
#if DEBUG
            if (openBracketToken == null) throw new ArgumentNullException(nameof(openBracketToken));
            if (openBracketToken.Kind != SyntaxKind.OpenBracketToken) throw new ArgumentException(nameof(openBracketToken));
            if (closeBracketToken == null) throw new ArgumentNullException(nameof(closeBracketToken));
            if (closeBracketToken.Kind != SyntaxKind.CloseBracketToken) throw new ArgumentException(nameof(closeBracketToken));
#endif

            int hash;
            var cached = CSharpSyntaxNodeCache.TryGetNode((int)SyntaxKind.FunctionPointerUnmanagedCallingConventionList, openBracketToken, callingConventions.Node, closeBracketToken, this.context, out hash);
            if (cached != null) return (FunctionPointerUnmanagedCallingConventionListSyntax)cached;

            var result = new FunctionPointerUnmanagedCallingConventionListSyntax(SyntaxKind.FunctionPointerUnmanagedCallingConventionList, openBracketToken, callingConventions.Node, closeBracketToken, this.context);
            if (hash >= 0)
            {
                SyntaxNodeCache.AddNode(result, hash);
            }

            return result;
        }

        public FunctionPointerUnmanagedCallingConventionSyntax FunctionPointerUnmanagedCallingConvention(SyntaxToken name)
        {
#if DEBUG
            if (name == null) throw new ArgumentNullException(nameof(name));
            if (name.Kind != SyntaxKind.IdentifierToken) throw new ArgumentException(nameof(name));
#endif

            int hash;
            var cached = CSharpSyntaxNodeCache.TryGetNode((int)SyntaxKind.FunctionPointerUnmanagedCallingConvention, name, this.context, out hash);
            if (cached != null) return (FunctionPointerUnmanagedCallingConventionSyntax)cached;

            var result = new FunctionPointerUnmanagedCallingConventionSyntax(SyntaxKind.FunctionPointerUnmanagedCallingConvention, name, this.context);
            if (hash >= 0)
            {
                SyntaxNodeCache.AddNode(result, hash);
            }

            return result;
        }

        public NullableTypeSyntax NullableType(TypeSyntax elementType, SyntaxToken questionToken)
        {
#if DEBUG
            if (elementType == null) throw new ArgumentNullException(nameof(elementType));
            if (questionToken == null) throw new ArgumentNullException(nameof(questionToken));
            if (questionToken.Kind != SyntaxKind.QuestionToken) throw new ArgumentException(nameof(questionToken));
#endif

            int hash;
            var cached = CSharpSyntaxNodeCache.TryGetNode((int)SyntaxKind.NullableType, elementType, questionToken, this.context, out hash);
            if (cached != null) return (NullableTypeSyntax)cached;

            var result = new NullableTypeSyntax(SyntaxKind.NullableType, elementType, questionToken, this.context);
            if (hash >= 0)
            {
                SyntaxNodeCache.AddNode(result, hash);
            }

            return result;
        }

        public TupleTypeSyntax TupleType(SyntaxToken openParenToken, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<TupleElementSyntax> elements, SyntaxToken closeParenToken)
        {
#if DEBUG
            if (openParenToken == null) throw new ArgumentNullException(nameof(openParenToken));
            if (openParenToken.Kind != SyntaxKind.OpenParenToken) throw new ArgumentException(nameof(openParenToken));
            if (closeParenToken == null) throw new ArgumentNullException(nameof(closeParenToken));
            if (closeParenToken.Kind != SyntaxKind.CloseParenToken) throw new ArgumentException(nameof(closeParenToken));
#endif

            int hash;
            var cached = CSharpSyntaxNodeCache.TryGetNode((int)SyntaxKind.TupleType, openParenToken, elements.Node, closeParenToken, this.context, out hash);
            if (cached != null) return (TupleTypeSyntax)cached;

            var result = new TupleTypeSyntax(SyntaxKind.TupleType, openParenToken, elements.Node, closeParenToken, this.context);
            if (hash >= 0)
            {
                SyntaxNodeCache.AddNode(result, hash);
            }

            return result;
        }

        public TupleElementSyntax TupleElement(TypeSyntax type, SyntaxToken? identifier)
        {
#if DEBUG
            if (type == null) throw new ArgumentNullException(nameof(type));
            if (identifier != null)
            {
                switch (identifier.Kind)
                {
                    case SyntaxKind.IdentifierToken:
                    case SyntaxKind.None: break;
                    default: throw new ArgumentException(nameof(identifier));
                }
            }
#endif

            int hash;
            var cached = CSharpSyntaxNodeCache.TryGetNode((int)SyntaxKind.TupleElement, type, identifier, this.context, out hash);
            if (cached != null) return (TupleElementSyntax)cached;

            var result = new TupleElementSyntax(SyntaxKind.TupleElement, type, identifier, this.context);
            if (hash >= 0)
            {
                SyntaxNodeCache.AddNode(result, hash);
            }

            return result;
        }

        public OmittedTypeArgumentSyntax OmittedTypeArgument(SyntaxToken omittedTypeArgumentToken)
        {
#if DEBUG
            if (omittedTypeArgumentToken == null) throw new ArgumentNullException(nameof(omittedTypeArgumentToken));
            if (omittedTypeArgumentToken.Kind != SyntaxKind.OmittedTypeArgumentToken) throw new ArgumentException(nameof(omittedTypeArgumentToken));
#endif

            int hash;
            var cached = CSharpSyntaxNodeCache.TryGetNode((int)SyntaxKind.OmittedTypeArgument, omittedTypeArgumentToken, this.context, out hash);
            if (cached != null) return (OmittedTypeArgumentSyntax)cached;

            var result = new OmittedTypeArgumentSyntax(SyntaxKind.OmittedTypeArgument, omittedTypeArgumentToken, this.context);
            if (hash >= 0)
            {
                SyntaxNodeCache.AddNode(result, hash);
            }

            return result;
        }

        public RefTypeSyntax RefType(SyntaxToken refKeyword, SyntaxToken? readOnlyKeyword, TypeSyntax type)
        {
#if DEBUG
            if (refKeyword == null) throw new ArgumentNullException(nameof(refKeyword));
            if (refKeyword.Kind != SyntaxKind.RefKeyword) throw new ArgumentException(nameof(refKeyword));
            if (readOnlyKeyword != null)
            {
                switch (readOnlyKeyword.Kind)
                {
                    case SyntaxKind.ReadOnlyKeyword:
                    case SyntaxKind.None: break;
                    default: throw new ArgumentException(nameof(readOnlyKeyword));
                }
            }
            if (type == null) throw new ArgumentNullException(nameof(type));
#endif

            int hash;
            var cached = CSharpSyntaxNodeCache.TryGetNode((int)SyntaxKind.RefType, refKeyword, readOnlyKeyword, type, this.context, out hash);
            if (cached != null) return (RefTypeSyntax)cached;

            var result = new RefTypeSyntax(SyntaxKind.RefType, refKeyword, readOnlyKeyword, type, this.context);
            if (hash >= 0)
            {
                SyntaxNodeCache.AddNode(result, hash);
            }

            return result;
        }

        public ParenthesizedExpressionSyntax ParenthesizedExpression(SyntaxToken openParenToken, ExpressionSyntax expression, SyntaxToken closeParenToken)
        {
#if DEBUG
            if (openParenToken == null) throw new ArgumentNullException(nameof(openParenToken));
            if (openParenToken.Kind != SyntaxKind.OpenParenToken) throw new ArgumentException(nameof(openParenToken));
            if (expression == null) throw new ArgumentNullException(nameof(expression));
            if (closeParenToken == null) throw new ArgumentNullException(nameof(closeParenToken));
            if (closeParenToken.Kind != SyntaxKind.CloseParenToken) throw new ArgumentException(nameof(closeParenToken));
#endif

            int hash;
            var cached = CSharpSyntaxNodeCache.TryGetNode((int)SyntaxKind.ParenthesizedExpression, openParenToken, expression, closeParenToken, this.context, out hash);
            if (cached != null) return (ParenthesizedExpressionSyntax)cached;

            var result = new ParenthesizedExpressionSyntax(SyntaxKind.ParenthesizedExpression, openParenToken, expression, closeParenToken, this.context);
            if (hash >= 0)
            {
                SyntaxNodeCache.AddNode(result, hash);
            }

            return result;
        }

        public TupleExpressionSyntax TupleExpression(SyntaxToken openParenToken, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<ArgumentSyntax> arguments, SyntaxToken closeParenToken)
        {
#if DEBUG
            if (openParenToken == null) throw new ArgumentNullException(nameof(openParenToken));
            if (openParenToken.Kind != SyntaxKind.OpenParenToken) throw new ArgumentException(nameof(openParenToken));
            if (closeParenToken == null) throw new ArgumentNullException(nameof(closeParenToken));
            if (closeParenToken.Kind != SyntaxKind.CloseParenToken) throw new ArgumentException(nameof(closeParenToken));
#endif

            int hash;
            var cached = CSharpSyntaxNodeCache.TryGetNode((int)SyntaxKind.TupleExpression, openParenToken, arguments.Node, closeParenToken, this.context, out hash);
            if (cached != null) return (TupleExpressionSyntax)cached;

            var result = new TupleExpressionSyntax(SyntaxKind.TupleExpression, openParenToken, arguments.Node, closeParenToken, this.context);
            if (hash >= 0)
            {
                SyntaxNodeCache.AddNode(result, hash);
            }

            return result;
        }

        public PrefixUnaryExpressionSyntax PrefixUnaryExpression(SyntaxKind kind, SyntaxToken operatorToken, ExpressionSyntax operand)
        {
            switch (kind)
            {
                case SyntaxKind.UnaryPlusExpression:
                case SyntaxKind.UnaryMinusExpression:
                case SyntaxKind.BitwiseNotExpression:
                case SyntaxKind.LogicalNotExpression:
                case SyntaxKind.PreIncrementExpression:
                case SyntaxKind.PreDecrementExpression:
                case SyntaxKind.AddressOfExpression:
                case SyntaxKind.PointerIndirectionExpression:
                case SyntaxKind.IndexExpression: break;
                default: throw new ArgumentException(nameof(kind));
            }
#if DEBUG
            if (operatorToken == null) throw new ArgumentNullException(nameof(operatorToken));
            switch (operatorToken.Kind)
            {
                case SyntaxKind.PlusToken:
                case SyntaxKind.MinusToken:
                case SyntaxKind.TildeToken:
                case SyntaxKind.ExclamationToken:
                case SyntaxKind.PlusPlusToken:
                case SyntaxKind.MinusMinusToken:
                case SyntaxKind.AmpersandToken:
                case SyntaxKind.AsteriskToken:
                case SyntaxKind.CaretToken: break;
                default: throw new ArgumentException(nameof(operatorToken));
            }
            if (operand == null) throw new ArgumentNullException(nameof(operand));
#endif

            int hash;
            var cached = CSharpSyntaxNodeCache.TryGetNode((int)kind, operatorToken, operand, this.context, out hash);
            if (cached != null) return (PrefixUnaryExpressionSyntax)cached;

            var result = new PrefixUnaryExpressionSyntax(kind, operatorToken, operand, this.context);
            if (hash >= 0)
            {
                SyntaxNodeCache.AddNode(result, hash);
            }

            return result;
        }

        public AwaitExpressionSyntax AwaitExpression(SyntaxToken awaitKeyword, ExpressionSyntax expression)
        {
#if DEBUG
            if (awaitKeyword == null) throw new ArgumentNullException(nameof(awaitKeyword));
            if (awaitKeyword.Kind != SyntaxKind.AwaitKeyword) throw new ArgumentException(nameof(awaitKeyword));
            if (expression == null) throw new ArgumentNullException(nameof(expression));
#endif

            int hash;
            var cached = CSharpSyntaxNodeCache.TryGetNode((int)SyntaxKind.AwaitExpression, awaitKeyword, expression, this.context, out hash);
            if (cached != null) return (AwaitExpressionSyntax)cached;

            var result = new AwaitExpressionSyntax(SyntaxKind.AwaitExpression, awaitKeyword, expression, this.context);
            if (hash >= 0)
            {
                SyntaxNodeCache.AddNode(result, hash);
            }

            return result;
        }

        public PostfixUnaryExpressionSyntax PostfixUnaryExpression(SyntaxKind kind, ExpressionSyntax operand, SyntaxToken operatorToken)
        {
            switch (kind)
            {
                case SyntaxKind.PostIncrementExpression:
                case SyntaxKind.PostDecrementExpression:
                case SyntaxKind.SuppressNullableWarningExpression: break;
                default: throw new ArgumentException(nameof(kind));
            }
#if DEBUG
            if (operand == null) throw new ArgumentNullException(nameof(operand));
            if (operatorToken == null) throw new ArgumentNullException(nameof(operatorToken));
            switch (operatorToken.Kind)
            {
                case SyntaxKind.PlusPlusToken:
                case SyntaxKind.MinusMinusToken:
                case SyntaxKind.ExclamationToken: break;
                default: throw new ArgumentException(nameof(operatorToken));
            }
#endif

            int hash;
            var cached = CSharpSyntaxNodeCache.TryGetNode((int)kind, operand, operatorToken, this.context, out hash);
            if (cached != null) return (PostfixUnaryExpressionSyntax)cached;

            var result = new PostfixUnaryExpressionSyntax(kind, operand, operatorToken, this.context);
            if (hash >= 0)
            {
                SyntaxNodeCache.AddNode(result, hash);
            }

            return result;
        }

        public MemberAccessExpressionSyntax MemberAccessExpression(SyntaxKind kind, ExpressionSyntax expression, SyntaxToken operatorToken, SimpleNameSyntax name)
        {
            switch (kind)
            {
                case SyntaxKind.SimpleMemberAccessExpression:
                case SyntaxKind.PointerMemberAccessExpression: break;
                default: throw new ArgumentException(nameof(kind));
            }
#if DEBUG
            if (expression == null) throw new ArgumentNullException(nameof(expression));
            if (operatorToken == null) throw new ArgumentNullException(nameof(operatorToken));
            switch (operatorToken.Kind)
            {
                case SyntaxKind.DotToken:
                case SyntaxKind.MinusGreaterThanToken: break;
                default: throw new ArgumentException(nameof(operatorToken));
            }
            if (name == null) throw new ArgumentNullException(nameof(name));
#endif

            int hash;
            var cached = CSharpSyntaxNodeCache.TryGetNode((int)kind, expression, operatorToken, name, this.context, out hash);
            if (cached != null) return (MemberAccessExpressionSyntax)cached;

            var result = new MemberAccessExpressionSyntax(kind, expression, operatorToken, name, this.context);
            if (hash >= 0)
            {
                SyntaxNodeCache.AddNode(result, hash);
            }

            return result;
        }

        public ConditionalAccessExpressionSyntax ConditionalAccessExpression(ExpressionSyntax expression, SyntaxToken operatorToken, ExpressionSyntax whenNotNull)
        {
#if DEBUG
            if (expression == null) throw new ArgumentNullException(nameof(expression));
            if (operatorToken == null) throw new ArgumentNullException(nameof(operatorToken));
            if (operatorToken.Kind != SyntaxKind.QuestionToken) throw new ArgumentException(nameof(operatorToken));
            if (whenNotNull == null) throw new ArgumentNullException(nameof(whenNotNull));
#endif

            int hash;
            var cached = CSharpSyntaxNodeCache.TryGetNode((int)SyntaxKind.ConditionalAccessExpression, expression, operatorToken, whenNotNull, this.context, out hash);
            if (cached != null) return (ConditionalAccessExpressionSyntax)cached;

            var result = new ConditionalAccessExpressionSyntax(SyntaxKind.ConditionalAccessExpression, expression, operatorToken, whenNotNull, this.context);
            if (hash >= 0)
            {
                SyntaxNodeCache.AddNode(result, hash);
            }

            return result;
        }

        public MemberBindingExpressionSyntax MemberBindingExpression(SyntaxToken operatorToken, SimpleNameSyntax name)
        {
#if DEBUG
            if (operatorToken == null) throw new ArgumentNullException(nameof(operatorToken));
            if (operatorToken.Kind != SyntaxKind.DotToken) throw new ArgumentException(nameof(operatorToken));
            if (name == null) throw new ArgumentNullException(nameof(name));
#endif

            int hash;
            var cached = CSharpSyntaxNodeCache.TryGetNode((int)SyntaxKind.MemberBindingExpression, operatorToken, name, this.context, out hash);
            if (cached != null) return (MemberBindingExpressionSyntax)cached;

            var result = new MemberBindingExpressionSyntax(SyntaxKind.MemberBindingExpression, operatorToken, name, this.context);
            if (hash >= 0)
            {
                SyntaxNodeCache.AddNode(result, hash);
            }

            return result;
        }

        public ElementBindingExpressionSyntax ElementBindingExpression(BracketedArgumentListSyntax argumentList)
        {
#if DEBUG
            if (argumentList == null) throw new ArgumentNullException(nameof(argumentList));
#endif

            int hash;
            var cached = CSharpSyntaxNodeCache.TryGetNode((int)SyntaxKind.ElementBindingExpression, argumentList, this.context, out hash);
            if (cached != null) return (ElementBindingExpressionSyntax)cached;

            var result = new ElementBindingExpressionSyntax(SyntaxKind.ElementBindingExpression, argumentList, this.context);
            if (hash >= 0)
            {
                SyntaxNodeCache.AddNode(result, hash);
            }

            return result;
        }

        public RangeExpressionSyntax RangeExpression(ExpressionSyntax? leftOperand, SyntaxToken operatorToken, ExpressionSyntax? rightOperand)
        {
#if DEBUG
            if (operatorToken == null) throw new ArgumentNullException(nameof(operatorToken));
            if (operatorToken.Kind != SyntaxKind.DotDotToken) throw new ArgumentException(nameof(operatorToken));
#endif

            int hash;
            var cached = CSharpSyntaxNodeCache.TryGetNode((int)SyntaxKind.RangeExpression, leftOperand, operatorToken, rightOperand, this.context, out hash);
            if (cached != null) return (RangeExpressionSyntax)cached;

            var result = new RangeExpressionSyntax(SyntaxKind.RangeExpression, leftOperand, operatorToken, rightOperand, this.context);
            if (hash >= 0)
            {
                SyntaxNodeCache.AddNode(result, hash);
            }

            return result;
        }

        public ImplicitElementAccessSyntax ImplicitElementAccess(BracketedArgumentListSyntax argumentList)
        {
#if DEBUG
            if (argumentList == null) throw new ArgumentNullException(nameof(argumentList));
#endif

            int hash;
            var cached = CSharpSyntaxNodeCache.TryGetNode((int)SyntaxKind.ImplicitElementAccess, argumentList, this.context, out hash);
            if (cached != null) return (ImplicitElementAccessSyntax)cached;

            var result = new ImplicitElementAccessSyntax(SyntaxKind.ImplicitElementAccess, argumentList, this.context);
            if (hash >= 0)
            {
                SyntaxNodeCache.AddNode(result, hash);
            }

            return result;
        }

        public BinaryExpressionSyntax BinaryExpression(SyntaxKind kind, ExpressionSyntax left, SyntaxToken operatorToken, ExpressionSyntax right)
        {
            switch (kind)
            {
                case SyntaxKind.AddExpression:
                case SyntaxKind.SubtractExpression:
                case SyntaxKind.MultiplyExpression:
                case SyntaxKind.DivideExpression:
                case SyntaxKind.ModuloExpression:
                case SyntaxKind.LeftShiftExpression:
                case SyntaxKind.RightShiftExpression:
                case SyntaxKind.LogicalOrExpression:
                case SyntaxKind.LogicalAndExpression:
                case SyntaxKind.BitwiseOrExpression:
                case SyntaxKind.BitwiseAndExpression:
                case SyntaxKind.ExclusiveOrExpression:
                case SyntaxKind.EqualsExpression:
                case SyntaxKind.NotEqualsExpression:
                case SyntaxKind.LessThanExpression:
                case SyntaxKind.LessThanOrEqualExpression:
                case SyntaxKind.GreaterThanExpression:
                case SyntaxKind.GreaterThanOrEqualExpression:
                case SyntaxKind.IsExpression:
                case SyntaxKind.AsExpression:
                case SyntaxKind.CoalesceExpression: break;
                default: throw new ArgumentException(nameof(kind));
            }
#if DEBUG
            if (left == null) throw new ArgumentNullException(nameof(left));
            if (operatorToken == null) throw new ArgumentNullException(nameof(operatorToken));
            switch (operatorToken.Kind)
            {
                case SyntaxKind.PlusToken:
                case SyntaxKind.MinusToken:
                case SyntaxKind.AsteriskToken:
                case SyntaxKind.SlashToken:
                case SyntaxKind.PercentToken:
                case SyntaxKind.LessThanLessThanToken:
                case SyntaxKind.GreaterThanGreaterThanToken:
                case SyntaxKind.BarBarToken:
                case SyntaxKind.AmpersandAmpersandToken:
                case SyntaxKind.BarToken:
                case SyntaxKind.AmpersandToken:
                case SyntaxKind.CaretToken:
                case SyntaxKind.EqualsEqualsToken:
                case SyntaxKind.ExclamationEqualsToken:
                case SyntaxKind.LessThanToken:
                case SyntaxKind.LessThanEqualsToken:
                case SyntaxKind.GreaterThanToken:
                case SyntaxKind.GreaterThanEqualsToken:
                case SyntaxKind.IsKeyword:
                case SyntaxKind.AsKeyword:
                case SyntaxKind.QuestionQuestionToken: break;
                default: throw new ArgumentException(nameof(operatorToken));
            }
            if (right == null) throw new ArgumentNullException(nameof(right));
#endif

            int hash;
            var cached = CSharpSyntaxNodeCache.TryGetNode((int)kind, left, operatorToken, right, this.context, out hash);
            if (cached != null) return (BinaryExpressionSyntax)cached;

            var result = new BinaryExpressionSyntax(kind, left, operatorToken, right, this.context);
            if (hash >= 0)
            {
                SyntaxNodeCache.AddNode(result, hash);
            }

            return result;
        }

        public AssignmentExpressionSyntax AssignmentExpression(SyntaxKind kind, ExpressionSyntax left, SyntaxToken operatorToken, ExpressionSyntax right)
        {
            switch (kind)
            {
                case SyntaxKind.SimpleAssignmentExpression:
                case SyntaxKind.AddAssignmentExpression:
                case SyntaxKind.SubtractAssignmentExpression:
                case SyntaxKind.MultiplyAssignmentExpression:
                case SyntaxKind.DivideAssignmentExpression:
                case SyntaxKind.ModuloAssignmentExpression:
                case SyntaxKind.AndAssignmentExpression:
                case SyntaxKind.ExclusiveOrAssignmentExpression:
                case SyntaxKind.OrAssignmentExpression:
                case SyntaxKind.LeftShiftAssignmentExpression:
                case SyntaxKind.RightShiftAssignmentExpression:
                case SyntaxKind.CoalesceAssignmentExpression: break;
                default: throw new ArgumentException(nameof(kind));
            }
#if DEBUG
            if (left == null) throw new ArgumentNullException(nameof(left));
            if (operatorToken == null) throw new ArgumentNullException(nameof(operatorToken));
            switch (operatorToken.Kind)
            {
                case SyntaxKind.EqualsToken:
                case SyntaxKind.PlusEqualsToken:
                case SyntaxKind.MinusEqualsToken:
                case SyntaxKind.AsteriskEqualsToken:
                case SyntaxKind.SlashEqualsToken:
                case SyntaxKind.PercentEqualsToken:
                case SyntaxKind.AmpersandEqualsToken:
                case SyntaxKind.CaretEqualsToken:
                case SyntaxKind.BarEqualsToken:
                case SyntaxKind.LessThanLessThanEqualsToken:
                case SyntaxKind.GreaterThanGreaterThanEqualsToken:
                case SyntaxKind.QuestionQuestionEqualsToken: break;
                default: throw new ArgumentException(nameof(operatorToken));
            }
            if (right == null) throw new ArgumentNullException(nameof(right));
#endif

            int hash;
            var cached = CSharpSyntaxNodeCache.TryGetNode((int)kind, left, operatorToken, right, this.context, out hash);
            if (cached != null) return (AssignmentExpressionSyntax)cached;

            var result = new AssignmentExpressionSyntax(kind, left, operatorToken, right, this.context);
            if (hash >= 0)
            {
                SyntaxNodeCache.AddNode(result, hash);
            }

            return result;
        }

        public ConditionalExpressionSyntax ConditionalExpression(ExpressionSyntax condition, SyntaxToken questionToken, ExpressionSyntax whenTrue, SyntaxToken colonToken, ExpressionSyntax whenFalse)
        {
#if DEBUG
            if (condition == null) throw new ArgumentNullException(nameof(condition));
            if (questionToken == null) throw new ArgumentNullException(nameof(questionToken));
            if (questionToken.Kind != SyntaxKind.QuestionToken) throw new ArgumentException(nameof(questionToken));
            if (whenTrue == null) throw new ArgumentNullException(nameof(whenTrue));
            if (colonToken == null) throw new ArgumentNullException(nameof(colonToken));
            if (colonToken.Kind != SyntaxKind.ColonToken) throw new ArgumentException(nameof(colonToken));
            if (whenFalse == null) throw new ArgumentNullException(nameof(whenFalse));
#endif

            return new ConditionalExpressionSyntax(SyntaxKind.ConditionalExpression, condition, questionToken, whenTrue, colonToken, whenFalse, this.context);
        }

        public ThisExpressionSyntax ThisExpression(SyntaxToken token)
        {
#if DEBUG
            if (token == null) throw new ArgumentNullException(nameof(token));
            if (token.Kind != SyntaxKind.ThisKeyword) throw new ArgumentException(nameof(token));
#endif

            int hash;
            var cached = CSharpSyntaxNodeCache.TryGetNode((int)SyntaxKind.ThisExpression, token, this.context, out hash);
            if (cached != null) return (ThisExpressionSyntax)cached;

            var result = new ThisExpressionSyntax(SyntaxKind.ThisExpression, token, this.context);
            if (hash >= 0)
            {
                SyntaxNodeCache.AddNode(result, hash);
            }

            return result;
        }

        public BaseExpressionSyntax BaseExpression(SyntaxToken token)
        {
#if DEBUG
            if (token == null) throw new ArgumentNullException(nameof(token));
            if (token.Kind != SyntaxKind.BaseKeyword) throw new ArgumentException(nameof(token));
#endif

            int hash;
            var cached = CSharpSyntaxNodeCache.TryGetNode((int)SyntaxKind.BaseExpression, token, this.context, out hash);
            if (cached != null) return (BaseExpressionSyntax)cached;

            var result = new BaseExpressionSyntax(SyntaxKind.BaseExpression, token, this.context);
            if (hash >= 0)
            {
                SyntaxNodeCache.AddNode(result, hash);
            }

            return result;
        }

        public LiteralExpressionSyntax LiteralExpression(SyntaxKind kind, SyntaxToken token)
        {
            switch (kind)
            {
                case SyntaxKind.ArgListExpression:
                case SyntaxKind.NumericLiteralExpression:
                case SyntaxKind.StringLiteralExpression:
                case SyntaxKind.CharacterLiteralExpression:
                case SyntaxKind.TrueLiteralExpression:
                case SyntaxKind.FalseLiteralExpression:
                case SyntaxKind.NullLiteralExpression:
                case SyntaxKind.DefaultLiteralExpression: break;
                default: throw new ArgumentException(nameof(kind));
            }
#if DEBUG
            if (token == null) throw new ArgumentNullException(nameof(token));
            switch (token.Kind)
            {
                case SyntaxKind.ArgListKeyword:
                case SyntaxKind.NumericLiteralToken:
                case SyntaxKind.StringLiteralToken:
                case SyntaxKind.CharacterLiteralToken:
                case SyntaxKind.TrueKeyword:
                case SyntaxKind.FalseKeyword:
                case SyntaxKind.NullKeyword:
                case SyntaxKind.DefaultKeyword: break;
                default: throw new ArgumentException(nameof(token));
            }
#endif

            int hash;
            var cached = CSharpSyntaxNodeCache.TryGetNode((int)kind, token, this.context, out hash);
            if (cached != null) return (LiteralExpressionSyntax)cached;

            var result = new LiteralExpressionSyntax(kind, token, this.context);
            if (hash >= 0)
            {
                SyntaxNodeCache.AddNode(result, hash);
            }

            return result;
        }

        public MakeRefExpressionSyntax MakeRefExpression(SyntaxToken keyword, SyntaxToken openParenToken, ExpressionSyntax expression, SyntaxToken closeParenToken)
        {
#if DEBUG
            if (keyword == null) throw new ArgumentNullException(nameof(keyword));
            if (keyword.Kind != SyntaxKind.MakeRefKeyword) throw new ArgumentException(nameof(keyword));
            if (openParenToken == null) throw new ArgumentNullException(nameof(openParenToken));
            if (openParenToken.Kind != SyntaxKind.OpenParenToken) throw new ArgumentException(nameof(openParenToken));
            if (expression == null) throw new ArgumentNullException(nameof(expression));
            if (closeParenToken == null) throw new ArgumentNullException(nameof(closeParenToken));
            if (closeParenToken.Kind != SyntaxKind.CloseParenToken) throw new ArgumentException(nameof(closeParenToken));
#endif

            return new MakeRefExpressionSyntax(SyntaxKind.MakeRefExpression, keyword, openParenToken, expression, closeParenToken, this.context);
        }

        public RefTypeExpressionSyntax RefTypeExpression(SyntaxToken keyword, SyntaxToken openParenToken, ExpressionSyntax expression, SyntaxToken closeParenToken)
        {
#if DEBUG
            if (keyword == null) throw new ArgumentNullException(nameof(keyword));
            if (keyword.Kind != SyntaxKind.RefTypeKeyword) throw new ArgumentException(nameof(keyword));
            if (openParenToken == null) throw new ArgumentNullException(nameof(openParenToken));
            if (openParenToken.Kind != SyntaxKind.OpenParenToken) throw new ArgumentException(nameof(openParenToken));
            if (expression == null) throw new ArgumentNullException(nameof(expression));
            if (closeParenToken == null) throw new ArgumentNullException(nameof(closeParenToken));
            if (closeParenToken.Kind != SyntaxKind.CloseParenToken) throw new ArgumentException(nameof(closeParenToken));
#endif

            return new RefTypeExpressionSyntax(SyntaxKind.RefTypeExpression, keyword, openParenToken, expression, closeParenToken, this.context);
        }

        public RefValueExpressionSyntax RefValueExpression(SyntaxToken keyword, SyntaxToken openParenToken, ExpressionSyntax expression, SyntaxToken comma, TypeSyntax type, SyntaxToken closeParenToken)
        {
#if DEBUG
            if (keyword == null) throw new ArgumentNullException(nameof(keyword));
            if (keyword.Kind != SyntaxKind.RefValueKeyword) throw new ArgumentException(nameof(keyword));
            if (openParenToken == null) throw new ArgumentNullException(nameof(openParenToken));
            if (openParenToken.Kind != SyntaxKind.OpenParenToken) throw new ArgumentException(nameof(openParenToken));
            if (expression == null) throw new ArgumentNullException(nameof(expression));
            if (comma == null) throw new ArgumentNullException(nameof(comma));
            if (comma.Kind != SyntaxKind.CommaToken) throw new ArgumentException(nameof(comma));
            if (type == null) throw new ArgumentNullException(nameof(type));
            if (closeParenToken == null) throw new ArgumentNullException(nameof(closeParenToken));
            if (closeParenToken.Kind != SyntaxKind.CloseParenToken) throw new ArgumentException(nameof(closeParenToken));
#endif

            return new RefValueExpressionSyntax(SyntaxKind.RefValueExpression, keyword, openParenToken, expression, comma, type, closeParenToken, this.context);
        }

        public CheckedExpressionSyntax CheckedExpression(SyntaxKind kind, SyntaxToken keyword, SyntaxToken openParenToken, ExpressionSyntax expression, SyntaxToken closeParenToken)
        {
            switch (kind)
            {
                case SyntaxKind.CheckedExpression:
                case SyntaxKind.UncheckedExpression: break;
                default: throw new ArgumentException(nameof(kind));
            }
#if DEBUG
            if (keyword == null) throw new ArgumentNullException(nameof(keyword));
            switch (keyword.Kind)
            {
                case SyntaxKind.CheckedKeyword:
                case SyntaxKind.UncheckedKeyword: break;
                default: throw new ArgumentException(nameof(keyword));
            }
            if (openParenToken == null) throw new ArgumentNullException(nameof(openParenToken));
            if (openParenToken.Kind != SyntaxKind.OpenParenToken) throw new ArgumentException(nameof(openParenToken));
            if (expression == null) throw new ArgumentNullException(nameof(expression));
            if (closeParenToken == null) throw new ArgumentNullException(nameof(closeParenToken));
            if (closeParenToken.Kind != SyntaxKind.CloseParenToken) throw new ArgumentException(nameof(closeParenToken));
#endif

            return new CheckedExpressionSyntax(kind, keyword, openParenToken, expression, closeParenToken, this.context);
        }

        public DefaultExpressionSyntax DefaultExpression(SyntaxToken keyword, SyntaxToken openParenToken, TypeSyntax type, SyntaxToken closeParenToken)
        {
#if DEBUG
            if (keyword == null) throw new ArgumentNullException(nameof(keyword));
            if (keyword.Kind != SyntaxKind.DefaultKeyword) throw new ArgumentException(nameof(keyword));
            if (openParenToken == null) throw new ArgumentNullException(nameof(openParenToken));
            if (openParenToken.Kind != SyntaxKind.OpenParenToken) throw new ArgumentException(nameof(openParenToken));
            if (type == null) throw new ArgumentNullException(nameof(type));
            if (closeParenToken == null) throw new ArgumentNullException(nameof(closeParenToken));
            if (closeParenToken.Kind != SyntaxKind.CloseParenToken) throw new ArgumentException(nameof(closeParenToken));
#endif

            return new DefaultExpressionSyntax(SyntaxKind.DefaultExpression, keyword, openParenToken, type, closeParenToken, this.context);
        }

        public TypeOfExpressionSyntax TypeOfExpression(SyntaxToken keyword, SyntaxToken openParenToken, TypeSyntax type, SyntaxToken closeParenToken)
        {
#if DEBUG
            if (keyword == null) throw new ArgumentNullException(nameof(keyword));
            if (keyword.Kind != SyntaxKind.TypeOfKeyword) throw new ArgumentException(nameof(keyword));
            if (openParenToken == null) throw new ArgumentNullException(nameof(openParenToken));
            if (openParenToken.Kind != SyntaxKind.OpenParenToken) throw new ArgumentException(nameof(openParenToken));
            if (type == null) throw new ArgumentNullException(nameof(type));
            if (closeParenToken == null) throw new ArgumentNullException(nameof(closeParenToken));
            if (closeParenToken.Kind != SyntaxKind.CloseParenToken) throw new ArgumentException(nameof(closeParenToken));
#endif

            return new TypeOfExpressionSyntax(SyntaxKind.TypeOfExpression, keyword, openParenToken, type, closeParenToken, this.context);
        }

        public SizeOfExpressionSyntax SizeOfExpression(SyntaxToken keyword, SyntaxToken openParenToken, TypeSyntax type, SyntaxToken closeParenToken)
        {
#if DEBUG
            if (keyword == null) throw new ArgumentNullException(nameof(keyword));
            if (keyword.Kind != SyntaxKind.SizeOfKeyword) throw new ArgumentException(nameof(keyword));
            if (openParenToken == null) throw new ArgumentNullException(nameof(openParenToken));
            if (openParenToken.Kind != SyntaxKind.OpenParenToken) throw new ArgumentException(nameof(openParenToken));
            if (type == null) throw new ArgumentNullException(nameof(type));
            if (closeParenToken == null) throw new ArgumentNullException(nameof(closeParenToken));
            if (closeParenToken.Kind != SyntaxKind.CloseParenToken) throw new ArgumentException(nameof(closeParenToken));
#endif

            return new SizeOfExpressionSyntax(SyntaxKind.SizeOfExpression, keyword, openParenToken, type, closeParenToken, this.context);
        }

        public InvocationExpressionSyntax InvocationExpression(ExpressionSyntax expression, ArgumentListSyntax argumentList)
        {
#if DEBUG
            if (expression == null) throw new ArgumentNullException(nameof(expression));
            if (argumentList == null) throw new ArgumentNullException(nameof(argumentList));
#endif

            int hash;
            var cached = CSharpSyntaxNodeCache.TryGetNode((int)SyntaxKind.InvocationExpression, expression, argumentList, this.context, out hash);
            if (cached != null) return (InvocationExpressionSyntax)cached;

            var result = new InvocationExpressionSyntax(SyntaxKind.InvocationExpression, expression, argumentList, this.context);
            if (hash >= 0)
            {
                SyntaxNodeCache.AddNode(result, hash);
            }

            return result;
        }

        public ElementAccessExpressionSyntax ElementAccessExpression(ExpressionSyntax expression, BracketedArgumentListSyntax argumentList)
        {
#if DEBUG
            if (expression == null) throw new ArgumentNullException(nameof(expression));
            if (argumentList == null) throw new ArgumentNullException(nameof(argumentList));
#endif

            int hash;
            var cached = CSharpSyntaxNodeCache.TryGetNode((int)SyntaxKind.ElementAccessExpression, expression, argumentList, this.context, out hash);
            if (cached != null) return (ElementAccessExpressionSyntax)cached;

            var result = new ElementAccessExpressionSyntax(SyntaxKind.ElementAccessExpression, expression, argumentList, this.context);
            if (hash >= 0)
            {
                SyntaxNodeCache.AddNode(result, hash);
            }

            return result;
        }

        public ArgumentListSyntax ArgumentList(SyntaxToken openParenToken, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<ArgumentSyntax> arguments, SyntaxToken closeParenToken)
        {
#if DEBUG
            if (openParenToken == null) throw new ArgumentNullException(nameof(openParenToken));
            if (openParenToken.Kind != SyntaxKind.OpenParenToken) throw new ArgumentException(nameof(openParenToken));
            if (closeParenToken == null) throw new ArgumentNullException(nameof(closeParenToken));
            if (closeParenToken.Kind != SyntaxKind.CloseParenToken) throw new ArgumentException(nameof(closeParenToken));
#endif

            int hash;
            var cached = CSharpSyntaxNodeCache.TryGetNode((int)SyntaxKind.ArgumentList, openParenToken, arguments.Node, closeParenToken, this.context, out hash);
            if (cached != null) return (ArgumentListSyntax)cached;

            var result = new ArgumentListSyntax(SyntaxKind.ArgumentList, openParenToken, arguments.Node, closeParenToken, this.context);
            if (hash >= 0)
            {
                SyntaxNodeCache.AddNode(result, hash);
            }

            return result;
        }

        public BracketedArgumentListSyntax BracketedArgumentList(SyntaxToken openBracketToken, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<ArgumentSyntax> arguments, SyntaxToken closeBracketToken)
        {
#if DEBUG
            if (openBracketToken == null) throw new ArgumentNullException(nameof(openBracketToken));
            if (openBracketToken.Kind != SyntaxKind.OpenBracketToken) throw new ArgumentException(nameof(openBracketToken));
            if (closeBracketToken == null) throw new ArgumentNullException(nameof(closeBracketToken));
            if (closeBracketToken.Kind != SyntaxKind.CloseBracketToken) throw new ArgumentException(nameof(closeBracketToken));
#endif

            int hash;
            var cached = CSharpSyntaxNodeCache.TryGetNode((int)SyntaxKind.BracketedArgumentList, openBracketToken, arguments.Node, closeBracketToken, this.context, out hash);
            if (cached != null) return (BracketedArgumentListSyntax)cached;

            var result = new BracketedArgumentListSyntax(SyntaxKind.BracketedArgumentList, openBracketToken, arguments.Node, closeBracketToken, this.context);
            if (hash >= 0)
            {
                SyntaxNodeCache.AddNode(result, hash);
            }

            return result;
        }

        public ArgumentSyntax Argument(NameColonSyntax? nameColon, SyntaxToken? refKindKeyword, ExpressionSyntax expression)
        {
#if DEBUG
            if (refKindKeyword != null)
            {
                switch (refKindKeyword.Kind)
                {
                    case SyntaxKind.RefKeyword:
                    case SyntaxKind.OutKeyword:
                    case SyntaxKind.InKeyword:
                    case SyntaxKind.None: break;
                    default: throw new ArgumentException(nameof(refKindKeyword));
                }
            }
            if (expression == null) throw new ArgumentNullException(nameof(expression));
#endif

            int hash;
            var cached = CSharpSyntaxNodeCache.TryGetNode((int)SyntaxKind.Argument, nameColon, refKindKeyword, expression, this.context, out hash);
            if (cached != null) return (ArgumentSyntax)cached;

            var result = new ArgumentSyntax(SyntaxKind.Argument, nameColon, refKindKeyword, expression, this.context);
            if (hash >= 0)
            {
                SyntaxNodeCache.AddNode(result, hash);
            }

            return result;
        }

        public NameColonSyntax NameColon(IdentifierNameSyntax name, SyntaxToken colonToken)
        {
#if DEBUG
            if (name == null) throw new ArgumentNullException(nameof(name));
            if (colonToken == null) throw new ArgumentNullException(nameof(colonToken));
            if (colonToken.Kind != SyntaxKind.ColonToken) throw new ArgumentException(nameof(colonToken));
#endif

            int hash;
            var cached = CSharpSyntaxNodeCache.TryGetNode((int)SyntaxKind.NameColon, name, colonToken, this.context, out hash);
            if (cached != null) return (NameColonSyntax)cached;

            var result = new NameColonSyntax(SyntaxKind.NameColon, name, colonToken, this.context);
            if (hash >= 0)
            {
                SyntaxNodeCache.AddNode(result, hash);
            }

            return result;
        }

        public DeclarationExpressionSyntax DeclarationExpression(TypeSyntax type, VariableDesignationSyntax designation)
        {
#if DEBUG
            if (type == null) throw new ArgumentNullException(nameof(type));
            if (designation == null) throw new ArgumentNullException(nameof(designation));
#endif

            int hash;
            var cached = CSharpSyntaxNodeCache.TryGetNode((int)SyntaxKind.DeclarationExpression, type, designation, this.context, out hash);
            if (cached != null) return (DeclarationExpressionSyntax)cached;

            var result = new DeclarationExpressionSyntax(SyntaxKind.DeclarationExpression, type, designation, this.context);
            if (hash >= 0)
            {
                SyntaxNodeCache.AddNode(result, hash);
            }

            return result;
        }

        public CastExpressionSyntax CastExpression(SyntaxToken openParenToken, TypeSyntax type, SyntaxToken closeParenToken, ExpressionSyntax expression)
        {
#if DEBUG
            if (openParenToken == null) throw new ArgumentNullException(nameof(openParenToken));
            if (openParenToken.Kind != SyntaxKind.OpenParenToken) throw new ArgumentException(nameof(openParenToken));
            if (type == null) throw new ArgumentNullException(nameof(type));
            if (closeParenToken == null) throw new ArgumentNullException(nameof(closeParenToken));
            if (closeParenToken.Kind != SyntaxKind.CloseParenToken) throw new ArgumentException(nameof(closeParenToken));
            if (expression == null) throw new ArgumentNullException(nameof(expression));
#endif

            return new CastExpressionSyntax(SyntaxKind.CastExpression, openParenToken, type, closeParenToken, expression, this.context);
        }

        public AnonymousMethodExpressionSyntax AnonymousMethodExpression(Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SyntaxToken> modifiers, SyntaxToken delegateKeyword, ParameterListSyntax? parameterList, BlockSyntax block, ExpressionSyntax? expressionBody)
        {
#if DEBUG
            if (delegateKeyword == null) throw new ArgumentNullException(nameof(delegateKeyword));
            if (delegateKeyword.Kind != SyntaxKind.DelegateKeyword) throw new ArgumentException(nameof(delegateKeyword));
            if (block == null) throw new ArgumentNullException(nameof(block));
#endif

            return new AnonymousMethodExpressionSyntax(SyntaxKind.AnonymousMethodExpression, modifiers.Node, delegateKeyword, parameterList, block, expressionBody, this.context);
        }

        public SimpleLambdaExpressionSyntax SimpleLambdaExpression(Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SyntaxToken> modifiers, ParameterSyntax parameter, SyntaxToken arrowToken, BlockSyntax? block, ExpressionSyntax? expressionBody)
        {
#if DEBUG
            if (parameter == null) throw new ArgumentNullException(nameof(parameter));
            if (arrowToken == null) throw new ArgumentNullException(nameof(arrowToken));
            if (arrowToken.Kind != SyntaxKind.EqualsGreaterThanToken) throw new ArgumentException(nameof(arrowToken));
#endif

            return new SimpleLambdaExpressionSyntax(SyntaxKind.SimpleLambdaExpression, modifiers.Node, parameter, arrowToken, block, expressionBody, this.context);
        }

        public RefExpressionSyntax RefExpression(SyntaxToken refKeyword, ExpressionSyntax expression)
        {
#if DEBUG
            if (refKeyword == null) throw new ArgumentNullException(nameof(refKeyword));
            if (refKeyword.Kind != SyntaxKind.RefKeyword) throw new ArgumentException(nameof(refKeyword));
            if (expression == null) throw new ArgumentNullException(nameof(expression));
#endif

            int hash;
            var cached = CSharpSyntaxNodeCache.TryGetNode((int)SyntaxKind.RefExpression, refKeyword, expression, this.context, out hash);
            if (cached != null) return (RefExpressionSyntax)cached;

            var result = new RefExpressionSyntax(SyntaxKind.RefExpression, refKeyword, expression, this.context);
            if (hash >= 0)
            {
                SyntaxNodeCache.AddNode(result, hash);
            }

            return result;
        }

        public ParenthesizedLambdaExpressionSyntax ParenthesizedLambdaExpression(Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SyntaxToken> modifiers, ParameterListSyntax parameterList, SyntaxToken arrowToken, BlockSyntax? block, ExpressionSyntax? expressionBody)
        {
#if DEBUG
            if (parameterList == null) throw new ArgumentNullException(nameof(parameterList));
            if (arrowToken == null) throw new ArgumentNullException(nameof(arrowToken));
            if (arrowToken.Kind != SyntaxKind.EqualsGreaterThanToken) throw new ArgumentException(nameof(arrowToken));
#endif

            return new ParenthesizedLambdaExpressionSyntax(SyntaxKind.ParenthesizedLambdaExpression, modifiers.Node, parameterList, arrowToken, block, expressionBody, this.context);
        }

        public InitializerExpressionSyntax InitializerExpression(SyntaxKind kind, SyntaxToken openBraceToken, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<ExpressionSyntax> expressions, SyntaxToken closeBraceToken)
        {
            switch (kind)
            {
                case SyntaxKind.ObjectInitializerExpression:
                case SyntaxKind.CollectionInitializerExpression:
                case SyntaxKind.ArrayInitializerExpression:
                case SyntaxKind.ComplexElementInitializerExpression:
                case SyntaxKind.WithInitializerExpression: break;
                default: throw new ArgumentException(nameof(kind));
            }
#if DEBUG
            if (openBraceToken == null) throw new ArgumentNullException(nameof(openBraceToken));
            if (openBraceToken.Kind != SyntaxKind.OpenBraceToken) throw new ArgumentException(nameof(openBraceToken));
            if (closeBraceToken == null) throw new ArgumentNullException(nameof(closeBraceToken));
            if (closeBraceToken.Kind != SyntaxKind.CloseBraceToken) throw new ArgumentException(nameof(closeBraceToken));
#endif

            int hash;
            var cached = CSharpSyntaxNodeCache.TryGetNode((int)kind, openBraceToken, expressions.Node, closeBraceToken, this.context, out hash);
            if (cached != null) return (InitializerExpressionSyntax)cached;

            var result = new InitializerExpressionSyntax(kind, openBraceToken, expressions.Node, closeBraceToken, this.context);
            if (hash >= 0)
            {
                SyntaxNodeCache.AddNode(result, hash);
            }

            return result;
        }

        public ImplicitObjectCreationExpressionSyntax ImplicitObjectCreationExpression(SyntaxToken newKeyword, ArgumentListSyntax argumentList, InitializerExpressionSyntax? initializer)
        {
#if DEBUG
            if (newKeyword == null) throw new ArgumentNullException(nameof(newKeyword));
            if (newKeyword.Kind != SyntaxKind.NewKeyword) throw new ArgumentException(nameof(newKeyword));
            if (argumentList == null) throw new ArgumentNullException(nameof(argumentList));
#endif

            int hash;
            var cached = CSharpSyntaxNodeCache.TryGetNode((int)SyntaxKind.ImplicitObjectCreationExpression, newKeyword, argumentList, initializer, this.context, out hash);
            if (cached != null) return (ImplicitObjectCreationExpressionSyntax)cached;

            var result = new ImplicitObjectCreationExpressionSyntax(SyntaxKind.ImplicitObjectCreationExpression, newKeyword, argumentList, initializer, this.context);
            if (hash >= 0)
            {
                SyntaxNodeCache.AddNode(result, hash);
            }

            return result;
        }

        public ObjectCreationExpressionSyntax ObjectCreationExpression(SyntaxToken newKeyword, TypeSyntax type, ArgumentListSyntax? argumentList, InitializerExpressionSyntax? initializer)
        {
#if DEBUG
            if (newKeyword == null) throw new ArgumentNullException(nameof(newKeyword));
            if (newKeyword.Kind != SyntaxKind.NewKeyword) throw new ArgumentException(nameof(newKeyword));
            if (type == null) throw new ArgumentNullException(nameof(type));
#endif

            return new ObjectCreationExpressionSyntax(SyntaxKind.ObjectCreationExpression, newKeyword, type, argumentList, initializer, this.context);
        }

        public WithExpressionSyntax WithExpression(ExpressionSyntax expression, SyntaxToken withKeyword, InitializerExpressionSyntax initializer)
        {
#if DEBUG
            if (expression == null) throw new ArgumentNullException(nameof(expression));
            if (withKeyword == null) throw new ArgumentNullException(nameof(withKeyword));
            if (withKeyword.Kind != SyntaxKind.WithKeyword) throw new ArgumentException(nameof(withKeyword));
            if (initializer == null) throw new ArgumentNullException(nameof(initializer));
#endif

            int hash;
            var cached = CSharpSyntaxNodeCache.TryGetNode((int)SyntaxKind.WithExpression, expression, withKeyword, initializer, this.context, out hash);
            if (cached != null) return (WithExpressionSyntax)cached;

            var result = new WithExpressionSyntax(SyntaxKind.WithExpression, expression, withKeyword, initializer, this.context);
            if (hash >= 0)
            {
                SyntaxNodeCache.AddNode(result, hash);
            }

            return result;
        }

        public AnonymousObjectMemberDeclaratorSyntax AnonymousObjectMemberDeclarator(NameEqualsSyntax? nameEquals, ExpressionSyntax expression)
        {
#if DEBUG
            if (expression == null) throw new ArgumentNullException(nameof(expression));
#endif

            int hash;
            var cached = CSharpSyntaxNodeCache.TryGetNode((int)SyntaxKind.AnonymousObjectMemberDeclarator, nameEquals, expression, this.context, out hash);
            if (cached != null) return (AnonymousObjectMemberDeclaratorSyntax)cached;

            var result = new AnonymousObjectMemberDeclaratorSyntax(SyntaxKind.AnonymousObjectMemberDeclarator, nameEquals, expression, this.context);
            if (hash >= 0)
            {
                SyntaxNodeCache.AddNode(result, hash);
            }

            return result;
        }

        public AnonymousObjectCreationExpressionSyntax AnonymousObjectCreationExpression(SyntaxToken newKeyword, SyntaxToken openBraceToken, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<AnonymousObjectMemberDeclaratorSyntax> initializers, SyntaxToken closeBraceToken)
        {
#if DEBUG
            if (newKeyword == null) throw new ArgumentNullException(nameof(newKeyword));
            if (newKeyword.Kind != SyntaxKind.NewKeyword) throw new ArgumentException(nameof(newKeyword));
            if (openBraceToken == null) throw new ArgumentNullException(nameof(openBraceToken));
            if (openBraceToken.Kind != SyntaxKind.OpenBraceToken) throw new ArgumentException(nameof(openBraceToken));
            if (closeBraceToken == null) throw new ArgumentNullException(nameof(closeBraceToken));
            if (closeBraceToken.Kind != SyntaxKind.CloseBraceToken) throw new ArgumentException(nameof(closeBraceToken));
#endif

            return new AnonymousObjectCreationExpressionSyntax(SyntaxKind.AnonymousObjectCreationExpression, newKeyword, openBraceToken, initializers.Node, closeBraceToken, this.context);
        }

        public ArrayCreationExpressionSyntax ArrayCreationExpression(SyntaxToken newKeyword, ArrayTypeSyntax type, InitializerExpressionSyntax? initializer)
        {
#if DEBUG
            if (newKeyword == null) throw new ArgumentNullException(nameof(newKeyword));
            if (newKeyword.Kind != SyntaxKind.NewKeyword) throw new ArgumentException(nameof(newKeyword));
            if (type == null) throw new ArgumentNullException(nameof(type));
#endif

            int hash;
            var cached = CSharpSyntaxNodeCache.TryGetNode((int)SyntaxKind.ArrayCreationExpression, newKeyword, type, initializer, this.context, out hash);
            if (cached != null) return (ArrayCreationExpressionSyntax)cached;

            var result = new ArrayCreationExpressionSyntax(SyntaxKind.ArrayCreationExpression, newKeyword, type, initializer, this.context);
            if (hash >= 0)
            {
                SyntaxNodeCache.AddNode(result, hash);
            }

            return result;
        }

        public ImplicitArrayCreationExpressionSyntax ImplicitArrayCreationExpression(SyntaxToken newKeyword, SyntaxToken openBracketToken, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SyntaxToken> commas, SyntaxToken closeBracketToken, InitializerExpressionSyntax initializer)
        {
#if DEBUG
            if (newKeyword == null) throw new ArgumentNullException(nameof(newKeyword));
            if (newKeyword.Kind != SyntaxKind.NewKeyword) throw new ArgumentException(nameof(newKeyword));
            if (openBracketToken == null) throw new ArgumentNullException(nameof(openBracketToken));
            if (openBracketToken.Kind != SyntaxKind.OpenBracketToken) throw new ArgumentException(nameof(openBracketToken));
            if (closeBracketToken == null) throw new ArgumentNullException(nameof(closeBracketToken));
            if (closeBracketToken.Kind != SyntaxKind.CloseBracketToken) throw new ArgumentException(nameof(closeBracketToken));
            if (initializer == null) throw new ArgumentNullException(nameof(initializer));
#endif

            return new ImplicitArrayCreationExpressionSyntax(SyntaxKind.ImplicitArrayCreationExpression, newKeyword, openBracketToken, commas.Node, closeBracketToken, initializer, this.context);
        }

        public StackAllocArrayCreationExpressionSyntax StackAllocArrayCreationExpression(SyntaxToken stackAllocKeyword, TypeSyntax type, InitializerExpressionSyntax? initializer)
        {
#if DEBUG
            if (stackAllocKeyword == null) throw new ArgumentNullException(nameof(stackAllocKeyword));
            if (stackAllocKeyword.Kind != SyntaxKind.StackAllocKeyword) throw new ArgumentException(nameof(stackAllocKeyword));
            if (type == null) throw new ArgumentNullException(nameof(type));
#endif

            int hash;
            var cached = CSharpSyntaxNodeCache.TryGetNode((int)SyntaxKind.StackAllocArrayCreationExpression, stackAllocKeyword, type, initializer, this.context, out hash);
            if (cached != null) return (StackAllocArrayCreationExpressionSyntax)cached;

            var result = new StackAllocArrayCreationExpressionSyntax(SyntaxKind.StackAllocArrayCreationExpression, stackAllocKeyword, type, initializer, this.context);
            if (hash >= 0)
            {
                SyntaxNodeCache.AddNode(result, hash);
            }

            return result;
        }

        public ImplicitStackAllocArrayCreationExpressionSyntax ImplicitStackAllocArrayCreationExpression(SyntaxToken stackAllocKeyword, SyntaxToken openBracketToken, SyntaxToken closeBracketToken, InitializerExpressionSyntax initializer)
        {
#if DEBUG
            if (stackAllocKeyword == null) throw new ArgumentNullException(nameof(stackAllocKeyword));
            if (stackAllocKeyword.Kind != SyntaxKind.StackAllocKeyword) throw new ArgumentException(nameof(stackAllocKeyword));
            if (openBracketToken == null) throw new ArgumentNullException(nameof(openBracketToken));
            if (openBracketToken.Kind != SyntaxKind.OpenBracketToken) throw new ArgumentException(nameof(openBracketToken));
            if (closeBracketToken == null) throw new ArgumentNullException(nameof(closeBracketToken));
            if (closeBracketToken.Kind != SyntaxKind.CloseBracketToken) throw new ArgumentException(nameof(closeBracketToken));
            if (initializer == null) throw new ArgumentNullException(nameof(initializer));
#endif

            return new ImplicitStackAllocArrayCreationExpressionSyntax(SyntaxKind.ImplicitStackAllocArrayCreationExpression, stackAllocKeyword, openBracketToken, closeBracketToken, initializer, this.context);
        }

        public QueryExpressionSyntax QueryExpression(FromClauseSyntax fromClause, QueryBodySyntax body)
        {
#if DEBUG
            if (fromClause == null) throw new ArgumentNullException(nameof(fromClause));
            if (body == null) throw new ArgumentNullException(nameof(body));
#endif

            int hash;
            var cached = CSharpSyntaxNodeCache.TryGetNode((int)SyntaxKind.QueryExpression, fromClause, body, this.context, out hash);
            if (cached != null) return (QueryExpressionSyntax)cached;

            var result = new QueryExpressionSyntax(SyntaxKind.QueryExpression, fromClause, body, this.context);
            if (hash >= 0)
            {
                SyntaxNodeCache.AddNode(result, hash);
            }

            return result;
        }

        public QueryBodySyntax QueryBody(Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<QueryClauseSyntax> clauses, SelectOrGroupClauseSyntax selectOrGroup, QueryContinuationSyntax? continuation)
        {
#if DEBUG
            if (selectOrGroup == null) throw new ArgumentNullException(nameof(selectOrGroup));
#endif

            int hash;
            var cached = CSharpSyntaxNodeCache.TryGetNode((int)SyntaxKind.QueryBody, clauses.Node, selectOrGroup, continuation, this.context, out hash);
            if (cached != null) return (QueryBodySyntax)cached;

            var result = new QueryBodySyntax(SyntaxKind.QueryBody, clauses.Node, selectOrGroup, continuation, this.context);
            if (hash >= 0)
            {
                SyntaxNodeCache.AddNode(result, hash);
            }

            return result;
        }

        public FromClauseSyntax FromClause(SyntaxToken fromKeyword, TypeSyntax? type, SyntaxToken identifier, SyntaxToken inKeyword, ExpressionSyntax expression)
        {
#if DEBUG
            if (fromKeyword == null) throw new ArgumentNullException(nameof(fromKeyword));
            if (fromKeyword.Kind != SyntaxKind.FromKeyword) throw new ArgumentException(nameof(fromKeyword));
            if (identifier == null) throw new ArgumentNullException(nameof(identifier));
            if (identifier.Kind != SyntaxKind.IdentifierToken) throw new ArgumentException(nameof(identifier));
            if (inKeyword == null) throw new ArgumentNullException(nameof(inKeyword));
            if (inKeyword.Kind != SyntaxKind.InKeyword) throw new ArgumentException(nameof(inKeyword));
            if (expression == null) throw new ArgumentNullException(nameof(expression));
#endif

            return new FromClauseSyntax(SyntaxKind.FromClause, fromKeyword, type, identifier, inKeyword, expression, this.context);
        }

        public LetClauseSyntax LetClause(SyntaxToken letKeyword, SyntaxToken identifier, SyntaxToken equalsToken, ExpressionSyntax expression)
        {
#if DEBUG
            if (letKeyword == null) throw new ArgumentNullException(nameof(letKeyword));
            if (letKeyword.Kind != SyntaxKind.LetKeyword) throw new ArgumentException(nameof(letKeyword));
            if (identifier == null) throw new ArgumentNullException(nameof(identifier));
            if (identifier.Kind != SyntaxKind.IdentifierToken) throw new ArgumentException(nameof(identifier));
            if (equalsToken == null) throw new ArgumentNullException(nameof(equalsToken));
            if (equalsToken.Kind != SyntaxKind.EqualsToken) throw new ArgumentException(nameof(equalsToken));
            if (expression == null) throw new ArgumentNullException(nameof(expression));
#endif

            return new LetClauseSyntax(SyntaxKind.LetClause, letKeyword, identifier, equalsToken, expression, this.context);
        }

        public JoinClauseSyntax JoinClause(SyntaxToken joinKeyword, TypeSyntax? type, SyntaxToken identifier, SyntaxToken inKeyword, ExpressionSyntax inExpression, SyntaxToken onKeyword, ExpressionSyntax leftExpression, SyntaxToken equalsKeyword, ExpressionSyntax rightExpression, JoinIntoClauseSyntax? into)
        {
#if DEBUG
            if (joinKeyword == null) throw new ArgumentNullException(nameof(joinKeyword));
            if (joinKeyword.Kind != SyntaxKind.JoinKeyword) throw new ArgumentException(nameof(joinKeyword));
            if (identifier == null) throw new ArgumentNullException(nameof(identifier));
            if (identifier.Kind != SyntaxKind.IdentifierToken) throw new ArgumentException(nameof(identifier));
            if (inKeyword == null) throw new ArgumentNullException(nameof(inKeyword));
            if (inKeyword.Kind != SyntaxKind.InKeyword) throw new ArgumentException(nameof(inKeyword));
            if (inExpression == null) throw new ArgumentNullException(nameof(inExpression));
            if (onKeyword == null) throw new ArgumentNullException(nameof(onKeyword));
            if (onKeyword.Kind != SyntaxKind.OnKeyword) throw new ArgumentException(nameof(onKeyword));
            if (leftExpression == null) throw new ArgumentNullException(nameof(leftExpression));
            if (equalsKeyword == null) throw new ArgumentNullException(nameof(equalsKeyword));
            if (equalsKeyword.Kind != SyntaxKind.EqualsKeyword) throw new ArgumentException(nameof(equalsKeyword));
            if (rightExpression == null) throw new ArgumentNullException(nameof(rightExpression));
#endif

            return new JoinClauseSyntax(SyntaxKind.JoinClause, joinKeyword, type, identifier, inKeyword, inExpression, onKeyword, leftExpression, equalsKeyword, rightExpression, into, this.context);
        }

        public JoinIntoClauseSyntax JoinIntoClause(SyntaxToken intoKeyword, SyntaxToken identifier)
        {
#if DEBUG
            if (intoKeyword == null) throw new ArgumentNullException(nameof(intoKeyword));
            if (intoKeyword.Kind != SyntaxKind.IntoKeyword) throw new ArgumentException(nameof(intoKeyword));
            if (identifier == null) throw new ArgumentNullException(nameof(identifier));
            if (identifier.Kind != SyntaxKind.IdentifierToken) throw new ArgumentException(nameof(identifier));
#endif

            int hash;
            var cached = CSharpSyntaxNodeCache.TryGetNode((int)SyntaxKind.JoinIntoClause, intoKeyword, identifier, this.context, out hash);
            if (cached != null) return (JoinIntoClauseSyntax)cached;

            var result = new JoinIntoClauseSyntax(SyntaxKind.JoinIntoClause, intoKeyword, identifier, this.context);
            if (hash >= 0)
            {
                SyntaxNodeCache.AddNode(result, hash);
            }

            return result;
        }

        public WhereClauseSyntax WhereClause(SyntaxToken whereKeyword, ExpressionSyntax condition)
        {
#if DEBUG
            if (whereKeyword == null) throw new ArgumentNullException(nameof(whereKeyword));
            if (whereKeyword.Kind != SyntaxKind.WhereKeyword) throw new ArgumentException(nameof(whereKeyword));
            if (condition == null) throw new ArgumentNullException(nameof(condition));
#endif

            int hash;
            var cached = CSharpSyntaxNodeCache.TryGetNode((int)SyntaxKind.WhereClause, whereKeyword, condition, this.context, out hash);
            if (cached != null) return (WhereClauseSyntax)cached;

            var result = new WhereClauseSyntax(SyntaxKind.WhereClause, whereKeyword, condition, this.context);
            if (hash >= 0)
            {
                SyntaxNodeCache.AddNode(result, hash);
            }

            return result;
        }

        public OrderByClauseSyntax OrderByClause(SyntaxToken orderByKeyword, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<OrderingSyntax> orderings)
        {
#if DEBUG
            if (orderByKeyword == null) throw new ArgumentNullException(nameof(orderByKeyword));
            if (orderByKeyword.Kind != SyntaxKind.OrderByKeyword) throw new ArgumentException(nameof(orderByKeyword));
#endif

            int hash;
            var cached = CSharpSyntaxNodeCache.TryGetNode((int)SyntaxKind.OrderByClause, orderByKeyword, orderings.Node, this.context, out hash);
            if (cached != null) return (OrderByClauseSyntax)cached;

            var result = new OrderByClauseSyntax(SyntaxKind.OrderByClause, orderByKeyword, orderings.Node, this.context);
            if (hash >= 0)
            {
                SyntaxNodeCache.AddNode(result, hash);
            }

            return result;
        }

        public OrderingSyntax Ordering(SyntaxKind kind, ExpressionSyntax expression, SyntaxToken? ascendingOrDescendingKeyword)
        {
            switch (kind)
            {
                case SyntaxKind.AscendingOrdering:
                case SyntaxKind.DescendingOrdering: break;
                default: throw new ArgumentException(nameof(kind));
            }
#if DEBUG
            if (expression == null) throw new ArgumentNullException(nameof(expression));
            if (ascendingOrDescendingKeyword != null)
            {
                switch (ascendingOrDescendingKeyword.Kind)
                {
                    case SyntaxKind.AscendingKeyword:
                    case SyntaxKind.DescendingKeyword:
                    case SyntaxKind.None: break;
                    default: throw new ArgumentException(nameof(ascendingOrDescendingKeyword));
                }
            }
#endif

            int hash;
            var cached = CSharpSyntaxNodeCache.TryGetNode((int)kind, expression, ascendingOrDescendingKeyword, this.context, out hash);
            if (cached != null) return (OrderingSyntax)cached;

            var result = new OrderingSyntax(kind, expression, ascendingOrDescendingKeyword, this.context);
            if (hash >= 0)
            {
                SyntaxNodeCache.AddNode(result, hash);
            }

            return result;
        }

        public SelectClauseSyntax SelectClause(SyntaxToken selectKeyword, ExpressionSyntax expression)
        {
#if DEBUG
            if (selectKeyword == null) throw new ArgumentNullException(nameof(selectKeyword));
            if (selectKeyword.Kind != SyntaxKind.SelectKeyword) throw new ArgumentException(nameof(selectKeyword));
            if (expression == null) throw new ArgumentNullException(nameof(expression));
#endif

            int hash;
            var cached = CSharpSyntaxNodeCache.TryGetNode((int)SyntaxKind.SelectClause, selectKeyword, expression, this.context, out hash);
            if (cached != null) return (SelectClauseSyntax)cached;

            var result = new SelectClauseSyntax(SyntaxKind.SelectClause, selectKeyword, expression, this.context);
            if (hash >= 0)
            {
                SyntaxNodeCache.AddNode(result, hash);
            }

            return result;
        }

        public GroupClauseSyntax GroupClause(SyntaxToken groupKeyword, ExpressionSyntax groupExpression, SyntaxToken byKeyword, ExpressionSyntax byExpression)
        {
#if DEBUG
            if (groupKeyword == null) throw new ArgumentNullException(nameof(groupKeyword));
            if (groupKeyword.Kind != SyntaxKind.GroupKeyword) throw new ArgumentException(nameof(groupKeyword));
            if (groupExpression == null) throw new ArgumentNullException(nameof(groupExpression));
            if (byKeyword == null) throw new ArgumentNullException(nameof(byKeyword));
            if (byKeyword.Kind != SyntaxKind.ByKeyword) throw new ArgumentException(nameof(byKeyword));
            if (byExpression == null) throw new ArgumentNullException(nameof(byExpression));
#endif

            return new GroupClauseSyntax(SyntaxKind.GroupClause, groupKeyword, groupExpression, byKeyword, byExpression, this.context);
        }

        public QueryContinuationSyntax QueryContinuation(SyntaxToken intoKeyword, SyntaxToken identifier, QueryBodySyntax body)
        {
#if DEBUG
            if (intoKeyword == null) throw new ArgumentNullException(nameof(intoKeyword));
            if (intoKeyword.Kind != SyntaxKind.IntoKeyword) throw new ArgumentException(nameof(intoKeyword));
            if (identifier == null) throw new ArgumentNullException(nameof(identifier));
            if (identifier.Kind != SyntaxKind.IdentifierToken) throw new ArgumentException(nameof(identifier));
            if (body == null) throw new ArgumentNullException(nameof(body));
#endif

            int hash;
            var cached = CSharpSyntaxNodeCache.TryGetNode((int)SyntaxKind.QueryContinuation, intoKeyword, identifier, body, this.context, out hash);
            if (cached != null) return (QueryContinuationSyntax)cached;

            var result = new QueryContinuationSyntax(SyntaxKind.QueryContinuation, intoKeyword, identifier, body, this.context);
            if (hash >= 0)
            {
                SyntaxNodeCache.AddNode(result, hash);
            }

            return result;
        }

        public OmittedArraySizeExpressionSyntax OmittedArraySizeExpression(SyntaxToken omittedArraySizeExpressionToken)
        {
#if DEBUG
            if (omittedArraySizeExpressionToken == null) throw new ArgumentNullException(nameof(omittedArraySizeExpressionToken));
            if (omittedArraySizeExpressionToken.Kind != SyntaxKind.OmittedArraySizeExpressionToken) throw new ArgumentException(nameof(omittedArraySizeExpressionToken));
#endif

            int hash;
            var cached = CSharpSyntaxNodeCache.TryGetNode((int)SyntaxKind.OmittedArraySizeExpression, omittedArraySizeExpressionToken, this.context, out hash);
            if (cached != null) return (OmittedArraySizeExpressionSyntax)cached;

            var result = new OmittedArraySizeExpressionSyntax(SyntaxKind.OmittedArraySizeExpression, omittedArraySizeExpressionToken, this.context);
            if (hash >= 0)
            {
                SyntaxNodeCache.AddNode(result, hash);
            }

            return result;
        }

        public InterpolatedStringExpressionSyntax InterpolatedStringExpression(SyntaxToken stringStartToken, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<InterpolatedStringContentSyntax> contents, SyntaxToken stringEndToken)
        {
#if DEBUG
            if (stringStartToken == null) throw new ArgumentNullException(nameof(stringStartToken));
            switch (stringStartToken.Kind)
            {
                case SyntaxKind.InterpolatedStringStartToken:
                case SyntaxKind.InterpolatedVerbatimStringStartToken: break;
                default: throw new ArgumentException(nameof(stringStartToken));
            }
            if (stringEndToken == null) throw new ArgumentNullException(nameof(stringEndToken));
            if (stringEndToken.Kind != SyntaxKind.InterpolatedStringEndToken) throw new ArgumentException(nameof(stringEndToken));
#endif

            int hash;
            var cached = CSharpSyntaxNodeCache.TryGetNode((int)SyntaxKind.InterpolatedStringExpression, stringStartToken, contents.Node, stringEndToken, this.context, out hash);
            if (cached != null) return (InterpolatedStringExpressionSyntax)cached;

            var result = new InterpolatedStringExpressionSyntax(SyntaxKind.InterpolatedStringExpression, stringStartToken, contents.Node, stringEndToken, this.context);
            if (hash >= 0)
            {
                SyntaxNodeCache.AddNode(result, hash);
            }

            return result;
        }

        public IsPatternExpressionSyntax IsPatternExpression(ExpressionSyntax expression, SyntaxToken isKeyword, PatternSyntax pattern)
        {
#if DEBUG
            if (expression == null) throw new ArgumentNullException(nameof(expression));
            if (isKeyword == null) throw new ArgumentNullException(nameof(isKeyword));
            if (isKeyword.Kind != SyntaxKind.IsKeyword) throw new ArgumentException(nameof(isKeyword));
            if (pattern == null) throw new ArgumentNullException(nameof(pattern));
#endif

            int hash;
            var cached = CSharpSyntaxNodeCache.TryGetNode((int)SyntaxKind.IsPatternExpression, expression, isKeyword, pattern, this.context, out hash);
            if (cached != null) return (IsPatternExpressionSyntax)cached;

            var result = new IsPatternExpressionSyntax(SyntaxKind.IsPatternExpression, expression, isKeyword, pattern, this.context);
            if (hash >= 0)
            {
                SyntaxNodeCache.AddNode(result, hash);
            }

            return result;
        }

        public ThrowExpressionSyntax ThrowExpression(SyntaxToken throwKeyword, ExpressionSyntax expression)
        {
#if DEBUG
            if (throwKeyword == null) throw new ArgumentNullException(nameof(throwKeyword));
            if (throwKeyword.Kind != SyntaxKind.ThrowKeyword) throw new ArgumentException(nameof(throwKeyword));
            if (expression == null) throw new ArgumentNullException(nameof(expression));
#endif

            int hash;
            var cached = CSharpSyntaxNodeCache.TryGetNode((int)SyntaxKind.ThrowExpression, throwKeyword, expression, this.context, out hash);
            if (cached != null) return (ThrowExpressionSyntax)cached;

            var result = new ThrowExpressionSyntax(SyntaxKind.ThrowExpression, throwKeyword, expression, this.context);
            if (hash >= 0)
            {
                SyntaxNodeCache.AddNode(result, hash);
            }

            return result;
        }

        public WhenClauseSyntax WhenClause(SyntaxToken whenKeyword, ExpressionSyntax condition)
        {
#if DEBUG
            if (whenKeyword == null) throw new ArgumentNullException(nameof(whenKeyword));
            if (whenKeyword.Kind != SyntaxKind.WhenKeyword) throw new ArgumentException(nameof(whenKeyword));
            if (condition == null) throw new ArgumentNullException(nameof(condition));
#endif

            int hash;
            var cached = CSharpSyntaxNodeCache.TryGetNode((int)SyntaxKind.WhenClause, whenKeyword, condition, this.context, out hash);
            if (cached != null) return (WhenClauseSyntax)cached;

            var result = new WhenClauseSyntax(SyntaxKind.WhenClause, whenKeyword, condition, this.context);
            if (hash >= 0)
            {
                SyntaxNodeCache.AddNode(result, hash);
            }

            return result;
        }

        public DiscardPatternSyntax DiscardPattern(SyntaxToken underscoreToken)
        {
#if DEBUG
            if (underscoreToken == null) throw new ArgumentNullException(nameof(underscoreToken));
            if (underscoreToken.Kind != SyntaxKind.UnderscoreToken) throw new ArgumentException(nameof(underscoreToken));
#endif

            int hash;
            var cached = CSharpSyntaxNodeCache.TryGetNode((int)SyntaxKind.DiscardPattern, underscoreToken, this.context, out hash);
            if (cached != null) return (DiscardPatternSyntax)cached;

            var result = new DiscardPatternSyntax(SyntaxKind.DiscardPattern, underscoreToken, this.context);
            if (hash >= 0)
            {
                SyntaxNodeCache.AddNode(result, hash);
            }

            return result;
        }

        public DeclarationPatternSyntax DeclarationPattern(TypeSyntax type, VariableDesignationSyntax designation)
        {
#if DEBUG
            if (type == null) throw new ArgumentNullException(nameof(type));
            if (designation == null) throw new ArgumentNullException(nameof(designation));
#endif

            int hash;
            var cached = CSharpSyntaxNodeCache.TryGetNode((int)SyntaxKind.DeclarationPattern, type, designation, this.context, out hash);
            if (cached != null) return (DeclarationPatternSyntax)cached;

            var result = new DeclarationPatternSyntax(SyntaxKind.DeclarationPattern, type, designation, this.context);
            if (hash >= 0)
            {
                SyntaxNodeCache.AddNode(result, hash);
            }

            return result;
        }

        public VarPatternSyntax VarPattern(SyntaxToken varKeyword, VariableDesignationSyntax designation)
        {
#if DEBUG
            if (varKeyword == null) throw new ArgumentNullException(nameof(varKeyword));
            if (varKeyword.Kind != SyntaxKind.VarKeyword) throw new ArgumentException(nameof(varKeyword));
            if (designation == null) throw new ArgumentNullException(nameof(designation));
#endif

            int hash;
            var cached = CSharpSyntaxNodeCache.TryGetNode((int)SyntaxKind.VarPattern, varKeyword, designation, this.context, out hash);
            if (cached != null) return (VarPatternSyntax)cached;

            var result = new VarPatternSyntax(SyntaxKind.VarPattern, varKeyword, designation, this.context);
            if (hash >= 0)
            {
                SyntaxNodeCache.AddNode(result, hash);
            }

            return result;
        }

        public RecursivePatternSyntax RecursivePattern(TypeSyntax? type, PositionalPatternClauseSyntax? positionalPatternClause, PropertyPatternClauseSyntax? propertyPatternClause, VariableDesignationSyntax? designation)
        {
#if DEBUG
#endif

            return new RecursivePatternSyntax(SyntaxKind.RecursivePattern, type, positionalPatternClause, propertyPatternClause, designation, this.context);
        }

        public PositionalPatternClauseSyntax PositionalPatternClause(SyntaxToken openParenToken, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<SubpatternSyntax> subpatterns, SyntaxToken closeParenToken)
        {
#if DEBUG
            if (openParenToken == null) throw new ArgumentNullException(nameof(openParenToken));
            if (openParenToken.Kind != SyntaxKind.OpenParenToken) throw new ArgumentException(nameof(openParenToken));
            if (closeParenToken == null) throw new ArgumentNullException(nameof(closeParenToken));
            if (closeParenToken.Kind != SyntaxKind.CloseParenToken) throw new ArgumentException(nameof(closeParenToken));
#endif

            int hash;
            var cached = CSharpSyntaxNodeCache.TryGetNode((int)SyntaxKind.PositionalPatternClause, openParenToken, subpatterns.Node, closeParenToken, this.context, out hash);
            if (cached != null) return (PositionalPatternClauseSyntax)cached;

            var result = new PositionalPatternClauseSyntax(SyntaxKind.PositionalPatternClause, openParenToken, subpatterns.Node, closeParenToken, this.context);
            if (hash >= 0)
            {
                SyntaxNodeCache.AddNode(result, hash);
            }

            return result;
        }

        public PropertyPatternClauseSyntax PropertyPatternClause(SyntaxToken openBraceToken, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<SubpatternSyntax> subpatterns, SyntaxToken closeBraceToken)
        {
#if DEBUG
            if (openBraceToken == null) throw new ArgumentNullException(nameof(openBraceToken));
            if (openBraceToken.Kind != SyntaxKind.OpenBraceToken) throw new ArgumentException(nameof(openBraceToken));
            if (closeBraceToken == null) throw new ArgumentNullException(nameof(closeBraceToken));
            if (closeBraceToken.Kind != SyntaxKind.CloseBraceToken) throw new ArgumentException(nameof(closeBraceToken));
#endif

            int hash;
            var cached = CSharpSyntaxNodeCache.TryGetNode((int)SyntaxKind.PropertyPatternClause, openBraceToken, subpatterns.Node, closeBraceToken, this.context, out hash);
            if (cached != null) return (PropertyPatternClauseSyntax)cached;

            var result = new PropertyPatternClauseSyntax(SyntaxKind.PropertyPatternClause, openBraceToken, subpatterns.Node, closeBraceToken, this.context);
            if (hash >= 0)
            {
                SyntaxNodeCache.AddNode(result, hash);
            }

            return result;
        }

        public SubpatternSyntax Subpattern(NameColonSyntax? nameColon, PatternSyntax pattern)
        {
#if DEBUG
            if (pattern == null) throw new ArgumentNullException(nameof(pattern));
#endif

            int hash;
            var cached = CSharpSyntaxNodeCache.TryGetNode((int)SyntaxKind.Subpattern, nameColon, pattern, this.context, out hash);
            if (cached != null) return (SubpatternSyntax)cached;

            var result = new SubpatternSyntax(SyntaxKind.Subpattern, nameColon, pattern, this.context);
            if (hash >= 0)
            {
                SyntaxNodeCache.AddNode(result, hash);
            }

            return result;
        }

        public ConstantPatternSyntax ConstantPattern(ExpressionSyntax expression)
        {
#if DEBUG
            if (expression == null) throw new ArgumentNullException(nameof(expression));
#endif

            int hash;
            var cached = CSharpSyntaxNodeCache.TryGetNode((int)SyntaxKind.ConstantPattern, expression, this.context, out hash);
            if (cached != null) return (ConstantPatternSyntax)cached;

            var result = new ConstantPatternSyntax(SyntaxKind.ConstantPattern, expression, this.context);
            if (hash >= 0)
            {
                SyntaxNodeCache.AddNode(result, hash);
            }

            return result;
        }

        public ParenthesizedPatternSyntax ParenthesizedPattern(SyntaxToken openParenToken, PatternSyntax pattern, SyntaxToken closeParenToken)
        {
#if DEBUG
            if (openParenToken == null) throw new ArgumentNullException(nameof(openParenToken));
            if (openParenToken.Kind != SyntaxKind.OpenParenToken) throw new ArgumentException(nameof(openParenToken));
            if (pattern == null) throw new ArgumentNullException(nameof(pattern));
            if (closeParenToken == null) throw new ArgumentNullException(nameof(closeParenToken));
            if (closeParenToken.Kind != SyntaxKind.CloseParenToken) throw new ArgumentException(nameof(closeParenToken));
#endif

            int hash;
            var cached = CSharpSyntaxNodeCache.TryGetNode((int)SyntaxKind.ParenthesizedPattern, openParenToken, pattern, closeParenToken, this.context, out hash);
            if (cached != null) return (ParenthesizedPatternSyntax)cached;

            var result = new ParenthesizedPatternSyntax(SyntaxKind.ParenthesizedPattern, openParenToken, pattern, closeParenToken, this.context);
            if (hash >= 0)
            {
                SyntaxNodeCache.AddNode(result, hash);
            }

            return result;
        }

        public RelationalPatternSyntax RelationalPattern(SyntaxToken operatorToken, ExpressionSyntax expression)
        {
#if DEBUG
            if (operatorToken == null) throw new ArgumentNullException(nameof(operatorToken));
            switch (operatorToken.Kind)
            {
                case SyntaxKind.EqualsEqualsToken:
                case SyntaxKind.ExclamationEqualsToken:
                case SyntaxKind.LessThanToken:
                case SyntaxKind.LessThanEqualsToken:
                case SyntaxKind.GreaterThanToken:
                case SyntaxKind.GreaterThanEqualsToken: break;
                default: throw new ArgumentException(nameof(operatorToken));
            }
            if (expression == null) throw new ArgumentNullException(nameof(expression));
#endif

            int hash;
            var cached = CSharpSyntaxNodeCache.TryGetNode((int)SyntaxKind.RelationalPattern, operatorToken, expression, this.context, out hash);
            if (cached != null) return (RelationalPatternSyntax)cached;

            var result = new RelationalPatternSyntax(SyntaxKind.RelationalPattern, operatorToken, expression, this.context);
            if (hash >= 0)
            {
                SyntaxNodeCache.AddNode(result, hash);
            }

            return result;
        }

        public TypePatternSyntax TypePattern(TypeSyntax type)
        {
#if DEBUG
            if (type == null) throw new ArgumentNullException(nameof(type));
#endif

            int hash;
            var cached = CSharpSyntaxNodeCache.TryGetNode((int)SyntaxKind.TypePattern, type, this.context, out hash);
            if (cached != null) return (TypePatternSyntax)cached;

            var result = new TypePatternSyntax(SyntaxKind.TypePattern, type, this.context);
            if (hash >= 0)
            {
                SyntaxNodeCache.AddNode(result, hash);
            }

            return result;
        }

        public BinaryPatternSyntax BinaryPattern(SyntaxKind kind, PatternSyntax left, SyntaxToken operatorToken, PatternSyntax right)
        {
            switch (kind)
            {
                case SyntaxKind.OrPattern:
                case SyntaxKind.AndPattern: break;
                default: throw new ArgumentException(nameof(kind));
            }
#if DEBUG
            if (left == null) throw new ArgumentNullException(nameof(left));
            if (operatorToken == null) throw new ArgumentNullException(nameof(operatorToken));
            switch (operatorToken.Kind)
            {
                case SyntaxKind.OrKeyword:
                case SyntaxKind.AndKeyword: break;
                default: throw new ArgumentException(nameof(operatorToken));
            }
            if (right == null) throw new ArgumentNullException(nameof(right));
#endif

            int hash;
            var cached = CSharpSyntaxNodeCache.TryGetNode((int)kind, left, operatorToken, right, this.context, out hash);
            if (cached != null) return (BinaryPatternSyntax)cached;

            var result = new BinaryPatternSyntax(kind, left, operatorToken, right, this.context);
            if (hash >= 0)
            {
                SyntaxNodeCache.AddNode(result, hash);
            }

            return result;
        }

        public UnaryPatternSyntax UnaryPattern(SyntaxToken operatorToken, PatternSyntax pattern)
        {
#if DEBUG
            if (operatorToken == null) throw new ArgumentNullException(nameof(operatorToken));
            if (operatorToken.Kind != SyntaxKind.NotKeyword) throw new ArgumentException(nameof(operatorToken));
            if (pattern == null) throw new ArgumentNullException(nameof(pattern));
#endif

            int hash;
            var cached = CSharpSyntaxNodeCache.TryGetNode((int)SyntaxKind.NotPattern, operatorToken, pattern, this.context, out hash);
            if (cached != null) return (UnaryPatternSyntax)cached;

            var result = new UnaryPatternSyntax(SyntaxKind.NotPattern, operatorToken, pattern, this.context);
            if (hash >= 0)
            {
                SyntaxNodeCache.AddNode(result, hash);
            }

            return result;
        }

        public InterpolatedStringTextSyntax InterpolatedStringText(SyntaxToken textToken)
        {
#if DEBUG
            if (textToken == null) throw new ArgumentNullException(nameof(textToken));
            if (textToken.Kind != SyntaxKind.InterpolatedStringTextToken) throw new ArgumentException(nameof(textToken));
#endif

            int hash;
            var cached = CSharpSyntaxNodeCache.TryGetNode((int)SyntaxKind.InterpolatedStringText, textToken, this.context, out hash);
            if (cached != null) return (InterpolatedStringTextSyntax)cached;

            var result = new InterpolatedStringTextSyntax(SyntaxKind.InterpolatedStringText, textToken, this.context);
            if (hash >= 0)
            {
                SyntaxNodeCache.AddNode(result, hash);
            }

            return result;
        }

        public InterpolationSyntax Interpolation(SyntaxToken openBraceToken, ExpressionSyntax expression, InterpolationAlignmentClauseSyntax? alignmentClause, InterpolationFormatClauseSyntax? formatClause, SyntaxToken closeBraceToken)
        {
#if DEBUG
            if (openBraceToken == null) throw new ArgumentNullException(nameof(openBraceToken));
            if (openBraceToken.Kind != SyntaxKind.OpenBraceToken) throw new ArgumentException(nameof(openBraceToken));
            if (expression == null) throw new ArgumentNullException(nameof(expression));
            if (closeBraceToken == null) throw new ArgumentNullException(nameof(closeBraceToken));
            if (closeBraceToken.Kind != SyntaxKind.CloseBraceToken) throw new ArgumentException(nameof(closeBraceToken));
#endif

            return new InterpolationSyntax(SyntaxKind.Interpolation, openBraceToken, expression, alignmentClause, formatClause, closeBraceToken, this.context);
        }

        public InterpolationAlignmentClauseSyntax InterpolationAlignmentClause(SyntaxToken commaToken, ExpressionSyntax value)
        {
#if DEBUG
            if (commaToken == null) throw new ArgumentNullException(nameof(commaToken));
            if (value == null) throw new ArgumentNullException(nameof(value));
#endif

            int hash;
            var cached = CSharpSyntaxNodeCache.TryGetNode((int)SyntaxKind.InterpolationAlignmentClause, commaToken, value, this.context, out hash);
            if (cached != null) return (InterpolationAlignmentClauseSyntax)cached;

            var result = new InterpolationAlignmentClauseSyntax(SyntaxKind.InterpolationAlignmentClause, commaToken, value, this.context);
            if (hash >= 0)
            {
                SyntaxNodeCache.AddNode(result, hash);
            }

            return result;
        }

        public InterpolationFormatClauseSyntax InterpolationFormatClause(SyntaxToken colonToken, SyntaxToken formatStringToken)
        {
#if DEBUG
            if (colonToken == null) throw new ArgumentNullException(nameof(colonToken));
            if (formatStringToken == null) throw new ArgumentNullException(nameof(formatStringToken));
            if (formatStringToken.Kind != SyntaxKind.InterpolatedStringTextToken) throw new ArgumentException(nameof(formatStringToken));
#endif

            int hash;
            var cached = CSharpSyntaxNodeCache.TryGetNode((int)SyntaxKind.InterpolationFormatClause, colonToken, formatStringToken, this.context, out hash);
            if (cached != null) return (InterpolationFormatClauseSyntax)cached;

            var result = new InterpolationFormatClauseSyntax(SyntaxKind.InterpolationFormatClause, colonToken, formatStringToken, this.context);
            if (hash >= 0)
            {
                SyntaxNodeCache.AddNode(result, hash);
            }

            return result;
        }

        public GlobalStatementSyntax GlobalStatement(Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<AttributeListSyntax> attributeLists, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SyntaxToken> modifiers, StatementSyntax statement)
        {
#if DEBUG
            if (statement == null) throw new ArgumentNullException(nameof(statement));
#endif

            int hash;
            var cached = CSharpSyntaxNodeCache.TryGetNode((int)SyntaxKind.GlobalStatement, attributeLists.Node, modifiers.Node, statement, this.context, out hash);
            if (cached != null) return (GlobalStatementSyntax)cached;

            var result = new GlobalStatementSyntax(SyntaxKind.GlobalStatement, attributeLists.Node, modifiers.Node, statement, this.context);
            if (hash >= 0)
            {
                SyntaxNodeCache.AddNode(result, hash);
            }

            return result;
        }

        public BlockSyntax Block(Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<AttributeListSyntax> attributeLists, SyntaxToken openBraceToken, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<StatementSyntax> statements, SyntaxToken closeBraceToken)
        {
#if DEBUG
            if (openBraceToken == null) throw new ArgumentNullException(nameof(openBraceToken));
            if (openBraceToken.Kind != SyntaxKind.OpenBraceToken) throw new ArgumentException(nameof(openBraceToken));
            if (closeBraceToken == null) throw new ArgumentNullException(nameof(closeBraceToken));
            if (closeBraceToken.Kind != SyntaxKind.CloseBraceToken) throw new ArgumentException(nameof(closeBraceToken));
#endif

            return new BlockSyntax(SyntaxKind.Block, attributeLists.Node, openBraceToken, statements.Node, closeBraceToken, this.context);
        }

        public LocalFunctionStatementSyntax LocalFunctionStatement(Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<AttributeListSyntax> attributeLists, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SyntaxToken> modifiers, TypeSyntax returnType, SyntaxToken identifier, TypeParameterListSyntax? typeParameterList, ParameterListSyntax parameterList, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<TypeParameterConstraintClauseSyntax> constraintClauses, BlockSyntax? body, ArrowExpressionClauseSyntax? expressionBody, SyntaxToken? semicolonToken)
        {
#if DEBUG
            if (returnType == null) throw new ArgumentNullException(nameof(returnType));
            if (identifier == null) throw new ArgumentNullException(nameof(identifier));
            if (identifier.Kind != SyntaxKind.IdentifierToken) throw new ArgumentException(nameof(identifier));
            if (parameterList == null) throw new ArgumentNullException(nameof(parameterList));
            if (semicolonToken != null)
            {
                switch (semicolonToken.Kind)
                {
                    case SyntaxKind.SemicolonToken:
                    case SyntaxKind.None: break;
                    default: throw new ArgumentException(nameof(semicolonToken));
                }
            }
#endif

            return new LocalFunctionStatementSyntax(SyntaxKind.LocalFunctionStatement, attributeLists.Node, modifiers.Node, returnType, identifier, typeParameterList, parameterList, constraintClauses.Node, body, expressionBody, semicolonToken, this.context);
        }

        public LocalDeclarationStatementSyntax LocalDeclarationStatement(Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<AttributeListSyntax> attributeLists, SyntaxToken? awaitKeyword, SyntaxToken? usingKeyword, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SyntaxToken> modifiers, VariableDeclarationSyntax declaration, SyntaxToken semicolonToken)
        {
#if DEBUG
            if (awaitKeyword != null)
            {
                switch (awaitKeyword.Kind)
                {
                    case SyntaxKind.AwaitKeyword:
                    case SyntaxKind.None: break;
                    default: throw new ArgumentException(nameof(awaitKeyword));
                }
            }
            if (usingKeyword != null)
            {
                switch (usingKeyword.Kind)
                {
                    case SyntaxKind.UsingKeyword:
                    case SyntaxKind.None: break;
                    default: throw new ArgumentException(nameof(usingKeyword));
                }
            }
            if (declaration == null) throw new ArgumentNullException(nameof(declaration));
            if (semicolonToken == null) throw new ArgumentNullException(nameof(semicolonToken));
            if (semicolonToken.Kind != SyntaxKind.SemicolonToken) throw new ArgumentException(nameof(semicolonToken));
#endif

            return new LocalDeclarationStatementSyntax(SyntaxKind.LocalDeclarationStatement, attributeLists.Node, awaitKeyword, usingKeyword, modifiers.Node, declaration, semicolonToken, this.context);
        }

        public VariableDeclarationSyntax VariableDeclaration(TypeSyntax type, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<VariableDeclaratorSyntax> variables)
        {
#if DEBUG
            if (type == null) throw new ArgumentNullException(nameof(type));
#endif

            int hash;
            var cached = CSharpSyntaxNodeCache.TryGetNode((int)SyntaxKind.VariableDeclaration, type, variables.Node, this.context, out hash);
            if (cached != null) return (VariableDeclarationSyntax)cached;

            var result = new VariableDeclarationSyntax(SyntaxKind.VariableDeclaration, type, variables.Node, this.context);
            if (hash >= 0)
            {
                SyntaxNodeCache.AddNode(result, hash);
            }

            return result;
        }

        public VariableDeclaratorSyntax VariableDeclarator(SyntaxToken identifier, BracketedArgumentListSyntax? argumentList, EqualsValueClauseSyntax? initializer)
        {
#if DEBUG
            if (identifier == null) throw new ArgumentNullException(nameof(identifier));
            if (identifier.Kind != SyntaxKind.IdentifierToken) throw new ArgumentException(nameof(identifier));
#endif

            int hash;
            var cached = CSharpSyntaxNodeCache.TryGetNode((int)SyntaxKind.VariableDeclarator, identifier, argumentList, initializer, this.context, out hash);
            if (cached != null) return (VariableDeclaratorSyntax)cached;

            var result = new VariableDeclaratorSyntax(SyntaxKind.VariableDeclarator, identifier, argumentList, initializer, this.context);
            if (hash >= 0)
            {
                SyntaxNodeCache.AddNode(result, hash);
            }

            return result;
        }

        public EqualsValueClauseSyntax EqualsValueClause(SyntaxToken equalsToken, ExpressionSyntax value)
        {
#if DEBUG
            if (equalsToken == null) throw new ArgumentNullException(nameof(equalsToken));
            if (equalsToken.Kind != SyntaxKind.EqualsToken) throw new ArgumentException(nameof(equalsToken));
            if (value == null) throw new ArgumentNullException(nameof(value));
#endif

            int hash;
            var cached = CSharpSyntaxNodeCache.TryGetNode((int)SyntaxKind.EqualsValueClause, equalsToken, value, this.context, out hash);
            if (cached != null) return (EqualsValueClauseSyntax)cached;

            var result = new EqualsValueClauseSyntax(SyntaxKind.EqualsValueClause, equalsToken, value, this.context);
            if (hash >= 0)
            {
                SyntaxNodeCache.AddNode(result, hash);
            }

            return result;
        }

        public SingleVariableDesignationSyntax SingleVariableDesignation(SyntaxToken identifier)
        {
#if DEBUG
            if (identifier == null) throw new ArgumentNullException(nameof(identifier));
            if (identifier.Kind != SyntaxKind.IdentifierToken) throw new ArgumentException(nameof(identifier));
#endif

            int hash;
            var cached = CSharpSyntaxNodeCache.TryGetNode((int)SyntaxKind.SingleVariableDesignation, identifier, this.context, out hash);
            if (cached != null) return (SingleVariableDesignationSyntax)cached;

            var result = new SingleVariableDesignationSyntax(SyntaxKind.SingleVariableDesignation, identifier, this.context);
            if (hash >= 0)
            {
                SyntaxNodeCache.AddNode(result, hash);
            }

            return result;
        }

        public DiscardDesignationSyntax DiscardDesignation(SyntaxToken underscoreToken)
        {
#if DEBUG
            if (underscoreToken == null) throw new ArgumentNullException(nameof(underscoreToken));
            if (underscoreToken.Kind != SyntaxKind.UnderscoreToken) throw new ArgumentException(nameof(underscoreToken));
#endif

            int hash;
            var cached = CSharpSyntaxNodeCache.TryGetNode((int)SyntaxKind.DiscardDesignation, underscoreToken, this.context, out hash);
            if (cached != null) return (DiscardDesignationSyntax)cached;

            var result = new DiscardDesignationSyntax(SyntaxKind.DiscardDesignation, underscoreToken, this.context);
            if (hash >= 0)
            {
                SyntaxNodeCache.AddNode(result, hash);
            }

            return result;
        }

        public ParenthesizedVariableDesignationSyntax ParenthesizedVariableDesignation(SyntaxToken openParenToken, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<VariableDesignationSyntax> variables, SyntaxToken closeParenToken)
        {
#if DEBUG
            if (openParenToken == null) throw new ArgumentNullException(nameof(openParenToken));
            if (openParenToken.Kind != SyntaxKind.OpenParenToken) throw new ArgumentException(nameof(openParenToken));
            if (closeParenToken == null) throw new ArgumentNullException(nameof(closeParenToken));
            if (closeParenToken.Kind != SyntaxKind.CloseParenToken) throw new ArgumentException(nameof(closeParenToken));
#endif

            int hash;
            var cached = CSharpSyntaxNodeCache.TryGetNode((int)SyntaxKind.ParenthesizedVariableDesignation, openParenToken, variables.Node, closeParenToken, this.context, out hash);
            if (cached != null) return (ParenthesizedVariableDesignationSyntax)cached;

            var result = new ParenthesizedVariableDesignationSyntax(SyntaxKind.ParenthesizedVariableDesignation, openParenToken, variables.Node, closeParenToken, this.context);
            if (hash >= 0)
            {
                SyntaxNodeCache.AddNode(result, hash);
            }

            return result;
        }

        public ExpressionStatementSyntax ExpressionStatement(Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<AttributeListSyntax> attributeLists, ExpressionSyntax expression, SyntaxToken semicolonToken)
        {
#if DEBUG
            if (expression == null) throw new ArgumentNullException(nameof(expression));
            if (semicolonToken == null) throw new ArgumentNullException(nameof(semicolonToken));
            if (semicolonToken.Kind != SyntaxKind.SemicolonToken) throw new ArgumentException(nameof(semicolonToken));
#endif

            int hash;
            var cached = CSharpSyntaxNodeCache.TryGetNode((int)SyntaxKind.ExpressionStatement, attributeLists.Node, expression, semicolonToken, this.context, out hash);
            if (cached != null) return (ExpressionStatementSyntax)cached;

            var result = new ExpressionStatementSyntax(SyntaxKind.ExpressionStatement, attributeLists.Node, expression, semicolonToken, this.context);
            if (hash >= 0)
            {
                SyntaxNodeCache.AddNode(result, hash);
            }

            return result;
        }

        public EmptyStatementSyntax EmptyStatement(Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<AttributeListSyntax> attributeLists, SyntaxToken semicolonToken)
        {
#if DEBUG
            if (semicolonToken == null) throw new ArgumentNullException(nameof(semicolonToken));
            if (semicolonToken.Kind != SyntaxKind.SemicolonToken) throw new ArgumentException(nameof(semicolonToken));
#endif

            int hash;
            var cached = CSharpSyntaxNodeCache.TryGetNode((int)SyntaxKind.EmptyStatement, attributeLists.Node, semicolonToken, this.context, out hash);
            if (cached != null) return (EmptyStatementSyntax)cached;

            var result = new EmptyStatementSyntax(SyntaxKind.EmptyStatement, attributeLists.Node, semicolonToken, this.context);
            if (hash >= 0)
            {
                SyntaxNodeCache.AddNode(result, hash);
            }

            return result;
        }

        public LabeledStatementSyntax LabeledStatement(Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<AttributeListSyntax> attributeLists, SyntaxToken identifier, SyntaxToken colonToken, StatementSyntax statement)
        {
#if DEBUG
            if (identifier == null) throw new ArgumentNullException(nameof(identifier));
            if (identifier.Kind != SyntaxKind.IdentifierToken) throw new ArgumentException(nameof(identifier));
            if (colonToken == null) throw new ArgumentNullException(nameof(colonToken));
            if (colonToken.Kind != SyntaxKind.ColonToken) throw new ArgumentException(nameof(colonToken));
            if (statement == null) throw new ArgumentNullException(nameof(statement));
#endif

            return new LabeledStatementSyntax(SyntaxKind.LabeledStatement, attributeLists.Node, identifier, colonToken, statement, this.context);
        }

        public GotoStatementSyntax GotoStatement(SyntaxKind kind, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<AttributeListSyntax> attributeLists, SyntaxToken gotoKeyword, SyntaxToken? caseOrDefaultKeyword, ExpressionSyntax? expression, SyntaxToken semicolonToken)
        {
            switch (kind)
            {
                case SyntaxKind.GotoStatement:
                case SyntaxKind.GotoCaseStatement:
                case SyntaxKind.GotoDefaultStatement: break;
                default: throw new ArgumentException(nameof(kind));
            }
#if DEBUG
            if (gotoKeyword == null) throw new ArgumentNullException(nameof(gotoKeyword));
            if (gotoKeyword.Kind != SyntaxKind.GotoKeyword) throw new ArgumentException(nameof(gotoKeyword));
            if (caseOrDefaultKeyword != null)
            {
                switch (caseOrDefaultKeyword.Kind)
                {
                    case SyntaxKind.CaseKeyword:
                    case SyntaxKind.DefaultKeyword:
                    case SyntaxKind.None: break;
                    default: throw new ArgumentException(nameof(caseOrDefaultKeyword));
                }
            }
            if (semicolonToken == null) throw new ArgumentNullException(nameof(semicolonToken));
            if (semicolonToken.Kind != SyntaxKind.SemicolonToken) throw new ArgumentException(nameof(semicolonToken));
#endif

            return new GotoStatementSyntax(kind, attributeLists.Node, gotoKeyword, caseOrDefaultKeyword, expression, semicolonToken, this.context);
        }

        public BreakStatementSyntax BreakStatement(Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<AttributeListSyntax> attributeLists, SyntaxToken breakKeyword, SyntaxToken semicolonToken)
        {
#if DEBUG
            if (breakKeyword == null) throw new ArgumentNullException(nameof(breakKeyword));
            if (breakKeyword.Kind != SyntaxKind.BreakKeyword) throw new ArgumentException(nameof(breakKeyword));
            if (semicolonToken == null) throw new ArgumentNullException(nameof(semicolonToken));
            if (semicolonToken.Kind != SyntaxKind.SemicolonToken) throw new ArgumentException(nameof(semicolonToken));
#endif

            int hash;
            var cached = CSharpSyntaxNodeCache.TryGetNode((int)SyntaxKind.BreakStatement, attributeLists.Node, breakKeyword, semicolonToken, this.context, out hash);
            if (cached != null) return (BreakStatementSyntax)cached;

            var result = new BreakStatementSyntax(SyntaxKind.BreakStatement, attributeLists.Node, breakKeyword, semicolonToken, this.context);
            if (hash >= 0)
            {
                SyntaxNodeCache.AddNode(result, hash);
            }

            return result;
        }

        public ContinueStatementSyntax ContinueStatement(Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<AttributeListSyntax> attributeLists, SyntaxToken continueKeyword, SyntaxToken semicolonToken)
        {
#if DEBUG
            if (continueKeyword == null) throw new ArgumentNullException(nameof(continueKeyword));
            if (continueKeyword.Kind != SyntaxKind.ContinueKeyword) throw new ArgumentException(nameof(continueKeyword));
            if (semicolonToken == null) throw new ArgumentNullException(nameof(semicolonToken));
            if (semicolonToken.Kind != SyntaxKind.SemicolonToken) throw new ArgumentException(nameof(semicolonToken));
#endif

            int hash;
            var cached = CSharpSyntaxNodeCache.TryGetNode((int)SyntaxKind.ContinueStatement, attributeLists.Node, continueKeyword, semicolonToken, this.context, out hash);
            if (cached != null) return (ContinueStatementSyntax)cached;

            var result = new ContinueStatementSyntax(SyntaxKind.ContinueStatement, attributeLists.Node, continueKeyword, semicolonToken, this.context);
            if (hash >= 0)
            {
                SyntaxNodeCache.AddNode(result, hash);
            }

            return result;
        }

        public ReturnStatementSyntax ReturnStatement(Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<AttributeListSyntax> attributeLists, SyntaxToken returnKeyword, ExpressionSyntax? expression, SyntaxToken semicolonToken)
        {
#if DEBUG
            if (returnKeyword == null) throw new ArgumentNullException(nameof(returnKeyword));
            if (returnKeyword.Kind != SyntaxKind.ReturnKeyword) throw new ArgumentException(nameof(returnKeyword));
            if (semicolonToken == null) throw new ArgumentNullException(nameof(semicolonToken));
            if (semicolonToken.Kind != SyntaxKind.SemicolonToken) throw new ArgumentException(nameof(semicolonToken));
#endif

            return new ReturnStatementSyntax(SyntaxKind.ReturnStatement, attributeLists.Node, returnKeyword, expression, semicolonToken, this.context);
        }

        public ThrowStatementSyntax ThrowStatement(Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<AttributeListSyntax> attributeLists, SyntaxToken throwKeyword, ExpressionSyntax? expression, SyntaxToken semicolonToken)
        {
#if DEBUG
            if (throwKeyword == null) throw new ArgumentNullException(nameof(throwKeyword));
            if (throwKeyword.Kind != SyntaxKind.ThrowKeyword) throw new ArgumentException(nameof(throwKeyword));
            if (semicolonToken == null) throw new ArgumentNullException(nameof(semicolonToken));
            if (semicolonToken.Kind != SyntaxKind.SemicolonToken) throw new ArgumentException(nameof(semicolonToken));
#endif

            return new ThrowStatementSyntax(SyntaxKind.ThrowStatement, attributeLists.Node, throwKeyword, expression, semicolonToken, this.context);
        }

        public YieldStatementSyntax YieldStatement(SyntaxKind kind, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<AttributeListSyntax> attributeLists, SyntaxToken yieldKeyword, SyntaxToken returnOrBreakKeyword, ExpressionSyntax? expression, SyntaxToken semicolonToken)
        {
            switch (kind)
            {
                case SyntaxKind.YieldReturnStatement:
                case SyntaxKind.YieldBreakStatement: break;
                default: throw new ArgumentException(nameof(kind));
            }
#if DEBUG
            if (yieldKeyword == null) throw new ArgumentNullException(nameof(yieldKeyword));
            if (yieldKeyword.Kind != SyntaxKind.YieldKeyword) throw new ArgumentException(nameof(yieldKeyword));
            if (returnOrBreakKeyword == null) throw new ArgumentNullException(nameof(returnOrBreakKeyword));
            switch (returnOrBreakKeyword.Kind)
            {
                case SyntaxKind.ReturnKeyword:
                case SyntaxKind.BreakKeyword: break;
                default: throw new ArgumentException(nameof(returnOrBreakKeyword));
            }
            if (semicolonToken == null) throw new ArgumentNullException(nameof(semicolonToken));
            if (semicolonToken.Kind != SyntaxKind.SemicolonToken) throw new ArgumentException(nameof(semicolonToken));
#endif

            return new YieldStatementSyntax(kind, attributeLists.Node, yieldKeyword, returnOrBreakKeyword, expression, semicolonToken, this.context);
        }

        public WhileStatementSyntax WhileStatement(Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<AttributeListSyntax> attributeLists, SyntaxToken whileKeyword, SyntaxToken openParenToken, ExpressionSyntax condition, SyntaxToken closeParenToken, StatementSyntax statement)
        {
#if DEBUG
            if (whileKeyword == null) throw new ArgumentNullException(nameof(whileKeyword));
            if (whileKeyword.Kind != SyntaxKind.WhileKeyword) throw new ArgumentException(nameof(whileKeyword));
            if (openParenToken == null) throw new ArgumentNullException(nameof(openParenToken));
            if (openParenToken.Kind != SyntaxKind.OpenParenToken) throw new ArgumentException(nameof(openParenToken));
            if (condition == null) throw new ArgumentNullException(nameof(condition));
            if (closeParenToken == null) throw new ArgumentNullException(nameof(closeParenToken));
            if (closeParenToken.Kind != SyntaxKind.CloseParenToken) throw new ArgumentException(nameof(closeParenToken));
            if (statement == null) throw new ArgumentNullException(nameof(statement));
#endif

            return new WhileStatementSyntax(SyntaxKind.WhileStatement, attributeLists.Node, whileKeyword, openParenToken, condition, closeParenToken, statement, this.context);
        }

        public DoStatementSyntax DoStatement(Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<AttributeListSyntax> attributeLists, SyntaxToken doKeyword, StatementSyntax statement, SyntaxToken whileKeyword, SyntaxToken openParenToken, ExpressionSyntax condition, SyntaxToken closeParenToken, SyntaxToken semicolonToken)
        {
#if DEBUG
            if (doKeyword == null) throw new ArgumentNullException(nameof(doKeyword));
            if (doKeyword.Kind != SyntaxKind.DoKeyword) throw new ArgumentException(nameof(doKeyword));
            if (statement == null) throw new ArgumentNullException(nameof(statement));
            if (whileKeyword == null) throw new ArgumentNullException(nameof(whileKeyword));
            if (whileKeyword.Kind != SyntaxKind.WhileKeyword) throw new ArgumentException(nameof(whileKeyword));
            if (openParenToken == null) throw new ArgumentNullException(nameof(openParenToken));
            if (openParenToken.Kind != SyntaxKind.OpenParenToken) throw new ArgumentException(nameof(openParenToken));
            if (condition == null) throw new ArgumentNullException(nameof(condition));
            if (closeParenToken == null) throw new ArgumentNullException(nameof(closeParenToken));
            if (closeParenToken.Kind != SyntaxKind.CloseParenToken) throw new ArgumentException(nameof(closeParenToken));
            if (semicolonToken == null) throw new ArgumentNullException(nameof(semicolonToken));
            if (semicolonToken.Kind != SyntaxKind.SemicolonToken) throw new ArgumentException(nameof(semicolonToken));
#endif

            return new DoStatementSyntax(SyntaxKind.DoStatement, attributeLists.Node, doKeyword, statement, whileKeyword, openParenToken, condition, closeParenToken, semicolonToken, this.context);
        }

        public ForStatementSyntax ForStatement(Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<AttributeListSyntax> attributeLists, SyntaxToken forKeyword, SyntaxToken openParenToken, VariableDeclarationSyntax? declaration, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<ExpressionSyntax> initializers, SyntaxToken firstSemicolonToken, ExpressionSyntax? condition, SyntaxToken secondSemicolonToken, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<ExpressionSyntax> incrementors, SyntaxToken closeParenToken, StatementSyntax statement)
        {
#if DEBUG
            if (forKeyword == null) throw new ArgumentNullException(nameof(forKeyword));
            if (forKeyword.Kind != SyntaxKind.ForKeyword) throw new ArgumentException(nameof(forKeyword));
            if (openParenToken == null) throw new ArgumentNullException(nameof(openParenToken));
            if (openParenToken.Kind != SyntaxKind.OpenParenToken) throw new ArgumentException(nameof(openParenToken));
            if (firstSemicolonToken == null) throw new ArgumentNullException(nameof(firstSemicolonToken));
            if (firstSemicolonToken.Kind != SyntaxKind.SemicolonToken) throw new ArgumentException(nameof(firstSemicolonToken));
            if (secondSemicolonToken == null) throw new ArgumentNullException(nameof(secondSemicolonToken));
            if (secondSemicolonToken.Kind != SyntaxKind.SemicolonToken) throw new ArgumentException(nameof(secondSemicolonToken));
            if (closeParenToken == null) throw new ArgumentNullException(nameof(closeParenToken));
            if (closeParenToken.Kind != SyntaxKind.CloseParenToken) throw new ArgumentException(nameof(closeParenToken));
            if (statement == null) throw new ArgumentNullException(nameof(statement));
#endif

            return new ForStatementSyntax(SyntaxKind.ForStatement, attributeLists.Node, forKeyword, openParenToken, declaration, initializers.Node, firstSemicolonToken, condition, secondSemicolonToken, incrementors.Node, closeParenToken, statement, this.context);
        }

        public ForEachStatementSyntax ForEachStatement(Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<AttributeListSyntax> attributeLists, SyntaxToken? awaitKeyword, SyntaxToken forEachKeyword, SyntaxToken openParenToken, TypeSyntax type, SyntaxToken identifier, SyntaxToken inKeyword, ExpressionSyntax expression, SyntaxToken closeParenToken, StatementSyntax statement)
        {
#if DEBUG
            if (awaitKeyword != null)
            {
                switch (awaitKeyword.Kind)
                {
                    case SyntaxKind.AwaitKeyword:
                    case SyntaxKind.None: break;
                    default: throw new ArgumentException(nameof(awaitKeyword));
                }
            }
            if (forEachKeyword == null) throw new ArgumentNullException(nameof(forEachKeyword));
            if (forEachKeyword.Kind != SyntaxKind.ForEachKeyword) throw new ArgumentException(nameof(forEachKeyword));
            if (openParenToken == null) throw new ArgumentNullException(nameof(openParenToken));
            if (openParenToken.Kind != SyntaxKind.OpenParenToken) throw new ArgumentException(nameof(openParenToken));
            if (type == null) throw new ArgumentNullException(nameof(type));
            if (identifier == null) throw new ArgumentNullException(nameof(identifier));
            if (identifier.Kind != SyntaxKind.IdentifierToken) throw new ArgumentException(nameof(identifier));
            if (inKeyword == null) throw new ArgumentNullException(nameof(inKeyword));
            if (inKeyword.Kind != SyntaxKind.InKeyword) throw new ArgumentException(nameof(inKeyword));
            if (expression == null) throw new ArgumentNullException(nameof(expression));
            if (closeParenToken == null) throw new ArgumentNullException(nameof(closeParenToken));
            if (closeParenToken.Kind != SyntaxKind.CloseParenToken) throw new ArgumentException(nameof(closeParenToken));
            if (statement == null) throw new ArgumentNullException(nameof(statement));
#endif

            return new ForEachStatementSyntax(SyntaxKind.ForEachStatement, attributeLists.Node, awaitKeyword, forEachKeyword, openParenToken, type, identifier, inKeyword, expression, closeParenToken, statement, this.context);
        }

        public ForEachVariableStatementSyntax ForEachVariableStatement(Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<AttributeListSyntax> attributeLists, SyntaxToken? awaitKeyword, SyntaxToken forEachKeyword, SyntaxToken openParenToken, ExpressionSyntax variable, SyntaxToken inKeyword, ExpressionSyntax expression, SyntaxToken closeParenToken, StatementSyntax statement)
        {
#if DEBUG
            if (awaitKeyword != null)
            {
                switch (awaitKeyword.Kind)
                {
                    case SyntaxKind.AwaitKeyword:
                    case SyntaxKind.None: break;
                    default: throw new ArgumentException(nameof(awaitKeyword));
                }
            }
            if (forEachKeyword == null) throw new ArgumentNullException(nameof(forEachKeyword));
            if (forEachKeyword.Kind != SyntaxKind.ForEachKeyword) throw new ArgumentException(nameof(forEachKeyword));
            if (openParenToken == null) throw new ArgumentNullException(nameof(openParenToken));
            if (openParenToken.Kind != SyntaxKind.OpenParenToken) throw new ArgumentException(nameof(openParenToken));
            if (variable == null) throw new ArgumentNullException(nameof(variable));
            if (inKeyword == null) throw new ArgumentNullException(nameof(inKeyword));
            if (inKeyword.Kind != SyntaxKind.InKeyword) throw new ArgumentException(nameof(inKeyword));
            if (expression == null) throw new ArgumentNullException(nameof(expression));
            if (closeParenToken == null) throw new ArgumentNullException(nameof(closeParenToken));
            if (closeParenToken.Kind != SyntaxKind.CloseParenToken) throw new ArgumentException(nameof(closeParenToken));
            if (statement == null) throw new ArgumentNullException(nameof(statement));
#endif

            return new ForEachVariableStatementSyntax(SyntaxKind.ForEachVariableStatement, attributeLists.Node, awaitKeyword, forEachKeyword, openParenToken, variable, inKeyword, expression, closeParenToken, statement, this.context);
        }

        public UsingStatementSyntax UsingStatement(Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<AttributeListSyntax> attributeLists, SyntaxToken? awaitKeyword, SyntaxToken usingKeyword, SyntaxToken openParenToken, VariableDeclarationSyntax? declaration, ExpressionSyntax? expression, SyntaxToken closeParenToken, StatementSyntax statement)
        {
#if DEBUG
            if (awaitKeyword != null)
            {
                switch (awaitKeyword.Kind)
                {
                    case SyntaxKind.AwaitKeyword:
                    case SyntaxKind.None: break;
                    default: throw new ArgumentException(nameof(awaitKeyword));
                }
            }
            if (usingKeyword == null) throw new ArgumentNullException(nameof(usingKeyword));
            if (usingKeyword.Kind != SyntaxKind.UsingKeyword) throw new ArgumentException(nameof(usingKeyword));
            if (openParenToken == null) throw new ArgumentNullException(nameof(openParenToken));
            if (openParenToken.Kind != SyntaxKind.OpenParenToken) throw new ArgumentException(nameof(openParenToken));
            if (closeParenToken == null) throw new ArgumentNullException(nameof(closeParenToken));
            if (closeParenToken.Kind != SyntaxKind.CloseParenToken) throw new ArgumentException(nameof(closeParenToken));
            if (statement == null) throw new ArgumentNullException(nameof(statement));
#endif

            return new UsingStatementSyntax(SyntaxKind.UsingStatement, attributeLists.Node, awaitKeyword, usingKeyword, openParenToken, declaration, expression, closeParenToken, statement, this.context);
        }

        public FixedStatementSyntax FixedStatement(Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<AttributeListSyntax> attributeLists, SyntaxToken fixedKeyword, SyntaxToken openParenToken, VariableDeclarationSyntax declaration, SyntaxToken closeParenToken, StatementSyntax statement)
        {
#if DEBUG
            if (fixedKeyword == null) throw new ArgumentNullException(nameof(fixedKeyword));
            if (fixedKeyword.Kind != SyntaxKind.FixedKeyword) throw new ArgumentException(nameof(fixedKeyword));
            if (openParenToken == null) throw new ArgumentNullException(nameof(openParenToken));
            if (openParenToken.Kind != SyntaxKind.OpenParenToken) throw new ArgumentException(nameof(openParenToken));
            if (declaration == null) throw new ArgumentNullException(nameof(declaration));
            if (closeParenToken == null) throw new ArgumentNullException(nameof(closeParenToken));
            if (closeParenToken.Kind != SyntaxKind.CloseParenToken) throw new ArgumentException(nameof(closeParenToken));
            if (statement == null) throw new ArgumentNullException(nameof(statement));
#endif

            return new FixedStatementSyntax(SyntaxKind.FixedStatement, attributeLists.Node, fixedKeyword, openParenToken, declaration, closeParenToken, statement, this.context);
        }

        public CheckedStatementSyntax CheckedStatement(SyntaxKind kind, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<AttributeListSyntax> attributeLists, SyntaxToken keyword, BlockSyntax block)
        {
            switch (kind)
            {
                case SyntaxKind.CheckedStatement:
                case SyntaxKind.UncheckedStatement: break;
                default: throw new ArgumentException(nameof(kind));
            }
#if DEBUG
            if (keyword == null) throw new ArgumentNullException(nameof(keyword));
            switch (keyword.Kind)
            {
                case SyntaxKind.CheckedKeyword:
                case SyntaxKind.UncheckedKeyword: break;
                default: throw new ArgumentException(nameof(keyword));
            }
            if (block == null) throw new ArgumentNullException(nameof(block));
#endif

            int hash;
            var cached = CSharpSyntaxNodeCache.TryGetNode((int)kind, attributeLists.Node, keyword, block, this.context, out hash);
            if (cached != null) return (CheckedStatementSyntax)cached;

            var result = new CheckedStatementSyntax(kind, attributeLists.Node, keyword, block, this.context);
            if (hash >= 0)
            {
                SyntaxNodeCache.AddNode(result, hash);
            }

            return result;
        }

        public UnsafeStatementSyntax UnsafeStatement(Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<AttributeListSyntax> attributeLists, SyntaxToken unsafeKeyword, BlockSyntax block)
        {
#if DEBUG
            if (unsafeKeyword == null) throw new ArgumentNullException(nameof(unsafeKeyword));
            if (unsafeKeyword.Kind != SyntaxKind.UnsafeKeyword) throw new ArgumentException(nameof(unsafeKeyword));
            if (block == null) throw new ArgumentNullException(nameof(block));
#endif

            int hash;
            var cached = CSharpSyntaxNodeCache.TryGetNode((int)SyntaxKind.UnsafeStatement, attributeLists.Node, unsafeKeyword, block, this.context, out hash);
            if (cached != null) return (UnsafeStatementSyntax)cached;

            var result = new UnsafeStatementSyntax(SyntaxKind.UnsafeStatement, attributeLists.Node, unsafeKeyword, block, this.context);
            if (hash >= 0)
            {
                SyntaxNodeCache.AddNode(result, hash);
            }

            return result;
        }

        public LockStatementSyntax LockStatement(Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<AttributeListSyntax> attributeLists, SyntaxToken lockKeyword, SyntaxToken openParenToken, ExpressionSyntax expression, SyntaxToken closeParenToken, StatementSyntax statement)
        {
#if DEBUG
            if (lockKeyword == null) throw new ArgumentNullException(nameof(lockKeyword));
            if (lockKeyword.Kind != SyntaxKind.LockKeyword) throw new ArgumentException(nameof(lockKeyword));
            if (openParenToken == null) throw new ArgumentNullException(nameof(openParenToken));
            if (openParenToken.Kind != SyntaxKind.OpenParenToken) throw new ArgumentException(nameof(openParenToken));
            if (expression == null) throw new ArgumentNullException(nameof(expression));
            if (closeParenToken == null) throw new ArgumentNullException(nameof(closeParenToken));
            if (closeParenToken.Kind != SyntaxKind.CloseParenToken) throw new ArgumentException(nameof(closeParenToken));
            if (statement == null) throw new ArgumentNullException(nameof(statement));
#endif

            return new LockStatementSyntax(SyntaxKind.LockStatement, attributeLists.Node, lockKeyword, openParenToken, expression, closeParenToken, statement, this.context);
        }

        public IfStatementSyntax IfStatement(Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<AttributeListSyntax> attributeLists, SyntaxToken ifKeyword, SyntaxToken openParenToken, ExpressionSyntax condition, SyntaxToken closeParenToken, StatementSyntax statement, ElseClauseSyntax? @else)
        {
#if DEBUG
            if (ifKeyword == null) throw new ArgumentNullException(nameof(ifKeyword));
            if (ifKeyword.Kind != SyntaxKind.IfKeyword) throw new ArgumentException(nameof(ifKeyword));
            if (openParenToken == null) throw new ArgumentNullException(nameof(openParenToken));
            if (openParenToken.Kind != SyntaxKind.OpenParenToken) throw new ArgumentException(nameof(openParenToken));
            if (condition == null) throw new ArgumentNullException(nameof(condition));
            if (closeParenToken == null) throw new ArgumentNullException(nameof(closeParenToken));
            if (closeParenToken.Kind != SyntaxKind.CloseParenToken) throw new ArgumentException(nameof(closeParenToken));
            if (statement == null) throw new ArgumentNullException(nameof(statement));
#endif

            return new IfStatementSyntax(SyntaxKind.IfStatement, attributeLists.Node, ifKeyword, openParenToken, condition, closeParenToken, statement, @else, this.context);
        }

        public ElseClauseSyntax ElseClause(SyntaxToken elseKeyword, StatementSyntax statement)
        {
#if DEBUG
            if (elseKeyword == null) throw new ArgumentNullException(nameof(elseKeyword));
            if (elseKeyword.Kind != SyntaxKind.ElseKeyword) throw new ArgumentException(nameof(elseKeyword));
            if (statement == null) throw new ArgumentNullException(nameof(statement));
#endif

            int hash;
            var cached = CSharpSyntaxNodeCache.TryGetNode((int)SyntaxKind.ElseClause, elseKeyword, statement, this.context, out hash);
            if (cached != null) return (ElseClauseSyntax)cached;

            var result = new ElseClauseSyntax(SyntaxKind.ElseClause, elseKeyword, statement, this.context);
            if (hash >= 0)
            {
                SyntaxNodeCache.AddNode(result, hash);
            }

            return result;
        }

        public SwitchStatementSyntax SwitchStatement(Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<AttributeListSyntax> attributeLists, SyntaxToken switchKeyword, SyntaxToken? openParenToken, ExpressionSyntax expression, SyntaxToken? closeParenToken, SyntaxToken openBraceToken, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SwitchSectionSyntax> sections, SyntaxToken closeBraceToken)
        {
#if DEBUG
            if (switchKeyword == null) throw new ArgumentNullException(nameof(switchKeyword));
            if (switchKeyword.Kind != SyntaxKind.SwitchKeyword) throw new ArgumentException(nameof(switchKeyword));
            if (openParenToken != null)
            {
                switch (openParenToken.Kind)
                {
                    case SyntaxKind.OpenParenToken:
                    case SyntaxKind.None: break;
                    default: throw new ArgumentException(nameof(openParenToken));
                }
            }
            if (expression == null) throw new ArgumentNullException(nameof(expression));
            if (closeParenToken != null)
            {
                switch (closeParenToken.Kind)
                {
                    case SyntaxKind.CloseParenToken:
                    case SyntaxKind.None: break;
                    default: throw new ArgumentException(nameof(closeParenToken));
                }
            }
            if (openBraceToken == null) throw new ArgumentNullException(nameof(openBraceToken));
            if (openBraceToken.Kind != SyntaxKind.OpenBraceToken) throw new ArgumentException(nameof(openBraceToken));
            if (closeBraceToken == null) throw new ArgumentNullException(nameof(closeBraceToken));
            if (closeBraceToken.Kind != SyntaxKind.CloseBraceToken) throw new ArgumentException(nameof(closeBraceToken));
#endif

            return new SwitchStatementSyntax(SyntaxKind.SwitchStatement, attributeLists.Node, switchKeyword, openParenToken, expression, closeParenToken, openBraceToken, sections.Node, closeBraceToken, this.context);
        }

        public SwitchSectionSyntax SwitchSection(Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SwitchLabelSyntax> labels, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<StatementSyntax> statements)
        {
#if DEBUG
#endif

            int hash;
            var cached = CSharpSyntaxNodeCache.TryGetNode((int)SyntaxKind.SwitchSection, labels.Node, statements.Node, this.context, out hash);
            if (cached != null) return (SwitchSectionSyntax)cached;

            var result = new SwitchSectionSyntax(SyntaxKind.SwitchSection, labels.Node, statements.Node, this.context);
            if (hash >= 0)
            {
                SyntaxNodeCache.AddNode(result, hash);
            }

            return result;
        }

        public CasePatternSwitchLabelSyntax CasePatternSwitchLabel(SyntaxToken keyword, PatternSyntax pattern, WhenClauseSyntax? whenClause, SyntaxToken colonToken)
        {
#if DEBUG
            if (keyword == null) throw new ArgumentNullException(nameof(keyword));
            if (keyword.Kind != SyntaxKind.CaseKeyword) throw new ArgumentException(nameof(keyword));
            if (pattern == null) throw new ArgumentNullException(nameof(pattern));
            if (colonToken == null) throw new ArgumentNullException(nameof(colonToken));
#endif

            return new CasePatternSwitchLabelSyntax(SyntaxKind.CasePatternSwitchLabel, keyword, pattern, whenClause, colonToken, this.context);
        }

        public CaseSwitchLabelSyntax CaseSwitchLabel(SyntaxToken keyword, ExpressionSyntax value, SyntaxToken colonToken)
        {
#if DEBUG
            if (keyword == null) throw new ArgumentNullException(nameof(keyword));
            if (keyword.Kind != SyntaxKind.CaseKeyword) throw new ArgumentException(nameof(keyword));
            if (value == null) throw new ArgumentNullException(nameof(value));
            if (colonToken == null) throw new ArgumentNullException(nameof(colonToken));
#endif

            int hash;
            var cached = CSharpSyntaxNodeCache.TryGetNode((int)SyntaxKind.CaseSwitchLabel, keyword, value, colonToken, this.context, out hash);
            if (cached != null) return (CaseSwitchLabelSyntax)cached;

            var result = new CaseSwitchLabelSyntax(SyntaxKind.CaseSwitchLabel, keyword, value, colonToken, this.context);
            if (hash >= 0)
            {
                SyntaxNodeCache.AddNode(result, hash);
            }

            return result;
        }

        public DefaultSwitchLabelSyntax DefaultSwitchLabel(SyntaxToken keyword, SyntaxToken colonToken)
        {
#if DEBUG
            if (keyword == null) throw new ArgumentNullException(nameof(keyword));
            if (keyword.Kind != SyntaxKind.DefaultKeyword) throw new ArgumentException(nameof(keyword));
            if (colonToken == null) throw new ArgumentNullException(nameof(colonToken));
#endif

            int hash;
            var cached = CSharpSyntaxNodeCache.TryGetNode((int)SyntaxKind.DefaultSwitchLabel, keyword, colonToken, this.context, out hash);
            if (cached != null) return (DefaultSwitchLabelSyntax)cached;

            var result = new DefaultSwitchLabelSyntax(SyntaxKind.DefaultSwitchLabel, keyword, colonToken, this.context);
            if (hash >= 0)
            {
                SyntaxNodeCache.AddNode(result, hash);
            }

            return result;
        }

        public SwitchExpressionSyntax SwitchExpression(ExpressionSyntax governingExpression, SyntaxToken switchKeyword, SyntaxToken openBraceToken, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<SwitchExpressionArmSyntax> arms, SyntaxToken closeBraceToken)
        {
#if DEBUG
            if (governingExpression == null) throw new ArgumentNullException(nameof(governingExpression));
            if (switchKeyword == null) throw new ArgumentNullException(nameof(switchKeyword));
            if (switchKeyword.Kind != SyntaxKind.SwitchKeyword) throw new ArgumentException(nameof(switchKeyword));
            if (openBraceToken == null) throw new ArgumentNullException(nameof(openBraceToken));
            if (openBraceToken.Kind != SyntaxKind.OpenBraceToken) throw new ArgumentException(nameof(openBraceToken));
            if (closeBraceToken == null) throw new ArgumentNullException(nameof(closeBraceToken));
            if (closeBraceToken.Kind != SyntaxKind.CloseBraceToken) throw new ArgumentException(nameof(closeBraceToken));
#endif

            return new SwitchExpressionSyntax(SyntaxKind.SwitchExpression, governingExpression, switchKeyword, openBraceToken, arms.Node, closeBraceToken, this.context);
        }

        public SwitchExpressionArmSyntax SwitchExpressionArm(PatternSyntax pattern, WhenClauseSyntax? whenClause, SyntaxToken equalsGreaterThanToken, ExpressionSyntax expression)
        {
#if DEBUG
            if (pattern == null) throw new ArgumentNullException(nameof(pattern));
            if (equalsGreaterThanToken == null) throw new ArgumentNullException(nameof(equalsGreaterThanToken));
            if (equalsGreaterThanToken.Kind != SyntaxKind.EqualsGreaterThanToken) throw new ArgumentException(nameof(equalsGreaterThanToken));
            if (expression == null) throw new ArgumentNullException(nameof(expression));
#endif

            return new SwitchExpressionArmSyntax(SyntaxKind.SwitchExpressionArm, pattern, whenClause, equalsGreaterThanToken, expression, this.context);
        }

        public TryStatementSyntax TryStatement(Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<AttributeListSyntax> attributeLists, SyntaxToken tryKeyword, BlockSyntax block, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<CatchClauseSyntax> catches, FinallyClauseSyntax? @finally)
        {
#if DEBUG
            if (tryKeyword == null) throw new ArgumentNullException(nameof(tryKeyword));
            if (tryKeyword.Kind != SyntaxKind.TryKeyword) throw new ArgumentException(nameof(tryKeyword));
            if (block == null) throw new ArgumentNullException(nameof(block));
#endif

            return new TryStatementSyntax(SyntaxKind.TryStatement, attributeLists.Node, tryKeyword, block, catches.Node, @finally, this.context);
        }

        public CatchClauseSyntax CatchClause(SyntaxToken catchKeyword, CatchDeclarationSyntax? declaration, CatchFilterClauseSyntax? filter, BlockSyntax block)
        {
#if DEBUG
            if (catchKeyword == null) throw new ArgumentNullException(nameof(catchKeyword));
            if (catchKeyword.Kind != SyntaxKind.CatchKeyword) throw new ArgumentException(nameof(catchKeyword));
            if (block == null) throw new ArgumentNullException(nameof(block));
#endif

            return new CatchClauseSyntax(SyntaxKind.CatchClause, catchKeyword, declaration, filter, block, this.context);
        }

        public CatchDeclarationSyntax CatchDeclaration(SyntaxToken openParenToken, TypeSyntax type, SyntaxToken? identifier, SyntaxToken closeParenToken)
        {
#if DEBUG
            if (openParenToken == null) throw new ArgumentNullException(nameof(openParenToken));
            if (openParenToken.Kind != SyntaxKind.OpenParenToken) throw new ArgumentException(nameof(openParenToken));
            if (type == null) throw new ArgumentNullException(nameof(type));
            if (identifier != null)
            {
                switch (identifier.Kind)
                {
                    case SyntaxKind.IdentifierToken:
                    case SyntaxKind.None: break;
                    default: throw new ArgumentException(nameof(identifier));
                }
            }
            if (closeParenToken == null) throw new ArgumentNullException(nameof(closeParenToken));
            if (closeParenToken.Kind != SyntaxKind.CloseParenToken) throw new ArgumentException(nameof(closeParenToken));
#endif

            return new CatchDeclarationSyntax(SyntaxKind.CatchDeclaration, openParenToken, type, identifier, closeParenToken, this.context);
        }

        public CatchFilterClauseSyntax CatchFilterClause(SyntaxToken whenKeyword, SyntaxToken openParenToken, ExpressionSyntax filterExpression, SyntaxToken closeParenToken)
        {
#if DEBUG
            if (whenKeyword == null) throw new ArgumentNullException(nameof(whenKeyword));
            if (whenKeyword.Kind != SyntaxKind.WhenKeyword) throw new ArgumentException(nameof(whenKeyword));
            if (openParenToken == null) throw new ArgumentNullException(nameof(openParenToken));
            if (openParenToken.Kind != SyntaxKind.OpenParenToken) throw new ArgumentException(nameof(openParenToken));
            if (filterExpression == null) throw new ArgumentNullException(nameof(filterExpression));
            if (closeParenToken == null) throw new ArgumentNullException(nameof(closeParenToken));
            if (closeParenToken.Kind != SyntaxKind.CloseParenToken) throw new ArgumentException(nameof(closeParenToken));
#endif

            return new CatchFilterClauseSyntax(SyntaxKind.CatchFilterClause, whenKeyword, openParenToken, filterExpression, closeParenToken, this.context);
        }

        public FinallyClauseSyntax FinallyClause(SyntaxToken finallyKeyword, BlockSyntax block)
        {
#if DEBUG
            if (finallyKeyword == null) throw new ArgumentNullException(nameof(finallyKeyword));
            if (finallyKeyword.Kind != SyntaxKind.FinallyKeyword) throw new ArgumentException(nameof(finallyKeyword));
            if (block == null) throw new ArgumentNullException(nameof(block));
#endif

            int hash;
            var cached = CSharpSyntaxNodeCache.TryGetNode((int)SyntaxKind.FinallyClause, finallyKeyword, block, this.context, out hash);
            if (cached != null) return (FinallyClauseSyntax)cached;

            var result = new FinallyClauseSyntax(SyntaxKind.FinallyClause, finallyKeyword, block, this.context);
            if (hash >= 0)
            {
                SyntaxNodeCache.AddNode(result, hash);
            }

            return result;
        }

        public CompilationUnitSyntax CompilationUnit(Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<ExternAliasDirectiveSyntax> externs, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<UsingDirectiveSyntax> usings, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<AttributeListSyntax> attributeLists, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<MemberDeclarationSyntax> members, SyntaxToken endOfFileToken)
        {
#if DEBUG
            if (endOfFileToken == null) throw new ArgumentNullException(nameof(endOfFileToken));
            if (endOfFileToken.Kind != SyntaxKind.EndOfFileToken) throw new ArgumentException(nameof(endOfFileToken));
#endif

            return new CompilationUnitSyntax(SyntaxKind.CompilationUnit, externs.Node, usings.Node, attributeLists.Node, members.Node, endOfFileToken, this.context);
        }

        public ExternAliasDirectiveSyntax ExternAliasDirective(SyntaxToken externKeyword, SyntaxToken aliasKeyword, SyntaxToken identifier, SyntaxToken semicolonToken)
        {
#if DEBUG
            if (externKeyword == null) throw new ArgumentNullException(nameof(externKeyword));
            if (externKeyword.Kind != SyntaxKind.ExternKeyword) throw new ArgumentException(nameof(externKeyword));
            if (aliasKeyword == null) throw new ArgumentNullException(nameof(aliasKeyword));
            if (aliasKeyword.Kind != SyntaxKind.AliasKeyword) throw new ArgumentException(nameof(aliasKeyword));
            if (identifier == null) throw new ArgumentNullException(nameof(identifier));
            if (identifier.Kind != SyntaxKind.IdentifierToken) throw new ArgumentException(nameof(identifier));
            if (semicolonToken == null) throw new ArgumentNullException(nameof(semicolonToken));
            if (semicolonToken.Kind != SyntaxKind.SemicolonToken) throw new ArgumentException(nameof(semicolonToken));
#endif

            return new ExternAliasDirectiveSyntax(SyntaxKind.ExternAliasDirective, externKeyword, aliasKeyword, identifier, semicolonToken, this.context);
        }

        public UsingDirectiveSyntax UsingDirective(SyntaxToken usingKeyword, SyntaxToken? staticKeyword, NameEqualsSyntax? alias, NameSyntax name, SyntaxToken semicolonToken)
        {
#if DEBUG
            if (usingKeyword == null) throw new ArgumentNullException(nameof(usingKeyword));
            if (usingKeyword.Kind != SyntaxKind.UsingKeyword) throw new ArgumentException(nameof(usingKeyword));
            if (name == null) throw new ArgumentNullException(nameof(name));
            if (semicolonToken == null) throw new ArgumentNullException(nameof(semicolonToken));
            if (semicolonToken.Kind != SyntaxKind.SemicolonToken) throw new ArgumentException(nameof(semicolonToken));
#endif

            return new UsingDirectiveSyntax(SyntaxKind.UsingDirective, usingKeyword, staticKeyword, alias, name, semicolonToken, this.context);
        }

        public NamespaceDeclarationSyntax NamespaceDeclaration(Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<AttributeListSyntax> attributeLists, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SyntaxToken> modifiers, SyntaxToken namespaceKeyword, NameSyntax name, SyntaxToken openBraceToken, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<ExternAliasDirectiveSyntax> externs, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<UsingDirectiveSyntax> usings, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<MemberDeclarationSyntax> members, SyntaxToken closeBraceToken, SyntaxToken? semicolonToken)
        {
#if DEBUG
            if (namespaceKeyword == null) throw new ArgumentNullException(nameof(namespaceKeyword));
            if (namespaceKeyword.Kind != SyntaxKind.NamespaceKeyword) throw new ArgumentException(nameof(namespaceKeyword));
            if (name == null) throw new ArgumentNullException(nameof(name));
            if (openBraceToken == null) throw new ArgumentNullException(nameof(openBraceToken));
            if (openBraceToken.Kind != SyntaxKind.OpenBraceToken) throw new ArgumentException(nameof(openBraceToken));
            if (closeBraceToken == null) throw new ArgumentNullException(nameof(closeBraceToken));
            if (closeBraceToken.Kind != SyntaxKind.CloseBraceToken) throw new ArgumentException(nameof(closeBraceToken));
            if (semicolonToken != null)
            {
                switch (semicolonToken.Kind)
                {
                    case SyntaxKind.SemicolonToken:
                    case SyntaxKind.None: break;
                    default: throw new ArgumentException(nameof(semicolonToken));
                }
            }
#endif

            return new NamespaceDeclarationSyntax(SyntaxKind.NamespaceDeclaration, attributeLists.Node, modifiers.Node, namespaceKeyword, name, openBraceToken, externs.Node, usings.Node, members.Node, closeBraceToken, semicolonToken, this.context);
        }

        public AttributeListSyntax AttributeList(SyntaxToken openBracketToken, AttributeTargetSpecifierSyntax? target, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<AttributeSyntax> attributes, SyntaxToken closeBracketToken)
        {
#if DEBUG
            if (openBracketToken == null) throw new ArgumentNullException(nameof(openBracketToken));
            if (openBracketToken.Kind != SyntaxKind.OpenBracketToken) throw new ArgumentException(nameof(openBracketToken));
            if (closeBracketToken == null) throw new ArgumentNullException(nameof(closeBracketToken));
            if (closeBracketToken.Kind != SyntaxKind.CloseBracketToken) throw new ArgumentException(nameof(closeBracketToken));
#endif

            return new AttributeListSyntax(SyntaxKind.AttributeList, openBracketToken, target, attributes.Node, closeBracketToken, this.context);
        }

        public AttributeTargetSpecifierSyntax AttributeTargetSpecifier(SyntaxToken identifier, SyntaxToken colonToken)
        {
#if DEBUG
            if (identifier == null) throw new ArgumentNullException(nameof(identifier));
            if (colonToken == null) throw new ArgumentNullException(nameof(colonToken));
            if (colonToken.Kind != SyntaxKind.ColonToken) throw new ArgumentException(nameof(colonToken));
#endif

            int hash;
            var cached = CSharpSyntaxNodeCache.TryGetNode((int)SyntaxKind.AttributeTargetSpecifier, identifier, colonToken, this.context, out hash);
            if (cached != null) return (AttributeTargetSpecifierSyntax)cached;

            var result = new AttributeTargetSpecifierSyntax(SyntaxKind.AttributeTargetSpecifier, identifier, colonToken, this.context);
            if (hash >= 0)
            {
                SyntaxNodeCache.AddNode(result, hash);
            }

            return result;
        }

        public AttributeSyntax Attribute(NameSyntax name, AttributeArgumentListSyntax? argumentList)
        {
#if DEBUG
            if (name == null) throw new ArgumentNullException(nameof(name));
#endif

            int hash;
            var cached = CSharpSyntaxNodeCache.TryGetNode((int)SyntaxKind.Attribute, name, argumentList, this.context, out hash);
            if (cached != null) return (AttributeSyntax)cached;

            var result = new AttributeSyntax(SyntaxKind.Attribute, name, argumentList, this.context);
            if (hash >= 0)
            {
                SyntaxNodeCache.AddNode(result, hash);
            }

            return result;
        }

        public AttributeArgumentListSyntax AttributeArgumentList(SyntaxToken openParenToken, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<AttributeArgumentSyntax> arguments, SyntaxToken closeParenToken)
        {
#if DEBUG
            if (openParenToken == null) throw new ArgumentNullException(nameof(openParenToken));
            if (openParenToken.Kind != SyntaxKind.OpenParenToken) throw new ArgumentException(nameof(openParenToken));
            if (closeParenToken == null) throw new ArgumentNullException(nameof(closeParenToken));
            if (closeParenToken.Kind != SyntaxKind.CloseParenToken) throw new ArgumentException(nameof(closeParenToken));
#endif

            int hash;
            var cached = CSharpSyntaxNodeCache.TryGetNode((int)SyntaxKind.AttributeArgumentList, openParenToken, arguments.Node, closeParenToken, this.context, out hash);
            if (cached != null) return (AttributeArgumentListSyntax)cached;

            var result = new AttributeArgumentListSyntax(SyntaxKind.AttributeArgumentList, openParenToken, arguments.Node, closeParenToken, this.context);
            if (hash >= 0)
            {
                SyntaxNodeCache.AddNode(result, hash);
            }

            return result;
        }

        public AttributeArgumentSyntax AttributeArgument(NameEqualsSyntax? nameEquals, NameColonSyntax? nameColon, ExpressionSyntax expression)
        {
#if DEBUG
            if (expression == null) throw new ArgumentNullException(nameof(expression));
#endif

            int hash;
            var cached = CSharpSyntaxNodeCache.TryGetNode((int)SyntaxKind.AttributeArgument, nameEquals, nameColon, expression, this.context, out hash);
            if (cached != null) return (AttributeArgumentSyntax)cached;

            var result = new AttributeArgumentSyntax(SyntaxKind.AttributeArgument, nameEquals, nameColon, expression, this.context);
            if (hash >= 0)
            {
                SyntaxNodeCache.AddNode(result, hash);
            }

            return result;
        }

        public NameEqualsSyntax NameEquals(IdentifierNameSyntax name, SyntaxToken equalsToken)
        {
#if DEBUG
            if (name == null) throw new ArgumentNullException(nameof(name));
            if (equalsToken == null) throw new ArgumentNullException(nameof(equalsToken));
            if (equalsToken.Kind != SyntaxKind.EqualsToken) throw new ArgumentException(nameof(equalsToken));
#endif

            int hash;
            var cached = CSharpSyntaxNodeCache.TryGetNode((int)SyntaxKind.NameEquals, name, equalsToken, this.context, out hash);
            if (cached != null) return (NameEqualsSyntax)cached;

            var result = new NameEqualsSyntax(SyntaxKind.NameEquals, name, equalsToken, this.context);
            if (hash >= 0)
            {
                SyntaxNodeCache.AddNode(result, hash);
            }

            return result;
        }

        public TypeParameterListSyntax TypeParameterList(SyntaxToken lessThanToken, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<TypeParameterSyntax> parameters, SyntaxToken greaterThanToken)
        {
#if DEBUG
            if (lessThanToken == null) throw new ArgumentNullException(nameof(lessThanToken));
            if (lessThanToken.Kind != SyntaxKind.LessThanToken) throw new ArgumentException(nameof(lessThanToken));
            if (greaterThanToken == null) throw new ArgumentNullException(nameof(greaterThanToken));
            if (greaterThanToken.Kind != SyntaxKind.GreaterThanToken) throw new ArgumentException(nameof(greaterThanToken));
#endif

            int hash;
            var cached = CSharpSyntaxNodeCache.TryGetNode((int)SyntaxKind.TypeParameterList, lessThanToken, parameters.Node, greaterThanToken, this.context, out hash);
            if (cached != null) return (TypeParameterListSyntax)cached;

            var result = new TypeParameterListSyntax(SyntaxKind.TypeParameterList, lessThanToken, parameters.Node, greaterThanToken, this.context);
            if (hash >= 0)
            {
                SyntaxNodeCache.AddNode(result, hash);
            }

            return result;
        }

        public TypeParameterSyntax TypeParameter(Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<AttributeListSyntax> attributeLists, SyntaxToken? varianceKeyword, SyntaxToken identifier)
        {
#if DEBUG
            if (varianceKeyword != null)
            {
                switch (varianceKeyword.Kind)
                {
                    case SyntaxKind.InKeyword:
                    case SyntaxKind.OutKeyword:
                    case SyntaxKind.None: break;
                    default: throw new ArgumentException(nameof(varianceKeyword));
                }
            }
            if (identifier == null) throw new ArgumentNullException(nameof(identifier));
            if (identifier.Kind != SyntaxKind.IdentifierToken) throw new ArgumentException(nameof(identifier));
#endif

            int hash;
            var cached = CSharpSyntaxNodeCache.TryGetNode((int)SyntaxKind.TypeParameter, attributeLists.Node, varianceKeyword, identifier, this.context, out hash);
            if (cached != null) return (TypeParameterSyntax)cached;

            var result = new TypeParameterSyntax(SyntaxKind.TypeParameter, attributeLists.Node, varianceKeyword, identifier, this.context);
            if (hash >= 0)
            {
                SyntaxNodeCache.AddNode(result, hash);
            }

            return result;
        }

        public ClassDeclarationSyntax ClassDeclaration(Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<AttributeListSyntax> attributeLists, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SyntaxToken> modifiers, SyntaxToken keyword, SyntaxToken identifier, TypeParameterListSyntax? typeParameterList, BaseListSyntax? baseList, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<TypeParameterConstraintClauseSyntax> constraintClauses, SyntaxToken openBraceToken, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<MemberDeclarationSyntax> members, SyntaxToken closeBraceToken, SyntaxToken? semicolonToken)
        {
#if DEBUG
            if (keyword == null) throw new ArgumentNullException(nameof(keyword));
            if (keyword.Kind != SyntaxKind.ClassKeyword) throw new ArgumentException(nameof(keyword));
            if (identifier == null) throw new ArgumentNullException(nameof(identifier));
            if (identifier.Kind != SyntaxKind.IdentifierToken) throw new ArgumentException(nameof(identifier));
            if (openBraceToken == null) throw new ArgumentNullException(nameof(openBraceToken));
            if (openBraceToken.Kind != SyntaxKind.OpenBraceToken) throw new ArgumentException(nameof(openBraceToken));
            if (closeBraceToken == null) throw new ArgumentNullException(nameof(closeBraceToken));
            if (closeBraceToken.Kind != SyntaxKind.CloseBraceToken) throw new ArgumentException(nameof(closeBraceToken));
            if (semicolonToken != null)
            {
                switch (semicolonToken.Kind)
                {
                    case SyntaxKind.SemicolonToken:
                    case SyntaxKind.None: break;
                    default: throw new ArgumentException(nameof(semicolonToken));
                }
            }
#endif

            return new ClassDeclarationSyntax(SyntaxKind.ClassDeclaration, attributeLists.Node, modifiers.Node, keyword, identifier, typeParameterList, baseList, constraintClauses.Node, openBraceToken, members.Node, closeBraceToken, semicolonToken, this.context);
        }

        public StructDeclarationSyntax StructDeclaration(Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<AttributeListSyntax> attributeLists, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SyntaxToken> modifiers, SyntaxToken keyword, SyntaxToken identifier, TypeParameterListSyntax? typeParameterList, BaseListSyntax? baseList, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<TypeParameterConstraintClauseSyntax> constraintClauses, SyntaxToken openBraceToken, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<MemberDeclarationSyntax> members, SyntaxToken closeBraceToken, SyntaxToken? semicolonToken)
        {
#if DEBUG
            if (keyword == null) throw new ArgumentNullException(nameof(keyword));
            if (keyword.Kind != SyntaxKind.StructKeyword) throw new ArgumentException(nameof(keyword));
            if (identifier == null) throw new ArgumentNullException(nameof(identifier));
            if (identifier.Kind != SyntaxKind.IdentifierToken) throw new ArgumentException(nameof(identifier));
            if (openBraceToken == null) throw new ArgumentNullException(nameof(openBraceToken));
            if (openBraceToken.Kind != SyntaxKind.OpenBraceToken) throw new ArgumentException(nameof(openBraceToken));
            if (closeBraceToken == null) throw new ArgumentNullException(nameof(closeBraceToken));
            if (closeBraceToken.Kind != SyntaxKind.CloseBraceToken) throw new ArgumentException(nameof(closeBraceToken));
            if (semicolonToken != null)
            {
                switch (semicolonToken.Kind)
                {
                    case SyntaxKind.SemicolonToken:
                    case SyntaxKind.None: break;
                    default: throw new ArgumentException(nameof(semicolonToken));
                }
            }
#endif

            return new StructDeclarationSyntax(SyntaxKind.StructDeclaration, attributeLists.Node, modifiers.Node, keyword, identifier, typeParameterList, baseList, constraintClauses.Node, openBraceToken, members.Node, closeBraceToken, semicolonToken, this.context);
        }

        public InterfaceDeclarationSyntax InterfaceDeclaration(Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<AttributeListSyntax> attributeLists, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SyntaxToken> modifiers, SyntaxToken keyword, SyntaxToken identifier, TypeParameterListSyntax? typeParameterList, BaseListSyntax? baseList, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<TypeParameterConstraintClauseSyntax> constraintClauses, SyntaxToken openBraceToken, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<MemberDeclarationSyntax> members, SyntaxToken closeBraceToken, SyntaxToken? semicolonToken)
        {
#if DEBUG
            if (keyword == null) throw new ArgumentNullException(nameof(keyword));
            if (keyword.Kind != SyntaxKind.InterfaceKeyword) throw new ArgumentException(nameof(keyword));
            if (identifier == null) throw new ArgumentNullException(nameof(identifier));
            if (identifier.Kind != SyntaxKind.IdentifierToken) throw new ArgumentException(nameof(identifier));
            if (openBraceToken == null) throw new ArgumentNullException(nameof(openBraceToken));
            if (openBraceToken.Kind != SyntaxKind.OpenBraceToken) throw new ArgumentException(nameof(openBraceToken));
            if (closeBraceToken == null) throw new ArgumentNullException(nameof(closeBraceToken));
            if (closeBraceToken.Kind != SyntaxKind.CloseBraceToken) throw new ArgumentException(nameof(closeBraceToken));
            if (semicolonToken != null)
            {
                switch (semicolonToken.Kind)
                {
                    case SyntaxKind.SemicolonToken:
                    case SyntaxKind.None: break;
                    default: throw new ArgumentException(nameof(semicolonToken));
                }
            }
#endif

            return new InterfaceDeclarationSyntax(SyntaxKind.InterfaceDeclaration, attributeLists.Node, modifiers.Node, keyword, identifier, typeParameterList, baseList, constraintClauses.Node, openBraceToken, members.Node, closeBraceToken, semicolonToken, this.context);
        }

        public RecordDeclarationSyntax RecordDeclaration(Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<AttributeListSyntax> attributeLists, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SyntaxToken> modifiers, SyntaxToken keyword, SyntaxToken identifier, TypeParameterListSyntax? typeParameterList, ParameterListSyntax? parameterList, BaseListSyntax? baseList, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<TypeParameterConstraintClauseSyntax> constraintClauses, SyntaxToken? openBraceToken, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<MemberDeclarationSyntax> members, SyntaxToken? closeBraceToken, SyntaxToken? semicolonToken)
        {
#if DEBUG
            if (keyword == null) throw new ArgumentNullException(nameof(keyword));
            if (identifier == null) throw new ArgumentNullException(nameof(identifier));
            if (identifier.Kind != SyntaxKind.IdentifierToken) throw new ArgumentException(nameof(identifier));
            if (openBraceToken != null)
            {
                switch (openBraceToken.Kind)
                {
                    case SyntaxKind.OpenBraceToken:
                    case SyntaxKind.None: break;
                    default: throw new ArgumentException(nameof(openBraceToken));
                }
            }
            if (closeBraceToken != null)
            {
                switch (closeBraceToken.Kind)
                {
                    case SyntaxKind.CloseBraceToken:
                    case SyntaxKind.None: break;
                    default: throw new ArgumentException(nameof(closeBraceToken));
                }
            }
            if (semicolonToken != null)
            {
                switch (semicolonToken.Kind)
                {
                    case SyntaxKind.SemicolonToken:
                    case SyntaxKind.None: break;
                    default: throw new ArgumentException(nameof(semicolonToken));
                }
            }
#endif

            return new RecordDeclarationSyntax(SyntaxKind.RecordDeclaration, attributeLists.Node, modifiers.Node, keyword, identifier, typeParameterList, parameterList, baseList, constraintClauses.Node, openBraceToken, members.Node, closeBraceToken, semicolonToken, this.context);
        }

        public EnumDeclarationSyntax EnumDeclaration(Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<AttributeListSyntax> attributeLists, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SyntaxToken> modifiers, SyntaxToken enumKeyword, SyntaxToken identifier, BaseListSyntax? baseList, SyntaxToken openBraceToken, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<EnumMemberDeclarationSyntax> members, SyntaxToken closeBraceToken, SyntaxToken? semicolonToken)
        {
#if DEBUG
            if (enumKeyword == null) throw new ArgumentNullException(nameof(enumKeyword));
            if (enumKeyword.Kind != SyntaxKind.EnumKeyword) throw new ArgumentException(nameof(enumKeyword));
            if (identifier == null) throw new ArgumentNullException(nameof(identifier));
            if (identifier.Kind != SyntaxKind.IdentifierToken) throw new ArgumentException(nameof(identifier));
            if (openBraceToken == null) throw new ArgumentNullException(nameof(openBraceToken));
            if (openBraceToken.Kind != SyntaxKind.OpenBraceToken) throw new ArgumentException(nameof(openBraceToken));
            if (closeBraceToken == null) throw new ArgumentNullException(nameof(closeBraceToken));
            if (closeBraceToken.Kind != SyntaxKind.CloseBraceToken) throw new ArgumentException(nameof(closeBraceToken));
            if (semicolonToken != null)
            {
                switch (semicolonToken.Kind)
                {
                    case SyntaxKind.SemicolonToken:
                    case SyntaxKind.None: break;
                    default: throw new ArgumentException(nameof(semicolonToken));
                }
            }
#endif

            return new EnumDeclarationSyntax(SyntaxKind.EnumDeclaration, attributeLists.Node, modifiers.Node, enumKeyword, identifier, baseList, openBraceToken, members.Node, closeBraceToken, semicolonToken, this.context);
        }

        public DelegateDeclarationSyntax DelegateDeclaration(Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<AttributeListSyntax> attributeLists, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SyntaxToken> modifiers, SyntaxToken delegateKeyword, TypeSyntax returnType, SyntaxToken identifier, TypeParameterListSyntax? typeParameterList, ParameterListSyntax parameterList, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<TypeParameterConstraintClauseSyntax> constraintClauses, SyntaxToken semicolonToken)
        {
#if DEBUG
            if (delegateKeyword == null) throw new ArgumentNullException(nameof(delegateKeyword));
            if (delegateKeyword.Kind != SyntaxKind.DelegateKeyword) throw new ArgumentException(nameof(delegateKeyword));
            if (returnType == null) throw new ArgumentNullException(nameof(returnType));
            if (identifier == null) throw new ArgumentNullException(nameof(identifier));
            if (identifier.Kind != SyntaxKind.IdentifierToken) throw new ArgumentException(nameof(identifier));
            if (parameterList == null) throw new ArgumentNullException(nameof(parameterList));
            if (semicolonToken == null) throw new ArgumentNullException(nameof(semicolonToken));
            if (semicolonToken.Kind != SyntaxKind.SemicolonToken) throw new ArgumentException(nameof(semicolonToken));
#endif

            return new DelegateDeclarationSyntax(SyntaxKind.DelegateDeclaration, attributeLists.Node, modifiers.Node, delegateKeyword, returnType, identifier, typeParameterList, parameterList, constraintClauses.Node, semicolonToken, this.context);
        }

        public EnumMemberDeclarationSyntax EnumMemberDeclaration(Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<AttributeListSyntax> attributeLists, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SyntaxToken> modifiers, SyntaxToken identifier, EqualsValueClauseSyntax? equalsValue)
        {
#if DEBUG
            if (identifier == null) throw new ArgumentNullException(nameof(identifier));
            if (identifier.Kind != SyntaxKind.IdentifierToken) throw new ArgumentException(nameof(identifier));
#endif

            return new EnumMemberDeclarationSyntax(SyntaxKind.EnumMemberDeclaration, attributeLists.Node, modifiers.Node, identifier, equalsValue, this.context);
        }

        public BaseListSyntax BaseList(SyntaxToken colonToken, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<BaseTypeSyntax> types)
        {
#if DEBUG
            if (colonToken == null) throw new ArgumentNullException(nameof(colonToken));
            if (colonToken.Kind != SyntaxKind.ColonToken) throw new ArgumentException(nameof(colonToken));
#endif

            int hash;
            var cached = CSharpSyntaxNodeCache.TryGetNode((int)SyntaxKind.BaseList, colonToken, types.Node, this.context, out hash);
            if (cached != null) return (BaseListSyntax)cached;

            var result = new BaseListSyntax(SyntaxKind.BaseList, colonToken, types.Node, this.context);
            if (hash >= 0)
            {
                SyntaxNodeCache.AddNode(result, hash);
            }

            return result;
        }

        public SimpleBaseTypeSyntax SimpleBaseType(TypeSyntax type)
        {
#if DEBUG
            if (type == null) throw new ArgumentNullException(nameof(type));
#endif

            int hash;
            var cached = CSharpSyntaxNodeCache.TryGetNode((int)SyntaxKind.SimpleBaseType, type, this.context, out hash);
            if (cached != null) return (SimpleBaseTypeSyntax)cached;

            var result = new SimpleBaseTypeSyntax(SyntaxKind.SimpleBaseType, type, this.context);
            if (hash >= 0)
            {
                SyntaxNodeCache.AddNode(result, hash);
            }

            return result;
        }

        public PrimaryConstructorBaseTypeSyntax PrimaryConstructorBaseType(TypeSyntax type, ArgumentListSyntax argumentList)
        {
#if DEBUG
            if (type == null) throw new ArgumentNullException(nameof(type));
            if (argumentList == null) throw new ArgumentNullException(nameof(argumentList));
#endif

            int hash;
            var cached = CSharpSyntaxNodeCache.TryGetNode((int)SyntaxKind.PrimaryConstructorBaseType, type, argumentList, this.context, out hash);
            if (cached != null) return (PrimaryConstructorBaseTypeSyntax)cached;

            var result = new PrimaryConstructorBaseTypeSyntax(SyntaxKind.PrimaryConstructorBaseType, type, argumentList, this.context);
            if (hash >= 0)
            {
                SyntaxNodeCache.AddNode(result, hash);
            }

            return result;
        }

        public TypeParameterConstraintClauseSyntax TypeParameterConstraintClause(SyntaxToken whereKeyword, IdentifierNameSyntax name, SyntaxToken colonToken, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<TypeParameterConstraintSyntax> constraints)
        {
#if DEBUG
            if (whereKeyword == null) throw new ArgumentNullException(nameof(whereKeyword));
            if (whereKeyword.Kind != SyntaxKind.WhereKeyword) throw new ArgumentException(nameof(whereKeyword));
            if (name == null) throw new ArgumentNullException(nameof(name));
            if (colonToken == null) throw new ArgumentNullException(nameof(colonToken));
            if (colonToken.Kind != SyntaxKind.ColonToken) throw new ArgumentException(nameof(colonToken));
#endif

            return new TypeParameterConstraintClauseSyntax(SyntaxKind.TypeParameterConstraintClause, whereKeyword, name, colonToken, constraints.Node, this.context);
        }

        public ConstructorConstraintSyntax ConstructorConstraint(SyntaxToken newKeyword, SyntaxToken openParenToken, SyntaxToken closeParenToken)
        {
#if DEBUG
            if (newKeyword == null) throw new ArgumentNullException(nameof(newKeyword));
            if (newKeyword.Kind != SyntaxKind.NewKeyword) throw new ArgumentException(nameof(newKeyword));
            if (openParenToken == null) throw new ArgumentNullException(nameof(openParenToken));
            if (openParenToken.Kind != SyntaxKind.OpenParenToken) throw new ArgumentException(nameof(openParenToken));
            if (closeParenToken == null) throw new ArgumentNullException(nameof(closeParenToken));
            if (closeParenToken.Kind != SyntaxKind.CloseParenToken) throw new ArgumentException(nameof(closeParenToken));
#endif

            int hash;
            var cached = CSharpSyntaxNodeCache.TryGetNode((int)SyntaxKind.ConstructorConstraint, newKeyword, openParenToken, closeParenToken, this.context, out hash);
            if (cached != null) return (ConstructorConstraintSyntax)cached;

            var result = new ConstructorConstraintSyntax(SyntaxKind.ConstructorConstraint, newKeyword, openParenToken, closeParenToken, this.context);
            if (hash >= 0)
            {
                SyntaxNodeCache.AddNode(result, hash);
            }

            return result;
        }

        public ClassOrStructConstraintSyntax ClassOrStructConstraint(SyntaxKind kind, SyntaxToken classOrStructKeyword, SyntaxToken? questionToken)
        {
            switch (kind)
            {
                case SyntaxKind.ClassConstraint:
                case SyntaxKind.StructConstraint: break;
                default: throw new ArgumentException(nameof(kind));
            }
#if DEBUG
            if (classOrStructKeyword == null) throw new ArgumentNullException(nameof(classOrStructKeyword));
            switch (classOrStructKeyword.Kind)
            {
                case SyntaxKind.ClassKeyword:
                case SyntaxKind.StructKeyword: break;
                default: throw new ArgumentException(nameof(classOrStructKeyword));
            }
            if (questionToken != null)
            {
                switch (questionToken.Kind)
                {
                    case SyntaxKind.QuestionToken:
                    case SyntaxKind.None: break;
                    default: throw new ArgumentException(nameof(questionToken));
                }
            }
#endif

            int hash;
            var cached = CSharpSyntaxNodeCache.TryGetNode((int)kind, classOrStructKeyword, questionToken, this.context, out hash);
            if (cached != null) return (ClassOrStructConstraintSyntax)cached;

            var result = new ClassOrStructConstraintSyntax(kind, classOrStructKeyword, questionToken, this.context);
            if (hash >= 0)
            {
                SyntaxNodeCache.AddNode(result, hash);
            }

            return result;
        }

        public TypeConstraintSyntax TypeConstraint(TypeSyntax type)
        {
#if DEBUG
            if (type == null) throw new ArgumentNullException(nameof(type));
#endif

            int hash;
            var cached = CSharpSyntaxNodeCache.TryGetNode((int)SyntaxKind.TypeConstraint, type, this.context, out hash);
            if (cached != null) return (TypeConstraintSyntax)cached;

            var result = new TypeConstraintSyntax(SyntaxKind.TypeConstraint, type, this.context);
            if (hash >= 0)
            {
                SyntaxNodeCache.AddNode(result, hash);
            }

            return result;
        }

        public DefaultConstraintSyntax DefaultConstraint(SyntaxToken defaultKeyword)
        {
#if DEBUG
            if (defaultKeyword == null) throw new ArgumentNullException(nameof(defaultKeyword));
            if (defaultKeyword.Kind != SyntaxKind.DefaultKeyword) throw new ArgumentException(nameof(defaultKeyword));
#endif

            int hash;
            var cached = CSharpSyntaxNodeCache.TryGetNode((int)SyntaxKind.DefaultConstraint, defaultKeyword, this.context, out hash);
            if (cached != null) return (DefaultConstraintSyntax)cached;

            var result = new DefaultConstraintSyntax(SyntaxKind.DefaultConstraint, defaultKeyword, this.context);
            if (hash >= 0)
            {
                SyntaxNodeCache.AddNode(result, hash);
            }

            return result;
        }

        public FieldDeclarationSyntax FieldDeclaration(Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<AttributeListSyntax> attributeLists, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SyntaxToken> modifiers, VariableDeclarationSyntax declaration, SyntaxToken semicolonToken)
        {
#if DEBUG
            if (declaration == null) throw new ArgumentNullException(nameof(declaration));
            if (semicolonToken == null) throw new ArgumentNullException(nameof(semicolonToken));
            if (semicolonToken.Kind != SyntaxKind.SemicolonToken) throw new ArgumentException(nameof(semicolonToken));
#endif

            return new FieldDeclarationSyntax(SyntaxKind.FieldDeclaration, attributeLists.Node, modifiers.Node, declaration, semicolonToken, this.context);
        }

        public EventFieldDeclarationSyntax EventFieldDeclaration(Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<AttributeListSyntax> attributeLists, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SyntaxToken> modifiers, SyntaxToken eventKeyword, VariableDeclarationSyntax declaration, SyntaxToken semicolonToken)
        {
#if DEBUG
            if (eventKeyword == null) throw new ArgumentNullException(nameof(eventKeyword));
            if (eventKeyword.Kind != SyntaxKind.EventKeyword) throw new ArgumentException(nameof(eventKeyword));
            if (declaration == null) throw new ArgumentNullException(nameof(declaration));
            if (semicolonToken == null) throw new ArgumentNullException(nameof(semicolonToken));
            if (semicolonToken.Kind != SyntaxKind.SemicolonToken) throw new ArgumentException(nameof(semicolonToken));
#endif

            return new EventFieldDeclarationSyntax(SyntaxKind.EventFieldDeclaration, attributeLists.Node, modifiers.Node, eventKeyword, declaration, semicolonToken, this.context);
        }

        public ExplicitInterfaceSpecifierSyntax ExplicitInterfaceSpecifier(NameSyntax name, SyntaxToken dotToken)
        {
#if DEBUG
            if (name == null) throw new ArgumentNullException(nameof(name));
            if (dotToken == null) throw new ArgumentNullException(nameof(dotToken));
            if (dotToken.Kind != SyntaxKind.DotToken) throw new ArgumentException(nameof(dotToken));
#endif

            int hash;
            var cached = CSharpSyntaxNodeCache.TryGetNode((int)SyntaxKind.ExplicitInterfaceSpecifier, name, dotToken, this.context, out hash);
            if (cached != null) return (ExplicitInterfaceSpecifierSyntax)cached;

            var result = new ExplicitInterfaceSpecifierSyntax(SyntaxKind.ExplicitInterfaceSpecifier, name, dotToken, this.context);
            if (hash >= 0)
            {
                SyntaxNodeCache.AddNode(result, hash);
            }

            return result;
        }

        public MethodDeclarationSyntax MethodDeclaration(Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<AttributeListSyntax> attributeLists, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SyntaxToken> modifiers, TypeSyntax returnType, ExplicitInterfaceSpecifierSyntax? explicitInterfaceSpecifier, SyntaxToken identifier, TypeParameterListSyntax? typeParameterList, ParameterListSyntax parameterList, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<TypeParameterConstraintClauseSyntax> constraintClauses, BlockSyntax? body, ArrowExpressionClauseSyntax? expressionBody, SyntaxToken? semicolonToken)
        {
#if DEBUG
            if (returnType == null) throw new ArgumentNullException(nameof(returnType));
            if (identifier == null) throw new ArgumentNullException(nameof(identifier));
            if (identifier.Kind != SyntaxKind.IdentifierToken) throw new ArgumentException(nameof(identifier));
            if (parameterList == null) throw new ArgumentNullException(nameof(parameterList));
            if (semicolonToken != null)
            {
                switch (semicolonToken.Kind)
                {
                    case SyntaxKind.SemicolonToken:
                    case SyntaxKind.None: break;
                    default: throw new ArgumentException(nameof(semicolonToken));
                }
            }
#endif

            return new MethodDeclarationSyntax(SyntaxKind.MethodDeclaration, attributeLists.Node, modifiers.Node, returnType, explicitInterfaceSpecifier, identifier, typeParameterList, parameterList, constraintClauses.Node, body, expressionBody, semicolonToken, this.context);
        }

        public OperatorDeclarationSyntax OperatorDeclaration(Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<AttributeListSyntax> attributeLists, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SyntaxToken> modifiers, TypeSyntax returnType, SyntaxToken operatorKeyword, SyntaxToken operatorToken, ParameterListSyntax parameterList, BlockSyntax? body, ArrowExpressionClauseSyntax? expressionBody, SyntaxToken? semicolonToken)
        {
#if DEBUG
            if (returnType == null) throw new ArgumentNullException(nameof(returnType));
            if (operatorKeyword == null) throw new ArgumentNullException(nameof(operatorKeyword));
            if (operatorKeyword.Kind != SyntaxKind.OperatorKeyword) throw new ArgumentException(nameof(operatorKeyword));
            if (operatorToken == null) throw new ArgumentNullException(nameof(operatorToken));
            switch (operatorToken.Kind)
            {
                case SyntaxKind.PlusToken:
                case SyntaxKind.MinusToken:
                case SyntaxKind.ExclamationToken:
                case SyntaxKind.TildeToken:
                case SyntaxKind.PlusPlusToken:
                case SyntaxKind.MinusMinusToken:
                case SyntaxKind.AsteriskToken:
                case SyntaxKind.SlashToken:
                case SyntaxKind.PercentToken:
                case SyntaxKind.LessThanLessThanToken:
                case SyntaxKind.GreaterThanGreaterThanToken:
                case SyntaxKind.BarToken:
                case SyntaxKind.AmpersandToken:
                case SyntaxKind.CaretToken:
                case SyntaxKind.EqualsEqualsToken:
                case SyntaxKind.ExclamationEqualsToken:
                case SyntaxKind.LessThanToken:
                case SyntaxKind.LessThanEqualsToken:
                case SyntaxKind.GreaterThanToken:
                case SyntaxKind.GreaterThanEqualsToken:
                case SyntaxKind.FalseKeyword:
                case SyntaxKind.TrueKeyword:
                case SyntaxKind.IsKeyword: break;
                default: throw new ArgumentException(nameof(operatorToken));
            }
            if (parameterList == null) throw new ArgumentNullException(nameof(parameterList));
            if (semicolonToken != null)
            {
                switch (semicolonToken.Kind)
                {
                    case SyntaxKind.SemicolonToken:
                    case SyntaxKind.None: break;
                    default: throw new ArgumentException(nameof(semicolonToken));
                }
            }
#endif

            return new OperatorDeclarationSyntax(SyntaxKind.OperatorDeclaration, attributeLists.Node, modifiers.Node, returnType, operatorKeyword, operatorToken, parameterList, body, expressionBody, semicolonToken, this.context);
        }

        public ConversionOperatorDeclarationSyntax ConversionOperatorDeclaration(Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<AttributeListSyntax> attributeLists, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SyntaxToken> modifiers, SyntaxToken implicitOrExplicitKeyword, SyntaxToken operatorKeyword, TypeSyntax type, ParameterListSyntax parameterList, BlockSyntax? body, ArrowExpressionClauseSyntax? expressionBody, SyntaxToken? semicolonToken)
        {
#if DEBUG
            if (implicitOrExplicitKeyword == null) throw new ArgumentNullException(nameof(implicitOrExplicitKeyword));
            switch (implicitOrExplicitKeyword.Kind)
            {
                case SyntaxKind.ImplicitKeyword:
                case SyntaxKind.ExplicitKeyword: break;
                default: throw new ArgumentException(nameof(implicitOrExplicitKeyword));
            }
            if (operatorKeyword == null) throw new ArgumentNullException(nameof(operatorKeyword));
            if (operatorKeyword.Kind != SyntaxKind.OperatorKeyword) throw new ArgumentException(nameof(operatorKeyword));
            if (type == null) throw new ArgumentNullException(nameof(type));
            if (parameterList == null) throw new ArgumentNullException(nameof(parameterList));
            if (semicolonToken != null)
            {
                switch (semicolonToken.Kind)
                {
                    case SyntaxKind.SemicolonToken:
                    case SyntaxKind.None: break;
                    default: throw new ArgumentException(nameof(semicolonToken));
                }
            }
#endif

            return new ConversionOperatorDeclarationSyntax(SyntaxKind.ConversionOperatorDeclaration, attributeLists.Node, modifiers.Node, implicitOrExplicitKeyword, operatorKeyword, type, parameterList, body, expressionBody, semicolonToken, this.context);
        }

        public ConstructorDeclarationSyntax ConstructorDeclaration(Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<AttributeListSyntax> attributeLists, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SyntaxToken> modifiers, SyntaxToken identifier, ParameterListSyntax parameterList, ConstructorInitializerSyntax? initializer, BlockSyntax? body, ArrowExpressionClauseSyntax? expressionBody, SyntaxToken? semicolonToken)
        {
#if DEBUG
            if (identifier == null) throw new ArgumentNullException(nameof(identifier));
            if (identifier.Kind != SyntaxKind.IdentifierToken) throw new ArgumentException(nameof(identifier));
            if (parameterList == null) throw new ArgumentNullException(nameof(parameterList));
            if (semicolonToken != null)
            {
                switch (semicolonToken.Kind)
                {
                    case SyntaxKind.SemicolonToken:
                    case SyntaxKind.None: break;
                    default: throw new ArgumentException(nameof(semicolonToken));
                }
            }
#endif

            return new ConstructorDeclarationSyntax(SyntaxKind.ConstructorDeclaration, attributeLists.Node, modifiers.Node, identifier, parameterList, initializer, body, expressionBody, semicolonToken, this.context);
        }

        public ConstructorInitializerSyntax ConstructorInitializer(SyntaxKind kind, SyntaxToken colonToken, SyntaxToken thisOrBaseKeyword, ArgumentListSyntax argumentList)
        {
            switch (kind)
            {
                case SyntaxKind.BaseConstructorInitializer:
                case SyntaxKind.ThisConstructorInitializer: break;
                default: throw new ArgumentException(nameof(kind));
            }
#if DEBUG
            if (colonToken == null) throw new ArgumentNullException(nameof(colonToken));
            if (colonToken.Kind != SyntaxKind.ColonToken) throw new ArgumentException(nameof(colonToken));
            if (thisOrBaseKeyword == null) throw new ArgumentNullException(nameof(thisOrBaseKeyword));
            switch (thisOrBaseKeyword.Kind)
            {
                case SyntaxKind.BaseKeyword:
                case SyntaxKind.ThisKeyword: break;
                default: throw new ArgumentException(nameof(thisOrBaseKeyword));
            }
            if (argumentList == null) throw new ArgumentNullException(nameof(argumentList));
#endif

            int hash;
            var cached = CSharpSyntaxNodeCache.TryGetNode((int)kind, colonToken, thisOrBaseKeyword, argumentList, this.context, out hash);
            if (cached != null) return (ConstructorInitializerSyntax)cached;

            var result = new ConstructorInitializerSyntax(kind, colonToken, thisOrBaseKeyword, argumentList, this.context);
            if (hash >= 0)
            {
                SyntaxNodeCache.AddNode(result, hash);
            }

            return result;
        }

        public DestructorDeclarationSyntax DestructorDeclaration(Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<AttributeListSyntax> attributeLists, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SyntaxToken> modifiers, SyntaxToken tildeToken, SyntaxToken identifier, ParameterListSyntax parameterList, BlockSyntax? body, ArrowExpressionClauseSyntax? expressionBody, SyntaxToken? semicolonToken)
        {
#if DEBUG
            if (tildeToken == null) throw new ArgumentNullException(nameof(tildeToken));
            if (tildeToken.Kind != SyntaxKind.TildeToken) throw new ArgumentException(nameof(tildeToken));
            if (identifier == null) throw new ArgumentNullException(nameof(identifier));
            if (identifier.Kind != SyntaxKind.IdentifierToken) throw new ArgumentException(nameof(identifier));
            if (parameterList == null) throw new ArgumentNullException(nameof(parameterList));
            if (semicolonToken != null)
            {
                switch (semicolonToken.Kind)
                {
                    case SyntaxKind.SemicolonToken:
                    case SyntaxKind.None: break;
                    default: throw new ArgumentException(nameof(semicolonToken));
                }
            }
#endif

            return new DestructorDeclarationSyntax(SyntaxKind.DestructorDeclaration, attributeLists.Node, modifiers.Node, tildeToken, identifier, parameterList, body, expressionBody, semicolonToken, this.context);
        }

        public PropertyDeclarationSyntax PropertyDeclaration(Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<AttributeListSyntax> attributeLists, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SyntaxToken> modifiers, TypeSyntax type, ExplicitInterfaceSpecifierSyntax? explicitInterfaceSpecifier, SyntaxToken identifier, AccessorListSyntax? accessorList, ArrowExpressionClauseSyntax? expressionBody, EqualsValueClauseSyntax? initializer, SyntaxToken? semicolonToken)
        {
#if DEBUG
            if (type == null) throw new ArgumentNullException(nameof(type));
            if (identifier == null) throw new ArgumentNullException(nameof(identifier));
            if (identifier.Kind != SyntaxKind.IdentifierToken) throw new ArgumentException(nameof(identifier));
            if (semicolonToken != null)
            {
                switch (semicolonToken.Kind)
                {
                    case SyntaxKind.SemicolonToken:
                    case SyntaxKind.None: break;
                    default: throw new ArgumentException(nameof(semicolonToken));
                }
            }
#endif

            return new PropertyDeclarationSyntax(SyntaxKind.PropertyDeclaration, attributeLists.Node, modifiers.Node, type, explicitInterfaceSpecifier, identifier, accessorList, expressionBody, initializer, semicolonToken, this.context);
        }

        public ArrowExpressionClauseSyntax ArrowExpressionClause(SyntaxToken arrowToken, ExpressionSyntax expression)
        {
#if DEBUG
            if (arrowToken == null) throw new ArgumentNullException(nameof(arrowToken));
            if (arrowToken.Kind != SyntaxKind.EqualsGreaterThanToken) throw new ArgumentException(nameof(arrowToken));
            if (expression == null) throw new ArgumentNullException(nameof(expression));
#endif

            int hash;
            var cached = CSharpSyntaxNodeCache.TryGetNode((int)SyntaxKind.ArrowExpressionClause, arrowToken, expression, this.context, out hash);
            if (cached != null) return (ArrowExpressionClauseSyntax)cached;

            var result = new ArrowExpressionClauseSyntax(SyntaxKind.ArrowExpressionClause, arrowToken, expression, this.context);
            if (hash >= 0)
            {
                SyntaxNodeCache.AddNode(result, hash);
            }

            return result;
        }

        public EventDeclarationSyntax EventDeclaration(Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<AttributeListSyntax> attributeLists, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SyntaxToken> modifiers, SyntaxToken eventKeyword, TypeSyntax type, ExplicitInterfaceSpecifierSyntax? explicitInterfaceSpecifier, SyntaxToken identifier, AccessorListSyntax? accessorList, SyntaxToken? semicolonToken)
        {
#if DEBUG
            if (eventKeyword == null) throw new ArgumentNullException(nameof(eventKeyword));
            if (eventKeyword.Kind != SyntaxKind.EventKeyword) throw new ArgumentException(nameof(eventKeyword));
            if (type == null) throw new ArgumentNullException(nameof(type));
            if (identifier == null) throw new ArgumentNullException(nameof(identifier));
            if (identifier.Kind != SyntaxKind.IdentifierToken) throw new ArgumentException(nameof(identifier));
            if (semicolonToken != null)
            {
                switch (semicolonToken.Kind)
                {
                    case SyntaxKind.SemicolonToken:
                    case SyntaxKind.None: break;
                    default: throw new ArgumentException(nameof(semicolonToken));
                }
            }
#endif

            return new EventDeclarationSyntax(SyntaxKind.EventDeclaration, attributeLists.Node, modifiers.Node, eventKeyword, type, explicitInterfaceSpecifier, identifier, accessorList, semicolonToken, this.context);
        }

        public IndexerDeclarationSyntax IndexerDeclaration(Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<AttributeListSyntax> attributeLists, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SyntaxToken> modifiers, TypeSyntax type, ExplicitInterfaceSpecifierSyntax? explicitInterfaceSpecifier, SyntaxToken thisKeyword, BracketedParameterListSyntax parameterList, AccessorListSyntax? accessorList, ArrowExpressionClauseSyntax? expressionBody, SyntaxToken? semicolonToken)
        {
#if DEBUG
            if (type == null) throw new ArgumentNullException(nameof(type));
            if (thisKeyword == null) throw new ArgumentNullException(nameof(thisKeyword));
            if (thisKeyword.Kind != SyntaxKind.ThisKeyword) throw new ArgumentException(nameof(thisKeyword));
            if (parameterList == null) throw new ArgumentNullException(nameof(parameterList));
            if (semicolonToken != null)
            {
                switch (semicolonToken.Kind)
                {
                    case SyntaxKind.SemicolonToken:
                    case SyntaxKind.None: break;
                    default: throw new ArgumentException(nameof(semicolonToken));
                }
            }
#endif

            return new IndexerDeclarationSyntax(SyntaxKind.IndexerDeclaration, attributeLists.Node, modifiers.Node, type, explicitInterfaceSpecifier, thisKeyword, parameterList, accessorList, expressionBody, semicolonToken, this.context);
        }

        public AccessorListSyntax AccessorList(SyntaxToken openBraceToken, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<AccessorDeclarationSyntax> accessors, SyntaxToken closeBraceToken)
        {
#if DEBUG
            if (openBraceToken == null) throw new ArgumentNullException(nameof(openBraceToken));
            if (openBraceToken.Kind != SyntaxKind.OpenBraceToken) throw new ArgumentException(nameof(openBraceToken));
            if (closeBraceToken == null) throw new ArgumentNullException(nameof(closeBraceToken));
            if (closeBraceToken.Kind != SyntaxKind.CloseBraceToken) throw new ArgumentException(nameof(closeBraceToken));
#endif

            int hash;
            var cached = CSharpSyntaxNodeCache.TryGetNode((int)SyntaxKind.AccessorList, openBraceToken, accessors.Node, closeBraceToken, this.context, out hash);
            if (cached != null) return (AccessorListSyntax)cached;

            var result = new AccessorListSyntax(SyntaxKind.AccessorList, openBraceToken, accessors.Node, closeBraceToken, this.context);
            if (hash >= 0)
            {
                SyntaxNodeCache.AddNode(result, hash);
            }

            return result;
        }

        public AccessorDeclarationSyntax AccessorDeclaration(SyntaxKind kind, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<AttributeListSyntax> attributeLists, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SyntaxToken> modifiers, SyntaxToken keyword, BlockSyntax? body, ArrowExpressionClauseSyntax? expressionBody, SyntaxToken? semicolonToken)
        {
            switch (kind)
            {
                case SyntaxKind.GetAccessorDeclaration:
                case SyntaxKind.SetAccessorDeclaration:
                case SyntaxKind.InitAccessorDeclaration:
                case SyntaxKind.AddAccessorDeclaration:
                case SyntaxKind.RemoveAccessorDeclaration:
                case SyntaxKind.UnknownAccessorDeclaration: break;
                default: throw new ArgumentException(nameof(kind));
            }
#if DEBUG
            if (keyword == null) throw new ArgumentNullException(nameof(keyword));
            switch (keyword.Kind)
            {
                case SyntaxKind.GetKeyword:
                case SyntaxKind.SetKeyword:
                case SyntaxKind.InitKeyword:
                case SyntaxKind.AddKeyword:
                case SyntaxKind.RemoveKeyword:
                case SyntaxKind.IdentifierToken: break;
                default: throw new ArgumentException(nameof(keyword));
            }
            if (semicolonToken != null)
            {
                switch (semicolonToken.Kind)
                {
                    case SyntaxKind.SemicolonToken:
                    case SyntaxKind.None: break;
                    default: throw new ArgumentException(nameof(semicolonToken));
                }
            }
#endif

            return new AccessorDeclarationSyntax(kind, attributeLists.Node, modifiers.Node, keyword, body, expressionBody, semicolonToken, this.context);
        }

        public ParameterListSyntax ParameterList(SyntaxToken openParenToken, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<ParameterSyntax> parameters, SyntaxToken closeParenToken)
        {
#if DEBUG
            if (openParenToken == null) throw new ArgumentNullException(nameof(openParenToken));
            if (openParenToken.Kind != SyntaxKind.OpenParenToken) throw new ArgumentException(nameof(openParenToken));
            if (closeParenToken == null) throw new ArgumentNullException(nameof(closeParenToken));
            if (closeParenToken.Kind != SyntaxKind.CloseParenToken) throw new ArgumentException(nameof(closeParenToken));
#endif

            int hash;
            var cached = CSharpSyntaxNodeCache.TryGetNode((int)SyntaxKind.ParameterList, openParenToken, parameters.Node, closeParenToken, this.context, out hash);
            if (cached != null) return (ParameterListSyntax)cached;

            var result = new ParameterListSyntax(SyntaxKind.ParameterList, openParenToken, parameters.Node, closeParenToken, this.context);
            if (hash >= 0)
            {
                SyntaxNodeCache.AddNode(result, hash);
            }

            return result;
        }

        public BracketedParameterListSyntax BracketedParameterList(SyntaxToken openBracketToken, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<ParameterSyntax> parameters, SyntaxToken closeBracketToken)
        {
#if DEBUG
            if (openBracketToken == null) throw new ArgumentNullException(nameof(openBracketToken));
            if (openBracketToken.Kind != SyntaxKind.OpenBracketToken) throw new ArgumentException(nameof(openBracketToken));
            if (closeBracketToken == null) throw new ArgumentNullException(nameof(closeBracketToken));
            if (closeBracketToken.Kind != SyntaxKind.CloseBracketToken) throw new ArgumentException(nameof(closeBracketToken));
#endif

            int hash;
            var cached = CSharpSyntaxNodeCache.TryGetNode((int)SyntaxKind.BracketedParameterList, openBracketToken, parameters.Node, closeBracketToken, this.context, out hash);
            if (cached != null) return (BracketedParameterListSyntax)cached;

            var result = new BracketedParameterListSyntax(SyntaxKind.BracketedParameterList, openBracketToken, parameters.Node, closeBracketToken, this.context);
            if (hash >= 0)
            {
                SyntaxNodeCache.AddNode(result, hash);
            }

            return result;
        }

        public ParameterSyntax Parameter(Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<AttributeListSyntax> attributeLists, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SyntaxToken> modifiers, TypeSyntax? type, SyntaxToken identifier, EqualsValueClauseSyntax? @default)
        {
#if DEBUG
            if (identifier == null) throw new ArgumentNullException(nameof(identifier));
            switch (identifier.Kind)
            {
                case SyntaxKind.IdentifierToken:
                case SyntaxKind.ArgListKeyword: break;
                default: throw new ArgumentException(nameof(identifier));
            }
#endif

            return new ParameterSyntax(SyntaxKind.Parameter, attributeLists.Node, modifiers.Node, type, identifier, @default, this.context);
        }

        public FunctionPointerParameterSyntax FunctionPointerParameter(Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<AttributeListSyntax> attributeLists, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SyntaxToken> modifiers, TypeSyntax type)
        {
#if DEBUG
            if (type == null) throw new ArgumentNullException(nameof(type));
#endif

            int hash;
            var cached = CSharpSyntaxNodeCache.TryGetNode((int)SyntaxKind.FunctionPointerParameter, attributeLists.Node, modifiers.Node, type, this.context, out hash);
            if (cached != null) return (FunctionPointerParameterSyntax)cached;

            var result = new FunctionPointerParameterSyntax(SyntaxKind.FunctionPointerParameter, attributeLists.Node, modifiers.Node, type, this.context);
            if (hash >= 0)
            {
                SyntaxNodeCache.AddNode(result, hash);
            }

            return result;
        }

        public IncompleteMemberSyntax IncompleteMember(Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<AttributeListSyntax> attributeLists, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SyntaxToken> modifiers, TypeSyntax? type)
        {
#if DEBUG
#endif

            return new IncompleteMemberSyntax(SyntaxKind.IncompleteMember, attributeLists.Node, modifiers.Node, type, this.context);
        }

        public SkippedTokensTriviaSyntax SkippedTokensTrivia(Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SyntaxToken> tokens)
        {
#if DEBUG
#endif

            return new SkippedTokensTriviaSyntax(SyntaxKind.SkippedTokensTrivia, tokens.Node, this.context);
        }

        public DocumentationCommentTriviaSyntax DocumentationCommentTrivia(SyntaxKind kind, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<XmlNodeSyntax> content, SyntaxToken endOfComment)
        {
            switch (kind)
            {
                case SyntaxKind.SingleLineDocumentationCommentTrivia:
                case SyntaxKind.MultiLineDocumentationCommentTrivia: break;
                default: throw new ArgumentException(nameof(kind));
            }
#if DEBUG
            if (endOfComment == null) throw new ArgumentNullException(nameof(endOfComment));
            if (endOfComment.Kind != SyntaxKind.EndOfDocumentationCommentToken) throw new ArgumentException(nameof(endOfComment));
#endif

            return new DocumentationCommentTriviaSyntax(kind, content.Node, endOfComment, this.context);
        }

        public TypeCrefSyntax TypeCref(TypeSyntax type)
        {
#if DEBUG
            if (type == null) throw new ArgumentNullException(nameof(type));
#endif

            int hash;
            var cached = CSharpSyntaxNodeCache.TryGetNode((int)SyntaxKind.TypeCref, type, this.context, out hash);
            if (cached != null) return (TypeCrefSyntax)cached;

            var result = new TypeCrefSyntax(SyntaxKind.TypeCref, type, this.context);
            if (hash >= 0)
            {
                SyntaxNodeCache.AddNode(result, hash);
            }

            return result;
        }

        public QualifiedCrefSyntax QualifiedCref(TypeSyntax container, SyntaxToken dotToken, MemberCrefSyntax member)
        {
#if DEBUG
            if (container == null) throw new ArgumentNullException(nameof(container));
            if (dotToken == null) throw new ArgumentNullException(nameof(dotToken));
            if (dotToken.Kind != SyntaxKind.DotToken) throw new ArgumentException(nameof(dotToken));
            if (member == null) throw new ArgumentNullException(nameof(member));
#endif

            int hash;
            var cached = CSharpSyntaxNodeCache.TryGetNode((int)SyntaxKind.QualifiedCref, container, dotToken, member, this.context, out hash);
            if (cached != null) return (QualifiedCrefSyntax)cached;

            var result = new QualifiedCrefSyntax(SyntaxKind.QualifiedCref, container, dotToken, member, this.context);
            if (hash >= 0)
            {
                SyntaxNodeCache.AddNode(result, hash);
            }

            return result;
        }

        public NameMemberCrefSyntax NameMemberCref(TypeSyntax name, CrefParameterListSyntax? parameters)
        {
#if DEBUG
            if (name == null) throw new ArgumentNullException(nameof(name));
#endif

            int hash;
            var cached = CSharpSyntaxNodeCache.TryGetNode((int)SyntaxKind.NameMemberCref, name, parameters, this.context, out hash);
            if (cached != null) return (NameMemberCrefSyntax)cached;

            var result = new NameMemberCrefSyntax(SyntaxKind.NameMemberCref, name, parameters, this.context);
            if (hash >= 0)
            {
                SyntaxNodeCache.AddNode(result, hash);
            }

            return result;
        }

        public IndexerMemberCrefSyntax IndexerMemberCref(SyntaxToken thisKeyword, CrefBracketedParameterListSyntax? parameters)
        {
#if DEBUG
            if (thisKeyword == null) throw new ArgumentNullException(nameof(thisKeyword));
            if (thisKeyword.Kind != SyntaxKind.ThisKeyword) throw new ArgumentException(nameof(thisKeyword));
#endif

            int hash;
            var cached = CSharpSyntaxNodeCache.TryGetNode((int)SyntaxKind.IndexerMemberCref, thisKeyword, parameters, this.context, out hash);
            if (cached != null) return (IndexerMemberCrefSyntax)cached;

            var result = new IndexerMemberCrefSyntax(SyntaxKind.IndexerMemberCref, thisKeyword, parameters, this.context);
            if (hash >= 0)
            {
                SyntaxNodeCache.AddNode(result, hash);
            }

            return result;
        }

        public OperatorMemberCrefSyntax OperatorMemberCref(SyntaxToken operatorKeyword, SyntaxToken operatorToken, CrefParameterListSyntax? parameters)
        {
#if DEBUG
            if (operatorKeyword == null) throw new ArgumentNullException(nameof(operatorKeyword));
            if (operatorKeyword.Kind != SyntaxKind.OperatorKeyword) throw new ArgumentException(nameof(operatorKeyword));
            if (operatorToken == null) throw new ArgumentNullException(nameof(operatorToken));
            switch (operatorToken.Kind)
            {
                case SyntaxKind.PlusToken:
                case SyntaxKind.MinusToken:
                case SyntaxKind.ExclamationToken:
                case SyntaxKind.TildeToken:
                case SyntaxKind.PlusPlusToken:
                case SyntaxKind.MinusMinusToken:
                case SyntaxKind.AsteriskToken:
                case SyntaxKind.SlashToken:
                case SyntaxKind.PercentToken:
                case SyntaxKind.LessThanLessThanToken:
                case SyntaxKind.GreaterThanGreaterThanToken:
                case SyntaxKind.BarToken:
                case SyntaxKind.AmpersandToken:
                case SyntaxKind.CaretToken:
                case SyntaxKind.EqualsEqualsToken:
                case SyntaxKind.ExclamationEqualsToken:
                case SyntaxKind.LessThanToken:
                case SyntaxKind.LessThanEqualsToken:
                case SyntaxKind.GreaterThanToken:
                case SyntaxKind.GreaterThanEqualsToken:
                case SyntaxKind.FalseKeyword:
                case SyntaxKind.TrueKeyword: break;
                default: throw new ArgumentException(nameof(operatorToken));
            }
#endif

            int hash;
            var cached = CSharpSyntaxNodeCache.TryGetNode((int)SyntaxKind.OperatorMemberCref, operatorKeyword, operatorToken, parameters, this.context, out hash);
            if (cached != null) return (OperatorMemberCrefSyntax)cached;

            var result = new OperatorMemberCrefSyntax(SyntaxKind.OperatorMemberCref, operatorKeyword, operatorToken, parameters, this.context);
            if (hash >= 0)
            {
                SyntaxNodeCache.AddNode(result, hash);
            }

            return result;
        }

        public ConversionOperatorMemberCrefSyntax ConversionOperatorMemberCref(SyntaxToken implicitOrExplicitKeyword, SyntaxToken operatorKeyword, TypeSyntax type, CrefParameterListSyntax? parameters)
        {
#if DEBUG
            if (implicitOrExplicitKeyword == null) throw new ArgumentNullException(nameof(implicitOrExplicitKeyword));
            switch (implicitOrExplicitKeyword.Kind)
            {
                case SyntaxKind.ImplicitKeyword:
                case SyntaxKind.ExplicitKeyword: break;
                default: throw new ArgumentException(nameof(implicitOrExplicitKeyword));
            }
            if (operatorKeyword == null) throw new ArgumentNullException(nameof(operatorKeyword));
            if (operatorKeyword.Kind != SyntaxKind.OperatorKeyword) throw new ArgumentException(nameof(operatorKeyword));
            if (type == null) throw new ArgumentNullException(nameof(type));
#endif

            return new ConversionOperatorMemberCrefSyntax(SyntaxKind.ConversionOperatorMemberCref, implicitOrExplicitKeyword, operatorKeyword, type, parameters, this.context);
        }

        public CrefParameterListSyntax CrefParameterList(SyntaxToken openParenToken, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<CrefParameterSyntax> parameters, SyntaxToken closeParenToken)
        {
#if DEBUG
            if (openParenToken == null) throw new ArgumentNullException(nameof(openParenToken));
            if (openParenToken.Kind != SyntaxKind.OpenParenToken) throw new ArgumentException(nameof(openParenToken));
            if (closeParenToken == null) throw new ArgumentNullException(nameof(closeParenToken));
            if (closeParenToken.Kind != SyntaxKind.CloseParenToken) throw new ArgumentException(nameof(closeParenToken));
#endif

            int hash;
            var cached = CSharpSyntaxNodeCache.TryGetNode((int)SyntaxKind.CrefParameterList, openParenToken, parameters.Node, closeParenToken, this.context, out hash);
            if (cached != null) return (CrefParameterListSyntax)cached;

            var result = new CrefParameterListSyntax(SyntaxKind.CrefParameterList, openParenToken, parameters.Node, closeParenToken, this.context);
            if (hash >= 0)
            {
                SyntaxNodeCache.AddNode(result, hash);
            }

            return result;
        }

        public CrefBracketedParameterListSyntax CrefBracketedParameterList(SyntaxToken openBracketToken, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<CrefParameterSyntax> parameters, SyntaxToken closeBracketToken)
        {
#if DEBUG
            if (openBracketToken == null) throw new ArgumentNullException(nameof(openBracketToken));
            if (openBracketToken.Kind != SyntaxKind.OpenBracketToken) throw new ArgumentException(nameof(openBracketToken));
            if (closeBracketToken == null) throw new ArgumentNullException(nameof(closeBracketToken));
            if (closeBracketToken.Kind != SyntaxKind.CloseBracketToken) throw new ArgumentException(nameof(closeBracketToken));
#endif

            int hash;
            var cached = CSharpSyntaxNodeCache.TryGetNode((int)SyntaxKind.CrefBracketedParameterList, openBracketToken, parameters.Node, closeBracketToken, this.context, out hash);
            if (cached != null) return (CrefBracketedParameterListSyntax)cached;

            var result = new CrefBracketedParameterListSyntax(SyntaxKind.CrefBracketedParameterList, openBracketToken, parameters.Node, closeBracketToken, this.context);
            if (hash >= 0)
            {
                SyntaxNodeCache.AddNode(result, hash);
            }

            return result;
        }

        public CrefParameterSyntax CrefParameter(SyntaxToken? refKindKeyword, TypeSyntax type)
        {
#if DEBUG
            if (refKindKeyword != null)
            {
                switch (refKindKeyword.Kind)
                {
                    case SyntaxKind.RefKeyword:
                    case SyntaxKind.OutKeyword:
                    case SyntaxKind.InKeyword:
                    case SyntaxKind.None: break;
                    default: throw new ArgumentException(nameof(refKindKeyword));
                }
            }
            if (type == null) throw new ArgumentNullException(nameof(type));
#endif

            int hash;
            var cached = CSharpSyntaxNodeCache.TryGetNode((int)SyntaxKind.CrefParameter, refKindKeyword, type, this.context, out hash);
            if (cached != null) return (CrefParameterSyntax)cached;

            var result = new CrefParameterSyntax(SyntaxKind.CrefParameter, refKindKeyword, type, this.context);
            if (hash >= 0)
            {
                SyntaxNodeCache.AddNode(result, hash);
            }

            return result;
        }

        public XmlElementSyntax XmlElement(XmlElementStartTagSyntax startTag, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<XmlNodeSyntax> content, XmlElementEndTagSyntax endTag)
        {
#if DEBUG
            if (startTag == null) throw new ArgumentNullException(nameof(startTag));
            if (endTag == null) throw new ArgumentNullException(nameof(endTag));
#endif

            int hash;
            var cached = CSharpSyntaxNodeCache.TryGetNode((int)SyntaxKind.XmlElement, startTag, content.Node, endTag, this.context, out hash);
            if (cached != null) return (XmlElementSyntax)cached;

            var result = new XmlElementSyntax(SyntaxKind.XmlElement, startTag, content.Node, endTag, this.context);
            if (hash >= 0)
            {
                SyntaxNodeCache.AddNode(result, hash);
            }

            return result;
        }

        public XmlElementStartTagSyntax XmlElementStartTag(SyntaxToken lessThanToken, XmlNameSyntax name, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<XmlAttributeSyntax> attributes, SyntaxToken greaterThanToken)
        {
#if DEBUG
            if (lessThanToken == null) throw new ArgumentNullException(nameof(lessThanToken));
            if (lessThanToken.Kind != SyntaxKind.LessThanToken) throw new ArgumentException(nameof(lessThanToken));
            if (name == null) throw new ArgumentNullException(nameof(name));
            if (greaterThanToken == null) throw new ArgumentNullException(nameof(greaterThanToken));
            if (greaterThanToken.Kind != SyntaxKind.GreaterThanToken) throw new ArgumentException(nameof(greaterThanToken));
#endif

            return new XmlElementStartTagSyntax(SyntaxKind.XmlElementStartTag, lessThanToken, name, attributes.Node, greaterThanToken, this.context);
        }

        public XmlElementEndTagSyntax XmlElementEndTag(SyntaxToken lessThanSlashToken, XmlNameSyntax name, SyntaxToken greaterThanToken)
        {
#if DEBUG
            if (lessThanSlashToken == null) throw new ArgumentNullException(nameof(lessThanSlashToken));
            if (lessThanSlashToken.Kind != SyntaxKind.LessThanSlashToken) throw new ArgumentException(nameof(lessThanSlashToken));
            if (name == null) throw new ArgumentNullException(nameof(name));
            if (greaterThanToken == null) throw new ArgumentNullException(nameof(greaterThanToken));
            if (greaterThanToken.Kind != SyntaxKind.GreaterThanToken) throw new ArgumentException(nameof(greaterThanToken));
#endif

            int hash;
            var cached = CSharpSyntaxNodeCache.TryGetNode((int)SyntaxKind.XmlElementEndTag, lessThanSlashToken, name, greaterThanToken, this.context, out hash);
            if (cached != null) return (XmlElementEndTagSyntax)cached;

            var result = new XmlElementEndTagSyntax(SyntaxKind.XmlElementEndTag, lessThanSlashToken, name, greaterThanToken, this.context);
            if (hash >= 0)
            {
                SyntaxNodeCache.AddNode(result, hash);
            }

            return result;
        }

        public XmlEmptyElementSyntax XmlEmptyElement(SyntaxToken lessThanToken, XmlNameSyntax name, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<XmlAttributeSyntax> attributes, SyntaxToken slashGreaterThanToken)
        {
#if DEBUG
            if (lessThanToken == null) throw new ArgumentNullException(nameof(lessThanToken));
            if (lessThanToken.Kind != SyntaxKind.LessThanToken) throw new ArgumentException(nameof(lessThanToken));
            if (name == null) throw new ArgumentNullException(nameof(name));
            if (slashGreaterThanToken == null) throw new ArgumentNullException(nameof(slashGreaterThanToken));
            if (slashGreaterThanToken.Kind != SyntaxKind.SlashGreaterThanToken) throw new ArgumentException(nameof(slashGreaterThanToken));
#endif

            return new XmlEmptyElementSyntax(SyntaxKind.XmlEmptyElement, lessThanToken, name, attributes.Node, slashGreaterThanToken, this.context);
        }

        public XmlNameSyntax XmlName(XmlPrefixSyntax? prefix, SyntaxToken localName)
        {
#if DEBUG
            if (localName == null) throw new ArgumentNullException(nameof(localName));
            if (localName.Kind != SyntaxKind.IdentifierToken) throw new ArgumentException(nameof(localName));
#endif

            int hash;
            var cached = CSharpSyntaxNodeCache.TryGetNode((int)SyntaxKind.XmlName, prefix, localName, this.context, out hash);
            if (cached != null) return (XmlNameSyntax)cached;

            var result = new XmlNameSyntax(SyntaxKind.XmlName, prefix, localName, this.context);
            if (hash >= 0)
            {
                SyntaxNodeCache.AddNode(result, hash);
            }

            return result;
        }

        public XmlPrefixSyntax XmlPrefix(SyntaxToken prefix, SyntaxToken colonToken)
        {
#if DEBUG
            if (prefix == null) throw new ArgumentNullException(nameof(prefix));
            if (prefix.Kind != SyntaxKind.IdentifierToken) throw new ArgumentException(nameof(prefix));
            if (colonToken == null) throw new ArgumentNullException(nameof(colonToken));
            if (colonToken.Kind != SyntaxKind.ColonToken) throw new ArgumentException(nameof(colonToken));
#endif

            int hash;
            var cached = CSharpSyntaxNodeCache.TryGetNode((int)SyntaxKind.XmlPrefix, prefix, colonToken, this.context, out hash);
            if (cached != null) return (XmlPrefixSyntax)cached;

            var result = new XmlPrefixSyntax(SyntaxKind.XmlPrefix, prefix, colonToken, this.context);
            if (hash >= 0)
            {
                SyntaxNodeCache.AddNode(result, hash);
            }

            return result;
        }

        public XmlTextAttributeSyntax XmlTextAttribute(XmlNameSyntax name, SyntaxToken equalsToken, SyntaxToken startQuoteToken, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SyntaxToken> textTokens, SyntaxToken endQuoteToken)
        {
#if DEBUG
            if (name == null) throw new ArgumentNullException(nameof(name));
            if (equalsToken == null) throw new ArgumentNullException(nameof(equalsToken));
            if (equalsToken.Kind != SyntaxKind.EqualsToken) throw new ArgumentException(nameof(equalsToken));
            if (startQuoteToken == null) throw new ArgumentNullException(nameof(startQuoteToken));
            switch (startQuoteToken.Kind)
            {
                case SyntaxKind.SingleQuoteToken:
                case SyntaxKind.DoubleQuoteToken: break;
                default: throw new ArgumentException(nameof(startQuoteToken));
            }
            if (endQuoteToken == null) throw new ArgumentNullException(nameof(endQuoteToken));
            switch (endQuoteToken.Kind)
            {
                case SyntaxKind.SingleQuoteToken:
                case SyntaxKind.DoubleQuoteToken: break;
                default: throw new ArgumentException(nameof(endQuoteToken));
            }
#endif

            return new XmlTextAttributeSyntax(SyntaxKind.XmlTextAttribute, name, equalsToken, startQuoteToken, textTokens.Node, endQuoteToken, this.context);
        }

        public XmlCrefAttributeSyntax XmlCrefAttribute(XmlNameSyntax name, SyntaxToken equalsToken, SyntaxToken startQuoteToken, CrefSyntax cref, SyntaxToken endQuoteToken)
        {
#if DEBUG
            if (name == null) throw new ArgumentNullException(nameof(name));
            if (equalsToken == null) throw new ArgumentNullException(nameof(equalsToken));
            if (equalsToken.Kind != SyntaxKind.EqualsToken) throw new ArgumentException(nameof(equalsToken));
            if (startQuoteToken == null) throw new ArgumentNullException(nameof(startQuoteToken));
            switch (startQuoteToken.Kind)
            {
                case SyntaxKind.SingleQuoteToken:
                case SyntaxKind.DoubleQuoteToken: break;
                default: throw new ArgumentException(nameof(startQuoteToken));
            }
            if (cref == null) throw new ArgumentNullException(nameof(cref));
            if (endQuoteToken == null) throw new ArgumentNullException(nameof(endQuoteToken));
            switch (endQuoteToken.Kind)
            {
                case SyntaxKind.SingleQuoteToken:
                case SyntaxKind.DoubleQuoteToken: break;
                default: throw new ArgumentException(nameof(endQuoteToken));
            }
#endif

            return new XmlCrefAttributeSyntax(SyntaxKind.XmlCrefAttribute, name, equalsToken, startQuoteToken, cref, endQuoteToken, this.context);
        }

        public XmlNameAttributeSyntax XmlNameAttribute(XmlNameSyntax name, SyntaxToken equalsToken, SyntaxToken startQuoteToken, IdentifierNameSyntax identifier, SyntaxToken endQuoteToken)
        {
#if DEBUG
            if (name == null) throw new ArgumentNullException(nameof(name));
            if (equalsToken == null) throw new ArgumentNullException(nameof(equalsToken));
            if (equalsToken.Kind != SyntaxKind.EqualsToken) throw new ArgumentException(nameof(equalsToken));
            if (startQuoteToken == null) throw new ArgumentNullException(nameof(startQuoteToken));
            switch (startQuoteToken.Kind)
            {
                case SyntaxKind.SingleQuoteToken:
                case SyntaxKind.DoubleQuoteToken: break;
                default: throw new ArgumentException(nameof(startQuoteToken));
            }
            if (identifier == null) throw new ArgumentNullException(nameof(identifier));
            if (endQuoteToken == null) throw new ArgumentNullException(nameof(endQuoteToken));
            switch (endQuoteToken.Kind)
            {
                case SyntaxKind.SingleQuoteToken:
                case SyntaxKind.DoubleQuoteToken: break;
                default: throw new ArgumentException(nameof(endQuoteToken));
            }
#endif

            return new XmlNameAttributeSyntax(SyntaxKind.XmlNameAttribute, name, equalsToken, startQuoteToken, identifier, endQuoteToken, this.context);
        }

        public XmlTextSyntax XmlText(Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SyntaxToken> textTokens)
        {
#if DEBUG
#endif

            int hash;
            var cached = CSharpSyntaxNodeCache.TryGetNode((int)SyntaxKind.XmlText, textTokens.Node, this.context, out hash);
            if (cached != null) return (XmlTextSyntax)cached;

            var result = new XmlTextSyntax(SyntaxKind.XmlText, textTokens.Node, this.context);
            if (hash >= 0)
            {
                SyntaxNodeCache.AddNode(result, hash);
            }

            return result;
        }

        public XmlCDataSectionSyntax XmlCDataSection(SyntaxToken startCDataToken, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SyntaxToken> textTokens, SyntaxToken endCDataToken)
        {
#if DEBUG
            if (startCDataToken == null) throw new ArgumentNullException(nameof(startCDataToken));
            if (startCDataToken.Kind != SyntaxKind.XmlCDataStartToken) throw new ArgumentException(nameof(startCDataToken));
            if (endCDataToken == null) throw new ArgumentNullException(nameof(endCDataToken));
            if (endCDataToken.Kind != SyntaxKind.XmlCDataEndToken) throw new ArgumentException(nameof(endCDataToken));
#endif

            int hash;
            var cached = CSharpSyntaxNodeCache.TryGetNode((int)SyntaxKind.XmlCDataSection, startCDataToken, textTokens.Node, endCDataToken, this.context, out hash);
            if (cached != null) return (XmlCDataSectionSyntax)cached;

            var result = new XmlCDataSectionSyntax(SyntaxKind.XmlCDataSection, startCDataToken, textTokens.Node, endCDataToken, this.context);
            if (hash >= 0)
            {
                SyntaxNodeCache.AddNode(result, hash);
            }

            return result;
        }

        public XmlProcessingInstructionSyntax XmlProcessingInstruction(SyntaxToken startProcessingInstructionToken, XmlNameSyntax name, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SyntaxToken> textTokens, SyntaxToken endProcessingInstructionToken)
        {
#if DEBUG
            if (startProcessingInstructionToken == null) throw new ArgumentNullException(nameof(startProcessingInstructionToken));
            if (startProcessingInstructionToken.Kind != SyntaxKind.XmlProcessingInstructionStartToken) throw new ArgumentException(nameof(startProcessingInstructionToken));
            if (name == null) throw new ArgumentNullException(nameof(name));
            if (endProcessingInstructionToken == null) throw new ArgumentNullException(nameof(endProcessingInstructionToken));
            if (endProcessingInstructionToken.Kind != SyntaxKind.XmlProcessingInstructionEndToken) throw new ArgumentException(nameof(endProcessingInstructionToken));
#endif

            return new XmlProcessingInstructionSyntax(SyntaxKind.XmlProcessingInstruction, startProcessingInstructionToken, name, textTokens.Node, endProcessingInstructionToken, this.context);
        }

        public XmlCommentSyntax XmlComment(SyntaxToken lessThanExclamationMinusMinusToken, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SyntaxToken> textTokens, SyntaxToken minusMinusGreaterThanToken)
        {
#if DEBUG
            if (lessThanExclamationMinusMinusToken == null) throw new ArgumentNullException(nameof(lessThanExclamationMinusMinusToken));
            if (lessThanExclamationMinusMinusToken.Kind != SyntaxKind.XmlCommentStartToken) throw new ArgumentException(nameof(lessThanExclamationMinusMinusToken));
            if (minusMinusGreaterThanToken == null) throw new ArgumentNullException(nameof(minusMinusGreaterThanToken));
            if (minusMinusGreaterThanToken.Kind != SyntaxKind.XmlCommentEndToken) throw new ArgumentException(nameof(minusMinusGreaterThanToken));
#endif

            int hash;
            var cached = CSharpSyntaxNodeCache.TryGetNode((int)SyntaxKind.XmlComment, lessThanExclamationMinusMinusToken, textTokens.Node, minusMinusGreaterThanToken, this.context, out hash);
            if (cached != null) return (XmlCommentSyntax)cached;

            var result = new XmlCommentSyntax(SyntaxKind.XmlComment, lessThanExclamationMinusMinusToken, textTokens.Node, minusMinusGreaterThanToken, this.context);
            if (hash >= 0)
            {
                SyntaxNodeCache.AddNode(result, hash);
            }

            return result;
        }

        public IfDirectiveTriviaSyntax IfDirectiveTrivia(SyntaxToken hashToken, SyntaxToken ifKeyword, ExpressionSyntax condition, SyntaxToken endOfDirectiveToken, bool isActive, bool branchTaken, bool conditionValue)
        {
#if DEBUG
            if (hashToken == null) throw new ArgumentNullException(nameof(hashToken));
            if (hashToken.Kind != SyntaxKind.HashToken) throw new ArgumentException(nameof(hashToken));
            if (ifKeyword == null) throw new ArgumentNullException(nameof(ifKeyword));
            if (ifKeyword.Kind != SyntaxKind.IfKeyword) throw new ArgumentException(nameof(ifKeyword));
            if (condition == null) throw new ArgumentNullException(nameof(condition));
            if (endOfDirectiveToken == null) throw new ArgumentNullException(nameof(endOfDirectiveToken));
            if (endOfDirectiveToken.Kind != SyntaxKind.EndOfDirectiveToken) throw new ArgumentException(nameof(endOfDirectiveToken));
#endif

            return new IfDirectiveTriviaSyntax(SyntaxKind.IfDirectiveTrivia, hashToken, ifKeyword, condition, endOfDirectiveToken, isActive, branchTaken, conditionValue, this.context);
        }

        public ElifDirectiveTriviaSyntax ElifDirectiveTrivia(SyntaxToken hashToken, SyntaxToken elifKeyword, ExpressionSyntax condition, SyntaxToken endOfDirectiveToken, bool isActive, bool branchTaken, bool conditionValue)
        {
#if DEBUG
            if (hashToken == null) throw new ArgumentNullException(nameof(hashToken));
            if (hashToken.Kind != SyntaxKind.HashToken) throw new ArgumentException(nameof(hashToken));
            if (elifKeyword == null) throw new ArgumentNullException(nameof(elifKeyword));
            if (elifKeyword.Kind != SyntaxKind.ElifKeyword) throw new ArgumentException(nameof(elifKeyword));
            if (condition == null) throw new ArgumentNullException(nameof(condition));
            if (endOfDirectiveToken == null) throw new ArgumentNullException(nameof(endOfDirectiveToken));
            if (endOfDirectiveToken.Kind != SyntaxKind.EndOfDirectiveToken) throw new ArgumentException(nameof(endOfDirectiveToken));
#endif

            return new ElifDirectiveTriviaSyntax(SyntaxKind.ElifDirectiveTrivia, hashToken, elifKeyword, condition, endOfDirectiveToken, isActive, branchTaken, conditionValue, this.context);
        }

        public ElseDirectiveTriviaSyntax ElseDirectiveTrivia(SyntaxToken hashToken, SyntaxToken elseKeyword, SyntaxToken endOfDirectiveToken, bool isActive, bool branchTaken)
        {
#if DEBUG
            if (hashToken == null) throw new ArgumentNullException(nameof(hashToken));
            if (hashToken.Kind != SyntaxKind.HashToken) throw new ArgumentException(nameof(hashToken));
            if (elseKeyword == null) throw new ArgumentNullException(nameof(elseKeyword));
            if (elseKeyword.Kind != SyntaxKind.ElseKeyword) throw new ArgumentException(nameof(elseKeyword));
            if (endOfDirectiveToken == null) throw new ArgumentNullException(nameof(endOfDirectiveToken));
            if (endOfDirectiveToken.Kind != SyntaxKind.EndOfDirectiveToken) throw new ArgumentException(nameof(endOfDirectiveToken));
#endif

            return new ElseDirectiveTriviaSyntax(SyntaxKind.ElseDirectiveTrivia, hashToken, elseKeyword, endOfDirectiveToken, isActive, branchTaken, this.context);
        }

        public EndIfDirectiveTriviaSyntax EndIfDirectiveTrivia(SyntaxToken hashToken, SyntaxToken endIfKeyword, SyntaxToken endOfDirectiveToken, bool isActive)
        {
#if DEBUG
            if (hashToken == null) throw new ArgumentNullException(nameof(hashToken));
            if (hashToken.Kind != SyntaxKind.HashToken) throw new ArgumentException(nameof(hashToken));
            if (endIfKeyword == null) throw new ArgumentNullException(nameof(endIfKeyword));
            if (endIfKeyword.Kind != SyntaxKind.EndIfKeyword) throw new ArgumentException(nameof(endIfKeyword));
            if (endOfDirectiveToken == null) throw new ArgumentNullException(nameof(endOfDirectiveToken));
            if (endOfDirectiveToken.Kind != SyntaxKind.EndOfDirectiveToken) throw new ArgumentException(nameof(endOfDirectiveToken));
#endif

            return new EndIfDirectiveTriviaSyntax(SyntaxKind.EndIfDirectiveTrivia, hashToken, endIfKeyword, endOfDirectiveToken, isActive, this.context);
        }

        public RegionDirectiveTriviaSyntax RegionDirectiveTrivia(SyntaxToken hashToken, SyntaxToken regionKeyword, SyntaxToken endOfDirectiveToken, bool isActive)
        {
#if DEBUG
            if (hashToken == null) throw new ArgumentNullException(nameof(hashToken));
            if (hashToken.Kind != SyntaxKind.HashToken) throw new ArgumentException(nameof(hashToken));
            if (regionKeyword == null) throw new ArgumentNullException(nameof(regionKeyword));
            if (regionKeyword.Kind != SyntaxKind.RegionKeyword) throw new ArgumentException(nameof(regionKeyword));
            if (endOfDirectiveToken == null) throw new ArgumentNullException(nameof(endOfDirectiveToken));
            if (endOfDirectiveToken.Kind != SyntaxKind.EndOfDirectiveToken) throw new ArgumentException(nameof(endOfDirectiveToken));
#endif

            return new RegionDirectiveTriviaSyntax(SyntaxKind.RegionDirectiveTrivia, hashToken, regionKeyword, endOfDirectiveToken, isActive, this.context);
        }

        public EndRegionDirectiveTriviaSyntax EndRegionDirectiveTrivia(SyntaxToken hashToken, SyntaxToken endRegionKeyword, SyntaxToken endOfDirectiveToken, bool isActive)
        {
#if DEBUG
            if (hashToken == null) throw new ArgumentNullException(nameof(hashToken));
            if (hashToken.Kind != SyntaxKind.HashToken) throw new ArgumentException(nameof(hashToken));
            if (endRegionKeyword == null) throw new ArgumentNullException(nameof(endRegionKeyword));
            if (endRegionKeyword.Kind != SyntaxKind.EndRegionKeyword) throw new ArgumentException(nameof(endRegionKeyword));
            if (endOfDirectiveToken == null) throw new ArgumentNullException(nameof(endOfDirectiveToken));
            if (endOfDirectiveToken.Kind != SyntaxKind.EndOfDirectiveToken) throw new ArgumentException(nameof(endOfDirectiveToken));
#endif

            return new EndRegionDirectiveTriviaSyntax(SyntaxKind.EndRegionDirectiveTrivia, hashToken, endRegionKeyword, endOfDirectiveToken, isActive, this.context);
        }

        public ErrorDirectiveTriviaSyntax ErrorDirectiveTrivia(SyntaxToken hashToken, SyntaxToken errorKeyword, SyntaxToken endOfDirectiveToken, bool isActive)
        {
#if DEBUG
            if (hashToken == null) throw new ArgumentNullException(nameof(hashToken));
            if (hashToken.Kind != SyntaxKind.HashToken) throw new ArgumentException(nameof(hashToken));
            if (errorKeyword == null) throw new ArgumentNullException(nameof(errorKeyword));
            if (errorKeyword.Kind != SyntaxKind.ErrorKeyword) throw new ArgumentException(nameof(errorKeyword));
            if (endOfDirectiveToken == null) throw new ArgumentNullException(nameof(endOfDirectiveToken));
            if (endOfDirectiveToken.Kind != SyntaxKind.EndOfDirectiveToken) throw new ArgumentException(nameof(endOfDirectiveToken));
#endif

            return new ErrorDirectiveTriviaSyntax(SyntaxKind.ErrorDirectiveTrivia, hashToken, errorKeyword, endOfDirectiveToken, isActive, this.context);
        }

        public WarningDirectiveTriviaSyntax WarningDirectiveTrivia(SyntaxToken hashToken, SyntaxToken warningKeyword, SyntaxToken endOfDirectiveToken, bool isActive)
        {
#if DEBUG
            if (hashToken == null) throw new ArgumentNullException(nameof(hashToken));
            if (hashToken.Kind != SyntaxKind.HashToken) throw new ArgumentException(nameof(hashToken));
            if (warningKeyword == null) throw new ArgumentNullException(nameof(warningKeyword));
            if (warningKeyword.Kind != SyntaxKind.WarningKeyword) throw new ArgumentException(nameof(warningKeyword));
            if (endOfDirectiveToken == null) throw new ArgumentNullException(nameof(endOfDirectiveToken));
            if (endOfDirectiveToken.Kind != SyntaxKind.EndOfDirectiveToken) throw new ArgumentException(nameof(endOfDirectiveToken));
#endif

            return new WarningDirectiveTriviaSyntax(SyntaxKind.WarningDirectiveTrivia, hashToken, warningKeyword, endOfDirectiveToken, isActive, this.context);
        }

        public BadDirectiveTriviaSyntax BadDirectiveTrivia(SyntaxToken hashToken, SyntaxToken identifier, SyntaxToken endOfDirectiveToken, bool isActive)
        {
#if DEBUG
            if (hashToken == null) throw new ArgumentNullException(nameof(hashToken));
            if (hashToken.Kind != SyntaxKind.HashToken) throw new ArgumentException(nameof(hashToken));
            if (identifier == null) throw new ArgumentNullException(nameof(identifier));
            if (endOfDirectiveToken == null) throw new ArgumentNullException(nameof(endOfDirectiveToken));
            if (endOfDirectiveToken.Kind != SyntaxKind.EndOfDirectiveToken) throw new ArgumentException(nameof(endOfDirectiveToken));
#endif

            return new BadDirectiveTriviaSyntax(SyntaxKind.BadDirectiveTrivia, hashToken, identifier, endOfDirectiveToken, isActive, this.context);
        }

        public DefineDirectiveTriviaSyntax DefineDirectiveTrivia(SyntaxToken hashToken, SyntaxToken defineKeyword, SyntaxToken name, SyntaxToken endOfDirectiveToken, bool isActive)
        {
#if DEBUG
            if (hashToken == null) throw new ArgumentNullException(nameof(hashToken));
            if (hashToken.Kind != SyntaxKind.HashToken) throw new ArgumentException(nameof(hashToken));
            if (defineKeyword == null) throw new ArgumentNullException(nameof(defineKeyword));
            if (defineKeyword.Kind != SyntaxKind.DefineKeyword) throw new ArgumentException(nameof(defineKeyword));
            if (name == null) throw new ArgumentNullException(nameof(name));
            if (name.Kind != SyntaxKind.IdentifierToken) throw new ArgumentException(nameof(name));
            if (endOfDirectiveToken == null) throw new ArgumentNullException(nameof(endOfDirectiveToken));
            if (endOfDirectiveToken.Kind != SyntaxKind.EndOfDirectiveToken) throw new ArgumentException(nameof(endOfDirectiveToken));
#endif

            return new DefineDirectiveTriviaSyntax(SyntaxKind.DefineDirectiveTrivia, hashToken, defineKeyword, name, endOfDirectiveToken, isActive, this.context);
        }

        public UndefDirectiveTriviaSyntax UndefDirectiveTrivia(SyntaxToken hashToken, SyntaxToken undefKeyword, SyntaxToken name, SyntaxToken endOfDirectiveToken, bool isActive)
        {
#if DEBUG
            if (hashToken == null) throw new ArgumentNullException(nameof(hashToken));
            if (hashToken.Kind != SyntaxKind.HashToken) throw new ArgumentException(nameof(hashToken));
            if (undefKeyword == null) throw new ArgumentNullException(nameof(undefKeyword));
            if (undefKeyword.Kind != SyntaxKind.UndefKeyword) throw new ArgumentException(nameof(undefKeyword));
            if (name == null) throw new ArgumentNullException(nameof(name));
            if (name.Kind != SyntaxKind.IdentifierToken) throw new ArgumentException(nameof(name));
            if (endOfDirectiveToken == null) throw new ArgumentNullException(nameof(endOfDirectiveToken));
            if (endOfDirectiveToken.Kind != SyntaxKind.EndOfDirectiveToken) throw new ArgumentException(nameof(endOfDirectiveToken));
#endif

            return new UndefDirectiveTriviaSyntax(SyntaxKind.UndefDirectiveTrivia, hashToken, undefKeyword, name, endOfDirectiveToken, isActive, this.context);
        }

        public LineDirectiveTriviaSyntax LineDirectiveTrivia(SyntaxToken hashToken, SyntaxToken lineKeyword, SyntaxToken line, SyntaxToken? file, SyntaxToken endOfDirectiveToken, bool isActive)
        {
#if DEBUG
            if (hashToken == null) throw new ArgumentNullException(nameof(hashToken));
            if (hashToken.Kind != SyntaxKind.HashToken) throw new ArgumentException(nameof(hashToken));
            if (lineKeyword == null) throw new ArgumentNullException(nameof(lineKeyword));
            if (lineKeyword.Kind != SyntaxKind.LineKeyword) throw new ArgumentException(nameof(lineKeyword));
            if (line == null) throw new ArgumentNullException(nameof(line));
            switch (line.Kind)
            {
                case SyntaxKind.NumericLiteralToken:
                case SyntaxKind.DefaultKeyword:
                case SyntaxKind.HiddenKeyword: break;
                default: throw new ArgumentException(nameof(line));
            }
            if (file != null)
            {
                switch (file.Kind)
                {
                    case SyntaxKind.StringLiteralToken:
                    case SyntaxKind.None: break;
                    default: throw new ArgumentException(nameof(file));
                }
            }
            if (endOfDirectiveToken == null) throw new ArgumentNullException(nameof(endOfDirectiveToken));
            if (endOfDirectiveToken.Kind != SyntaxKind.EndOfDirectiveToken) throw new ArgumentException(nameof(endOfDirectiveToken));
#endif

            return new LineDirectiveTriviaSyntax(SyntaxKind.LineDirectiveTrivia, hashToken, lineKeyword, line, file, endOfDirectiveToken, isActive, this.context);
        }

        public PragmaWarningDirectiveTriviaSyntax PragmaWarningDirectiveTrivia(SyntaxToken hashToken, SyntaxToken pragmaKeyword, SyntaxToken warningKeyword, SyntaxToken disableOrRestoreKeyword, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<ExpressionSyntax> errorCodes, SyntaxToken endOfDirectiveToken, bool isActive)
        {
#if DEBUG
            if (hashToken == null) throw new ArgumentNullException(nameof(hashToken));
            if (hashToken.Kind != SyntaxKind.HashToken) throw new ArgumentException(nameof(hashToken));
            if (pragmaKeyword == null) throw new ArgumentNullException(nameof(pragmaKeyword));
            if (pragmaKeyword.Kind != SyntaxKind.PragmaKeyword) throw new ArgumentException(nameof(pragmaKeyword));
            if (warningKeyword == null) throw new ArgumentNullException(nameof(warningKeyword));
            if (warningKeyword.Kind != SyntaxKind.WarningKeyword) throw new ArgumentException(nameof(warningKeyword));
            if (disableOrRestoreKeyword == null) throw new ArgumentNullException(nameof(disableOrRestoreKeyword));
            switch (disableOrRestoreKeyword.Kind)
            {
                case SyntaxKind.DisableKeyword:
                case SyntaxKind.RestoreKeyword: break;
                default: throw new ArgumentException(nameof(disableOrRestoreKeyword));
            }
            if (endOfDirectiveToken == null) throw new ArgumentNullException(nameof(endOfDirectiveToken));
            if (endOfDirectiveToken.Kind != SyntaxKind.EndOfDirectiveToken) throw new ArgumentException(nameof(endOfDirectiveToken));
#endif

            return new PragmaWarningDirectiveTriviaSyntax(SyntaxKind.PragmaWarningDirectiveTrivia, hashToken, pragmaKeyword, warningKeyword, disableOrRestoreKeyword, errorCodes.Node, endOfDirectiveToken, isActive, this.context);
        }

        public PragmaChecksumDirectiveTriviaSyntax PragmaChecksumDirectiveTrivia(SyntaxToken hashToken, SyntaxToken pragmaKeyword, SyntaxToken checksumKeyword, SyntaxToken file, SyntaxToken guid, SyntaxToken bytes, SyntaxToken endOfDirectiveToken, bool isActive)
        {
#if DEBUG
            if (hashToken == null) throw new ArgumentNullException(nameof(hashToken));
            if (hashToken.Kind != SyntaxKind.HashToken) throw new ArgumentException(nameof(hashToken));
            if (pragmaKeyword == null) throw new ArgumentNullException(nameof(pragmaKeyword));
            if (pragmaKeyword.Kind != SyntaxKind.PragmaKeyword) throw new ArgumentException(nameof(pragmaKeyword));
            if (checksumKeyword == null) throw new ArgumentNullException(nameof(checksumKeyword));
            if (checksumKeyword.Kind != SyntaxKind.ChecksumKeyword) throw new ArgumentException(nameof(checksumKeyword));
            if (file == null) throw new ArgumentNullException(nameof(file));
            if (file.Kind != SyntaxKind.StringLiteralToken) throw new ArgumentException(nameof(file));
            if (guid == null) throw new ArgumentNullException(nameof(guid));
            if (guid.Kind != SyntaxKind.StringLiteralToken) throw new ArgumentException(nameof(guid));
            if (bytes == null) throw new ArgumentNullException(nameof(bytes));
            if (bytes.Kind != SyntaxKind.StringLiteralToken) throw new ArgumentException(nameof(bytes));
            if (endOfDirectiveToken == null) throw new ArgumentNullException(nameof(endOfDirectiveToken));
            if (endOfDirectiveToken.Kind != SyntaxKind.EndOfDirectiveToken) throw new ArgumentException(nameof(endOfDirectiveToken));
#endif

            return new PragmaChecksumDirectiveTriviaSyntax(SyntaxKind.PragmaChecksumDirectiveTrivia, hashToken, pragmaKeyword, checksumKeyword, file, guid, bytes, endOfDirectiveToken, isActive, this.context);
        }

        public ReferenceDirectiveTriviaSyntax ReferenceDirectiveTrivia(SyntaxToken hashToken, SyntaxToken referenceKeyword, SyntaxToken file, SyntaxToken endOfDirectiveToken, bool isActive)
        {
#if DEBUG
            if (hashToken == null) throw new ArgumentNullException(nameof(hashToken));
            if (hashToken.Kind != SyntaxKind.HashToken) throw new ArgumentException(nameof(hashToken));
            if (referenceKeyword == null) throw new ArgumentNullException(nameof(referenceKeyword));
            if (referenceKeyword.Kind != SyntaxKind.ReferenceKeyword) throw new ArgumentException(nameof(referenceKeyword));
            if (file == null) throw new ArgumentNullException(nameof(file));
            if (file.Kind != SyntaxKind.StringLiteralToken) throw new ArgumentException(nameof(file));
            if (endOfDirectiveToken == null) throw new ArgumentNullException(nameof(endOfDirectiveToken));
            if (endOfDirectiveToken.Kind != SyntaxKind.EndOfDirectiveToken) throw new ArgumentException(nameof(endOfDirectiveToken));
#endif

            return new ReferenceDirectiveTriviaSyntax(SyntaxKind.ReferenceDirectiveTrivia, hashToken, referenceKeyword, file, endOfDirectiveToken, isActive, this.context);
        }

        public LoadDirectiveTriviaSyntax LoadDirectiveTrivia(SyntaxToken hashToken, SyntaxToken loadKeyword, SyntaxToken file, SyntaxToken endOfDirectiveToken, bool isActive)
        {
#if DEBUG
            if (hashToken == null) throw new ArgumentNullException(nameof(hashToken));
            if (hashToken.Kind != SyntaxKind.HashToken) throw new ArgumentException(nameof(hashToken));
            if (loadKeyword == null) throw new ArgumentNullException(nameof(loadKeyword));
            if (loadKeyword.Kind != SyntaxKind.LoadKeyword) throw new ArgumentException(nameof(loadKeyword));
            if (file == null) throw new ArgumentNullException(nameof(file));
            if (file.Kind != SyntaxKind.StringLiteralToken) throw new ArgumentException(nameof(file));
            if (endOfDirectiveToken == null) throw new ArgumentNullException(nameof(endOfDirectiveToken));
            if (endOfDirectiveToken.Kind != SyntaxKind.EndOfDirectiveToken) throw new ArgumentException(nameof(endOfDirectiveToken));
#endif

            return new LoadDirectiveTriviaSyntax(SyntaxKind.LoadDirectiveTrivia, hashToken, loadKeyword, file, endOfDirectiveToken, isActive, this.context);
        }

        public ShebangDirectiveTriviaSyntax ShebangDirectiveTrivia(SyntaxToken hashToken, SyntaxToken exclamationToken, SyntaxToken endOfDirectiveToken, bool isActive)
        {
#if DEBUG
            if (hashToken == null) throw new ArgumentNullException(nameof(hashToken));
            if (hashToken.Kind != SyntaxKind.HashToken) throw new ArgumentException(nameof(hashToken));
            if (exclamationToken == null) throw new ArgumentNullException(nameof(exclamationToken));
            if (exclamationToken.Kind != SyntaxKind.ExclamationToken) throw new ArgumentException(nameof(exclamationToken));
            if (endOfDirectiveToken == null) throw new ArgumentNullException(nameof(endOfDirectiveToken));
            if (endOfDirectiveToken.Kind != SyntaxKind.EndOfDirectiveToken) throw new ArgumentException(nameof(endOfDirectiveToken));
#endif

            return new ShebangDirectiveTriviaSyntax(SyntaxKind.ShebangDirectiveTrivia, hashToken, exclamationToken, endOfDirectiveToken, isActive, this.context);
        }

        public NullableDirectiveTriviaSyntax NullableDirectiveTrivia(SyntaxToken hashToken, SyntaxToken nullableKeyword, SyntaxToken settingToken, SyntaxToken? targetToken, SyntaxToken endOfDirectiveToken, bool isActive)
        {
#if DEBUG
            if (hashToken == null) throw new ArgumentNullException(nameof(hashToken));
            if (hashToken.Kind != SyntaxKind.HashToken) throw new ArgumentException(nameof(hashToken));
            if (nullableKeyword == null) throw new ArgumentNullException(nameof(nullableKeyword));
            if (nullableKeyword.Kind != SyntaxKind.NullableKeyword) throw new ArgumentException(nameof(nullableKeyword));
            if (settingToken == null) throw new ArgumentNullException(nameof(settingToken));
            switch (settingToken.Kind)
            {
                case SyntaxKind.EnableKeyword:
                case SyntaxKind.DisableKeyword:
                case SyntaxKind.RestoreKeyword: break;
                default: throw new ArgumentException(nameof(settingToken));
            }
            if (targetToken != null)
            {
                switch (targetToken.Kind)
                {
                    case SyntaxKind.WarningsKeyword:
                    case SyntaxKind.AnnotationsKeyword:
                    case SyntaxKind.None: break;
                    default: throw new ArgumentException(nameof(targetToken));
                }
            }
            if (endOfDirectiveToken == null) throw new ArgumentNullException(nameof(endOfDirectiveToken));
            if (endOfDirectiveToken.Kind != SyntaxKind.EndOfDirectiveToken) throw new ArgumentException(nameof(endOfDirectiveToken));
#endif

            return new NullableDirectiveTriviaSyntax(SyntaxKind.NullableDirectiveTrivia, hashToken, nullableKeyword, settingToken, targetToken, endOfDirectiveToken, isActive, this.context);
        }
    }

    internal static partial class SyntaxFactory
    {
        public static IdentifierNameSyntax IdentifierName(SyntaxToken identifier)
        {
#if DEBUG
            if (identifier == null) throw new ArgumentNullException(nameof(identifier));
            switch (identifier.Kind)
            {
                case SyntaxKind.IdentifierToken:
                case SyntaxKind.GlobalKeyword: break;
                default: throw new ArgumentException(nameof(identifier));
            }
#endif

            int hash;
            var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.IdentifierName, identifier, out hash);
            if (cached != null) return (IdentifierNameSyntax)cached;

            var result = new IdentifierNameSyntax(SyntaxKind.IdentifierName, identifier);
            if (hash >= 0)
            {
                SyntaxNodeCache.AddNode(result, hash);
            }

            return result;
        }

        public static QualifiedNameSyntax QualifiedName(NameSyntax left, SyntaxToken dotToken, SimpleNameSyntax right)
        {
#if DEBUG
            if (left == null) throw new ArgumentNullException(nameof(left));
            if (dotToken == null) throw new ArgumentNullException(nameof(dotToken));
            if (dotToken.Kind != SyntaxKind.DotToken) throw new ArgumentException(nameof(dotToken));
            if (right == null) throw new ArgumentNullException(nameof(right));
#endif

            int hash;
            var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.QualifiedName, left, dotToken, right, out hash);
            if (cached != null) return (QualifiedNameSyntax)cached;

            var result = new QualifiedNameSyntax(SyntaxKind.QualifiedName, left, dotToken, right);
            if (hash >= 0)
            {
                SyntaxNodeCache.AddNode(result, hash);
            }

            return result;
        }

        public static GenericNameSyntax GenericName(SyntaxToken identifier, TypeArgumentListSyntax typeArgumentList)
        {
#if DEBUG
            if (identifier == null) throw new ArgumentNullException(nameof(identifier));
            if (identifier.Kind != SyntaxKind.IdentifierToken) throw new ArgumentException(nameof(identifier));
            if (typeArgumentList == null) throw new ArgumentNullException(nameof(typeArgumentList));
#endif

            int hash;
            var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.GenericName, identifier, typeArgumentList, out hash);
            if (cached != null) return (GenericNameSyntax)cached;

            var result = new GenericNameSyntax(SyntaxKind.GenericName, identifier, typeArgumentList);
            if (hash >= 0)
            {
                SyntaxNodeCache.AddNode(result, hash);
            }

            return result;
        }

        public static TypeArgumentListSyntax TypeArgumentList(SyntaxToken lessThanToken, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<TypeSyntax> arguments, SyntaxToken greaterThanToken)
        {
#if DEBUG
            if (lessThanToken == null) throw new ArgumentNullException(nameof(lessThanToken));
            if (lessThanToken.Kind != SyntaxKind.LessThanToken) throw new ArgumentException(nameof(lessThanToken));
            if (greaterThanToken == null) throw new ArgumentNullException(nameof(greaterThanToken));
            if (greaterThanToken.Kind != SyntaxKind.GreaterThanToken) throw new ArgumentException(nameof(greaterThanToken));
#endif

            int hash;
            var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.TypeArgumentList, lessThanToken, arguments.Node, greaterThanToken, out hash);
            if (cached != null) return (TypeArgumentListSyntax)cached;

            var result = new TypeArgumentListSyntax(SyntaxKind.TypeArgumentList, lessThanToken, arguments.Node, greaterThanToken);
            if (hash >= 0)
            {
                SyntaxNodeCache.AddNode(result, hash);
            }

            return result;
        }

        public static AliasQualifiedNameSyntax AliasQualifiedName(IdentifierNameSyntax alias, SyntaxToken colonColonToken, SimpleNameSyntax name)
        {
#if DEBUG
            if (alias == null) throw new ArgumentNullException(nameof(alias));
            if (colonColonToken == null) throw new ArgumentNullException(nameof(colonColonToken));
            if (colonColonToken.Kind != SyntaxKind.ColonColonToken) throw new ArgumentException(nameof(colonColonToken));
            if (name == null) throw new ArgumentNullException(nameof(name));
#endif

            int hash;
            var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.AliasQualifiedName, alias, colonColonToken, name, out hash);
            if (cached != null) return (AliasQualifiedNameSyntax)cached;

            var result = new AliasQualifiedNameSyntax(SyntaxKind.AliasQualifiedName, alias, colonColonToken, name);
            if (hash >= 0)
            {
                SyntaxNodeCache.AddNode(result, hash);
            }

            return result;
        }

        public static PredefinedTypeSyntax PredefinedType(SyntaxToken keyword)
        {
#if DEBUG
            if (keyword == null) throw new ArgumentNullException(nameof(keyword));
            switch (keyword.Kind)
            {
                case SyntaxKind.BoolKeyword:
                case SyntaxKind.ByteKeyword:
                case SyntaxKind.SByteKeyword:
                case SyntaxKind.IntKeyword:
                case SyntaxKind.UIntKeyword:
                case SyntaxKind.ShortKeyword:
                case SyntaxKind.UShortKeyword:
                case SyntaxKind.LongKeyword:
                case SyntaxKind.ULongKeyword:
                case SyntaxKind.FloatKeyword:
                case SyntaxKind.DoubleKeyword:
                case SyntaxKind.DecimalKeyword:
                case SyntaxKind.StringKeyword:
                case SyntaxKind.CharKeyword:
                case SyntaxKind.ObjectKeyword:
                case SyntaxKind.VoidKeyword: break;
                default: throw new ArgumentException(nameof(keyword));
            }
#endif

            int hash;
            var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.PredefinedType, keyword, out hash);
            if (cached != null) return (PredefinedTypeSyntax)cached;

            var result = new PredefinedTypeSyntax(SyntaxKind.PredefinedType, keyword);
            if (hash >= 0)
            {
                SyntaxNodeCache.AddNode(result, hash);
            }

            return result;
        }

        public static ArrayTypeSyntax ArrayType(TypeSyntax elementType, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<ArrayRankSpecifierSyntax> rankSpecifiers)
        {
#if DEBUG
            if (elementType == null) throw new ArgumentNullException(nameof(elementType));
#endif

            int hash;
            var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.ArrayType, elementType, rankSpecifiers.Node, out hash);
            if (cached != null) return (ArrayTypeSyntax)cached;

            var result = new ArrayTypeSyntax(SyntaxKind.ArrayType, elementType, rankSpecifiers.Node);
            if (hash >= 0)
            {
                SyntaxNodeCache.AddNode(result, hash);
            }

            return result;
        }

        public static ArrayRankSpecifierSyntax ArrayRankSpecifier(SyntaxToken openBracketToken, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<ExpressionSyntax> sizes, SyntaxToken closeBracketToken)
        {
#if DEBUG
            if (openBracketToken == null) throw new ArgumentNullException(nameof(openBracketToken));
            if (openBracketToken.Kind != SyntaxKind.OpenBracketToken) throw new ArgumentException(nameof(openBracketToken));
            if (closeBracketToken == null) throw new ArgumentNullException(nameof(closeBracketToken));
            if (closeBracketToken.Kind != SyntaxKind.CloseBracketToken) throw new ArgumentException(nameof(closeBracketToken));
#endif

            int hash;
            var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.ArrayRankSpecifier, openBracketToken, sizes.Node, closeBracketToken, out hash);
            if (cached != null) return (ArrayRankSpecifierSyntax)cached;

            var result = new ArrayRankSpecifierSyntax(SyntaxKind.ArrayRankSpecifier, openBracketToken, sizes.Node, closeBracketToken);
            if (hash >= 0)
            {
                SyntaxNodeCache.AddNode(result, hash);
            }

            return result;
        }

        public static PointerTypeSyntax PointerType(TypeSyntax elementType, SyntaxToken asteriskToken)
        {
#if DEBUG
            if (elementType == null) throw new ArgumentNullException(nameof(elementType));
            if (asteriskToken == null) throw new ArgumentNullException(nameof(asteriskToken));
            if (asteriskToken.Kind != SyntaxKind.AsteriskToken) throw new ArgumentException(nameof(asteriskToken));
#endif

            int hash;
            var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.PointerType, elementType, asteriskToken, out hash);
            if (cached != null) return (PointerTypeSyntax)cached;

            var result = new PointerTypeSyntax(SyntaxKind.PointerType, elementType, asteriskToken);
            if (hash >= 0)
            {
                SyntaxNodeCache.AddNode(result, hash);
            }

            return result;
        }

        public static FunctionPointerTypeSyntax FunctionPointerType(SyntaxToken delegateKeyword, SyntaxToken asteriskToken, FunctionPointerCallingConventionSyntax? callingConvention, FunctionPointerParameterListSyntax parameterList)
        {
#if DEBUG
            if (delegateKeyword == null) throw new ArgumentNullException(nameof(delegateKeyword));
            if (delegateKeyword.Kind != SyntaxKind.DelegateKeyword) throw new ArgumentException(nameof(delegateKeyword));
            if (asteriskToken == null) throw new ArgumentNullException(nameof(asteriskToken));
            if (asteriskToken.Kind != SyntaxKind.AsteriskToken) throw new ArgumentException(nameof(asteriskToken));
            if (parameterList == null) throw new ArgumentNullException(nameof(parameterList));
#endif

            return new FunctionPointerTypeSyntax(SyntaxKind.FunctionPointerType, delegateKeyword, asteriskToken, callingConvention, parameterList);
        }

        public static FunctionPointerParameterListSyntax FunctionPointerParameterList(SyntaxToken lessThanToken, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<FunctionPointerParameterSyntax> parameters, SyntaxToken greaterThanToken)
        {
#if DEBUG
            if (lessThanToken == null) throw new ArgumentNullException(nameof(lessThanToken));
            if (lessThanToken.Kind != SyntaxKind.LessThanToken) throw new ArgumentException(nameof(lessThanToken));
            if (greaterThanToken == null) throw new ArgumentNullException(nameof(greaterThanToken));
            if (greaterThanToken.Kind != SyntaxKind.GreaterThanToken) throw new ArgumentException(nameof(greaterThanToken));
#endif

            int hash;
            var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.FunctionPointerParameterList, lessThanToken, parameters.Node, greaterThanToken, out hash);
            if (cached != null) return (FunctionPointerParameterListSyntax)cached;

            var result = new FunctionPointerParameterListSyntax(SyntaxKind.FunctionPointerParameterList, lessThanToken, parameters.Node, greaterThanToken);
            if (hash >= 0)
            {
                SyntaxNodeCache.AddNode(result, hash);
            }

            return result;
        }

        public static FunctionPointerCallingConventionSyntax FunctionPointerCallingConvention(SyntaxToken managedOrUnmanagedKeyword, FunctionPointerUnmanagedCallingConventionListSyntax? unmanagedCallingConventionList)
        {
#if DEBUG
            if (managedOrUnmanagedKeyword == null) throw new ArgumentNullException(nameof(managedOrUnmanagedKeyword));
            switch (managedOrUnmanagedKeyword.Kind)
            {
                case SyntaxKind.ManagedKeyword:
                case SyntaxKind.UnmanagedKeyword: break;
                default: throw new ArgumentException(nameof(managedOrUnmanagedKeyword));
            }
#endif

            int hash;
            var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.FunctionPointerCallingConvention, managedOrUnmanagedKeyword, unmanagedCallingConventionList, out hash);
            if (cached != null) return (FunctionPointerCallingConventionSyntax)cached;

            var result = new FunctionPointerCallingConventionSyntax(SyntaxKind.FunctionPointerCallingConvention, managedOrUnmanagedKeyword, unmanagedCallingConventionList);
            if (hash >= 0)
            {
                SyntaxNodeCache.AddNode(result, hash);
            }

            return result;
        }

        public static FunctionPointerUnmanagedCallingConventionListSyntax FunctionPointerUnmanagedCallingConventionList(SyntaxToken openBracketToken, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<FunctionPointerUnmanagedCallingConventionSyntax> callingConventions, SyntaxToken closeBracketToken)
        {
#if DEBUG
            if (openBracketToken == null) throw new ArgumentNullException(nameof(openBracketToken));
            if (openBracketToken.Kind != SyntaxKind.OpenBracketToken) throw new ArgumentException(nameof(openBracketToken));
            if (closeBracketToken == null) throw new ArgumentNullException(nameof(closeBracketToken));
            if (closeBracketToken.Kind != SyntaxKind.CloseBracketToken) throw new ArgumentException(nameof(closeBracketToken));
#endif

            int hash;
            var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.FunctionPointerUnmanagedCallingConventionList, openBracketToken, callingConventions.Node, closeBracketToken, out hash);
            if (cached != null) return (FunctionPointerUnmanagedCallingConventionListSyntax)cached;

            var result = new FunctionPointerUnmanagedCallingConventionListSyntax(SyntaxKind.FunctionPointerUnmanagedCallingConventionList, openBracketToken, callingConventions.Node, closeBracketToken);
            if (hash >= 0)
            {
                SyntaxNodeCache.AddNode(result, hash);
            }

            return result;
        }

        public static FunctionPointerUnmanagedCallingConventionSyntax FunctionPointerUnmanagedCallingConvention(SyntaxToken name)
        {
#if DEBUG
            if (name == null) throw new ArgumentNullException(nameof(name));
            if (name.Kind != SyntaxKind.IdentifierToken) throw new ArgumentException(nameof(name));
#endif

            int hash;
            var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.FunctionPointerUnmanagedCallingConvention, name, out hash);
            if (cached != null) return (FunctionPointerUnmanagedCallingConventionSyntax)cached;

            var result = new FunctionPointerUnmanagedCallingConventionSyntax(SyntaxKind.FunctionPointerUnmanagedCallingConvention, name);
            if (hash >= 0)
            {
                SyntaxNodeCache.AddNode(result, hash);
            }

            return result;
        }

        public static NullableTypeSyntax NullableType(TypeSyntax elementType, SyntaxToken questionToken)
        {
#if DEBUG
            if (elementType == null) throw new ArgumentNullException(nameof(elementType));
            if (questionToken == null) throw new ArgumentNullException(nameof(questionToken));
            if (questionToken.Kind != SyntaxKind.QuestionToken) throw new ArgumentException(nameof(questionToken));
#endif

            int hash;
            var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.NullableType, elementType, questionToken, out hash);
            if (cached != null) return (NullableTypeSyntax)cached;

            var result = new NullableTypeSyntax(SyntaxKind.NullableType, elementType, questionToken);
            if (hash >= 0)
            {
                SyntaxNodeCache.AddNode(result, hash);
            }

            return result;
        }

        public static TupleTypeSyntax TupleType(SyntaxToken openParenToken, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<TupleElementSyntax> elements, SyntaxToken closeParenToken)
        {
#if DEBUG
            if (openParenToken == null) throw new ArgumentNullException(nameof(openParenToken));
            if (openParenToken.Kind != SyntaxKind.OpenParenToken) throw new ArgumentException(nameof(openParenToken));
            if (closeParenToken == null) throw new ArgumentNullException(nameof(closeParenToken));
            if (closeParenToken.Kind != SyntaxKind.CloseParenToken) throw new ArgumentException(nameof(closeParenToken));
#endif

            int hash;
            var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.TupleType, openParenToken, elements.Node, closeParenToken, out hash);
            if (cached != null) return (TupleTypeSyntax)cached;

            var result = new TupleTypeSyntax(SyntaxKind.TupleType, openParenToken, elements.Node, closeParenToken);
            if (hash >= 0)
            {
                SyntaxNodeCache.AddNode(result, hash);
            }

            return result;
        }

        public static TupleElementSyntax TupleElement(TypeSyntax type, SyntaxToken? identifier)
        {
#if DEBUG
            if (type == null) throw new ArgumentNullException(nameof(type));
            if (identifier != null)
            {
                switch (identifier.Kind)
                {
                    case SyntaxKind.IdentifierToken:
                    case SyntaxKind.None: break;
                    default: throw new ArgumentException(nameof(identifier));
                }
            }
#endif

            int hash;
            var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.TupleElement, type, identifier, out hash);
            if (cached != null) return (TupleElementSyntax)cached;

            var result = new TupleElementSyntax(SyntaxKind.TupleElement, type, identifier);
            if (hash >= 0)
            {
                SyntaxNodeCache.AddNode(result, hash);
            }

            return result;
        }

        public static OmittedTypeArgumentSyntax OmittedTypeArgument(SyntaxToken omittedTypeArgumentToken)
        {
#if DEBUG
            if (omittedTypeArgumentToken == null) throw new ArgumentNullException(nameof(omittedTypeArgumentToken));
            if (omittedTypeArgumentToken.Kind != SyntaxKind.OmittedTypeArgumentToken) throw new ArgumentException(nameof(omittedTypeArgumentToken));
#endif

            int hash;
            var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.OmittedTypeArgument, omittedTypeArgumentToken, out hash);
            if (cached != null) return (OmittedTypeArgumentSyntax)cached;

            var result = new OmittedTypeArgumentSyntax(SyntaxKind.OmittedTypeArgument, omittedTypeArgumentToken);
            if (hash >= 0)
            {
                SyntaxNodeCache.AddNode(result, hash);
            }

            return result;
        }

        public static RefTypeSyntax RefType(SyntaxToken refKeyword, SyntaxToken? readOnlyKeyword, TypeSyntax type)
        {
#if DEBUG
            if (refKeyword == null) throw new ArgumentNullException(nameof(refKeyword));
            if (refKeyword.Kind != SyntaxKind.RefKeyword) throw new ArgumentException(nameof(refKeyword));
            if (readOnlyKeyword != null)
            {
                switch (readOnlyKeyword.Kind)
                {
                    case SyntaxKind.ReadOnlyKeyword:
                    case SyntaxKind.None: break;
                    default: throw new ArgumentException(nameof(readOnlyKeyword));
                }
            }
            if (type == null) throw new ArgumentNullException(nameof(type));
#endif

            int hash;
            var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.RefType, refKeyword, readOnlyKeyword, type, out hash);
            if (cached != null) return (RefTypeSyntax)cached;

            var result = new RefTypeSyntax(SyntaxKind.RefType, refKeyword, readOnlyKeyword, type);
            if (hash >= 0)
            {
                SyntaxNodeCache.AddNode(result, hash);
            }

            return result;
        }

        public static ParenthesizedExpressionSyntax ParenthesizedExpression(SyntaxToken openParenToken, ExpressionSyntax expression, SyntaxToken closeParenToken)
        {
#if DEBUG
            if (openParenToken == null) throw new ArgumentNullException(nameof(openParenToken));
            if (openParenToken.Kind != SyntaxKind.OpenParenToken) throw new ArgumentException(nameof(openParenToken));
            if (expression == null) throw new ArgumentNullException(nameof(expression));
            if (closeParenToken == null) throw new ArgumentNullException(nameof(closeParenToken));
            if (closeParenToken.Kind != SyntaxKind.CloseParenToken) throw new ArgumentException(nameof(closeParenToken));
#endif

            int hash;
            var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.ParenthesizedExpression, openParenToken, expression, closeParenToken, out hash);
            if (cached != null) return (ParenthesizedExpressionSyntax)cached;

            var result = new ParenthesizedExpressionSyntax(SyntaxKind.ParenthesizedExpression, openParenToken, expression, closeParenToken);
            if (hash >= 0)
            {
                SyntaxNodeCache.AddNode(result, hash);
            }

            return result;
        }

        public static TupleExpressionSyntax TupleExpression(SyntaxToken openParenToken, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<ArgumentSyntax> arguments, SyntaxToken closeParenToken)
        {
#if DEBUG
            if (openParenToken == null) throw new ArgumentNullException(nameof(openParenToken));
            if (openParenToken.Kind != SyntaxKind.OpenParenToken) throw new ArgumentException(nameof(openParenToken));
            if (closeParenToken == null) throw new ArgumentNullException(nameof(closeParenToken));
            if (closeParenToken.Kind != SyntaxKind.CloseParenToken) throw new ArgumentException(nameof(closeParenToken));
#endif

            int hash;
            var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.TupleExpression, openParenToken, arguments.Node, closeParenToken, out hash);
            if (cached != null) return (TupleExpressionSyntax)cached;

            var result = new TupleExpressionSyntax(SyntaxKind.TupleExpression, openParenToken, arguments.Node, closeParenToken);
            if (hash >= 0)
            {
                SyntaxNodeCache.AddNode(result, hash);
            }

            return result;
        }

        public static PrefixUnaryExpressionSyntax PrefixUnaryExpression(SyntaxKind kind, SyntaxToken operatorToken, ExpressionSyntax operand)
        {
            switch (kind)
            {
                case SyntaxKind.UnaryPlusExpression:
                case SyntaxKind.UnaryMinusExpression:
                case SyntaxKind.BitwiseNotExpression:
                case SyntaxKind.LogicalNotExpression:
                case SyntaxKind.PreIncrementExpression:
                case SyntaxKind.PreDecrementExpression:
                case SyntaxKind.AddressOfExpression:
                case SyntaxKind.PointerIndirectionExpression:
                case SyntaxKind.IndexExpression: break;
                default: throw new ArgumentException(nameof(kind));
            }
#if DEBUG
            if (operatorToken == null) throw new ArgumentNullException(nameof(operatorToken));
            switch (operatorToken.Kind)
            {
                case SyntaxKind.PlusToken:
                case SyntaxKind.MinusToken:
                case SyntaxKind.TildeToken:
                case SyntaxKind.ExclamationToken:
                case SyntaxKind.PlusPlusToken:
                case SyntaxKind.MinusMinusToken:
                case SyntaxKind.AmpersandToken:
                case SyntaxKind.AsteriskToken:
                case SyntaxKind.CaretToken: break;
                default: throw new ArgumentException(nameof(operatorToken));
            }
            if (operand == null) throw new ArgumentNullException(nameof(operand));
#endif

            int hash;
            var cached = SyntaxNodeCache.TryGetNode((int)kind, operatorToken, operand, out hash);
            if (cached != null) return (PrefixUnaryExpressionSyntax)cached;

            var result = new PrefixUnaryExpressionSyntax(kind, operatorToken, operand);
            if (hash >= 0)
            {
                SyntaxNodeCache.AddNode(result, hash);
            }

            return result;
        }

        public static AwaitExpressionSyntax AwaitExpression(SyntaxToken awaitKeyword, ExpressionSyntax expression)
        {
#if DEBUG
            if (awaitKeyword == null) throw new ArgumentNullException(nameof(awaitKeyword));
            if (awaitKeyword.Kind != SyntaxKind.AwaitKeyword) throw new ArgumentException(nameof(awaitKeyword));
            if (expression == null) throw new ArgumentNullException(nameof(expression));
#endif

            int hash;
            var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.AwaitExpression, awaitKeyword, expression, out hash);
            if (cached != null) return (AwaitExpressionSyntax)cached;

            var result = new AwaitExpressionSyntax(SyntaxKind.AwaitExpression, awaitKeyword, expression);
            if (hash >= 0)
            {
                SyntaxNodeCache.AddNode(result, hash);
            }

            return result;
        }

        public static PostfixUnaryExpressionSyntax PostfixUnaryExpression(SyntaxKind kind, ExpressionSyntax operand, SyntaxToken operatorToken)
        {
            switch (kind)
            {
                case SyntaxKind.PostIncrementExpression:
                case SyntaxKind.PostDecrementExpression:
                case SyntaxKind.SuppressNullableWarningExpression: break;
                default: throw new ArgumentException(nameof(kind));
            }
#if DEBUG
            if (operand == null) throw new ArgumentNullException(nameof(operand));
            if (operatorToken == null) throw new ArgumentNullException(nameof(operatorToken));
            switch (operatorToken.Kind)
            {
                case SyntaxKind.PlusPlusToken:
                case SyntaxKind.MinusMinusToken:
                case SyntaxKind.ExclamationToken: break;
                default: throw new ArgumentException(nameof(operatorToken));
            }
#endif

            int hash;
            var cached = SyntaxNodeCache.TryGetNode((int)kind, operand, operatorToken, out hash);
            if (cached != null) return (PostfixUnaryExpressionSyntax)cached;

            var result = new PostfixUnaryExpressionSyntax(kind, operand, operatorToken);
            if (hash >= 0)
            {
                SyntaxNodeCache.AddNode(result, hash);
            }

            return result;
        }

        public static MemberAccessExpressionSyntax MemberAccessExpression(SyntaxKind kind, ExpressionSyntax expression, SyntaxToken operatorToken, SimpleNameSyntax name)
        {
            switch (kind)
            {
                case SyntaxKind.SimpleMemberAccessExpression:
                case SyntaxKind.PointerMemberAccessExpression: break;
                default: throw new ArgumentException(nameof(kind));
            }
#if DEBUG
            if (expression == null) throw new ArgumentNullException(nameof(expression));
            if (operatorToken == null) throw new ArgumentNullException(nameof(operatorToken));
            switch (operatorToken.Kind)
            {
                case SyntaxKind.DotToken:
                case SyntaxKind.MinusGreaterThanToken: break;
                default: throw new ArgumentException(nameof(operatorToken));
            }
            if (name == null) throw new ArgumentNullException(nameof(name));
#endif

            int hash;
            var cached = SyntaxNodeCache.TryGetNode((int)kind, expression, operatorToken, name, out hash);
            if (cached != null) return (MemberAccessExpressionSyntax)cached;

            var result = new MemberAccessExpressionSyntax(kind, expression, operatorToken, name);
            if (hash >= 0)
            {
                SyntaxNodeCache.AddNode(result, hash);
            }

            return result;
        }

        public static ConditionalAccessExpressionSyntax ConditionalAccessExpression(ExpressionSyntax expression, SyntaxToken operatorToken, ExpressionSyntax whenNotNull)
        {
#if DEBUG
            if (expression == null) throw new ArgumentNullException(nameof(expression));
            if (operatorToken == null) throw new ArgumentNullException(nameof(operatorToken));
            if (operatorToken.Kind != SyntaxKind.QuestionToken) throw new ArgumentException(nameof(operatorToken));
            if (whenNotNull == null) throw new ArgumentNullException(nameof(whenNotNull));
#endif

            int hash;
            var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.ConditionalAccessExpression, expression, operatorToken, whenNotNull, out hash);
            if (cached != null) return (ConditionalAccessExpressionSyntax)cached;

            var result = new ConditionalAccessExpressionSyntax(SyntaxKind.ConditionalAccessExpression, expression, operatorToken, whenNotNull);
            if (hash >= 0)
            {
                SyntaxNodeCache.AddNode(result, hash);
            }

            return result;
        }

        public static MemberBindingExpressionSyntax MemberBindingExpression(SyntaxToken operatorToken, SimpleNameSyntax name)
        {
#if DEBUG
            if (operatorToken == null) throw new ArgumentNullException(nameof(operatorToken));
            if (operatorToken.Kind != SyntaxKind.DotToken) throw new ArgumentException(nameof(operatorToken));
            if (name == null) throw new ArgumentNullException(nameof(name));
#endif

            int hash;
            var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.MemberBindingExpression, operatorToken, name, out hash);
            if (cached != null) return (MemberBindingExpressionSyntax)cached;

            var result = new MemberBindingExpressionSyntax(SyntaxKind.MemberBindingExpression, operatorToken, name);
            if (hash >= 0)
            {
                SyntaxNodeCache.AddNode(result, hash);
            }

            return result;
        }

        public static ElementBindingExpressionSyntax ElementBindingExpression(BracketedArgumentListSyntax argumentList)
        {
#if DEBUG
            if (argumentList == null) throw new ArgumentNullException(nameof(argumentList));
#endif

            int hash;
            var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.ElementBindingExpression, argumentList, out hash);
            if (cached != null) return (ElementBindingExpressionSyntax)cached;

            var result = new ElementBindingExpressionSyntax(SyntaxKind.ElementBindingExpression, argumentList);
            if (hash >= 0)
            {
                SyntaxNodeCache.AddNode(result, hash);
            }

            return result;
        }

        public static RangeExpressionSyntax RangeExpression(ExpressionSyntax? leftOperand, SyntaxToken operatorToken, ExpressionSyntax? rightOperand)
        {
#if DEBUG
            if (operatorToken == null) throw new ArgumentNullException(nameof(operatorToken));
            if (operatorToken.Kind != SyntaxKind.DotDotToken) throw new ArgumentException(nameof(operatorToken));
#endif

            int hash;
            var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.RangeExpression, leftOperand, operatorToken, rightOperand, out hash);
            if (cached != null) return (RangeExpressionSyntax)cached;

            var result = new RangeExpressionSyntax(SyntaxKind.RangeExpression, leftOperand, operatorToken, rightOperand);
            if (hash >= 0)
            {
                SyntaxNodeCache.AddNode(result, hash);
            }

            return result;
        }

        public static ImplicitElementAccessSyntax ImplicitElementAccess(BracketedArgumentListSyntax argumentList)
        {
#if DEBUG
            if (argumentList == null) throw new ArgumentNullException(nameof(argumentList));
#endif

            int hash;
            var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.ImplicitElementAccess, argumentList, out hash);
            if (cached != null) return (ImplicitElementAccessSyntax)cached;

            var result = new ImplicitElementAccessSyntax(SyntaxKind.ImplicitElementAccess, argumentList);
            if (hash >= 0)
            {
                SyntaxNodeCache.AddNode(result, hash);
            }

            return result;
        }

        public static BinaryExpressionSyntax BinaryExpression(SyntaxKind kind, ExpressionSyntax left, SyntaxToken operatorToken, ExpressionSyntax right)
        {
            switch (kind)
            {
                case SyntaxKind.AddExpression:
                case SyntaxKind.SubtractExpression:
                case SyntaxKind.MultiplyExpression:
                case SyntaxKind.DivideExpression:
                case SyntaxKind.ModuloExpression:
                case SyntaxKind.LeftShiftExpression:
                case SyntaxKind.RightShiftExpression:
                case SyntaxKind.LogicalOrExpression:
                case SyntaxKind.LogicalAndExpression:
                case SyntaxKind.BitwiseOrExpression:
                case SyntaxKind.BitwiseAndExpression:
                case SyntaxKind.ExclusiveOrExpression:
                case SyntaxKind.EqualsExpression:
                case SyntaxKind.NotEqualsExpression:
                case SyntaxKind.LessThanExpression:
                case SyntaxKind.LessThanOrEqualExpression:
                case SyntaxKind.GreaterThanExpression:
                case SyntaxKind.GreaterThanOrEqualExpression:
                case SyntaxKind.IsExpression:
                case SyntaxKind.AsExpression:
                case SyntaxKind.CoalesceExpression: break;
                default: throw new ArgumentException(nameof(kind));
            }
#if DEBUG
            if (left == null) throw new ArgumentNullException(nameof(left));
            if (operatorToken == null) throw new ArgumentNullException(nameof(operatorToken));
            switch (operatorToken.Kind)
            {
                case SyntaxKind.PlusToken:
                case SyntaxKind.MinusToken:
                case SyntaxKind.AsteriskToken:
                case SyntaxKind.SlashToken:
                case SyntaxKind.PercentToken:
                case SyntaxKind.LessThanLessThanToken:
                case SyntaxKind.GreaterThanGreaterThanToken:
                case SyntaxKind.BarBarToken:
                case SyntaxKind.AmpersandAmpersandToken:
                case SyntaxKind.BarToken:
                case SyntaxKind.AmpersandToken:
                case SyntaxKind.CaretToken:
                case SyntaxKind.EqualsEqualsToken:
                case SyntaxKind.ExclamationEqualsToken:
                case SyntaxKind.LessThanToken:
                case SyntaxKind.LessThanEqualsToken:
                case SyntaxKind.GreaterThanToken:
                case SyntaxKind.GreaterThanEqualsToken:
                case SyntaxKind.IsKeyword:
                case SyntaxKind.AsKeyword:
                case SyntaxKind.QuestionQuestionToken: break;
                default: throw new ArgumentException(nameof(operatorToken));
            }
            if (right == null) throw new ArgumentNullException(nameof(right));
#endif

            int hash;
            var cached = SyntaxNodeCache.TryGetNode((int)kind, left, operatorToken, right, out hash);
            if (cached != null) return (BinaryExpressionSyntax)cached;

            var result = new BinaryExpressionSyntax(kind, left, operatorToken, right);
            if (hash >= 0)
            {
                SyntaxNodeCache.AddNode(result, hash);
            }

            return result;
        }

        public static AssignmentExpressionSyntax AssignmentExpression(SyntaxKind kind, ExpressionSyntax left, SyntaxToken operatorToken, ExpressionSyntax right)
        {
            switch (kind)
            {
                case SyntaxKind.SimpleAssignmentExpression:
                case SyntaxKind.AddAssignmentExpression:
                case SyntaxKind.SubtractAssignmentExpression:
                case SyntaxKind.MultiplyAssignmentExpression:
                case SyntaxKind.DivideAssignmentExpression:
                case SyntaxKind.ModuloAssignmentExpression:
                case SyntaxKind.AndAssignmentExpression:
                case SyntaxKind.ExclusiveOrAssignmentExpression:
                case SyntaxKind.OrAssignmentExpression:
                case SyntaxKind.LeftShiftAssignmentExpression:
                case SyntaxKind.RightShiftAssignmentExpression:
                case SyntaxKind.CoalesceAssignmentExpression: break;
                default: throw new ArgumentException(nameof(kind));
            }
#if DEBUG
            if (left == null) throw new ArgumentNullException(nameof(left));
            if (operatorToken == null) throw new ArgumentNullException(nameof(operatorToken));
            switch (operatorToken.Kind)
            {
                case SyntaxKind.EqualsToken:
                case SyntaxKind.PlusEqualsToken:
                case SyntaxKind.MinusEqualsToken:
                case SyntaxKind.AsteriskEqualsToken:
                case SyntaxKind.SlashEqualsToken:
                case SyntaxKind.PercentEqualsToken:
                case SyntaxKind.AmpersandEqualsToken:
                case SyntaxKind.CaretEqualsToken:
                case SyntaxKind.BarEqualsToken:
                case SyntaxKind.LessThanLessThanEqualsToken:
                case SyntaxKind.GreaterThanGreaterThanEqualsToken:
                case SyntaxKind.QuestionQuestionEqualsToken: break;
                default: throw new ArgumentException(nameof(operatorToken));
            }
            if (right == null) throw new ArgumentNullException(nameof(right));
#endif

            int hash;
            var cached = SyntaxNodeCache.TryGetNode((int)kind, left, operatorToken, right, out hash);
            if (cached != null) return (AssignmentExpressionSyntax)cached;

            var result = new AssignmentExpressionSyntax(kind, left, operatorToken, right);
            if (hash >= 0)
            {
                SyntaxNodeCache.AddNode(result, hash);
            }

            return result;
        }

        public static ConditionalExpressionSyntax ConditionalExpression(ExpressionSyntax condition, SyntaxToken questionToken, ExpressionSyntax whenTrue, SyntaxToken colonToken, ExpressionSyntax whenFalse)
        {
#if DEBUG
            if (condition == null) throw new ArgumentNullException(nameof(condition));
            if (questionToken == null) throw new ArgumentNullException(nameof(questionToken));
            if (questionToken.Kind != SyntaxKind.QuestionToken) throw new ArgumentException(nameof(questionToken));
            if (whenTrue == null) throw new ArgumentNullException(nameof(whenTrue));
            if (colonToken == null) throw new ArgumentNullException(nameof(colonToken));
            if (colonToken.Kind != SyntaxKind.ColonToken) throw new ArgumentException(nameof(colonToken));
            if (whenFalse == null) throw new ArgumentNullException(nameof(whenFalse));
#endif

            return new ConditionalExpressionSyntax(SyntaxKind.ConditionalExpression, condition, questionToken, whenTrue, colonToken, whenFalse);
        }

        public static ThisExpressionSyntax ThisExpression(SyntaxToken token)
        {
#if DEBUG
            if (token == null) throw new ArgumentNullException(nameof(token));
            if (token.Kind != SyntaxKind.ThisKeyword) throw new ArgumentException(nameof(token));
#endif

            int hash;
            var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.ThisExpression, token, out hash);
            if (cached != null) return (ThisExpressionSyntax)cached;

            var result = new ThisExpressionSyntax(SyntaxKind.ThisExpression, token);
            if (hash >= 0)
            {
                SyntaxNodeCache.AddNode(result, hash);
            }

            return result;
        }

        public static BaseExpressionSyntax BaseExpression(SyntaxToken token)
        {
#if DEBUG
            if (token == null) throw new ArgumentNullException(nameof(token));
            if (token.Kind != SyntaxKind.BaseKeyword) throw new ArgumentException(nameof(token));
#endif

            int hash;
            var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.BaseExpression, token, out hash);
            if (cached != null) return (BaseExpressionSyntax)cached;

            var result = new BaseExpressionSyntax(SyntaxKind.BaseExpression, token);
            if (hash >= 0)
            {
                SyntaxNodeCache.AddNode(result, hash);
            }

            return result;
        }

        public static LiteralExpressionSyntax LiteralExpression(SyntaxKind kind, SyntaxToken token)
        {
            switch (kind)
            {
                case SyntaxKind.ArgListExpression:
                case SyntaxKind.NumericLiteralExpression:
                case SyntaxKind.StringLiteralExpression:
                case SyntaxKind.CharacterLiteralExpression:
                case SyntaxKind.TrueLiteralExpression:
                case SyntaxKind.FalseLiteralExpression:
                case SyntaxKind.NullLiteralExpression:
                case SyntaxKind.DefaultLiteralExpression: break;
                default: throw new ArgumentException(nameof(kind));
            }
#if DEBUG
            if (token == null) throw new ArgumentNullException(nameof(token));
            switch (token.Kind)
            {
                case SyntaxKind.ArgListKeyword:
                case SyntaxKind.NumericLiteralToken:
                case SyntaxKind.StringLiteralToken:
                case SyntaxKind.CharacterLiteralToken:
                case SyntaxKind.TrueKeyword:
                case SyntaxKind.FalseKeyword:
                case SyntaxKind.NullKeyword:
                case SyntaxKind.DefaultKeyword: break;
                default: throw new ArgumentException(nameof(token));
            }
#endif

            int hash;
            var cached = SyntaxNodeCache.TryGetNode((int)kind, token, out hash);
            if (cached != null) return (LiteralExpressionSyntax)cached;

            var result = new LiteralExpressionSyntax(kind, token);
            if (hash >= 0)
            {
                SyntaxNodeCache.AddNode(result, hash);
            }

            return result;
        }

        public static MakeRefExpressionSyntax MakeRefExpression(SyntaxToken keyword, SyntaxToken openParenToken, ExpressionSyntax expression, SyntaxToken closeParenToken)
        {
#if DEBUG
            if (keyword == null) throw new ArgumentNullException(nameof(keyword));
            if (keyword.Kind != SyntaxKind.MakeRefKeyword) throw new ArgumentException(nameof(keyword));
            if (openParenToken == null) throw new ArgumentNullException(nameof(openParenToken));
            if (openParenToken.Kind != SyntaxKind.OpenParenToken) throw new ArgumentException(nameof(openParenToken));
            if (expression == null) throw new ArgumentNullException(nameof(expression));
            if (closeParenToken == null) throw new ArgumentNullException(nameof(closeParenToken));
            if (closeParenToken.Kind != SyntaxKind.CloseParenToken) throw new ArgumentException(nameof(closeParenToken));
#endif

            return new MakeRefExpressionSyntax(SyntaxKind.MakeRefExpression, keyword, openParenToken, expression, closeParenToken);
        }

        public static RefTypeExpressionSyntax RefTypeExpression(SyntaxToken keyword, SyntaxToken openParenToken, ExpressionSyntax expression, SyntaxToken closeParenToken)
        {
#if DEBUG
            if (keyword == null) throw new ArgumentNullException(nameof(keyword));
            if (keyword.Kind != SyntaxKind.RefTypeKeyword) throw new ArgumentException(nameof(keyword));
            if (openParenToken == null) throw new ArgumentNullException(nameof(openParenToken));
            if (openParenToken.Kind != SyntaxKind.OpenParenToken) throw new ArgumentException(nameof(openParenToken));
            if (expression == null) throw new ArgumentNullException(nameof(expression));
            if (closeParenToken == null) throw new ArgumentNullException(nameof(closeParenToken));
            if (closeParenToken.Kind != SyntaxKind.CloseParenToken) throw new ArgumentException(nameof(closeParenToken));
#endif

            return new RefTypeExpressionSyntax(SyntaxKind.RefTypeExpression, keyword, openParenToken, expression, closeParenToken);
        }

        public static RefValueExpressionSyntax RefValueExpression(SyntaxToken keyword, SyntaxToken openParenToken, ExpressionSyntax expression, SyntaxToken comma, TypeSyntax type, SyntaxToken closeParenToken)
        {
#if DEBUG
            if (keyword == null) throw new ArgumentNullException(nameof(keyword));
            if (keyword.Kind != SyntaxKind.RefValueKeyword) throw new ArgumentException(nameof(keyword));
            if (openParenToken == null) throw new ArgumentNullException(nameof(openParenToken));
            if (openParenToken.Kind != SyntaxKind.OpenParenToken) throw new ArgumentException(nameof(openParenToken));
            if (expression == null) throw new ArgumentNullException(nameof(expression));
            if (comma == null) throw new ArgumentNullException(nameof(comma));
            if (comma.Kind != SyntaxKind.CommaToken) throw new ArgumentException(nameof(comma));
            if (type == null) throw new ArgumentNullException(nameof(type));
            if (closeParenToken == null) throw new ArgumentNullException(nameof(closeParenToken));
            if (closeParenToken.Kind != SyntaxKind.CloseParenToken) throw new ArgumentException(nameof(closeParenToken));
#endif

            return new RefValueExpressionSyntax(SyntaxKind.RefValueExpression, keyword, openParenToken, expression, comma, type, closeParenToken);
        }

        public static CheckedExpressionSyntax CheckedExpression(SyntaxKind kind, SyntaxToken keyword, SyntaxToken openParenToken, ExpressionSyntax expression, SyntaxToken closeParenToken)
        {
            switch (kind)
            {
                case SyntaxKind.CheckedExpression:
                case SyntaxKind.UncheckedExpression: break;
                default: throw new ArgumentException(nameof(kind));
            }
#if DEBUG
            if (keyword == null) throw new ArgumentNullException(nameof(keyword));
            switch (keyword.Kind)
            {
                case SyntaxKind.CheckedKeyword:
                case SyntaxKind.UncheckedKeyword: break;
                default: throw new ArgumentException(nameof(keyword));
            }
            if (openParenToken == null) throw new ArgumentNullException(nameof(openParenToken));
            if (openParenToken.Kind != SyntaxKind.OpenParenToken) throw new ArgumentException(nameof(openParenToken));
            if (expression == null) throw new ArgumentNullException(nameof(expression));
            if (closeParenToken == null) throw new ArgumentNullException(nameof(closeParenToken));
            if (closeParenToken.Kind != SyntaxKind.CloseParenToken) throw new ArgumentException(nameof(closeParenToken));
#endif

            return new CheckedExpressionSyntax(kind, keyword, openParenToken, expression, closeParenToken);
        }

        public static DefaultExpressionSyntax DefaultExpression(SyntaxToken keyword, SyntaxToken openParenToken, TypeSyntax type, SyntaxToken closeParenToken)
        {
#if DEBUG
            if (keyword == null) throw new ArgumentNullException(nameof(keyword));
            if (keyword.Kind != SyntaxKind.DefaultKeyword) throw new ArgumentException(nameof(keyword));
            if (openParenToken == null) throw new ArgumentNullException(nameof(openParenToken));
            if (openParenToken.Kind != SyntaxKind.OpenParenToken) throw new ArgumentException(nameof(openParenToken));
            if (type == null) throw new ArgumentNullException(nameof(type));
            if (closeParenToken == null) throw new ArgumentNullException(nameof(closeParenToken));
            if (closeParenToken.Kind != SyntaxKind.CloseParenToken) throw new ArgumentException(nameof(closeParenToken));
#endif

            return new DefaultExpressionSyntax(SyntaxKind.DefaultExpression, keyword, openParenToken, type, closeParenToken);
        }

        public static TypeOfExpressionSyntax TypeOfExpression(SyntaxToken keyword, SyntaxToken openParenToken, TypeSyntax type, SyntaxToken closeParenToken)
        {
#if DEBUG
            if (keyword == null) throw new ArgumentNullException(nameof(keyword));
            if (keyword.Kind != SyntaxKind.TypeOfKeyword) throw new ArgumentException(nameof(keyword));
            if (openParenToken == null) throw new ArgumentNullException(nameof(openParenToken));
            if (openParenToken.Kind != SyntaxKind.OpenParenToken) throw new ArgumentException(nameof(openParenToken));
            if (type == null) throw new ArgumentNullException(nameof(type));
            if (closeParenToken == null) throw new ArgumentNullException(nameof(closeParenToken));
            if (closeParenToken.Kind != SyntaxKind.CloseParenToken) throw new ArgumentException(nameof(closeParenToken));
#endif

            return new TypeOfExpressionSyntax(SyntaxKind.TypeOfExpression, keyword, openParenToken, type, closeParenToken);
        }

        public static SizeOfExpressionSyntax SizeOfExpression(SyntaxToken keyword, SyntaxToken openParenToken, TypeSyntax type, SyntaxToken closeParenToken)
        {
#if DEBUG
            if (keyword == null) throw new ArgumentNullException(nameof(keyword));
            if (keyword.Kind != SyntaxKind.SizeOfKeyword) throw new ArgumentException(nameof(keyword));
            if (openParenToken == null) throw new ArgumentNullException(nameof(openParenToken));
            if (openParenToken.Kind != SyntaxKind.OpenParenToken) throw new ArgumentException(nameof(openParenToken));
            if (type == null) throw new ArgumentNullException(nameof(type));
            if (closeParenToken == null) throw new ArgumentNullException(nameof(closeParenToken));
            if (closeParenToken.Kind != SyntaxKind.CloseParenToken) throw new ArgumentException(nameof(closeParenToken));
#endif

            return new SizeOfExpressionSyntax(SyntaxKind.SizeOfExpression, keyword, openParenToken, type, closeParenToken);
        }

        public static InvocationExpressionSyntax InvocationExpression(ExpressionSyntax expression, ArgumentListSyntax argumentList)
        {
#if DEBUG
            if (expression == null) throw new ArgumentNullException(nameof(expression));
            if (argumentList == null) throw new ArgumentNullException(nameof(argumentList));
#endif

            int hash;
            var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.InvocationExpression, expression, argumentList, out hash);
            if (cached != null) return (InvocationExpressionSyntax)cached;

            var result = new InvocationExpressionSyntax(SyntaxKind.InvocationExpression, expression, argumentList);
            if (hash >= 0)
            {
                SyntaxNodeCache.AddNode(result, hash);
            }

            return result;
        }

        public static ElementAccessExpressionSyntax ElementAccessExpression(ExpressionSyntax expression, BracketedArgumentListSyntax argumentList)
        {
#if DEBUG
            if (expression == null) throw new ArgumentNullException(nameof(expression));
            if (argumentList == null) throw new ArgumentNullException(nameof(argumentList));
#endif

            int hash;
            var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.ElementAccessExpression, expression, argumentList, out hash);
            if (cached != null) return (ElementAccessExpressionSyntax)cached;

            var result = new ElementAccessExpressionSyntax(SyntaxKind.ElementAccessExpression, expression, argumentList);
            if (hash >= 0)
            {
                SyntaxNodeCache.AddNode(result, hash);
            }

            return result;
        }

        public static ArgumentListSyntax ArgumentList(SyntaxToken openParenToken, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<ArgumentSyntax> arguments, SyntaxToken closeParenToken)
        {
#if DEBUG
            if (openParenToken == null) throw new ArgumentNullException(nameof(openParenToken));
            if (openParenToken.Kind != SyntaxKind.OpenParenToken) throw new ArgumentException(nameof(openParenToken));
            if (closeParenToken == null) throw new ArgumentNullException(nameof(closeParenToken));
            if (closeParenToken.Kind != SyntaxKind.CloseParenToken) throw new ArgumentException(nameof(closeParenToken));
#endif

            int hash;
            var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.ArgumentList, openParenToken, arguments.Node, closeParenToken, out hash);
            if (cached != null) return (ArgumentListSyntax)cached;

            var result = new ArgumentListSyntax(SyntaxKind.ArgumentList, openParenToken, arguments.Node, closeParenToken);
            if (hash >= 0)
            {
                SyntaxNodeCache.AddNode(result, hash);
            }

            return result;
        }

        public static BracketedArgumentListSyntax BracketedArgumentList(SyntaxToken openBracketToken, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<ArgumentSyntax> arguments, SyntaxToken closeBracketToken)
        {
#if DEBUG
            if (openBracketToken == null) throw new ArgumentNullException(nameof(openBracketToken));
            if (openBracketToken.Kind != SyntaxKind.OpenBracketToken) throw new ArgumentException(nameof(openBracketToken));
            if (closeBracketToken == null) throw new ArgumentNullException(nameof(closeBracketToken));
            if (closeBracketToken.Kind != SyntaxKind.CloseBracketToken) throw new ArgumentException(nameof(closeBracketToken));
#endif

            int hash;
            var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.BracketedArgumentList, openBracketToken, arguments.Node, closeBracketToken, out hash);
            if (cached != null) return (BracketedArgumentListSyntax)cached;

            var result = new BracketedArgumentListSyntax(SyntaxKind.BracketedArgumentList, openBracketToken, arguments.Node, closeBracketToken);
            if (hash >= 0)
            {
                SyntaxNodeCache.AddNode(result, hash);
            }

            return result;
        }

        public static ArgumentSyntax Argument(NameColonSyntax? nameColon, SyntaxToken? refKindKeyword, ExpressionSyntax expression)
        {
#if DEBUG
            if (refKindKeyword != null)
            {
                switch (refKindKeyword.Kind)
                {
                    case SyntaxKind.RefKeyword:
                    case SyntaxKind.OutKeyword:
                    case SyntaxKind.InKeyword:
                    case SyntaxKind.None: break;
                    default: throw new ArgumentException(nameof(refKindKeyword));
                }
            }
            if (expression == null) throw new ArgumentNullException(nameof(expression));
#endif

            int hash;
            var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.Argument, nameColon, refKindKeyword, expression, out hash);
            if (cached != null) return (ArgumentSyntax)cached;

            var result = new ArgumentSyntax(SyntaxKind.Argument, nameColon, refKindKeyword, expression);
            if (hash >= 0)
            {
                SyntaxNodeCache.AddNode(result, hash);
            }

            return result;
        }

        public static NameColonSyntax NameColon(IdentifierNameSyntax name, SyntaxToken colonToken)
        {
#if DEBUG
            if (name == null) throw new ArgumentNullException(nameof(name));
            if (colonToken == null) throw new ArgumentNullException(nameof(colonToken));
            if (colonToken.Kind != SyntaxKind.ColonToken) throw new ArgumentException(nameof(colonToken));
#endif

            int hash;
            var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.NameColon, name, colonToken, out hash);
            if (cached != null) return (NameColonSyntax)cached;

            var result = new NameColonSyntax(SyntaxKind.NameColon, name, colonToken);
            if (hash >= 0)
            {
                SyntaxNodeCache.AddNode(result, hash);
            }

            return result;
        }

        public static DeclarationExpressionSyntax DeclarationExpression(TypeSyntax type, VariableDesignationSyntax designation)
        {
#if DEBUG
            if (type == null) throw new ArgumentNullException(nameof(type));
            if (designation == null) throw new ArgumentNullException(nameof(designation));
#endif

            int hash;
            var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.DeclarationExpression, type, designation, out hash);
            if (cached != null) return (DeclarationExpressionSyntax)cached;

            var result = new DeclarationExpressionSyntax(SyntaxKind.DeclarationExpression, type, designation);
            if (hash >= 0)
            {
                SyntaxNodeCache.AddNode(result, hash);
            }

            return result;
        }

        public static CastExpressionSyntax CastExpression(SyntaxToken openParenToken, TypeSyntax type, SyntaxToken closeParenToken, ExpressionSyntax expression)
        {
#if DEBUG
            if (openParenToken == null) throw new ArgumentNullException(nameof(openParenToken));
            if (openParenToken.Kind != SyntaxKind.OpenParenToken) throw new ArgumentException(nameof(openParenToken));
            if (type == null) throw new ArgumentNullException(nameof(type));
            if (closeParenToken == null) throw new ArgumentNullException(nameof(closeParenToken));
            if (closeParenToken.Kind != SyntaxKind.CloseParenToken) throw new ArgumentException(nameof(closeParenToken));
            if (expression == null) throw new ArgumentNullException(nameof(expression));
#endif

            return new CastExpressionSyntax(SyntaxKind.CastExpression, openParenToken, type, closeParenToken, expression);
        }

        public static AnonymousMethodExpressionSyntax AnonymousMethodExpression(Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SyntaxToken> modifiers, SyntaxToken delegateKeyword, ParameterListSyntax? parameterList, BlockSyntax block, ExpressionSyntax? expressionBody)
        {
#if DEBUG
            if (delegateKeyword == null) throw new ArgumentNullException(nameof(delegateKeyword));
            if (delegateKeyword.Kind != SyntaxKind.DelegateKeyword) throw new ArgumentException(nameof(delegateKeyword));
            if (block == null) throw new ArgumentNullException(nameof(block));
#endif

            return new AnonymousMethodExpressionSyntax(SyntaxKind.AnonymousMethodExpression, modifiers.Node, delegateKeyword, parameterList, block, expressionBody);
        }

        public static SimpleLambdaExpressionSyntax SimpleLambdaExpression(Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SyntaxToken> modifiers, ParameterSyntax parameter, SyntaxToken arrowToken, BlockSyntax? block, ExpressionSyntax? expressionBody)
        {
#if DEBUG
            if (parameter == null) throw new ArgumentNullException(nameof(parameter));
            if (arrowToken == null) throw new ArgumentNullException(nameof(arrowToken));
            if (arrowToken.Kind != SyntaxKind.EqualsGreaterThanToken) throw new ArgumentException(nameof(arrowToken));
#endif

            return new SimpleLambdaExpressionSyntax(SyntaxKind.SimpleLambdaExpression, modifiers.Node, parameter, arrowToken, block, expressionBody);
        }

        public static RefExpressionSyntax RefExpression(SyntaxToken refKeyword, ExpressionSyntax expression)
        {
#if DEBUG
            if (refKeyword == null) throw new ArgumentNullException(nameof(refKeyword));
            if (refKeyword.Kind != SyntaxKind.RefKeyword) throw new ArgumentException(nameof(refKeyword));
            if (expression == null) throw new ArgumentNullException(nameof(expression));
#endif

            int hash;
            var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.RefExpression, refKeyword, expression, out hash);
            if (cached != null) return (RefExpressionSyntax)cached;

            var result = new RefExpressionSyntax(SyntaxKind.RefExpression, refKeyword, expression);
            if (hash >= 0)
            {
                SyntaxNodeCache.AddNode(result, hash);
            }

            return result;
        }

        public static ParenthesizedLambdaExpressionSyntax ParenthesizedLambdaExpression(Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SyntaxToken> modifiers, ParameterListSyntax parameterList, SyntaxToken arrowToken, BlockSyntax? block, ExpressionSyntax? expressionBody)
        {
#if DEBUG
            if (parameterList == null) throw new ArgumentNullException(nameof(parameterList));
            if (arrowToken == null) throw new ArgumentNullException(nameof(arrowToken));
            if (arrowToken.Kind != SyntaxKind.EqualsGreaterThanToken) throw new ArgumentException(nameof(arrowToken));
#endif

            return new ParenthesizedLambdaExpressionSyntax(SyntaxKind.ParenthesizedLambdaExpression, modifiers.Node, parameterList, arrowToken, block, expressionBody);
        }

        public static InitializerExpressionSyntax InitializerExpression(SyntaxKind kind, SyntaxToken openBraceToken, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<ExpressionSyntax> expressions, SyntaxToken closeBraceToken)
        {
            switch (kind)
            {
                case SyntaxKind.ObjectInitializerExpression:
                case SyntaxKind.CollectionInitializerExpression:
                case SyntaxKind.ArrayInitializerExpression:
                case SyntaxKind.ComplexElementInitializerExpression:
                case SyntaxKind.WithInitializerExpression: break;
                default: throw new ArgumentException(nameof(kind));
            }
#if DEBUG
            if (openBraceToken == null) throw new ArgumentNullException(nameof(openBraceToken));
            if (openBraceToken.Kind != SyntaxKind.OpenBraceToken) throw new ArgumentException(nameof(openBraceToken));
            if (closeBraceToken == null) throw new ArgumentNullException(nameof(closeBraceToken));
            if (closeBraceToken.Kind != SyntaxKind.CloseBraceToken) throw new ArgumentException(nameof(closeBraceToken));
#endif

            int hash;
            var cached = SyntaxNodeCache.TryGetNode((int)kind, openBraceToken, expressions.Node, closeBraceToken, out hash);
            if (cached != null) return (InitializerExpressionSyntax)cached;

            var result = new InitializerExpressionSyntax(kind, openBraceToken, expressions.Node, closeBraceToken);
            if (hash >= 0)
            {
                SyntaxNodeCache.AddNode(result, hash);
            }

            return result;
        }

        public static ImplicitObjectCreationExpressionSyntax ImplicitObjectCreationExpression(SyntaxToken newKeyword, ArgumentListSyntax argumentList, InitializerExpressionSyntax? initializer)
        {
#if DEBUG
            if (newKeyword == null) throw new ArgumentNullException(nameof(newKeyword));
            if (newKeyword.Kind != SyntaxKind.NewKeyword) throw new ArgumentException(nameof(newKeyword));
            if (argumentList == null) throw new ArgumentNullException(nameof(argumentList));
#endif

            int hash;
            var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.ImplicitObjectCreationExpression, newKeyword, argumentList, initializer, out hash);
            if (cached != null) return (ImplicitObjectCreationExpressionSyntax)cached;

            var result = new ImplicitObjectCreationExpressionSyntax(SyntaxKind.ImplicitObjectCreationExpression, newKeyword, argumentList, initializer);
            if (hash >= 0)
            {
                SyntaxNodeCache.AddNode(result, hash);
            }

            return result;
        }

        public static ObjectCreationExpressionSyntax ObjectCreationExpression(SyntaxToken newKeyword, TypeSyntax type, ArgumentListSyntax? argumentList, InitializerExpressionSyntax? initializer)
        {
#if DEBUG
            if (newKeyword == null) throw new ArgumentNullException(nameof(newKeyword));
            if (newKeyword.Kind != SyntaxKind.NewKeyword) throw new ArgumentException(nameof(newKeyword));
            if (type == null) throw new ArgumentNullException(nameof(type));
#endif

            return new ObjectCreationExpressionSyntax(SyntaxKind.ObjectCreationExpression, newKeyword, type, argumentList, initializer);
        }

        public static WithExpressionSyntax WithExpression(ExpressionSyntax expression, SyntaxToken withKeyword, InitializerExpressionSyntax initializer)
        {
#if DEBUG
            if (expression == null) throw new ArgumentNullException(nameof(expression));
            if (withKeyword == null) throw new ArgumentNullException(nameof(withKeyword));
            if (withKeyword.Kind != SyntaxKind.WithKeyword) throw new ArgumentException(nameof(withKeyword));
            if (initializer == null) throw new ArgumentNullException(nameof(initializer));
#endif

            int hash;
            var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.WithExpression, expression, withKeyword, initializer, out hash);
            if (cached != null) return (WithExpressionSyntax)cached;

            var result = new WithExpressionSyntax(SyntaxKind.WithExpression, expression, withKeyword, initializer);
            if (hash >= 0)
            {
                SyntaxNodeCache.AddNode(result, hash);
            }

            return result;
        }

        public static AnonymousObjectMemberDeclaratorSyntax AnonymousObjectMemberDeclarator(NameEqualsSyntax? nameEquals, ExpressionSyntax expression)
        {
#if DEBUG
            if (expression == null) throw new ArgumentNullException(nameof(expression));
#endif

            int hash;
            var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.AnonymousObjectMemberDeclarator, nameEquals, expression, out hash);
            if (cached != null) return (AnonymousObjectMemberDeclaratorSyntax)cached;

            var result = new AnonymousObjectMemberDeclaratorSyntax(SyntaxKind.AnonymousObjectMemberDeclarator, nameEquals, expression);
            if (hash >= 0)
            {
                SyntaxNodeCache.AddNode(result, hash);
            }

            return result;
        }

        public static AnonymousObjectCreationExpressionSyntax AnonymousObjectCreationExpression(SyntaxToken newKeyword, SyntaxToken openBraceToken, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<AnonymousObjectMemberDeclaratorSyntax> initializers, SyntaxToken closeBraceToken)
        {
#if DEBUG
            if (newKeyword == null) throw new ArgumentNullException(nameof(newKeyword));
            if (newKeyword.Kind != SyntaxKind.NewKeyword) throw new ArgumentException(nameof(newKeyword));
            if (openBraceToken == null) throw new ArgumentNullException(nameof(openBraceToken));
            if (openBraceToken.Kind != SyntaxKind.OpenBraceToken) throw new ArgumentException(nameof(openBraceToken));
            if (closeBraceToken == null) throw new ArgumentNullException(nameof(closeBraceToken));
            if (closeBraceToken.Kind != SyntaxKind.CloseBraceToken) throw new ArgumentException(nameof(closeBraceToken));
#endif

            return new AnonymousObjectCreationExpressionSyntax(SyntaxKind.AnonymousObjectCreationExpression, newKeyword, openBraceToken, initializers.Node, closeBraceToken);
        }

        public static ArrayCreationExpressionSyntax ArrayCreationExpression(SyntaxToken newKeyword, ArrayTypeSyntax type, InitializerExpressionSyntax? initializer)
        {
#if DEBUG
            if (newKeyword == null) throw new ArgumentNullException(nameof(newKeyword));
            if (newKeyword.Kind != SyntaxKind.NewKeyword) throw new ArgumentException(nameof(newKeyword));
            if (type == null) throw new ArgumentNullException(nameof(type));
#endif

            int hash;
            var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.ArrayCreationExpression, newKeyword, type, initializer, out hash);
            if (cached != null) return (ArrayCreationExpressionSyntax)cached;

            var result = new ArrayCreationExpressionSyntax(SyntaxKind.ArrayCreationExpression, newKeyword, type, initializer);
            if (hash >= 0)
            {
                SyntaxNodeCache.AddNode(result, hash);
            }

            return result;
        }

        public static ImplicitArrayCreationExpressionSyntax ImplicitArrayCreationExpression(SyntaxToken newKeyword, SyntaxToken openBracketToken, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SyntaxToken> commas, SyntaxToken closeBracketToken, InitializerExpressionSyntax initializer)
        {
#if DEBUG
            if (newKeyword == null) throw new ArgumentNullException(nameof(newKeyword));
            if (newKeyword.Kind != SyntaxKind.NewKeyword) throw new ArgumentException(nameof(newKeyword));
            if (openBracketToken == null) throw new ArgumentNullException(nameof(openBracketToken));
            if (openBracketToken.Kind != SyntaxKind.OpenBracketToken) throw new ArgumentException(nameof(openBracketToken));
            if (closeBracketToken == null) throw new ArgumentNullException(nameof(closeBracketToken));
            if (closeBracketToken.Kind != SyntaxKind.CloseBracketToken) throw new ArgumentException(nameof(closeBracketToken));
            if (initializer == null) throw new ArgumentNullException(nameof(initializer));
#endif

            return new ImplicitArrayCreationExpressionSyntax(SyntaxKind.ImplicitArrayCreationExpression, newKeyword, openBracketToken, commas.Node, closeBracketToken, initializer);
        }

        public static StackAllocArrayCreationExpressionSyntax StackAllocArrayCreationExpression(SyntaxToken stackAllocKeyword, TypeSyntax type, InitializerExpressionSyntax? initializer)
        {
#if DEBUG
            if (stackAllocKeyword == null) throw new ArgumentNullException(nameof(stackAllocKeyword));
            if (stackAllocKeyword.Kind != SyntaxKind.StackAllocKeyword) throw new ArgumentException(nameof(stackAllocKeyword));
            if (type == null) throw new ArgumentNullException(nameof(type));
#endif

            int hash;
            var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.StackAllocArrayCreationExpression, stackAllocKeyword, type, initializer, out hash);
            if (cached != null) return (StackAllocArrayCreationExpressionSyntax)cached;

            var result = new StackAllocArrayCreationExpressionSyntax(SyntaxKind.StackAllocArrayCreationExpression, stackAllocKeyword, type, initializer);
            if (hash >= 0)
            {
                SyntaxNodeCache.AddNode(result, hash);
            }

            return result;
        }

        public static ImplicitStackAllocArrayCreationExpressionSyntax ImplicitStackAllocArrayCreationExpression(SyntaxToken stackAllocKeyword, SyntaxToken openBracketToken, SyntaxToken closeBracketToken, InitializerExpressionSyntax initializer)
        {
#if DEBUG
            if (stackAllocKeyword == null) throw new ArgumentNullException(nameof(stackAllocKeyword));
            if (stackAllocKeyword.Kind != SyntaxKind.StackAllocKeyword) throw new ArgumentException(nameof(stackAllocKeyword));
            if (openBracketToken == null) throw new ArgumentNullException(nameof(openBracketToken));
            if (openBracketToken.Kind != SyntaxKind.OpenBracketToken) throw new ArgumentException(nameof(openBracketToken));
            if (closeBracketToken == null) throw new ArgumentNullException(nameof(closeBracketToken));
            if (closeBracketToken.Kind != SyntaxKind.CloseBracketToken) throw new ArgumentException(nameof(closeBracketToken));
            if (initializer == null) throw new ArgumentNullException(nameof(initializer));
#endif

            return new ImplicitStackAllocArrayCreationExpressionSyntax(SyntaxKind.ImplicitStackAllocArrayCreationExpression, stackAllocKeyword, openBracketToken, closeBracketToken, initializer);
        }

        public static QueryExpressionSyntax QueryExpression(FromClauseSyntax fromClause, QueryBodySyntax body)
        {
#if DEBUG
            if (fromClause == null) throw new ArgumentNullException(nameof(fromClause));
            if (body == null) throw new ArgumentNullException(nameof(body));
#endif

            int hash;
            var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.QueryExpression, fromClause, body, out hash);
            if (cached != null) return (QueryExpressionSyntax)cached;

            var result = new QueryExpressionSyntax(SyntaxKind.QueryExpression, fromClause, body);
            if (hash >= 0)
            {
                SyntaxNodeCache.AddNode(result, hash);
            }

            return result;
        }

        public static QueryBodySyntax QueryBody(Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<QueryClauseSyntax> clauses, SelectOrGroupClauseSyntax selectOrGroup, QueryContinuationSyntax? continuation)
        {
#if DEBUG
            if (selectOrGroup == null) throw new ArgumentNullException(nameof(selectOrGroup));
#endif

            int hash;
            var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.QueryBody, clauses.Node, selectOrGroup, continuation, out hash);
            if (cached != null) return (QueryBodySyntax)cached;

            var result = new QueryBodySyntax(SyntaxKind.QueryBody, clauses.Node, selectOrGroup, continuation);
            if (hash >= 0)
            {
                SyntaxNodeCache.AddNode(result, hash);
            }

            return result;
        }

        public static FromClauseSyntax FromClause(SyntaxToken fromKeyword, TypeSyntax? type, SyntaxToken identifier, SyntaxToken inKeyword, ExpressionSyntax expression)
        {
#if DEBUG
            if (fromKeyword == null) throw new ArgumentNullException(nameof(fromKeyword));
            if (fromKeyword.Kind != SyntaxKind.FromKeyword) throw new ArgumentException(nameof(fromKeyword));
            if (identifier == null) throw new ArgumentNullException(nameof(identifier));
            if (identifier.Kind != SyntaxKind.IdentifierToken) throw new ArgumentException(nameof(identifier));
            if (inKeyword == null) throw new ArgumentNullException(nameof(inKeyword));
            if (inKeyword.Kind != SyntaxKind.InKeyword) throw new ArgumentException(nameof(inKeyword));
            if (expression == null) throw new ArgumentNullException(nameof(expression));
#endif

            return new FromClauseSyntax(SyntaxKind.FromClause, fromKeyword, type, identifier, inKeyword, expression);
        }

        public static LetClauseSyntax LetClause(SyntaxToken letKeyword, SyntaxToken identifier, SyntaxToken equalsToken, ExpressionSyntax expression)
        {
#if DEBUG
            if (letKeyword == null) throw new ArgumentNullException(nameof(letKeyword));
            if (letKeyword.Kind != SyntaxKind.LetKeyword) throw new ArgumentException(nameof(letKeyword));
            if (identifier == null) throw new ArgumentNullException(nameof(identifier));
            if (identifier.Kind != SyntaxKind.IdentifierToken) throw new ArgumentException(nameof(identifier));
            if (equalsToken == null) throw new ArgumentNullException(nameof(equalsToken));
            if (equalsToken.Kind != SyntaxKind.EqualsToken) throw new ArgumentException(nameof(equalsToken));
            if (expression == null) throw new ArgumentNullException(nameof(expression));
#endif

            return new LetClauseSyntax(SyntaxKind.LetClause, letKeyword, identifier, equalsToken, expression);
        }

        public static JoinClauseSyntax JoinClause(SyntaxToken joinKeyword, TypeSyntax? type, SyntaxToken identifier, SyntaxToken inKeyword, ExpressionSyntax inExpression, SyntaxToken onKeyword, ExpressionSyntax leftExpression, SyntaxToken equalsKeyword, ExpressionSyntax rightExpression, JoinIntoClauseSyntax? into)
        {
#if DEBUG
            if (joinKeyword == null) throw new ArgumentNullException(nameof(joinKeyword));
            if (joinKeyword.Kind != SyntaxKind.JoinKeyword) throw new ArgumentException(nameof(joinKeyword));
            if (identifier == null) throw new ArgumentNullException(nameof(identifier));
            if (identifier.Kind != SyntaxKind.IdentifierToken) throw new ArgumentException(nameof(identifier));
            if (inKeyword == null) throw new ArgumentNullException(nameof(inKeyword));
            if (inKeyword.Kind != SyntaxKind.InKeyword) throw new ArgumentException(nameof(inKeyword));
            if (inExpression == null) throw new ArgumentNullException(nameof(inExpression));
            if (onKeyword == null) throw new ArgumentNullException(nameof(onKeyword));
            if (onKeyword.Kind != SyntaxKind.OnKeyword) throw new ArgumentException(nameof(onKeyword));
            if (leftExpression == null) throw new ArgumentNullException(nameof(leftExpression));
            if (equalsKeyword == null) throw new ArgumentNullException(nameof(equalsKeyword));
            if (equalsKeyword.Kind != SyntaxKind.EqualsKeyword) throw new ArgumentException(nameof(equalsKeyword));
            if (rightExpression == null) throw new ArgumentNullException(nameof(rightExpression));
#endif

            return new JoinClauseSyntax(SyntaxKind.JoinClause, joinKeyword, type, identifier, inKeyword, inExpression, onKeyword, leftExpression, equalsKeyword, rightExpression, into);
        }

        public static JoinIntoClauseSyntax JoinIntoClause(SyntaxToken intoKeyword, SyntaxToken identifier)
        {
#if DEBUG
            if (intoKeyword == null) throw new ArgumentNullException(nameof(intoKeyword));
            if (intoKeyword.Kind != SyntaxKind.IntoKeyword) throw new ArgumentException(nameof(intoKeyword));
            if (identifier == null) throw new ArgumentNullException(nameof(identifier));
            if (identifier.Kind != SyntaxKind.IdentifierToken) throw new ArgumentException(nameof(identifier));
#endif

            int hash;
            var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.JoinIntoClause, intoKeyword, identifier, out hash);
            if (cached != null) return (JoinIntoClauseSyntax)cached;

            var result = new JoinIntoClauseSyntax(SyntaxKind.JoinIntoClause, intoKeyword, identifier);
            if (hash >= 0)
            {
                SyntaxNodeCache.AddNode(result, hash);
            }

            return result;
        }

        public static WhereClauseSyntax WhereClause(SyntaxToken whereKeyword, ExpressionSyntax condition)
        {
#if DEBUG
            if (whereKeyword == null) throw new ArgumentNullException(nameof(whereKeyword));
            if (whereKeyword.Kind != SyntaxKind.WhereKeyword) throw new ArgumentException(nameof(whereKeyword));
            if (condition == null) throw new ArgumentNullException(nameof(condition));
#endif

            int hash;
            var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.WhereClause, whereKeyword, condition, out hash);
            if (cached != null) return (WhereClauseSyntax)cached;

            var result = new WhereClauseSyntax(SyntaxKind.WhereClause, whereKeyword, condition);
            if (hash >= 0)
            {
                SyntaxNodeCache.AddNode(result, hash);
            }

            return result;
        }

        public static OrderByClauseSyntax OrderByClause(SyntaxToken orderByKeyword, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<OrderingSyntax> orderings)
        {
#if DEBUG
            if (orderByKeyword == null) throw new ArgumentNullException(nameof(orderByKeyword));
            if (orderByKeyword.Kind != SyntaxKind.OrderByKeyword) throw new ArgumentException(nameof(orderByKeyword));
#endif

            int hash;
            var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.OrderByClause, orderByKeyword, orderings.Node, out hash);
            if (cached != null) return (OrderByClauseSyntax)cached;

            var result = new OrderByClauseSyntax(SyntaxKind.OrderByClause, orderByKeyword, orderings.Node);
            if (hash >= 0)
            {
                SyntaxNodeCache.AddNode(result, hash);
            }

            return result;
        }

        public static OrderingSyntax Ordering(SyntaxKind kind, ExpressionSyntax expression, SyntaxToken? ascendingOrDescendingKeyword)
        {
            switch (kind)
            {
                case SyntaxKind.AscendingOrdering:
                case SyntaxKind.DescendingOrdering: break;
                default: throw new ArgumentException(nameof(kind));
            }
#if DEBUG
            if (expression == null) throw new ArgumentNullException(nameof(expression));
            if (ascendingOrDescendingKeyword != null)
            {
                switch (ascendingOrDescendingKeyword.Kind)
                {
                    case SyntaxKind.AscendingKeyword:
                    case SyntaxKind.DescendingKeyword:
                    case SyntaxKind.None: break;
                    default: throw new ArgumentException(nameof(ascendingOrDescendingKeyword));
                }
            }
#endif

            int hash;
            var cached = SyntaxNodeCache.TryGetNode((int)kind, expression, ascendingOrDescendingKeyword, out hash);
            if (cached != null) return (OrderingSyntax)cached;

            var result = new OrderingSyntax(kind, expression, ascendingOrDescendingKeyword);
            if (hash >= 0)
            {
                SyntaxNodeCache.AddNode(result, hash);
            }

            return result;
        }

        public static SelectClauseSyntax SelectClause(SyntaxToken selectKeyword, ExpressionSyntax expression)
        {
#if DEBUG
            if (selectKeyword == null) throw new ArgumentNullException(nameof(selectKeyword));
            if (selectKeyword.Kind != SyntaxKind.SelectKeyword) throw new ArgumentException(nameof(selectKeyword));
            if (expression == null) throw new ArgumentNullException(nameof(expression));
#endif

            int hash;
            var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.SelectClause, selectKeyword, expression, out hash);
            if (cached != null) return (SelectClauseSyntax)cached;

            var result = new SelectClauseSyntax(SyntaxKind.SelectClause, selectKeyword, expression);
            if (hash >= 0)
            {
                SyntaxNodeCache.AddNode(result, hash);
            }

            return result;
        }

        public static GroupClauseSyntax GroupClause(SyntaxToken groupKeyword, ExpressionSyntax groupExpression, SyntaxToken byKeyword, ExpressionSyntax byExpression)
        {
#if DEBUG
            if (groupKeyword == null) throw new ArgumentNullException(nameof(groupKeyword));
            if (groupKeyword.Kind != SyntaxKind.GroupKeyword) throw new ArgumentException(nameof(groupKeyword));
            if (groupExpression == null) throw new ArgumentNullException(nameof(groupExpression));
            if (byKeyword == null) throw new ArgumentNullException(nameof(byKeyword));
            if (byKeyword.Kind != SyntaxKind.ByKeyword) throw new ArgumentException(nameof(byKeyword));
            if (byExpression == null) throw new ArgumentNullException(nameof(byExpression));
#endif

            return new GroupClauseSyntax(SyntaxKind.GroupClause, groupKeyword, groupExpression, byKeyword, byExpression);
        }

        public static QueryContinuationSyntax QueryContinuation(SyntaxToken intoKeyword, SyntaxToken identifier, QueryBodySyntax body)
        {
#if DEBUG
            if (intoKeyword == null) throw new ArgumentNullException(nameof(intoKeyword));
            if (intoKeyword.Kind != SyntaxKind.IntoKeyword) throw new ArgumentException(nameof(intoKeyword));
            if (identifier == null) throw new ArgumentNullException(nameof(identifier));
            if (identifier.Kind != SyntaxKind.IdentifierToken) throw new ArgumentException(nameof(identifier));
            if (body == null) throw new ArgumentNullException(nameof(body));
#endif

            int hash;
            var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.QueryContinuation, intoKeyword, identifier, body, out hash);
            if (cached != null) return (QueryContinuationSyntax)cached;

            var result = new QueryContinuationSyntax(SyntaxKind.QueryContinuation, intoKeyword, identifier, body);
            if (hash >= 0)
            {
                SyntaxNodeCache.AddNode(result, hash);
            }

            return result;
        }

        public static OmittedArraySizeExpressionSyntax OmittedArraySizeExpression(SyntaxToken omittedArraySizeExpressionToken)
        {
#if DEBUG
            if (omittedArraySizeExpressionToken == null) throw new ArgumentNullException(nameof(omittedArraySizeExpressionToken));
            if (omittedArraySizeExpressionToken.Kind != SyntaxKind.OmittedArraySizeExpressionToken) throw new ArgumentException(nameof(omittedArraySizeExpressionToken));
#endif

            int hash;
            var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.OmittedArraySizeExpression, omittedArraySizeExpressionToken, out hash);
            if (cached != null) return (OmittedArraySizeExpressionSyntax)cached;

            var result = new OmittedArraySizeExpressionSyntax(SyntaxKind.OmittedArraySizeExpression, omittedArraySizeExpressionToken);
            if (hash >= 0)
            {
                SyntaxNodeCache.AddNode(result, hash);
            }

            return result;
        }

        public static InterpolatedStringExpressionSyntax InterpolatedStringExpression(SyntaxToken stringStartToken, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<InterpolatedStringContentSyntax> contents, SyntaxToken stringEndToken)
        {
#if DEBUG
            if (stringStartToken == null) throw new ArgumentNullException(nameof(stringStartToken));
            switch (stringStartToken.Kind)
            {
                case SyntaxKind.InterpolatedStringStartToken:
                case SyntaxKind.InterpolatedVerbatimStringStartToken: break;
                default: throw new ArgumentException(nameof(stringStartToken));
            }
            if (stringEndToken == null) throw new ArgumentNullException(nameof(stringEndToken));
            if (stringEndToken.Kind != SyntaxKind.InterpolatedStringEndToken) throw new ArgumentException(nameof(stringEndToken));
#endif

            int hash;
            var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.InterpolatedStringExpression, stringStartToken, contents.Node, stringEndToken, out hash);
            if (cached != null) return (InterpolatedStringExpressionSyntax)cached;

            var result = new InterpolatedStringExpressionSyntax(SyntaxKind.InterpolatedStringExpression, stringStartToken, contents.Node, stringEndToken);
            if (hash >= 0)
            {
                SyntaxNodeCache.AddNode(result, hash);
            }

            return result;
        }

        public static IsPatternExpressionSyntax IsPatternExpression(ExpressionSyntax expression, SyntaxToken isKeyword, PatternSyntax pattern)
        {
#if DEBUG
            if (expression == null) throw new ArgumentNullException(nameof(expression));
            if (isKeyword == null) throw new ArgumentNullException(nameof(isKeyword));
            if (isKeyword.Kind != SyntaxKind.IsKeyword) throw new ArgumentException(nameof(isKeyword));
            if (pattern == null) throw new ArgumentNullException(nameof(pattern));
#endif

            int hash;
            var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.IsPatternExpression, expression, isKeyword, pattern, out hash);
            if (cached != null) return (IsPatternExpressionSyntax)cached;

            var result = new IsPatternExpressionSyntax(SyntaxKind.IsPatternExpression, expression, isKeyword, pattern);
            if (hash >= 0)
            {
                SyntaxNodeCache.AddNode(result, hash);
            }

            return result;
        }

        public static ThrowExpressionSyntax ThrowExpression(SyntaxToken throwKeyword, ExpressionSyntax expression)
        {
#if DEBUG
            if (throwKeyword == null) throw new ArgumentNullException(nameof(throwKeyword));
            if (throwKeyword.Kind != SyntaxKind.ThrowKeyword) throw new ArgumentException(nameof(throwKeyword));
            if (expression == null) throw new ArgumentNullException(nameof(expression));
#endif

            int hash;
            var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.ThrowExpression, throwKeyword, expression, out hash);
            if (cached != null) return (ThrowExpressionSyntax)cached;

            var result = new ThrowExpressionSyntax(SyntaxKind.ThrowExpression, throwKeyword, expression);
            if (hash >= 0)
            {
                SyntaxNodeCache.AddNode(result, hash);
            }

            return result;
        }

        public static WhenClauseSyntax WhenClause(SyntaxToken whenKeyword, ExpressionSyntax condition)
        {
#if DEBUG
            if (whenKeyword == null) throw new ArgumentNullException(nameof(whenKeyword));
            if (whenKeyword.Kind != SyntaxKind.WhenKeyword) throw new ArgumentException(nameof(whenKeyword));
            if (condition == null) throw new ArgumentNullException(nameof(condition));
#endif

            int hash;
            var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.WhenClause, whenKeyword, condition, out hash);
            if (cached != null) return (WhenClauseSyntax)cached;

            var result = new WhenClauseSyntax(SyntaxKind.WhenClause, whenKeyword, condition);
            if (hash >= 0)
            {
                SyntaxNodeCache.AddNode(result, hash);
            }

            return result;
        }

        public static DiscardPatternSyntax DiscardPattern(SyntaxToken underscoreToken)
        {
#if DEBUG
            if (underscoreToken == null) throw new ArgumentNullException(nameof(underscoreToken));
            if (underscoreToken.Kind != SyntaxKind.UnderscoreToken) throw new ArgumentException(nameof(underscoreToken));
#endif

            int hash;
            var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.DiscardPattern, underscoreToken, out hash);
            if (cached != null) return (DiscardPatternSyntax)cached;

            var result = new DiscardPatternSyntax(SyntaxKind.DiscardPattern, underscoreToken);
            if (hash >= 0)
            {
                SyntaxNodeCache.AddNode(result, hash);
            }

            return result;
        }

        public static DeclarationPatternSyntax DeclarationPattern(TypeSyntax type, VariableDesignationSyntax designation)
        {
#if DEBUG
            if (type == null) throw new ArgumentNullException(nameof(type));
            if (designation == null) throw new ArgumentNullException(nameof(designation));
#endif

            int hash;
            var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.DeclarationPattern, type, designation, out hash);
            if (cached != null) return (DeclarationPatternSyntax)cached;

            var result = new DeclarationPatternSyntax(SyntaxKind.DeclarationPattern, type, designation);
            if (hash >= 0)
            {
                SyntaxNodeCache.AddNode(result, hash);
            }

            return result;
        }

        public static VarPatternSyntax VarPattern(SyntaxToken varKeyword, VariableDesignationSyntax designation)
        {
#if DEBUG
            if (varKeyword == null) throw new ArgumentNullException(nameof(varKeyword));
            if (varKeyword.Kind != SyntaxKind.VarKeyword) throw new ArgumentException(nameof(varKeyword));
            if (designation == null) throw new ArgumentNullException(nameof(designation));
#endif

            int hash;
            var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.VarPattern, varKeyword, designation, out hash);
            if (cached != null) return (VarPatternSyntax)cached;

            var result = new VarPatternSyntax(SyntaxKind.VarPattern, varKeyword, designation);
            if (hash >= 0)
            {
                SyntaxNodeCache.AddNode(result, hash);
            }

            return result;
        }

        public static RecursivePatternSyntax RecursivePattern(TypeSyntax? type, PositionalPatternClauseSyntax? positionalPatternClause, PropertyPatternClauseSyntax? propertyPatternClause, VariableDesignationSyntax? designation)
        {
#if DEBUG
#endif

            return new RecursivePatternSyntax(SyntaxKind.RecursivePattern, type, positionalPatternClause, propertyPatternClause, designation);
        }

        public static PositionalPatternClauseSyntax PositionalPatternClause(SyntaxToken openParenToken, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<SubpatternSyntax> subpatterns, SyntaxToken closeParenToken)
        {
#if DEBUG
            if (openParenToken == null) throw new ArgumentNullException(nameof(openParenToken));
            if (openParenToken.Kind != SyntaxKind.OpenParenToken) throw new ArgumentException(nameof(openParenToken));
            if (closeParenToken == null) throw new ArgumentNullException(nameof(closeParenToken));
            if (closeParenToken.Kind != SyntaxKind.CloseParenToken) throw new ArgumentException(nameof(closeParenToken));
#endif

            int hash;
            var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.PositionalPatternClause, openParenToken, subpatterns.Node, closeParenToken, out hash);
            if (cached != null) return (PositionalPatternClauseSyntax)cached;

            var result = new PositionalPatternClauseSyntax(SyntaxKind.PositionalPatternClause, openParenToken, subpatterns.Node, closeParenToken);
            if (hash >= 0)
            {
                SyntaxNodeCache.AddNode(result, hash);
            }

            return result;
        }

        public static PropertyPatternClauseSyntax PropertyPatternClause(SyntaxToken openBraceToken, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<SubpatternSyntax> subpatterns, SyntaxToken closeBraceToken)
        {
#if DEBUG
            if (openBraceToken == null) throw new ArgumentNullException(nameof(openBraceToken));
            if (openBraceToken.Kind != SyntaxKind.OpenBraceToken) throw new ArgumentException(nameof(openBraceToken));
            if (closeBraceToken == null) throw new ArgumentNullException(nameof(closeBraceToken));
            if (closeBraceToken.Kind != SyntaxKind.CloseBraceToken) throw new ArgumentException(nameof(closeBraceToken));
#endif

            int hash;
            var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.PropertyPatternClause, openBraceToken, subpatterns.Node, closeBraceToken, out hash);
            if (cached != null) return (PropertyPatternClauseSyntax)cached;

            var result = new PropertyPatternClauseSyntax(SyntaxKind.PropertyPatternClause, openBraceToken, subpatterns.Node, closeBraceToken);
            if (hash >= 0)
            {
                SyntaxNodeCache.AddNode(result, hash);
            }

            return result;
        }

        public static SubpatternSyntax Subpattern(NameColonSyntax? nameColon, PatternSyntax pattern)
        {
#if DEBUG
            if (pattern == null) throw new ArgumentNullException(nameof(pattern));
#endif

            int hash;
            var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.Subpattern, nameColon, pattern, out hash);
            if (cached != null) return (SubpatternSyntax)cached;

            var result = new SubpatternSyntax(SyntaxKind.Subpattern, nameColon, pattern);
            if (hash >= 0)
            {
                SyntaxNodeCache.AddNode(result, hash);
            }

            return result;
        }

        public static ConstantPatternSyntax ConstantPattern(ExpressionSyntax expression)
        {
#if DEBUG
            if (expression == null) throw new ArgumentNullException(nameof(expression));
#endif

            int hash;
            var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.ConstantPattern, expression, out hash);
            if (cached != null) return (ConstantPatternSyntax)cached;

            var result = new ConstantPatternSyntax(SyntaxKind.ConstantPattern, expression);
            if (hash >= 0)
            {
                SyntaxNodeCache.AddNode(result, hash);
            }

            return result;
        }

        public static ParenthesizedPatternSyntax ParenthesizedPattern(SyntaxToken openParenToken, PatternSyntax pattern, SyntaxToken closeParenToken)
        {
#if DEBUG
            if (openParenToken == null) throw new ArgumentNullException(nameof(openParenToken));
            if (openParenToken.Kind != SyntaxKind.OpenParenToken) throw new ArgumentException(nameof(openParenToken));
            if (pattern == null) throw new ArgumentNullException(nameof(pattern));
            if (closeParenToken == null) throw new ArgumentNullException(nameof(closeParenToken));
            if (closeParenToken.Kind != SyntaxKind.CloseParenToken) throw new ArgumentException(nameof(closeParenToken));
#endif

            int hash;
            var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.ParenthesizedPattern, openParenToken, pattern, closeParenToken, out hash);
            if (cached != null) return (ParenthesizedPatternSyntax)cached;

            var result = new ParenthesizedPatternSyntax(SyntaxKind.ParenthesizedPattern, openParenToken, pattern, closeParenToken);
            if (hash >= 0)
            {
                SyntaxNodeCache.AddNode(result, hash);
            }

            return result;
        }

        public static RelationalPatternSyntax RelationalPattern(SyntaxToken operatorToken, ExpressionSyntax expression)
        {
#if DEBUG
            if (operatorToken == null) throw new ArgumentNullException(nameof(operatorToken));
            switch (operatorToken.Kind)
            {
                case SyntaxKind.EqualsEqualsToken:
                case SyntaxKind.ExclamationEqualsToken:
                case SyntaxKind.LessThanToken:
                case SyntaxKind.LessThanEqualsToken:
                case SyntaxKind.GreaterThanToken:
                case SyntaxKind.GreaterThanEqualsToken: break;
                default: throw new ArgumentException(nameof(operatorToken));
            }
            if (expression == null) throw new ArgumentNullException(nameof(expression));
#endif

            int hash;
            var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.RelationalPattern, operatorToken, expression, out hash);
            if (cached != null) return (RelationalPatternSyntax)cached;

            var result = new RelationalPatternSyntax(SyntaxKind.RelationalPattern, operatorToken, expression);
            if (hash >= 0)
            {
                SyntaxNodeCache.AddNode(result, hash);
            }

            return result;
        }

        public static TypePatternSyntax TypePattern(TypeSyntax type)
        {
#if DEBUG
            if (type == null) throw new ArgumentNullException(nameof(type));
#endif

            int hash;
            var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.TypePattern, type, out hash);
            if (cached != null) return (TypePatternSyntax)cached;

            var result = new TypePatternSyntax(SyntaxKind.TypePattern, type);
            if (hash >= 0)
            {
                SyntaxNodeCache.AddNode(result, hash);
            }

            return result;
        }

        public static BinaryPatternSyntax BinaryPattern(SyntaxKind kind, PatternSyntax left, SyntaxToken operatorToken, PatternSyntax right)
        {
            switch (kind)
            {
                case SyntaxKind.OrPattern:
                case SyntaxKind.AndPattern: break;
                default: throw new ArgumentException(nameof(kind));
            }
#if DEBUG
            if (left == null) throw new ArgumentNullException(nameof(left));
            if (operatorToken == null) throw new ArgumentNullException(nameof(operatorToken));
            switch (operatorToken.Kind)
            {
                case SyntaxKind.OrKeyword:
                case SyntaxKind.AndKeyword: break;
                default: throw new ArgumentException(nameof(operatorToken));
            }
            if (right == null) throw new ArgumentNullException(nameof(right));
#endif

            int hash;
            var cached = SyntaxNodeCache.TryGetNode((int)kind, left, operatorToken, right, out hash);
            if (cached != null) return (BinaryPatternSyntax)cached;

            var result = new BinaryPatternSyntax(kind, left, operatorToken, right);
            if (hash >= 0)
            {
                SyntaxNodeCache.AddNode(result, hash);
            }

            return result;
        }

        public static UnaryPatternSyntax UnaryPattern(SyntaxToken operatorToken, PatternSyntax pattern)
        {
#if DEBUG
            if (operatorToken == null) throw new ArgumentNullException(nameof(operatorToken));
            if (operatorToken.Kind != SyntaxKind.NotKeyword) throw new ArgumentException(nameof(operatorToken));
            if (pattern == null) throw new ArgumentNullException(nameof(pattern));
#endif

            int hash;
            var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.NotPattern, operatorToken, pattern, out hash);
            if (cached != null) return (UnaryPatternSyntax)cached;

            var result = new UnaryPatternSyntax(SyntaxKind.NotPattern, operatorToken, pattern);
            if (hash >= 0)
            {
                SyntaxNodeCache.AddNode(result, hash);
            }

            return result;
        }

        public static InterpolatedStringTextSyntax InterpolatedStringText(SyntaxToken textToken)
        {
#if DEBUG
            if (textToken == null) throw new ArgumentNullException(nameof(textToken));
            if (textToken.Kind != SyntaxKind.InterpolatedStringTextToken) throw new ArgumentException(nameof(textToken));
#endif

            int hash;
            var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.InterpolatedStringText, textToken, out hash);
            if (cached != null) return (InterpolatedStringTextSyntax)cached;

            var result = new InterpolatedStringTextSyntax(SyntaxKind.InterpolatedStringText, textToken);
            if (hash >= 0)
            {
                SyntaxNodeCache.AddNode(result, hash);
            }

            return result;
        }

        public static InterpolationSyntax Interpolation(SyntaxToken openBraceToken, ExpressionSyntax expression, InterpolationAlignmentClauseSyntax? alignmentClause, InterpolationFormatClauseSyntax? formatClause, SyntaxToken closeBraceToken)
        {
#if DEBUG
            if (openBraceToken == null) throw new ArgumentNullException(nameof(openBraceToken));
            if (openBraceToken.Kind != SyntaxKind.OpenBraceToken) throw new ArgumentException(nameof(openBraceToken));
            if (expression == null) throw new ArgumentNullException(nameof(expression));
            if (closeBraceToken == null) throw new ArgumentNullException(nameof(closeBraceToken));
            if (closeBraceToken.Kind != SyntaxKind.CloseBraceToken) throw new ArgumentException(nameof(closeBraceToken));
#endif

            return new InterpolationSyntax(SyntaxKind.Interpolation, openBraceToken, expression, alignmentClause, formatClause, closeBraceToken);
        }

        public static InterpolationAlignmentClauseSyntax InterpolationAlignmentClause(SyntaxToken commaToken, ExpressionSyntax value)
        {
#if DEBUG
            if (commaToken == null) throw new ArgumentNullException(nameof(commaToken));
            if (value == null) throw new ArgumentNullException(nameof(value));
#endif

            int hash;
            var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.InterpolationAlignmentClause, commaToken, value, out hash);
            if (cached != null) return (InterpolationAlignmentClauseSyntax)cached;

            var result = new InterpolationAlignmentClauseSyntax(SyntaxKind.InterpolationAlignmentClause, commaToken, value);
            if (hash >= 0)
            {
                SyntaxNodeCache.AddNode(result, hash);
            }

            return result;
        }

        public static InterpolationFormatClauseSyntax InterpolationFormatClause(SyntaxToken colonToken, SyntaxToken formatStringToken)
        {
#if DEBUG
            if (colonToken == null) throw new ArgumentNullException(nameof(colonToken));
            if (formatStringToken == null) throw new ArgumentNullException(nameof(formatStringToken));
            if (formatStringToken.Kind != SyntaxKind.InterpolatedStringTextToken) throw new ArgumentException(nameof(formatStringToken));
#endif

            int hash;
            var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.InterpolationFormatClause, colonToken, formatStringToken, out hash);
            if (cached != null) return (InterpolationFormatClauseSyntax)cached;

            var result = new InterpolationFormatClauseSyntax(SyntaxKind.InterpolationFormatClause, colonToken, formatStringToken);
            if (hash >= 0)
            {
                SyntaxNodeCache.AddNode(result, hash);
            }

            return result;
        }

        public static GlobalStatementSyntax GlobalStatement(Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<AttributeListSyntax> attributeLists, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SyntaxToken> modifiers, StatementSyntax statement)
        {
#if DEBUG
            if (statement == null) throw new ArgumentNullException(nameof(statement));
#endif

            int hash;
            var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.GlobalStatement, attributeLists.Node, modifiers.Node, statement, out hash);
            if (cached != null) return (GlobalStatementSyntax)cached;

            var result = new GlobalStatementSyntax(SyntaxKind.GlobalStatement, attributeLists.Node, modifiers.Node, statement);
            if (hash >= 0)
            {
                SyntaxNodeCache.AddNode(result, hash);
            }

            return result;
        }

        public static BlockSyntax Block(Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<AttributeListSyntax> attributeLists, SyntaxToken openBraceToken, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<StatementSyntax> statements, SyntaxToken closeBraceToken)
        {
#if DEBUG
            if (openBraceToken == null) throw new ArgumentNullException(nameof(openBraceToken));
            if (openBraceToken.Kind != SyntaxKind.OpenBraceToken) throw new ArgumentException(nameof(openBraceToken));
            if (closeBraceToken == null) throw new ArgumentNullException(nameof(closeBraceToken));
            if (closeBraceToken.Kind != SyntaxKind.CloseBraceToken) throw new ArgumentException(nameof(closeBraceToken));
#endif

            return new BlockSyntax(SyntaxKind.Block, attributeLists.Node, openBraceToken, statements.Node, closeBraceToken);
        }

        public static LocalFunctionStatementSyntax LocalFunctionStatement(Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<AttributeListSyntax> attributeLists, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SyntaxToken> modifiers, TypeSyntax returnType, SyntaxToken identifier, TypeParameterListSyntax? typeParameterList, ParameterListSyntax parameterList, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<TypeParameterConstraintClauseSyntax> constraintClauses, BlockSyntax? body, ArrowExpressionClauseSyntax? expressionBody, SyntaxToken? semicolonToken)
        {
#if DEBUG
            if (returnType == null) throw new ArgumentNullException(nameof(returnType));
            if (identifier == null) throw new ArgumentNullException(nameof(identifier));
            if (identifier.Kind != SyntaxKind.IdentifierToken) throw new ArgumentException(nameof(identifier));
            if (parameterList == null) throw new ArgumentNullException(nameof(parameterList));
            if (semicolonToken != null)
            {
                switch (semicolonToken.Kind)
                {
                    case SyntaxKind.SemicolonToken:
                    case SyntaxKind.None: break;
                    default: throw new ArgumentException(nameof(semicolonToken));
                }
            }
#endif

            return new LocalFunctionStatementSyntax(SyntaxKind.LocalFunctionStatement, attributeLists.Node, modifiers.Node, returnType, identifier, typeParameterList, parameterList, constraintClauses.Node, body, expressionBody, semicolonToken);
        }

        public static LocalDeclarationStatementSyntax LocalDeclarationStatement(Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<AttributeListSyntax> attributeLists, SyntaxToken? awaitKeyword, SyntaxToken? usingKeyword, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SyntaxToken> modifiers, VariableDeclarationSyntax declaration, SyntaxToken semicolonToken)
        {
#if DEBUG
            if (awaitKeyword != null)
            {
                switch (awaitKeyword.Kind)
                {
                    case SyntaxKind.AwaitKeyword:
                    case SyntaxKind.None: break;
                    default: throw new ArgumentException(nameof(awaitKeyword));
                }
            }
            if (usingKeyword != null)
            {
                switch (usingKeyword.Kind)
                {
                    case SyntaxKind.UsingKeyword:
                    case SyntaxKind.None: break;
                    default: throw new ArgumentException(nameof(usingKeyword));
                }
            }
            if (declaration == null) throw new ArgumentNullException(nameof(declaration));
            if (semicolonToken == null) throw new ArgumentNullException(nameof(semicolonToken));
            if (semicolonToken.Kind != SyntaxKind.SemicolonToken) throw new ArgumentException(nameof(semicolonToken));
#endif

            return new LocalDeclarationStatementSyntax(SyntaxKind.LocalDeclarationStatement, attributeLists.Node, awaitKeyword, usingKeyword, modifiers.Node, declaration, semicolonToken);
        }

        public static VariableDeclarationSyntax VariableDeclaration(TypeSyntax type, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<VariableDeclaratorSyntax> variables)
        {
#if DEBUG
            if (type == null) throw new ArgumentNullException(nameof(type));
#endif

            int hash;
            var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.VariableDeclaration, type, variables.Node, out hash);
            if (cached != null) return (VariableDeclarationSyntax)cached;

            var result = new VariableDeclarationSyntax(SyntaxKind.VariableDeclaration, type, variables.Node);
            if (hash >= 0)
            {
                SyntaxNodeCache.AddNode(result, hash);
            }

            return result;
        }

        public static VariableDeclaratorSyntax VariableDeclarator(SyntaxToken identifier, BracketedArgumentListSyntax? argumentList, EqualsValueClauseSyntax? initializer)
        {
#if DEBUG
            if (identifier == null) throw new ArgumentNullException(nameof(identifier));
            if (identifier.Kind != SyntaxKind.IdentifierToken) throw new ArgumentException(nameof(identifier));
#endif

            int hash;
            var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.VariableDeclarator, identifier, argumentList, initializer, out hash);
            if (cached != null) return (VariableDeclaratorSyntax)cached;

            var result = new VariableDeclaratorSyntax(SyntaxKind.VariableDeclarator, identifier, argumentList, initializer);
            if (hash >= 0)
            {
                SyntaxNodeCache.AddNode(result, hash);
            }

            return result;
        }

        public static EqualsValueClauseSyntax EqualsValueClause(SyntaxToken equalsToken, ExpressionSyntax value)
        {
#if DEBUG
            if (equalsToken == null) throw new ArgumentNullException(nameof(equalsToken));
            if (equalsToken.Kind != SyntaxKind.EqualsToken) throw new ArgumentException(nameof(equalsToken));
            if (value == null) throw new ArgumentNullException(nameof(value));
#endif

            int hash;
            var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.EqualsValueClause, equalsToken, value, out hash);
            if (cached != null) return (EqualsValueClauseSyntax)cached;

            var result = new EqualsValueClauseSyntax(SyntaxKind.EqualsValueClause, equalsToken, value);
            if (hash >= 0)
            {
                SyntaxNodeCache.AddNode(result, hash);
            }

            return result;
        }

        public static SingleVariableDesignationSyntax SingleVariableDesignation(SyntaxToken identifier)
        {
#if DEBUG
            if (identifier == null) throw new ArgumentNullException(nameof(identifier));
            if (identifier.Kind != SyntaxKind.IdentifierToken) throw new ArgumentException(nameof(identifier));
#endif

            int hash;
            var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.SingleVariableDesignation, identifier, out hash);
            if (cached != null) return (SingleVariableDesignationSyntax)cached;

            var result = new SingleVariableDesignationSyntax(SyntaxKind.SingleVariableDesignation, identifier);
            if (hash >= 0)
            {
                SyntaxNodeCache.AddNode(result, hash);
            }

            return result;
        }

        public static DiscardDesignationSyntax DiscardDesignation(SyntaxToken underscoreToken)
        {
#if DEBUG
            if (underscoreToken == null) throw new ArgumentNullException(nameof(underscoreToken));
            if (underscoreToken.Kind != SyntaxKind.UnderscoreToken) throw new ArgumentException(nameof(underscoreToken));
#endif

            int hash;
            var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.DiscardDesignation, underscoreToken, out hash);
            if (cached != null) return (DiscardDesignationSyntax)cached;

            var result = new DiscardDesignationSyntax(SyntaxKind.DiscardDesignation, underscoreToken);
            if (hash >= 0)
            {
                SyntaxNodeCache.AddNode(result, hash);
            }

            return result;
        }

        public static ParenthesizedVariableDesignationSyntax ParenthesizedVariableDesignation(SyntaxToken openParenToken, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<VariableDesignationSyntax> variables, SyntaxToken closeParenToken)
        {
#if DEBUG
            if (openParenToken == null) throw new ArgumentNullException(nameof(openParenToken));
            if (openParenToken.Kind != SyntaxKind.OpenParenToken) throw new ArgumentException(nameof(openParenToken));
            if (closeParenToken == null) throw new ArgumentNullException(nameof(closeParenToken));
            if (closeParenToken.Kind != SyntaxKind.CloseParenToken) throw new ArgumentException(nameof(closeParenToken));
#endif

            int hash;
            var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.ParenthesizedVariableDesignation, openParenToken, variables.Node, closeParenToken, out hash);
            if (cached != null) return (ParenthesizedVariableDesignationSyntax)cached;

            var result = new ParenthesizedVariableDesignationSyntax(SyntaxKind.ParenthesizedVariableDesignation, openParenToken, variables.Node, closeParenToken);
            if (hash >= 0)
            {
                SyntaxNodeCache.AddNode(result, hash);
            }

            return result;
        }

        public static ExpressionStatementSyntax ExpressionStatement(Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<AttributeListSyntax> attributeLists, ExpressionSyntax expression, SyntaxToken semicolonToken)
        {
#if DEBUG
            if (expression == null) throw new ArgumentNullException(nameof(expression));
            if (semicolonToken == null) throw new ArgumentNullException(nameof(semicolonToken));
            if (semicolonToken.Kind != SyntaxKind.SemicolonToken) throw new ArgumentException(nameof(semicolonToken));
#endif

            int hash;
            var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.ExpressionStatement, attributeLists.Node, expression, semicolonToken, out hash);
            if (cached != null) return (ExpressionStatementSyntax)cached;

            var result = new ExpressionStatementSyntax(SyntaxKind.ExpressionStatement, attributeLists.Node, expression, semicolonToken);
            if (hash >= 0)
            {
                SyntaxNodeCache.AddNode(result, hash);
            }

            return result;
        }

        public static EmptyStatementSyntax EmptyStatement(Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<AttributeListSyntax> attributeLists, SyntaxToken semicolonToken)
        {
#if DEBUG
            if (semicolonToken == null) throw new ArgumentNullException(nameof(semicolonToken));
            if (semicolonToken.Kind != SyntaxKind.SemicolonToken) throw new ArgumentException(nameof(semicolonToken));
#endif

            int hash;
            var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.EmptyStatement, attributeLists.Node, semicolonToken, out hash);
            if (cached != null) return (EmptyStatementSyntax)cached;

            var result = new EmptyStatementSyntax(SyntaxKind.EmptyStatement, attributeLists.Node, semicolonToken);
            if (hash >= 0)
            {
                SyntaxNodeCache.AddNode(result, hash);
            }

            return result;
        }

        public static LabeledStatementSyntax LabeledStatement(Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<AttributeListSyntax> attributeLists, SyntaxToken identifier, SyntaxToken colonToken, StatementSyntax statement)
        {
#if DEBUG
            if (identifier == null) throw new ArgumentNullException(nameof(identifier));
            if (identifier.Kind != SyntaxKind.IdentifierToken) throw new ArgumentException(nameof(identifier));
            if (colonToken == null) throw new ArgumentNullException(nameof(colonToken));
            if (colonToken.Kind != SyntaxKind.ColonToken) throw new ArgumentException(nameof(colonToken));
            if (statement == null) throw new ArgumentNullException(nameof(statement));
#endif

            return new LabeledStatementSyntax(SyntaxKind.LabeledStatement, attributeLists.Node, identifier, colonToken, statement);
        }

        public static GotoStatementSyntax GotoStatement(SyntaxKind kind, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<AttributeListSyntax> attributeLists, SyntaxToken gotoKeyword, SyntaxToken? caseOrDefaultKeyword, ExpressionSyntax? expression, SyntaxToken semicolonToken)
        {
            switch (kind)
            {
                case SyntaxKind.GotoStatement:
                case SyntaxKind.GotoCaseStatement:
                case SyntaxKind.GotoDefaultStatement: break;
                default: throw new ArgumentException(nameof(kind));
            }
#if DEBUG
            if (gotoKeyword == null) throw new ArgumentNullException(nameof(gotoKeyword));
            if (gotoKeyword.Kind != SyntaxKind.GotoKeyword) throw new ArgumentException(nameof(gotoKeyword));
            if (caseOrDefaultKeyword != null)
            {
                switch (caseOrDefaultKeyword.Kind)
                {
                    case SyntaxKind.CaseKeyword:
                    case SyntaxKind.DefaultKeyword:
                    case SyntaxKind.None: break;
                    default: throw new ArgumentException(nameof(caseOrDefaultKeyword));
                }
            }
            if (semicolonToken == null) throw new ArgumentNullException(nameof(semicolonToken));
            if (semicolonToken.Kind != SyntaxKind.SemicolonToken) throw new ArgumentException(nameof(semicolonToken));
#endif

            return new GotoStatementSyntax(kind, attributeLists.Node, gotoKeyword, caseOrDefaultKeyword, expression, semicolonToken);
        }

        public static BreakStatementSyntax BreakStatement(Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<AttributeListSyntax> attributeLists, SyntaxToken breakKeyword, SyntaxToken semicolonToken)
        {
#if DEBUG
            if (breakKeyword == null) throw new ArgumentNullException(nameof(breakKeyword));
            if (breakKeyword.Kind != SyntaxKind.BreakKeyword) throw new ArgumentException(nameof(breakKeyword));
            if (semicolonToken == null) throw new ArgumentNullException(nameof(semicolonToken));
            if (semicolonToken.Kind != SyntaxKind.SemicolonToken) throw new ArgumentException(nameof(semicolonToken));
#endif

            int hash;
            var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.BreakStatement, attributeLists.Node, breakKeyword, semicolonToken, out hash);
            if (cached != null) return (BreakStatementSyntax)cached;

            var result = new BreakStatementSyntax(SyntaxKind.BreakStatement, attributeLists.Node, breakKeyword, semicolonToken);
            if (hash >= 0)
            {
                SyntaxNodeCache.AddNode(result, hash);
            }

            return result;
        }

        public static ContinueStatementSyntax ContinueStatement(Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<AttributeListSyntax> attributeLists, SyntaxToken continueKeyword, SyntaxToken semicolonToken)
        {
#if DEBUG
            if (continueKeyword == null) throw new ArgumentNullException(nameof(continueKeyword));
            if (continueKeyword.Kind != SyntaxKind.ContinueKeyword) throw new ArgumentException(nameof(continueKeyword));
            if (semicolonToken == null) throw new ArgumentNullException(nameof(semicolonToken));
            if (semicolonToken.Kind != SyntaxKind.SemicolonToken) throw new ArgumentException(nameof(semicolonToken));
#endif

            int hash;
            var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.ContinueStatement, attributeLists.Node, continueKeyword, semicolonToken, out hash);
            if (cached != null) return (ContinueStatementSyntax)cached;

            var result = new ContinueStatementSyntax(SyntaxKind.ContinueStatement, attributeLists.Node, continueKeyword, semicolonToken);
            if (hash >= 0)
            {
                SyntaxNodeCache.AddNode(result, hash);
            }

            return result;
        }

        public static ReturnStatementSyntax ReturnStatement(Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<AttributeListSyntax> attributeLists, SyntaxToken returnKeyword, ExpressionSyntax? expression, SyntaxToken semicolonToken)
        {
#if DEBUG
            if (returnKeyword == null) throw new ArgumentNullException(nameof(returnKeyword));
            if (returnKeyword.Kind != SyntaxKind.ReturnKeyword) throw new ArgumentException(nameof(returnKeyword));
            if (semicolonToken == null) throw new ArgumentNullException(nameof(semicolonToken));
            if (semicolonToken.Kind != SyntaxKind.SemicolonToken) throw new ArgumentException(nameof(semicolonToken));
#endif

            return new ReturnStatementSyntax(SyntaxKind.ReturnStatement, attributeLists.Node, returnKeyword, expression, semicolonToken);
        }

        public static ThrowStatementSyntax ThrowStatement(Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<AttributeListSyntax> attributeLists, SyntaxToken throwKeyword, ExpressionSyntax? expression, SyntaxToken semicolonToken)
        {
#if DEBUG
            if (throwKeyword == null) throw new ArgumentNullException(nameof(throwKeyword));
            if (throwKeyword.Kind != SyntaxKind.ThrowKeyword) throw new ArgumentException(nameof(throwKeyword));
            if (semicolonToken == null) throw new ArgumentNullException(nameof(semicolonToken));
            if (semicolonToken.Kind != SyntaxKind.SemicolonToken) throw new ArgumentException(nameof(semicolonToken));
#endif

            return new ThrowStatementSyntax(SyntaxKind.ThrowStatement, attributeLists.Node, throwKeyword, expression, semicolonToken);
        }

        public static YieldStatementSyntax YieldStatement(SyntaxKind kind, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<AttributeListSyntax> attributeLists, SyntaxToken yieldKeyword, SyntaxToken returnOrBreakKeyword, ExpressionSyntax? expression, SyntaxToken semicolonToken)
        {
            switch (kind)
            {
                case SyntaxKind.YieldReturnStatement:
                case SyntaxKind.YieldBreakStatement: break;
                default: throw new ArgumentException(nameof(kind));
            }
#if DEBUG
            if (yieldKeyword == null) throw new ArgumentNullException(nameof(yieldKeyword));
            if (yieldKeyword.Kind != SyntaxKind.YieldKeyword) throw new ArgumentException(nameof(yieldKeyword));
            if (returnOrBreakKeyword == null) throw new ArgumentNullException(nameof(returnOrBreakKeyword));
            switch (returnOrBreakKeyword.Kind)
            {
                case SyntaxKind.ReturnKeyword:
                case SyntaxKind.BreakKeyword: break;
                default: throw new ArgumentException(nameof(returnOrBreakKeyword));
            }
            if (semicolonToken == null) throw new ArgumentNullException(nameof(semicolonToken));
            if (semicolonToken.Kind != SyntaxKind.SemicolonToken) throw new ArgumentException(nameof(semicolonToken));
#endif

            return new YieldStatementSyntax(kind, attributeLists.Node, yieldKeyword, returnOrBreakKeyword, expression, semicolonToken);
        }

        public static WhileStatementSyntax WhileStatement(Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<AttributeListSyntax> attributeLists, SyntaxToken whileKeyword, SyntaxToken openParenToken, ExpressionSyntax condition, SyntaxToken closeParenToken, StatementSyntax statement)
        {
#if DEBUG
            if (whileKeyword == null) throw new ArgumentNullException(nameof(whileKeyword));
            if (whileKeyword.Kind != SyntaxKind.WhileKeyword) throw new ArgumentException(nameof(whileKeyword));
            if (openParenToken == null) throw new ArgumentNullException(nameof(openParenToken));
            if (openParenToken.Kind != SyntaxKind.OpenParenToken) throw new ArgumentException(nameof(openParenToken));
            if (condition == null) throw new ArgumentNullException(nameof(condition));
            if (closeParenToken == null) throw new ArgumentNullException(nameof(closeParenToken));
            if (closeParenToken.Kind != SyntaxKind.CloseParenToken) throw new ArgumentException(nameof(closeParenToken));
            if (statement == null) throw new ArgumentNullException(nameof(statement));
#endif

            return new WhileStatementSyntax(SyntaxKind.WhileStatement, attributeLists.Node, whileKeyword, openParenToken, condition, closeParenToken, statement);
        }

        public static DoStatementSyntax DoStatement(Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<AttributeListSyntax> attributeLists, SyntaxToken doKeyword, StatementSyntax statement, SyntaxToken whileKeyword, SyntaxToken openParenToken, ExpressionSyntax condition, SyntaxToken closeParenToken, SyntaxToken semicolonToken)
        {
#if DEBUG
            if (doKeyword == null) throw new ArgumentNullException(nameof(doKeyword));
            if (doKeyword.Kind != SyntaxKind.DoKeyword) throw new ArgumentException(nameof(doKeyword));
            if (statement == null) throw new ArgumentNullException(nameof(statement));
            if (whileKeyword == null) throw new ArgumentNullException(nameof(whileKeyword));
            if (whileKeyword.Kind != SyntaxKind.WhileKeyword) throw new ArgumentException(nameof(whileKeyword));
            if (openParenToken == null) throw new ArgumentNullException(nameof(openParenToken));
            if (openParenToken.Kind != SyntaxKind.OpenParenToken) throw new ArgumentException(nameof(openParenToken));
            if (condition == null) throw new ArgumentNullException(nameof(condition));
            if (closeParenToken == null) throw new ArgumentNullException(nameof(closeParenToken));
            if (closeParenToken.Kind != SyntaxKind.CloseParenToken) throw new ArgumentException(nameof(closeParenToken));
            if (semicolonToken == null) throw new ArgumentNullException(nameof(semicolonToken));
            if (semicolonToken.Kind != SyntaxKind.SemicolonToken) throw new ArgumentException(nameof(semicolonToken));
#endif

            return new DoStatementSyntax(SyntaxKind.DoStatement, attributeLists.Node, doKeyword, statement, whileKeyword, openParenToken, condition, closeParenToken, semicolonToken);
        }

        public static ForStatementSyntax ForStatement(Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<AttributeListSyntax> attributeLists, SyntaxToken forKeyword, SyntaxToken openParenToken, VariableDeclarationSyntax? declaration, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<ExpressionSyntax> initializers, SyntaxToken firstSemicolonToken, ExpressionSyntax? condition, SyntaxToken secondSemicolonToken, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<ExpressionSyntax> incrementors, SyntaxToken closeParenToken, StatementSyntax statement)
        {
#if DEBUG
            if (forKeyword == null) throw new ArgumentNullException(nameof(forKeyword));
            if (forKeyword.Kind != SyntaxKind.ForKeyword) throw new ArgumentException(nameof(forKeyword));
            if (openParenToken == null) throw new ArgumentNullException(nameof(openParenToken));
            if (openParenToken.Kind != SyntaxKind.OpenParenToken) throw new ArgumentException(nameof(openParenToken));
            if (firstSemicolonToken == null) throw new ArgumentNullException(nameof(firstSemicolonToken));
            if (firstSemicolonToken.Kind != SyntaxKind.SemicolonToken) throw new ArgumentException(nameof(firstSemicolonToken));
            if (secondSemicolonToken == null) throw new ArgumentNullException(nameof(secondSemicolonToken));
            if (secondSemicolonToken.Kind != SyntaxKind.SemicolonToken) throw new ArgumentException(nameof(secondSemicolonToken));
            if (closeParenToken == null) throw new ArgumentNullException(nameof(closeParenToken));
            if (closeParenToken.Kind != SyntaxKind.CloseParenToken) throw new ArgumentException(nameof(closeParenToken));
            if (statement == null) throw new ArgumentNullException(nameof(statement));
#endif

            return new ForStatementSyntax(SyntaxKind.ForStatement, attributeLists.Node, forKeyword, openParenToken, declaration, initializers.Node, firstSemicolonToken, condition, secondSemicolonToken, incrementors.Node, closeParenToken, statement);
        }

        public static ForEachStatementSyntax ForEachStatement(Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<AttributeListSyntax> attributeLists, SyntaxToken? awaitKeyword, SyntaxToken forEachKeyword, SyntaxToken openParenToken, TypeSyntax type, SyntaxToken identifier, SyntaxToken inKeyword, ExpressionSyntax expression, SyntaxToken closeParenToken, StatementSyntax statement)
        {
#if DEBUG
            if (awaitKeyword != null)
            {
                switch (awaitKeyword.Kind)
                {
                    case SyntaxKind.AwaitKeyword:
                    case SyntaxKind.None: break;
                    default: throw new ArgumentException(nameof(awaitKeyword));
                }
            }
            if (forEachKeyword == null) throw new ArgumentNullException(nameof(forEachKeyword));
            if (forEachKeyword.Kind != SyntaxKind.ForEachKeyword) throw new ArgumentException(nameof(forEachKeyword));
            if (openParenToken == null) throw new ArgumentNullException(nameof(openParenToken));
            if (openParenToken.Kind != SyntaxKind.OpenParenToken) throw new ArgumentException(nameof(openParenToken));
            if (type == null) throw new ArgumentNullException(nameof(type));
            if (identifier == null) throw new ArgumentNullException(nameof(identifier));
            if (identifier.Kind != SyntaxKind.IdentifierToken) throw new ArgumentException(nameof(identifier));
            if (inKeyword == null) throw new ArgumentNullException(nameof(inKeyword));
            if (inKeyword.Kind != SyntaxKind.InKeyword) throw new ArgumentException(nameof(inKeyword));
            if (expression == null) throw new ArgumentNullException(nameof(expression));
            if (closeParenToken == null) throw new ArgumentNullException(nameof(closeParenToken));
            if (closeParenToken.Kind != SyntaxKind.CloseParenToken) throw new ArgumentException(nameof(closeParenToken));
            if (statement == null) throw new ArgumentNullException(nameof(statement));
#endif

            return new ForEachStatementSyntax(SyntaxKind.ForEachStatement, attributeLists.Node, awaitKeyword, forEachKeyword, openParenToken, type, identifier, inKeyword, expression, closeParenToken, statement);
        }

        public static ForEachVariableStatementSyntax ForEachVariableStatement(Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<AttributeListSyntax> attributeLists, SyntaxToken? awaitKeyword, SyntaxToken forEachKeyword, SyntaxToken openParenToken, ExpressionSyntax variable, SyntaxToken inKeyword, ExpressionSyntax expression, SyntaxToken closeParenToken, StatementSyntax statement)
        {
#if DEBUG
            if (awaitKeyword != null)
            {
                switch (awaitKeyword.Kind)
                {
                    case SyntaxKind.AwaitKeyword:
                    case SyntaxKind.None: break;
                    default: throw new ArgumentException(nameof(awaitKeyword));
                }
            }
            if (forEachKeyword == null) throw new ArgumentNullException(nameof(forEachKeyword));
            if (forEachKeyword.Kind != SyntaxKind.ForEachKeyword) throw new ArgumentException(nameof(forEachKeyword));
            if (openParenToken == null) throw new ArgumentNullException(nameof(openParenToken));
            if (openParenToken.Kind != SyntaxKind.OpenParenToken) throw new ArgumentException(nameof(openParenToken));
            if (variable == null) throw new ArgumentNullException(nameof(variable));
            if (inKeyword == null) throw new ArgumentNullException(nameof(inKeyword));
            if (inKeyword.Kind != SyntaxKind.InKeyword) throw new ArgumentException(nameof(inKeyword));
            if (expression == null) throw new ArgumentNullException(nameof(expression));
            if (closeParenToken == null) throw new ArgumentNullException(nameof(closeParenToken));
            if (closeParenToken.Kind != SyntaxKind.CloseParenToken) throw new ArgumentException(nameof(closeParenToken));
            if (statement == null) throw new ArgumentNullException(nameof(statement));
#endif

            return new ForEachVariableStatementSyntax(SyntaxKind.ForEachVariableStatement, attributeLists.Node, awaitKeyword, forEachKeyword, openParenToken, variable, inKeyword, expression, closeParenToken, statement);
        }

        public static UsingStatementSyntax UsingStatement(Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<AttributeListSyntax> attributeLists, SyntaxToken? awaitKeyword, SyntaxToken usingKeyword, SyntaxToken openParenToken, VariableDeclarationSyntax? declaration, ExpressionSyntax? expression, SyntaxToken closeParenToken, StatementSyntax statement)
        {
#if DEBUG
            if (awaitKeyword != null)
            {
                switch (awaitKeyword.Kind)
                {
                    case SyntaxKind.AwaitKeyword:
                    case SyntaxKind.None: break;
                    default: throw new ArgumentException(nameof(awaitKeyword));
                }
            }
            if (usingKeyword == null) throw new ArgumentNullException(nameof(usingKeyword));
            if (usingKeyword.Kind != SyntaxKind.UsingKeyword) throw new ArgumentException(nameof(usingKeyword));
            if (openParenToken == null) throw new ArgumentNullException(nameof(openParenToken));
            if (openParenToken.Kind != SyntaxKind.OpenParenToken) throw new ArgumentException(nameof(openParenToken));
            if (closeParenToken == null) throw new ArgumentNullException(nameof(closeParenToken));
            if (closeParenToken.Kind != SyntaxKind.CloseParenToken) throw new ArgumentException(nameof(closeParenToken));
            if (statement == null) throw new ArgumentNullException(nameof(statement));
#endif

            return new UsingStatementSyntax(SyntaxKind.UsingStatement, attributeLists.Node, awaitKeyword, usingKeyword, openParenToken, declaration, expression, closeParenToken, statement);
        }

        public static FixedStatementSyntax FixedStatement(Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<AttributeListSyntax> attributeLists, SyntaxToken fixedKeyword, SyntaxToken openParenToken, VariableDeclarationSyntax declaration, SyntaxToken closeParenToken, StatementSyntax statement)
        {
#if DEBUG
            if (fixedKeyword == null) throw new ArgumentNullException(nameof(fixedKeyword));
            if (fixedKeyword.Kind != SyntaxKind.FixedKeyword) throw new ArgumentException(nameof(fixedKeyword));
            if (openParenToken == null) throw new ArgumentNullException(nameof(openParenToken));
            if (openParenToken.Kind != SyntaxKind.OpenParenToken) throw new ArgumentException(nameof(openParenToken));
            if (declaration == null) throw new ArgumentNullException(nameof(declaration));
            if (closeParenToken == null) throw new ArgumentNullException(nameof(closeParenToken));
            if (closeParenToken.Kind != SyntaxKind.CloseParenToken) throw new ArgumentException(nameof(closeParenToken));
            if (statement == null) throw new ArgumentNullException(nameof(statement));
#endif

            return new FixedStatementSyntax(SyntaxKind.FixedStatement, attributeLists.Node, fixedKeyword, openParenToken, declaration, closeParenToken, statement);
        }

        public static CheckedStatementSyntax CheckedStatement(SyntaxKind kind, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<AttributeListSyntax> attributeLists, SyntaxToken keyword, BlockSyntax block)
        {
            switch (kind)
            {
                case SyntaxKind.CheckedStatement:
                case SyntaxKind.UncheckedStatement: break;
                default: throw new ArgumentException(nameof(kind));
            }
#if DEBUG
            if (keyword == null) throw new ArgumentNullException(nameof(keyword));
            switch (keyword.Kind)
            {
                case SyntaxKind.CheckedKeyword:
                case SyntaxKind.UncheckedKeyword: break;
                default: throw new ArgumentException(nameof(keyword));
            }
            if (block == null) throw new ArgumentNullException(nameof(block));
#endif

            int hash;
            var cached = SyntaxNodeCache.TryGetNode((int)kind, attributeLists.Node, keyword, block, out hash);
            if (cached != null) return (CheckedStatementSyntax)cached;

            var result = new CheckedStatementSyntax(kind, attributeLists.Node, keyword, block);
            if (hash >= 0)
            {
                SyntaxNodeCache.AddNode(result, hash);
            }

            return result;
        }

        public static UnsafeStatementSyntax UnsafeStatement(Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<AttributeListSyntax> attributeLists, SyntaxToken unsafeKeyword, BlockSyntax block)
        {
#if DEBUG
            if (unsafeKeyword == null) throw new ArgumentNullException(nameof(unsafeKeyword));
            if (unsafeKeyword.Kind != SyntaxKind.UnsafeKeyword) throw new ArgumentException(nameof(unsafeKeyword));
            if (block == null) throw new ArgumentNullException(nameof(block));
#endif

            int hash;
            var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.UnsafeStatement, attributeLists.Node, unsafeKeyword, block, out hash);
            if (cached != null) return (UnsafeStatementSyntax)cached;

            var result = new UnsafeStatementSyntax(SyntaxKind.UnsafeStatement, attributeLists.Node, unsafeKeyword, block);
            if (hash >= 0)
            {
                SyntaxNodeCache.AddNode(result, hash);
            }

            return result;
        }

        public static LockStatementSyntax LockStatement(Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<AttributeListSyntax> attributeLists, SyntaxToken lockKeyword, SyntaxToken openParenToken, ExpressionSyntax expression, SyntaxToken closeParenToken, StatementSyntax statement)
        {
#if DEBUG
            if (lockKeyword == null) throw new ArgumentNullException(nameof(lockKeyword));
            if (lockKeyword.Kind != SyntaxKind.LockKeyword) throw new ArgumentException(nameof(lockKeyword));
            if (openParenToken == null) throw new ArgumentNullException(nameof(openParenToken));
            if (openParenToken.Kind != SyntaxKind.OpenParenToken) throw new ArgumentException(nameof(openParenToken));
            if (expression == null) throw new ArgumentNullException(nameof(expression));
            if (closeParenToken == null) throw new ArgumentNullException(nameof(closeParenToken));
            if (closeParenToken.Kind != SyntaxKind.CloseParenToken) throw new ArgumentException(nameof(closeParenToken));
            if (statement == null) throw new ArgumentNullException(nameof(statement));
#endif

            return new LockStatementSyntax(SyntaxKind.LockStatement, attributeLists.Node, lockKeyword, openParenToken, expression, closeParenToken, statement);
        }

        public static IfStatementSyntax IfStatement(Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<AttributeListSyntax> attributeLists, SyntaxToken ifKeyword, SyntaxToken openParenToken, ExpressionSyntax condition, SyntaxToken closeParenToken, StatementSyntax statement, ElseClauseSyntax? @else)
        {
#if DEBUG
            if (ifKeyword == null) throw new ArgumentNullException(nameof(ifKeyword));
            if (ifKeyword.Kind != SyntaxKind.IfKeyword) throw new ArgumentException(nameof(ifKeyword));
            if (openParenToken == null) throw new ArgumentNullException(nameof(openParenToken));
            if (openParenToken.Kind != SyntaxKind.OpenParenToken) throw new ArgumentException(nameof(openParenToken));
            if (condition == null) throw new ArgumentNullException(nameof(condition));
            if (closeParenToken == null) throw new ArgumentNullException(nameof(closeParenToken));
            if (closeParenToken.Kind != SyntaxKind.CloseParenToken) throw new ArgumentException(nameof(closeParenToken));
            if (statement == null) throw new ArgumentNullException(nameof(statement));
#endif

            return new IfStatementSyntax(SyntaxKind.IfStatement, attributeLists.Node, ifKeyword, openParenToken, condition, closeParenToken, statement, @else);
        }

        public static ElseClauseSyntax ElseClause(SyntaxToken elseKeyword, StatementSyntax statement)
        {
#if DEBUG
            if (elseKeyword == null) throw new ArgumentNullException(nameof(elseKeyword));
            if (elseKeyword.Kind != SyntaxKind.ElseKeyword) throw new ArgumentException(nameof(elseKeyword));
            if (statement == null) throw new ArgumentNullException(nameof(statement));
#endif

            int hash;
            var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.ElseClause, elseKeyword, statement, out hash);
            if (cached != null) return (ElseClauseSyntax)cached;

            var result = new ElseClauseSyntax(SyntaxKind.ElseClause, elseKeyword, statement);
            if (hash >= 0)
            {
                SyntaxNodeCache.AddNode(result, hash);
            }

            return result;
        }

        public static SwitchStatementSyntax SwitchStatement(Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<AttributeListSyntax> attributeLists, SyntaxToken switchKeyword, SyntaxToken? openParenToken, ExpressionSyntax expression, SyntaxToken? closeParenToken, SyntaxToken openBraceToken, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SwitchSectionSyntax> sections, SyntaxToken closeBraceToken)
        {
#if DEBUG
            if (switchKeyword == null) throw new ArgumentNullException(nameof(switchKeyword));
            if (switchKeyword.Kind != SyntaxKind.SwitchKeyword) throw new ArgumentException(nameof(switchKeyword));
            if (openParenToken != null)
            {
                switch (openParenToken.Kind)
                {
                    case SyntaxKind.OpenParenToken:
                    case SyntaxKind.None: break;
                    default: throw new ArgumentException(nameof(openParenToken));
                }
            }
            if (expression == null) throw new ArgumentNullException(nameof(expression));
            if (closeParenToken != null)
            {
                switch (closeParenToken.Kind)
                {
                    case SyntaxKind.CloseParenToken:
                    case SyntaxKind.None: break;
                    default: throw new ArgumentException(nameof(closeParenToken));
                }
            }
            if (openBraceToken == null) throw new ArgumentNullException(nameof(openBraceToken));
            if (openBraceToken.Kind != SyntaxKind.OpenBraceToken) throw new ArgumentException(nameof(openBraceToken));
            if (closeBraceToken == null) throw new ArgumentNullException(nameof(closeBraceToken));
            if (closeBraceToken.Kind != SyntaxKind.CloseBraceToken) throw new ArgumentException(nameof(closeBraceToken));
#endif

            return new SwitchStatementSyntax(SyntaxKind.SwitchStatement, attributeLists.Node, switchKeyword, openParenToken, expression, closeParenToken, openBraceToken, sections.Node, closeBraceToken);
        }

        public static SwitchSectionSyntax SwitchSection(Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SwitchLabelSyntax> labels, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<StatementSyntax> statements)
        {
#if DEBUG
#endif

            int hash;
            var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.SwitchSection, labels.Node, statements.Node, out hash);
            if (cached != null) return (SwitchSectionSyntax)cached;

            var result = new SwitchSectionSyntax(SyntaxKind.SwitchSection, labels.Node, statements.Node);
            if (hash >= 0)
            {
                SyntaxNodeCache.AddNode(result, hash);
            }

            return result;
        }

        public static CasePatternSwitchLabelSyntax CasePatternSwitchLabel(SyntaxToken keyword, PatternSyntax pattern, WhenClauseSyntax? whenClause, SyntaxToken colonToken)
        {
#if DEBUG
            if (keyword == null) throw new ArgumentNullException(nameof(keyword));
            if (keyword.Kind != SyntaxKind.CaseKeyword) throw new ArgumentException(nameof(keyword));
            if (pattern == null) throw new ArgumentNullException(nameof(pattern));
            if (colonToken == null) throw new ArgumentNullException(nameof(colonToken));
#endif

            return new CasePatternSwitchLabelSyntax(SyntaxKind.CasePatternSwitchLabel, keyword, pattern, whenClause, colonToken);
        }

        public static CaseSwitchLabelSyntax CaseSwitchLabel(SyntaxToken keyword, ExpressionSyntax value, SyntaxToken colonToken)
        {
#if DEBUG
            if (keyword == null) throw new ArgumentNullException(nameof(keyword));
            if (keyword.Kind != SyntaxKind.CaseKeyword) throw new ArgumentException(nameof(keyword));
            if (value == null) throw new ArgumentNullException(nameof(value));
            if (colonToken == null) throw new ArgumentNullException(nameof(colonToken));
#endif

            int hash;
            var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.CaseSwitchLabel, keyword, value, colonToken, out hash);
            if (cached != null) return (CaseSwitchLabelSyntax)cached;

            var result = new CaseSwitchLabelSyntax(SyntaxKind.CaseSwitchLabel, keyword, value, colonToken);
            if (hash >= 0)
            {
                SyntaxNodeCache.AddNode(result, hash);
            }

            return result;
        }

        public static DefaultSwitchLabelSyntax DefaultSwitchLabel(SyntaxToken keyword, SyntaxToken colonToken)
        {
#if DEBUG
            if (keyword == null) throw new ArgumentNullException(nameof(keyword));
            if (keyword.Kind != SyntaxKind.DefaultKeyword) throw new ArgumentException(nameof(keyword));
            if (colonToken == null) throw new ArgumentNullException(nameof(colonToken));
#endif

            int hash;
            var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.DefaultSwitchLabel, keyword, colonToken, out hash);
            if (cached != null) return (DefaultSwitchLabelSyntax)cached;

            var result = new DefaultSwitchLabelSyntax(SyntaxKind.DefaultSwitchLabel, keyword, colonToken);
            if (hash >= 0)
            {
                SyntaxNodeCache.AddNode(result, hash);
            }

            return result;
        }

        public static SwitchExpressionSyntax SwitchExpression(ExpressionSyntax governingExpression, SyntaxToken switchKeyword, SyntaxToken openBraceToken, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<SwitchExpressionArmSyntax> arms, SyntaxToken closeBraceToken)
        {
#if DEBUG
            if (governingExpression == null) throw new ArgumentNullException(nameof(governingExpression));
            if (switchKeyword == null) throw new ArgumentNullException(nameof(switchKeyword));
            if (switchKeyword.Kind != SyntaxKind.SwitchKeyword) throw new ArgumentException(nameof(switchKeyword));
            if (openBraceToken == null) throw new ArgumentNullException(nameof(openBraceToken));
            if (openBraceToken.Kind != SyntaxKind.OpenBraceToken) throw new ArgumentException(nameof(openBraceToken));
            if (closeBraceToken == null) throw new ArgumentNullException(nameof(closeBraceToken));
            if (closeBraceToken.Kind != SyntaxKind.CloseBraceToken) throw new ArgumentException(nameof(closeBraceToken));
#endif

            return new SwitchExpressionSyntax(SyntaxKind.SwitchExpression, governingExpression, switchKeyword, openBraceToken, arms.Node, closeBraceToken);
        }

        public static SwitchExpressionArmSyntax SwitchExpressionArm(PatternSyntax pattern, WhenClauseSyntax? whenClause, SyntaxToken equalsGreaterThanToken, ExpressionSyntax expression)
        {
#if DEBUG
            if (pattern == null) throw new ArgumentNullException(nameof(pattern));
            if (equalsGreaterThanToken == null) throw new ArgumentNullException(nameof(equalsGreaterThanToken));
            if (equalsGreaterThanToken.Kind != SyntaxKind.EqualsGreaterThanToken) throw new ArgumentException(nameof(equalsGreaterThanToken));
            if (expression == null) throw new ArgumentNullException(nameof(expression));
#endif

            return new SwitchExpressionArmSyntax(SyntaxKind.SwitchExpressionArm, pattern, whenClause, equalsGreaterThanToken, expression);
        }

        public static TryStatementSyntax TryStatement(Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<AttributeListSyntax> attributeLists, SyntaxToken tryKeyword, BlockSyntax block, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<CatchClauseSyntax> catches, FinallyClauseSyntax? @finally)
        {
#if DEBUG
            if (tryKeyword == null) throw new ArgumentNullException(nameof(tryKeyword));
            if (tryKeyword.Kind != SyntaxKind.TryKeyword) throw new ArgumentException(nameof(tryKeyword));
            if (block == null) throw new ArgumentNullException(nameof(block));
#endif

            return new TryStatementSyntax(SyntaxKind.TryStatement, attributeLists.Node, tryKeyword, block, catches.Node, @finally);
        }

        public static CatchClauseSyntax CatchClause(SyntaxToken catchKeyword, CatchDeclarationSyntax? declaration, CatchFilterClauseSyntax? filter, BlockSyntax block)
        {
#if DEBUG
            if (catchKeyword == null) throw new ArgumentNullException(nameof(catchKeyword));
            if (catchKeyword.Kind != SyntaxKind.CatchKeyword) throw new ArgumentException(nameof(catchKeyword));
            if (block == null) throw new ArgumentNullException(nameof(block));
#endif

            return new CatchClauseSyntax(SyntaxKind.CatchClause, catchKeyword, declaration, filter, block);
        }

        public static CatchDeclarationSyntax CatchDeclaration(SyntaxToken openParenToken, TypeSyntax type, SyntaxToken? identifier, SyntaxToken closeParenToken)
        {
#if DEBUG
            if (openParenToken == null) throw new ArgumentNullException(nameof(openParenToken));
            if (openParenToken.Kind != SyntaxKind.OpenParenToken) throw new ArgumentException(nameof(openParenToken));
            if (type == null) throw new ArgumentNullException(nameof(type));
            if (identifier != null)
            {
                switch (identifier.Kind)
                {
                    case SyntaxKind.IdentifierToken:
                    case SyntaxKind.None: break;
                    default: throw new ArgumentException(nameof(identifier));
                }
            }
            if (closeParenToken == null) throw new ArgumentNullException(nameof(closeParenToken));
            if (closeParenToken.Kind != SyntaxKind.CloseParenToken) throw new ArgumentException(nameof(closeParenToken));
#endif

            return new CatchDeclarationSyntax(SyntaxKind.CatchDeclaration, openParenToken, type, identifier, closeParenToken);
        }

        public static CatchFilterClauseSyntax CatchFilterClause(SyntaxToken whenKeyword, SyntaxToken openParenToken, ExpressionSyntax filterExpression, SyntaxToken closeParenToken)
        {
#if DEBUG
            if (whenKeyword == null) throw new ArgumentNullException(nameof(whenKeyword));
            if (whenKeyword.Kind != SyntaxKind.WhenKeyword) throw new ArgumentException(nameof(whenKeyword));
            if (openParenToken == null) throw new ArgumentNullException(nameof(openParenToken));
            if (openParenToken.Kind != SyntaxKind.OpenParenToken) throw new ArgumentException(nameof(openParenToken));
            if (filterExpression == null) throw new ArgumentNullException(nameof(filterExpression));
            if (closeParenToken == null) throw new ArgumentNullException(nameof(closeParenToken));
            if (closeParenToken.Kind != SyntaxKind.CloseParenToken) throw new ArgumentException(nameof(closeParenToken));
#endif

            return new CatchFilterClauseSyntax(SyntaxKind.CatchFilterClause, whenKeyword, openParenToken, filterExpression, closeParenToken);
        }

        public static FinallyClauseSyntax FinallyClause(SyntaxToken finallyKeyword, BlockSyntax block)
        {
#if DEBUG
            if (finallyKeyword == null) throw new ArgumentNullException(nameof(finallyKeyword));
            if (finallyKeyword.Kind != SyntaxKind.FinallyKeyword) throw new ArgumentException(nameof(finallyKeyword));
            if (block == null) throw new ArgumentNullException(nameof(block));
#endif

            int hash;
            var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.FinallyClause, finallyKeyword, block, out hash);
            if (cached != null) return (FinallyClauseSyntax)cached;

            var result = new FinallyClauseSyntax(SyntaxKind.FinallyClause, finallyKeyword, block);
            if (hash >= 0)
            {
                SyntaxNodeCache.AddNode(result, hash);
            }

            return result;
        }

        public static CompilationUnitSyntax CompilationUnit(Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<ExternAliasDirectiveSyntax> externs, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<UsingDirectiveSyntax> usings, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<AttributeListSyntax> attributeLists, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<MemberDeclarationSyntax> members, SyntaxToken endOfFileToken)
        {
#if DEBUG
            if (endOfFileToken == null) throw new ArgumentNullException(nameof(endOfFileToken));
            if (endOfFileToken.Kind != SyntaxKind.EndOfFileToken) throw new ArgumentException(nameof(endOfFileToken));
#endif

            return new CompilationUnitSyntax(SyntaxKind.CompilationUnit, externs.Node, usings.Node, attributeLists.Node, members.Node, endOfFileToken);
        }

        public static ExternAliasDirectiveSyntax ExternAliasDirective(SyntaxToken externKeyword, SyntaxToken aliasKeyword, SyntaxToken identifier, SyntaxToken semicolonToken)
        {
#if DEBUG
            if (externKeyword == null) throw new ArgumentNullException(nameof(externKeyword));
            if (externKeyword.Kind != SyntaxKind.ExternKeyword) throw new ArgumentException(nameof(externKeyword));
            if (aliasKeyword == null) throw new ArgumentNullException(nameof(aliasKeyword));
            if (aliasKeyword.Kind != SyntaxKind.AliasKeyword) throw new ArgumentException(nameof(aliasKeyword));
            if (identifier == null) throw new ArgumentNullException(nameof(identifier));
            if (identifier.Kind != SyntaxKind.IdentifierToken) throw new ArgumentException(nameof(identifier));
            if (semicolonToken == null) throw new ArgumentNullException(nameof(semicolonToken));
            if (semicolonToken.Kind != SyntaxKind.SemicolonToken) throw new ArgumentException(nameof(semicolonToken));
#endif

            return new ExternAliasDirectiveSyntax(SyntaxKind.ExternAliasDirective, externKeyword, aliasKeyword, identifier, semicolonToken);
        }

        public static UsingDirectiveSyntax UsingDirective(SyntaxToken usingKeyword, SyntaxToken? staticKeyword, NameEqualsSyntax? alias, NameSyntax name, SyntaxToken semicolonToken)
        {
#if DEBUG
            if (usingKeyword == null) throw new ArgumentNullException(nameof(usingKeyword));
            if (usingKeyword.Kind != SyntaxKind.UsingKeyword) throw new ArgumentException(nameof(usingKeyword));
            if (name == null) throw new ArgumentNullException(nameof(name));
            if (semicolonToken == null) throw new ArgumentNullException(nameof(semicolonToken));
            if (semicolonToken.Kind != SyntaxKind.SemicolonToken) throw new ArgumentException(nameof(semicolonToken));
#endif

            return new UsingDirectiveSyntax(SyntaxKind.UsingDirective, usingKeyword, staticKeyword, alias, name, semicolonToken);
        }

        public static NamespaceDeclarationSyntax NamespaceDeclaration(Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<AttributeListSyntax> attributeLists, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SyntaxToken> modifiers, SyntaxToken namespaceKeyword, NameSyntax name, SyntaxToken openBraceToken, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<ExternAliasDirectiveSyntax> externs, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<UsingDirectiveSyntax> usings, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<MemberDeclarationSyntax> members, SyntaxToken closeBraceToken, SyntaxToken? semicolonToken)
        {
#if DEBUG
            if (namespaceKeyword == null) throw new ArgumentNullException(nameof(namespaceKeyword));
            if (namespaceKeyword.Kind != SyntaxKind.NamespaceKeyword) throw new ArgumentException(nameof(namespaceKeyword));
            if (name == null) throw new ArgumentNullException(nameof(name));
            if (openBraceToken == null) throw new ArgumentNullException(nameof(openBraceToken));
            if (openBraceToken.Kind != SyntaxKind.OpenBraceToken) throw new ArgumentException(nameof(openBraceToken));
            if (closeBraceToken == null) throw new ArgumentNullException(nameof(closeBraceToken));
            if (closeBraceToken.Kind != SyntaxKind.CloseBraceToken) throw new ArgumentException(nameof(closeBraceToken));
            if (semicolonToken != null)
            {
                switch (semicolonToken.Kind)
                {
                    case SyntaxKind.SemicolonToken:
                    case SyntaxKind.None: break;
                    default: throw new ArgumentException(nameof(semicolonToken));
                }
            }
#endif

            return new NamespaceDeclarationSyntax(SyntaxKind.NamespaceDeclaration, attributeLists.Node, modifiers.Node, namespaceKeyword, name, openBraceToken, externs.Node, usings.Node, members.Node, closeBraceToken, semicolonToken);
        }

        public static AttributeListSyntax AttributeList(SyntaxToken openBracketToken, AttributeTargetSpecifierSyntax? target, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<AttributeSyntax> attributes, SyntaxToken closeBracketToken)
        {
#if DEBUG
            if (openBracketToken == null) throw new ArgumentNullException(nameof(openBracketToken));
            if (openBracketToken.Kind != SyntaxKind.OpenBracketToken) throw new ArgumentException(nameof(openBracketToken));
            if (closeBracketToken == null) throw new ArgumentNullException(nameof(closeBracketToken));
            if (closeBracketToken.Kind != SyntaxKind.CloseBracketToken) throw new ArgumentException(nameof(closeBracketToken));
#endif

            return new AttributeListSyntax(SyntaxKind.AttributeList, openBracketToken, target, attributes.Node, closeBracketToken);
        }

        public static AttributeTargetSpecifierSyntax AttributeTargetSpecifier(SyntaxToken identifier, SyntaxToken colonToken)
        {
#if DEBUG
            if (identifier == null) throw new ArgumentNullException(nameof(identifier));
            if (colonToken == null) throw new ArgumentNullException(nameof(colonToken));
            if (colonToken.Kind != SyntaxKind.ColonToken) throw new ArgumentException(nameof(colonToken));
#endif

            int hash;
            var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.AttributeTargetSpecifier, identifier, colonToken, out hash);
            if (cached != null) return (AttributeTargetSpecifierSyntax)cached;

            var result = new AttributeTargetSpecifierSyntax(SyntaxKind.AttributeTargetSpecifier, identifier, colonToken);
            if (hash >= 0)
            {
                SyntaxNodeCache.AddNode(result, hash);
            }

            return result;
        }

        public static AttributeSyntax Attribute(NameSyntax name, AttributeArgumentListSyntax? argumentList)
        {
#if DEBUG
            if (name == null) throw new ArgumentNullException(nameof(name));
#endif

            int hash;
            var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.Attribute, name, argumentList, out hash);
            if (cached != null) return (AttributeSyntax)cached;

            var result = new AttributeSyntax(SyntaxKind.Attribute, name, argumentList);
            if (hash >= 0)
            {
                SyntaxNodeCache.AddNode(result, hash);
            }

            return result;
        }

        public static AttributeArgumentListSyntax AttributeArgumentList(SyntaxToken openParenToken, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<AttributeArgumentSyntax> arguments, SyntaxToken closeParenToken)
        {
#if DEBUG
            if (openParenToken == null) throw new ArgumentNullException(nameof(openParenToken));
            if (openParenToken.Kind != SyntaxKind.OpenParenToken) throw new ArgumentException(nameof(openParenToken));
            if (closeParenToken == null) throw new ArgumentNullException(nameof(closeParenToken));
            if (closeParenToken.Kind != SyntaxKind.CloseParenToken) throw new ArgumentException(nameof(closeParenToken));
#endif

            int hash;
            var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.AttributeArgumentList, openParenToken, arguments.Node, closeParenToken, out hash);
            if (cached != null) return (AttributeArgumentListSyntax)cached;

            var result = new AttributeArgumentListSyntax(SyntaxKind.AttributeArgumentList, openParenToken, arguments.Node, closeParenToken);
            if (hash >= 0)
            {
                SyntaxNodeCache.AddNode(result, hash);
            }

            return result;
        }

        public static AttributeArgumentSyntax AttributeArgument(NameEqualsSyntax? nameEquals, NameColonSyntax? nameColon, ExpressionSyntax expression)
        {
#if DEBUG
            if (expression == null) throw new ArgumentNullException(nameof(expression));
#endif

            int hash;
            var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.AttributeArgument, nameEquals, nameColon, expression, out hash);
            if (cached != null) return (AttributeArgumentSyntax)cached;

            var result = new AttributeArgumentSyntax(SyntaxKind.AttributeArgument, nameEquals, nameColon, expression);
            if (hash >= 0)
            {
                SyntaxNodeCache.AddNode(result, hash);
            }

            return result;
        }

        public static NameEqualsSyntax NameEquals(IdentifierNameSyntax name, SyntaxToken equalsToken)
        {
#if DEBUG
            if (name == null) throw new ArgumentNullException(nameof(name));
            if (equalsToken == null) throw new ArgumentNullException(nameof(equalsToken));
            if (equalsToken.Kind != SyntaxKind.EqualsToken) throw new ArgumentException(nameof(equalsToken));
#endif

            int hash;
            var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.NameEquals, name, equalsToken, out hash);
            if (cached != null) return (NameEqualsSyntax)cached;

            var result = new NameEqualsSyntax(SyntaxKind.NameEquals, name, equalsToken);
            if (hash >= 0)
            {
                SyntaxNodeCache.AddNode(result, hash);
            }

            return result;
        }

        public static TypeParameterListSyntax TypeParameterList(SyntaxToken lessThanToken, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<TypeParameterSyntax> parameters, SyntaxToken greaterThanToken)
        {
#if DEBUG
            if (lessThanToken == null) throw new ArgumentNullException(nameof(lessThanToken));
            if (lessThanToken.Kind != SyntaxKind.LessThanToken) throw new ArgumentException(nameof(lessThanToken));
            if (greaterThanToken == null) throw new ArgumentNullException(nameof(greaterThanToken));
            if (greaterThanToken.Kind != SyntaxKind.GreaterThanToken) throw new ArgumentException(nameof(greaterThanToken));
#endif

            int hash;
            var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.TypeParameterList, lessThanToken, parameters.Node, greaterThanToken, out hash);
            if (cached != null) return (TypeParameterListSyntax)cached;

            var result = new TypeParameterListSyntax(SyntaxKind.TypeParameterList, lessThanToken, parameters.Node, greaterThanToken);
            if (hash >= 0)
            {
                SyntaxNodeCache.AddNode(result, hash);
            }

            return result;
        }

        public static TypeParameterSyntax TypeParameter(Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<AttributeListSyntax> attributeLists, SyntaxToken? varianceKeyword, SyntaxToken identifier)
        {
#if DEBUG
            if (varianceKeyword != null)
            {
                switch (varianceKeyword.Kind)
                {
                    case SyntaxKind.InKeyword:
                    case SyntaxKind.OutKeyword:
                    case SyntaxKind.None: break;
                    default: throw new ArgumentException(nameof(varianceKeyword));
                }
            }
            if (identifier == null) throw new ArgumentNullException(nameof(identifier));
            if (identifier.Kind != SyntaxKind.IdentifierToken) throw new ArgumentException(nameof(identifier));
#endif

            int hash;
            var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.TypeParameter, attributeLists.Node, varianceKeyword, identifier, out hash);
            if (cached != null) return (TypeParameterSyntax)cached;

            var result = new TypeParameterSyntax(SyntaxKind.TypeParameter, attributeLists.Node, varianceKeyword, identifier);
            if (hash >= 0)
            {
                SyntaxNodeCache.AddNode(result, hash);
            }

            return result;
        }

        public static ClassDeclarationSyntax ClassDeclaration(Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<AttributeListSyntax> attributeLists, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SyntaxToken> modifiers, SyntaxToken keyword, SyntaxToken identifier, TypeParameterListSyntax? typeParameterList, BaseListSyntax? baseList, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<TypeParameterConstraintClauseSyntax> constraintClauses, SyntaxToken openBraceToken, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<MemberDeclarationSyntax> members, SyntaxToken closeBraceToken, SyntaxToken? semicolonToken)
        {
#if DEBUG
            if (keyword == null) throw new ArgumentNullException(nameof(keyword));
            if (keyword.Kind != SyntaxKind.ClassKeyword) throw new ArgumentException(nameof(keyword));
            if (identifier == null) throw new ArgumentNullException(nameof(identifier));
            if (identifier.Kind != SyntaxKind.IdentifierToken) throw new ArgumentException(nameof(identifier));
            if (openBraceToken == null) throw new ArgumentNullException(nameof(openBraceToken));
            if (openBraceToken.Kind != SyntaxKind.OpenBraceToken) throw new ArgumentException(nameof(openBraceToken));
            if (closeBraceToken == null) throw new ArgumentNullException(nameof(closeBraceToken));
            if (closeBraceToken.Kind != SyntaxKind.CloseBraceToken) throw new ArgumentException(nameof(closeBraceToken));
            if (semicolonToken != null)
            {
                switch (semicolonToken.Kind)
                {
                    case SyntaxKind.SemicolonToken:
                    case SyntaxKind.None: break;
                    default: throw new ArgumentException(nameof(semicolonToken));
                }
            }
#endif

            return new ClassDeclarationSyntax(SyntaxKind.ClassDeclaration, attributeLists.Node, modifiers.Node, keyword, identifier, typeParameterList, baseList, constraintClauses.Node, openBraceToken, members.Node, closeBraceToken, semicolonToken);
        }

        public static StructDeclarationSyntax StructDeclaration(Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<AttributeListSyntax> attributeLists, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SyntaxToken> modifiers, SyntaxToken keyword, SyntaxToken identifier, TypeParameterListSyntax? typeParameterList, BaseListSyntax? baseList, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<TypeParameterConstraintClauseSyntax> constraintClauses, SyntaxToken openBraceToken, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<MemberDeclarationSyntax> members, SyntaxToken closeBraceToken, SyntaxToken? semicolonToken)
        {
#if DEBUG
            if (keyword == null) throw new ArgumentNullException(nameof(keyword));
            if (keyword.Kind != SyntaxKind.StructKeyword) throw new ArgumentException(nameof(keyword));
            if (identifier == null) throw new ArgumentNullException(nameof(identifier));
            if (identifier.Kind != SyntaxKind.IdentifierToken) throw new ArgumentException(nameof(identifier));
            if (openBraceToken == null) throw new ArgumentNullException(nameof(openBraceToken));
            if (openBraceToken.Kind != SyntaxKind.OpenBraceToken) throw new ArgumentException(nameof(openBraceToken));
            if (closeBraceToken == null) throw new ArgumentNullException(nameof(closeBraceToken));
            if (closeBraceToken.Kind != SyntaxKind.CloseBraceToken) throw new ArgumentException(nameof(closeBraceToken));
            if (semicolonToken != null)
            {
                switch (semicolonToken.Kind)
                {
                    case SyntaxKind.SemicolonToken:
                    case SyntaxKind.None: break;
                    default: throw new ArgumentException(nameof(semicolonToken));
                }
            }
#endif

            return new StructDeclarationSyntax(SyntaxKind.StructDeclaration, attributeLists.Node, modifiers.Node, keyword, identifier, typeParameterList, baseList, constraintClauses.Node, openBraceToken, members.Node, closeBraceToken, semicolonToken);
        }

        public static InterfaceDeclarationSyntax InterfaceDeclaration(Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<AttributeListSyntax> attributeLists, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SyntaxToken> modifiers, SyntaxToken keyword, SyntaxToken identifier, TypeParameterListSyntax? typeParameterList, BaseListSyntax? baseList, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<TypeParameterConstraintClauseSyntax> constraintClauses, SyntaxToken openBraceToken, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<MemberDeclarationSyntax> members, SyntaxToken closeBraceToken, SyntaxToken? semicolonToken)
        {
#if DEBUG
            if (keyword == null) throw new ArgumentNullException(nameof(keyword));
            if (keyword.Kind != SyntaxKind.InterfaceKeyword) throw new ArgumentException(nameof(keyword));
            if (identifier == null) throw new ArgumentNullException(nameof(identifier));
            if (identifier.Kind != SyntaxKind.IdentifierToken) throw new ArgumentException(nameof(identifier));
            if (openBraceToken == null) throw new ArgumentNullException(nameof(openBraceToken));
            if (openBraceToken.Kind != SyntaxKind.OpenBraceToken) throw new ArgumentException(nameof(openBraceToken));
            if (closeBraceToken == null) throw new ArgumentNullException(nameof(closeBraceToken));
            if (closeBraceToken.Kind != SyntaxKind.CloseBraceToken) throw new ArgumentException(nameof(closeBraceToken));
            if (semicolonToken != null)
            {
                switch (semicolonToken.Kind)
                {
                    case SyntaxKind.SemicolonToken:
                    case SyntaxKind.None: break;
                    default: throw new ArgumentException(nameof(semicolonToken));
                }
            }
#endif

            return new InterfaceDeclarationSyntax(SyntaxKind.InterfaceDeclaration, attributeLists.Node, modifiers.Node, keyword, identifier, typeParameterList, baseList, constraintClauses.Node, openBraceToken, members.Node, closeBraceToken, semicolonToken);
        }

        public static RecordDeclarationSyntax RecordDeclaration(Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<AttributeListSyntax> attributeLists, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SyntaxToken> modifiers, SyntaxToken keyword, SyntaxToken identifier, TypeParameterListSyntax? typeParameterList, ParameterListSyntax? parameterList, BaseListSyntax? baseList, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<TypeParameterConstraintClauseSyntax> constraintClauses, SyntaxToken? openBraceToken, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<MemberDeclarationSyntax> members, SyntaxToken? closeBraceToken, SyntaxToken? semicolonToken)
        {
#if DEBUG
            if (keyword == null) throw new ArgumentNullException(nameof(keyword));
            if (identifier == null) throw new ArgumentNullException(nameof(identifier));
            if (identifier.Kind != SyntaxKind.IdentifierToken) throw new ArgumentException(nameof(identifier));
            if (openBraceToken != null)
            {
                switch (openBraceToken.Kind)
                {
                    case SyntaxKind.OpenBraceToken:
                    case SyntaxKind.None: break;
                    default: throw new ArgumentException(nameof(openBraceToken));
                }
            }
            if (closeBraceToken != null)
            {
                switch (closeBraceToken.Kind)
                {
                    case SyntaxKind.CloseBraceToken:
                    case SyntaxKind.None: break;
                    default: throw new ArgumentException(nameof(closeBraceToken));
                }
            }
            if (semicolonToken != null)
            {
                switch (semicolonToken.Kind)
                {
                    case SyntaxKind.SemicolonToken:
                    case SyntaxKind.None: break;
                    default: throw new ArgumentException(nameof(semicolonToken));
                }
            }
#endif

            return new RecordDeclarationSyntax(SyntaxKind.RecordDeclaration, attributeLists.Node, modifiers.Node, keyword, identifier, typeParameterList, parameterList, baseList, constraintClauses.Node, openBraceToken, members.Node, closeBraceToken, semicolonToken);
        }

        public static EnumDeclarationSyntax EnumDeclaration(Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<AttributeListSyntax> attributeLists, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SyntaxToken> modifiers, SyntaxToken enumKeyword, SyntaxToken identifier, BaseListSyntax? baseList, SyntaxToken openBraceToken, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<EnumMemberDeclarationSyntax> members, SyntaxToken closeBraceToken, SyntaxToken? semicolonToken)
        {
#if DEBUG
            if (enumKeyword == null) throw new ArgumentNullException(nameof(enumKeyword));
            if (enumKeyword.Kind != SyntaxKind.EnumKeyword) throw new ArgumentException(nameof(enumKeyword));
            if (identifier == null) throw new ArgumentNullException(nameof(identifier));
            if (identifier.Kind != SyntaxKind.IdentifierToken) throw new ArgumentException(nameof(identifier));
            if (openBraceToken == null) throw new ArgumentNullException(nameof(openBraceToken));
            if (openBraceToken.Kind != SyntaxKind.OpenBraceToken) throw new ArgumentException(nameof(openBraceToken));
            if (closeBraceToken == null) throw new ArgumentNullException(nameof(closeBraceToken));
            if (closeBraceToken.Kind != SyntaxKind.CloseBraceToken) throw new ArgumentException(nameof(closeBraceToken));
            if (semicolonToken != null)
            {
                switch (semicolonToken.Kind)
                {
                    case SyntaxKind.SemicolonToken:
                    case SyntaxKind.None: break;
                    default: throw new ArgumentException(nameof(semicolonToken));
                }
            }
#endif

            return new EnumDeclarationSyntax(SyntaxKind.EnumDeclaration, attributeLists.Node, modifiers.Node, enumKeyword, identifier, baseList, openBraceToken, members.Node, closeBraceToken, semicolonToken);
        }

        public static DelegateDeclarationSyntax DelegateDeclaration(Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<AttributeListSyntax> attributeLists, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SyntaxToken> modifiers, SyntaxToken delegateKeyword, TypeSyntax returnType, SyntaxToken identifier, TypeParameterListSyntax? typeParameterList, ParameterListSyntax parameterList, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<TypeParameterConstraintClauseSyntax> constraintClauses, SyntaxToken semicolonToken)
        {
#if DEBUG
            if (delegateKeyword == null) throw new ArgumentNullException(nameof(delegateKeyword));
            if (delegateKeyword.Kind != SyntaxKind.DelegateKeyword) throw new ArgumentException(nameof(delegateKeyword));
            if (returnType == null) throw new ArgumentNullException(nameof(returnType));
            if (identifier == null) throw new ArgumentNullException(nameof(identifier));
            if (identifier.Kind != SyntaxKind.IdentifierToken) throw new ArgumentException(nameof(identifier));
            if (parameterList == null) throw new ArgumentNullException(nameof(parameterList));
            if (semicolonToken == null) throw new ArgumentNullException(nameof(semicolonToken));
            if (semicolonToken.Kind != SyntaxKind.SemicolonToken) throw new ArgumentException(nameof(semicolonToken));
#endif

            return new DelegateDeclarationSyntax(SyntaxKind.DelegateDeclaration, attributeLists.Node, modifiers.Node, delegateKeyword, returnType, identifier, typeParameterList, parameterList, constraintClauses.Node, semicolonToken);
        }

        public static EnumMemberDeclarationSyntax EnumMemberDeclaration(Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<AttributeListSyntax> attributeLists, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SyntaxToken> modifiers, SyntaxToken identifier, EqualsValueClauseSyntax? equalsValue)
        {
#if DEBUG
            if (identifier == null) throw new ArgumentNullException(nameof(identifier));
            if (identifier.Kind != SyntaxKind.IdentifierToken) throw new ArgumentException(nameof(identifier));
#endif

            return new EnumMemberDeclarationSyntax(SyntaxKind.EnumMemberDeclaration, attributeLists.Node, modifiers.Node, identifier, equalsValue);
        }

        public static BaseListSyntax BaseList(SyntaxToken colonToken, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<BaseTypeSyntax> types)
        {
#if DEBUG
            if (colonToken == null) throw new ArgumentNullException(nameof(colonToken));
            if (colonToken.Kind != SyntaxKind.ColonToken) throw new ArgumentException(nameof(colonToken));
#endif

            int hash;
            var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.BaseList, colonToken, types.Node, out hash);
            if (cached != null) return (BaseListSyntax)cached;

            var result = new BaseListSyntax(SyntaxKind.BaseList, colonToken, types.Node);
            if (hash >= 0)
            {
                SyntaxNodeCache.AddNode(result, hash);
            }

            return result;
        }

        public static SimpleBaseTypeSyntax SimpleBaseType(TypeSyntax type)
        {
#if DEBUG
            if (type == null) throw new ArgumentNullException(nameof(type));
#endif

            int hash;
            var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.SimpleBaseType, type, out hash);
            if (cached != null) return (SimpleBaseTypeSyntax)cached;

            var result = new SimpleBaseTypeSyntax(SyntaxKind.SimpleBaseType, type);
            if (hash >= 0)
            {
                SyntaxNodeCache.AddNode(result, hash);
            }

            return result;
        }

        public static PrimaryConstructorBaseTypeSyntax PrimaryConstructorBaseType(TypeSyntax type, ArgumentListSyntax argumentList)
        {
#if DEBUG
            if (type == null) throw new ArgumentNullException(nameof(type));
            if (argumentList == null) throw new ArgumentNullException(nameof(argumentList));
#endif

            int hash;
            var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.PrimaryConstructorBaseType, type, argumentList, out hash);
            if (cached != null) return (PrimaryConstructorBaseTypeSyntax)cached;

            var result = new PrimaryConstructorBaseTypeSyntax(SyntaxKind.PrimaryConstructorBaseType, type, argumentList);
            if (hash >= 0)
            {
                SyntaxNodeCache.AddNode(result, hash);
            }

            return result;
        }

        public static TypeParameterConstraintClauseSyntax TypeParameterConstraintClause(SyntaxToken whereKeyword, IdentifierNameSyntax name, SyntaxToken colonToken, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<TypeParameterConstraintSyntax> constraints)
        {
#if DEBUG
            if (whereKeyword == null) throw new ArgumentNullException(nameof(whereKeyword));
            if (whereKeyword.Kind != SyntaxKind.WhereKeyword) throw new ArgumentException(nameof(whereKeyword));
            if (name == null) throw new ArgumentNullException(nameof(name));
            if (colonToken == null) throw new ArgumentNullException(nameof(colonToken));
            if (colonToken.Kind != SyntaxKind.ColonToken) throw new ArgumentException(nameof(colonToken));
#endif

            return new TypeParameterConstraintClauseSyntax(SyntaxKind.TypeParameterConstraintClause, whereKeyword, name, colonToken, constraints.Node);
        }

        public static ConstructorConstraintSyntax ConstructorConstraint(SyntaxToken newKeyword, SyntaxToken openParenToken, SyntaxToken closeParenToken)
        {
#if DEBUG
            if (newKeyword == null) throw new ArgumentNullException(nameof(newKeyword));
            if (newKeyword.Kind != SyntaxKind.NewKeyword) throw new ArgumentException(nameof(newKeyword));
            if (openParenToken == null) throw new ArgumentNullException(nameof(openParenToken));
            if (openParenToken.Kind != SyntaxKind.OpenParenToken) throw new ArgumentException(nameof(openParenToken));
            if (closeParenToken == null) throw new ArgumentNullException(nameof(closeParenToken));
            if (closeParenToken.Kind != SyntaxKind.CloseParenToken) throw new ArgumentException(nameof(closeParenToken));
#endif

            int hash;
            var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.ConstructorConstraint, newKeyword, openParenToken, closeParenToken, out hash);
            if (cached != null) return (ConstructorConstraintSyntax)cached;

            var result = new ConstructorConstraintSyntax(SyntaxKind.ConstructorConstraint, newKeyword, openParenToken, closeParenToken);
            if (hash >= 0)
            {
                SyntaxNodeCache.AddNode(result, hash);
            }

            return result;
        }

        public static ClassOrStructConstraintSyntax ClassOrStructConstraint(SyntaxKind kind, SyntaxToken classOrStructKeyword, SyntaxToken? questionToken)
        {
            switch (kind)
            {
                case SyntaxKind.ClassConstraint:
                case SyntaxKind.StructConstraint: break;
                default: throw new ArgumentException(nameof(kind));
            }
#if DEBUG
            if (classOrStructKeyword == null) throw new ArgumentNullException(nameof(classOrStructKeyword));
            switch (classOrStructKeyword.Kind)
            {
                case SyntaxKind.ClassKeyword:
                case SyntaxKind.StructKeyword: break;
                default: throw new ArgumentException(nameof(classOrStructKeyword));
            }
            if (questionToken != null)
            {
                switch (questionToken.Kind)
                {
                    case SyntaxKind.QuestionToken:
                    case SyntaxKind.None: break;
                    default: throw new ArgumentException(nameof(questionToken));
                }
            }
#endif

            int hash;
            var cached = SyntaxNodeCache.TryGetNode((int)kind, classOrStructKeyword, questionToken, out hash);
            if (cached != null) return (ClassOrStructConstraintSyntax)cached;

            var result = new ClassOrStructConstraintSyntax(kind, classOrStructKeyword, questionToken);
            if (hash >= 0)
            {
                SyntaxNodeCache.AddNode(result, hash);
            }

            return result;
        }

        public static TypeConstraintSyntax TypeConstraint(TypeSyntax type)
        {
#if DEBUG
            if (type == null) throw new ArgumentNullException(nameof(type));
#endif

            int hash;
            var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.TypeConstraint, type, out hash);
            if (cached != null) return (TypeConstraintSyntax)cached;

            var result = new TypeConstraintSyntax(SyntaxKind.TypeConstraint, type);
            if (hash >= 0)
            {
                SyntaxNodeCache.AddNode(result, hash);
            }

            return result;
        }

        public static DefaultConstraintSyntax DefaultConstraint(SyntaxToken defaultKeyword)
        {
#if DEBUG
            if (defaultKeyword == null) throw new ArgumentNullException(nameof(defaultKeyword));
            if (defaultKeyword.Kind != SyntaxKind.DefaultKeyword) throw new ArgumentException(nameof(defaultKeyword));
#endif

            int hash;
            var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.DefaultConstraint, defaultKeyword, out hash);
            if (cached != null) return (DefaultConstraintSyntax)cached;

            var result = new DefaultConstraintSyntax(SyntaxKind.DefaultConstraint, defaultKeyword);
            if (hash >= 0)
            {
                SyntaxNodeCache.AddNode(result, hash);
            }

            return result;
        }

        public static FieldDeclarationSyntax FieldDeclaration(Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<AttributeListSyntax> attributeLists, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SyntaxToken> modifiers, VariableDeclarationSyntax declaration, SyntaxToken semicolonToken)
        {
#if DEBUG
            if (declaration == null) throw new ArgumentNullException(nameof(declaration));
            if (semicolonToken == null) throw new ArgumentNullException(nameof(semicolonToken));
            if (semicolonToken.Kind != SyntaxKind.SemicolonToken) throw new ArgumentException(nameof(semicolonToken));
#endif

            return new FieldDeclarationSyntax(SyntaxKind.FieldDeclaration, attributeLists.Node, modifiers.Node, declaration, semicolonToken);
        }

        public static EventFieldDeclarationSyntax EventFieldDeclaration(Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<AttributeListSyntax> attributeLists, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SyntaxToken> modifiers, SyntaxToken eventKeyword, VariableDeclarationSyntax declaration, SyntaxToken semicolonToken)
        {
#if DEBUG
            if (eventKeyword == null) throw new ArgumentNullException(nameof(eventKeyword));
            if (eventKeyword.Kind != SyntaxKind.EventKeyword) throw new ArgumentException(nameof(eventKeyword));
            if (declaration == null) throw new ArgumentNullException(nameof(declaration));
            if (semicolonToken == null) throw new ArgumentNullException(nameof(semicolonToken));
            if (semicolonToken.Kind != SyntaxKind.SemicolonToken) throw new ArgumentException(nameof(semicolonToken));
#endif

            return new EventFieldDeclarationSyntax(SyntaxKind.EventFieldDeclaration, attributeLists.Node, modifiers.Node, eventKeyword, declaration, semicolonToken);
        }

        public static ExplicitInterfaceSpecifierSyntax ExplicitInterfaceSpecifier(NameSyntax name, SyntaxToken dotToken)
        {
#if DEBUG
            if (name == null) throw new ArgumentNullException(nameof(name));
            if (dotToken == null) throw new ArgumentNullException(nameof(dotToken));
            if (dotToken.Kind != SyntaxKind.DotToken) throw new ArgumentException(nameof(dotToken));
#endif

            int hash;
            var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.ExplicitInterfaceSpecifier, name, dotToken, out hash);
            if (cached != null) return (ExplicitInterfaceSpecifierSyntax)cached;

            var result = new ExplicitInterfaceSpecifierSyntax(SyntaxKind.ExplicitInterfaceSpecifier, name, dotToken);
            if (hash >= 0)
            {
                SyntaxNodeCache.AddNode(result, hash);
            }

            return result;
        }

        public static MethodDeclarationSyntax MethodDeclaration(Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<AttributeListSyntax> attributeLists, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SyntaxToken> modifiers, TypeSyntax returnType, ExplicitInterfaceSpecifierSyntax? explicitInterfaceSpecifier, SyntaxToken identifier, TypeParameterListSyntax? typeParameterList, ParameterListSyntax parameterList, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<TypeParameterConstraintClauseSyntax> constraintClauses, BlockSyntax? body, ArrowExpressionClauseSyntax? expressionBody, SyntaxToken? semicolonToken)
        {
#if DEBUG
            if (returnType == null) throw new ArgumentNullException(nameof(returnType));
            if (identifier == null) throw new ArgumentNullException(nameof(identifier));
            if (identifier.Kind != SyntaxKind.IdentifierToken) throw new ArgumentException(nameof(identifier));
            if (parameterList == null) throw new ArgumentNullException(nameof(parameterList));
            if (semicolonToken != null)
            {
                switch (semicolonToken.Kind)
                {
                    case SyntaxKind.SemicolonToken:
                    case SyntaxKind.None: break;
                    default: throw new ArgumentException(nameof(semicolonToken));
                }
            }
#endif

            return new MethodDeclarationSyntax(SyntaxKind.MethodDeclaration, attributeLists.Node, modifiers.Node, returnType, explicitInterfaceSpecifier, identifier, typeParameterList, parameterList, constraintClauses.Node, body, expressionBody, semicolonToken);
        }

        public static OperatorDeclarationSyntax OperatorDeclaration(Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<AttributeListSyntax> attributeLists, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SyntaxToken> modifiers, TypeSyntax returnType, SyntaxToken operatorKeyword, SyntaxToken operatorToken, ParameterListSyntax parameterList, BlockSyntax? body, ArrowExpressionClauseSyntax? expressionBody, SyntaxToken? semicolonToken)
        {
#if DEBUG
            if (returnType == null) throw new ArgumentNullException(nameof(returnType));
            if (operatorKeyword == null) throw new ArgumentNullException(nameof(operatorKeyword));
            if (operatorKeyword.Kind != SyntaxKind.OperatorKeyword) throw new ArgumentException(nameof(operatorKeyword));
            if (operatorToken == null) throw new ArgumentNullException(nameof(operatorToken));
            switch (operatorToken.Kind)
            {
                case SyntaxKind.PlusToken:
                case SyntaxKind.MinusToken:
                case SyntaxKind.ExclamationToken:
                case SyntaxKind.TildeToken:
                case SyntaxKind.PlusPlusToken:
                case SyntaxKind.MinusMinusToken:
                case SyntaxKind.AsteriskToken:
                case SyntaxKind.SlashToken:
                case SyntaxKind.PercentToken:
                case SyntaxKind.LessThanLessThanToken:
                case SyntaxKind.GreaterThanGreaterThanToken:
                case SyntaxKind.BarToken:
                case SyntaxKind.AmpersandToken:
                case SyntaxKind.CaretToken:
                case SyntaxKind.EqualsEqualsToken:
                case SyntaxKind.ExclamationEqualsToken:
                case SyntaxKind.LessThanToken:
                case SyntaxKind.LessThanEqualsToken:
                case SyntaxKind.GreaterThanToken:
                case SyntaxKind.GreaterThanEqualsToken:
                case SyntaxKind.FalseKeyword:
                case SyntaxKind.TrueKeyword:
                case SyntaxKind.IsKeyword: break;
                default: throw new ArgumentException(nameof(operatorToken));
            }
            if (parameterList == null) throw new ArgumentNullException(nameof(parameterList));
            if (semicolonToken != null)
            {
                switch (semicolonToken.Kind)
                {
                    case SyntaxKind.SemicolonToken:
                    case SyntaxKind.None: break;
                    default: throw new ArgumentException(nameof(semicolonToken));
                }
            }
#endif

            return new OperatorDeclarationSyntax(SyntaxKind.OperatorDeclaration, attributeLists.Node, modifiers.Node, returnType, operatorKeyword, operatorToken, parameterList, body, expressionBody, semicolonToken);
        }

        public static ConversionOperatorDeclarationSyntax ConversionOperatorDeclaration(Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<AttributeListSyntax> attributeLists, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SyntaxToken> modifiers, SyntaxToken implicitOrExplicitKeyword, SyntaxToken operatorKeyword, TypeSyntax type, ParameterListSyntax parameterList, BlockSyntax? body, ArrowExpressionClauseSyntax? expressionBody, SyntaxToken? semicolonToken)
        {
#if DEBUG
            if (implicitOrExplicitKeyword == null) throw new ArgumentNullException(nameof(implicitOrExplicitKeyword));
            switch (implicitOrExplicitKeyword.Kind)
            {
                case SyntaxKind.ImplicitKeyword:
                case SyntaxKind.ExplicitKeyword: break;
                default: throw new ArgumentException(nameof(implicitOrExplicitKeyword));
            }
            if (operatorKeyword == null) throw new ArgumentNullException(nameof(operatorKeyword));
            if (operatorKeyword.Kind != SyntaxKind.OperatorKeyword) throw new ArgumentException(nameof(operatorKeyword));
            if (type == null) throw new ArgumentNullException(nameof(type));
            if (parameterList == null) throw new ArgumentNullException(nameof(parameterList));
            if (semicolonToken != null)
            {
                switch (semicolonToken.Kind)
                {
                    case SyntaxKind.SemicolonToken:
                    case SyntaxKind.None: break;
                    default: throw new ArgumentException(nameof(semicolonToken));
                }
            }
#endif

            return new ConversionOperatorDeclarationSyntax(SyntaxKind.ConversionOperatorDeclaration, attributeLists.Node, modifiers.Node, implicitOrExplicitKeyword, operatorKeyword, type, parameterList, body, expressionBody, semicolonToken);
        }

        public static ConstructorDeclarationSyntax ConstructorDeclaration(Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<AttributeListSyntax> attributeLists, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SyntaxToken> modifiers, SyntaxToken identifier, ParameterListSyntax parameterList, ConstructorInitializerSyntax? initializer, BlockSyntax? body, ArrowExpressionClauseSyntax? expressionBody, SyntaxToken? semicolonToken)
        {
#if DEBUG
            if (identifier == null) throw new ArgumentNullException(nameof(identifier));
            if (identifier.Kind != SyntaxKind.IdentifierToken) throw new ArgumentException(nameof(identifier));
            if (parameterList == null) throw new ArgumentNullException(nameof(parameterList));
            if (semicolonToken != null)
            {
                switch (semicolonToken.Kind)
                {
                    case SyntaxKind.SemicolonToken:
                    case SyntaxKind.None: break;
                    default: throw new ArgumentException(nameof(semicolonToken));
                }
            }
#endif

            return new ConstructorDeclarationSyntax(SyntaxKind.ConstructorDeclaration, attributeLists.Node, modifiers.Node, identifier, parameterList, initializer, body, expressionBody, semicolonToken);
        }

        public static ConstructorInitializerSyntax ConstructorInitializer(SyntaxKind kind, SyntaxToken colonToken, SyntaxToken thisOrBaseKeyword, ArgumentListSyntax argumentList)
        {
            switch (kind)
            {
                case SyntaxKind.BaseConstructorInitializer:
                case SyntaxKind.ThisConstructorInitializer: break;
                default: throw new ArgumentException(nameof(kind));
            }
#if DEBUG
            if (colonToken == null) throw new ArgumentNullException(nameof(colonToken));
            if (colonToken.Kind != SyntaxKind.ColonToken) throw new ArgumentException(nameof(colonToken));
            if (thisOrBaseKeyword == null) throw new ArgumentNullException(nameof(thisOrBaseKeyword));
            switch (thisOrBaseKeyword.Kind)
            {
                case SyntaxKind.BaseKeyword:
                case SyntaxKind.ThisKeyword: break;
                default: throw new ArgumentException(nameof(thisOrBaseKeyword));
            }
            if (argumentList == null) throw new ArgumentNullException(nameof(argumentList));
#endif

            int hash;
            var cached = SyntaxNodeCache.TryGetNode((int)kind, colonToken, thisOrBaseKeyword, argumentList, out hash);
            if (cached != null) return (ConstructorInitializerSyntax)cached;

            var result = new ConstructorInitializerSyntax(kind, colonToken, thisOrBaseKeyword, argumentList);
            if (hash >= 0)
            {
                SyntaxNodeCache.AddNode(result, hash);
            }

            return result;
        }

        public static DestructorDeclarationSyntax DestructorDeclaration(Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<AttributeListSyntax> attributeLists, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SyntaxToken> modifiers, SyntaxToken tildeToken, SyntaxToken identifier, ParameterListSyntax parameterList, BlockSyntax? body, ArrowExpressionClauseSyntax? expressionBody, SyntaxToken? semicolonToken)
        {
#if DEBUG
            if (tildeToken == null) throw new ArgumentNullException(nameof(tildeToken));
            if (tildeToken.Kind != SyntaxKind.TildeToken) throw new ArgumentException(nameof(tildeToken));
            if (identifier == null) throw new ArgumentNullException(nameof(identifier));
            if (identifier.Kind != SyntaxKind.IdentifierToken) throw new ArgumentException(nameof(identifier));
            if (parameterList == null) throw new ArgumentNullException(nameof(parameterList));
            if (semicolonToken != null)
            {
                switch (semicolonToken.Kind)
                {
                    case SyntaxKind.SemicolonToken:
                    case SyntaxKind.None: break;
                    default: throw new ArgumentException(nameof(semicolonToken));
                }
            }
#endif

            return new DestructorDeclarationSyntax(SyntaxKind.DestructorDeclaration, attributeLists.Node, modifiers.Node, tildeToken, identifier, parameterList, body, expressionBody, semicolonToken);
        }

        public static PropertyDeclarationSyntax PropertyDeclaration(Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<AttributeListSyntax> attributeLists, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SyntaxToken> modifiers, TypeSyntax type, ExplicitInterfaceSpecifierSyntax? explicitInterfaceSpecifier, SyntaxToken identifier, AccessorListSyntax? accessorList, ArrowExpressionClauseSyntax? expressionBody, EqualsValueClauseSyntax? initializer, SyntaxToken? semicolonToken)
        {
#if DEBUG
            if (type == null) throw new ArgumentNullException(nameof(type));
            if (identifier == null) throw new ArgumentNullException(nameof(identifier));
            if (identifier.Kind != SyntaxKind.IdentifierToken) throw new ArgumentException(nameof(identifier));
            if (semicolonToken != null)
            {
                switch (semicolonToken.Kind)
                {
                    case SyntaxKind.SemicolonToken:
                    case SyntaxKind.None: break;
                    default: throw new ArgumentException(nameof(semicolonToken));
                }
            }
#endif

            return new PropertyDeclarationSyntax(SyntaxKind.PropertyDeclaration, attributeLists.Node, modifiers.Node, type, explicitInterfaceSpecifier, identifier, accessorList, expressionBody, initializer, semicolonToken);
        }

        public static ArrowExpressionClauseSyntax ArrowExpressionClause(SyntaxToken arrowToken, ExpressionSyntax expression)
        {
#if DEBUG
            if (arrowToken == null) throw new ArgumentNullException(nameof(arrowToken));
            if (arrowToken.Kind != SyntaxKind.EqualsGreaterThanToken) throw new ArgumentException(nameof(arrowToken));
            if (expression == null) throw new ArgumentNullException(nameof(expression));
#endif

            int hash;
            var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.ArrowExpressionClause, arrowToken, expression, out hash);
            if (cached != null) return (ArrowExpressionClauseSyntax)cached;

            var result = new ArrowExpressionClauseSyntax(SyntaxKind.ArrowExpressionClause, arrowToken, expression);
            if (hash >= 0)
            {
                SyntaxNodeCache.AddNode(result, hash);
            }

            return result;
        }

        public static EventDeclarationSyntax EventDeclaration(Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<AttributeListSyntax> attributeLists, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SyntaxToken> modifiers, SyntaxToken eventKeyword, TypeSyntax type, ExplicitInterfaceSpecifierSyntax? explicitInterfaceSpecifier, SyntaxToken identifier, AccessorListSyntax? accessorList, SyntaxToken? semicolonToken)
        {
#if DEBUG
            if (eventKeyword == null) throw new ArgumentNullException(nameof(eventKeyword));
            if (eventKeyword.Kind != SyntaxKind.EventKeyword) throw new ArgumentException(nameof(eventKeyword));
            if (type == null) throw new ArgumentNullException(nameof(type));
            if (identifier == null) throw new ArgumentNullException(nameof(identifier));
            if (identifier.Kind != SyntaxKind.IdentifierToken) throw new ArgumentException(nameof(identifier));
            if (semicolonToken != null)
            {
                switch (semicolonToken.Kind)
                {
                    case SyntaxKind.SemicolonToken:
                    case SyntaxKind.None: break;
                    default: throw new ArgumentException(nameof(semicolonToken));
                }
            }
#endif

            return new EventDeclarationSyntax(SyntaxKind.EventDeclaration, attributeLists.Node, modifiers.Node, eventKeyword, type, explicitInterfaceSpecifier, identifier, accessorList, semicolonToken);
        }

        public static IndexerDeclarationSyntax IndexerDeclaration(Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<AttributeListSyntax> attributeLists, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SyntaxToken> modifiers, TypeSyntax type, ExplicitInterfaceSpecifierSyntax? explicitInterfaceSpecifier, SyntaxToken thisKeyword, BracketedParameterListSyntax parameterList, AccessorListSyntax? accessorList, ArrowExpressionClauseSyntax? expressionBody, SyntaxToken? semicolonToken)
        {
#if DEBUG
            if (type == null) throw new ArgumentNullException(nameof(type));
            if (thisKeyword == null) throw new ArgumentNullException(nameof(thisKeyword));
            if (thisKeyword.Kind != SyntaxKind.ThisKeyword) throw new ArgumentException(nameof(thisKeyword));
            if (parameterList == null) throw new ArgumentNullException(nameof(parameterList));
            if (semicolonToken != null)
            {
                switch (semicolonToken.Kind)
                {
                    case SyntaxKind.SemicolonToken:
                    case SyntaxKind.None: break;
                    default: throw new ArgumentException(nameof(semicolonToken));
                }
            }
#endif

            return new IndexerDeclarationSyntax(SyntaxKind.IndexerDeclaration, attributeLists.Node, modifiers.Node, type, explicitInterfaceSpecifier, thisKeyword, parameterList, accessorList, expressionBody, semicolonToken);
        }

        public static AccessorListSyntax AccessorList(SyntaxToken openBraceToken, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<AccessorDeclarationSyntax> accessors, SyntaxToken closeBraceToken)
        {
#if DEBUG
            if (openBraceToken == null) throw new ArgumentNullException(nameof(openBraceToken));
            if (openBraceToken.Kind != SyntaxKind.OpenBraceToken) throw new ArgumentException(nameof(openBraceToken));
            if (closeBraceToken == null) throw new ArgumentNullException(nameof(closeBraceToken));
            if (closeBraceToken.Kind != SyntaxKind.CloseBraceToken) throw new ArgumentException(nameof(closeBraceToken));
#endif

            int hash;
            var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.AccessorList, openBraceToken, accessors.Node, closeBraceToken, out hash);
            if (cached != null) return (AccessorListSyntax)cached;

            var result = new AccessorListSyntax(SyntaxKind.AccessorList, openBraceToken, accessors.Node, closeBraceToken);
            if (hash >= 0)
            {
                SyntaxNodeCache.AddNode(result, hash);
            }

            return result;
        }

        public static AccessorDeclarationSyntax AccessorDeclaration(SyntaxKind kind, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<AttributeListSyntax> attributeLists, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SyntaxToken> modifiers, SyntaxToken keyword, BlockSyntax? body, ArrowExpressionClauseSyntax? expressionBody, SyntaxToken? semicolonToken)
        {
            switch (kind)
            {
                case SyntaxKind.GetAccessorDeclaration:
                case SyntaxKind.SetAccessorDeclaration:
                case SyntaxKind.InitAccessorDeclaration:
                case SyntaxKind.AddAccessorDeclaration:
                case SyntaxKind.RemoveAccessorDeclaration:
                case SyntaxKind.UnknownAccessorDeclaration: break;
                default: throw new ArgumentException(nameof(kind));
            }
#if DEBUG
            if (keyword == null) throw new ArgumentNullException(nameof(keyword));
            switch (keyword.Kind)
            {
                case SyntaxKind.GetKeyword:
                case SyntaxKind.SetKeyword:
                case SyntaxKind.InitKeyword:
                case SyntaxKind.AddKeyword:
                case SyntaxKind.RemoveKeyword:
                case SyntaxKind.IdentifierToken: break;
                default: throw new ArgumentException(nameof(keyword));
            }
            if (semicolonToken != null)
            {
                switch (semicolonToken.Kind)
                {
                    case SyntaxKind.SemicolonToken:
                    case SyntaxKind.None: break;
                    default: throw new ArgumentException(nameof(semicolonToken));
                }
            }
#endif

            return new AccessorDeclarationSyntax(kind, attributeLists.Node, modifiers.Node, keyword, body, expressionBody, semicolonToken);
        }

        public static ParameterListSyntax ParameterList(SyntaxToken openParenToken, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<ParameterSyntax> parameters, SyntaxToken closeParenToken)
        {
#if DEBUG
            if (openParenToken == null) throw new ArgumentNullException(nameof(openParenToken));
            if (openParenToken.Kind != SyntaxKind.OpenParenToken) throw new ArgumentException(nameof(openParenToken));
            if (closeParenToken == null) throw new ArgumentNullException(nameof(closeParenToken));
            if (closeParenToken.Kind != SyntaxKind.CloseParenToken) throw new ArgumentException(nameof(closeParenToken));
#endif

            int hash;
            var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.ParameterList, openParenToken, parameters.Node, closeParenToken, out hash);
            if (cached != null) return (ParameterListSyntax)cached;

            var result = new ParameterListSyntax(SyntaxKind.ParameterList, openParenToken, parameters.Node, closeParenToken);
            if (hash >= 0)
            {
                SyntaxNodeCache.AddNode(result, hash);
            }

            return result;
        }

        public static BracketedParameterListSyntax BracketedParameterList(SyntaxToken openBracketToken, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<ParameterSyntax> parameters, SyntaxToken closeBracketToken)
        {
#if DEBUG
            if (openBracketToken == null) throw new ArgumentNullException(nameof(openBracketToken));
            if (openBracketToken.Kind != SyntaxKind.OpenBracketToken) throw new ArgumentException(nameof(openBracketToken));
            if (closeBracketToken == null) throw new ArgumentNullException(nameof(closeBracketToken));
            if (closeBracketToken.Kind != SyntaxKind.CloseBracketToken) throw new ArgumentException(nameof(closeBracketToken));
#endif

            int hash;
            var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.BracketedParameterList, openBracketToken, parameters.Node, closeBracketToken, out hash);
            if (cached != null) return (BracketedParameterListSyntax)cached;

            var result = new BracketedParameterListSyntax(SyntaxKind.BracketedParameterList, openBracketToken, parameters.Node, closeBracketToken);
            if (hash >= 0)
            {
                SyntaxNodeCache.AddNode(result, hash);
            }

            return result;
        }

        public static ParameterSyntax Parameter(Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<AttributeListSyntax> attributeLists, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SyntaxToken> modifiers, TypeSyntax? type, SyntaxToken identifier, EqualsValueClauseSyntax? @default)
        {
#if DEBUG
            if (identifier == null) throw new ArgumentNullException(nameof(identifier));
            switch (identifier.Kind)
            {
                case SyntaxKind.IdentifierToken:
                case SyntaxKind.ArgListKeyword: break;
                default: throw new ArgumentException(nameof(identifier));
            }
#endif

            return new ParameterSyntax(SyntaxKind.Parameter, attributeLists.Node, modifiers.Node, type, identifier, @default);
        }

        public static FunctionPointerParameterSyntax FunctionPointerParameter(Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<AttributeListSyntax> attributeLists, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SyntaxToken> modifiers, TypeSyntax type)
        {
#if DEBUG
            if (type == null) throw new ArgumentNullException(nameof(type));
#endif

            int hash;
            var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.FunctionPointerParameter, attributeLists.Node, modifiers.Node, type, out hash);
            if (cached != null) return (FunctionPointerParameterSyntax)cached;

            var result = new FunctionPointerParameterSyntax(SyntaxKind.FunctionPointerParameter, attributeLists.Node, modifiers.Node, type);
            if (hash >= 0)
            {
                SyntaxNodeCache.AddNode(result, hash);
            }

            return result;
        }

        public static IncompleteMemberSyntax IncompleteMember(Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<AttributeListSyntax> attributeLists, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SyntaxToken> modifiers, TypeSyntax? type)
        {
#if DEBUG
#endif

            return new IncompleteMemberSyntax(SyntaxKind.IncompleteMember, attributeLists.Node, modifiers.Node, type);
        }

        public static SkippedTokensTriviaSyntax SkippedTokensTrivia(Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SyntaxToken> tokens)
        {
#if DEBUG
#endif

            return new SkippedTokensTriviaSyntax(SyntaxKind.SkippedTokensTrivia, tokens.Node);
        }

        public static DocumentationCommentTriviaSyntax DocumentationCommentTrivia(SyntaxKind kind, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<XmlNodeSyntax> content, SyntaxToken endOfComment)
        {
            switch (kind)
            {
                case SyntaxKind.SingleLineDocumentationCommentTrivia:
                case SyntaxKind.MultiLineDocumentationCommentTrivia: break;
                default: throw new ArgumentException(nameof(kind));
            }
#if DEBUG
            if (endOfComment == null) throw new ArgumentNullException(nameof(endOfComment));
            if (endOfComment.Kind != SyntaxKind.EndOfDocumentationCommentToken) throw new ArgumentException(nameof(endOfComment));
#endif

            return new DocumentationCommentTriviaSyntax(kind, content.Node, endOfComment);
        }

        public static TypeCrefSyntax TypeCref(TypeSyntax type)
        {
#if DEBUG
            if (type == null) throw new ArgumentNullException(nameof(type));
#endif

            int hash;
            var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.TypeCref, type, out hash);
            if (cached != null) return (TypeCrefSyntax)cached;

            var result = new TypeCrefSyntax(SyntaxKind.TypeCref, type);
            if (hash >= 0)
            {
                SyntaxNodeCache.AddNode(result, hash);
            }

            return result;
        }

        public static QualifiedCrefSyntax QualifiedCref(TypeSyntax container, SyntaxToken dotToken, MemberCrefSyntax member)
        {
#if DEBUG
            if (container == null) throw new ArgumentNullException(nameof(container));
            if (dotToken == null) throw new ArgumentNullException(nameof(dotToken));
            if (dotToken.Kind != SyntaxKind.DotToken) throw new ArgumentException(nameof(dotToken));
            if (member == null) throw new ArgumentNullException(nameof(member));
#endif

            int hash;
            var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.QualifiedCref, container, dotToken, member, out hash);
            if (cached != null) return (QualifiedCrefSyntax)cached;

            var result = new QualifiedCrefSyntax(SyntaxKind.QualifiedCref, container, dotToken, member);
            if (hash >= 0)
            {
                SyntaxNodeCache.AddNode(result, hash);
            }

            return result;
        }

        public static NameMemberCrefSyntax NameMemberCref(TypeSyntax name, CrefParameterListSyntax? parameters)
        {
#if DEBUG
            if (name == null) throw new ArgumentNullException(nameof(name));
#endif

            int hash;
            var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.NameMemberCref, name, parameters, out hash);
            if (cached != null) return (NameMemberCrefSyntax)cached;

            var result = new NameMemberCrefSyntax(SyntaxKind.NameMemberCref, name, parameters);
            if (hash >= 0)
            {
                SyntaxNodeCache.AddNode(result, hash);
            }

            return result;
        }

        public static IndexerMemberCrefSyntax IndexerMemberCref(SyntaxToken thisKeyword, CrefBracketedParameterListSyntax? parameters)
        {
#if DEBUG
            if (thisKeyword == null) throw new ArgumentNullException(nameof(thisKeyword));
            if (thisKeyword.Kind != SyntaxKind.ThisKeyword) throw new ArgumentException(nameof(thisKeyword));
#endif

            int hash;
            var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.IndexerMemberCref, thisKeyword, parameters, out hash);
            if (cached != null) return (IndexerMemberCrefSyntax)cached;

            var result = new IndexerMemberCrefSyntax(SyntaxKind.IndexerMemberCref, thisKeyword, parameters);
            if (hash >= 0)
            {
                SyntaxNodeCache.AddNode(result, hash);
            }

            return result;
        }

        public static OperatorMemberCrefSyntax OperatorMemberCref(SyntaxToken operatorKeyword, SyntaxToken operatorToken, CrefParameterListSyntax? parameters)
        {
#if DEBUG
            if (operatorKeyword == null) throw new ArgumentNullException(nameof(operatorKeyword));
            if (operatorKeyword.Kind != SyntaxKind.OperatorKeyword) throw new ArgumentException(nameof(operatorKeyword));
            if (operatorToken == null) throw new ArgumentNullException(nameof(operatorToken));
            switch (operatorToken.Kind)
            {
                case SyntaxKind.PlusToken:
                case SyntaxKind.MinusToken:
                case SyntaxKind.ExclamationToken:
                case SyntaxKind.TildeToken:
                case SyntaxKind.PlusPlusToken:
                case SyntaxKind.MinusMinusToken:
                case SyntaxKind.AsteriskToken:
                case SyntaxKind.SlashToken:
                case SyntaxKind.PercentToken:
                case SyntaxKind.LessThanLessThanToken:
                case SyntaxKind.GreaterThanGreaterThanToken:
                case SyntaxKind.BarToken:
                case SyntaxKind.AmpersandToken:
                case SyntaxKind.CaretToken:
                case SyntaxKind.EqualsEqualsToken:
                case SyntaxKind.ExclamationEqualsToken:
                case SyntaxKind.LessThanToken:
                case SyntaxKind.LessThanEqualsToken:
                case SyntaxKind.GreaterThanToken:
                case SyntaxKind.GreaterThanEqualsToken:
                case SyntaxKind.FalseKeyword:
                case SyntaxKind.TrueKeyword: break;
                default: throw new ArgumentException(nameof(operatorToken));
            }
#endif

            int hash;
            var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.OperatorMemberCref, operatorKeyword, operatorToken, parameters, out hash);
            if (cached != null) return (OperatorMemberCrefSyntax)cached;

            var result = new OperatorMemberCrefSyntax(SyntaxKind.OperatorMemberCref, operatorKeyword, operatorToken, parameters);
            if (hash >= 0)
            {
                SyntaxNodeCache.AddNode(result, hash);
            }

            return result;
        }

        public static ConversionOperatorMemberCrefSyntax ConversionOperatorMemberCref(SyntaxToken implicitOrExplicitKeyword, SyntaxToken operatorKeyword, TypeSyntax type, CrefParameterListSyntax? parameters)
        {
#if DEBUG
            if (implicitOrExplicitKeyword == null) throw new ArgumentNullException(nameof(implicitOrExplicitKeyword));
            switch (implicitOrExplicitKeyword.Kind)
            {
                case SyntaxKind.ImplicitKeyword:
                case SyntaxKind.ExplicitKeyword: break;
                default: throw new ArgumentException(nameof(implicitOrExplicitKeyword));
            }
            if (operatorKeyword == null) throw new ArgumentNullException(nameof(operatorKeyword));
            if (operatorKeyword.Kind != SyntaxKind.OperatorKeyword) throw new ArgumentException(nameof(operatorKeyword));
            if (type == null) throw new ArgumentNullException(nameof(type));
#endif

            return new ConversionOperatorMemberCrefSyntax(SyntaxKind.ConversionOperatorMemberCref, implicitOrExplicitKeyword, operatorKeyword, type, parameters);
        }

        public static CrefParameterListSyntax CrefParameterList(SyntaxToken openParenToken, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<CrefParameterSyntax> parameters, SyntaxToken closeParenToken)
        {
#if DEBUG
            if (openParenToken == null) throw new ArgumentNullException(nameof(openParenToken));
            if (openParenToken.Kind != SyntaxKind.OpenParenToken) throw new ArgumentException(nameof(openParenToken));
            if (closeParenToken == null) throw new ArgumentNullException(nameof(closeParenToken));
            if (closeParenToken.Kind != SyntaxKind.CloseParenToken) throw new ArgumentException(nameof(closeParenToken));
#endif

            int hash;
            var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.CrefParameterList, openParenToken, parameters.Node, closeParenToken, out hash);
            if (cached != null) return (CrefParameterListSyntax)cached;

            var result = new CrefParameterListSyntax(SyntaxKind.CrefParameterList, openParenToken, parameters.Node, closeParenToken);
            if (hash >= 0)
            {
                SyntaxNodeCache.AddNode(result, hash);
            }

            return result;
        }

        public static CrefBracketedParameterListSyntax CrefBracketedParameterList(SyntaxToken openBracketToken, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<CrefParameterSyntax> parameters, SyntaxToken closeBracketToken)
        {
#if DEBUG
            if (openBracketToken == null) throw new ArgumentNullException(nameof(openBracketToken));
            if (openBracketToken.Kind != SyntaxKind.OpenBracketToken) throw new ArgumentException(nameof(openBracketToken));
            if (closeBracketToken == null) throw new ArgumentNullException(nameof(closeBracketToken));
            if (closeBracketToken.Kind != SyntaxKind.CloseBracketToken) throw new ArgumentException(nameof(closeBracketToken));
#endif

            int hash;
            var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.CrefBracketedParameterList, openBracketToken, parameters.Node, closeBracketToken, out hash);
            if (cached != null) return (CrefBracketedParameterListSyntax)cached;

            var result = new CrefBracketedParameterListSyntax(SyntaxKind.CrefBracketedParameterList, openBracketToken, parameters.Node, closeBracketToken);
            if (hash >= 0)
            {
                SyntaxNodeCache.AddNode(result, hash);
            }

            return result;
        }

        public static CrefParameterSyntax CrefParameter(SyntaxToken? refKindKeyword, TypeSyntax type)
        {
#if DEBUG
            if (refKindKeyword != null)
            {
                switch (refKindKeyword.Kind)
                {
                    case SyntaxKind.RefKeyword:
                    case SyntaxKind.OutKeyword:
                    case SyntaxKind.InKeyword:
                    case SyntaxKind.None: break;
                    default: throw new ArgumentException(nameof(refKindKeyword));
                }
            }
            if (type == null) throw new ArgumentNullException(nameof(type));
#endif

            int hash;
            var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.CrefParameter, refKindKeyword, type, out hash);
            if (cached != null) return (CrefParameterSyntax)cached;

            var result = new CrefParameterSyntax(SyntaxKind.CrefParameter, refKindKeyword, type);
            if (hash >= 0)
            {
                SyntaxNodeCache.AddNode(result, hash);
            }

            return result;
        }

        public static XmlElementSyntax XmlElement(XmlElementStartTagSyntax startTag, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<XmlNodeSyntax> content, XmlElementEndTagSyntax endTag)
        {
#if DEBUG
            if (startTag == null) throw new ArgumentNullException(nameof(startTag));
            if (endTag == null) throw new ArgumentNullException(nameof(endTag));
#endif

            int hash;
            var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.XmlElement, startTag, content.Node, endTag, out hash);
            if (cached != null) return (XmlElementSyntax)cached;

            var result = new XmlElementSyntax(SyntaxKind.XmlElement, startTag, content.Node, endTag);
            if (hash >= 0)
            {
                SyntaxNodeCache.AddNode(result, hash);
            }

            return result;
        }

        public static XmlElementStartTagSyntax XmlElementStartTag(SyntaxToken lessThanToken, XmlNameSyntax name, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<XmlAttributeSyntax> attributes, SyntaxToken greaterThanToken)
        {
#if DEBUG
            if (lessThanToken == null) throw new ArgumentNullException(nameof(lessThanToken));
            if (lessThanToken.Kind != SyntaxKind.LessThanToken) throw new ArgumentException(nameof(lessThanToken));
            if (name == null) throw new ArgumentNullException(nameof(name));
            if (greaterThanToken == null) throw new ArgumentNullException(nameof(greaterThanToken));
            if (greaterThanToken.Kind != SyntaxKind.GreaterThanToken) throw new ArgumentException(nameof(greaterThanToken));
#endif

            return new XmlElementStartTagSyntax(SyntaxKind.XmlElementStartTag, lessThanToken, name, attributes.Node, greaterThanToken);
        }

        public static XmlElementEndTagSyntax XmlElementEndTag(SyntaxToken lessThanSlashToken, XmlNameSyntax name, SyntaxToken greaterThanToken)
        {
#if DEBUG
            if (lessThanSlashToken == null) throw new ArgumentNullException(nameof(lessThanSlashToken));
            if (lessThanSlashToken.Kind != SyntaxKind.LessThanSlashToken) throw new ArgumentException(nameof(lessThanSlashToken));
            if (name == null) throw new ArgumentNullException(nameof(name));
            if (greaterThanToken == null) throw new ArgumentNullException(nameof(greaterThanToken));
            if (greaterThanToken.Kind != SyntaxKind.GreaterThanToken) throw new ArgumentException(nameof(greaterThanToken));
#endif

            int hash;
            var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.XmlElementEndTag, lessThanSlashToken, name, greaterThanToken, out hash);
            if (cached != null) return (XmlElementEndTagSyntax)cached;

            var result = new XmlElementEndTagSyntax(SyntaxKind.XmlElementEndTag, lessThanSlashToken, name, greaterThanToken);
            if (hash >= 0)
            {
                SyntaxNodeCache.AddNode(result, hash);
            }

            return result;
        }

        public static XmlEmptyElementSyntax XmlEmptyElement(SyntaxToken lessThanToken, XmlNameSyntax name, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<XmlAttributeSyntax> attributes, SyntaxToken slashGreaterThanToken)
        {
#if DEBUG
            if (lessThanToken == null) throw new ArgumentNullException(nameof(lessThanToken));
            if (lessThanToken.Kind != SyntaxKind.LessThanToken) throw new ArgumentException(nameof(lessThanToken));
            if (name == null) throw new ArgumentNullException(nameof(name));
            if (slashGreaterThanToken == null) throw new ArgumentNullException(nameof(slashGreaterThanToken));
            if (slashGreaterThanToken.Kind != SyntaxKind.SlashGreaterThanToken) throw new ArgumentException(nameof(slashGreaterThanToken));
#endif

            return new XmlEmptyElementSyntax(SyntaxKind.XmlEmptyElement, lessThanToken, name, attributes.Node, slashGreaterThanToken);
        }

        public static XmlNameSyntax XmlName(XmlPrefixSyntax? prefix, SyntaxToken localName)
        {
#if DEBUG
            if (localName == null) throw new ArgumentNullException(nameof(localName));
            if (localName.Kind != SyntaxKind.IdentifierToken) throw new ArgumentException(nameof(localName));
#endif

            int hash;
            var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.XmlName, prefix, localName, out hash);
            if (cached != null) return (XmlNameSyntax)cached;

            var result = new XmlNameSyntax(SyntaxKind.XmlName, prefix, localName);
            if (hash >= 0)
            {
                SyntaxNodeCache.AddNode(result, hash);
            }

            return result;
        }

        public static XmlPrefixSyntax XmlPrefix(SyntaxToken prefix, SyntaxToken colonToken)
        {
#if DEBUG
            if (prefix == null) throw new ArgumentNullException(nameof(prefix));
            if (prefix.Kind != SyntaxKind.IdentifierToken) throw new ArgumentException(nameof(prefix));
            if (colonToken == null) throw new ArgumentNullException(nameof(colonToken));
            if (colonToken.Kind != SyntaxKind.ColonToken) throw new ArgumentException(nameof(colonToken));
#endif

            int hash;
            var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.XmlPrefix, prefix, colonToken, out hash);
            if (cached != null) return (XmlPrefixSyntax)cached;

            var result = new XmlPrefixSyntax(SyntaxKind.XmlPrefix, prefix, colonToken);
            if (hash >= 0)
            {
                SyntaxNodeCache.AddNode(result, hash);
            }

            return result;
        }

        public static XmlTextAttributeSyntax XmlTextAttribute(XmlNameSyntax name, SyntaxToken equalsToken, SyntaxToken startQuoteToken, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SyntaxToken> textTokens, SyntaxToken endQuoteToken)
        {
#if DEBUG
            if (name == null) throw new ArgumentNullException(nameof(name));
            if (equalsToken == null) throw new ArgumentNullException(nameof(equalsToken));
            if (equalsToken.Kind != SyntaxKind.EqualsToken) throw new ArgumentException(nameof(equalsToken));
            if (startQuoteToken == null) throw new ArgumentNullException(nameof(startQuoteToken));
            switch (startQuoteToken.Kind)
            {
                case SyntaxKind.SingleQuoteToken:
                case SyntaxKind.DoubleQuoteToken: break;
                default: throw new ArgumentException(nameof(startQuoteToken));
            }
            if (endQuoteToken == null) throw new ArgumentNullException(nameof(endQuoteToken));
            switch (endQuoteToken.Kind)
            {
                case SyntaxKind.SingleQuoteToken:
                case SyntaxKind.DoubleQuoteToken: break;
                default: throw new ArgumentException(nameof(endQuoteToken));
            }
#endif

            return new XmlTextAttributeSyntax(SyntaxKind.XmlTextAttribute, name, equalsToken, startQuoteToken, textTokens.Node, endQuoteToken);
        }

        public static XmlCrefAttributeSyntax XmlCrefAttribute(XmlNameSyntax name, SyntaxToken equalsToken, SyntaxToken startQuoteToken, CrefSyntax cref, SyntaxToken endQuoteToken)
        {
#if DEBUG
            if (name == null) throw new ArgumentNullException(nameof(name));
            if (equalsToken == null) throw new ArgumentNullException(nameof(equalsToken));
            if (equalsToken.Kind != SyntaxKind.EqualsToken) throw new ArgumentException(nameof(equalsToken));
            if (startQuoteToken == null) throw new ArgumentNullException(nameof(startQuoteToken));
            switch (startQuoteToken.Kind)
            {
                case SyntaxKind.SingleQuoteToken:
                case SyntaxKind.DoubleQuoteToken: break;
                default: throw new ArgumentException(nameof(startQuoteToken));
            }
            if (cref == null) throw new ArgumentNullException(nameof(cref));
            if (endQuoteToken == null) throw new ArgumentNullException(nameof(endQuoteToken));
            switch (endQuoteToken.Kind)
            {
                case SyntaxKind.SingleQuoteToken:
                case SyntaxKind.DoubleQuoteToken: break;
                default: throw new ArgumentException(nameof(endQuoteToken));
            }
#endif

            return new XmlCrefAttributeSyntax(SyntaxKind.XmlCrefAttribute, name, equalsToken, startQuoteToken, cref, endQuoteToken);
        }

        public static XmlNameAttributeSyntax XmlNameAttribute(XmlNameSyntax name, SyntaxToken equalsToken, SyntaxToken startQuoteToken, IdentifierNameSyntax identifier, SyntaxToken endQuoteToken)
        {
#if DEBUG
            if (name == null) throw new ArgumentNullException(nameof(name));
            if (equalsToken == null) throw new ArgumentNullException(nameof(equalsToken));
            if (equalsToken.Kind != SyntaxKind.EqualsToken) throw new ArgumentException(nameof(equalsToken));
            if (startQuoteToken == null) throw new ArgumentNullException(nameof(startQuoteToken));
            switch (startQuoteToken.Kind)
            {
                case SyntaxKind.SingleQuoteToken:
                case SyntaxKind.DoubleQuoteToken: break;
                default: throw new ArgumentException(nameof(startQuoteToken));
            }
            if (identifier == null) throw new ArgumentNullException(nameof(identifier));
            if (endQuoteToken == null) throw new ArgumentNullException(nameof(endQuoteToken));
            switch (endQuoteToken.Kind)
            {
                case SyntaxKind.SingleQuoteToken:
                case SyntaxKind.DoubleQuoteToken: break;
                default: throw new ArgumentException(nameof(endQuoteToken));
            }
#endif

            return new XmlNameAttributeSyntax(SyntaxKind.XmlNameAttribute, name, equalsToken, startQuoteToken, identifier, endQuoteToken);
        }

        public static XmlTextSyntax XmlText(Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SyntaxToken> textTokens)
        {
#if DEBUG
#endif

            int hash;
            var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.XmlText, textTokens.Node, out hash);
            if (cached != null) return (XmlTextSyntax)cached;

            var result = new XmlTextSyntax(SyntaxKind.XmlText, textTokens.Node);
            if (hash >= 0)
            {
                SyntaxNodeCache.AddNode(result, hash);
            }

            return result;
        }

        public static XmlCDataSectionSyntax XmlCDataSection(SyntaxToken startCDataToken, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SyntaxToken> textTokens, SyntaxToken endCDataToken)
        {
#if DEBUG
            if (startCDataToken == null) throw new ArgumentNullException(nameof(startCDataToken));
            if (startCDataToken.Kind != SyntaxKind.XmlCDataStartToken) throw new ArgumentException(nameof(startCDataToken));
            if (endCDataToken == null) throw new ArgumentNullException(nameof(endCDataToken));
            if (endCDataToken.Kind != SyntaxKind.XmlCDataEndToken) throw new ArgumentException(nameof(endCDataToken));
#endif

            int hash;
            var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.XmlCDataSection, startCDataToken, textTokens.Node, endCDataToken, out hash);
            if (cached != null) return (XmlCDataSectionSyntax)cached;

            var result = new XmlCDataSectionSyntax(SyntaxKind.XmlCDataSection, startCDataToken, textTokens.Node, endCDataToken);
            if (hash >= 0)
            {
                SyntaxNodeCache.AddNode(result, hash);
            }

            return result;
        }

        public static XmlProcessingInstructionSyntax XmlProcessingInstruction(SyntaxToken startProcessingInstructionToken, XmlNameSyntax name, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SyntaxToken> textTokens, SyntaxToken endProcessingInstructionToken)
        {
#if DEBUG
            if (startProcessingInstructionToken == null) throw new ArgumentNullException(nameof(startProcessingInstructionToken));
            if (startProcessingInstructionToken.Kind != SyntaxKind.XmlProcessingInstructionStartToken) throw new ArgumentException(nameof(startProcessingInstructionToken));
            if (name == null) throw new ArgumentNullException(nameof(name));
            if (endProcessingInstructionToken == null) throw new ArgumentNullException(nameof(endProcessingInstructionToken));
            if (endProcessingInstructionToken.Kind != SyntaxKind.XmlProcessingInstructionEndToken) throw new ArgumentException(nameof(endProcessingInstructionToken));
#endif

            return new XmlProcessingInstructionSyntax(SyntaxKind.XmlProcessingInstruction, startProcessingInstructionToken, name, textTokens.Node, endProcessingInstructionToken);
        }

        public static XmlCommentSyntax XmlComment(SyntaxToken lessThanExclamationMinusMinusToken, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SyntaxToken> textTokens, SyntaxToken minusMinusGreaterThanToken)
        {
#if DEBUG
            if (lessThanExclamationMinusMinusToken == null) throw new ArgumentNullException(nameof(lessThanExclamationMinusMinusToken));
            if (lessThanExclamationMinusMinusToken.Kind != SyntaxKind.XmlCommentStartToken) throw new ArgumentException(nameof(lessThanExclamationMinusMinusToken));
            if (minusMinusGreaterThanToken == null) throw new ArgumentNullException(nameof(minusMinusGreaterThanToken));
            if (minusMinusGreaterThanToken.Kind != SyntaxKind.XmlCommentEndToken) throw new ArgumentException(nameof(minusMinusGreaterThanToken));
#endif

            int hash;
            var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.XmlComment, lessThanExclamationMinusMinusToken, textTokens.Node, minusMinusGreaterThanToken, out hash);
            if (cached != null) return (XmlCommentSyntax)cached;

            var result = new XmlCommentSyntax(SyntaxKind.XmlComment, lessThanExclamationMinusMinusToken, textTokens.Node, minusMinusGreaterThanToken);
            if (hash >= 0)
            {
                SyntaxNodeCache.AddNode(result, hash);
            }

            return result;
        }

        public static IfDirectiveTriviaSyntax IfDirectiveTrivia(SyntaxToken hashToken, SyntaxToken ifKeyword, ExpressionSyntax condition, SyntaxToken endOfDirectiveToken, bool isActive, bool branchTaken, bool conditionValue)
        {
#if DEBUG
            if (hashToken == null) throw new ArgumentNullException(nameof(hashToken));
            if (hashToken.Kind != SyntaxKind.HashToken) throw new ArgumentException(nameof(hashToken));
            if (ifKeyword == null) throw new ArgumentNullException(nameof(ifKeyword));
            if (ifKeyword.Kind != SyntaxKind.IfKeyword) throw new ArgumentException(nameof(ifKeyword));
            if (condition == null) throw new ArgumentNullException(nameof(condition));
            if (endOfDirectiveToken == null) throw new ArgumentNullException(nameof(endOfDirectiveToken));
            if (endOfDirectiveToken.Kind != SyntaxKind.EndOfDirectiveToken) throw new ArgumentException(nameof(endOfDirectiveToken));
#endif

            return new IfDirectiveTriviaSyntax(SyntaxKind.IfDirectiveTrivia, hashToken, ifKeyword, condition, endOfDirectiveToken, isActive, branchTaken, conditionValue);
        }

        public static ElifDirectiveTriviaSyntax ElifDirectiveTrivia(SyntaxToken hashToken, SyntaxToken elifKeyword, ExpressionSyntax condition, SyntaxToken endOfDirectiveToken, bool isActive, bool branchTaken, bool conditionValue)
        {
#if DEBUG
            if (hashToken == null) throw new ArgumentNullException(nameof(hashToken));
            if (hashToken.Kind != SyntaxKind.HashToken) throw new ArgumentException(nameof(hashToken));
            if (elifKeyword == null) throw new ArgumentNullException(nameof(elifKeyword));
            if (elifKeyword.Kind != SyntaxKind.ElifKeyword) throw new ArgumentException(nameof(elifKeyword));
            if (condition == null) throw new ArgumentNullException(nameof(condition));
            if (endOfDirectiveToken == null) throw new ArgumentNullException(nameof(endOfDirectiveToken));
            if (endOfDirectiveToken.Kind != SyntaxKind.EndOfDirectiveToken) throw new ArgumentException(nameof(endOfDirectiveToken));
#endif

            return new ElifDirectiveTriviaSyntax(SyntaxKind.ElifDirectiveTrivia, hashToken, elifKeyword, condition, endOfDirectiveToken, isActive, branchTaken, conditionValue);
        }

        public static ElseDirectiveTriviaSyntax ElseDirectiveTrivia(SyntaxToken hashToken, SyntaxToken elseKeyword, SyntaxToken endOfDirectiveToken, bool isActive, bool branchTaken)
        {
#if DEBUG
            if (hashToken == null) throw new ArgumentNullException(nameof(hashToken));
            if (hashToken.Kind != SyntaxKind.HashToken) throw new ArgumentException(nameof(hashToken));
            if (elseKeyword == null) throw new ArgumentNullException(nameof(elseKeyword));
            if (elseKeyword.Kind != SyntaxKind.ElseKeyword) throw new ArgumentException(nameof(elseKeyword));
            if (endOfDirectiveToken == null) throw new ArgumentNullException(nameof(endOfDirectiveToken));
            if (endOfDirectiveToken.Kind != SyntaxKind.EndOfDirectiveToken) throw new ArgumentException(nameof(endOfDirectiveToken));
#endif

            return new ElseDirectiveTriviaSyntax(SyntaxKind.ElseDirectiveTrivia, hashToken, elseKeyword, endOfDirectiveToken, isActive, branchTaken);
        }

        public static EndIfDirectiveTriviaSyntax EndIfDirectiveTrivia(SyntaxToken hashToken, SyntaxToken endIfKeyword, SyntaxToken endOfDirectiveToken, bool isActive)
        {
#if DEBUG
            if (hashToken == null) throw new ArgumentNullException(nameof(hashToken));
            if (hashToken.Kind != SyntaxKind.HashToken) throw new ArgumentException(nameof(hashToken));
            if (endIfKeyword == null) throw new ArgumentNullException(nameof(endIfKeyword));
            if (endIfKeyword.Kind != SyntaxKind.EndIfKeyword) throw new ArgumentException(nameof(endIfKeyword));
            if (endOfDirectiveToken == null) throw new ArgumentNullException(nameof(endOfDirectiveToken));
            if (endOfDirectiveToken.Kind != SyntaxKind.EndOfDirectiveToken) throw new ArgumentException(nameof(endOfDirectiveToken));
#endif

            return new EndIfDirectiveTriviaSyntax(SyntaxKind.EndIfDirectiveTrivia, hashToken, endIfKeyword, endOfDirectiveToken, isActive);
        }

        public static RegionDirectiveTriviaSyntax RegionDirectiveTrivia(SyntaxToken hashToken, SyntaxToken regionKeyword, SyntaxToken endOfDirectiveToken, bool isActive)
        {
#if DEBUG
            if (hashToken == null) throw new ArgumentNullException(nameof(hashToken));
            if (hashToken.Kind != SyntaxKind.HashToken) throw new ArgumentException(nameof(hashToken));
            if (regionKeyword == null) throw new ArgumentNullException(nameof(regionKeyword));
            if (regionKeyword.Kind != SyntaxKind.RegionKeyword) throw new ArgumentException(nameof(regionKeyword));
            if (endOfDirectiveToken == null) throw new ArgumentNullException(nameof(endOfDirectiveToken));
            if (endOfDirectiveToken.Kind != SyntaxKind.EndOfDirectiveToken) throw new ArgumentException(nameof(endOfDirectiveToken));
#endif

            return new RegionDirectiveTriviaSyntax(SyntaxKind.RegionDirectiveTrivia, hashToken, regionKeyword, endOfDirectiveToken, isActive);
        }

        public static EndRegionDirectiveTriviaSyntax EndRegionDirectiveTrivia(SyntaxToken hashToken, SyntaxToken endRegionKeyword, SyntaxToken endOfDirectiveToken, bool isActive)
        {
#if DEBUG
            if (hashToken == null) throw new ArgumentNullException(nameof(hashToken));
            if (hashToken.Kind != SyntaxKind.HashToken) throw new ArgumentException(nameof(hashToken));
            if (endRegionKeyword == null) throw new ArgumentNullException(nameof(endRegionKeyword));
            if (endRegionKeyword.Kind != SyntaxKind.EndRegionKeyword) throw new ArgumentException(nameof(endRegionKeyword));
            if (endOfDirectiveToken == null) throw new ArgumentNullException(nameof(endOfDirectiveToken));
            if (endOfDirectiveToken.Kind != SyntaxKind.EndOfDirectiveToken) throw new ArgumentException(nameof(endOfDirectiveToken));
#endif

            return new EndRegionDirectiveTriviaSyntax(SyntaxKind.EndRegionDirectiveTrivia, hashToken, endRegionKeyword, endOfDirectiveToken, isActive);
        }

        public static ErrorDirectiveTriviaSyntax ErrorDirectiveTrivia(SyntaxToken hashToken, SyntaxToken errorKeyword, SyntaxToken endOfDirectiveToken, bool isActive)
        {
#if DEBUG
            if (hashToken == null) throw new ArgumentNullException(nameof(hashToken));
            if (hashToken.Kind != SyntaxKind.HashToken) throw new ArgumentException(nameof(hashToken));
            if (errorKeyword == null) throw new ArgumentNullException(nameof(errorKeyword));
            if (errorKeyword.Kind != SyntaxKind.ErrorKeyword) throw new ArgumentException(nameof(errorKeyword));
            if (endOfDirectiveToken == null) throw new ArgumentNullException(nameof(endOfDirectiveToken));
            if (endOfDirectiveToken.Kind != SyntaxKind.EndOfDirectiveToken) throw new ArgumentException(nameof(endOfDirectiveToken));
#endif

            return new ErrorDirectiveTriviaSyntax(SyntaxKind.ErrorDirectiveTrivia, hashToken, errorKeyword, endOfDirectiveToken, isActive);
        }

        public static WarningDirectiveTriviaSyntax WarningDirectiveTrivia(SyntaxToken hashToken, SyntaxToken warningKeyword, SyntaxToken endOfDirectiveToken, bool isActive)
        {
#if DEBUG
            if (hashToken == null) throw new ArgumentNullException(nameof(hashToken));
            if (hashToken.Kind != SyntaxKind.HashToken) throw new ArgumentException(nameof(hashToken));
            if (warningKeyword == null) throw new ArgumentNullException(nameof(warningKeyword));
            if (warningKeyword.Kind != SyntaxKind.WarningKeyword) throw new ArgumentException(nameof(warningKeyword));
            if (endOfDirectiveToken == null) throw new ArgumentNullException(nameof(endOfDirectiveToken));
            if (endOfDirectiveToken.Kind != SyntaxKind.EndOfDirectiveToken) throw new ArgumentException(nameof(endOfDirectiveToken));
#endif

            return new WarningDirectiveTriviaSyntax(SyntaxKind.WarningDirectiveTrivia, hashToken, warningKeyword, endOfDirectiveToken, isActive);
        }

        public static BadDirectiveTriviaSyntax BadDirectiveTrivia(SyntaxToken hashToken, SyntaxToken identifier, SyntaxToken endOfDirectiveToken, bool isActive)
        {
#if DEBUG
            if (hashToken == null) throw new ArgumentNullException(nameof(hashToken));
            if (hashToken.Kind != SyntaxKind.HashToken) throw new ArgumentException(nameof(hashToken));
            if (identifier == null) throw new ArgumentNullException(nameof(identifier));
            if (endOfDirectiveToken == null) throw new ArgumentNullException(nameof(endOfDirectiveToken));
            if (endOfDirectiveToken.Kind != SyntaxKind.EndOfDirectiveToken) throw new ArgumentException(nameof(endOfDirectiveToken));
#endif

            return new BadDirectiveTriviaSyntax(SyntaxKind.BadDirectiveTrivia, hashToken, identifier, endOfDirectiveToken, isActive);
        }

        public static DefineDirectiveTriviaSyntax DefineDirectiveTrivia(SyntaxToken hashToken, SyntaxToken defineKeyword, SyntaxToken name, SyntaxToken endOfDirectiveToken, bool isActive)
        {
#if DEBUG
            if (hashToken == null) throw new ArgumentNullException(nameof(hashToken));
            if (hashToken.Kind != SyntaxKind.HashToken) throw new ArgumentException(nameof(hashToken));
            if (defineKeyword == null) throw new ArgumentNullException(nameof(defineKeyword));
            if (defineKeyword.Kind != SyntaxKind.DefineKeyword) throw new ArgumentException(nameof(defineKeyword));
            if (name == null) throw new ArgumentNullException(nameof(name));
            if (name.Kind != SyntaxKind.IdentifierToken) throw new ArgumentException(nameof(name));
            if (endOfDirectiveToken == null) throw new ArgumentNullException(nameof(endOfDirectiveToken));
            if (endOfDirectiveToken.Kind != SyntaxKind.EndOfDirectiveToken) throw new ArgumentException(nameof(endOfDirectiveToken));
#endif

            return new DefineDirectiveTriviaSyntax(SyntaxKind.DefineDirectiveTrivia, hashToken, defineKeyword, name, endOfDirectiveToken, isActive);
        }

        public static UndefDirectiveTriviaSyntax UndefDirectiveTrivia(SyntaxToken hashToken, SyntaxToken undefKeyword, SyntaxToken name, SyntaxToken endOfDirectiveToken, bool isActive)
        {
#if DEBUG
            if (hashToken == null) throw new ArgumentNullException(nameof(hashToken));
            if (hashToken.Kind != SyntaxKind.HashToken) throw new ArgumentException(nameof(hashToken));
            if (undefKeyword == null) throw new ArgumentNullException(nameof(undefKeyword));
            if (undefKeyword.Kind != SyntaxKind.UndefKeyword) throw new ArgumentException(nameof(undefKeyword));
            if (name == null) throw new ArgumentNullException(nameof(name));
            if (name.Kind != SyntaxKind.IdentifierToken) throw new ArgumentException(nameof(name));
            if (endOfDirectiveToken == null) throw new ArgumentNullException(nameof(endOfDirectiveToken));
            if (endOfDirectiveToken.Kind != SyntaxKind.EndOfDirectiveToken) throw new ArgumentException(nameof(endOfDirectiveToken));
#endif

            return new UndefDirectiveTriviaSyntax(SyntaxKind.UndefDirectiveTrivia, hashToken, undefKeyword, name, endOfDirectiveToken, isActive);
        }

        public static LineDirectiveTriviaSyntax LineDirectiveTrivia(SyntaxToken hashToken, SyntaxToken lineKeyword, SyntaxToken line, SyntaxToken? file, SyntaxToken endOfDirectiveToken, bool isActive)
        {
#if DEBUG
            if (hashToken == null) throw new ArgumentNullException(nameof(hashToken));
            if (hashToken.Kind != SyntaxKind.HashToken) throw new ArgumentException(nameof(hashToken));
            if (lineKeyword == null) throw new ArgumentNullException(nameof(lineKeyword));
            if (lineKeyword.Kind != SyntaxKind.LineKeyword) throw new ArgumentException(nameof(lineKeyword));
            if (line == null) throw new ArgumentNullException(nameof(line));
            switch (line.Kind)
            {
                case SyntaxKind.NumericLiteralToken:
                case SyntaxKind.DefaultKeyword:
                case SyntaxKind.HiddenKeyword: break;
                default: throw new ArgumentException(nameof(line));
            }
            if (file != null)
            {
                switch (file.Kind)
                {
                    case SyntaxKind.StringLiteralToken:
                    case SyntaxKind.None: break;
                    default: throw new ArgumentException(nameof(file));
                }
            }
            if (endOfDirectiveToken == null) throw new ArgumentNullException(nameof(endOfDirectiveToken));
            if (endOfDirectiveToken.Kind != SyntaxKind.EndOfDirectiveToken) throw new ArgumentException(nameof(endOfDirectiveToken));
#endif

            return new LineDirectiveTriviaSyntax(SyntaxKind.LineDirectiveTrivia, hashToken, lineKeyword, line, file, endOfDirectiveToken, isActive);
        }

        public static PragmaWarningDirectiveTriviaSyntax PragmaWarningDirectiveTrivia(SyntaxToken hashToken, SyntaxToken pragmaKeyword, SyntaxToken warningKeyword, SyntaxToken disableOrRestoreKeyword, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<ExpressionSyntax> errorCodes, SyntaxToken endOfDirectiveToken, bool isActive)
        {
#if DEBUG
            if (hashToken == null) throw new ArgumentNullException(nameof(hashToken));
            if (hashToken.Kind != SyntaxKind.HashToken) throw new ArgumentException(nameof(hashToken));
            if (pragmaKeyword == null) throw new ArgumentNullException(nameof(pragmaKeyword));
            if (pragmaKeyword.Kind != SyntaxKind.PragmaKeyword) throw new ArgumentException(nameof(pragmaKeyword));
            if (warningKeyword == null) throw new ArgumentNullException(nameof(warningKeyword));
            if (warningKeyword.Kind != SyntaxKind.WarningKeyword) throw new ArgumentException(nameof(warningKeyword));
            if (disableOrRestoreKeyword == null) throw new ArgumentNullException(nameof(disableOrRestoreKeyword));
            switch (disableOrRestoreKeyword.Kind)
            {
                case SyntaxKind.DisableKeyword:
                case SyntaxKind.RestoreKeyword: break;
                default: throw new ArgumentException(nameof(disableOrRestoreKeyword));
            }
            if (endOfDirectiveToken == null) throw new ArgumentNullException(nameof(endOfDirectiveToken));
            if (endOfDirectiveToken.Kind != SyntaxKind.EndOfDirectiveToken) throw new ArgumentException(nameof(endOfDirectiveToken));
#endif

            return new PragmaWarningDirectiveTriviaSyntax(SyntaxKind.PragmaWarningDirectiveTrivia, hashToken, pragmaKeyword, warningKeyword, disableOrRestoreKeyword, errorCodes.Node, endOfDirectiveToken, isActive);
        }

        public static PragmaChecksumDirectiveTriviaSyntax PragmaChecksumDirectiveTrivia(SyntaxToken hashToken, SyntaxToken pragmaKeyword, SyntaxToken checksumKeyword, SyntaxToken file, SyntaxToken guid, SyntaxToken bytes, SyntaxToken endOfDirectiveToken, bool isActive)
        {
#if DEBUG
            if (hashToken == null) throw new ArgumentNullException(nameof(hashToken));
            if (hashToken.Kind != SyntaxKind.HashToken) throw new ArgumentException(nameof(hashToken));
            if (pragmaKeyword == null) throw new ArgumentNullException(nameof(pragmaKeyword));
            if (pragmaKeyword.Kind != SyntaxKind.PragmaKeyword) throw new ArgumentException(nameof(pragmaKeyword));
            if (checksumKeyword == null) throw new ArgumentNullException(nameof(checksumKeyword));
            if (checksumKeyword.Kind != SyntaxKind.ChecksumKeyword) throw new ArgumentException(nameof(checksumKeyword));
            if (file == null) throw new ArgumentNullException(nameof(file));
            if (file.Kind != SyntaxKind.StringLiteralToken) throw new ArgumentException(nameof(file));
            if (guid == null) throw new ArgumentNullException(nameof(guid));
            if (guid.Kind != SyntaxKind.StringLiteralToken) throw new ArgumentException(nameof(guid));
            if (bytes == null) throw new ArgumentNullException(nameof(bytes));
            if (bytes.Kind != SyntaxKind.StringLiteralToken) throw new ArgumentException(nameof(bytes));
            if (endOfDirectiveToken == null) throw new ArgumentNullException(nameof(endOfDirectiveToken));
            if (endOfDirectiveToken.Kind != SyntaxKind.EndOfDirectiveToken) throw new ArgumentException(nameof(endOfDirectiveToken));
#endif

            return new PragmaChecksumDirectiveTriviaSyntax(SyntaxKind.PragmaChecksumDirectiveTrivia, hashToken, pragmaKeyword, checksumKeyword, file, guid, bytes, endOfDirectiveToken, isActive);
        }

        public static ReferenceDirectiveTriviaSyntax ReferenceDirectiveTrivia(SyntaxToken hashToken, SyntaxToken referenceKeyword, SyntaxToken file, SyntaxToken endOfDirectiveToken, bool isActive)
        {
#if DEBUG
            if (hashToken == null) throw new ArgumentNullException(nameof(hashToken));
            if (hashToken.Kind != SyntaxKind.HashToken) throw new ArgumentException(nameof(hashToken));
            if (referenceKeyword == null) throw new ArgumentNullException(nameof(referenceKeyword));
            if (referenceKeyword.Kind != SyntaxKind.ReferenceKeyword) throw new ArgumentException(nameof(referenceKeyword));
            if (file == null) throw new ArgumentNullException(nameof(file));
            if (file.Kind != SyntaxKind.StringLiteralToken) throw new ArgumentException(nameof(file));
            if (endOfDirectiveToken == null) throw new ArgumentNullException(nameof(endOfDirectiveToken));
            if (endOfDirectiveToken.Kind != SyntaxKind.EndOfDirectiveToken) throw new ArgumentException(nameof(endOfDirectiveToken));
#endif

            return new ReferenceDirectiveTriviaSyntax(SyntaxKind.ReferenceDirectiveTrivia, hashToken, referenceKeyword, file, endOfDirectiveToken, isActive);
        }

        public static LoadDirectiveTriviaSyntax LoadDirectiveTrivia(SyntaxToken hashToken, SyntaxToken loadKeyword, SyntaxToken file, SyntaxToken endOfDirectiveToken, bool isActive)
        {
#if DEBUG
            if (hashToken == null) throw new ArgumentNullException(nameof(hashToken));
            if (hashToken.Kind != SyntaxKind.HashToken) throw new ArgumentException(nameof(hashToken));
            if (loadKeyword == null) throw new ArgumentNullException(nameof(loadKeyword));
            if (loadKeyword.Kind != SyntaxKind.LoadKeyword) throw new ArgumentException(nameof(loadKeyword));
            if (file == null) throw new ArgumentNullException(nameof(file));
            if (file.Kind != SyntaxKind.StringLiteralToken) throw new ArgumentException(nameof(file));
            if (endOfDirectiveToken == null) throw new ArgumentNullException(nameof(endOfDirectiveToken));
            if (endOfDirectiveToken.Kind != SyntaxKind.EndOfDirectiveToken) throw new ArgumentException(nameof(endOfDirectiveToken));
#endif

            return new LoadDirectiveTriviaSyntax(SyntaxKind.LoadDirectiveTrivia, hashToken, loadKeyword, file, endOfDirectiveToken, isActive);
        }

        public static ShebangDirectiveTriviaSyntax ShebangDirectiveTrivia(SyntaxToken hashToken, SyntaxToken exclamationToken, SyntaxToken endOfDirectiveToken, bool isActive)
        {
#if DEBUG
            if (hashToken == null) throw new ArgumentNullException(nameof(hashToken));
            if (hashToken.Kind != SyntaxKind.HashToken) throw new ArgumentException(nameof(hashToken));
            if (exclamationToken == null) throw new ArgumentNullException(nameof(exclamationToken));
            if (exclamationToken.Kind != SyntaxKind.ExclamationToken) throw new ArgumentException(nameof(exclamationToken));
            if (endOfDirectiveToken == null) throw new ArgumentNullException(nameof(endOfDirectiveToken));
            if (endOfDirectiveToken.Kind != SyntaxKind.EndOfDirectiveToken) throw new ArgumentException(nameof(endOfDirectiveToken));
#endif

            return new ShebangDirectiveTriviaSyntax(SyntaxKind.ShebangDirectiveTrivia, hashToken, exclamationToken, endOfDirectiveToken, isActive);
        }

        public static NullableDirectiveTriviaSyntax NullableDirectiveTrivia(SyntaxToken hashToken, SyntaxToken nullableKeyword, SyntaxToken settingToken, SyntaxToken? targetToken, SyntaxToken endOfDirectiveToken, bool isActive)
        {
#if DEBUG
            if (hashToken == null) throw new ArgumentNullException(nameof(hashToken));
            if (hashToken.Kind != SyntaxKind.HashToken) throw new ArgumentException(nameof(hashToken));
            if (nullableKeyword == null) throw new ArgumentNullException(nameof(nullableKeyword));
            if (nullableKeyword.Kind != SyntaxKind.NullableKeyword) throw new ArgumentException(nameof(nullableKeyword));
            if (settingToken == null) throw new ArgumentNullException(nameof(settingToken));
            switch (settingToken.Kind)
            {
                case SyntaxKind.EnableKeyword:
                case SyntaxKind.DisableKeyword:
                case SyntaxKind.RestoreKeyword: break;
                default: throw new ArgumentException(nameof(settingToken));
            }
            if (targetToken != null)
            {
                switch (targetToken.Kind)
                {
                    case SyntaxKind.WarningsKeyword:
                    case SyntaxKind.AnnotationsKeyword:
                    case SyntaxKind.None: break;
                    default: throw new ArgumentException(nameof(targetToken));
                }
            }
            if (endOfDirectiveToken == null) throw new ArgumentNullException(nameof(endOfDirectiveToken));
            if (endOfDirectiveToken.Kind != SyntaxKind.EndOfDirectiveToken) throw new ArgumentException(nameof(endOfDirectiveToken));
#endif

            return new NullableDirectiveTriviaSyntax(SyntaxKind.NullableDirectiveTrivia, hashToken, nullableKeyword, settingToken, targetToken, endOfDirectiveToken, isActive);
        }

        internal static IEnumerable<Type> GetNodeTypes()
            => new Type[]
            {
                typeof(IdentifierNameSyntax),
                typeof(QualifiedNameSyntax),
                typeof(GenericNameSyntax),
                typeof(TypeArgumentListSyntax),
                typeof(AliasQualifiedNameSyntax),
                typeof(PredefinedTypeSyntax),
                typeof(ArrayTypeSyntax),
                typeof(ArrayRankSpecifierSyntax),
                typeof(PointerTypeSyntax),
                typeof(FunctionPointerTypeSyntax),
                typeof(FunctionPointerParameterListSyntax),
                typeof(FunctionPointerCallingConventionSyntax),
                typeof(FunctionPointerUnmanagedCallingConventionListSyntax),
                typeof(FunctionPointerUnmanagedCallingConventionSyntax),
                typeof(NullableTypeSyntax),
                typeof(TupleTypeSyntax),
                typeof(TupleElementSyntax),
                typeof(OmittedTypeArgumentSyntax),
                typeof(RefTypeSyntax),
                typeof(ParenthesizedExpressionSyntax),
                typeof(TupleExpressionSyntax),
                typeof(PrefixUnaryExpressionSyntax),
                typeof(AwaitExpressionSyntax),
                typeof(PostfixUnaryExpressionSyntax),
                typeof(MemberAccessExpressionSyntax),
                typeof(ConditionalAccessExpressionSyntax),
                typeof(MemberBindingExpressionSyntax),
                typeof(ElementBindingExpressionSyntax),
                typeof(RangeExpressionSyntax),
                typeof(ImplicitElementAccessSyntax),
                typeof(BinaryExpressionSyntax),
                typeof(AssignmentExpressionSyntax),
                typeof(ConditionalExpressionSyntax),
                typeof(ThisExpressionSyntax),
                typeof(BaseExpressionSyntax),
                typeof(LiteralExpressionSyntax),
                typeof(MakeRefExpressionSyntax),
                typeof(RefTypeExpressionSyntax),
                typeof(RefValueExpressionSyntax),
                typeof(CheckedExpressionSyntax),
                typeof(DefaultExpressionSyntax),
                typeof(TypeOfExpressionSyntax),
                typeof(SizeOfExpressionSyntax),
                typeof(InvocationExpressionSyntax),
                typeof(ElementAccessExpressionSyntax),
                typeof(ArgumentListSyntax),
                typeof(BracketedArgumentListSyntax),
                typeof(ArgumentSyntax),
                typeof(NameColonSyntax),
                typeof(DeclarationExpressionSyntax),
                typeof(CastExpressionSyntax),
                typeof(AnonymousMethodExpressionSyntax),
                typeof(SimpleLambdaExpressionSyntax),
                typeof(RefExpressionSyntax),
                typeof(ParenthesizedLambdaExpressionSyntax),
                typeof(InitializerExpressionSyntax),
                typeof(ImplicitObjectCreationExpressionSyntax),
                typeof(ObjectCreationExpressionSyntax),
                typeof(WithExpressionSyntax),
                typeof(AnonymousObjectMemberDeclaratorSyntax),
                typeof(AnonymousObjectCreationExpressionSyntax),
                typeof(ArrayCreationExpressionSyntax),
                typeof(ImplicitArrayCreationExpressionSyntax),
                typeof(StackAllocArrayCreationExpressionSyntax),
                typeof(ImplicitStackAllocArrayCreationExpressionSyntax),
                typeof(QueryExpressionSyntax),
                typeof(QueryBodySyntax),
                typeof(FromClauseSyntax),
                typeof(LetClauseSyntax),
                typeof(JoinClauseSyntax),
                typeof(JoinIntoClauseSyntax),
                typeof(WhereClauseSyntax),
                typeof(OrderByClauseSyntax),
                typeof(OrderingSyntax),
                typeof(SelectClauseSyntax),
                typeof(GroupClauseSyntax),
                typeof(QueryContinuationSyntax),
                typeof(OmittedArraySizeExpressionSyntax),
                typeof(InterpolatedStringExpressionSyntax),
                typeof(IsPatternExpressionSyntax),
                typeof(ThrowExpressionSyntax),
                typeof(WhenClauseSyntax),
                typeof(DiscardPatternSyntax),
                typeof(DeclarationPatternSyntax),
                typeof(VarPatternSyntax),
                typeof(RecursivePatternSyntax),
                typeof(PositionalPatternClauseSyntax),
                typeof(PropertyPatternClauseSyntax),
                typeof(SubpatternSyntax),
                typeof(ConstantPatternSyntax),
                typeof(ParenthesizedPatternSyntax),
                typeof(RelationalPatternSyntax),
                typeof(TypePatternSyntax),
                typeof(BinaryPatternSyntax),
                typeof(UnaryPatternSyntax),
                typeof(InterpolatedStringTextSyntax),
                typeof(InterpolationSyntax),
                typeof(InterpolationAlignmentClauseSyntax),
                typeof(InterpolationFormatClauseSyntax),
                typeof(GlobalStatementSyntax),
                typeof(BlockSyntax),
                typeof(LocalFunctionStatementSyntax),
                typeof(LocalDeclarationStatementSyntax),
                typeof(VariableDeclarationSyntax),
                typeof(VariableDeclaratorSyntax),
                typeof(EqualsValueClauseSyntax),
                typeof(SingleVariableDesignationSyntax),
                typeof(DiscardDesignationSyntax),
                typeof(ParenthesizedVariableDesignationSyntax),
                typeof(ExpressionStatementSyntax),
                typeof(EmptyStatementSyntax),
                typeof(LabeledStatementSyntax),
                typeof(GotoStatementSyntax),
                typeof(BreakStatementSyntax),
                typeof(ContinueStatementSyntax),
                typeof(ReturnStatementSyntax),
                typeof(ThrowStatementSyntax),
                typeof(YieldStatementSyntax),
                typeof(WhileStatementSyntax),
                typeof(DoStatementSyntax),
                typeof(ForStatementSyntax),
                typeof(ForEachStatementSyntax),
                typeof(ForEachVariableStatementSyntax),
                typeof(UsingStatementSyntax),
                typeof(FixedStatementSyntax),
                typeof(CheckedStatementSyntax),
                typeof(UnsafeStatementSyntax),
                typeof(LockStatementSyntax),
                typeof(IfStatementSyntax),
                typeof(ElseClauseSyntax),
                typeof(SwitchStatementSyntax),
                typeof(SwitchSectionSyntax),
                typeof(CasePatternSwitchLabelSyntax),
                typeof(CaseSwitchLabelSyntax),
                typeof(DefaultSwitchLabelSyntax),
                typeof(SwitchExpressionSyntax),
                typeof(SwitchExpressionArmSyntax),
                typeof(TryStatementSyntax),
                typeof(CatchClauseSyntax),
                typeof(CatchDeclarationSyntax),
                typeof(CatchFilterClauseSyntax),
                typeof(FinallyClauseSyntax),
                typeof(CompilationUnitSyntax),
                typeof(ExternAliasDirectiveSyntax),
                typeof(UsingDirectiveSyntax),
                typeof(NamespaceDeclarationSyntax),
                typeof(AttributeListSyntax),
                typeof(AttributeTargetSpecifierSyntax),
                typeof(AttributeSyntax),
                typeof(AttributeArgumentListSyntax),
                typeof(AttributeArgumentSyntax),
                typeof(NameEqualsSyntax),
                typeof(TypeParameterListSyntax),
                typeof(TypeParameterSyntax),
                typeof(ClassDeclarationSyntax),
                typeof(StructDeclarationSyntax),
                typeof(InterfaceDeclarationSyntax),
                typeof(RecordDeclarationSyntax),
                typeof(EnumDeclarationSyntax),
                typeof(DelegateDeclarationSyntax),
                typeof(EnumMemberDeclarationSyntax),
                typeof(BaseListSyntax),
                typeof(SimpleBaseTypeSyntax),
                typeof(PrimaryConstructorBaseTypeSyntax),
                typeof(TypeParameterConstraintClauseSyntax),
                typeof(ConstructorConstraintSyntax),
                typeof(ClassOrStructConstraintSyntax),
                typeof(TypeConstraintSyntax),
                typeof(DefaultConstraintSyntax),
                typeof(FieldDeclarationSyntax),
                typeof(EventFieldDeclarationSyntax),
                typeof(ExplicitInterfaceSpecifierSyntax),
                typeof(MethodDeclarationSyntax),
                typeof(OperatorDeclarationSyntax),
                typeof(ConversionOperatorDeclarationSyntax),
                typeof(ConstructorDeclarationSyntax),
                typeof(ConstructorInitializerSyntax),
                typeof(DestructorDeclarationSyntax),
                typeof(PropertyDeclarationSyntax),
                typeof(ArrowExpressionClauseSyntax),
                typeof(EventDeclarationSyntax),
                typeof(IndexerDeclarationSyntax),
                typeof(AccessorListSyntax),
                typeof(AccessorDeclarationSyntax),
                typeof(ParameterListSyntax),
                typeof(BracketedParameterListSyntax),
                typeof(ParameterSyntax),
                typeof(FunctionPointerParameterSyntax),
                typeof(IncompleteMemberSyntax),
                typeof(SkippedTokensTriviaSyntax),
                typeof(DocumentationCommentTriviaSyntax),
                typeof(TypeCrefSyntax),
                typeof(QualifiedCrefSyntax),
                typeof(NameMemberCrefSyntax),
                typeof(IndexerMemberCrefSyntax),
                typeof(OperatorMemberCrefSyntax),
                typeof(ConversionOperatorMemberCrefSyntax),
                typeof(CrefParameterListSyntax),
                typeof(CrefBracketedParameterListSyntax),
                typeof(CrefParameterSyntax),
                typeof(XmlElementSyntax),
                typeof(XmlElementStartTagSyntax),
                typeof(XmlElementEndTagSyntax),
                typeof(XmlEmptyElementSyntax),
                typeof(XmlNameSyntax),
                typeof(XmlPrefixSyntax),
                typeof(XmlTextAttributeSyntax),
                typeof(XmlCrefAttributeSyntax),
                typeof(XmlNameAttributeSyntax),
                typeof(XmlTextSyntax),
                typeof(XmlCDataSectionSyntax),
                typeof(XmlProcessingInstructionSyntax),
                typeof(XmlCommentSyntax),
                typeof(IfDirectiveTriviaSyntax),
                typeof(ElifDirectiveTriviaSyntax),
                typeof(ElseDirectiveTriviaSyntax),
                typeof(EndIfDirectiveTriviaSyntax),
                typeof(RegionDirectiveTriviaSyntax),
                typeof(EndRegionDirectiveTriviaSyntax),
                typeof(ErrorDirectiveTriviaSyntax),
                typeof(WarningDirectiveTriviaSyntax),
                typeof(BadDirectiveTriviaSyntax),
                typeof(DefineDirectiveTriviaSyntax),
                typeof(UndefDirectiveTriviaSyntax),
                typeof(LineDirectiveTriviaSyntax),
                typeof(PragmaWarningDirectiveTriviaSyntax),
                typeof(PragmaChecksumDirectiveTriviaSyntax),
                typeof(ReferenceDirectiveTriviaSyntax),
                typeof(LoadDirectiveTriviaSyntax),
                typeof(ShebangDirectiveTriviaSyntax),
                typeof(NullableDirectiveTriviaSyntax),
            };
    }
}
