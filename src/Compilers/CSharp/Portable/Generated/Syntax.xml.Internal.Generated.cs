// <auto-generated />

#nullable enable

using System;
using System.Collections;
using System.Collections.Generic;
using System.Linq;
using System.Threading;
using Microsoft.CodeAnalysis.Syntax.InternalSyntax;
using Roslyn.Utilities;

namespace Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax
{
  /// <summary>Provides the base class from which the classes that represent name syntax nodes are derived. This is an abstract class.</summary>
  internal abstract partial class NameSyntax : TypeSyntax
  {
    internal NameSyntax(SyntaxKind kind, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
      : base(kind, diagnostics, annotations)
    {
    }
    internal NameSyntax(SyntaxKind kind)
      : base(kind)
    {
    }

    protected NameSyntax(ObjectReader reader)
       : base(reader)
    {
    }
  }

  /// <summary>Provides the base class from which the classes that represent simple name syntax nodes are derived. This is an abstract class.</summary>
  internal abstract partial class SimpleNameSyntax : NameSyntax
  {
    internal SimpleNameSyntax(SyntaxKind kind, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
      : base(kind, diagnostics, annotations)
    {
    }
    internal SimpleNameSyntax(SyntaxKind kind)
      : base(kind)
    {
    }

    protected SimpleNameSyntax(ObjectReader reader)
       : base(reader)
    {
    }

    /// <summary>SyntaxToken representing the identifier of the simple name.</summary>
    public abstract SyntaxToken Identifier { get; }
  }

  /// <summary>Class which represents the syntax node for identifier name.</summary>
  internal sealed partial class IdentifierNameSyntax : SimpleNameSyntax
  {
    internal readonly SyntaxToken identifier;

    internal IdentifierNameSyntax(SyntaxKind kind, SyntaxToken identifier, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 1;
        this.AdjustFlagsAndWidth(identifier);
        this.identifier = identifier;
    }


    internal IdentifierNameSyntax(SyntaxKind kind, SyntaxToken identifier, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 1;
        this.AdjustFlagsAndWidth(identifier);
        this.identifier = identifier;
    }


    internal IdentifierNameSyntax(SyntaxKind kind, SyntaxToken identifier)
        : base(kind)
    {
        this.SlotCount = 1;
        this.AdjustFlagsAndWidth(identifier);
        this.identifier = identifier;
    }

    /// <summary>SyntaxToken representing the keyword for the kind of the identifier name.</summary>
    public override SyntaxToken Identifier => this.identifier;

    internal override GreenNode? GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.identifier;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new CSharp.Syntax.IdentifierNameSyntax(this, parent, position);

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor) => visitor.VisitIdentifierName(this);

    public override void Accept(CSharpSyntaxVisitor visitor) => visitor.VisitIdentifierName(this);

    public IdentifierNameSyntax Update(SyntaxToken identifier)
    {
        if (identifier != this.Identifier)
        {
            var newNode = SyntaxFactory.IdentifierName(identifier);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
        => new IdentifierNameSyntax(this.Kind, this.identifier, diagnostics, GetAnnotations());

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
        => new IdentifierNameSyntax(this.Kind, this.identifier, GetDiagnostics(), annotations);

    internal IdentifierNameSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 1;
      var identifier = (SyntaxToken)reader.ReadValue();
      if (identifier != null)
      {
         AdjustFlagsAndWidth(identifier);
         this.identifier = identifier;
      }
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.identifier);
    }

    static IdentifierNameSyntax()
    {
       ObjectBinder.RegisterTypeReader(typeof(IdentifierNameSyntax), r => new IdentifierNameSyntax(r));
    }
  }

  /// <summary>Class which represents the syntax node for qualified name.</summary>
  internal sealed partial class QualifiedNameSyntax : NameSyntax
  {
    internal readonly NameSyntax left;
    internal readonly SyntaxToken dotToken;
    internal readonly SimpleNameSyntax right;

    internal QualifiedNameSyntax(SyntaxKind kind, NameSyntax left, SyntaxToken dotToken, SimpleNameSyntax right, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 3;
        this.AdjustFlagsAndWidth(left);
        this.left = left;
        this.AdjustFlagsAndWidth(dotToken);
        this.dotToken = dotToken;
        this.AdjustFlagsAndWidth(right);
        this.right = right;
    }


    internal QualifiedNameSyntax(SyntaxKind kind, NameSyntax left, SyntaxToken dotToken, SimpleNameSyntax right, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 3;
        this.AdjustFlagsAndWidth(left);
        this.left = left;
        this.AdjustFlagsAndWidth(dotToken);
        this.dotToken = dotToken;
        this.AdjustFlagsAndWidth(right);
        this.right = right;
    }


    internal QualifiedNameSyntax(SyntaxKind kind, NameSyntax left, SyntaxToken dotToken, SimpleNameSyntax right)
        : base(kind)
    {
        this.SlotCount = 3;
        this.AdjustFlagsAndWidth(left);
        this.left = left;
        this.AdjustFlagsAndWidth(dotToken);
        this.dotToken = dotToken;
        this.AdjustFlagsAndWidth(right);
        this.right = right;
    }

    /// <summary>NameSyntax node representing the name on the left side of the dot token of the qualified name.</summary>
    public NameSyntax Left => this.left;
    /// <summary>SyntaxToken representing the dot.</summary>
    public SyntaxToken DotToken => this.dotToken;
    /// <summary>SimpleNameSyntax node representing the name on the right side of the dot token of the qualified name.</summary>
    public SimpleNameSyntax Right => this.right;

    internal override GreenNode? GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.left;
            case 1: return this.dotToken;
            case 2: return this.right;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new CSharp.Syntax.QualifiedNameSyntax(this, parent, position);

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor) => visitor.VisitQualifiedName(this);

    public override void Accept(CSharpSyntaxVisitor visitor) => visitor.VisitQualifiedName(this);

    public QualifiedNameSyntax Update(NameSyntax left, SyntaxToken dotToken, SimpleNameSyntax right)
    {
        if (left != this.Left || dotToken != this.DotToken || right != this.Right)
        {
            var newNode = SyntaxFactory.QualifiedName(left, dotToken, right);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
        => new QualifiedNameSyntax(this.Kind, this.left, this.dotToken, this.right, diagnostics, GetAnnotations());

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
        => new QualifiedNameSyntax(this.Kind, this.left, this.dotToken, this.right, GetDiagnostics(), annotations);

    internal QualifiedNameSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 3;
      var left = (NameSyntax)reader.ReadValue();
      if (left != null)
      {
         AdjustFlagsAndWidth(left);
         this.left = left;
      }
      var dotToken = (SyntaxToken)reader.ReadValue();
      if (dotToken != null)
      {
         AdjustFlagsAndWidth(dotToken);
         this.dotToken = dotToken;
      }
      var right = (SimpleNameSyntax)reader.ReadValue();
      if (right != null)
      {
         AdjustFlagsAndWidth(right);
         this.right = right;
      }
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.left);
      writer.WriteValue(this.dotToken);
      writer.WriteValue(this.right);
    }

    static QualifiedNameSyntax()
    {
       ObjectBinder.RegisterTypeReader(typeof(QualifiedNameSyntax), r => new QualifiedNameSyntax(r));
    }
  }

  /// <summary>Class which represents the syntax node for generic name.</summary>
  internal sealed partial class GenericNameSyntax : SimpleNameSyntax
  {
    internal readonly SyntaxToken identifier;
    internal readonly TypeArgumentListSyntax typeArgumentList;

    internal GenericNameSyntax(SyntaxKind kind, SyntaxToken identifier, TypeArgumentListSyntax typeArgumentList, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 2;
        this.AdjustFlagsAndWidth(identifier);
        this.identifier = identifier;
        this.AdjustFlagsAndWidth(typeArgumentList);
        this.typeArgumentList = typeArgumentList;
    }


    internal GenericNameSyntax(SyntaxKind kind, SyntaxToken identifier, TypeArgumentListSyntax typeArgumentList, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 2;
        this.AdjustFlagsAndWidth(identifier);
        this.identifier = identifier;
        this.AdjustFlagsAndWidth(typeArgumentList);
        this.typeArgumentList = typeArgumentList;
    }


    internal GenericNameSyntax(SyntaxKind kind, SyntaxToken identifier, TypeArgumentListSyntax typeArgumentList)
        : base(kind)
    {
        this.SlotCount = 2;
        this.AdjustFlagsAndWidth(identifier);
        this.identifier = identifier;
        this.AdjustFlagsAndWidth(typeArgumentList);
        this.typeArgumentList = typeArgumentList;
    }

    /// <summary>SyntaxToken representing the name of the identifier of the generic name.</summary>
    public override SyntaxToken Identifier => this.identifier;
    /// <summary>TypeArgumentListSyntax node representing the list of type arguments of the generic name.</summary>
    public TypeArgumentListSyntax TypeArgumentList => this.typeArgumentList;

    internal override GreenNode? GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.identifier;
            case 1: return this.typeArgumentList;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new CSharp.Syntax.GenericNameSyntax(this, parent, position);

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor) => visitor.VisitGenericName(this);

    public override void Accept(CSharpSyntaxVisitor visitor) => visitor.VisitGenericName(this);

    public GenericNameSyntax Update(SyntaxToken identifier, TypeArgumentListSyntax typeArgumentList)
    {
        if (identifier != this.Identifier || typeArgumentList != this.TypeArgumentList)
        {
            var newNode = SyntaxFactory.GenericName(identifier, typeArgumentList);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
        => new GenericNameSyntax(this.Kind, this.identifier, this.typeArgumentList, diagnostics, GetAnnotations());

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
        => new GenericNameSyntax(this.Kind, this.identifier, this.typeArgumentList, GetDiagnostics(), annotations);

    internal GenericNameSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 2;
      var identifier = (SyntaxToken)reader.ReadValue();
      if (identifier != null)
      {
         AdjustFlagsAndWidth(identifier);
         this.identifier = identifier;
      }
      var typeArgumentList = (TypeArgumentListSyntax)reader.ReadValue();
      if (typeArgumentList != null)
      {
         AdjustFlagsAndWidth(typeArgumentList);
         this.typeArgumentList = typeArgumentList;
      }
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.identifier);
      writer.WriteValue(this.typeArgumentList);
    }

    static GenericNameSyntax()
    {
       ObjectBinder.RegisterTypeReader(typeof(GenericNameSyntax), r => new GenericNameSyntax(r));
    }
  }

  /// <summary>Class which represents the syntax node for type argument list.</summary>
  internal sealed partial class TypeArgumentListSyntax : CSharpSyntaxNode
  {
    internal readonly SyntaxToken lessThanToken;
    internal readonly GreenNode? arguments;
    internal readonly SyntaxToken greaterThanToken;

    internal TypeArgumentListSyntax(SyntaxKind kind, SyntaxToken lessThanToken, GreenNode? arguments, SyntaxToken greaterThanToken, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 3;
        this.AdjustFlagsAndWidth(lessThanToken);
        this.lessThanToken = lessThanToken;
        if (arguments != null)
        {
            this.AdjustFlagsAndWidth(arguments);
            this.arguments = arguments;
        }
        this.AdjustFlagsAndWidth(greaterThanToken);
        this.greaterThanToken = greaterThanToken;
    }


    internal TypeArgumentListSyntax(SyntaxKind kind, SyntaxToken lessThanToken, GreenNode? arguments, SyntaxToken greaterThanToken, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 3;
        this.AdjustFlagsAndWidth(lessThanToken);
        this.lessThanToken = lessThanToken;
        if (arguments != null)
        {
            this.AdjustFlagsAndWidth(arguments);
            this.arguments = arguments;
        }
        this.AdjustFlagsAndWidth(greaterThanToken);
        this.greaterThanToken = greaterThanToken;
    }


    internal TypeArgumentListSyntax(SyntaxKind kind, SyntaxToken lessThanToken, GreenNode? arguments, SyntaxToken greaterThanToken)
        : base(kind)
    {
        this.SlotCount = 3;
        this.AdjustFlagsAndWidth(lessThanToken);
        this.lessThanToken = lessThanToken;
        if (arguments != null)
        {
            this.AdjustFlagsAndWidth(arguments);
            this.arguments = arguments;
        }
        this.AdjustFlagsAndWidth(greaterThanToken);
        this.greaterThanToken = greaterThanToken;
    }

    /// <summary>SyntaxToken representing less than.</summary>
    public SyntaxToken LessThanToken => this.lessThanToken;
    /// <summary>SeparatedSyntaxList of TypeSyntax node representing the type arguments.</summary>
    public Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<TypeSyntax> Arguments => new Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<TypeSyntax>(new Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<CSharpSyntaxNode>(this.arguments));
    /// <summary>SyntaxToken representing greater than.</summary>
    public SyntaxToken GreaterThanToken => this.greaterThanToken;

    internal override GreenNode? GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.lessThanToken;
            case 1: return this.arguments;
            case 2: return this.greaterThanToken;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new CSharp.Syntax.TypeArgumentListSyntax(this, parent, position);

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor) => visitor.VisitTypeArgumentList(this);

    public override void Accept(CSharpSyntaxVisitor visitor) => visitor.VisitTypeArgumentList(this);

    public TypeArgumentListSyntax Update(SyntaxToken lessThanToken, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<TypeSyntax> arguments, SyntaxToken greaterThanToken)
    {
        if (lessThanToken != this.LessThanToken || arguments != this.Arguments || greaterThanToken != this.GreaterThanToken)
        {
            var newNode = SyntaxFactory.TypeArgumentList(lessThanToken, arguments, greaterThanToken);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
        => new TypeArgumentListSyntax(this.Kind, this.lessThanToken, this.arguments, this.greaterThanToken, diagnostics, GetAnnotations());

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
        => new TypeArgumentListSyntax(this.Kind, this.lessThanToken, this.arguments, this.greaterThanToken, GetDiagnostics(), annotations);

    internal TypeArgumentListSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 3;
      var lessThanToken = (SyntaxToken)reader.ReadValue();
      if (lessThanToken != null)
      {
         AdjustFlagsAndWidth(lessThanToken);
         this.lessThanToken = lessThanToken;
      }
      var arguments = (GreenNode?)reader.ReadValue();
      if (arguments != null)
      {
         AdjustFlagsAndWidth(arguments);
         this.arguments = arguments;
      }
      var greaterThanToken = (SyntaxToken)reader.ReadValue();
      if (greaterThanToken != null)
      {
         AdjustFlagsAndWidth(greaterThanToken);
         this.greaterThanToken = greaterThanToken;
      }
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.lessThanToken);
      writer.WriteValue(this.arguments);
      writer.WriteValue(this.greaterThanToken);
    }

    static TypeArgumentListSyntax()
    {
       ObjectBinder.RegisterTypeReader(typeof(TypeArgumentListSyntax), r => new TypeArgumentListSyntax(r));
    }
  }

  /// <summary>Class which represents the syntax node for alias qualified name.</summary>
  internal sealed partial class AliasQualifiedNameSyntax : NameSyntax
  {
    internal readonly IdentifierNameSyntax alias;
    internal readonly SyntaxToken colonColonToken;
    internal readonly SimpleNameSyntax name;

    internal AliasQualifiedNameSyntax(SyntaxKind kind, IdentifierNameSyntax alias, SyntaxToken colonColonToken, SimpleNameSyntax name, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 3;
        this.AdjustFlagsAndWidth(alias);
        this.alias = alias;
        this.AdjustFlagsAndWidth(colonColonToken);
        this.colonColonToken = colonColonToken;
        this.AdjustFlagsAndWidth(name);
        this.name = name;
    }


    internal AliasQualifiedNameSyntax(SyntaxKind kind, IdentifierNameSyntax alias, SyntaxToken colonColonToken, SimpleNameSyntax name, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 3;
        this.AdjustFlagsAndWidth(alias);
        this.alias = alias;
        this.AdjustFlagsAndWidth(colonColonToken);
        this.colonColonToken = colonColonToken;
        this.AdjustFlagsAndWidth(name);
        this.name = name;
    }


    internal AliasQualifiedNameSyntax(SyntaxKind kind, IdentifierNameSyntax alias, SyntaxToken colonColonToken, SimpleNameSyntax name)
        : base(kind)
    {
        this.SlotCount = 3;
        this.AdjustFlagsAndWidth(alias);
        this.alias = alias;
        this.AdjustFlagsAndWidth(colonColonToken);
        this.colonColonToken = colonColonToken;
        this.AdjustFlagsAndWidth(name);
        this.name = name;
    }

    /// <summary>IdentifierNameSyntax node representing the name of the alias</summary>
    public IdentifierNameSyntax Alias => this.alias;
    /// <summary>SyntaxToken representing colon colon.</summary>
    public SyntaxToken ColonColonToken => this.colonColonToken;
    /// <summary>SimpleNameSyntax node representing the name that is being alias qualified.</summary>
    public SimpleNameSyntax Name => this.name;

    internal override GreenNode? GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.alias;
            case 1: return this.colonColonToken;
            case 2: return this.name;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new CSharp.Syntax.AliasQualifiedNameSyntax(this, parent, position);

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor) => visitor.VisitAliasQualifiedName(this);

    public override void Accept(CSharpSyntaxVisitor visitor) => visitor.VisitAliasQualifiedName(this);

    public AliasQualifiedNameSyntax Update(IdentifierNameSyntax alias, SyntaxToken colonColonToken, SimpleNameSyntax name)
    {
        if (alias != this.Alias || colonColonToken != this.ColonColonToken || name != this.Name)
        {
            var newNode = SyntaxFactory.AliasQualifiedName(alias, colonColonToken, name);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
        => new AliasQualifiedNameSyntax(this.Kind, this.alias, this.colonColonToken, this.name, diagnostics, GetAnnotations());

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
        => new AliasQualifiedNameSyntax(this.Kind, this.alias, this.colonColonToken, this.name, GetDiagnostics(), annotations);

    internal AliasQualifiedNameSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 3;
      var alias = (IdentifierNameSyntax)reader.ReadValue();
      if (alias != null)
      {
         AdjustFlagsAndWidth(alias);
         this.alias = alias;
      }
      var colonColonToken = (SyntaxToken)reader.ReadValue();
      if (colonColonToken != null)
      {
         AdjustFlagsAndWidth(colonColonToken);
         this.colonColonToken = colonColonToken;
      }
      var name = (SimpleNameSyntax)reader.ReadValue();
      if (name != null)
      {
         AdjustFlagsAndWidth(name);
         this.name = name;
      }
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.alias);
      writer.WriteValue(this.colonColonToken);
      writer.WriteValue(this.name);
    }

    static AliasQualifiedNameSyntax()
    {
       ObjectBinder.RegisterTypeReader(typeof(AliasQualifiedNameSyntax), r => new AliasQualifiedNameSyntax(r));
    }
  }

  /// <summary>Provides the base class from which the classes that represent type syntax nodes are derived. This is an abstract class.</summary>
  internal abstract partial class TypeSyntax : ExpressionSyntax
  {
    internal TypeSyntax(SyntaxKind kind, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
      : base(kind, diagnostics, annotations)
    {
    }
    internal TypeSyntax(SyntaxKind kind)
      : base(kind)
    {
    }

    protected TypeSyntax(ObjectReader reader)
       : base(reader)
    {
    }
  }

  /// <summary>Class which represents the syntax node for predefined types.</summary>
  internal sealed partial class PredefinedTypeSyntax : TypeSyntax
  {
    internal readonly SyntaxToken keyword;

    internal PredefinedTypeSyntax(SyntaxKind kind, SyntaxToken keyword, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 1;
        this.AdjustFlagsAndWidth(keyword);
        this.keyword = keyword;
    }


    internal PredefinedTypeSyntax(SyntaxKind kind, SyntaxToken keyword, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 1;
        this.AdjustFlagsAndWidth(keyword);
        this.keyword = keyword;
    }


    internal PredefinedTypeSyntax(SyntaxKind kind, SyntaxToken keyword)
        : base(kind)
    {
        this.SlotCount = 1;
        this.AdjustFlagsAndWidth(keyword);
        this.keyword = keyword;
    }

    /// <summary>SyntaxToken which represents the keyword corresponding to the predefined type.</summary>
    public SyntaxToken Keyword => this.keyword;

    internal override GreenNode? GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.keyword;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new CSharp.Syntax.PredefinedTypeSyntax(this, parent, position);

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor) => visitor.VisitPredefinedType(this);

    public override void Accept(CSharpSyntaxVisitor visitor) => visitor.VisitPredefinedType(this);

    public PredefinedTypeSyntax Update(SyntaxToken keyword)
    {
        if (keyword != this.Keyword)
        {
            var newNode = SyntaxFactory.PredefinedType(keyword);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
        => new PredefinedTypeSyntax(this.Kind, this.keyword, diagnostics, GetAnnotations());

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
        => new PredefinedTypeSyntax(this.Kind, this.keyword, GetDiagnostics(), annotations);

    internal PredefinedTypeSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 1;
      var keyword = (SyntaxToken)reader.ReadValue();
      if (keyword != null)
      {
         AdjustFlagsAndWidth(keyword);
         this.keyword = keyword;
      }
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.keyword);
    }

    static PredefinedTypeSyntax()
    {
       ObjectBinder.RegisterTypeReader(typeof(PredefinedTypeSyntax), r => new PredefinedTypeSyntax(r));
    }
  }

  /// <summary>Class which represents the syntax node for the array type.</summary>
  internal sealed partial class ArrayTypeSyntax : TypeSyntax
  {
    internal readonly TypeSyntax elementType;
    internal readonly GreenNode? rankSpecifiers;

    internal ArrayTypeSyntax(SyntaxKind kind, TypeSyntax elementType, GreenNode? rankSpecifiers, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 2;
        this.AdjustFlagsAndWidth(elementType);
        this.elementType = elementType;
        if (rankSpecifiers != null)
        {
            this.AdjustFlagsAndWidth(rankSpecifiers);
            this.rankSpecifiers = rankSpecifiers;
        }
    }


    internal ArrayTypeSyntax(SyntaxKind kind, TypeSyntax elementType, GreenNode? rankSpecifiers, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 2;
        this.AdjustFlagsAndWidth(elementType);
        this.elementType = elementType;
        if (rankSpecifiers != null)
        {
            this.AdjustFlagsAndWidth(rankSpecifiers);
            this.rankSpecifiers = rankSpecifiers;
        }
    }


    internal ArrayTypeSyntax(SyntaxKind kind, TypeSyntax elementType, GreenNode? rankSpecifiers)
        : base(kind)
    {
        this.SlotCount = 2;
        this.AdjustFlagsAndWidth(elementType);
        this.elementType = elementType;
        if (rankSpecifiers != null)
        {
            this.AdjustFlagsAndWidth(rankSpecifiers);
            this.rankSpecifiers = rankSpecifiers;
        }
    }

    /// <summary>TypeSyntax node representing the type of the element of the array.</summary>
    public TypeSyntax ElementType => this.elementType;
    /// <summary>SyntaxList of ArrayRankSpecifierSyntax nodes representing the list of rank specifiers for the array.</summary>
    public Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<ArrayRankSpecifierSyntax> RankSpecifiers => new Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<ArrayRankSpecifierSyntax>(this.rankSpecifiers);

    internal override GreenNode? GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.elementType;
            case 1: return this.rankSpecifiers;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new CSharp.Syntax.ArrayTypeSyntax(this, parent, position);

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor) => visitor.VisitArrayType(this);

    public override void Accept(CSharpSyntaxVisitor visitor) => visitor.VisitArrayType(this);

    public ArrayTypeSyntax Update(TypeSyntax elementType, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<ArrayRankSpecifierSyntax> rankSpecifiers)
    {
        if (elementType != this.ElementType || rankSpecifiers != this.RankSpecifiers)
        {
            var newNode = SyntaxFactory.ArrayType(elementType, rankSpecifiers);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
        => new ArrayTypeSyntax(this.Kind, this.elementType, this.rankSpecifiers, diagnostics, GetAnnotations());

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
        => new ArrayTypeSyntax(this.Kind, this.elementType, this.rankSpecifiers, GetDiagnostics(), annotations);

    internal ArrayTypeSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 2;
      var elementType = (TypeSyntax)reader.ReadValue();
      if (elementType != null)
      {
         AdjustFlagsAndWidth(elementType);
         this.elementType = elementType;
      }
      var rankSpecifiers = (GreenNode?)reader.ReadValue();
      if (rankSpecifiers != null)
      {
         AdjustFlagsAndWidth(rankSpecifiers);
         this.rankSpecifiers = rankSpecifiers;
      }
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.elementType);
      writer.WriteValue(this.rankSpecifiers);
    }

    static ArrayTypeSyntax()
    {
       ObjectBinder.RegisterTypeReader(typeof(ArrayTypeSyntax), r => new ArrayTypeSyntax(r));
    }
  }

  internal sealed partial class ArrayRankSpecifierSyntax : CSharpSyntaxNode
  {
    internal readonly SyntaxToken openBracketToken;
    internal readonly GreenNode? sizes;
    internal readonly SyntaxToken closeBracketToken;

    internal ArrayRankSpecifierSyntax(SyntaxKind kind, SyntaxToken openBracketToken, GreenNode? sizes, SyntaxToken closeBracketToken, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 3;
        this.AdjustFlagsAndWidth(openBracketToken);
        this.openBracketToken = openBracketToken;
        if (sizes != null)
        {
            this.AdjustFlagsAndWidth(sizes);
            this.sizes = sizes;
        }
        this.AdjustFlagsAndWidth(closeBracketToken);
        this.closeBracketToken = closeBracketToken;
    }


    internal ArrayRankSpecifierSyntax(SyntaxKind kind, SyntaxToken openBracketToken, GreenNode? sizes, SyntaxToken closeBracketToken, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 3;
        this.AdjustFlagsAndWidth(openBracketToken);
        this.openBracketToken = openBracketToken;
        if (sizes != null)
        {
            this.AdjustFlagsAndWidth(sizes);
            this.sizes = sizes;
        }
        this.AdjustFlagsAndWidth(closeBracketToken);
        this.closeBracketToken = closeBracketToken;
    }


    internal ArrayRankSpecifierSyntax(SyntaxKind kind, SyntaxToken openBracketToken, GreenNode? sizes, SyntaxToken closeBracketToken)
        : base(kind)
    {
        this.SlotCount = 3;
        this.AdjustFlagsAndWidth(openBracketToken);
        this.openBracketToken = openBracketToken;
        if (sizes != null)
        {
            this.AdjustFlagsAndWidth(sizes);
            this.sizes = sizes;
        }
        this.AdjustFlagsAndWidth(closeBracketToken);
        this.closeBracketToken = closeBracketToken;
    }

    public SyntaxToken OpenBracketToken => this.openBracketToken;
    public Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<ExpressionSyntax> Sizes => new Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<ExpressionSyntax>(new Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<CSharpSyntaxNode>(this.sizes));
    public SyntaxToken CloseBracketToken => this.closeBracketToken;

    internal override GreenNode? GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.openBracketToken;
            case 1: return this.sizes;
            case 2: return this.closeBracketToken;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new CSharp.Syntax.ArrayRankSpecifierSyntax(this, parent, position);

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor) => visitor.VisitArrayRankSpecifier(this);

    public override void Accept(CSharpSyntaxVisitor visitor) => visitor.VisitArrayRankSpecifier(this);

    public ArrayRankSpecifierSyntax Update(SyntaxToken openBracketToken, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<ExpressionSyntax> sizes, SyntaxToken closeBracketToken)
    {
        if (openBracketToken != this.OpenBracketToken || sizes != this.Sizes || closeBracketToken != this.CloseBracketToken)
        {
            var newNode = SyntaxFactory.ArrayRankSpecifier(openBracketToken, sizes, closeBracketToken);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
        => new ArrayRankSpecifierSyntax(this.Kind, this.openBracketToken, this.sizes, this.closeBracketToken, diagnostics, GetAnnotations());

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
        => new ArrayRankSpecifierSyntax(this.Kind, this.openBracketToken, this.sizes, this.closeBracketToken, GetDiagnostics(), annotations);

    internal ArrayRankSpecifierSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 3;
      var openBracketToken = (SyntaxToken)reader.ReadValue();
      if (openBracketToken != null)
      {
         AdjustFlagsAndWidth(openBracketToken);
         this.openBracketToken = openBracketToken;
      }
      var sizes = (GreenNode?)reader.ReadValue();
      if (sizes != null)
      {
         AdjustFlagsAndWidth(sizes);
         this.sizes = sizes;
      }
      var closeBracketToken = (SyntaxToken)reader.ReadValue();
      if (closeBracketToken != null)
      {
         AdjustFlagsAndWidth(closeBracketToken);
         this.closeBracketToken = closeBracketToken;
      }
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.openBracketToken);
      writer.WriteValue(this.sizes);
      writer.WriteValue(this.closeBracketToken);
    }

    static ArrayRankSpecifierSyntax()
    {
       ObjectBinder.RegisterTypeReader(typeof(ArrayRankSpecifierSyntax), r => new ArrayRankSpecifierSyntax(r));
    }
  }

  /// <summary>Class which represents the syntax node for pointer type.</summary>
  internal sealed partial class PointerTypeSyntax : TypeSyntax
  {
    internal readonly TypeSyntax elementType;
    internal readonly SyntaxToken asteriskToken;

    internal PointerTypeSyntax(SyntaxKind kind, TypeSyntax elementType, SyntaxToken asteriskToken, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 2;
        this.AdjustFlagsAndWidth(elementType);
        this.elementType = elementType;
        this.AdjustFlagsAndWidth(asteriskToken);
        this.asteriskToken = asteriskToken;
    }


    internal PointerTypeSyntax(SyntaxKind kind, TypeSyntax elementType, SyntaxToken asteriskToken, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 2;
        this.AdjustFlagsAndWidth(elementType);
        this.elementType = elementType;
        this.AdjustFlagsAndWidth(asteriskToken);
        this.asteriskToken = asteriskToken;
    }


    internal PointerTypeSyntax(SyntaxKind kind, TypeSyntax elementType, SyntaxToken asteriskToken)
        : base(kind)
    {
        this.SlotCount = 2;
        this.AdjustFlagsAndWidth(elementType);
        this.elementType = elementType;
        this.AdjustFlagsAndWidth(asteriskToken);
        this.asteriskToken = asteriskToken;
    }

    /// <summary>TypeSyntax node that represents the element type of the pointer.</summary>
    public TypeSyntax ElementType => this.elementType;
    /// <summary>SyntaxToken representing the asterisk.</summary>
    public SyntaxToken AsteriskToken => this.asteriskToken;

    internal override GreenNode? GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.elementType;
            case 1: return this.asteriskToken;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new CSharp.Syntax.PointerTypeSyntax(this, parent, position);

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor) => visitor.VisitPointerType(this);

    public override void Accept(CSharpSyntaxVisitor visitor) => visitor.VisitPointerType(this);

    public PointerTypeSyntax Update(TypeSyntax elementType, SyntaxToken asteriskToken)
    {
        if (elementType != this.ElementType || asteriskToken != this.AsteriskToken)
        {
            var newNode = SyntaxFactory.PointerType(elementType, asteriskToken);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
        => new PointerTypeSyntax(this.Kind, this.elementType, this.asteriskToken, diagnostics, GetAnnotations());

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
        => new PointerTypeSyntax(this.Kind, this.elementType, this.asteriskToken, GetDiagnostics(), annotations);

    internal PointerTypeSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 2;
      var elementType = (TypeSyntax)reader.ReadValue();
      if (elementType != null)
      {
         AdjustFlagsAndWidth(elementType);
         this.elementType = elementType;
      }
      var asteriskToken = (SyntaxToken)reader.ReadValue();
      if (asteriskToken != null)
      {
         AdjustFlagsAndWidth(asteriskToken);
         this.asteriskToken = asteriskToken;
      }
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.elementType);
      writer.WriteValue(this.asteriskToken);
    }

    static PointerTypeSyntax()
    {
       ObjectBinder.RegisterTypeReader(typeof(PointerTypeSyntax), r => new PointerTypeSyntax(r));
    }
  }

  /// <summary>Class which represents the syntax node for a nullable type.</summary>
  internal sealed partial class NullableTypeSyntax : TypeSyntax
  {
    internal readonly TypeSyntax elementType;
    internal readonly SyntaxToken questionToken;

    internal NullableTypeSyntax(SyntaxKind kind, TypeSyntax elementType, SyntaxToken questionToken, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 2;
        this.AdjustFlagsAndWidth(elementType);
        this.elementType = elementType;
        this.AdjustFlagsAndWidth(questionToken);
        this.questionToken = questionToken;
    }


    internal NullableTypeSyntax(SyntaxKind kind, TypeSyntax elementType, SyntaxToken questionToken, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 2;
        this.AdjustFlagsAndWidth(elementType);
        this.elementType = elementType;
        this.AdjustFlagsAndWidth(questionToken);
        this.questionToken = questionToken;
    }


    internal NullableTypeSyntax(SyntaxKind kind, TypeSyntax elementType, SyntaxToken questionToken)
        : base(kind)
    {
        this.SlotCount = 2;
        this.AdjustFlagsAndWidth(elementType);
        this.elementType = elementType;
        this.AdjustFlagsAndWidth(questionToken);
        this.questionToken = questionToken;
    }

    /// <summary>TypeSyntax node representing the type of the element.</summary>
    public TypeSyntax ElementType => this.elementType;
    /// <summary>SyntaxToken representing the question mark.</summary>
    public SyntaxToken QuestionToken => this.questionToken;

    internal override GreenNode? GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.elementType;
            case 1: return this.questionToken;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new CSharp.Syntax.NullableTypeSyntax(this, parent, position);

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor) => visitor.VisitNullableType(this);

    public override void Accept(CSharpSyntaxVisitor visitor) => visitor.VisitNullableType(this);

    public NullableTypeSyntax Update(TypeSyntax elementType, SyntaxToken questionToken)
    {
        if (elementType != this.ElementType || questionToken != this.QuestionToken)
        {
            var newNode = SyntaxFactory.NullableType(elementType, questionToken);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
        => new NullableTypeSyntax(this.Kind, this.elementType, this.questionToken, diagnostics, GetAnnotations());

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
        => new NullableTypeSyntax(this.Kind, this.elementType, this.questionToken, GetDiagnostics(), annotations);

    internal NullableTypeSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 2;
      var elementType = (TypeSyntax)reader.ReadValue();
      if (elementType != null)
      {
         AdjustFlagsAndWidth(elementType);
         this.elementType = elementType;
      }
      var questionToken = (SyntaxToken)reader.ReadValue();
      if (questionToken != null)
      {
         AdjustFlagsAndWidth(questionToken);
         this.questionToken = questionToken;
      }
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.elementType);
      writer.WriteValue(this.questionToken);
    }

    static NullableTypeSyntax()
    {
       ObjectBinder.RegisterTypeReader(typeof(NullableTypeSyntax), r => new NullableTypeSyntax(r));
    }
  }

  /// <summary>Class which represents the syntax node for tuple type.</summary>
  internal sealed partial class TupleTypeSyntax : TypeSyntax
  {
    internal readonly SyntaxToken openParenToken;
    internal readonly GreenNode? elements;
    internal readonly SyntaxToken closeParenToken;

    internal TupleTypeSyntax(SyntaxKind kind, SyntaxToken openParenToken, GreenNode? elements, SyntaxToken closeParenToken, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 3;
        this.AdjustFlagsAndWidth(openParenToken);
        this.openParenToken = openParenToken;
        if (elements != null)
        {
            this.AdjustFlagsAndWidth(elements);
            this.elements = elements;
        }
        this.AdjustFlagsAndWidth(closeParenToken);
        this.closeParenToken = closeParenToken;
    }


    internal TupleTypeSyntax(SyntaxKind kind, SyntaxToken openParenToken, GreenNode? elements, SyntaxToken closeParenToken, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 3;
        this.AdjustFlagsAndWidth(openParenToken);
        this.openParenToken = openParenToken;
        if (elements != null)
        {
            this.AdjustFlagsAndWidth(elements);
            this.elements = elements;
        }
        this.AdjustFlagsAndWidth(closeParenToken);
        this.closeParenToken = closeParenToken;
    }


    internal TupleTypeSyntax(SyntaxKind kind, SyntaxToken openParenToken, GreenNode? elements, SyntaxToken closeParenToken)
        : base(kind)
    {
        this.SlotCount = 3;
        this.AdjustFlagsAndWidth(openParenToken);
        this.openParenToken = openParenToken;
        if (elements != null)
        {
            this.AdjustFlagsAndWidth(elements);
            this.elements = elements;
        }
        this.AdjustFlagsAndWidth(closeParenToken);
        this.closeParenToken = closeParenToken;
    }

    /// <summary>SyntaxToken representing the open parenthesis.</summary>
    public SyntaxToken OpenParenToken => this.openParenToken;
    public Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<TupleElementSyntax> Elements => new Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<TupleElementSyntax>(new Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<CSharpSyntaxNode>(this.elements));
    /// <summary>SyntaxToken representing the close parenthesis.</summary>
    public SyntaxToken CloseParenToken => this.closeParenToken;

    internal override GreenNode? GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.openParenToken;
            case 1: return this.elements;
            case 2: return this.closeParenToken;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new CSharp.Syntax.TupleTypeSyntax(this, parent, position);

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor) => visitor.VisitTupleType(this);

    public override void Accept(CSharpSyntaxVisitor visitor) => visitor.VisitTupleType(this);

    public TupleTypeSyntax Update(SyntaxToken openParenToken, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<TupleElementSyntax> elements, SyntaxToken closeParenToken)
    {
        if (openParenToken != this.OpenParenToken || elements != this.Elements || closeParenToken != this.CloseParenToken)
        {
            var newNode = SyntaxFactory.TupleType(openParenToken, elements, closeParenToken);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
        => new TupleTypeSyntax(this.Kind, this.openParenToken, this.elements, this.closeParenToken, diagnostics, GetAnnotations());

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
        => new TupleTypeSyntax(this.Kind, this.openParenToken, this.elements, this.closeParenToken, GetDiagnostics(), annotations);

    internal TupleTypeSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 3;
      var openParenToken = (SyntaxToken)reader.ReadValue();
      if (openParenToken != null)
      {
         AdjustFlagsAndWidth(openParenToken);
         this.openParenToken = openParenToken;
      }
      var elements = (GreenNode?)reader.ReadValue();
      if (elements != null)
      {
         AdjustFlagsAndWidth(elements);
         this.elements = elements;
      }
      var closeParenToken = (SyntaxToken)reader.ReadValue();
      if (closeParenToken != null)
      {
         AdjustFlagsAndWidth(closeParenToken);
         this.closeParenToken = closeParenToken;
      }
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.openParenToken);
      writer.WriteValue(this.elements);
      writer.WriteValue(this.closeParenToken);
    }

    static TupleTypeSyntax()
    {
       ObjectBinder.RegisterTypeReader(typeof(TupleTypeSyntax), r => new TupleTypeSyntax(r));
    }
  }

  /// <summary>Tuple type element.</summary>
  internal sealed partial class TupleElementSyntax : CSharpSyntaxNode
  {
    internal readonly TypeSyntax type;
    internal readonly SyntaxToken? identifier;

    internal TupleElementSyntax(SyntaxKind kind, TypeSyntax type, SyntaxToken? identifier, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 2;
        this.AdjustFlagsAndWidth(type);
        this.type = type;
        if (identifier != null)
        {
            this.AdjustFlagsAndWidth(identifier);
            this.identifier = identifier;
        }
    }


    internal TupleElementSyntax(SyntaxKind kind, TypeSyntax type, SyntaxToken? identifier, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 2;
        this.AdjustFlagsAndWidth(type);
        this.type = type;
        if (identifier != null)
        {
            this.AdjustFlagsAndWidth(identifier);
            this.identifier = identifier;
        }
    }


    internal TupleElementSyntax(SyntaxKind kind, TypeSyntax type, SyntaxToken? identifier)
        : base(kind)
    {
        this.SlotCount = 2;
        this.AdjustFlagsAndWidth(type);
        this.type = type;
        if (identifier != null)
        {
            this.AdjustFlagsAndWidth(identifier);
            this.identifier = identifier;
        }
    }

    /// <summary>Gets the type of the tuple element.</summary>
    public TypeSyntax Type => this.type;
    /// <summary>Gets the name of the tuple element.</summary>
    public SyntaxToken? Identifier => this.identifier;

    internal override GreenNode? GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.type;
            case 1: return this.identifier;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new CSharp.Syntax.TupleElementSyntax(this, parent, position);

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor) => visitor.VisitTupleElement(this);

    public override void Accept(CSharpSyntaxVisitor visitor) => visitor.VisitTupleElement(this);

    public TupleElementSyntax Update(TypeSyntax type, SyntaxToken identifier)
    {
        if (type != this.Type || identifier != this.Identifier)
        {
            var newNode = SyntaxFactory.TupleElement(type, identifier);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
        => new TupleElementSyntax(this.Kind, this.type, this.identifier, diagnostics, GetAnnotations());

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
        => new TupleElementSyntax(this.Kind, this.type, this.identifier, GetDiagnostics(), annotations);

    internal TupleElementSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 2;
      var type = (TypeSyntax)reader.ReadValue();
      if (type != null)
      {
         AdjustFlagsAndWidth(type);
         this.type = type;
      }
      var identifier = (SyntaxToken?)reader.ReadValue();
      if (identifier != null)
      {
         AdjustFlagsAndWidth(identifier);
         this.identifier = identifier;
      }
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.type);
      writer.WriteValue(this.identifier);
    }

    static TupleElementSyntax()
    {
       ObjectBinder.RegisterTypeReader(typeof(TupleElementSyntax), r => new TupleElementSyntax(r));
    }
  }

  /// <summary>Class which represents a placeholder in the type argument list of an unbound generic type.</summary>
  internal sealed partial class OmittedTypeArgumentSyntax : TypeSyntax
  {
    internal readonly SyntaxToken omittedTypeArgumentToken;

    internal OmittedTypeArgumentSyntax(SyntaxKind kind, SyntaxToken omittedTypeArgumentToken, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 1;
        this.AdjustFlagsAndWidth(omittedTypeArgumentToken);
        this.omittedTypeArgumentToken = omittedTypeArgumentToken;
    }


    internal OmittedTypeArgumentSyntax(SyntaxKind kind, SyntaxToken omittedTypeArgumentToken, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 1;
        this.AdjustFlagsAndWidth(omittedTypeArgumentToken);
        this.omittedTypeArgumentToken = omittedTypeArgumentToken;
    }


    internal OmittedTypeArgumentSyntax(SyntaxKind kind, SyntaxToken omittedTypeArgumentToken)
        : base(kind)
    {
        this.SlotCount = 1;
        this.AdjustFlagsAndWidth(omittedTypeArgumentToken);
        this.omittedTypeArgumentToken = omittedTypeArgumentToken;
    }

    /// <summary>SyntaxToken representing the omitted type argument.</summary>
    public SyntaxToken OmittedTypeArgumentToken => this.omittedTypeArgumentToken;

    internal override GreenNode? GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.omittedTypeArgumentToken;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new CSharp.Syntax.OmittedTypeArgumentSyntax(this, parent, position);

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor) => visitor.VisitOmittedTypeArgument(this);

    public override void Accept(CSharpSyntaxVisitor visitor) => visitor.VisitOmittedTypeArgument(this);

    public OmittedTypeArgumentSyntax Update(SyntaxToken omittedTypeArgumentToken)
    {
        if (omittedTypeArgumentToken != this.OmittedTypeArgumentToken)
        {
            var newNode = SyntaxFactory.OmittedTypeArgument(omittedTypeArgumentToken);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
        => new OmittedTypeArgumentSyntax(this.Kind, this.omittedTypeArgumentToken, diagnostics, GetAnnotations());

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
        => new OmittedTypeArgumentSyntax(this.Kind, this.omittedTypeArgumentToken, GetDiagnostics(), annotations);

    internal OmittedTypeArgumentSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 1;
      var omittedTypeArgumentToken = (SyntaxToken)reader.ReadValue();
      if (omittedTypeArgumentToken != null)
      {
         AdjustFlagsAndWidth(omittedTypeArgumentToken);
         this.omittedTypeArgumentToken = omittedTypeArgumentToken;
      }
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.omittedTypeArgumentToken);
    }

    static OmittedTypeArgumentSyntax()
    {
       ObjectBinder.RegisterTypeReader(typeof(OmittedTypeArgumentSyntax), r => new OmittedTypeArgumentSyntax(r));
    }
  }

  /// <summary>The ref modifier of a method's return value or a local.</summary>
  internal sealed partial class RefTypeSyntax : TypeSyntax
  {
    internal readonly SyntaxToken refKeyword;
    internal readonly SyntaxToken? readOnlyKeyword;
    internal readonly TypeSyntax type;

    internal RefTypeSyntax(SyntaxKind kind, SyntaxToken refKeyword, SyntaxToken? readOnlyKeyword, TypeSyntax type, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 3;
        this.AdjustFlagsAndWidth(refKeyword);
        this.refKeyword = refKeyword;
        if (readOnlyKeyword != null)
        {
            this.AdjustFlagsAndWidth(readOnlyKeyword);
            this.readOnlyKeyword = readOnlyKeyword;
        }
        this.AdjustFlagsAndWidth(type);
        this.type = type;
    }


    internal RefTypeSyntax(SyntaxKind kind, SyntaxToken refKeyword, SyntaxToken? readOnlyKeyword, TypeSyntax type, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 3;
        this.AdjustFlagsAndWidth(refKeyword);
        this.refKeyword = refKeyword;
        if (readOnlyKeyword != null)
        {
            this.AdjustFlagsAndWidth(readOnlyKeyword);
            this.readOnlyKeyword = readOnlyKeyword;
        }
        this.AdjustFlagsAndWidth(type);
        this.type = type;
    }


    internal RefTypeSyntax(SyntaxKind kind, SyntaxToken refKeyword, SyntaxToken? readOnlyKeyword, TypeSyntax type)
        : base(kind)
    {
        this.SlotCount = 3;
        this.AdjustFlagsAndWidth(refKeyword);
        this.refKeyword = refKeyword;
        if (readOnlyKeyword != null)
        {
            this.AdjustFlagsAndWidth(readOnlyKeyword);
            this.readOnlyKeyword = readOnlyKeyword;
        }
        this.AdjustFlagsAndWidth(type);
        this.type = type;
    }

    public SyntaxToken RefKeyword => this.refKeyword;
    /// <summary>Gets the optional "readonly" keyword.</summary>
    public SyntaxToken? ReadOnlyKeyword => this.readOnlyKeyword;
    public TypeSyntax Type => this.type;

    internal override GreenNode? GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.refKeyword;
            case 1: return this.readOnlyKeyword;
            case 2: return this.type;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new CSharp.Syntax.RefTypeSyntax(this, parent, position);

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor) => visitor.VisitRefType(this);

    public override void Accept(CSharpSyntaxVisitor visitor) => visitor.VisitRefType(this);

    public RefTypeSyntax Update(SyntaxToken refKeyword, SyntaxToken readOnlyKeyword, TypeSyntax type)
    {
        if (refKeyword != this.RefKeyword || readOnlyKeyword != this.ReadOnlyKeyword || type != this.Type)
        {
            var newNode = SyntaxFactory.RefType(refKeyword, readOnlyKeyword, type);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
        => new RefTypeSyntax(this.Kind, this.refKeyword, this.readOnlyKeyword, this.type, diagnostics, GetAnnotations());

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
        => new RefTypeSyntax(this.Kind, this.refKeyword, this.readOnlyKeyword, this.type, GetDiagnostics(), annotations);

    internal RefTypeSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 3;
      var refKeyword = (SyntaxToken)reader.ReadValue();
      if (refKeyword != null)
      {
         AdjustFlagsAndWidth(refKeyword);
         this.refKeyword = refKeyword;
      }
      var readOnlyKeyword = (SyntaxToken?)reader.ReadValue();
      if (readOnlyKeyword != null)
      {
         AdjustFlagsAndWidth(readOnlyKeyword);
         this.readOnlyKeyword = readOnlyKeyword;
      }
      var type = (TypeSyntax)reader.ReadValue();
      if (type != null)
      {
         AdjustFlagsAndWidth(type);
         this.type = type;
      }
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.refKeyword);
      writer.WriteValue(this.readOnlyKeyword);
      writer.WriteValue(this.type);
    }

    static RefTypeSyntax()
    {
       ObjectBinder.RegisterTypeReader(typeof(RefTypeSyntax), r => new RefTypeSyntax(r));
    }
  }

  /// <summary>Provides the base class from which the classes that represent expression syntax nodes are derived. This is an abstract class.</summary>
  internal abstract partial class ExpressionSyntax : CSharpSyntaxNode
  {
    internal ExpressionSyntax(SyntaxKind kind, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
      : base(kind, diagnostics, annotations)
    {
    }
    internal ExpressionSyntax(SyntaxKind kind)
      : base(kind)
    {
    }

    protected ExpressionSyntax(ObjectReader reader)
       : base(reader)
    {
    }
  }

  /// <summary>Class which represents the syntax node for parenthesized expression.</summary>
  internal sealed partial class ParenthesizedExpressionSyntax : ExpressionSyntax
  {
    internal readonly SyntaxToken openParenToken;
    internal readonly ExpressionSyntax expression;
    internal readonly SyntaxToken closeParenToken;

    internal ParenthesizedExpressionSyntax(SyntaxKind kind, SyntaxToken openParenToken, ExpressionSyntax expression, SyntaxToken closeParenToken, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 3;
        this.AdjustFlagsAndWidth(openParenToken);
        this.openParenToken = openParenToken;
        this.AdjustFlagsAndWidth(expression);
        this.expression = expression;
        this.AdjustFlagsAndWidth(closeParenToken);
        this.closeParenToken = closeParenToken;
    }


    internal ParenthesizedExpressionSyntax(SyntaxKind kind, SyntaxToken openParenToken, ExpressionSyntax expression, SyntaxToken closeParenToken, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 3;
        this.AdjustFlagsAndWidth(openParenToken);
        this.openParenToken = openParenToken;
        this.AdjustFlagsAndWidth(expression);
        this.expression = expression;
        this.AdjustFlagsAndWidth(closeParenToken);
        this.closeParenToken = closeParenToken;
    }


    internal ParenthesizedExpressionSyntax(SyntaxKind kind, SyntaxToken openParenToken, ExpressionSyntax expression, SyntaxToken closeParenToken)
        : base(kind)
    {
        this.SlotCount = 3;
        this.AdjustFlagsAndWidth(openParenToken);
        this.openParenToken = openParenToken;
        this.AdjustFlagsAndWidth(expression);
        this.expression = expression;
        this.AdjustFlagsAndWidth(closeParenToken);
        this.closeParenToken = closeParenToken;
    }

    /// <summary>SyntaxToken representing the open parenthesis.</summary>
    public SyntaxToken OpenParenToken => this.openParenToken;
    /// <summary>ExpressionSyntax node representing the expression enclosed within the parenthesis.</summary>
    public ExpressionSyntax Expression => this.expression;
    /// <summary>SyntaxToken representing the close parenthesis.</summary>
    public SyntaxToken CloseParenToken => this.closeParenToken;

    internal override GreenNode? GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.openParenToken;
            case 1: return this.expression;
            case 2: return this.closeParenToken;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new CSharp.Syntax.ParenthesizedExpressionSyntax(this, parent, position);

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor) => visitor.VisitParenthesizedExpression(this);

    public override void Accept(CSharpSyntaxVisitor visitor) => visitor.VisitParenthesizedExpression(this);

    public ParenthesizedExpressionSyntax Update(SyntaxToken openParenToken, ExpressionSyntax expression, SyntaxToken closeParenToken)
    {
        if (openParenToken != this.OpenParenToken || expression != this.Expression || closeParenToken != this.CloseParenToken)
        {
            var newNode = SyntaxFactory.ParenthesizedExpression(openParenToken, expression, closeParenToken);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
        => new ParenthesizedExpressionSyntax(this.Kind, this.openParenToken, this.expression, this.closeParenToken, diagnostics, GetAnnotations());

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
        => new ParenthesizedExpressionSyntax(this.Kind, this.openParenToken, this.expression, this.closeParenToken, GetDiagnostics(), annotations);

    internal ParenthesizedExpressionSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 3;
      var openParenToken = (SyntaxToken)reader.ReadValue();
      if (openParenToken != null)
      {
         AdjustFlagsAndWidth(openParenToken);
         this.openParenToken = openParenToken;
      }
      var expression = (ExpressionSyntax)reader.ReadValue();
      if (expression != null)
      {
         AdjustFlagsAndWidth(expression);
         this.expression = expression;
      }
      var closeParenToken = (SyntaxToken)reader.ReadValue();
      if (closeParenToken != null)
      {
         AdjustFlagsAndWidth(closeParenToken);
         this.closeParenToken = closeParenToken;
      }
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.openParenToken);
      writer.WriteValue(this.expression);
      writer.WriteValue(this.closeParenToken);
    }

    static ParenthesizedExpressionSyntax()
    {
       ObjectBinder.RegisterTypeReader(typeof(ParenthesizedExpressionSyntax), r => new ParenthesizedExpressionSyntax(r));
    }
  }

  /// <summary>Class which represents the syntax node for tuple expression.</summary>
  internal sealed partial class TupleExpressionSyntax : ExpressionSyntax
  {
    internal readonly SyntaxToken openParenToken;
    internal readonly GreenNode? arguments;
    internal readonly SyntaxToken closeParenToken;

    internal TupleExpressionSyntax(SyntaxKind kind, SyntaxToken openParenToken, GreenNode? arguments, SyntaxToken closeParenToken, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 3;
        this.AdjustFlagsAndWidth(openParenToken);
        this.openParenToken = openParenToken;
        if (arguments != null)
        {
            this.AdjustFlagsAndWidth(arguments);
            this.arguments = arguments;
        }
        this.AdjustFlagsAndWidth(closeParenToken);
        this.closeParenToken = closeParenToken;
    }


    internal TupleExpressionSyntax(SyntaxKind kind, SyntaxToken openParenToken, GreenNode? arguments, SyntaxToken closeParenToken, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 3;
        this.AdjustFlagsAndWidth(openParenToken);
        this.openParenToken = openParenToken;
        if (arguments != null)
        {
            this.AdjustFlagsAndWidth(arguments);
            this.arguments = arguments;
        }
        this.AdjustFlagsAndWidth(closeParenToken);
        this.closeParenToken = closeParenToken;
    }


    internal TupleExpressionSyntax(SyntaxKind kind, SyntaxToken openParenToken, GreenNode? arguments, SyntaxToken closeParenToken)
        : base(kind)
    {
        this.SlotCount = 3;
        this.AdjustFlagsAndWidth(openParenToken);
        this.openParenToken = openParenToken;
        if (arguments != null)
        {
            this.AdjustFlagsAndWidth(arguments);
            this.arguments = arguments;
        }
        this.AdjustFlagsAndWidth(closeParenToken);
        this.closeParenToken = closeParenToken;
    }

    /// <summary>SyntaxToken representing the open parenthesis.</summary>
    public SyntaxToken OpenParenToken => this.openParenToken;
    /// <summary>SeparatedSyntaxList of ArgumentSyntax representing the list of arguments.</summary>
    public Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<ArgumentSyntax> Arguments => new Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<ArgumentSyntax>(new Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<CSharpSyntaxNode>(this.arguments));
    /// <summary>SyntaxToken representing the close parenthesis.</summary>
    public SyntaxToken CloseParenToken => this.closeParenToken;

    internal override GreenNode? GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.openParenToken;
            case 1: return this.arguments;
            case 2: return this.closeParenToken;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new CSharp.Syntax.TupleExpressionSyntax(this, parent, position);

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor) => visitor.VisitTupleExpression(this);

    public override void Accept(CSharpSyntaxVisitor visitor) => visitor.VisitTupleExpression(this);

    public TupleExpressionSyntax Update(SyntaxToken openParenToken, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<ArgumentSyntax> arguments, SyntaxToken closeParenToken)
    {
        if (openParenToken != this.OpenParenToken || arguments != this.Arguments || closeParenToken != this.CloseParenToken)
        {
            var newNode = SyntaxFactory.TupleExpression(openParenToken, arguments, closeParenToken);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
        => new TupleExpressionSyntax(this.Kind, this.openParenToken, this.arguments, this.closeParenToken, diagnostics, GetAnnotations());

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
        => new TupleExpressionSyntax(this.Kind, this.openParenToken, this.arguments, this.closeParenToken, GetDiagnostics(), annotations);

    internal TupleExpressionSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 3;
      var openParenToken = (SyntaxToken)reader.ReadValue();
      if (openParenToken != null)
      {
         AdjustFlagsAndWidth(openParenToken);
         this.openParenToken = openParenToken;
      }
      var arguments = (GreenNode?)reader.ReadValue();
      if (arguments != null)
      {
         AdjustFlagsAndWidth(arguments);
         this.arguments = arguments;
      }
      var closeParenToken = (SyntaxToken)reader.ReadValue();
      if (closeParenToken != null)
      {
         AdjustFlagsAndWidth(closeParenToken);
         this.closeParenToken = closeParenToken;
      }
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.openParenToken);
      writer.WriteValue(this.arguments);
      writer.WriteValue(this.closeParenToken);
    }

    static TupleExpressionSyntax()
    {
       ObjectBinder.RegisterTypeReader(typeof(TupleExpressionSyntax), r => new TupleExpressionSyntax(r));
    }
  }

  /// <summary>Class which represents the syntax node for prefix unary expression.</summary>
  internal sealed partial class PrefixUnaryExpressionSyntax : ExpressionSyntax
  {
    internal readonly SyntaxToken operatorToken;
    internal readonly ExpressionSyntax operand;

    internal PrefixUnaryExpressionSyntax(SyntaxKind kind, SyntaxToken operatorToken, ExpressionSyntax operand, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 2;
        this.AdjustFlagsAndWidth(operatorToken);
        this.operatorToken = operatorToken;
        this.AdjustFlagsAndWidth(operand);
        this.operand = operand;
    }


    internal PrefixUnaryExpressionSyntax(SyntaxKind kind, SyntaxToken operatorToken, ExpressionSyntax operand, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 2;
        this.AdjustFlagsAndWidth(operatorToken);
        this.operatorToken = operatorToken;
        this.AdjustFlagsAndWidth(operand);
        this.operand = operand;
    }


    internal PrefixUnaryExpressionSyntax(SyntaxKind kind, SyntaxToken operatorToken, ExpressionSyntax operand)
        : base(kind)
    {
        this.SlotCount = 2;
        this.AdjustFlagsAndWidth(operatorToken);
        this.operatorToken = operatorToken;
        this.AdjustFlagsAndWidth(operand);
        this.operand = operand;
    }

    /// <summary>SyntaxToken representing the kind of the operator of the prefix unary expression.</summary>
    public SyntaxToken OperatorToken => this.operatorToken;
    /// <summary>ExpressionSyntax representing the operand of the prefix unary expression.</summary>
    public ExpressionSyntax Operand => this.operand;

    internal override GreenNode? GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.operatorToken;
            case 1: return this.operand;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new CSharp.Syntax.PrefixUnaryExpressionSyntax(this, parent, position);

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor) => visitor.VisitPrefixUnaryExpression(this);

    public override void Accept(CSharpSyntaxVisitor visitor) => visitor.VisitPrefixUnaryExpression(this);

    public PrefixUnaryExpressionSyntax Update(SyntaxToken operatorToken, ExpressionSyntax operand)
    {
        if (operatorToken != this.OperatorToken || operand != this.Operand)
        {
            var newNode = SyntaxFactory.PrefixUnaryExpression(this.Kind, operatorToken, operand);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
        => new PrefixUnaryExpressionSyntax(this.Kind, this.operatorToken, this.operand, diagnostics, GetAnnotations());

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
        => new PrefixUnaryExpressionSyntax(this.Kind, this.operatorToken, this.operand, GetDiagnostics(), annotations);

    internal PrefixUnaryExpressionSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 2;
      var operatorToken = (SyntaxToken)reader.ReadValue();
      if (operatorToken != null)
      {
         AdjustFlagsAndWidth(operatorToken);
         this.operatorToken = operatorToken;
      }
      var operand = (ExpressionSyntax)reader.ReadValue();
      if (operand != null)
      {
         AdjustFlagsAndWidth(operand);
         this.operand = operand;
      }
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.operatorToken);
      writer.WriteValue(this.operand);
    }

    static PrefixUnaryExpressionSyntax()
    {
       ObjectBinder.RegisterTypeReader(typeof(PrefixUnaryExpressionSyntax), r => new PrefixUnaryExpressionSyntax(r));
    }
  }

  /// <summary>Class which represents the syntax node for an "await" expression.</summary>
  internal sealed partial class AwaitExpressionSyntax : ExpressionSyntax
  {
    internal readonly SyntaxToken awaitKeyword;
    internal readonly ExpressionSyntax expression;

    internal AwaitExpressionSyntax(SyntaxKind kind, SyntaxToken awaitKeyword, ExpressionSyntax expression, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 2;
        this.AdjustFlagsAndWidth(awaitKeyword);
        this.awaitKeyword = awaitKeyword;
        this.AdjustFlagsAndWidth(expression);
        this.expression = expression;
    }


    internal AwaitExpressionSyntax(SyntaxKind kind, SyntaxToken awaitKeyword, ExpressionSyntax expression, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 2;
        this.AdjustFlagsAndWidth(awaitKeyword);
        this.awaitKeyword = awaitKeyword;
        this.AdjustFlagsAndWidth(expression);
        this.expression = expression;
    }


    internal AwaitExpressionSyntax(SyntaxKind kind, SyntaxToken awaitKeyword, ExpressionSyntax expression)
        : base(kind)
    {
        this.SlotCount = 2;
        this.AdjustFlagsAndWidth(awaitKeyword);
        this.awaitKeyword = awaitKeyword;
        this.AdjustFlagsAndWidth(expression);
        this.expression = expression;
    }

    /// <summary>SyntaxToken representing the kind "await" keyword.</summary>
    public SyntaxToken AwaitKeyword => this.awaitKeyword;
    /// <summary>ExpressionSyntax representing the operand of the "await" operator.</summary>
    public ExpressionSyntax Expression => this.expression;

    internal override GreenNode? GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.awaitKeyword;
            case 1: return this.expression;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new CSharp.Syntax.AwaitExpressionSyntax(this, parent, position);

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor) => visitor.VisitAwaitExpression(this);

    public override void Accept(CSharpSyntaxVisitor visitor) => visitor.VisitAwaitExpression(this);

    public AwaitExpressionSyntax Update(SyntaxToken awaitKeyword, ExpressionSyntax expression)
    {
        if (awaitKeyword != this.AwaitKeyword || expression != this.Expression)
        {
            var newNode = SyntaxFactory.AwaitExpression(awaitKeyword, expression);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
        => new AwaitExpressionSyntax(this.Kind, this.awaitKeyword, this.expression, diagnostics, GetAnnotations());

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
        => new AwaitExpressionSyntax(this.Kind, this.awaitKeyword, this.expression, GetDiagnostics(), annotations);

    internal AwaitExpressionSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 2;
      var awaitKeyword = (SyntaxToken)reader.ReadValue();
      if (awaitKeyword != null)
      {
         AdjustFlagsAndWidth(awaitKeyword);
         this.awaitKeyword = awaitKeyword;
      }
      var expression = (ExpressionSyntax)reader.ReadValue();
      if (expression != null)
      {
         AdjustFlagsAndWidth(expression);
         this.expression = expression;
      }
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.awaitKeyword);
      writer.WriteValue(this.expression);
    }

    static AwaitExpressionSyntax()
    {
       ObjectBinder.RegisterTypeReader(typeof(AwaitExpressionSyntax), r => new AwaitExpressionSyntax(r));
    }
  }

  /// <summary>Class which represents the syntax node for postfix unary expression.</summary>
  internal sealed partial class PostfixUnaryExpressionSyntax : ExpressionSyntax
  {
    internal readonly ExpressionSyntax operand;
    internal readonly SyntaxToken operatorToken;

    internal PostfixUnaryExpressionSyntax(SyntaxKind kind, ExpressionSyntax operand, SyntaxToken operatorToken, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 2;
        this.AdjustFlagsAndWidth(operand);
        this.operand = operand;
        this.AdjustFlagsAndWidth(operatorToken);
        this.operatorToken = operatorToken;
    }


    internal PostfixUnaryExpressionSyntax(SyntaxKind kind, ExpressionSyntax operand, SyntaxToken operatorToken, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 2;
        this.AdjustFlagsAndWidth(operand);
        this.operand = operand;
        this.AdjustFlagsAndWidth(operatorToken);
        this.operatorToken = operatorToken;
    }


    internal PostfixUnaryExpressionSyntax(SyntaxKind kind, ExpressionSyntax operand, SyntaxToken operatorToken)
        : base(kind)
    {
        this.SlotCount = 2;
        this.AdjustFlagsAndWidth(operand);
        this.operand = operand;
        this.AdjustFlagsAndWidth(operatorToken);
        this.operatorToken = operatorToken;
    }

    /// <summary>ExpressionSyntax representing the operand of the postfix unary expression.</summary>
    public ExpressionSyntax Operand => this.operand;
    /// <summary>SyntaxToken representing the kind of the operator of the postfix unary expression.</summary>
    public SyntaxToken OperatorToken => this.operatorToken;

    internal override GreenNode? GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.operand;
            case 1: return this.operatorToken;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new CSharp.Syntax.PostfixUnaryExpressionSyntax(this, parent, position);

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor) => visitor.VisitPostfixUnaryExpression(this);

    public override void Accept(CSharpSyntaxVisitor visitor) => visitor.VisitPostfixUnaryExpression(this);

    public PostfixUnaryExpressionSyntax Update(ExpressionSyntax operand, SyntaxToken operatorToken)
    {
        if (operand != this.Operand || operatorToken != this.OperatorToken)
        {
            var newNode = SyntaxFactory.PostfixUnaryExpression(this.Kind, operand, operatorToken);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
        => new PostfixUnaryExpressionSyntax(this.Kind, this.operand, this.operatorToken, diagnostics, GetAnnotations());

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
        => new PostfixUnaryExpressionSyntax(this.Kind, this.operand, this.operatorToken, GetDiagnostics(), annotations);

    internal PostfixUnaryExpressionSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 2;
      var operand = (ExpressionSyntax)reader.ReadValue();
      if (operand != null)
      {
         AdjustFlagsAndWidth(operand);
         this.operand = operand;
      }
      var operatorToken = (SyntaxToken)reader.ReadValue();
      if (operatorToken != null)
      {
         AdjustFlagsAndWidth(operatorToken);
         this.operatorToken = operatorToken;
      }
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.operand);
      writer.WriteValue(this.operatorToken);
    }

    static PostfixUnaryExpressionSyntax()
    {
       ObjectBinder.RegisterTypeReader(typeof(PostfixUnaryExpressionSyntax), r => new PostfixUnaryExpressionSyntax(r));
    }
  }

  /// <summary>Class which represents the syntax node for member access expression.</summary>
  internal sealed partial class MemberAccessExpressionSyntax : ExpressionSyntax
  {
    internal readonly ExpressionSyntax expression;
    internal readonly SyntaxToken operatorToken;
    internal readonly SimpleNameSyntax name;

    internal MemberAccessExpressionSyntax(SyntaxKind kind, ExpressionSyntax expression, SyntaxToken operatorToken, SimpleNameSyntax name, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 3;
        this.AdjustFlagsAndWidth(expression);
        this.expression = expression;
        this.AdjustFlagsAndWidth(operatorToken);
        this.operatorToken = operatorToken;
        this.AdjustFlagsAndWidth(name);
        this.name = name;
    }


    internal MemberAccessExpressionSyntax(SyntaxKind kind, ExpressionSyntax expression, SyntaxToken operatorToken, SimpleNameSyntax name, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 3;
        this.AdjustFlagsAndWidth(expression);
        this.expression = expression;
        this.AdjustFlagsAndWidth(operatorToken);
        this.operatorToken = operatorToken;
        this.AdjustFlagsAndWidth(name);
        this.name = name;
    }


    internal MemberAccessExpressionSyntax(SyntaxKind kind, ExpressionSyntax expression, SyntaxToken operatorToken, SimpleNameSyntax name)
        : base(kind)
    {
        this.SlotCount = 3;
        this.AdjustFlagsAndWidth(expression);
        this.expression = expression;
        this.AdjustFlagsAndWidth(operatorToken);
        this.operatorToken = operatorToken;
        this.AdjustFlagsAndWidth(name);
        this.name = name;
    }

    /// <summary>ExpressionSyntax node representing the object that the member belongs to.</summary>
    public ExpressionSyntax Expression => this.expression;
    /// <summary>SyntaxToken representing the kind of the operator in the member access expression.</summary>
    public SyntaxToken OperatorToken => this.operatorToken;
    /// <summary>SimpleNameSyntax node representing the member being accessed.</summary>
    public SimpleNameSyntax Name => this.name;

    internal override GreenNode? GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.expression;
            case 1: return this.operatorToken;
            case 2: return this.name;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new CSharp.Syntax.MemberAccessExpressionSyntax(this, parent, position);

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor) => visitor.VisitMemberAccessExpression(this);

    public override void Accept(CSharpSyntaxVisitor visitor) => visitor.VisitMemberAccessExpression(this);

    public MemberAccessExpressionSyntax Update(ExpressionSyntax expression, SyntaxToken operatorToken, SimpleNameSyntax name)
    {
        if (expression != this.Expression || operatorToken != this.OperatorToken || name != this.Name)
        {
            var newNode = SyntaxFactory.MemberAccessExpression(this.Kind, expression, operatorToken, name);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
        => new MemberAccessExpressionSyntax(this.Kind, this.expression, this.operatorToken, this.name, diagnostics, GetAnnotations());

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
        => new MemberAccessExpressionSyntax(this.Kind, this.expression, this.operatorToken, this.name, GetDiagnostics(), annotations);

    internal MemberAccessExpressionSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 3;
      var expression = (ExpressionSyntax)reader.ReadValue();
      if (expression != null)
      {
         AdjustFlagsAndWidth(expression);
         this.expression = expression;
      }
      var operatorToken = (SyntaxToken)reader.ReadValue();
      if (operatorToken != null)
      {
         AdjustFlagsAndWidth(operatorToken);
         this.operatorToken = operatorToken;
      }
      var name = (SimpleNameSyntax)reader.ReadValue();
      if (name != null)
      {
         AdjustFlagsAndWidth(name);
         this.name = name;
      }
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.expression);
      writer.WriteValue(this.operatorToken);
      writer.WriteValue(this.name);
    }

    static MemberAccessExpressionSyntax()
    {
       ObjectBinder.RegisterTypeReader(typeof(MemberAccessExpressionSyntax), r => new MemberAccessExpressionSyntax(r));
    }
  }

  /// <summary>Class which represents the syntax node for conditional access expression.</summary>
  internal sealed partial class ConditionalAccessExpressionSyntax : ExpressionSyntax
  {
    internal readonly ExpressionSyntax expression;
    internal readonly SyntaxToken operatorToken;
    internal readonly ExpressionSyntax whenNotNull;

    internal ConditionalAccessExpressionSyntax(SyntaxKind kind, ExpressionSyntax expression, SyntaxToken operatorToken, ExpressionSyntax whenNotNull, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 3;
        this.AdjustFlagsAndWidth(expression);
        this.expression = expression;
        this.AdjustFlagsAndWidth(operatorToken);
        this.operatorToken = operatorToken;
        this.AdjustFlagsAndWidth(whenNotNull);
        this.whenNotNull = whenNotNull;
    }


    internal ConditionalAccessExpressionSyntax(SyntaxKind kind, ExpressionSyntax expression, SyntaxToken operatorToken, ExpressionSyntax whenNotNull, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 3;
        this.AdjustFlagsAndWidth(expression);
        this.expression = expression;
        this.AdjustFlagsAndWidth(operatorToken);
        this.operatorToken = operatorToken;
        this.AdjustFlagsAndWidth(whenNotNull);
        this.whenNotNull = whenNotNull;
    }


    internal ConditionalAccessExpressionSyntax(SyntaxKind kind, ExpressionSyntax expression, SyntaxToken operatorToken, ExpressionSyntax whenNotNull)
        : base(kind)
    {
        this.SlotCount = 3;
        this.AdjustFlagsAndWidth(expression);
        this.expression = expression;
        this.AdjustFlagsAndWidth(operatorToken);
        this.operatorToken = operatorToken;
        this.AdjustFlagsAndWidth(whenNotNull);
        this.whenNotNull = whenNotNull;
    }

    /// <summary>ExpressionSyntax node representing the object conditionally accessed.</summary>
    public ExpressionSyntax Expression => this.expression;
    /// <summary>SyntaxToken representing the question mark.</summary>
    public SyntaxToken OperatorToken => this.operatorToken;
    /// <summary>ExpressionSyntax node representing the access expression to be executed when the object is not null.</summary>
    public ExpressionSyntax WhenNotNull => this.whenNotNull;

    internal override GreenNode? GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.expression;
            case 1: return this.operatorToken;
            case 2: return this.whenNotNull;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new CSharp.Syntax.ConditionalAccessExpressionSyntax(this, parent, position);

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor) => visitor.VisitConditionalAccessExpression(this);

    public override void Accept(CSharpSyntaxVisitor visitor) => visitor.VisitConditionalAccessExpression(this);

    public ConditionalAccessExpressionSyntax Update(ExpressionSyntax expression, SyntaxToken operatorToken, ExpressionSyntax whenNotNull)
    {
        if (expression != this.Expression || operatorToken != this.OperatorToken || whenNotNull != this.WhenNotNull)
        {
            var newNode = SyntaxFactory.ConditionalAccessExpression(expression, operatorToken, whenNotNull);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
        => new ConditionalAccessExpressionSyntax(this.Kind, this.expression, this.operatorToken, this.whenNotNull, diagnostics, GetAnnotations());

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
        => new ConditionalAccessExpressionSyntax(this.Kind, this.expression, this.operatorToken, this.whenNotNull, GetDiagnostics(), annotations);

    internal ConditionalAccessExpressionSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 3;
      var expression = (ExpressionSyntax)reader.ReadValue();
      if (expression != null)
      {
         AdjustFlagsAndWidth(expression);
         this.expression = expression;
      }
      var operatorToken = (SyntaxToken)reader.ReadValue();
      if (operatorToken != null)
      {
         AdjustFlagsAndWidth(operatorToken);
         this.operatorToken = operatorToken;
      }
      var whenNotNull = (ExpressionSyntax)reader.ReadValue();
      if (whenNotNull != null)
      {
         AdjustFlagsAndWidth(whenNotNull);
         this.whenNotNull = whenNotNull;
      }
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.expression);
      writer.WriteValue(this.operatorToken);
      writer.WriteValue(this.whenNotNull);
    }

    static ConditionalAccessExpressionSyntax()
    {
       ObjectBinder.RegisterTypeReader(typeof(ConditionalAccessExpressionSyntax), r => new ConditionalAccessExpressionSyntax(r));
    }
  }

  /// <summary>Class which represents the syntax node for member binding expression.</summary>
  internal sealed partial class MemberBindingExpressionSyntax : ExpressionSyntax
  {
    internal readonly SyntaxToken operatorToken;
    internal readonly SimpleNameSyntax name;

    internal MemberBindingExpressionSyntax(SyntaxKind kind, SyntaxToken operatorToken, SimpleNameSyntax name, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 2;
        this.AdjustFlagsAndWidth(operatorToken);
        this.operatorToken = operatorToken;
        this.AdjustFlagsAndWidth(name);
        this.name = name;
    }


    internal MemberBindingExpressionSyntax(SyntaxKind kind, SyntaxToken operatorToken, SimpleNameSyntax name, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 2;
        this.AdjustFlagsAndWidth(operatorToken);
        this.operatorToken = operatorToken;
        this.AdjustFlagsAndWidth(name);
        this.name = name;
    }


    internal MemberBindingExpressionSyntax(SyntaxKind kind, SyntaxToken operatorToken, SimpleNameSyntax name)
        : base(kind)
    {
        this.SlotCount = 2;
        this.AdjustFlagsAndWidth(operatorToken);
        this.operatorToken = operatorToken;
        this.AdjustFlagsAndWidth(name);
        this.name = name;
    }

    /// <summary>SyntaxToken representing dot.</summary>
    public SyntaxToken OperatorToken => this.operatorToken;
    /// <summary>SimpleNameSyntax node representing the member being bound to.</summary>
    public SimpleNameSyntax Name => this.name;

    internal override GreenNode? GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.operatorToken;
            case 1: return this.name;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new CSharp.Syntax.MemberBindingExpressionSyntax(this, parent, position);

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor) => visitor.VisitMemberBindingExpression(this);

    public override void Accept(CSharpSyntaxVisitor visitor) => visitor.VisitMemberBindingExpression(this);

    public MemberBindingExpressionSyntax Update(SyntaxToken operatorToken, SimpleNameSyntax name)
    {
        if (operatorToken != this.OperatorToken || name != this.Name)
        {
            var newNode = SyntaxFactory.MemberBindingExpression(operatorToken, name);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
        => new MemberBindingExpressionSyntax(this.Kind, this.operatorToken, this.name, diagnostics, GetAnnotations());

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
        => new MemberBindingExpressionSyntax(this.Kind, this.operatorToken, this.name, GetDiagnostics(), annotations);

    internal MemberBindingExpressionSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 2;
      var operatorToken = (SyntaxToken)reader.ReadValue();
      if (operatorToken != null)
      {
         AdjustFlagsAndWidth(operatorToken);
         this.operatorToken = operatorToken;
      }
      var name = (SimpleNameSyntax)reader.ReadValue();
      if (name != null)
      {
         AdjustFlagsAndWidth(name);
         this.name = name;
      }
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.operatorToken);
      writer.WriteValue(this.name);
    }

    static MemberBindingExpressionSyntax()
    {
       ObjectBinder.RegisterTypeReader(typeof(MemberBindingExpressionSyntax), r => new MemberBindingExpressionSyntax(r));
    }
  }

  /// <summary>Class which represents the syntax node for element binding expression.</summary>
  internal sealed partial class ElementBindingExpressionSyntax : ExpressionSyntax
  {
    internal readonly BracketedArgumentListSyntax argumentList;

    internal ElementBindingExpressionSyntax(SyntaxKind kind, BracketedArgumentListSyntax argumentList, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 1;
        this.AdjustFlagsAndWidth(argumentList);
        this.argumentList = argumentList;
    }


    internal ElementBindingExpressionSyntax(SyntaxKind kind, BracketedArgumentListSyntax argumentList, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 1;
        this.AdjustFlagsAndWidth(argumentList);
        this.argumentList = argumentList;
    }


    internal ElementBindingExpressionSyntax(SyntaxKind kind, BracketedArgumentListSyntax argumentList)
        : base(kind)
    {
        this.SlotCount = 1;
        this.AdjustFlagsAndWidth(argumentList);
        this.argumentList = argumentList;
    }

    /// <summary>BracketedArgumentListSyntax node representing the list of arguments of the element binding expression.</summary>
    public BracketedArgumentListSyntax ArgumentList => this.argumentList;

    internal override GreenNode? GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.argumentList;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new CSharp.Syntax.ElementBindingExpressionSyntax(this, parent, position);

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor) => visitor.VisitElementBindingExpression(this);

    public override void Accept(CSharpSyntaxVisitor visitor) => visitor.VisitElementBindingExpression(this);

    public ElementBindingExpressionSyntax Update(BracketedArgumentListSyntax argumentList)
    {
        if (argumentList != this.ArgumentList)
        {
            var newNode = SyntaxFactory.ElementBindingExpression(argumentList);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
        => new ElementBindingExpressionSyntax(this.Kind, this.argumentList, diagnostics, GetAnnotations());

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
        => new ElementBindingExpressionSyntax(this.Kind, this.argumentList, GetDiagnostics(), annotations);

    internal ElementBindingExpressionSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 1;
      var argumentList = (BracketedArgumentListSyntax)reader.ReadValue();
      if (argumentList != null)
      {
         AdjustFlagsAndWidth(argumentList);
         this.argumentList = argumentList;
      }
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.argumentList);
    }

    static ElementBindingExpressionSyntax()
    {
       ObjectBinder.RegisterTypeReader(typeof(ElementBindingExpressionSyntax), r => new ElementBindingExpressionSyntax(r));
    }
  }

  /// <summary>Class which represents the syntax node for a range expression.</summary>
  internal sealed partial class RangeExpressionSyntax : ExpressionSyntax
  {
    internal readonly ExpressionSyntax? leftOperand;
    internal readonly SyntaxToken operatorToken;
    internal readonly ExpressionSyntax? rightOperand;

    internal RangeExpressionSyntax(SyntaxKind kind, ExpressionSyntax? leftOperand, SyntaxToken operatorToken, ExpressionSyntax? rightOperand, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 3;
        if (leftOperand != null)
        {
            this.AdjustFlagsAndWidth(leftOperand);
            this.leftOperand = leftOperand;
        }
        this.AdjustFlagsAndWidth(operatorToken);
        this.operatorToken = operatorToken;
        if (rightOperand != null)
        {
            this.AdjustFlagsAndWidth(rightOperand);
            this.rightOperand = rightOperand;
        }
    }


    internal RangeExpressionSyntax(SyntaxKind kind, ExpressionSyntax? leftOperand, SyntaxToken operatorToken, ExpressionSyntax? rightOperand, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 3;
        if (leftOperand != null)
        {
            this.AdjustFlagsAndWidth(leftOperand);
            this.leftOperand = leftOperand;
        }
        this.AdjustFlagsAndWidth(operatorToken);
        this.operatorToken = operatorToken;
        if (rightOperand != null)
        {
            this.AdjustFlagsAndWidth(rightOperand);
            this.rightOperand = rightOperand;
        }
    }


    internal RangeExpressionSyntax(SyntaxKind kind, ExpressionSyntax? leftOperand, SyntaxToken operatorToken, ExpressionSyntax? rightOperand)
        : base(kind)
    {
        this.SlotCount = 3;
        if (leftOperand != null)
        {
            this.AdjustFlagsAndWidth(leftOperand);
            this.leftOperand = leftOperand;
        }
        this.AdjustFlagsAndWidth(operatorToken);
        this.operatorToken = operatorToken;
        if (rightOperand != null)
        {
            this.AdjustFlagsAndWidth(rightOperand);
            this.rightOperand = rightOperand;
        }
    }

    /// <summary>ExpressionSyntax node representing the expression on the left of the range operator.</summary>
    public ExpressionSyntax? LeftOperand => this.leftOperand;
    /// <summary>SyntaxToken representing the operator of the range expression.</summary>
    public SyntaxToken OperatorToken => this.operatorToken;
    /// <summary>ExpressionSyntax node representing the expression on the right of the range operator.</summary>
    public ExpressionSyntax? RightOperand => this.rightOperand;

    internal override GreenNode? GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.leftOperand;
            case 1: return this.operatorToken;
            case 2: return this.rightOperand;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new CSharp.Syntax.RangeExpressionSyntax(this, parent, position);

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor) => visitor.VisitRangeExpression(this);

    public override void Accept(CSharpSyntaxVisitor visitor) => visitor.VisitRangeExpression(this);

    public RangeExpressionSyntax Update(ExpressionSyntax leftOperand, SyntaxToken operatorToken, ExpressionSyntax rightOperand)
    {
        if (leftOperand != this.LeftOperand || operatorToken != this.OperatorToken || rightOperand != this.RightOperand)
        {
            var newNode = SyntaxFactory.RangeExpression(leftOperand, operatorToken, rightOperand);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
        => new RangeExpressionSyntax(this.Kind, this.leftOperand, this.operatorToken, this.rightOperand, diagnostics, GetAnnotations());

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
        => new RangeExpressionSyntax(this.Kind, this.leftOperand, this.operatorToken, this.rightOperand, GetDiagnostics(), annotations);

    internal RangeExpressionSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 3;
      var leftOperand = (ExpressionSyntax?)reader.ReadValue();
      if (leftOperand != null)
      {
         AdjustFlagsAndWidth(leftOperand);
         this.leftOperand = leftOperand;
      }
      var operatorToken = (SyntaxToken)reader.ReadValue();
      if (operatorToken != null)
      {
         AdjustFlagsAndWidth(operatorToken);
         this.operatorToken = operatorToken;
      }
      var rightOperand = (ExpressionSyntax?)reader.ReadValue();
      if (rightOperand != null)
      {
         AdjustFlagsAndWidth(rightOperand);
         this.rightOperand = rightOperand;
      }
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.leftOperand);
      writer.WriteValue(this.operatorToken);
      writer.WriteValue(this.rightOperand);
    }

    static RangeExpressionSyntax()
    {
       ObjectBinder.RegisterTypeReader(typeof(RangeExpressionSyntax), r => new RangeExpressionSyntax(r));
    }
  }

  /// <summary>Class which represents the syntax node for implicit element access expression.</summary>
  internal sealed partial class ImplicitElementAccessSyntax : ExpressionSyntax
  {
    internal readonly BracketedArgumentListSyntax argumentList;

    internal ImplicitElementAccessSyntax(SyntaxKind kind, BracketedArgumentListSyntax argumentList, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 1;
        this.AdjustFlagsAndWidth(argumentList);
        this.argumentList = argumentList;
    }


    internal ImplicitElementAccessSyntax(SyntaxKind kind, BracketedArgumentListSyntax argumentList, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 1;
        this.AdjustFlagsAndWidth(argumentList);
        this.argumentList = argumentList;
    }


    internal ImplicitElementAccessSyntax(SyntaxKind kind, BracketedArgumentListSyntax argumentList)
        : base(kind)
    {
        this.SlotCount = 1;
        this.AdjustFlagsAndWidth(argumentList);
        this.argumentList = argumentList;
    }

    /// <summary>BracketedArgumentListSyntax node representing the list of arguments of the implicit element access expression.</summary>
    public BracketedArgumentListSyntax ArgumentList => this.argumentList;

    internal override GreenNode? GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.argumentList;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new CSharp.Syntax.ImplicitElementAccessSyntax(this, parent, position);

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor) => visitor.VisitImplicitElementAccess(this);

    public override void Accept(CSharpSyntaxVisitor visitor) => visitor.VisitImplicitElementAccess(this);

    public ImplicitElementAccessSyntax Update(BracketedArgumentListSyntax argumentList)
    {
        if (argumentList != this.ArgumentList)
        {
            var newNode = SyntaxFactory.ImplicitElementAccess(argumentList);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
        => new ImplicitElementAccessSyntax(this.Kind, this.argumentList, diagnostics, GetAnnotations());

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
        => new ImplicitElementAccessSyntax(this.Kind, this.argumentList, GetDiagnostics(), annotations);

    internal ImplicitElementAccessSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 1;
      var argumentList = (BracketedArgumentListSyntax)reader.ReadValue();
      if (argumentList != null)
      {
         AdjustFlagsAndWidth(argumentList);
         this.argumentList = argumentList;
      }
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.argumentList);
    }

    static ImplicitElementAccessSyntax()
    {
       ObjectBinder.RegisterTypeReader(typeof(ImplicitElementAccessSyntax), r => new ImplicitElementAccessSyntax(r));
    }
  }

  /// <summary>Class which represents an expression that has a binary operator.</summary>
  internal sealed partial class BinaryExpressionSyntax : ExpressionSyntax
  {
    internal readonly ExpressionSyntax left;
    internal readonly SyntaxToken operatorToken;
    internal readonly ExpressionSyntax right;

    internal BinaryExpressionSyntax(SyntaxKind kind, ExpressionSyntax left, SyntaxToken operatorToken, ExpressionSyntax right, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 3;
        this.AdjustFlagsAndWidth(left);
        this.left = left;
        this.AdjustFlagsAndWidth(operatorToken);
        this.operatorToken = operatorToken;
        this.AdjustFlagsAndWidth(right);
        this.right = right;
    }


    internal BinaryExpressionSyntax(SyntaxKind kind, ExpressionSyntax left, SyntaxToken operatorToken, ExpressionSyntax right, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 3;
        this.AdjustFlagsAndWidth(left);
        this.left = left;
        this.AdjustFlagsAndWidth(operatorToken);
        this.operatorToken = operatorToken;
        this.AdjustFlagsAndWidth(right);
        this.right = right;
    }


    internal BinaryExpressionSyntax(SyntaxKind kind, ExpressionSyntax left, SyntaxToken operatorToken, ExpressionSyntax right)
        : base(kind)
    {
        this.SlotCount = 3;
        this.AdjustFlagsAndWidth(left);
        this.left = left;
        this.AdjustFlagsAndWidth(operatorToken);
        this.operatorToken = operatorToken;
        this.AdjustFlagsAndWidth(right);
        this.right = right;
    }

    /// <summary>ExpressionSyntax node representing the expression on the left of the binary operator.</summary>
    public ExpressionSyntax Left => this.left;
    /// <summary>SyntaxToken representing the operator of the binary expression.</summary>
    public SyntaxToken OperatorToken => this.operatorToken;
    /// <summary>ExpressionSyntax node representing the expression on the right of the binary operator.</summary>
    public ExpressionSyntax Right => this.right;

    internal override GreenNode? GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.left;
            case 1: return this.operatorToken;
            case 2: return this.right;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new CSharp.Syntax.BinaryExpressionSyntax(this, parent, position);

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor) => visitor.VisitBinaryExpression(this);

    public override void Accept(CSharpSyntaxVisitor visitor) => visitor.VisitBinaryExpression(this);

    public BinaryExpressionSyntax Update(ExpressionSyntax left, SyntaxToken operatorToken, ExpressionSyntax right)
    {
        if (left != this.Left || operatorToken != this.OperatorToken || right != this.Right)
        {
            var newNode = SyntaxFactory.BinaryExpression(this.Kind, left, operatorToken, right);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
        => new BinaryExpressionSyntax(this.Kind, this.left, this.operatorToken, this.right, diagnostics, GetAnnotations());

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
        => new BinaryExpressionSyntax(this.Kind, this.left, this.operatorToken, this.right, GetDiagnostics(), annotations);

    internal BinaryExpressionSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 3;
      var left = (ExpressionSyntax)reader.ReadValue();
      if (left != null)
      {
         AdjustFlagsAndWidth(left);
         this.left = left;
      }
      var operatorToken = (SyntaxToken)reader.ReadValue();
      if (operatorToken != null)
      {
         AdjustFlagsAndWidth(operatorToken);
         this.operatorToken = operatorToken;
      }
      var right = (ExpressionSyntax)reader.ReadValue();
      if (right != null)
      {
         AdjustFlagsAndWidth(right);
         this.right = right;
      }
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.left);
      writer.WriteValue(this.operatorToken);
      writer.WriteValue(this.right);
    }

    static BinaryExpressionSyntax()
    {
       ObjectBinder.RegisterTypeReader(typeof(BinaryExpressionSyntax), r => new BinaryExpressionSyntax(r));
    }
  }

  /// <summary>Class which represents an expression that has an assignment operator.</summary>
  internal sealed partial class AssignmentExpressionSyntax : ExpressionSyntax
  {
    internal readonly ExpressionSyntax left;
    internal readonly SyntaxToken operatorToken;
    internal readonly ExpressionSyntax right;

    internal AssignmentExpressionSyntax(SyntaxKind kind, ExpressionSyntax left, SyntaxToken operatorToken, ExpressionSyntax right, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 3;
        this.AdjustFlagsAndWidth(left);
        this.left = left;
        this.AdjustFlagsAndWidth(operatorToken);
        this.operatorToken = operatorToken;
        this.AdjustFlagsAndWidth(right);
        this.right = right;
    }


    internal AssignmentExpressionSyntax(SyntaxKind kind, ExpressionSyntax left, SyntaxToken operatorToken, ExpressionSyntax right, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 3;
        this.AdjustFlagsAndWidth(left);
        this.left = left;
        this.AdjustFlagsAndWidth(operatorToken);
        this.operatorToken = operatorToken;
        this.AdjustFlagsAndWidth(right);
        this.right = right;
    }


    internal AssignmentExpressionSyntax(SyntaxKind kind, ExpressionSyntax left, SyntaxToken operatorToken, ExpressionSyntax right)
        : base(kind)
    {
        this.SlotCount = 3;
        this.AdjustFlagsAndWidth(left);
        this.left = left;
        this.AdjustFlagsAndWidth(operatorToken);
        this.operatorToken = operatorToken;
        this.AdjustFlagsAndWidth(right);
        this.right = right;
    }

    /// <summary>ExpressionSyntax node representing the expression on the left of the assignment operator.</summary>
    public ExpressionSyntax Left => this.left;
    /// <summary>SyntaxToken representing the operator of the assignment expression.</summary>
    public SyntaxToken OperatorToken => this.operatorToken;
    /// <summary>ExpressionSyntax node representing the expression on the right of the assignment operator.</summary>
    public ExpressionSyntax Right => this.right;

    internal override GreenNode? GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.left;
            case 1: return this.operatorToken;
            case 2: return this.right;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new CSharp.Syntax.AssignmentExpressionSyntax(this, parent, position);

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor) => visitor.VisitAssignmentExpression(this);

    public override void Accept(CSharpSyntaxVisitor visitor) => visitor.VisitAssignmentExpression(this);

    public AssignmentExpressionSyntax Update(ExpressionSyntax left, SyntaxToken operatorToken, ExpressionSyntax right)
    {
        if (left != this.Left || operatorToken != this.OperatorToken || right != this.Right)
        {
            var newNode = SyntaxFactory.AssignmentExpression(this.Kind, left, operatorToken, right);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
        => new AssignmentExpressionSyntax(this.Kind, this.left, this.operatorToken, this.right, diagnostics, GetAnnotations());

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
        => new AssignmentExpressionSyntax(this.Kind, this.left, this.operatorToken, this.right, GetDiagnostics(), annotations);

    internal AssignmentExpressionSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 3;
      var left = (ExpressionSyntax)reader.ReadValue();
      if (left != null)
      {
         AdjustFlagsAndWidth(left);
         this.left = left;
      }
      var operatorToken = (SyntaxToken)reader.ReadValue();
      if (operatorToken != null)
      {
         AdjustFlagsAndWidth(operatorToken);
         this.operatorToken = operatorToken;
      }
      var right = (ExpressionSyntax)reader.ReadValue();
      if (right != null)
      {
         AdjustFlagsAndWidth(right);
         this.right = right;
      }
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.left);
      writer.WriteValue(this.operatorToken);
      writer.WriteValue(this.right);
    }

    static AssignmentExpressionSyntax()
    {
       ObjectBinder.RegisterTypeReader(typeof(AssignmentExpressionSyntax), r => new AssignmentExpressionSyntax(r));
    }
  }

  /// <summary>Class which represents the syntax node for conditional expression.</summary>
  internal sealed partial class ConditionalExpressionSyntax : ExpressionSyntax
  {
    internal readonly ExpressionSyntax condition;
    internal readonly SyntaxToken questionToken;
    internal readonly ExpressionSyntax whenTrue;
    internal readonly SyntaxToken colonToken;
    internal readonly ExpressionSyntax whenFalse;

    internal ConditionalExpressionSyntax(SyntaxKind kind, ExpressionSyntax condition, SyntaxToken questionToken, ExpressionSyntax whenTrue, SyntaxToken colonToken, ExpressionSyntax whenFalse, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 5;
        this.AdjustFlagsAndWidth(condition);
        this.condition = condition;
        this.AdjustFlagsAndWidth(questionToken);
        this.questionToken = questionToken;
        this.AdjustFlagsAndWidth(whenTrue);
        this.whenTrue = whenTrue;
        this.AdjustFlagsAndWidth(colonToken);
        this.colonToken = colonToken;
        this.AdjustFlagsAndWidth(whenFalse);
        this.whenFalse = whenFalse;
    }


    internal ConditionalExpressionSyntax(SyntaxKind kind, ExpressionSyntax condition, SyntaxToken questionToken, ExpressionSyntax whenTrue, SyntaxToken colonToken, ExpressionSyntax whenFalse, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 5;
        this.AdjustFlagsAndWidth(condition);
        this.condition = condition;
        this.AdjustFlagsAndWidth(questionToken);
        this.questionToken = questionToken;
        this.AdjustFlagsAndWidth(whenTrue);
        this.whenTrue = whenTrue;
        this.AdjustFlagsAndWidth(colonToken);
        this.colonToken = colonToken;
        this.AdjustFlagsAndWidth(whenFalse);
        this.whenFalse = whenFalse;
    }


    internal ConditionalExpressionSyntax(SyntaxKind kind, ExpressionSyntax condition, SyntaxToken questionToken, ExpressionSyntax whenTrue, SyntaxToken colonToken, ExpressionSyntax whenFalse)
        : base(kind)
    {
        this.SlotCount = 5;
        this.AdjustFlagsAndWidth(condition);
        this.condition = condition;
        this.AdjustFlagsAndWidth(questionToken);
        this.questionToken = questionToken;
        this.AdjustFlagsAndWidth(whenTrue);
        this.whenTrue = whenTrue;
        this.AdjustFlagsAndWidth(colonToken);
        this.colonToken = colonToken;
        this.AdjustFlagsAndWidth(whenFalse);
        this.whenFalse = whenFalse;
    }

    /// <summary>ExpressionSyntax node representing the condition of the conditional expression.</summary>
    public ExpressionSyntax Condition => this.condition;
    /// <summary>SyntaxToken representing the question mark.</summary>
    public SyntaxToken QuestionToken => this.questionToken;
    /// <summary>ExpressionSyntax node representing the expression to be executed when the condition is true.</summary>
    public ExpressionSyntax WhenTrue => this.whenTrue;
    /// <summary>SyntaxToken representing the colon.</summary>
    public SyntaxToken ColonToken => this.colonToken;
    /// <summary>ExpressionSyntax node representing the expression to be executed when the condition is false.</summary>
    public ExpressionSyntax WhenFalse => this.whenFalse;

    internal override GreenNode? GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.condition;
            case 1: return this.questionToken;
            case 2: return this.whenTrue;
            case 3: return this.colonToken;
            case 4: return this.whenFalse;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new CSharp.Syntax.ConditionalExpressionSyntax(this, parent, position);

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor) => visitor.VisitConditionalExpression(this);

    public override void Accept(CSharpSyntaxVisitor visitor) => visitor.VisitConditionalExpression(this);

    public ConditionalExpressionSyntax Update(ExpressionSyntax condition, SyntaxToken questionToken, ExpressionSyntax whenTrue, SyntaxToken colonToken, ExpressionSyntax whenFalse)
    {
        if (condition != this.Condition || questionToken != this.QuestionToken || whenTrue != this.WhenTrue || colonToken != this.ColonToken || whenFalse != this.WhenFalse)
        {
            var newNode = SyntaxFactory.ConditionalExpression(condition, questionToken, whenTrue, colonToken, whenFalse);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
        => new ConditionalExpressionSyntax(this.Kind, this.condition, this.questionToken, this.whenTrue, this.colonToken, this.whenFalse, diagnostics, GetAnnotations());

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
        => new ConditionalExpressionSyntax(this.Kind, this.condition, this.questionToken, this.whenTrue, this.colonToken, this.whenFalse, GetDiagnostics(), annotations);

    internal ConditionalExpressionSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 5;
      var condition = (ExpressionSyntax)reader.ReadValue();
      if (condition != null)
      {
         AdjustFlagsAndWidth(condition);
         this.condition = condition;
      }
      var questionToken = (SyntaxToken)reader.ReadValue();
      if (questionToken != null)
      {
         AdjustFlagsAndWidth(questionToken);
         this.questionToken = questionToken;
      }
      var whenTrue = (ExpressionSyntax)reader.ReadValue();
      if (whenTrue != null)
      {
         AdjustFlagsAndWidth(whenTrue);
         this.whenTrue = whenTrue;
      }
      var colonToken = (SyntaxToken)reader.ReadValue();
      if (colonToken != null)
      {
         AdjustFlagsAndWidth(colonToken);
         this.colonToken = colonToken;
      }
      var whenFalse = (ExpressionSyntax)reader.ReadValue();
      if (whenFalse != null)
      {
         AdjustFlagsAndWidth(whenFalse);
         this.whenFalse = whenFalse;
      }
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.condition);
      writer.WriteValue(this.questionToken);
      writer.WriteValue(this.whenTrue);
      writer.WriteValue(this.colonToken);
      writer.WriteValue(this.whenFalse);
    }

    static ConditionalExpressionSyntax()
    {
       ObjectBinder.RegisterTypeReader(typeof(ConditionalExpressionSyntax), r => new ConditionalExpressionSyntax(r));
    }
  }

  /// <summary>Provides the base class from which the classes that represent instance expression syntax nodes are derived. This is an abstract class.</summary>
  internal abstract partial class InstanceExpressionSyntax : ExpressionSyntax
  {
    internal InstanceExpressionSyntax(SyntaxKind kind, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
      : base(kind, diagnostics, annotations)
    {
    }
    internal InstanceExpressionSyntax(SyntaxKind kind)
      : base(kind)
    {
    }

    protected InstanceExpressionSyntax(ObjectReader reader)
       : base(reader)
    {
    }
  }

  /// <summary>Class which represents the syntax node for a this expression.</summary>
  internal sealed partial class ThisExpressionSyntax : InstanceExpressionSyntax
  {
    internal readonly SyntaxToken token;

    internal ThisExpressionSyntax(SyntaxKind kind, SyntaxToken token, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 1;
        this.AdjustFlagsAndWidth(token);
        this.token = token;
    }


    internal ThisExpressionSyntax(SyntaxKind kind, SyntaxToken token, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 1;
        this.AdjustFlagsAndWidth(token);
        this.token = token;
    }


    internal ThisExpressionSyntax(SyntaxKind kind, SyntaxToken token)
        : base(kind)
    {
        this.SlotCount = 1;
        this.AdjustFlagsAndWidth(token);
        this.token = token;
    }

    /// <summary>SyntaxToken representing the this keyword.</summary>
    public SyntaxToken Token => this.token;

    internal override GreenNode? GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.token;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new CSharp.Syntax.ThisExpressionSyntax(this, parent, position);

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor) => visitor.VisitThisExpression(this);

    public override void Accept(CSharpSyntaxVisitor visitor) => visitor.VisitThisExpression(this);

    public ThisExpressionSyntax Update(SyntaxToken token)
    {
        if (token != this.Token)
        {
            var newNode = SyntaxFactory.ThisExpression(token);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
        => new ThisExpressionSyntax(this.Kind, this.token, diagnostics, GetAnnotations());

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
        => new ThisExpressionSyntax(this.Kind, this.token, GetDiagnostics(), annotations);

    internal ThisExpressionSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 1;
      var token = (SyntaxToken)reader.ReadValue();
      if (token != null)
      {
         AdjustFlagsAndWidth(token);
         this.token = token;
      }
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.token);
    }

    static ThisExpressionSyntax()
    {
       ObjectBinder.RegisterTypeReader(typeof(ThisExpressionSyntax), r => new ThisExpressionSyntax(r));
    }
  }

  /// <summary>Class which represents the syntax node for a base expression.</summary>
  internal sealed partial class BaseExpressionSyntax : InstanceExpressionSyntax
  {
    internal readonly SyntaxToken token;

    internal BaseExpressionSyntax(SyntaxKind kind, SyntaxToken token, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 1;
        this.AdjustFlagsAndWidth(token);
        this.token = token;
    }


    internal BaseExpressionSyntax(SyntaxKind kind, SyntaxToken token, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 1;
        this.AdjustFlagsAndWidth(token);
        this.token = token;
    }


    internal BaseExpressionSyntax(SyntaxKind kind, SyntaxToken token)
        : base(kind)
    {
        this.SlotCount = 1;
        this.AdjustFlagsAndWidth(token);
        this.token = token;
    }

    /// <summary>SyntaxToken representing the base keyword.</summary>
    public SyntaxToken Token => this.token;

    internal override GreenNode? GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.token;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new CSharp.Syntax.BaseExpressionSyntax(this, parent, position);

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor) => visitor.VisitBaseExpression(this);

    public override void Accept(CSharpSyntaxVisitor visitor) => visitor.VisitBaseExpression(this);

    public BaseExpressionSyntax Update(SyntaxToken token)
    {
        if (token != this.Token)
        {
            var newNode = SyntaxFactory.BaseExpression(token);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
        => new BaseExpressionSyntax(this.Kind, this.token, diagnostics, GetAnnotations());

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
        => new BaseExpressionSyntax(this.Kind, this.token, GetDiagnostics(), annotations);

    internal BaseExpressionSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 1;
      var token = (SyntaxToken)reader.ReadValue();
      if (token != null)
      {
         AdjustFlagsAndWidth(token);
         this.token = token;
      }
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.token);
    }

    static BaseExpressionSyntax()
    {
       ObjectBinder.RegisterTypeReader(typeof(BaseExpressionSyntax), r => new BaseExpressionSyntax(r));
    }
  }

  /// <summary>Class which represents the syntax node for a literal expression.</summary>
  internal sealed partial class LiteralExpressionSyntax : ExpressionSyntax
  {
    internal readonly SyntaxToken token;

    internal LiteralExpressionSyntax(SyntaxKind kind, SyntaxToken token, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 1;
        this.AdjustFlagsAndWidth(token);
        this.token = token;
    }


    internal LiteralExpressionSyntax(SyntaxKind kind, SyntaxToken token, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 1;
        this.AdjustFlagsAndWidth(token);
        this.token = token;
    }


    internal LiteralExpressionSyntax(SyntaxKind kind, SyntaxToken token)
        : base(kind)
    {
        this.SlotCount = 1;
        this.AdjustFlagsAndWidth(token);
        this.token = token;
    }

    /// <summary>SyntaxToken representing the keyword corresponding to the kind of the literal expression.</summary>
    public SyntaxToken Token => this.token;

    internal override GreenNode? GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.token;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new CSharp.Syntax.LiteralExpressionSyntax(this, parent, position);

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor) => visitor.VisitLiteralExpression(this);

    public override void Accept(CSharpSyntaxVisitor visitor) => visitor.VisitLiteralExpression(this);

    public LiteralExpressionSyntax Update(SyntaxToken token)
    {
        if (token != this.Token)
        {
            var newNode = SyntaxFactory.LiteralExpression(this.Kind, token);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
        => new LiteralExpressionSyntax(this.Kind, this.token, diagnostics, GetAnnotations());

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
        => new LiteralExpressionSyntax(this.Kind, this.token, GetDiagnostics(), annotations);

    internal LiteralExpressionSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 1;
      var token = (SyntaxToken)reader.ReadValue();
      if (token != null)
      {
         AdjustFlagsAndWidth(token);
         this.token = token;
      }
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.token);
    }

    static LiteralExpressionSyntax()
    {
       ObjectBinder.RegisterTypeReader(typeof(LiteralExpressionSyntax), r => new LiteralExpressionSyntax(r));
    }
  }

  /// <summary>Class which represents the syntax node for MakeRef expression.</summary>
  internal sealed partial class MakeRefExpressionSyntax : ExpressionSyntax
  {
    internal readonly SyntaxToken keyword;
    internal readonly SyntaxToken openParenToken;
    internal readonly ExpressionSyntax expression;
    internal readonly SyntaxToken closeParenToken;

    internal MakeRefExpressionSyntax(SyntaxKind kind, SyntaxToken keyword, SyntaxToken openParenToken, ExpressionSyntax expression, SyntaxToken closeParenToken, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 4;
        this.AdjustFlagsAndWidth(keyword);
        this.keyword = keyword;
        this.AdjustFlagsAndWidth(openParenToken);
        this.openParenToken = openParenToken;
        this.AdjustFlagsAndWidth(expression);
        this.expression = expression;
        this.AdjustFlagsAndWidth(closeParenToken);
        this.closeParenToken = closeParenToken;
    }


    internal MakeRefExpressionSyntax(SyntaxKind kind, SyntaxToken keyword, SyntaxToken openParenToken, ExpressionSyntax expression, SyntaxToken closeParenToken, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 4;
        this.AdjustFlagsAndWidth(keyword);
        this.keyword = keyword;
        this.AdjustFlagsAndWidth(openParenToken);
        this.openParenToken = openParenToken;
        this.AdjustFlagsAndWidth(expression);
        this.expression = expression;
        this.AdjustFlagsAndWidth(closeParenToken);
        this.closeParenToken = closeParenToken;
    }


    internal MakeRefExpressionSyntax(SyntaxKind kind, SyntaxToken keyword, SyntaxToken openParenToken, ExpressionSyntax expression, SyntaxToken closeParenToken)
        : base(kind)
    {
        this.SlotCount = 4;
        this.AdjustFlagsAndWidth(keyword);
        this.keyword = keyword;
        this.AdjustFlagsAndWidth(openParenToken);
        this.openParenToken = openParenToken;
        this.AdjustFlagsAndWidth(expression);
        this.expression = expression;
        this.AdjustFlagsAndWidth(closeParenToken);
        this.closeParenToken = closeParenToken;
    }

    /// <summary>SyntaxToken representing the MakeRefKeyword.</summary>
    public SyntaxToken Keyword => this.keyword;
    /// <summary>SyntaxToken representing open parenthesis.</summary>
    public SyntaxToken OpenParenToken => this.openParenToken;
    /// <summary>Argument of the primary function.</summary>
    public ExpressionSyntax Expression => this.expression;
    /// <summary>SyntaxToken representing close parenthesis.</summary>
    public SyntaxToken CloseParenToken => this.closeParenToken;

    internal override GreenNode? GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.keyword;
            case 1: return this.openParenToken;
            case 2: return this.expression;
            case 3: return this.closeParenToken;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new CSharp.Syntax.MakeRefExpressionSyntax(this, parent, position);

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor) => visitor.VisitMakeRefExpression(this);

    public override void Accept(CSharpSyntaxVisitor visitor) => visitor.VisitMakeRefExpression(this);

    public MakeRefExpressionSyntax Update(SyntaxToken keyword, SyntaxToken openParenToken, ExpressionSyntax expression, SyntaxToken closeParenToken)
    {
        if (keyword != this.Keyword || openParenToken != this.OpenParenToken || expression != this.Expression || closeParenToken != this.CloseParenToken)
        {
            var newNode = SyntaxFactory.MakeRefExpression(keyword, openParenToken, expression, closeParenToken);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
        => new MakeRefExpressionSyntax(this.Kind, this.keyword, this.openParenToken, this.expression, this.closeParenToken, diagnostics, GetAnnotations());

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
        => new MakeRefExpressionSyntax(this.Kind, this.keyword, this.openParenToken, this.expression, this.closeParenToken, GetDiagnostics(), annotations);

    internal MakeRefExpressionSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 4;
      var keyword = (SyntaxToken)reader.ReadValue();
      if (keyword != null)
      {
         AdjustFlagsAndWidth(keyword);
         this.keyword = keyword;
      }
      var openParenToken = (SyntaxToken)reader.ReadValue();
      if (openParenToken != null)
      {
         AdjustFlagsAndWidth(openParenToken);
         this.openParenToken = openParenToken;
      }
      var expression = (ExpressionSyntax)reader.ReadValue();
      if (expression != null)
      {
         AdjustFlagsAndWidth(expression);
         this.expression = expression;
      }
      var closeParenToken = (SyntaxToken)reader.ReadValue();
      if (closeParenToken != null)
      {
         AdjustFlagsAndWidth(closeParenToken);
         this.closeParenToken = closeParenToken;
      }
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.keyword);
      writer.WriteValue(this.openParenToken);
      writer.WriteValue(this.expression);
      writer.WriteValue(this.closeParenToken);
    }

    static MakeRefExpressionSyntax()
    {
       ObjectBinder.RegisterTypeReader(typeof(MakeRefExpressionSyntax), r => new MakeRefExpressionSyntax(r));
    }
  }

  /// <summary>Class which represents the syntax node for RefType expression.</summary>
  internal sealed partial class RefTypeExpressionSyntax : ExpressionSyntax
  {
    internal readonly SyntaxToken keyword;
    internal readonly SyntaxToken openParenToken;
    internal readonly ExpressionSyntax expression;
    internal readonly SyntaxToken closeParenToken;

    internal RefTypeExpressionSyntax(SyntaxKind kind, SyntaxToken keyword, SyntaxToken openParenToken, ExpressionSyntax expression, SyntaxToken closeParenToken, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 4;
        this.AdjustFlagsAndWidth(keyword);
        this.keyword = keyword;
        this.AdjustFlagsAndWidth(openParenToken);
        this.openParenToken = openParenToken;
        this.AdjustFlagsAndWidth(expression);
        this.expression = expression;
        this.AdjustFlagsAndWidth(closeParenToken);
        this.closeParenToken = closeParenToken;
    }


    internal RefTypeExpressionSyntax(SyntaxKind kind, SyntaxToken keyword, SyntaxToken openParenToken, ExpressionSyntax expression, SyntaxToken closeParenToken, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 4;
        this.AdjustFlagsAndWidth(keyword);
        this.keyword = keyword;
        this.AdjustFlagsAndWidth(openParenToken);
        this.openParenToken = openParenToken;
        this.AdjustFlagsAndWidth(expression);
        this.expression = expression;
        this.AdjustFlagsAndWidth(closeParenToken);
        this.closeParenToken = closeParenToken;
    }


    internal RefTypeExpressionSyntax(SyntaxKind kind, SyntaxToken keyword, SyntaxToken openParenToken, ExpressionSyntax expression, SyntaxToken closeParenToken)
        : base(kind)
    {
        this.SlotCount = 4;
        this.AdjustFlagsAndWidth(keyword);
        this.keyword = keyword;
        this.AdjustFlagsAndWidth(openParenToken);
        this.openParenToken = openParenToken;
        this.AdjustFlagsAndWidth(expression);
        this.expression = expression;
        this.AdjustFlagsAndWidth(closeParenToken);
        this.closeParenToken = closeParenToken;
    }

    /// <summary>SyntaxToken representing the RefTypeKeyword.</summary>
    public SyntaxToken Keyword => this.keyword;
    /// <summary>SyntaxToken representing open parenthesis.</summary>
    public SyntaxToken OpenParenToken => this.openParenToken;
    /// <summary>Argument of the primary function.</summary>
    public ExpressionSyntax Expression => this.expression;
    /// <summary>SyntaxToken representing close parenthesis.</summary>
    public SyntaxToken CloseParenToken => this.closeParenToken;

    internal override GreenNode? GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.keyword;
            case 1: return this.openParenToken;
            case 2: return this.expression;
            case 3: return this.closeParenToken;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new CSharp.Syntax.RefTypeExpressionSyntax(this, parent, position);

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor) => visitor.VisitRefTypeExpression(this);

    public override void Accept(CSharpSyntaxVisitor visitor) => visitor.VisitRefTypeExpression(this);

    public RefTypeExpressionSyntax Update(SyntaxToken keyword, SyntaxToken openParenToken, ExpressionSyntax expression, SyntaxToken closeParenToken)
    {
        if (keyword != this.Keyword || openParenToken != this.OpenParenToken || expression != this.Expression || closeParenToken != this.CloseParenToken)
        {
            var newNode = SyntaxFactory.RefTypeExpression(keyword, openParenToken, expression, closeParenToken);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
        => new RefTypeExpressionSyntax(this.Kind, this.keyword, this.openParenToken, this.expression, this.closeParenToken, diagnostics, GetAnnotations());

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
        => new RefTypeExpressionSyntax(this.Kind, this.keyword, this.openParenToken, this.expression, this.closeParenToken, GetDiagnostics(), annotations);

    internal RefTypeExpressionSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 4;
      var keyword = (SyntaxToken)reader.ReadValue();
      if (keyword != null)
      {
         AdjustFlagsAndWidth(keyword);
         this.keyword = keyword;
      }
      var openParenToken = (SyntaxToken)reader.ReadValue();
      if (openParenToken != null)
      {
         AdjustFlagsAndWidth(openParenToken);
         this.openParenToken = openParenToken;
      }
      var expression = (ExpressionSyntax)reader.ReadValue();
      if (expression != null)
      {
         AdjustFlagsAndWidth(expression);
         this.expression = expression;
      }
      var closeParenToken = (SyntaxToken)reader.ReadValue();
      if (closeParenToken != null)
      {
         AdjustFlagsAndWidth(closeParenToken);
         this.closeParenToken = closeParenToken;
      }
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.keyword);
      writer.WriteValue(this.openParenToken);
      writer.WriteValue(this.expression);
      writer.WriteValue(this.closeParenToken);
    }

    static RefTypeExpressionSyntax()
    {
       ObjectBinder.RegisterTypeReader(typeof(RefTypeExpressionSyntax), r => new RefTypeExpressionSyntax(r));
    }
  }

  /// <summary>Class which represents the syntax node for RefValue expression.</summary>
  internal sealed partial class RefValueExpressionSyntax : ExpressionSyntax
  {
    internal readonly SyntaxToken keyword;
    internal readonly SyntaxToken openParenToken;
    internal readonly ExpressionSyntax expression;
    internal readonly SyntaxToken comma;
    internal readonly TypeSyntax type;
    internal readonly SyntaxToken closeParenToken;

    internal RefValueExpressionSyntax(SyntaxKind kind, SyntaxToken keyword, SyntaxToken openParenToken, ExpressionSyntax expression, SyntaxToken comma, TypeSyntax type, SyntaxToken closeParenToken, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 6;
        this.AdjustFlagsAndWidth(keyword);
        this.keyword = keyword;
        this.AdjustFlagsAndWidth(openParenToken);
        this.openParenToken = openParenToken;
        this.AdjustFlagsAndWidth(expression);
        this.expression = expression;
        this.AdjustFlagsAndWidth(comma);
        this.comma = comma;
        this.AdjustFlagsAndWidth(type);
        this.type = type;
        this.AdjustFlagsAndWidth(closeParenToken);
        this.closeParenToken = closeParenToken;
    }


    internal RefValueExpressionSyntax(SyntaxKind kind, SyntaxToken keyword, SyntaxToken openParenToken, ExpressionSyntax expression, SyntaxToken comma, TypeSyntax type, SyntaxToken closeParenToken, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 6;
        this.AdjustFlagsAndWidth(keyword);
        this.keyword = keyword;
        this.AdjustFlagsAndWidth(openParenToken);
        this.openParenToken = openParenToken;
        this.AdjustFlagsAndWidth(expression);
        this.expression = expression;
        this.AdjustFlagsAndWidth(comma);
        this.comma = comma;
        this.AdjustFlagsAndWidth(type);
        this.type = type;
        this.AdjustFlagsAndWidth(closeParenToken);
        this.closeParenToken = closeParenToken;
    }


    internal RefValueExpressionSyntax(SyntaxKind kind, SyntaxToken keyword, SyntaxToken openParenToken, ExpressionSyntax expression, SyntaxToken comma, TypeSyntax type, SyntaxToken closeParenToken)
        : base(kind)
    {
        this.SlotCount = 6;
        this.AdjustFlagsAndWidth(keyword);
        this.keyword = keyword;
        this.AdjustFlagsAndWidth(openParenToken);
        this.openParenToken = openParenToken;
        this.AdjustFlagsAndWidth(expression);
        this.expression = expression;
        this.AdjustFlagsAndWidth(comma);
        this.comma = comma;
        this.AdjustFlagsAndWidth(type);
        this.type = type;
        this.AdjustFlagsAndWidth(closeParenToken);
        this.closeParenToken = closeParenToken;
    }

    /// <summary>SyntaxToken representing the RefValueKeyword.</summary>
    public SyntaxToken Keyword => this.keyword;
    /// <summary>SyntaxToken representing open parenthesis.</summary>
    public SyntaxToken OpenParenToken => this.openParenToken;
    /// <summary>Typed reference expression.</summary>
    public ExpressionSyntax Expression => this.expression;
    /// <summary>Comma separating the arguments.</summary>
    public SyntaxToken Comma => this.comma;
    /// <summary>The type of the value.</summary>
    public TypeSyntax Type => this.type;
    /// <summary>SyntaxToken representing close parenthesis.</summary>
    public SyntaxToken CloseParenToken => this.closeParenToken;

    internal override GreenNode? GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.keyword;
            case 1: return this.openParenToken;
            case 2: return this.expression;
            case 3: return this.comma;
            case 4: return this.type;
            case 5: return this.closeParenToken;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new CSharp.Syntax.RefValueExpressionSyntax(this, parent, position);

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor) => visitor.VisitRefValueExpression(this);

    public override void Accept(CSharpSyntaxVisitor visitor) => visitor.VisitRefValueExpression(this);

    public RefValueExpressionSyntax Update(SyntaxToken keyword, SyntaxToken openParenToken, ExpressionSyntax expression, SyntaxToken comma, TypeSyntax type, SyntaxToken closeParenToken)
    {
        if (keyword != this.Keyword || openParenToken != this.OpenParenToken || expression != this.Expression || comma != this.Comma || type != this.Type || closeParenToken != this.CloseParenToken)
        {
            var newNode = SyntaxFactory.RefValueExpression(keyword, openParenToken, expression, comma, type, closeParenToken);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
        => new RefValueExpressionSyntax(this.Kind, this.keyword, this.openParenToken, this.expression, this.comma, this.type, this.closeParenToken, diagnostics, GetAnnotations());

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
        => new RefValueExpressionSyntax(this.Kind, this.keyword, this.openParenToken, this.expression, this.comma, this.type, this.closeParenToken, GetDiagnostics(), annotations);

    internal RefValueExpressionSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 6;
      var keyword = (SyntaxToken)reader.ReadValue();
      if (keyword != null)
      {
         AdjustFlagsAndWidth(keyword);
         this.keyword = keyword;
      }
      var openParenToken = (SyntaxToken)reader.ReadValue();
      if (openParenToken != null)
      {
         AdjustFlagsAndWidth(openParenToken);
         this.openParenToken = openParenToken;
      }
      var expression = (ExpressionSyntax)reader.ReadValue();
      if (expression != null)
      {
         AdjustFlagsAndWidth(expression);
         this.expression = expression;
      }
      var comma = (SyntaxToken)reader.ReadValue();
      if (comma != null)
      {
         AdjustFlagsAndWidth(comma);
         this.comma = comma;
      }
      var type = (TypeSyntax)reader.ReadValue();
      if (type != null)
      {
         AdjustFlagsAndWidth(type);
         this.type = type;
      }
      var closeParenToken = (SyntaxToken)reader.ReadValue();
      if (closeParenToken != null)
      {
         AdjustFlagsAndWidth(closeParenToken);
         this.closeParenToken = closeParenToken;
      }
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.keyword);
      writer.WriteValue(this.openParenToken);
      writer.WriteValue(this.expression);
      writer.WriteValue(this.comma);
      writer.WriteValue(this.type);
      writer.WriteValue(this.closeParenToken);
    }

    static RefValueExpressionSyntax()
    {
       ObjectBinder.RegisterTypeReader(typeof(RefValueExpressionSyntax), r => new RefValueExpressionSyntax(r));
    }
  }

  /// <summary>Class which represents the syntax node for Checked or Unchecked expression.</summary>
  internal sealed partial class CheckedExpressionSyntax : ExpressionSyntax
  {
    internal readonly SyntaxToken keyword;
    internal readonly SyntaxToken openParenToken;
    internal readonly ExpressionSyntax expression;
    internal readonly SyntaxToken closeParenToken;

    internal CheckedExpressionSyntax(SyntaxKind kind, SyntaxToken keyword, SyntaxToken openParenToken, ExpressionSyntax expression, SyntaxToken closeParenToken, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 4;
        this.AdjustFlagsAndWidth(keyword);
        this.keyword = keyword;
        this.AdjustFlagsAndWidth(openParenToken);
        this.openParenToken = openParenToken;
        this.AdjustFlagsAndWidth(expression);
        this.expression = expression;
        this.AdjustFlagsAndWidth(closeParenToken);
        this.closeParenToken = closeParenToken;
    }


    internal CheckedExpressionSyntax(SyntaxKind kind, SyntaxToken keyword, SyntaxToken openParenToken, ExpressionSyntax expression, SyntaxToken closeParenToken, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 4;
        this.AdjustFlagsAndWidth(keyword);
        this.keyword = keyword;
        this.AdjustFlagsAndWidth(openParenToken);
        this.openParenToken = openParenToken;
        this.AdjustFlagsAndWidth(expression);
        this.expression = expression;
        this.AdjustFlagsAndWidth(closeParenToken);
        this.closeParenToken = closeParenToken;
    }


    internal CheckedExpressionSyntax(SyntaxKind kind, SyntaxToken keyword, SyntaxToken openParenToken, ExpressionSyntax expression, SyntaxToken closeParenToken)
        : base(kind)
    {
        this.SlotCount = 4;
        this.AdjustFlagsAndWidth(keyword);
        this.keyword = keyword;
        this.AdjustFlagsAndWidth(openParenToken);
        this.openParenToken = openParenToken;
        this.AdjustFlagsAndWidth(expression);
        this.expression = expression;
        this.AdjustFlagsAndWidth(closeParenToken);
        this.closeParenToken = closeParenToken;
    }

    /// <summary>SyntaxToken representing the checked or unchecked keyword.</summary>
    public SyntaxToken Keyword => this.keyword;
    /// <summary>SyntaxToken representing open parenthesis.</summary>
    public SyntaxToken OpenParenToken => this.openParenToken;
    /// <summary>Argument of the primary function.</summary>
    public ExpressionSyntax Expression => this.expression;
    /// <summary>SyntaxToken representing close parenthesis.</summary>
    public SyntaxToken CloseParenToken => this.closeParenToken;

    internal override GreenNode? GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.keyword;
            case 1: return this.openParenToken;
            case 2: return this.expression;
            case 3: return this.closeParenToken;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new CSharp.Syntax.CheckedExpressionSyntax(this, parent, position);

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor) => visitor.VisitCheckedExpression(this);

    public override void Accept(CSharpSyntaxVisitor visitor) => visitor.VisitCheckedExpression(this);

    public CheckedExpressionSyntax Update(SyntaxToken keyword, SyntaxToken openParenToken, ExpressionSyntax expression, SyntaxToken closeParenToken)
    {
        if (keyword != this.Keyword || openParenToken != this.OpenParenToken || expression != this.Expression || closeParenToken != this.CloseParenToken)
        {
            var newNode = SyntaxFactory.CheckedExpression(this.Kind, keyword, openParenToken, expression, closeParenToken);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
        => new CheckedExpressionSyntax(this.Kind, this.keyword, this.openParenToken, this.expression, this.closeParenToken, diagnostics, GetAnnotations());

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
        => new CheckedExpressionSyntax(this.Kind, this.keyword, this.openParenToken, this.expression, this.closeParenToken, GetDiagnostics(), annotations);

    internal CheckedExpressionSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 4;
      var keyword = (SyntaxToken)reader.ReadValue();
      if (keyword != null)
      {
         AdjustFlagsAndWidth(keyword);
         this.keyword = keyword;
      }
      var openParenToken = (SyntaxToken)reader.ReadValue();
      if (openParenToken != null)
      {
         AdjustFlagsAndWidth(openParenToken);
         this.openParenToken = openParenToken;
      }
      var expression = (ExpressionSyntax)reader.ReadValue();
      if (expression != null)
      {
         AdjustFlagsAndWidth(expression);
         this.expression = expression;
      }
      var closeParenToken = (SyntaxToken)reader.ReadValue();
      if (closeParenToken != null)
      {
         AdjustFlagsAndWidth(closeParenToken);
         this.closeParenToken = closeParenToken;
      }
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.keyword);
      writer.WriteValue(this.openParenToken);
      writer.WriteValue(this.expression);
      writer.WriteValue(this.closeParenToken);
    }

    static CheckedExpressionSyntax()
    {
       ObjectBinder.RegisterTypeReader(typeof(CheckedExpressionSyntax), r => new CheckedExpressionSyntax(r));
    }
  }

  /// <summary>Class which represents the syntax node for Default expression.</summary>
  internal sealed partial class DefaultExpressionSyntax : ExpressionSyntax
  {
    internal readonly SyntaxToken keyword;
    internal readonly SyntaxToken openParenToken;
    internal readonly TypeSyntax type;
    internal readonly SyntaxToken closeParenToken;

    internal DefaultExpressionSyntax(SyntaxKind kind, SyntaxToken keyword, SyntaxToken openParenToken, TypeSyntax type, SyntaxToken closeParenToken, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 4;
        this.AdjustFlagsAndWidth(keyword);
        this.keyword = keyword;
        this.AdjustFlagsAndWidth(openParenToken);
        this.openParenToken = openParenToken;
        this.AdjustFlagsAndWidth(type);
        this.type = type;
        this.AdjustFlagsAndWidth(closeParenToken);
        this.closeParenToken = closeParenToken;
    }


    internal DefaultExpressionSyntax(SyntaxKind kind, SyntaxToken keyword, SyntaxToken openParenToken, TypeSyntax type, SyntaxToken closeParenToken, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 4;
        this.AdjustFlagsAndWidth(keyword);
        this.keyword = keyword;
        this.AdjustFlagsAndWidth(openParenToken);
        this.openParenToken = openParenToken;
        this.AdjustFlagsAndWidth(type);
        this.type = type;
        this.AdjustFlagsAndWidth(closeParenToken);
        this.closeParenToken = closeParenToken;
    }


    internal DefaultExpressionSyntax(SyntaxKind kind, SyntaxToken keyword, SyntaxToken openParenToken, TypeSyntax type, SyntaxToken closeParenToken)
        : base(kind)
    {
        this.SlotCount = 4;
        this.AdjustFlagsAndWidth(keyword);
        this.keyword = keyword;
        this.AdjustFlagsAndWidth(openParenToken);
        this.openParenToken = openParenToken;
        this.AdjustFlagsAndWidth(type);
        this.type = type;
        this.AdjustFlagsAndWidth(closeParenToken);
        this.closeParenToken = closeParenToken;
    }

    /// <summary>SyntaxToken representing the DefaultKeyword.</summary>
    public SyntaxToken Keyword => this.keyword;
    /// <summary>SyntaxToken representing open parenthesis.</summary>
    public SyntaxToken OpenParenToken => this.openParenToken;
    /// <summary>Argument of the primary function.</summary>
    public TypeSyntax Type => this.type;
    /// <summary>SyntaxToken representing close parenthesis.</summary>
    public SyntaxToken CloseParenToken => this.closeParenToken;

    internal override GreenNode? GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.keyword;
            case 1: return this.openParenToken;
            case 2: return this.type;
            case 3: return this.closeParenToken;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new CSharp.Syntax.DefaultExpressionSyntax(this, parent, position);

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor) => visitor.VisitDefaultExpression(this);

    public override void Accept(CSharpSyntaxVisitor visitor) => visitor.VisitDefaultExpression(this);

    public DefaultExpressionSyntax Update(SyntaxToken keyword, SyntaxToken openParenToken, TypeSyntax type, SyntaxToken closeParenToken)
    {
        if (keyword != this.Keyword || openParenToken != this.OpenParenToken || type != this.Type || closeParenToken != this.CloseParenToken)
        {
            var newNode = SyntaxFactory.DefaultExpression(keyword, openParenToken, type, closeParenToken);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
        => new DefaultExpressionSyntax(this.Kind, this.keyword, this.openParenToken, this.type, this.closeParenToken, diagnostics, GetAnnotations());

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
        => new DefaultExpressionSyntax(this.Kind, this.keyword, this.openParenToken, this.type, this.closeParenToken, GetDiagnostics(), annotations);

    internal DefaultExpressionSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 4;
      var keyword = (SyntaxToken)reader.ReadValue();
      if (keyword != null)
      {
         AdjustFlagsAndWidth(keyword);
         this.keyword = keyword;
      }
      var openParenToken = (SyntaxToken)reader.ReadValue();
      if (openParenToken != null)
      {
         AdjustFlagsAndWidth(openParenToken);
         this.openParenToken = openParenToken;
      }
      var type = (TypeSyntax)reader.ReadValue();
      if (type != null)
      {
         AdjustFlagsAndWidth(type);
         this.type = type;
      }
      var closeParenToken = (SyntaxToken)reader.ReadValue();
      if (closeParenToken != null)
      {
         AdjustFlagsAndWidth(closeParenToken);
         this.closeParenToken = closeParenToken;
      }
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.keyword);
      writer.WriteValue(this.openParenToken);
      writer.WriteValue(this.type);
      writer.WriteValue(this.closeParenToken);
    }

    static DefaultExpressionSyntax()
    {
       ObjectBinder.RegisterTypeReader(typeof(DefaultExpressionSyntax), r => new DefaultExpressionSyntax(r));
    }
  }

  /// <summary>Class which represents the syntax node for TypeOf expression.</summary>
  internal sealed partial class TypeOfExpressionSyntax : ExpressionSyntax
  {
    internal readonly SyntaxToken keyword;
    internal readonly SyntaxToken openParenToken;
    internal readonly TypeSyntax type;
    internal readonly SyntaxToken closeParenToken;

    internal TypeOfExpressionSyntax(SyntaxKind kind, SyntaxToken keyword, SyntaxToken openParenToken, TypeSyntax type, SyntaxToken closeParenToken, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 4;
        this.AdjustFlagsAndWidth(keyword);
        this.keyword = keyword;
        this.AdjustFlagsAndWidth(openParenToken);
        this.openParenToken = openParenToken;
        this.AdjustFlagsAndWidth(type);
        this.type = type;
        this.AdjustFlagsAndWidth(closeParenToken);
        this.closeParenToken = closeParenToken;
    }


    internal TypeOfExpressionSyntax(SyntaxKind kind, SyntaxToken keyword, SyntaxToken openParenToken, TypeSyntax type, SyntaxToken closeParenToken, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 4;
        this.AdjustFlagsAndWidth(keyword);
        this.keyword = keyword;
        this.AdjustFlagsAndWidth(openParenToken);
        this.openParenToken = openParenToken;
        this.AdjustFlagsAndWidth(type);
        this.type = type;
        this.AdjustFlagsAndWidth(closeParenToken);
        this.closeParenToken = closeParenToken;
    }


    internal TypeOfExpressionSyntax(SyntaxKind kind, SyntaxToken keyword, SyntaxToken openParenToken, TypeSyntax type, SyntaxToken closeParenToken)
        : base(kind)
    {
        this.SlotCount = 4;
        this.AdjustFlagsAndWidth(keyword);
        this.keyword = keyword;
        this.AdjustFlagsAndWidth(openParenToken);
        this.openParenToken = openParenToken;
        this.AdjustFlagsAndWidth(type);
        this.type = type;
        this.AdjustFlagsAndWidth(closeParenToken);
        this.closeParenToken = closeParenToken;
    }

    /// <summary>SyntaxToken representing the TypeOfKeyword.</summary>
    public SyntaxToken Keyword => this.keyword;
    /// <summary>SyntaxToken representing open parenthesis.</summary>
    public SyntaxToken OpenParenToken => this.openParenToken;
    /// <summary>The expression to return type of.</summary>
    public TypeSyntax Type => this.type;
    /// <summary>SyntaxToken representing close parenthesis.</summary>
    public SyntaxToken CloseParenToken => this.closeParenToken;

    internal override GreenNode? GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.keyword;
            case 1: return this.openParenToken;
            case 2: return this.type;
            case 3: return this.closeParenToken;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new CSharp.Syntax.TypeOfExpressionSyntax(this, parent, position);

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor) => visitor.VisitTypeOfExpression(this);

    public override void Accept(CSharpSyntaxVisitor visitor) => visitor.VisitTypeOfExpression(this);

    public TypeOfExpressionSyntax Update(SyntaxToken keyword, SyntaxToken openParenToken, TypeSyntax type, SyntaxToken closeParenToken)
    {
        if (keyword != this.Keyword || openParenToken != this.OpenParenToken || type != this.Type || closeParenToken != this.CloseParenToken)
        {
            var newNode = SyntaxFactory.TypeOfExpression(keyword, openParenToken, type, closeParenToken);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
        => new TypeOfExpressionSyntax(this.Kind, this.keyword, this.openParenToken, this.type, this.closeParenToken, diagnostics, GetAnnotations());

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
        => new TypeOfExpressionSyntax(this.Kind, this.keyword, this.openParenToken, this.type, this.closeParenToken, GetDiagnostics(), annotations);

    internal TypeOfExpressionSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 4;
      var keyword = (SyntaxToken)reader.ReadValue();
      if (keyword != null)
      {
         AdjustFlagsAndWidth(keyword);
         this.keyword = keyword;
      }
      var openParenToken = (SyntaxToken)reader.ReadValue();
      if (openParenToken != null)
      {
         AdjustFlagsAndWidth(openParenToken);
         this.openParenToken = openParenToken;
      }
      var type = (TypeSyntax)reader.ReadValue();
      if (type != null)
      {
         AdjustFlagsAndWidth(type);
         this.type = type;
      }
      var closeParenToken = (SyntaxToken)reader.ReadValue();
      if (closeParenToken != null)
      {
         AdjustFlagsAndWidth(closeParenToken);
         this.closeParenToken = closeParenToken;
      }
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.keyword);
      writer.WriteValue(this.openParenToken);
      writer.WriteValue(this.type);
      writer.WriteValue(this.closeParenToken);
    }

    static TypeOfExpressionSyntax()
    {
       ObjectBinder.RegisterTypeReader(typeof(TypeOfExpressionSyntax), r => new TypeOfExpressionSyntax(r));
    }
  }

  /// <summary>Class which represents the syntax node for SizeOf expression.</summary>
  internal sealed partial class SizeOfExpressionSyntax : ExpressionSyntax
  {
    internal readonly SyntaxToken keyword;
    internal readonly SyntaxToken openParenToken;
    internal readonly TypeSyntax type;
    internal readonly SyntaxToken closeParenToken;

    internal SizeOfExpressionSyntax(SyntaxKind kind, SyntaxToken keyword, SyntaxToken openParenToken, TypeSyntax type, SyntaxToken closeParenToken, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 4;
        this.AdjustFlagsAndWidth(keyword);
        this.keyword = keyword;
        this.AdjustFlagsAndWidth(openParenToken);
        this.openParenToken = openParenToken;
        this.AdjustFlagsAndWidth(type);
        this.type = type;
        this.AdjustFlagsAndWidth(closeParenToken);
        this.closeParenToken = closeParenToken;
    }


    internal SizeOfExpressionSyntax(SyntaxKind kind, SyntaxToken keyword, SyntaxToken openParenToken, TypeSyntax type, SyntaxToken closeParenToken, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 4;
        this.AdjustFlagsAndWidth(keyword);
        this.keyword = keyword;
        this.AdjustFlagsAndWidth(openParenToken);
        this.openParenToken = openParenToken;
        this.AdjustFlagsAndWidth(type);
        this.type = type;
        this.AdjustFlagsAndWidth(closeParenToken);
        this.closeParenToken = closeParenToken;
    }


    internal SizeOfExpressionSyntax(SyntaxKind kind, SyntaxToken keyword, SyntaxToken openParenToken, TypeSyntax type, SyntaxToken closeParenToken)
        : base(kind)
    {
        this.SlotCount = 4;
        this.AdjustFlagsAndWidth(keyword);
        this.keyword = keyword;
        this.AdjustFlagsAndWidth(openParenToken);
        this.openParenToken = openParenToken;
        this.AdjustFlagsAndWidth(type);
        this.type = type;
        this.AdjustFlagsAndWidth(closeParenToken);
        this.closeParenToken = closeParenToken;
    }

    /// <summary>SyntaxToken representing the SizeOfKeyword.</summary>
    public SyntaxToken Keyword => this.keyword;
    /// <summary>SyntaxToken representing open parenthesis.</summary>
    public SyntaxToken OpenParenToken => this.openParenToken;
    /// <summary>Argument of the primary function.</summary>
    public TypeSyntax Type => this.type;
    /// <summary>SyntaxToken representing close parenthesis.</summary>
    public SyntaxToken CloseParenToken => this.closeParenToken;

    internal override GreenNode? GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.keyword;
            case 1: return this.openParenToken;
            case 2: return this.type;
            case 3: return this.closeParenToken;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new CSharp.Syntax.SizeOfExpressionSyntax(this, parent, position);

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor) => visitor.VisitSizeOfExpression(this);

    public override void Accept(CSharpSyntaxVisitor visitor) => visitor.VisitSizeOfExpression(this);

    public SizeOfExpressionSyntax Update(SyntaxToken keyword, SyntaxToken openParenToken, TypeSyntax type, SyntaxToken closeParenToken)
    {
        if (keyword != this.Keyword || openParenToken != this.OpenParenToken || type != this.Type || closeParenToken != this.CloseParenToken)
        {
            var newNode = SyntaxFactory.SizeOfExpression(keyword, openParenToken, type, closeParenToken);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
        => new SizeOfExpressionSyntax(this.Kind, this.keyword, this.openParenToken, this.type, this.closeParenToken, diagnostics, GetAnnotations());

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
        => new SizeOfExpressionSyntax(this.Kind, this.keyword, this.openParenToken, this.type, this.closeParenToken, GetDiagnostics(), annotations);

    internal SizeOfExpressionSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 4;
      var keyword = (SyntaxToken)reader.ReadValue();
      if (keyword != null)
      {
         AdjustFlagsAndWidth(keyword);
         this.keyword = keyword;
      }
      var openParenToken = (SyntaxToken)reader.ReadValue();
      if (openParenToken != null)
      {
         AdjustFlagsAndWidth(openParenToken);
         this.openParenToken = openParenToken;
      }
      var type = (TypeSyntax)reader.ReadValue();
      if (type != null)
      {
         AdjustFlagsAndWidth(type);
         this.type = type;
      }
      var closeParenToken = (SyntaxToken)reader.ReadValue();
      if (closeParenToken != null)
      {
         AdjustFlagsAndWidth(closeParenToken);
         this.closeParenToken = closeParenToken;
      }
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.keyword);
      writer.WriteValue(this.openParenToken);
      writer.WriteValue(this.type);
      writer.WriteValue(this.closeParenToken);
    }

    static SizeOfExpressionSyntax()
    {
       ObjectBinder.RegisterTypeReader(typeof(SizeOfExpressionSyntax), r => new SizeOfExpressionSyntax(r));
    }
  }

  /// <summary>Class which represents the syntax node for invocation expression.</summary>
  internal sealed partial class InvocationExpressionSyntax : ExpressionSyntax
  {
    internal readonly ExpressionSyntax expression;
    internal readonly ArgumentListSyntax argumentList;

    internal InvocationExpressionSyntax(SyntaxKind kind, ExpressionSyntax expression, ArgumentListSyntax argumentList, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 2;
        this.AdjustFlagsAndWidth(expression);
        this.expression = expression;
        this.AdjustFlagsAndWidth(argumentList);
        this.argumentList = argumentList;
    }


    internal InvocationExpressionSyntax(SyntaxKind kind, ExpressionSyntax expression, ArgumentListSyntax argumentList, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 2;
        this.AdjustFlagsAndWidth(expression);
        this.expression = expression;
        this.AdjustFlagsAndWidth(argumentList);
        this.argumentList = argumentList;
    }


    internal InvocationExpressionSyntax(SyntaxKind kind, ExpressionSyntax expression, ArgumentListSyntax argumentList)
        : base(kind)
    {
        this.SlotCount = 2;
        this.AdjustFlagsAndWidth(expression);
        this.expression = expression;
        this.AdjustFlagsAndWidth(argumentList);
        this.argumentList = argumentList;
    }

    /// <summary>ExpressionSyntax node representing the expression part of the invocation.</summary>
    public ExpressionSyntax Expression => this.expression;
    /// <summary>ArgumentListSyntax node representing the list of arguments of the invocation expression.</summary>
    public ArgumentListSyntax ArgumentList => this.argumentList;

    internal override GreenNode? GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.expression;
            case 1: return this.argumentList;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new CSharp.Syntax.InvocationExpressionSyntax(this, parent, position);

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor) => visitor.VisitInvocationExpression(this);

    public override void Accept(CSharpSyntaxVisitor visitor) => visitor.VisitInvocationExpression(this);

    public InvocationExpressionSyntax Update(ExpressionSyntax expression, ArgumentListSyntax argumentList)
    {
        if (expression != this.Expression || argumentList != this.ArgumentList)
        {
            var newNode = SyntaxFactory.InvocationExpression(expression, argumentList);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
        => new InvocationExpressionSyntax(this.Kind, this.expression, this.argumentList, diagnostics, GetAnnotations());

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
        => new InvocationExpressionSyntax(this.Kind, this.expression, this.argumentList, GetDiagnostics(), annotations);

    internal InvocationExpressionSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 2;
      var expression = (ExpressionSyntax)reader.ReadValue();
      if (expression != null)
      {
         AdjustFlagsAndWidth(expression);
         this.expression = expression;
      }
      var argumentList = (ArgumentListSyntax)reader.ReadValue();
      if (argumentList != null)
      {
         AdjustFlagsAndWidth(argumentList);
         this.argumentList = argumentList;
      }
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.expression);
      writer.WriteValue(this.argumentList);
    }

    static InvocationExpressionSyntax()
    {
       ObjectBinder.RegisterTypeReader(typeof(InvocationExpressionSyntax), r => new InvocationExpressionSyntax(r));
    }
  }

  /// <summary>Class which represents the syntax node for element access expression.</summary>
  internal sealed partial class ElementAccessExpressionSyntax : ExpressionSyntax
  {
    internal readonly ExpressionSyntax expression;
    internal readonly BracketedArgumentListSyntax argumentList;

    internal ElementAccessExpressionSyntax(SyntaxKind kind, ExpressionSyntax expression, BracketedArgumentListSyntax argumentList, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 2;
        this.AdjustFlagsAndWidth(expression);
        this.expression = expression;
        this.AdjustFlagsAndWidth(argumentList);
        this.argumentList = argumentList;
    }


    internal ElementAccessExpressionSyntax(SyntaxKind kind, ExpressionSyntax expression, BracketedArgumentListSyntax argumentList, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 2;
        this.AdjustFlagsAndWidth(expression);
        this.expression = expression;
        this.AdjustFlagsAndWidth(argumentList);
        this.argumentList = argumentList;
    }


    internal ElementAccessExpressionSyntax(SyntaxKind kind, ExpressionSyntax expression, BracketedArgumentListSyntax argumentList)
        : base(kind)
    {
        this.SlotCount = 2;
        this.AdjustFlagsAndWidth(expression);
        this.expression = expression;
        this.AdjustFlagsAndWidth(argumentList);
        this.argumentList = argumentList;
    }

    /// <summary>ExpressionSyntax node representing the expression which is accessing the element.</summary>
    public ExpressionSyntax Expression => this.expression;
    /// <summary>BracketedArgumentListSyntax node representing the list of arguments of the element access expression.</summary>
    public BracketedArgumentListSyntax ArgumentList => this.argumentList;

    internal override GreenNode? GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.expression;
            case 1: return this.argumentList;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new CSharp.Syntax.ElementAccessExpressionSyntax(this, parent, position);

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor) => visitor.VisitElementAccessExpression(this);

    public override void Accept(CSharpSyntaxVisitor visitor) => visitor.VisitElementAccessExpression(this);

    public ElementAccessExpressionSyntax Update(ExpressionSyntax expression, BracketedArgumentListSyntax argumentList)
    {
        if (expression != this.Expression || argumentList != this.ArgumentList)
        {
            var newNode = SyntaxFactory.ElementAccessExpression(expression, argumentList);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
        => new ElementAccessExpressionSyntax(this.Kind, this.expression, this.argumentList, diagnostics, GetAnnotations());

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
        => new ElementAccessExpressionSyntax(this.Kind, this.expression, this.argumentList, GetDiagnostics(), annotations);

    internal ElementAccessExpressionSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 2;
      var expression = (ExpressionSyntax)reader.ReadValue();
      if (expression != null)
      {
         AdjustFlagsAndWidth(expression);
         this.expression = expression;
      }
      var argumentList = (BracketedArgumentListSyntax)reader.ReadValue();
      if (argumentList != null)
      {
         AdjustFlagsAndWidth(argumentList);
         this.argumentList = argumentList;
      }
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.expression);
      writer.WriteValue(this.argumentList);
    }

    static ElementAccessExpressionSyntax()
    {
       ObjectBinder.RegisterTypeReader(typeof(ElementAccessExpressionSyntax), r => new ElementAccessExpressionSyntax(r));
    }
  }

  /// <summary>Provides the base class from which the classes that represent argument list syntax nodes are derived. This is an abstract class.</summary>
  internal abstract partial class BaseArgumentListSyntax : CSharpSyntaxNode
  {
    internal BaseArgumentListSyntax(SyntaxKind kind, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
      : base(kind, diagnostics, annotations)
    {
    }
    internal BaseArgumentListSyntax(SyntaxKind kind)
      : base(kind)
    {
    }

    protected BaseArgumentListSyntax(ObjectReader reader)
       : base(reader)
    {
    }

    /// <summary>SeparatedSyntaxList of ArgumentSyntax nodes representing the list of arguments.</summary>
    public abstract Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<ArgumentSyntax> Arguments { get; }
  }

  /// <summary>Class which represents the syntax node for the list of arguments.</summary>
  internal sealed partial class ArgumentListSyntax : BaseArgumentListSyntax
  {
    internal readonly SyntaxToken openParenToken;
    internal readonly GreenNode? arguments;
    internal readonly SyntaxToken closeParenToken;

    internal ArgumentListSyntax(SyntaxKind kind, SyntaxToken openParenToken, GreenNode? arguments, SyntaxToken closeParenToken, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 3;
        this.AdjustFlagsAndWidth(openParenToken);
        this.openParenToken = openParenToken;
        if (arguments != null)
        {
            this.AdjustFlagsAndWidth(arguments);
            this.arguments = arguments;
        }
        this.AdjustFlagsAndWidth(closeParenToken);
        this.closeParenToken = closeParenToken;
    }


    internal ArgumentListSyntax(SyntaxKind kind, SyntaxToken openParenToken, GreenNode? arguments, SyntaxToken closeParenToken, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 3;
        this.AdjustFlagsAndWidth(openParenToken);
        this.openParenToken = openParenToken;
        if (arguments != null)
        {
            this.AdjustFlagsAndWidth(arguments);
            this.arguments = arguments;
        }
        this.AdjustFlagsAndWidth(closeParenToken);
        this.closeParenToken = closeParenToken;
    }


    internal ArgumentListSyntax(SyntaxKind kind, SyntaxToken openParenToken, GreenNode? arguments, SyntaxToken closeParenToken)
        : base(kind)
    {
        this.SlotCount = 3;
        this.AdjustFlagsAndWidth(openParenToken);
        this.openParenToken = openParenToken;
        if (arguments != null)
        {
            this.AdjustFlagsAndWidth(arguments);
            this.arguments = arguments;
        }
        this.AdjustFlagsAndWidth(closeParenToken);
        this.closeParenToken = closeParenToken;
    }

    /// <summary>SyntaxToken representing open parenthesis.</summary>
    public SyntaxToken OpenParenToken => this.openParenToken;
    /// <summary>SeparatedSyntaxList of ArgumentSyntax representing the list of arguments.</summary>
    public override Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<ArgumentSyntax> Arguments => new Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<ArgumentSyntax>(new Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<CSharpSyntaxNode>(this.arguments));
    /// <summary>SyntaxToken representing close parenthesis.</summary>
    public SyntaxToken CloseParenToken => this.closeParenToken;

    internal override GreenNode? GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.openParenToken;
            case 1: return this.arguments;
            case 2: return this.closeParenToken;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new CSharp.Syntax.ArgumentListSyntax(this, parent, position);

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor) => visitor.VisitArgumentList(this);

    public override void Accept(CSharpSyntaxVisitor visitor) => visitor.VisitArgumentList(this);

    public ArgumentListSyntax Update(SyntaxToken openParenToken, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<ArgumentSyntax> arguments, SyntaxToken closeParenToken)
    {
        if (openParenToken != this.OpenParenToken || arguments != this.Arguments || closeParenToken != this.CloseParenToken)
        {
            var newNode = SyntaxFactory.ArgumentList(openParenToken, arguments, closeParenToken);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
        => new ArgumentListSyntax(this.Kind, this.openParenToken, this.arguments, this.closeParenToken, diagnostics, GetAnnotations());

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
        => new ArgumentListSyntax(this.Kind, this.openParenToken, this.arguments, this.closeParenToken, GetDiagnostics(), annotations);

    internal ArgumentListSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 3;
      var openParenToken = (SyntaxToken)reader.ReadValue();
      if (openParenToken != null)
      {
         AdjustFlagsAndWidth(openParenToken);
         this.openParenToken = openParenToken;
      }
      var arguments = (GreenNode?)reader.ReadValue();
      if (arguments != null)
      {
         AdjustFlagsAndWidth(arguments);
         this.arguments = arguments;
      }
      var closeParenToken = (SyntaxToken)reader.ReadValue();
      if (closeParenToken != null)
      {
         AdjustFlagsAndWidth(closeParenToken);
         this.closeParenToken = closeParenToken;
      }
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.openParenToken);
      writer.WriteValue(this.arguments);
      writer.WriteValue(this.closeParenToken);
    }

    static ArgumentListSyntax()
    {
       ObjectBinder.RegisterTypeReader(typeof(ArgumentListSyntax), r => new ArgumentListSyntax(r));
    }
  }

  /// <summary>Class which represents the syntax node for bracketed argument list.</summary>
  internal sealed partial class BracketedArgumentListSyntax : BaseArgumentListSyntax
  {
    internal readonly SyntaxToken openBracketToken;
    internal readonly GreenNode? arguments;
    internal readonly SyntaxToken closeBracketToken;

    internal BracketedArgumentListSyntax(SyntaxKind kind, SyntaxToken openBracketToken, GreenNode? arguments, SyntaxToken closeBracketToken, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 3;
        this.AdjustFlagsAndWidth(openBracketToken);
        this.openBracketToken = openBracketToken;
        if (arguments != null)
        {
            this.AdjustFlagsAndWidth(arguments);
            this.arguments = arguments;
        }
        this.AdjustFlagsAndWidth(closeBracketToken);
        this.closeBracketToken = closeBracketToken;
    }


    internal BracketedArgumentListSyntax(SyntaxKind kind, SyntaxToken openBracketToken, GreenNode? arguments, SyntaxToken closeBracketToken, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 3;
        this.AdjustFlagsAndWidth(openBracketToken);
        this.openBracketToken = openBracketToken;
        if (arguments != null)
        {
            this.AdjustFlagsAndWidth(arguments);
            this.arguments = arguments;
        }
        this.AdjustFlagsAndWidth(closeBracketToken);
        this.closeBracketToken = closeBracketToken;
    }


    internal BracketedArgumentListSyntax(SyntaxKind kind, SyntaxToken openBracketToken, GreenNode? arguments, SyntaxToken closeBracketToken)
        : base(kind)
    {
        this.SlotCount = 3;
        this.AdjustFlagsAndWidth(openBracketToken);
        this.openBracketToken = openBracketToken;
        if (arguments != null)
        {
            this.AdjustFlagsAndWidth(arguments);
            this.arguments = arguments;
        }
        this.AdjustFlagsAndWidth(closeBracketToken);
        this.closeBracketToken = closeBracketToken;
    }

    /// <summary>SyntaxToken representing open bracket.</summary>
    public SyntaxToken OpenBracketToken => this.openBracketToken;
    /// <summary>SeparatedSyntaxList of ArgumentSyntax representing the list of arguments.</summary>
    public override Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<ArgumentSyntax> Arguments => new Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<ArgumentSyntax>(new Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<CSharpSyntaxNode>(this.arguments));
    /// <summary>SyntaxToken representing close bracket.</summary>
    public SyntaxToken CloseBracketToken => this.closeBracketToken;

    internal override GreenNode? GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.openBracketToken;
            case 1: return this.arguments;
            case 2: return this.closeBracketToken;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new CSharp.Syntax.BracketedArgumentListSyntax(this, parent, position);

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor) => visitor.VisitBracketedArgumentList(this);

    public override void Accept(CSharpSyntaxVisitor visitor) => visitor.VisitBracketedArgumentList(this);

    public BracketedArgumentListSyntax Update(SyntaxToken openBracketToken, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<ArgumentSyntax> arguments, SyntaxToken closeBracketToken)
    {
        if (openBracketToken != this.OpenBracketToken || arguments != this.Arguments || closeBracketToken != this.CloseBracketToken)
        {
            var newNode = SyntaxFactory.BracketedArgumentList(openBracketToken, arguments, closeBracketToken);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
        => new BracketedArgumentListSyntax(this.Kind, this.openBracketToken, this.arguments, this.closeBracketToken, diagnostics, GetAnnotations());

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
        => new BracketedArgumentListSyntax(this.Kind, this.openBracketToken, this.arguments, this.closeBracketToken, GetDiagnostics(), annotations);

    internal BracketedArgumentListSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 3;
      var openBracketToken = (SyntaxToken)reader.ReadValue();
      if (openBracketToken != null)
      {
         AdjustFlagsAndWidth(openBracketToken);
         this.openBracketToken = openBracketToken;
      }
      var arguments = (GreenNode?)reader.ReadValue();
      if (arguments != null)
      {
         AdjustFlagsAndWidth(arguments);
         this.arguments = arguments;
      }
      var closeBracketToken = (SyntaxToken)reader.ReadValue();
      if (closeBracketToken != null)
      {
         AdjustFlagsAndWidth(closeBracketToken);
         this.closeBracketToken = closeBracketToken;
      }
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.openBracketToken);
      writer.WriteValue(this.arguments);
      writer.WriteValue(this.closeBracketToken);
    }

    static BracketedArgumentListSyntax()
    {
       ObjectBinder.RegisterTypeReader(typeof(BracketedArgumentListSyntax), r => new BracketedArgumentListSyntax(r));
    }
  }

  /// <summary>Class which represents the syntax node for argument.</summary>
  internal sealed partial class ArgumentSyntax : CSharpSyntaxNode
  {
    internal readonly NameColonSyntax? nameColon;
    internal readonly SyntaxToken? refKindKeyword;
    internal readonly ExpressionSyntax expression;

    internal ArgumentSyntax(SyntaxKind kind, NameColonSyntax? nameColon, SyntaxToken? refKindKeyword, ExpressionSyntax expression, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 3;
        if (nameColon != null)
        {
            this.AdjustFlagsAndWidth(nameColon);
            this.nameColon = nameColon;
        }
        if (refKindKeyword != null)
        {
            this.AdjustFlagsAndWidth(refKindKeyword);
            this.refKindKeyword = refKindKeyword;
        }
        this.AdjustFlagsAndWidth(expression);
        this.expression = expression;
    }


    internal ArgumentSyntax(SyntaxKind kind, NameColonSyntax? nameColon, SyntaxToken? refKindKeyword, ExpressionSyntax expression, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 3;
        if (nameColon != null)
        {
            this.AdjustFlagsAndWidth(nameColon);
            this.nameColon = nameColon;
        }
        if (refKindKeyword != null)
        {
            this.AdjustFlagsAndWidth(refKindKeyword);
            this.refKindKeyword = refKindKeyword;
        }
        this.AdjustFlagsAndWidth(expression);
        this.expression = expression;
    }


    internal ArgumentSyntax(SyntaxKind kind, NameColonSyntax? nameColon, SyntaxToken? refKindKeyword, ExpressionSyntax expression)
        : base(kind)
    {
        this.SlotCount = 3;
        if (nameColon != null)
        {
            this.AdjustFlagsAndWidth(nameColon);
            this.nameColon = nameColon;
        }
        if (refKindKeyword != null)
        {
            this.AdjustFlagsAndWidth(refKindKeyword);
            this.refKindKeyword = refKindKeyword;
        }
        this.AdjustFlagsAndWidth(expression);
        this.expression = expression;
    }

    /// <summary>NameColonSyntax node representing the optional name arguments.</summary>
    public NameColonSyntax? NameColon => this.nameColon;
    /// <summary>SyntaxToken representing the optional ref or out keyword.</summary>
    public SyntaxToken? RefKindKeyword => this.refKindKeyword;
    /// <summary>ExpressionSyntax node representing the argument.</summary>
    public ExpressionSyntax Expression => this.expression;

    internal override GreenNode? GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.nameColon;
            case 1: return this.refKindKeyword;
            case 2: return this.expression;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new CSharp.Syntax.ArgumentSyntax(this, parent, position);

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor) => visitor.VisitArgument(this);

    public override void Accept(CSharpSyntaxVisitor visitor) => visitor.VisitArgument(this);

    public ArgumentSyntax Update(NameColonSyntax nameColon, SyntaxToken refKindKeyword, ExpressionSyntax expression)
    {
        if (nameColon != this.NameColon || refKindKeyword != this.RefKindKeyword || expression != this.Expression)
        {
            var newNode = SyntaxFactory.Argument(nameColon, refKindKeyword, expression);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
        => new ArgumentSyntax(this.Kind, this.nameColon, this.refKindKeyword, this.expression, diagnostics, GetAnnotations());

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
        => new ArgumentSyntax(this.Kind, this.nameColon, this.refKindKeyword, this.expression, GetDiagnostics(), annotations);

    internal ArgumentSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 3;
      var nameColon = (NameColonSyntax?)reader.ReadValue();
      if (nameColon != null)
      {
         AdjustFlagsAndWidth(nameColon);
         this.nameColon = nameColon;
      }
      var refKindKeyword = (SyntaxToken?)reader.ReadValue();
      if (refKindKeyword != null)
      {
         AdjustFlagsAndWidth(refKindKeyword);
         this.refKindKeyword = refKindKeyword;
      }
      var expression = (ExpressionSyntax)reader.ReadValue();
      if (expression != null)
      {
         AdjustFlagsAndWidth(expression);
         this.expression = expression;
      }
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.nameColon);
      writer.WriteValue(this.refKindKeyword);
      writer.WriteValue(this.expression);
    }

    static ArgumentSyntax()
    {
       ObjectBinder.RegisterTypeReader(typeof(ArgumentSyntax), r => new ArgumentSyntax(r));
    }
  }

  /// <summary>Class which represents the syntax node for name colon syntax.</summary>
  internal sealed partial class NameColonSyntax : CSharpSyntaxNode
  {
    internal readonly IdentifierNameSyntax name;
    internal readonly SyntaxToken colonToken;

    internal NameColonSyntax(SyntaxKind kind, IdentifierNameSyntax name, SyntaxToken colonToken, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 2;
        this.AdjustFlagsAndWidth(name);
        this.name = name;
        this.AdjustFlagsAndWidth(colonToken);
        this.colonToken = colonToken;
    }


    internal NameColonSyntax(SyntaxKind kind, IdentifierNameSyntax name, SyntaxToken colonToken, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 2;
        this.AdjustFlagsAndWidth(name);
        this.name = name;
        this.AdjustFlagsAndWidth(colonToken);
        this.colonToken = colonToken;
    }


    internal NameColonSyntax(SyntaxKind kind, IdentifierNameSyntax name, SyntaxToken colonToken)
        : base(kind)
    {
        this.SlotCount = 2;
        this.AdjustFlagsAndWidth(name);
        this.name = name;
        this.AdjustFlagsAndWidth(colonToken);
        this.colonToken = colonToken;
    }

    /// <summary>IdentifierNameSyntax representing the identifier name.</summary>
    public IdentifierNameSyntax Name => this.name;
    /// <summary>SyntaxToken representing colon.</summary>
    public SyntaxToken ColonToken => this.colonToken;

    internal override GreenNode? GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.name;
            case 1: return this.colonToken;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new CSharp.Syntax.NameColonSyntax(this, parent, position);

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor) => visitor.VisitNameColon(this);

    public override void Accept(CSharpSyntaxVisitor visitor) => visitor.VisitNameColon(this);

    public NameColonSyntax Update(IdentifierNameSyntax name, SyntaxToken colonToken)
    {
        if (name != this.Name || colonToken != this.ColonToken)
        {
            var newNode = SyntaxFactory.NameColon(name, colonToken);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
        => new NameColonSyntax(this.Kind, this.name, this.colonToken, diagnostics, GetAnnotations());

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
        => new NameColonSyntax(this.Kind, this.name, this.colonToken, GetDiagnostics(), annotations);

    internal NameColonSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 2;
      var name = (IdentifierNameSyntax)reader.ReadValue();
      if (name != null)
      {
         AdjustFlagsAndWidth(name);
         this.name = name;
      }
      var colonToken = (SyntaxToken)reader.ReadValue();
      if (colonToken != null)
      {
         AdjustFlagsAndWidth(colonToken);
         this.colonToken = colonToken;
      }
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.name);
      writer.WriteValue(this.colonToken);
    }

    static NameColonSyntax()
    {
       ObjectBinder.RegisterTypeReader(typeof(NameColonSyntax), r => new NameColonSyntax(r));
    }
  }

  /// <summary>Class which represents the syntax node for the variable declaration in an out var declaration or a deconstruction declaration.</summary>
  internal sealed partial class DeclarationExpressionSyntax : ExpressionSyntax
  {
    internal readonly TypeSyntax type;
    internal readonly VariableDesignationSyntax designation;

    internal DeclarationExpressionSyntax(SyntaxKind kind, TypeSyntax type, VariableDesignationSyntax designation, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 2;
        this.AdjustFlagsAndWidth(type);
        this.type = type;
        this.AdjustFlagsAndWidth(designation);
        this.designation = designation;
    }


    internal DeclarationExpressionSyntax(SyntaxKind kind, TypeSyntax type, VariableDesignationSyntax designation, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 2;
        this.AdjustFlagsAndWidth(type);
        this.type = type;
        this.AdjustFlagsAndWidth(designation);
        this.designation = designation;
    }


    internal DeclarationExpressionSyntax(SyntaxKind kind, TypeSyntax type, VariableDesignationSyntax designation)
        : base(kind)
    {
        this.SlotCount = 2;
        this.AdjustFlagsAndWidth(type);
        this.type = type;
        this.AdjustFlagsAndWidth(designation);
        this.designation = designation;
    }

    public TypeSyntax Type => this.type;
    /// <summary>Declaration representing the variable declared in an out parameter or deconstruction.</summary>
    public VariableDesignationSyntax Designation => this.designation;

    internal override GreenNode? GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.type;
            case 1: return this.designation;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new CSharp.Syntax.DeclarationExpressionSyntax(this, parent, position);

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor) => visitor.VisitDeclarationExpression(this);

    public override void Accept(CSharpSyntaxVisitor visitor) => visitor.VisitDeclarationExpression(this);

    public DeclarationExpressionSyntax Update(TypeSyntax type, VariableDesignationSyntax designation)
    {
        if (type != this.Type || designation != this.Designation)
        {
            var newNode = SyntaxFactory.DeclarationExpression(type, designation);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
        => new DeclarationExpressionSyntax(this.Kind, this.type, this.designation, diagnostics, GetAnnotations());

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
        => new DeclarationExpressionSyntax(this.Kind, this.type, this.designation, GetDiagnostics(), annotations);

    internal DeclarationExpressionSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 2;
      var type = (TypeSyntax)reader.ReadValue();
      if (type != null)
      {
         AdjustFlagsAndWidth(type);
         this.type = type;
      }
      var designation = (VariableDesignationSyntax)reader.ReadValue();
      if (designation != null)
      {
         AdjustFlagsAndWidth(designation);
         this.designation = designation;
      }
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.type);
      writer.WriteValue(this.designation);
    }

    static DeclarationExpressionSyntax()
    {
       ObjectBinder.RegisterTypeReader(typeof(DeclarationExpressionSyntax), r => new DeclarationExpressionSyntax(r));
    }
  }

  /// <summary>Class which represents the syntax node for cast expression.</summary>
  internal sealed partial class CastExpressionSyntax : ExpressionSyntax
  {
    internal readonly SyntaxToken openParenToken;
    internal readonly TypeSyntax type;
    internal readonly SyntaxToken closeParenToken;
    internal readonly ExpressionSyntax expression;

    internal CastExpressionSyntax(SyntaxKind kind, SyntaxToken openParenToken, TypeSyntax type, SyntaxToken closeParenToken, ExpressionSyntax expression, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 4;
        this.AdjustFlagsAndWidth(openParenToken);
        this.openParenToken = openParenToken;
        this.AdjustFlagsAndWidth(type);
        this.type = type;
        this.AdjustFlagsAndWidth(closeParenToken);
        this.closeParenToken = closeParenToken;
        this.AdjustFlagsAndWidth(expression);
        this.expression = expression;
    }


    internal CastExpressionSyntax(SyntaxKind kind, SyntaxToken openParenToken, TypeSyntax type, SyntaxToken closeParenToken, ExpressionSyntax expression, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 4;
        this.AdjustFlagsAndWidth(openParenToken);
        this.openParenToken = openParenToken;
        this.AdjustFlagsAndWidth(type);
        this.type = type;
        this.AdjustFlagsAndWidth(closeParenToken);
        this.closeParenToken = closeParenToken;
        this.AdjustFlagsAndWidth(expression);
        this.expression = expression;
    }


    internal CastExpressionSyntax(SyntaxKind kind, SyntaxToken openParenToken, TypeSyntax type, SyntaxToken closeParenToken, ExpressionSyntax expression)
        : base(kind)
    {
        this.SlotCount = 4;
        this.AdjustFlagsAndWidth(openParenToken);
        this.openParenToken = openParenToken;
        this.AdjustFlagsAndWidth(type);
        this.type = type;
        this.AdjustFlagsAndWidth(closeParenToken);
        this.closeParenToken = closeParenToken;
        this.AdjustFlagsAndWidth(expression);
        this.expression = expression;
    }

    /// <summary>SyntaxToken representing the open parenthesis.</summary>
    public SyntaxToken OpenParenToken => this.openParenToken;
    /// <summary>TypeSyntax node representing the type to which the expression is being cast.</summary>
    public TypeSyntax Type => this.type;
    /// <summary>SyntaxToken representing the close parenthesis.</summary>
    public SyntaxToken CloseParenToken => this.closeParenToken;
    /// <summary>ExpressionSyntax node representing the expression that is being casted.</summary>
    public ExpressionSyntax Expression => this.expression;

    internal override GreenNode? GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.openParenToken;
            case 1: return this.type;
            case 2: return this.closeParenToken;
            case 3: return this.expression;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new CSharp.Syntax.CastExpressionSyntax(this, parent, position);

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor) => visitor.VisitCastExpression(this);

    public override void Accept(CSharpSyntaxVisitor visitor) => visitor.VisitCastExpression(this);

    public CastExpressionSyntax Update(SyntaxToken openParenToken, TypeSyntax type, SyntaxToken closeParenToken, ExpressionSyntax expression)
    {
        if (openParenToken != this.OpenParenToken || type != this.Type || closeParenToken != this.CloseParenToken || expression != this.Expression)
        {
            var newNode = SyntaxFactory.CastExpression(openParenToken, type, closeParenToken, expression);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
        => new CastExpressionSyntax(this.Kind, this.openParenToken, this.type, this.closeParenToken, this.expression, diagnostics, GetAnnotations());

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
        => new CastExpressionSyntax(this.Kind, this.openParenToken, this.type, this.closeParenToken, this.expression, GetDiagnostics(), annotations);

    internal CastExpressionSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 4;
      var openParenToken = (SyntaxToken)reader.ReadValue();
      if (openParenToken != null)
      {
         AdjustFlagsAndWidth(openParenToken);
         this.openParenToken = openParenToken;
      }
      var type = (TypeSyntax)reader.ReadValue();
      if (type != null)
      {
         AdjustFlagsAndWidth(type);
         this.type = type;
      }
      var closeParenToken = (SyntaxToken)reader.ReadValue();
      if (closeParenToken != null)
      {
         AdjustFlagsAndWidth(closeParenToken);
         this.closeParenToken = closeParenToken;
      }
      var expression = (ExpressionSyntax)reader.ReadValue();
      if (expression != null)
      {
         AdjustFlagsAndWidth(expression);
         this.expression = expression;
      }
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.openParenToken);
      writer.WriteValue(this.type);
      writer.WriteValue(this.closeParenToken);
      writer.WriteValue(this.expression);
    }

    static CastExpressionSyntax()
    {
       ObjectBinder.RegisterTypeReader(typeof(CastExpressionSyntax), r => new CastExpressionSyntax(r));
    }
  }

  /// <summary>Provides the base class from which the classes that represent anonymous function expressions are derived.</summary>
  internal abstract partial class AnonymousFunctionExpressionSyntax : ExpressionSyntax
  {
    internal AnonymousFunctionExpressionSyntax(SyntaxKind kind, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
      : base(kind, diagnostics, annotations)
    {
    }
    internal AnonymousFunctionExpressionSyntax(SyntaxKind kind)
      : base(kind)
    {
    }

    protected AnonymousFunctionExpressionSyntax(ObjectReader reader)
       : base(reader)
    {
    }

    /// <summary>Gets the "async" token.</summary>
    public abstract SyntaxToken? AsyncKeyword { get; }

    /// <summary>ExpressionSyntax or BlockSyntax representing the body of the lambda expression.</summary>
    public abstract CSharpSyntaxNode Body { get; }
  }

  /// <summary>Class which represents the syntax node for anonymous method expression.</summary>
  internal sealed partial class AnonymousMethodExpressionSyntax : AnonymousFunctionExpressionSyntax
  {
    internal readonly SyntaxToken? asyncKeyword;
    internal readonly SyntaxToken delegateKeyword;
    internal readonly ParameterListSyntax? parameterList;
    internal readonly CSharpSyntaxNode body;

    internal AnonymousMethodExpressionSyntax(SyntaxKind kind, SyntaxToken? asyncKeyword, SyntaxToken delegateKeyword, ParameterListSyntax? parameterList, CSharpSyntaxNode body, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 4;
        if (asyncKeyword != null)
        {
            this.AdjustFlagsAndWidth(asyncKeyword);
            this.asyncKeyword = asyncKeyword;
        }
        this.AdjustFlagsAndWidth(delegateKeyword);
        this.delegateKeyword = delegateKeyword;
        if (parameterList != null)
        {
            this.AdjustFlagsAndWidth(parameterList);
            this.parameterList = parameterList;
        }
        this.AdjustFlagsAndWidth(body);
        this.body = body;
    }


    internal AnonymousMethodExpressionSyntax(SyntaxKind kind, SyntaxToken? asyncKeyword, SyntaxToken delegateKeyword, ParameterListSyntax? parameterList, CSharpSyntaxNode body, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 4;
        if (asyncKeyword != null)
        {
            this.AdjustFlagsAndWidth(asyncKeyword);
            this.asyncKeyword = asyncKeyword;
        }
        this.AdjustFlagsAndWidth(delegateKeyword);
        this.delegateKeyword = delegateKeyword;
        if (parameterList != null)
        {
            this.AdjustFlagsAndWidth(parameterList);
            this.parameterList = parameterList;
        }
        this.AdjustFlagsAndWidth(body);
        this.body = body;
    }


    internal AnonymousMethodExpressionSyntax(SyntaxKind kind, SyntaxToken? asyncKeyword, SyntaxToken delegateKeyword, ParameterListSyntax? parameterList, CSharpSyntaxNode body)
        : base(kind)
    {
        this.SlotCount = 4;
        if (asyncKeyword != null)
        {
            this.AdjustFlagsAndWidth(asyncKeyword);
            this.asyncKeyword = asyncKeyword;
        }
        this.AdjustFlagsAndWidth(delegateKeyword);
        this.delegateKeyword = delegateKeyword;
        if (parameterList != null)
        {
            this.AdjustFlagsAndWidth(parameterList);
            this.parameterList = parameterList;
        }
        this.AdjustFlagsAndWidth(body);
        this.body = body;
    }

    /// <summary>Gets the "async" token.</summary>
    public override SyntaxToken? AsyncKeyword => this.asyncKeyword;
    /// <summary>SyntaxToken representing the delegate keyword.</summary>
    public SyntaxToken DelegateKeyword => this.delegateKeyword;
    /// <summary>List of parameters of the anonymous method expression, or null if there no parameters are specified.</summary>
    public ParameterListSyntax? ParameterList => this.parameterList;
    /// <summary>BlockSyntax node representing the body of the anonymous method.</summary>
    public override CSharpSyntaxNode Body => this.body;

    internal override GreenNode? GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.asyncKeyword;
            case 1: return this.delegateKeyword;
            case 2: return this.parameterList;
            case 3: return this.body;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new CSharp.Syntax.AnonymousMethodExpressionSyntax(this, parent, position);

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor) => visitor.VisitAnonymousMethodExpression(this);

    public override void Accept(CSharpSyntaxVisitor visitor) => visitor.VisitAnonymousMethodExpression(this);

    public AnonymousMethodExpressionSyntax Update(SyntaxToken asyncKeyword, SyntaxToken delegateKeyword, ParameterListSyntax parameterList, CSharpSyntaxNode body)
    {
        if (asyncKeyword != this.AsyncKeyword || delegateKeyword != this.DelegateKeyword || parameterList != this.ParameterList || body != this.Body)
        {
            var newNode = SyntaxFactory.AnonymousMethodExpression(asyncKeyword, delegateKeyword, parameterList, body);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
        => new AnonymousMethodExpressionSyntax(this.Kind, this.asyncKeyword, this.delegateKeyword, this.parameterList, this.body, diagnostics, GetAnnotations());

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
        => new AnonymousMethodExpressionSyntax(this.Kind, this.asyncKeyword, this.delegateKeyword, this.parameterList, this.body, GetDiagnostics(), annotations);

    internal AnonymousMethodExpressionSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 4;
      var asyncKeyword = (SyntaxToken?)reader.ReadValue();
      if (asyncKeyword != null)
      {
         AdjustFlagsAndWidth(asyncKeyword);
         this.asyncKeyword = asyncKeyword;
      }
      var delegateKeyword = (SyntaxToken)reader.ReadValue();
      if (delegateKeyword != null)
      {
         AdjustFlagsAndWidth(delegateKeyword);
         this.delegateKeyword = delegateKeyword;
      }
      var parameterList = (ParameterListSyntax?)reader.ReadValue();
      if (parameterList != null)
      {
         AdjustFlagsAndWidth(parameterList);
         this.parameterList = parameterList;
      }
      var body = (CSharpSyntaxNode)reader.ReadValue();
      if (body != null)
      {
         AdjustFlagsAndWidth(body);
         this.body = body;
      }
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.asyncKeyword);
      writer.WriteValue(this.delegateKeyword);
      writer.WriteValue(this.parameterList);
      writer.WriteValue(this.body);
    }

    static AnonymousMethodExpressionSyntax()
    {
       ObjectBinder.RegisterTypeReader(typeof(AnonymousMethodExpressionSyntax), r => new AnonymousMethodExpressionSyntax(r));
    }
  }

  /// <summary>Provides the base class from which the classes that represent lambda expressions are derived.</summary>
  internal abstract partial class LambdaExpressionSyntax : AnonymousFunctionExpressionSyntax
  {
    internal LambdaExpressionSyntax(SyntaxKind kind, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
      : base(kind, diagnostics, annotations)
    {
    }
    internal LambdaExpressionSyntax(SyntaxKind kind)
      : base(kind)
    {
    }

    protected LambdaExpressionSyntax(ObjectReader reader)
       : base(reader)
    {
    }

    /// <summary>SyntaxToken representing equals greater than.</summary>
    public abstract SyntaxToken ArrowToken { get; }
  }

  /// <summary>Class which represents the syntax node for a simple lambda expression.</summary>
  internal sealed partial class SimpleLambdaExpressionSyntax : LambdaExpressionSyntax
  {
    internal readonly SyntaxToken? asyncKeyword;
    internal readonly ParameterSyntax parameter;
    internal readonly SyntaxToken arrowToken;
    internal readonly CSharpSyntaxNode body;

    internal SimpleLambdaExpressionSyntax(SyntaxKind kind, SyntaxToken? asyncKeyword, ParameterSyntax parameter, SyntaxToken arrowToken, CSharpSyntaxNode body, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 4;
        if (asyncKeyword != null)
        {
            this.AdjustFlagsAndWidth(asyncKeyword);
            this.asyncKeyword = asyncKeyword;
        }
        this.AdjustFlagsAndWidth(parameter);
        this.parameter = parameter;
        this.AdjustFlagsAndWidth(arrowToken);
        this.arrowToken = arrowToken;
        this.AdjustFlagsAndWidth(body);
        this.body = body;
    }


    internal SimpleLambdaExpressionSyntax(SyntaxKind kind, SyntaxToken? asyncKeyword, ParameterSyntax parameter, SyntaxToken arrowToken, CSharpSyntaxNode body, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 4;
        if (asyncKeyword != null)
        {
            this.AdjustFlagsAndWidth(asyncKeyword);
            this.asyncKeyword = asyncKeyword;
        }
        this.AdjustFlagsAndWidth(parameter);
        this.parameter = parameter;
        this.AdjustFlagsAndWidth(arrowToken);
        this.arrowToken = arrowToken;
        this.AdjustFlagsAndWidth(body);
        this.body = body;
    }


    internal SimpleLambdaExpressionSyntax(SyntaxKind kind, SyntaxToken? asyncKeyword, ParameterSyntax parameter, SyntaxToken arrowToken, CSharpSyntaxNode body)
        : base(kind)
    {
        this.SlotCount = 4;
        if (asyncKeyword != null)
        {
            this.AdjustFlagsAndWidth(asyncKeyword);
            this.asyncKeyword = asyncKeyword;
        }
        this.AdjustFlagsAndWidth(parameter);
        this.parameter = parameter;
        this.AdjustFlagsAndWidth(arrowToken);
        this.arrowToken = arrowToken;
        this.AdjustFlagsAndWidth(body);
        this.body = body;
    }

    /// <summary>Gets the "async" token.</summary>
    public override SyntaxToken? AsyncKeyword => this.asyncKeyword;
    /// <summary>ParameterSyntax node representing the parameter of the lambda expression.</summary>
    public ParameterSyntax Parameter => this.parameter;
    /// <summary>SyntaxToken representing equals greater than.</summary>
    public override SyntaxToken ArrowToken => this.arrowToken;
    /// <summary>SyntaxNode representing the body of the lambda expression.</summary>
    public override CSharpSyntaxNode Body => this.body;

    internal override GreenNode? GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.asyncKeyword;
            case 1: return this.parameter;
            case 2: return this.arrowToken;
            case 3: return this.body;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new CSharp.Syntax.SimpleLambdaExpressionSyntax(this, parent, position);

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor) => visitor.VisitSimpleLambdaExpression(this);

    public override void Accept(CSharpSyntaxVisitor visitor) => visitor.VisitSimpleLambdaExpression(this);

    public SimpleLambdaExpressionSyntax Update(SyntaxToken asyncKeyword, ParameterSyntax parameter, SyntaxToken arrowToken, CSharpSyntaxNode body)
    {
        if (asyncKeyword != this.AsyncKeyword || parameter != this.Parameter || arrowToken != this.ArrowToken || body != this.Body)
        {
            var newNode = SyntaxFactory.SimpleLambdaExpression(asyncKeyword, parameter, arrowToken, body);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
        => new SimpleLambdaExpressionSyntax(this.Kind, this.asyncKeyword, this.parameter, this.arrowToken, this.body, diagnostics, GetAnnotations());

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
        => new SimpleLambdaExpressionSyntax(this.Kind, this.asyncKeyword, this.parameter, this.arrowToken, this.body, GetDiagnostics(), annotations);

    internal SimpleLambdaExpressionSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 4;
      var asyncKeyword = (SyntaxToken?)reader.ReadValue();
      if (asyncKeyword != null)
      {
         AdjustFlagsAndWidth(asyncKeyword);
         this.asyncKeyword = asyncKeyword;
      }
      var parameter = (ParameterSyntax)reader.ReadValue();
      if (parameter != null)
      {
         AdjustFlagsAndWidth(parameter);
         this.parameter = parameter;
      }
      var arrowToken = (SyntaxToken)reader.ReadValue();
      if (arrowToken != null)
      {
         AdjustFlagsAndWidth(arrowToken);
         this.arrowToken = arrowToken;
      }
      var body = (CSharpSyntaxNode)reader.ReadValue();
      if (body != null)
      {
         AdjustFlagsAndWidth(body);
         this.body = body;
      }
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.asyncKeyword);
      writer.WriteValue(this.parameter);
      writer.WriteValue(this.arrowToken);
      writer.WriteValue(this.body);
    }

    static SimpleLambdaExpressionSyntax()
    {
       ObjectBinder.RegisterTypeReader(typeof(SimpleLambdaExpressionSyntax), r => new SimpleLambdaExpressionSyntax(r));
    }
  }

  internal sealed partial class RefExpressionSyntax : ExpressionSyntax
  {
    internal readonly SyntaxToken refKeyword;
    internal readonly ExpressionSyntax expression;

    internal RefExpressionSyntax(SyntaxKind kind, SyntaxToken refKeyword, ExpressionSyntax expression, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 2;
        this.AdjustFlagsAndWidth(refKeyword);
        this.refKeyword = refKeyword;
        this.AdjustFlagsAndWidth(expression);
        this.expression = expression;
    }


    internal RefExpressionSyntax(SyntaxKind kind, SyntaxToken refKeyword, ExpressionSyntax expression, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 2;
        this.AdjustFlagsAndWidth(refKeyword);
        this.refKeyword = refKeyword;
        this.AdjustFlagsAndWidth(expression);
        this.expression = expression;
    }


    internal RefExpressionSyntax(SyntaxKind kind, SyntaxToken refKeyword, ExpressionSyntax expression)
        : base(kind)
    {
        this.SlotCount = 2;
        this.AdjustFlagsAndWidth(refKeyword);
        this.refKeyword = refKeyword;
        this.AdjustFlagsAndWidth(expression);
        this.expression = expression;
    }

    public SyntaxToken RefKeyword => this.refKeyword;
    public ExpressionSyntax Expression => this.expression;

    internal override GreenNode? GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.refKeyword;
            case 1: return this.expression;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new CSharp.Syntax.RefExpressionSyntax(this, parent, position);

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor) => visitor.VisitRefExpression(this);

    public override void Accept(CSharpSyntaxVisitor visitor) => visitor.VisitRefExpression(this);

    public RefExpressionSyntax Update(SyntaxToken refKeyword, ExpressionSyntax expression)
    {
        if (refKeyword != this.RefKeyword || expression != this.Expression)
        {
            var newNode = SyntaxFactory.RefExpression(refKeyword, expression);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
        => new RefExpressionSyntax(this.Kind, this.refKeyword, this.expression, diagnostics, GetAnnotations());

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
        => new RefExpressionSyntax(this.Kind, this.refKeyword, this.expression, GetDiagnostics(), annotations);

    internal RefExpressionSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 2;
      var refKeyword = (SyntaxToken)reader.ReadValue();
      if (refKeyword != null)
      {
         AdjustFlagsAndWidth(refKeyword);
         this.refKeyword = refKeyword;
      }
      var expression = (ExpressionSyntax)reader.ReadValue();
      if (expression != null)
      {
         AdjustFlagsAndWidth(expression);
         this.expression = expression;
      }
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.refKeyword);
      writer.WriteValue(this.expression);
    }

    static RefExpressionSyntax()
    {
       ObjectBinder.RegisterTypeReader(typeof(RefExpressionSyntax), r => new RefExpressionSyntax(r));
    }
  }

  /// <summary>Class which represents the syntax node for parenthesized lambda expression.</summary>
  internal sealed partial class ParenthesizedLambdaExpressionSyntax : LambdaExpressionSyntax
  {
    internal readonly SyntaxToken? asyncKeyword;
    internal readonly ParameterListSyntax parameterList;
    internal readonly SyntaxToken arrowToken;
    internal readonly CSharpSyntaxNode body;

    internal ParenthesizedLambdaExpressionSyntax(SyntaxKind kind, SyntaxToken? asyncKeyword, ParameterListSyntax parameterList, SyntaxToken arrowToken, CSharpSyntaxNode body, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 4;
        if (asyncKeyword != null)
        {
            this.AdjustFlagsAndWidth(asyncKeyword);
            this.asyncKeyword = asyncKeyword;
        }
        this.AdjustFlagsAndWidth(parameterList);
        this.parameterList = parameterList;
        this.AdjustFlagsAndWidth(arrowToken);
        this.arrowToken = arrowToken;
        this.AdjustFlagsAndWidth(body);
        this.body = body;
    }


    internal ParenthesizedLambdaExpressionSyntax(SyntaxKind kind, SyntaxToken? asyncKeyword, ParameterListSyntax parameterList, SyntaxToken arrowToken, CSharpSyntaxNode body, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 4;
        if (asyncKeyword != null)
        {
            this.AdjustFlagsAndWidth(asyncKeyword);
            this.asyncKeyword = asyncKeyword;
        }
        this.AdjustFlagsAndWidth(parameterList);
        this.parameterList = parameterList;
        this.AdjustFlagsAndWidth(arrowToken);
        this.arrowToken = arrowToken;
        this.AdjustFlagsAndWidth(body);
        this.body = body;
    }


    internal ParenthesizedLambdaExpressionSyntax(SyntaxKind kind, SyntaxToken? asyncKeyword, ParameterListSyntax parameterList, SyntaxToken arrowToken, CSharpSyntaxNode body)
        : base(kind)
    {
        this.SlotCount = 4;
        if (asyncKeyword != null)
        {
            this.AdjustFlagsAndWidth(asyncKeyword);
            this.asyncKeyword = asyncKeyword;
        }
        this.AdjustFlagsAndWidth(parameterList);
        this.parameterList = parameterList;
        this.AdjustFlagsAndWidth(arrowToken);
        this.arrowToken = arrowToken;
        this.AdjustFlagsAndWidth(body);
        this.body = body;
    }

    /// <summary>Gets the "async" token.</summary>
    public override SyntaxToken? AsyncKeyword => this.asyncKeyword;
    /// <summary>ParameterListSyntax node representing the list of parameters for the lambda expression.</summary>
    public ParameterListSyntax ParameterList => this.parameterList;
    /// <summary>SyntaxToken representing equals greater than.</summary>
    public override SyntaxToken ArrowToken => this.arrowToken;
    /// <summary>SyntaxNode representing the body of the lambda expression.</summary>
    public override CSharpSyntaxNode Body => this.body;

    internal override GreenNode? GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.asyncKeyword;
            case 1: return this.parameterList;
            case 2: return this.arrowToken;
            case 3: return this.body;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new CSharp.Syntax.ParenthesizedLambdaExpressionSyntax(this, parent, position);

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor) => visitor.VisitParenthesizedLambdaExpression(this);

    public override void Accept(CSharpSyntaxVisitor visitor) => visitor.VisitParenthesizedLambdaExpression(this);

    public ParenthesizedLambdaExpressionSyntax Update(SyntaxToken asyncKeyword, ParameterListSyntax parameterList, SyntaxToken arrowToken, CSharpSyntaxNode body)
    {
        if (asyncKeyword != this.AsyncKeyword || parameterList != this.ParameterList || arrowToken != this.ArrowToken || body != this.Body)
        {
            var newNode = SyntaxFactory.ParenthesizedLambdaExpression(asyncKeyword, parameterList, arrowToken, body);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
        => new ParenthesizedLambdaExpressionSyntax(this.Kind, this.asyncKeyword, this.parameterList, this.arrowToken, this.body, diagnostics, GetAnnotations());

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
        => new ParenthesizedLambdaExpressionSyntax(this.Kind, this.asyncKeyword, this.parameterList, this.arrowToken, this.body, GetDiagnostics(), annotations);

    internal ParenthesizedLambdaExpressionSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 4;
      var asyncKeyword = (SyntaxToken?)reader.ReadValue();
      if (asyncKeyword != null)
      {
         AdjustFlagsAndWidth(asyncKeyword);
         this.asyncKeyword = asyncKeyword;
      }
      var parameterList = (ParameterListSyntax)reader.ReadValue();
      if (parameterList != null)
      {
         AdjustFlagsAndWidth(parameterList);
         this.parameterList = parameterList;
      }
      var arrowToken = (SyntaxToken)reader.ReadValue();
      if (arrowToken != null)
      {
         AdjustFlagsAndWidth(arrowToken);
         this.arrowToken = arrowToken;
      }
      var body = (CSharpSyntaxNode)reader.ReadValue();
      if (body != null)
      {
         AdjustFlagsAndWidth(body);
         this.body = body;
      }
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.asyncKeyword);
      writer.WriteValue(this.parameterList);
      writer.WriteValue(this.arrowToken);
      writer.WriteValue(this.body);
    }

    static ParenthesizedLambdaExpressionSyntax()
    {
       ObjectBinder.RegisterTypeReader(typeof(ParenthesizedLambdaExpressionSyntax), r => new ParenthesizedLambdaExpressionSyntax(r));
    }
  }

  /// <summary>Class which represents the syntax node for initializer expression.</summary>
  internal sealed partial class InitializerExpressionSyntax : ExpressionSyntax
  {
    internal readonly SyntaxToken openBraceToken;
    internal readonly GreenNode? expressions;
    internal readonly SyntaxToken closeBraceToken;

    internal InitializerExpressionSyntax(SyntaxKind kind, SyntaxToken openBraceToken, GreenNode? expressions, SyntaxToken closeBraceToken, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 3;
        this.AdjustFlagsAndWidth(openBraceToken);
        this.openBraceToken = openBraceToken;
        if (expressions != null)
        {
            this.AdjustFlagsAndWidth(expressions);
            this.expressions = expressions;
        }
        this.AdjustFlagsAndWidth(closeBraceToken);
        this.closeBraceToken = closeBraceToken;
    }


    internal InitializerExpressionSyntax(SyntaxKind kind, SyntaxToken openBraceToken, GreenNode? expressions, SyntaxToken closeBraceToken, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 3;
        this.AdjustFlagsAndWidth(openBraceToken);
        this.openBraceToken = openBraceToken;
        if (expressions != null)
        {
            this.AdjustFlagsAndWidth(expressions);
            this.expressions = expressions;
        }
        this.AdjustFlagsAndWidth(closeBraceToken);
        this.closeBraceToken = closeBraceToken;
    }


    internal InitializerExpressionSyntax(SyntaxKind kind, SyntaxToken openBraceToken, GreenNode? expressions, SyntaxToken closeBraceToken)
        : base(kind)
    {
        this.SlotCount = 3;
        this.AdjustFlagsAndWidth(openBraceToken);
        this.openBraceToken = openBraceToken;
        if (expressions != null)
        {
            this.AdjustFlagsAndWidth(expressions);
            this.expressions = expressions;
        }
        this.AdjustFlagsAndWidth(closeBraceToken);
        this.closeBraceToken = closeBraceToken;
    }

    /// <summary>SyntaxToken representing the open brace.</summary>
    public SyntaxToken OpenBraceToken => this.openBraceToken;
    /// <summary>SeparatedSyntaxList of ExpressionSyntax representing the list of expressions in the initializer expression.</summary>
    public Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<ExpressionSyntax> Expressions => new Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<ExpressionSyntax>(new Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<CSharpSyntaxNode>(this.expressions));
    /// <summary>SyntaxToken representing the close brace.</summary>
    public SyntaxToken CloseBraceToken => this.closeBraceToken;

    internal override GreenNode? GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.openBraceToken;
            case 1: return this.expressions;
            case 2: return this.closeBraceToken;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new CSharp.Syntax.InitializerExpressionSyntax(this, parent, position);

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor) => visitor.VisitInitializerExpression(this);

    public override void Accept(CSharpSyntaxVisitor visitor) => visitor.VisitInitializerExpression(this);

    public InitializerExpressionSyntax Update(SyntaxToken openBraceToken, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<ExpressionSyntax> expressions, SyntaxToken closeBraceToken)
    {
        if (openBraceToken != this.OpenBraceToken || expressions != this.Expressions || closeBraceToken != this.CloseBraceToken)
        {
            var newNode = SyntaxFactory.InitializerExpression(this.Kind, openBraceToken, expressions, closeBraceToken);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
        => new InitializerExpressionSyntax(this.Kind, this.openBraceToken, this.expressions, this.closeBraceToken, diagnostics, GetAnnotations());

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
        => new InitializerExpressionSyntax(this.Kind, this.openBraceToken, this.expressions, this.closeBraceToken, GetDiagnostics(), annotations);

    internal InitializerExpressionSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 3;
      var openBraceToken = (SyntaxToken)reader.ReadValue();
      if (openBraceToken != null)
      {
         AdjustFlagsAndWidth(openBraceToken);
         this.openBraceToken = openBraceToken;
      }
      var expressions = (GreenNode?)reader.ReadValue();
      if (expressions != null)
      {
         AdjustFlagsAndWidth(expressions);
         this.expressions = expressions;
      }
      var closeBraceToken = (SyntaxToken)reader.ReadValue();
      if (closeBraceToken != null)
      {
         AdjustFlagsAndWidth(closeBraceToken);
         this.closeBraceToken = closeBraceToken;
      }
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.openBraceToken);
      writer.WriteValue(this.expressions);
      writer.WriteValue(this.closeBraceToken);
    }

    static InitializerExpressionSyntax()
    {
       ObjectBinder.RegisterTypeReader(typeof(InitializerExpressionSyntax), r => new InitializerExpressionSyntax(r));
    }
  }

  /// <summary>Class which represents the syntax node for object creation expression.</summary>
  internal sealed partial class ObjectCreationExpressionSyntax : ExpressionSyntax
  {
    internal readonly SyntaxToken newKeyword;
    internal readonly TypeSyntax type;
    internal readonly ArgumentListSyntax? argumentList;
    internal readonly InitializerExpressionSyntax? initializer;

    internal ObjectCreationExpressionSyntax(SyntaxKind kind, SyntaxToken newKeyword, TypeSyntax type, ArgumentListSyntax? argumentList, InitializerExpressionSyntax? initializer, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 4;
        this.AdjustFlagsAndWidth(newKeyword);
        this.newKeyword = newKeyword;
        this.AdjustFlagsAndWidth(type);
        this.type = type;
        if (argumentList != null)
        {
            this.AdjustFlagsAndWidth(argumentList);
            this.argumentList = argumentList;
        }
        if (initializer != null)
        {
            this.AdjustFlagsAndWidth(initializer);
            this.initializer = initializer;
        }
    }


    internal ObjectCreationExpressionSyntax(SyntaxKind kind, SyntaxToken newKeyword, TypeSyntax type, ArgumentListSyntax? argumentList, InitializerExpressionSyntax? initializer, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 4;
        this.AdjustFlagsAndWidth(newKeyword);
        this.newKeyword = newKeyword;
        this.AdjustFlagsAndWidth(type);
        this.type = type;
        if (argumentList != null)
        {
            this.AdjustFlagsAndWidth(argumentList);
            this.argumentList = argumentList;
        }
        if (initializer != null)
        {
            this.AdjustFlagsAndWidth(initializer);
            this.initializer = initializer;
        }
    }


    internal ObjectCreationExpressionSyntax(SyntaxKind kind, SyntaxToken newKeyword, TypeSyntax type, ArgumentListSyntax? argumentList, InitializerExpressionSyntax? initializer)
        : base(kind)
    {
        this.SlotCount = 4;
        this.AdjustFlagsAndWidth(newKeyword);
        this.newKeyword = newKeyword;
        this.AdjustFlagsAndWidth(type);
        this.type = type;
        if (argumentList != null)
        {
            this.AdjustFlagsAndWidth(argumentList);
            this.argumentList = argumentList;
        }
        if (initializer != null)
        {
            this.AdjustFlagsAndWidth(initializer);
            this.initializer = initializer;
        }
    }

    /// <summary>SyntaxToken representing the new keyword.</summary>
    public SyntaxToken NewKeyword => this.newKeyword;
    /// <summary>TypeSyntax representing the type of the object being created.</summary>
    public TypeSyntax Type => this.type;
    /// <summary>ArgumentListSyntax representing the list of arguments passed as part of the object creation expression.</summary>
    public ArgumentListSyntax? ArgumentList => this.argumentList;
    /// <summary>InitializerExpressionSyntax representing the initializer expression for the object being created.</summary>
    public InitializerExpressionSyntax? Initializer => this.initializer;

    internal override GreenNode? GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.newKeyword;
            case 1: return this.type;
            case 2: return this.argumentList;
            case 3: return this.initializer;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new CSharp.Syntax.ObjectCreationExpressionSyntax(this, parent, position);

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor) => visitor.VisitObjectCreationExpression(this);

    public override void Accept(CSharpSyntaxVisitor visitor) => visitor.VisitObjectCreationExpression(this);

    public ObjectCreationExpressionSyntax Update(SyntaxToken newKeyword, TypeSyntax type, ArgumentListSyntax argumentList, InitializerExpressionSyntax initializer)
    {
        if (newKeyword != this.NewKeyword || type != this.Type || argumentList != this.ArgumentList || initializer != this.Initializer)
        {
            var newNode = SyntaxFactory.ObjectCreationExpression(newKeyword, type, argumentList, initializer);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
        => new ObjectCreationExpressionSyntax(this.Kind, this.newKeyword, this.type, this.argumentList, this.initializer, diagnostics, GetAnnotations());

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
        => new ObjectCreationExpressionSyntax(this.Kind, this.newKeyword, this.type, this.argumentList, this.initializer, GetDiagnostics(), annotations);

    internal ObjectCreationExpressionSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 4;
      var newKeyword = (SyntaxToken)reader.ReadValue();
      if (newKeyword != null)
      {
         AdjustFlagsAndWidth(newKeyword);
         this.newKeyword = newKeyword;
      }
      var type = (TypeSyntax)reader.ReadValue();
      if (type != null)
      {
         AdjustFlagsAndWidth(type);
         this.type = type;
      }
      var argumentList = (ArgumentListSyntax?)reader.ReadValue();
      if (argumentList != null)
      {
         AdjustFlagsAndWidth(argumentList);
         this.argumentList = argumentList;
      }
      var initializer = (InitializerExpressionSyntax?)reader.ReadValue();
      if (initializer != null)
      {
         AdjustFlagsAndWidth(initializer);
         this.initializer = initializer;
      }
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.newKeyword);
      writer.WriteValue(this.type);
      writer.WriteValue(this.argumentList);
      writer.WriteValue(this.initializer);
    }

    static ObjectCreationExpressionSyntax()
    {
       ObjectBinder.RegisterTypeReader(typeof(ObjectCreationExpressionSyntax), r => new ObjectCreationExpressionSyntax(r));
    }
  }

  internal sealed partial class AnonymousObjectMemberDeclaratorSyntax : CSharpSyntaxNode
  {
    internal readonly NameEqualsSyntax? nameEquals;
    internal readonly ExpressionSyntax expression;

    internal AnonymousObjectMemberDeclaratorSyntax(SyntaxKind kind, NameEqualsSyntax? nameEquals, ExpressionSyntax expression, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 2;
        if (nameEquals != null)
        {
            this.AdjustFlagsAndWidth(nameEquals);
            this.nameEquals = nameEquals;
        }
        this.AdjustFlagsAndWidth(expression);
        this.expression = expression;
    }


    internal AnonymousObjectMemberDeclaratorSyntax(SyntaxKind kind, NameEqualsSyntax? nameEquals, ExpressionSyntax expression, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 2;
        if (nameEquals != null)
        {
            this.AdjustFlagsAndWidth(nameEquals);
            this.nameEquals = nameEquals;
        }
        this.AdjustFlagsAndWidth(expression);
        this.expression = expression;
    }


    internal AnonymousObjectMemberDeclaratorSyntax(SyntaxKind kind, NameEqualsSyntax? nameEquals, ExpressionSyntax expression)
        : base(kind)
    {
        this.SlotCount = 2;
        if (nameEquals != null)
        {
            this.AdjustFlagsAndWidth(nameEquals);
            this.nameEquals = nameEquals;
        }
        this.AdjustFlagsAndWidth(expression);
        this.expression = expression;
    }

    /// <summary>NameEqualsSyntax representing the optional name of the member being initialized.</summary>
    public NameEqualsSyntax? NameEquals => this.nameEquals;
    /// <summary>ExpressionSyntax representing the value the member is initialized with.</summary>
    public ExpressionSyntax Expression => this.expression;

    internal override GreenNode? GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.nameEquals;
            case 1: return this.expression;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new CSharp.Syntax.AnonymousObjectMemberDeclaratorSyntax(this, parent, position);

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor) => visitor.VisitAnonymousObjectMemberDeclarator(this);

    public override void Accept(CSharpSyntaxVisitor visitor) => visitor.VisitAnonymousObjectMemberDeclarator(this);

    public AnonymousObjectMemberDeclaratorSyntax Update(NameEqualsSyntax nameEquals, ExpressionSyntax expression)
    {
        if (nameEquals != this.NameEquals || expression != this.Expression)
        {
            var newNode = SyntaxFactory.AnonymousObjectMemberDeclarator(nameEquals, expression);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
        => new AnonymousObjectMemberDeclaratorSyntax(this.Kind, this.nameEquals, this.expression, diagnostics, GetAnnotations());

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
        => new AnonymousObjectMemberDeclaratorSyntax(this.Kind, this.nameEquals, this.expression, GetDiagnostics(), annotations);

    internal AnonymousObjectMemberDeclaratorSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 2;
      var nameEquals = (NameEqualsSyntax?)reader.ReadValue();
      if (nameEquals != null)
      {
         AdjustFlagsAndWidth(nameEquals);
         this.nameEquals = nameEquals;
      }
      var expression = (ExpressionSyntax)reader.ReadValue();
      if (expression != null)
      {
         AdjustFlagsAndWidth(expression);
         this.expression = expression;
      }
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.nameEquals);
      writer.WriteValue(this.expression);
    }

    static AnonymousObjectMemberDeclaratorSyntax()
    {
       ObjectBinder.RegisterTypeReader(typeof(AnonymousObjectMemberDeclaratorSyntax), r => new AnonymousObjectMemberDeclaratorSyntax(r));
    }
  }

  /// <summary>Class which represents the syntax node for anonymous object creation expression.</summary>
  internal sealed partial class AnonymousObjectCreationExpressionSyntax : ExpressionSyntax
  {
    internal readonly SyntaxToken newKeyword;
    internal readonly SyntaxToken openBraceToken;
    internal readonly GreenNode? initializers;
    internal readonly SyntaxToken closeBraceToken;

    internal AnonymousObjectCreationExpressionSyntax(SyntaxKind kind, SyntaxToken newKeyword, SyntaxToken openBraceToken, GreenNode? initializers, SyntaxToken closeBraceToken, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 4;
        this.AdjustFlagsAndWidth(newKeyword);
        this.newKeyword = newKeyword;
        this.AdjustFlagsAndWidth(openBraceToken);
        this.openBraceToken = openBraceToken;
        if (initializers != null)
        {
            this.AdjustFlagsAndWidth(initializers);
            this.initializers = initializers;
        }
        this.AdjustFlagsAndWidth(closeBraceToken);
        this.closeBraceToken = closeBraceToken;
    }


    internal AnonymousObjectCreationExpressionSyntax(SyntaxKind kind, SyntaxToken newKeyword, SyntaxToken openBraceToken, GreenNode? initializers, SyntaxToken closeBraceToken, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 4;
        this.AdjustFlagsAndWidth(newKeyword);
        this.newKeyword = newKeyword;
        this.AdjustFlagsAndWidth(openBraceToken);
        this.openBraceToken = openBraceToken;
        if (initializers != null)
        {
            this.AdjustFlagsAndWidth(initializers);
            this.initializers = initializers;
        }
        this.AdjustFlagsAndWidth(closeBraceToken);
        this.closeBraceToken = closeBraceToken;
    }


    internal AnonymousObjectCreationExpressionSyntax(SyntaxKind kind, SyntaxToken newKeyword, SyntaxToken openBraceToken, GreenNode? initializers, SyntaxToken closeBraceToken)
        : base(kind)
    {
        this.SlotCount = 4;
        this.AdjustFlagsAndWidth(newKeyword);
        this.newKeyword = newKeyword;
        this.AdjustFlagsAndWidth(openBraceToken);
        this.openBraceToken = openBraceToken;
        if (initializers != null)
        {
            this.AdjustFlagsAndWidth(initializers);
            this.initializers = initializers;
        }
        this.AdjustFlagsAndWidth(closeBraceToken);
        this.closeBraceToken = closeBraceToken;
    }

    /// <summary>SyntaxToken representing the new keyword.</summary>
    public SyntaxToken NewKeyword => this.newKeyword;
    /// <summary>SyntaxToken representing the open brace.</summary>
    public SyntaxToken OpenBraceToken => this.openBraceToken;
    /// <summary>SeparatedSyntaxList of AnonymousObjectMemberDeclaratorSyntax representing the list of object member initializers.</summary>
    public Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<AnonymousObjectMemberDeclaratorSyntax> Initializers => new Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<AnonymousObjectMemberDeclaratorSyntax>(new Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<CSharpSyntaxNode>(this.initializers));
    /// <summary>SyntaxToken representing the close brace.</summary>
    public SyntaxToken CloseBraceToken => this.closeBraceToken;

    internal override GreenNode? GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.newKeyword;
            case 1: return this.openBraceToken;
            case 2: return this.initializers;
            case 3: return this.closeBraceToken;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new CSharp.Syntax.AnonymousObjectCreationExpressionSyntax(this, parent, position);

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor) => visitor.VisitAnonymousObjectCreationExpression(this);

    public override void Accept(CSharpSyntaxVisitor visitor) => visitor.VisitAnonymousObjectCreationExpression(this);

    public AnonymousObjectCreationExpressionSyntax Update(SyntaxToken newKeyword, SyntaxToken openBraceToken, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<AnonymousObjectMemberDeclaratorSyntax> initializers, SyntaxToken closeBraceToken)
    {
        if (newKeyword != this.NewKeyword || openBraceToken != this.OpenBraceToken || initializers != this.Initializers || closeBraceToken != this.CloseBraceToken)
        {
            var newNode = SyntaxFactory.AnonymousObjectCreationExpression(newKeyword, openBraceToken, initializers, closeBraceToken);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
        => new AnonymousObjectCreationExpressionSyntax(this.Kind, this.newKeyword, this.openBraceToken, this.initializers, this.closeBraceToken, diagnostics, GetAnnotations());

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
        => new AnonymousObjectCreationExpressionSyntax(this.Kind, this.newKeyword, this.openBraceToken, this.initializers, this.closeBraceToken, GetDiagnostics(), annotations);

    internal AnonymousObjectCreationExpressionSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 4;
      var newKeyword = (SyntaxToken)reader.ReadValue();
      if (newKeyword != null)
      {
         AdjustFlagsAndWidth(newKeyword);
         this.newKeyword = newKeyword;
      }
      var openBraceToken = (SyntaxToken)reader.ReadValue();
      if (openBraceToken != null)
      {
         AdjustFlagsAndWidth(openBraceToken);
         this.openBraceToken = openBraceToken;
      }
      var initializers = (GreenNode?)reader.ReadValue();
      if (initializers != null)
      {
         AdjustFlagsAndWidth(initializers);
         this.initializers = initializers;
      }
      var closeBraceToken = (SyntaxToken)reader.ReadValue();
      if (closeBraceToken != null)
      {
         AdjustFlagsAndWidth(closeBraceToken);
         this.closeBraceToken = closeBraceToken;
      }
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.newKeyword);
      writer.WriteValue(this.openBraceToken);
      writer.WriteValue(this.initializers);
      writer.WriteValue(this.closeBraceToken);
    }

    static AnonymousObjectCreationExpressionSyntax()
    {
       ObjectBinder.RegisterTypeReader(typeof(AnonymousObjectCreationExpressionSyntax), r => new AnonymousObjectCreationExpressionSyntax(r));
    }
  }

  /// <summary>Class which represents the syntax node for array creation expression.</summary>
  internal sealed partial class ArrayCreationExpressionSyntax : ExpressionSyntax
  {
    internal readonly SyntaxToken newKeyword;
    internal readonly ArrayTypeSyntax type;
    internal readonly InitializerExpressionSyntax? initializer;

    internal ArrayCreationExpressionSyntax(SyntaxKind kind, SyntaxToken newKeyword, ArrayTypeSyntax type, InitializerExpressionSyntax? initializer, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 3;
        this.AdjustFlagsAndWidth(newKeyword);
        this.newKeyword = newKeyword;
        this.AdjustFlagsAndWidth(type);
        this.type = type;
        if (initializer != null)
        {
            this.AdjustFlagsAndWidth(initializer);
            this.initializer = initializer;
        }
    }


    internal ArrayCreationExpressionSyntax(SyntaxKind kind, SyntaxToken newKeyword, ArrayTypeSyntax type, InitializerExpressionSyntax? initializer, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 3;
        this.AdjustFlagsAndWidth(newKeyword);
        this.newKeyword = newKeyword;
        this.AdjustFlagsAndWidth(type);
        this.type = type;
        if (initializer != null)
        {
            this.AdjustFlagsAndWidth(initializer);
            this.initializer = initializer;
        }
    }


    internal ArrayCreationExpressionSyntax(SyntaxKind kind, SyntaxToken newKeyword, ArrayTypeSyntax type, InitializerExpressionSyntax? initializer)
        : base(kind)
    {
        this.SlotCount = 3;
        this.AdjustFlagsAndWidth(newKeyword);
        this.newKeyword = newKeyword;
        this.AdjustFlagsAndWidth(type);
        this.type = type;
        if (initializer != null)
        {
            this.AdjustFlagsAndWidth(initializer);
            this.initializer = initializer;
        }
    }

    /// <summary>SyntaxToken representing the new keyword.</summary>
    public SyntaxToken NewKeyword => this.newKeyword;
    /// <summary>ArrayTypeSyntax node representing the type of the array.</summary>
    public ArrayTypeSyntax Type => this.type;
    /// <summary>InitializerExpressionSyntax node representing the initializer of the array creation expression.</summary>
    public InitializerExpressionSyntax? Initializer => this.initializer;

    internal override GreenNode? GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.newKeyword;
            case 1: return this.type;
            case 2: return this.initializer;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new CSharp.Syntax.ArrayCreationExpressionSyntax(this, parent, position);

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor) => visitor.VisitArrayCreationExpression(this);

    public override void Accept(CSharpSyntaxVisitor visitor) => visitor.VisitArrayCreationExpression(this);

    public ArrayCreationExpressionSyntax Update(SyntaxToken newKeyword, ArrayTypeSyntax type, InitializerExpressionSyntax initializer)
    {
        if (newKeyword != this.NewKeyword || type != this.Type || initializer != this.Initializer)
        {
            var newNode = SyntaxFactory.ArrayCreationExpression(newKeyword, type, initializer);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
        => new ArrayCreationExpressionSyntax(this.Kind, this.newKeyword, this.type, this.initializer, diagnostics, GetAnnotations());

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
        => new ArrayCreationExpressionSyntax(this.Kind, this.newKeyword, this.type, this.initializer, GetDiagnostics(), annotations);

    internal ArrayCreationExpressionSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 3;
      var newKeyword = (SyntaxToken)reader.ReadValue();
      if (newKeyword != null)
      {
         AdjustFlagsAndWidth(newKeyword);
         this.newKeyword = newKeyword;
      }
      var type = (ArrayTypeSyntax)reader.ReadValue();
      if (type != null)
      {
         AdjustFlagsAndWidth(type);
         this.type = type;
      }
      var initializer = (InitializerExpressionSyntax?)reader.ReadValue();
      if (initializer != null)
      {
         AdjustFlagsAndWidth(initializer);
         this.initializer = initializer;
      }
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.newKeyword);
      writer.WriteValue(this.type);
      writer.WriteValue(this.initializer);
    }

    static ArrayCreationExpressionSyntax()
    {
       ObjectBinder.RegisterTypeReader(typeof(ArrayCreationExpressionSyntax), r => new ArrayCreationExpressionSyntax(r));
    }
  }

  /// <summary>Class which represents the syntax node for implicit array creation expression.</summary>
  internal sealed partial class ImplicitArrayCreationExpressionSyntax : ExpressionSyntax
  {
    internal readonly SyntaxToken newKeyword;
    internal readonly SyntaxToken openBracketToken;
    internal readonly GreenNode? commas;
    internal readonly SyntaxToken closeBracketToken;
    internal readonly InitializerExpressionSyntax initializer;

    internal ImplicitArrayCreationExpressionSyntax(SyntaxKind kind, SyntaxToken newKeyword, SyntaxToken openBracketToken, GreenNode? commas, SyntaxToken closeBracketToken, InitializerExpressionSyntax initializer, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 5;
        this.AdjustFlagsAndWidth(newKeyword);
        this.newKeyword = newKeyword;
        this.AdjustFlagsAndWidth(openBracketToken);
        this.openBracketToken = openBracketToken;
        if (commas != null)
        {
            this.AdjustFlagsAndWidth(commas);
            this.commas = commas;
        }
        this.AdjustFlagsAndWidth(closeBracketToken);
        this.closeBracketToken = closeBracketToken;
        this.AdjustFlagsAndWidth(initializer);
        this.initializer = initializer;
    }


    internal ImplicitArrayCreationExpressionSyntax(SyntaxKind kind, SyntaxToken newKeyword, SyntaxToken openBracketToken, GreenNode? commas, SyntaxToken closeBracketToken, InitializerExpressionSyntax initializer, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 5;
        this.AdjustFlagsAndWidth(newKeyword);
        this.newKeyword = newKeyword;
        this.AdjustFlagsAndWidth(openBracketToken);
        this.openBracketToken = openBracketToken;
        if (commas != null)
        {
            this.AdjustFlagsAndWidth(commas);
            this.commas = commas;
        }
        this.AdjustFlagsAndWidth(closeBracketToken);
        this.closeBracketToken = closeBracketToken;
        this.AdjustFlagsAndWidth(initializer);
        this.initializer = initializer;
    }


    internal ImplicitArrayCreationExpressionSyntax(SyntaxKind kind, SyntaxToken newKeyword, SyntaxToken openBracketToken, GreenNode? commas, SyntaxToken closeBracketToken, InitializerExpressionSyntax initializer)
        : base(kind)
    {
        this.SlotCount = 5;
        this.AdjustFlagsAndWidth(newKeyword);
        this.newKeyword = newKeyword;
        this.AdjustFlagsAndWidth(openBracketToken);
        this.openBracketToken = openBracketToken;
        if (commas != null)
        {
            this.AdjustFlagsAndWidth(commas);
            this.commas = commas;
        }
        this.AdjustFlagsAndWidth(closeBracketToken);
        this.closeBracketToken = closeBracketToken;
        this.AdjustFlagsAndWidth(initializer);
        this.initializer = initializer;
    }

    /// <summary>SyntaxToken representing the new keyword.</summary>
    public SyntaxToken NewKeyword => this.newKeyword;
    /// <summary>SyntaxToken representing the open bracket.</summary>
    public SyntaxToken OpenBracketToken => this.openBracketToken;
    /// <summary>SyntaxList of SyntaxToken representing the commas in the implicit array creation expression.</summary>
    public Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SyntaxToken> Commas => new Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SyntaxToken>(this.commas);
    /// <summary>SyntaxToken representing the close bracket.</summary>
    public SyntaxToken CloseBracketToken => this.closeBracketToken;
    /// <summary>InitializerExpressionSyntax representing the initializer expression of the implicit array creation expression.</summary>
    public InitializerExpressionSyntax Initializer => this.initializer;

    internal override GreenNode? GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.newKeyword;
            case 1: return this.openBracketToken;
            case 2: return this.commas;
            case 3: return this.closeBracketToken;
            case 4: return this.initializer;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new CSharp.Syntax.ImplicitArrayCreationExpressionSyntax(this, parent, position);

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor) => visitor.VisitImplicitArrayCreationExpression(this);

    public override void Accept(CSharpSyntaxVisitor visitor) => visitor.VisitImplicitArrayCreationExpression(this);

    public ImplicitArrayCreationExpressionSyntax Update(SyntaxToken newKeyword, SyntaxToken openBracketToken, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SyntaxToken> commas, SyntaxToken closeBracketToken, InitializerExpressionSyntax initializer)
    {
        if (newKeyword != this.NewKeyword || openBracketToken != this.OpenBracketToken || commas != this.Commas || closeBracketToken != this.CloseBracketToken || initializer != this.Initializer)
        {
            var newNode = SyntaxFactory.ImplicitArrayCreationExpression(newKeyword, openBracketToken, commas, closeBracketToken, initializer);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
        => new ImplicitArrayCreationExpressionSyntax(this.Kind, this.newKeyword, this.openBracketToken, this.commas, this.closeBracketToken, this.initializer, diagnostics, GetAnnotations());

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
        => new ImplicitArrayCreationExpressionSyntax(this.Kind, this.newKeyword, this.openBracketToken, this.commas, this.closeBracketToken, this.initializer, GetDiagnostics(), annotations);

    internal ImplicitArrayCreationExpressionSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 5;
      var newKeyword = (SyntaxToken)reader.ReadValue();
      if (newKeyword != null)
      {
         AdjustFlagsAndWidth(newKeyword);
         this.newKeyword = newKeyword;
      }
      var openBracketToken = (SyntaxToken)reader.ReadValue();
      if (openBracketToken != null)
      {
         AdjustFlagsAndWidth(openBracketToken);
         this.openBracketToken = openBracketToken;
      }
      var commas = (GreenNode?)reader.ReadValue();
      if (commas != null)
      {
         AdjustFlagsAndWidth(commas);
         this.commas = commas;
      }
      var closeBracketToken = (SyntaxToken)reader.ReadValue();
      if (closeBracketToken != null)
      {
         AdjustFlagsAndWidth(closeBracketToken);
         this.closeBracketToken = closeBracketToken;
      }
      var initializer = (InitializerExpressionSyntax)reader.ReadValue();
      if (initializer != null)
      {
         AdjustFlagsAndWidth(initializer);
         this.initializer = initializer;
      }
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.newKeyword);
      writer.WriteValue(this.openBracketToken);
      writer.WriteValue(this.commas);
      writer.WriteValue(this.closeBracketToken);
      writer.WriteValue(this.initializer);
    }

    static ImplicitArrayCreationExpressionSyntax()
    {
       ObjectBinder.RegisterTypeReader(typeof(ImplicitArrayCreationExpressionSyntax), r => new ImplicitArrayCreationExpressionSyntax(r));
    }
  }

  /// <summary>Class which represents the syntax node for stackalloc array creation expression.</summary>
  internal sealed partial class StackAllocArrayCreationExpressionSyntax : ExpressionSyntax
  {
    internal readonly SyntaxToken stackAllocKeyword;
    internal readonly TypeSyntax type;
    internal readonly InitializerExpressionSyntax? initializer;

    internal StackAllocArrayCreationExpressionSyntax(SyntaxKind kind, SyntaxToken stackAllocKeyword, TypeSyntax type, InitializerExpressionSyntax? initializer, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 3;
        this.AdjustFlagsAndWidth(stackAllocKeyword);
        this.stackAllocKeyword = stackAllocKeyword;
        this.AdjustFlagsAndWidth(type);
        this.type = type;
        if (initializer != null)
        {
            this.AdjustFlagsAndWidth(initializer);
            this.initializer = initializer;
        }
    }


    internal StackAllocArrayCreationExpressionSyntax(SyntaxKind kind, SyntaxToken stackAllocKeyword, TypeSyntax type, InitializerExpressionSyntax? initializer, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 3;
        this.AdjustFlagsAndWidth(stackAllocKeyword);
        this.stackAllocKeyword = stackAllocKeyword;
        this.AdjustFlagsAndWidth(type);
        this.type = type;
        if (initializer != null)
        {
            this.AdjustFlagsAndWidth(initializer);
            this.initializer = initializer;
        }
    }


    internal StackAllocArrayCreationExpressionSyntax(SyntaxKind kind, SyntaxToken stackAllocKeyword, TypeSyntax type, InitializerExpressionSyntax? initializer)
        : base(kind)
    {
        this.SlotCount = 3;
        this.AdjustFlagsAndWidth(stackAllocKeyword);
        this.stackAllocKeyword = stackAllocKeyword;
        this.AdjustFlagsAndWidth(type);
        this.type = type;
        if (initializer != null)
        {
            this.AdjustFlagsAndWidth(initializer);
            this.initializer = initializer;
        }
    }

    /// <summary>SyntaxToken representing the stackalloc keyword.</summary>
    public SyntaxToken StackAllocKeyword => this.stackAllocKeyword;
    /// <summary>TypeSyntax node representing the type of the stackalloc array.</summary>
    public TypeSyntax Type => this.type;
    /// <summary>InitializerExpressionSyntax node representing the initializer of the stackalloc array creation expression.</summary>
    public InitializerExpressionSyntax? Initializer => this.initializer;

    internal override GreenNode? GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.stackAllocKeyword;
            case 1: return this.type;
            case 2: return this.initializer;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new CSharp.Syntax.StackAllocArrayCreationExpressionSyntax(this, parent, position);

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor) => visitor.VisitStackAllocArrayCreationExpression(this);

    public override void Accept(CSharpSyntaxVisitor visitor) => visitor.VisitStackAllocArrayCreationExpression(this);

    public StackAllocArrayCreationExpressionSyntax Update(SyntaxToken stackAllocKeyword, TypeSyntax type, InitializerExpressionSyntax initializer)
    {
        if (stackAllocKeyword != this.StackAllocKeyword || type != this.Type || initializer != this.Initializer)
        {
            var newNode = SyntaxFactory.StackAllocArrayCreationExpression(stackAllocKeyword, type, initializer);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
        => new StackAllocArrayCreationExpressionSyntax(this.Kind, this.stackAllocKeyword, this.type, this.initializer, diagnostics, GetAnnotations());

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
        => new StackAllocArrayCreationExpressionSyntax(this.Kind, this.stackAllocKeyword, this.type, this.initializer, GetDiagnostics(), annotations);

    internal StackAllocArrayCreationExpressionSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 3;
      var stackAllocKeyword = (SyntaxToken)reader.ReadValue();
      if (stackAllocKeyword != null)
      {
         AdjustFlagsAndWidth(stackAllocKeyword);
         this.stackAllocKeyword = stackAllocKeyword;
      }
      var type = (TypeSyntax)reader.ReadValue();
      if (type != null)
      {
         AdjustFlagsAndWidth(type);
         this.type = type;
      }
      var initializer = (InitializerExpressionSyntax?)reader.ReadValue();
      if (initializer != null)
      {
         AdjustFlagsAndWidth(initializer);
         this.initializer = initializer;
      }
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.stackAllocKeyword);
      writer.WriteValue(this.type);
      writer.WriteValue(this.initializer);
    }

    static StackAllocArrayCreationExpressionSyntax()
    {
       ObjectBinder.RegisterTypeReader(typeof(StackAllocArrayCreationExpressionSyntax), r => new StackAllocArrayCreationExpressionSyntax(r));
    }
  }

  /// <summary>Class which represents the syntax node for implicit stackalloc array creation expression.</summary>
  internal sealed partial class ImplicitStackAllocArrayCreationExpressionSyntax : ExpressionSyntax
  {
    internal readonly SyntaxToken stackAllocKeyword;
    internal readonly SyntaxToken openBracketToken;
    internal readonly SyntaxToken closeBracketToken;
    internal readonly InitializerExpressionSyntax initializer;

    internal ImplicitStackAllocArrayCreationExpressionSyntax(SyntaxKind kind, SyntaxToken stackAllocKeyword, SyntaxToken openBracketToken, SyntaxToken closeBracketToken, InitializerExpressionSyntax initializer, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 4;
        this.AdjustFlagsAndWidth(stackAllocKeyword);
        this.stackAllocKeyword = stackAllocKeyword;
        this.AdjustFlagsAndWidth(openBracketToken);
        this.openBracketToken = openBracketToken;
        this.AdjustFlagsAndWidth(closeBracketToken);
        this.closeBracketToken = closeBracketToken;
        this.AdjustFlagsAndWidth(initializer);
        this.initializer = initializer;
    }


    internal ImplicitStackAllocArrayCreationExpressionSyntax(SyntaxKind kind, SyntaxToken stackAllocKeyword, SyntaxToken openBracketToken, SyntaxToken closeBracketToken, InitializerExpressionSyntax initializer, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 4;
        this.AdjustFlagsAndWidth(stackAllocKeyword);
        this.stackAllocKeyword = stackAllocKeyword;
        this.AdjustFlagsAndWidth(openBracketToken);
        this.openBracketToken = openBracketToken;
        this.AdjustFlagsAndWidth(closeBracketToken);
        this.closeBracketToken = closeBracketToken;
        this.AdjustFlagsAndWidth(initializer);
        this.initializer = initializer;
    }


    internal ImplicitStackAllocArrayCreationExpressionSyntax(SyntaxKind kind, SyntaxToken stackAllocKeyword, SyntaxToken openBracketToken, SyntaxToken closeBracketToken, InitializerExpressionSyntax initializer)
        : base(kind)
    {
        this.SlotCount = 4;
        this.AdjustFlagsAndWidth(stackAllocKeyword);
        this.stackAllocKeyword = stackAllocKeyword;
        this.AdjustFlagsAndWidth(openBracketToken);
        this.openBracketToken = openBracketToken;
        this.AdjustFlagsAndWidth(closeBracketToken);
        this.closeBracketToken = closeBracketToken;
        this.AdjustFlagsAndWidth(initializer);
        this.initializer = initializer;
    }

    /// <summary>SyntaxToken representing the stackalloc keyword.</summary>
    public SyntaxToken StackAllocKeyword => this.stackAllocKeyword;
    /// <summary>SyntaxToken representing the open bracket.</summary>
    public SyntaxToken OpenBracketToken => this.openBracketToken;
    /// <summary>SyntaxToken representing the close bracket.</summary>
    public SyntaxToken CloseBracketToken => this.closeBracketToken;
    /// <summary>InitializerExpressionSyntax representing the initializer expression of the implicit stackalloc array creation expression.</summary>
    public InitializerExpressionSyntax Initializer => this.initializer;

    internal override GreenNode? GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.stackAllocKeyword;
            case 1: return this.openBracketToken;
            case 2: return this.closeBracketToken;
            case 3: return this.initializer;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new CSharp.Syntax.ImplicitStackAllocArrayCreationExpressionSyntax(this, parent, position);

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor) => visitor.VisitImplicitStackAllocArrayCreationExpression(this);

    public override void Accept(CSharpSyntaxVisitor visitor) => visitor.VisitImplicitStackAllocArrayCreationExpression(this);

    public ImplicitStackAllocArrayCreationExpressionSyntax Update(SyntaxToken stackAllocKeyword, SyntaxToken openBracketToken, SyntaxToken closeBracketToken, InitializerExpressionSyntax initializer)
    {
        if (stackAllocKeyword != this.StackAllocKeyword || openBracketToken != this.OpenBracketToken || closeBracketToken != this.CloseBracketToken || initializer != this.Initializer)
        {
            var newNode = SyntaxFactory.ImplicitStackAllocArrayCreationExpression(stackAllocKeyword, openBracketToken, closeBracketToken, initializer);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
        => new ImplicitStackAllocArrayCreationExpressionSyntax(this.Kind, this.stackAllocKeyword, this.openBracketToken, this.closeBracketToken, this.initializer, diagnostics, GetAnnotations());

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
        => new ImplicitStackAllocArrayCreationExpressionSyntax(this.Kind, this.stackAllocKeyword, this.openBracketToken, this.closeBracketToken, this.initializer, GetDiagnostics(), annotations);

    internal ImplicitStackAllocArrayCreationExpressionSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 4;
      var stackAllocKeyword = (SyntaxToken)reader.ReadValue();
      if (stackAllocKeyword != null)
      {
         AdjustFlagsAndWidth(stackAllocKeyword);
         this.stackAllocKeyword = stackAllocKeyword;
      }
      var openBracketToken = (SyntaxToken)reader.ReadValue();
      if (openBracketToken != null)
      {
         AdjustFlagsAndWidth(openBracketToken);
         this.openBracketToken = openBracketToken;
      }
      var closeBracketToken = (SyntaxToken)reader.ReadValue();
      if (closeBracketToken != null)
      {
         AdjustFlagsAndWidth(closeBracketToken);
         this.closeBracketToken = closeBracketToken;
      }
      var initializer = (InitializerExpressionSyntax)reader.ReadValue();
      if (initializer != null)
      {
         AdjustFlagsAndWidth(initializer);
         this.initializer = initializer;
      }
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.stackAllocKeyword);
      writer.WriteValue(this.openBracketToken);
      writer.WriteValue(this.closeBracketToken);
      writer.WriteValue(this.initializer);
    }

    static ImplicitStackAllocArrayCreationExpressionSyntax()
    {
       ObjectBinder.RegisterTypeReader(typeof(ImplicitStackAllocArrayCreationExpressionSyntax), r => new ImplicitStackAllocArrayCreationExpressionSyntax(r));
    }
  }

  internal abstract partial class QueryClauseSyntax : CSharpSyntaxNode
  {
    internal QueryClauseSyntax(SyntaxKind kind, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
      : base(kind, diagnostics, annotations)
    {
    }
    internal QueryClauseSyntax(SyntaxKind kind)
      : base(kind)
    {
    }

    protected QueryClauseSyntax(ObjectReader reader)
       : base(reader)
    {
    }
  }

  internal abstract partial class SelectOrGroupClauseSyntax : CSharpSyntaxNode
  {
    internal SelectOrGroupClauseSyntax(SyntaxKind kind, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
      : base(kind, diagnostics, annotations)
    {
    }
    internal SelectOrGroupClauseSyntax(SyntaxKind kind)
      : base(kind)
    {
    }

    protected SelectOrGroupClauseSyntax(ObjectReader reader)
       : base(reader)
    {
    }
  }

  internal sealed partial class QueryExpressionSyntax : ExpressionSyntax
  {
    internal readonly FromClauseSyntax fromClause;
    internal readonly QueryBodySyntax body;

    internal QueryExpressionSyntax(SyntaxKind kind, FromClauseSyntax fromClause, QueryBodySyntax body, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 2;
        this.AdjustFlagsAndWidth(fromClause);
        this.fromClause = fromClause;
        this.AdjustFlagsAndWidth(body);
        this.body = body;
    }


    internal QueryExpressionSyntax(SyntaxKind kind, FromClauseSyntax fromClause, QueryBodySyntax body, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 2;
        this.AdjustFlagsAndWidth(fromClause);
        this.fromClause = fromClause;
        this.AdjustFlagsAndWidth(body);
        this.body = body;
    }


    internal QueryExpressionSyntax(SyntaxKind kind, FromClauseSyntax fromClause, QueryBodySyntax body)
        : base(kind)
    {
        this.SlotCount = 2;
        this.AdjustFlagsAndWidth(fromClause);
        this.fromClause = fromClause;
        this.AdjustFlagsAndWidth(body);
        this.body = body;
    }

    public FromClauseSyntax FromClause => this.fromClause;
    public QueryBodySyntax Body => this.body;

    internal override GreenNode? GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.fromClause;
            case 1: return this.body;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new CSharp.Syntax.QueryExpressionSyntax(this, parent, position);

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor) => visitor.VisitQueryExpression(this);

    public override void Accept(CSharpSyntaxVisitor visitor) => visitor.VisitQueryExpression(this);

    public QueryExpressionSyntax Update(FromClauseSyntax fromClause, QueryBodySyntax body)
    {
        if (fromClause != this.FromClause || body != this.Body)
        {
            var newNode = SyntaxFactory.QueryExpression(fromClause, body);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
        => new QueryExpressionSyntax(this.Kind, this.fromClause, this.body, diagnostics, GetAnnotations());

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
        => new QueryExpressionSyntax(this.Kind, this.fromClause, this.body, GetDiagnostics(), annotations);

    internal QueryExpressionSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 2;
      var fromClause = (FromClauseSyntax)reader.ReadValue();
      if (fromClause != null)
      {
         AdjustFlagsAndWidth(fromClause);
         this.fromClause = fromClause;
      }
      var body = (QueryBodySyntax)reader.ReadValue();
      if (body != null)
      {
         AdjustFlagsAndWidth(body);
         this.body = body;
      }
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.fromClause);
      writer.WriteValue(this.body);
    }

    static QueryExpressionSyntax()
    {
       ObjectBinder.RegisterTypeReader(typeof(QueryExpressionSyntax), r => new QueryExpressionSyntax(r));
    }
  }

  internal sealed partial class QueryBodySyntax : CSharpSyntaxNode
  {
    internal readonly GreenNode? clauses;
    internal readonly SelectOrGroupClauseSyntax selectOrGroup;
    internal readonly QueryContinuationSyntax? continuation;

    internal QueryBodySyntax(SyntaxKind kind, GreenNode? clauses, SelectOrGroupClauseSyntax selectOrGroup, QueryContinuationSyntax? continuation, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 3;
        if (clauses != null)
        {
            this.AdjustFlagsAndWidth(clauses);
            this.clauses = clauses;
        }
        this.AdjustFlagsAndWidth(selectOrGroup);
        this.selectOrGroup = selectOrGroup;
        if (continuation != null)
        {
            this.AdjustFlagsAndWidth(continuation);
            this.continuation = continuation;
        }
    }


    internal QueryBodySyntax(SyntaxKind kind, GreenNode? clauses, SelectOrGroupClauseSyntax selectOrGroup, QueryContinuationSyntax? continuation, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 3;
        if (clauses != null)
        {
            this.AdjustFlagsAndWidth(clauses);
            this.clauses = clauses;
        }
        this.AdjustFlagsAndWidth(selectOrGroup);
        this.selectOrGroup = selectOrGroup;
        if (continuation != null)
        {
            this.AdjustFlagsAndWidth(continuation);
            this.continuation = continuation;
        }
    }


    internal QueryBodySyntax(SyntaxKind kind, GreenNode? clauses, SelectOrGroupClauseSyntax selectOrGroup, QueryContinuationSyntax? continuation)
        : base(kind)
    {
        this.SlotCount = 3;
        if (clauses != null)
        {
            this.AdjustFlagsAndWidth(clauses);
            this.clauses = clauses;
        }
        this.AdjustFlagsAndWidth(selectOrGroup);
        this.selectOrGroup = selectOrGroup;
        if (continuation != null)
        {
            this.AdjustFlagsAndWidth(continuation);
            this.continuation = continuation;
        }
    }

    public Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<QueryClauseSyntax> Clauses => new Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<QueryClauseSyntax>(this.clauses);
    public SelectOrGroupClauseSyntax SelectOrGroup => this.selectOrGroup;
    public QueryContinuationSyntax? Continuation => this.continuation;

    internal override GreenNode? GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.clauses;
            case 1: return this.selectOrGroup;
            case 2: return this.continuation;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new CSharp.Syntax.QueryBodySyntax(this, parent, position);

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor) => visitor.VisitQueryBody(this);

    public override void Accept(CSharpSyntaxVisitor visitor) => visitor.VisitQueryBody(this);

    public QueryBodySyntax Update(Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<QueryClauseSyntax> clauses, SelectOrGroupClauseSyntax selectOrGroup, QueryContinuationSyntax continuation)
    {
        if (clauses != this.Clauses || selectOrGroup != this.SelectOrGroup || continuation != this.Continuation)
        {
            var newNode = SyntaxFactory.QueryBody(clauses, selectOrGroup, continuation);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
        => new QueryBodySyntax(this.Kind, this.clauses, this.selectOrGroup, this.continuation, diagnostics, GetAnnotations());

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
        => new QueryBodySyntax(this.Kind, this.clauses, this.selectOrGroup, this.continuation, GetDiagnostics(), annotations);

    internal QueryBodySyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 3;
      var clauses = (GreenNode?)reader.ReadValue();
      if (clauses != null)
      {
         AdjustFlagsAndWidth(clauses);
         this.clauses = clauses;
      }
      var selectOrGroup = (SelectOrGroupClauseSyntax)reader.ReadValue();
      if (selectOrGroup != null)
      {
         AdjustFlagsAndWidth(selectOrGroup);
         this.selectOrGroup = selectOrGroup;
      }
      var continuation = (QueryContinuationSyntax?)reader.ReadValue();
      if (continuation != null)
      {
         AdjustFlagsAndWidth(continuation);
         this.continuation = continuation;
      }
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.clauses);
      writer.WriteValue(this.selectOrGroup);
      writer.WriteValue(this.continuation);
    }

    static QueryBodySyntax()
    {
       ObjectBinder.RegisterTypeReader(typeof(QueryBodySyntax), r => new QueryBodySyntax(r));
    }
  }

  internal sealed partial class FromClauseSyntax : QueryClauseSyntax
  {
    internal readonly SyntaxToken fromKeyword;
    internal readonly TypeSyntax? type;
    internal readonly SyntaxToken identifier;
    internal readonly SyntaxToken inKeyword;
    internal readonly ExpressionSyntax expression;

    internal FromClauseSyntax(SyntaxKind kind, SyntaxToken fromKeyword, TypeSyntax? type, SyntaxToken identifier, SyntaxToken inKeyword, ExpressionSyntax expression, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 5;
        this.AdjustFlagsAndWidth(fromKeyword);
        this.fromKeyword = fromKeyword;
        if (type != null)
        {
            this.AdjustFlagsAndWidth(type);
            this.type = type;
        }
        this.AdjustFlagsAndWidth(identifier);
        this.identifier = identifier;
        this.AdjustFlagsAndWidth(inKeyword);
        this.inKeyword = inKeyword;
        this.AdjustFlagsAndWidth(expression);
        this.expression = expression;
    }


    internal FromClauseSyntax(SyntaxKind kind, SyntaxToken fromKeyword, TypeSyntax? type, SyntaxToken identifier, SyntaxToken inKeyword, ExpressionSyntax expression, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 5;
        this.AdjustFlagsAndWidth(fromKeyword);
        this.fromKeyword = fromKeyword;
        if (type != null)
        {
            this.AdjustFlagsAndWidth(type);
            this.type = type;
        }
        this.AdjustFlagsAndWidth(identifier);
        this.identifier = identifier;
        this.AdjustFlagsAndWidth(inKeyword);
        this.inKeyword = inKeyword;
        this.AdjustFlagsAndWidth(expression);
        this.expression = expression;
    }


    internal FromClauseSyntax(SyntaxKind kind, SyntaxToken fromKeyword, TypeSyntax? type, SyntaxToken identifier, SyntaxToken inKeyword, ExpressionSyntax expression)
        : base(kind)
    {
        this.SlotCount = 5;
        this.AdjustFlagsAndWidth(fromKeyword);
        this.fromKeyword = fromKeyword;
        if (type != null)
        {
            this.AdjustFlagsAndWidth(type);
            this.type = type;
        }
        this.AdjustFlagsAndWidth(identifier);
        this.identifier = identifier;
        this.AdjustFlagsAndWidth(inKeyword);
        this.inKeyword = inKeyword;
        this.AdjustFlagsAndWidth(expression);
        this.expression = expression;
    }

    public SyntaxToken FromKeyword => this.fromKeyword;
    public TypeSyntax? Type => this.type;
    /// <summary>Gets the identifier.</summary>
    public SyntaxToken Identifier => this.identifier;
    public SyntaxToken InKeyword => this.inKeyword;
    public ExpressionSyntax Expression => this.expression;

    internal override GreenNode? GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.fromKeyword;
            case 1: return this.type;
            case 2: return this.identifier;
            case 3: return this.inKeyword;
            case 4: return this.expression;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new CSharp.Syntax.FromClauseSyntax(this, parent, position);

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor) => visitor.VisitFromClause(this);

    public override void Accept(CSharpSyntaxVisitor visitor) => visitor.VisitFromClause(this);

    public FromClauseSyntax Update(SyntaxToken fromKeyword, TypeSyntax type, SyntaxToken identifier, SyntaxToken inKeyword, ExpressionSyntax expression)
    {
        if (fromKeyword != this.FromKeyword || type != this.Type || identifier != this.Identifier || inKeyword != this.InKeyword || expression != this.Expression)
        {
            var newNode = SyntaxFactory.FromClause(fromKeyword, type, identifier, inKeyword, expression);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
        => new FromClauseSyntax(this.Kind, this.fromKeyword, this.type, this.identifier, this.inKeyword, this.expression, diagnostics, GetAnnotations());

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
        => new FromClauseSyntax(this.Kind, this.fromKeyword, this.type, this.identifier, this.inKeyword, this.expression, GetDiagnostics(), annotations);

    internal FromClauseSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 5;
      var fromKeyword = (SyntaxToken)reader.ReadValue();
      if (fromKeyword != null)
      {
         AdjustFlagsAndWidth(fromKeyword);
         this.fromKeyword = fromKeyword;
      }
      var type = (TypeSyntax?)reader.ReadValue();
      if (type != null)
      {
         AdjustFlagsAndWidth(type);
         this.type = type;
      }
      var identifier = (SyntaxToken)reader.ReadValue();
      if (identifier != null)
      {
         AdjustFlagsAndWidth(identifier);
         this.identifier = identifier;
      }
      var inKeyword = (SyntaxToken)reader.ReadValue();
      if (inKeyword != null)
      {
         AdjustFlagsAndWidth(inKeyword);
         this.inKeyword = inKeyword;
      }
      var expression = (ExpressionSyntax)reader.ReadValue();
      if (expression != null)
      {
         AdjustFlagsAndWidth(expression);
         this.expression = expression;
      }
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.fromKeyword);
      writer.WriteValue(this.type);
      writer.WriteValue(this.identifier);
      writer.WriteValue(this.inKeyword);
      writer.WriteValue(this.expression);
    }

    static FromClauseSyntax()
    {
       ObjectBinder.RegisterTypeReader(typeof(FromClauseSyntax), r => new FromClauseSyntax(r));
    }
  }

  internal sealed partial class LetClauseSyntax : QueryClauseSyntax
  {
    internal readonly SyntaxToken letKeyword;
    internal readonly SyntaxToken identifier;
    internal readonly SyntaxToken equalsToken;
    internal readonly ExpressionSyntax expression;

    internal LetClauseSyntax(SyntaxKind kind, SyntaxToken letKeyword, SyntaxToken identifier, SyntaxToken equalsToken, ExpressionSyntax expression, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 4;
        this.AdjustFlagsAndWidth(letKeyword);
        this.letKeyword = letKeyword;
        this.AdjustFlagsAndWidth(identifier);
        this.identifier = identifier;
        this.AdjustFlagsAndWidth(equalsToken);
        this.equalsToken = equalsToken;
        this.AdjustFlagsAndWidth(expression);
        this.expression = expression;
    }


    internal LetClauseSyntax(SyntaxKind kind, SyntaxToken letKeyword, SyntaxToken identifier, SyntaxToken equalsToken, ExpressionSyntax expression, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 4;
        this.AdjustFlagsAndWidth(letKeyword);
        this.letKeyword = letKeyword;
        this.AdjustFlagsAndWidth(identifier);
        this.identifier = identifier;
        this.AdjustFlagsAndWidth(equalsToken);
        this.equalsToken = equalsToken;
        this.AdjustFlagsAndWidth(expression);
        this.expression = expression;
    }


    internal LetClauseSyntax(SyntaxKind kind, SyntaxToken letKeyword, SyntaxToken identifier, SyntaxToken equalsToken, ExpressionSyntax expression)
        : base(kind)
    {
        this.SlotCount = 4;
        this.AdjustFlagsAndWidth(letKeyword);
        this.letKeyword = letKeyword;
        this.AdjustFlagsAndWidth(identifier);
        this.identifier = identifier;
        this.AdjustFlagsAndWidth(equalsToken);
        this.equalsToken = equalsToken;
        this.AdjustFlagsAndWidth(expression);
        this.expression = expression;
    }

    public SyntaxToken LetKeyword => this.letKeyword;
    /// <summary>Gets the identifier.</summary>
    public SyntaxToken Identifier => this.identifier;
    public SyntaxToken EqualsToken => this.equalsToken;
    public ExpressionSyntax Expression => this.expression;

    internal override GreenNode? GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.letKeyword;
            case 1: return this.identifier;
            case 2: return this.equalsToken;
            case 3: return this.expression;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new CSharp.Syntax.LetClauseSyntax(this, parent, position);

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor) => visitor.VisitLetClause(this);

    public override void Accept(CSharpSyntaxVisitor visitor) => visitor.VisitLetClause(this);

    public LetClauseSyntax Update(SyntaxToken letKeyword, SyntaxToken identifier, SyntaxToken equalsToken, ExpressionSyntax expression)
    {
        if (letKeyword != this.LetKeyword || identifier != this.Identifier || equalsToken != this.EqualsToken || expression != this.Expression)
        {
            var newNode = SyntaxFactory.LetClause(letKeyword, identifier, equalsToken, expression);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
        => new LetClauseSyntax(this.Kind, this.letKeyword, this.identifier, this.equalsToken, this.expression, diagnostics, GetAnnotations());

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
        => new LetClauseSyntax(this.Kind, this.letKeyword, this.identifier, this.equalsToken, this.expression, GetDiagnostics(), annotations);

    internal LetClauseSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 4;
      var letKeyword = (SyntaxToken)reader.ReadValue();
      if (letKeyword != null)
      {
         AdjustFlagsAndWidth(letKeyword);
         this.letKeyword = letKeyword;
      }
      var identifier = (SyntaxToken)reader.ReadValue();
      if (identifier != null)
      {
         AdjustFlagsAndWidth(identifier);
         this.identifier = identifier;
      }
      var equalsToken = (SyntaxToken)reader.ReadValue();
      if (equalsToken != null)
      {
         AdjustFlagsAndWidth(equalsToken);
         this.equalsToken = equalsToken;
      }
      var expression = (ExpressionSyntax)reader.ReadValue();
      if (expression != null)
      {
         AdjustFlagsAndWidth(expression);
         this.expression = expression;
      }
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.letKeyword);
      writer.WriteValue(this.identifier);
      writer.WriteValue(this.equalsToken);
      writer.WriteValue(this.expression);
    }

    static LetClauseSyntax()
    {
       ObjectBinder.RegisterTypeReader(typeof(LetClauseSyntax), r => new LetClauseSyntax(r));
    }
  }

  internal sealed partial class JoinClauseSyntax : QueryClauseSyntax
  {
    internal readonly SyntaxToken joinKeyword;
    internal readonly TypeSyntax? type;
    internal readonly SyntaxToken identifier;
    internal readonly SyntaxToken inKeyword;
    internal readonly ExpressionSyntax inExpression;
    internal readonly SyntaxToken onKeyword;
    internal readonly ExpressionSyntax leftExpression;
    internal readonly SyntaxToken equalsKeyword;
    internal readonly ExpressionSyntax rightExpression;
    internal readonly JoinIntoClauseSyntax? into;

    internal JoinClauseSyntax(SyntaxKind kind, SyntaxToken joinKeyword, TypeSyntax? type, SyntaxToken identifier, SyntaxToken inKeyword, ExpressionSyntax inExpression, SyntaxToken onKeyword, ExpressionSyntax leftExpression, SyntaxToken equalsKeyword, ExpressionSyntax rightExpression, JoinIntoClauseSyntax? into, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 10;
        this.AdjustFlagsAndWidth(joinKeyword);
        this.joinKeyword = joinKeyword;
        if (type != null)
        {
            this.AdjustFlagsAndWidth(type);
            this.type = type;
        }
        this.AdjustFlagsAndWidth(identifier);
        this.identifier = identifier;
        this.AdjustFlagsAndWidth(inKeyword);
        this.inKeyword = inKeyword;
        this.AdjustFlagsAndWidth(inExpression);
        this.inExpression = inExpression;
        this.AdjustFlagsAndWidth(onKeyword);
        this.onKeyword = onKeyword;
        this.AdjustFlagsAndWidth(leftExpression);
        this.leftExpression = leftExpression;
        this.AdjustFlagsAndWidth(equalsKeyword);
        this.equalsKeyword = equalsKeyword;
        this.AdjustFlagsAndWidth(rightExpression);
        this.rightExpression = rightExpression;
        if (into != null)
        {
            this.AdjustFlagsAndWidth(into);
            this.into = into;
        }
    }


    internal JoinClauseSyntax(SyntaxKind kind, SyntaxToken joinKeyword, TypeSyntax? type, SyntaxToken identifier, SyntaxToken inKeyword, ExpressionSyntax inExpression, SyntaxToken onKeyword, ExpressionSyntax leftExpression, SyntaxToken equalsKeyword, ExpressionSyntax rightExpression, JoinIntoClauseSyntax? into, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 10;
        this.AdjustFlagsAndWidth(joinKeyword);
        this.joinKeyword = joinKeyword;
        if (type != null)
        {
            this.AdjustFlagsAndWidth(type);
            this.type = type;
        }
        this.AdjustFlagsAndWidth(identifier);
        this.identifier = identifier;
        this.AdjustFlagsAndWidth(inKeyword);
        this.inKeyword = inKeyword;
        this.AdjustFlagsAndWidth(inExpression);
        this.inExpression = inExpression;
        this.AdjustFlagsAndWidth(onKeyword);
        this.onKeyword = onKeyword;
        this.AdjustFlagsAndWidth(leftExpression);
        this.leftExpression = leftExpression;
        this.AdjustFlagsAndWidth(equalsKeyword);
        this.equalsKeyword = equalsKeyword;
        this.AdjustFlagsAndWidth(rightExpression);
        this.rightExpression = rightExpression;
        if (into != null)
        {
            this.AdjustFlagsAndWidth(into);
            this.into = into;
        }
    }


    internal JoinClauseSyntax(SyntaxKind kind, SyntaxToken joinKeyword, TypeSyntax? type, SyntaxToken identifier, SyntaxToken inKeyword, ExpressionSyntax inExpression, SyntaxToken onKeyword, ExpressionSyntax leftExpression, SyntaxToken equalsKeyword, ExpressionSyntax rightExpression, JoinIntoClauseSyntax? into)
        : base(kind)
    {
        this.SlotCount = 10;
        this.AdjustFlagsAndWidth(joinKeyword);
        this.joinKeyword = joinKeyword;
        if (type != null)
        {
            this.AdjustFlagsAndWidth(type);
            this.type = type;
        }
        this.AdjustFlagsAndWidth(identifier);
        this.identifier = identifier;
        this.AdjustFlagsAndWidth(inKeyword);
        this.inKeyword = inKeyword;
        this.AdjustFlagsAndWidth(inExpression);
        this.inExpression = inExpression;
        this.AdjustFlagsAndWidth(onKeyword);
        this.onKeyword = onKeyword;
        this.AdjustFlagsAndWidth(leftExpression);
        this.leftExpression = leftExpression;
        this.AdjustFlagsAndWidth(equalsKeyword);
        this.equalsKeyword = equalsKeyword;
        this.AdjustFlagsAndWidth(rightExpression);
        this.rightExpression = rightExpression;
        if (into != null)
        {
            this.AdjustFlagsAndWidth(into);
            this.into = into;
        }
    }

    public SyntaxToken JoinKeyword => this.joinKeyword;
    public TypeSyntax? Type => this.type;
    /// <summary>Gets the identifier.</summary>
    public SyntaxToken Identifier => this.identifier;
    public SyntaxToken InKeyword => this.inKeyword;
    public ExpressionSyntax InExpression => this.inExpression;
    public SyntaxToken OnKeyword => this.onKeyword;
    public ExpressionSyntax LeftExpression => this.leftExpression;
    public SyntaxToken EqualsKeyword => this.equalsKeyword;
    public ExpressionSyntax RightExpression => this.rightExpression;
    public JoinIntoClauseSyntax? Into => this.into;

    internal override GreenNode? GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.joinKeyword;
            case 1: return this.type;
            case 2: return this.identifier;
            case 3: return this.inKeyword;
            case 4: return this.inExpression;
            case 5: return this.onKeyword;
            case 6: return this.leftExpression;
            case 7: return this.equalsKeyword;
            case 8: return this.rightExpression;
            case 9: return this.into;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new CSharp.Syntax.JoinClauseSyntax(this, parent, position);

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor) => visitor.VisitJoinClause(this);

    public override void Accept(CSharpSyntaxVisitor visitor) => visitor.VisitJoinClause(this);

    public JoinClauseSyntax Update(SyntaxToken joinKeyword, TypeSyntax type, SyntaxToken identifier, SyntaxToken inKeyword, ExpressionSyntax inExpression, SyntaxToken onKeyword, ExpressionSyntax leftExpression, SyntaxToken equalsKeyword, ExpressionSyntax rightExpression, JoinIntoClauseSyntax into)
    {
        if (joinKeyword != this.JoinKeyword || type != this.Type || identifier != this.Identifier || inKeyword != this.InKeyword || inExpression != this.InExpression || onKeyword != this.OnKeyword || leftExpression != this.LeftExpression || equalsKeyword != this.EqualsKeyword || rightExpression != this.RightExpression || into != this.Into)
        {
            var newNode = SyntaxFactory.JoinClause(joinKeyword, type, identifier, inKeyword, inExpression, onKeyword, leftExpression, equalsKeyword, rightExpression, into);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
        => new JoinClauseSyntax(this.Kind, this.joinKeyword, this.type, this.identifier, this.inKeyword, this.inExpression, this.onKeyword, this.leftExpression, this.equalsKeyword, this.rightExpression, this.into, diagnostics, GetAnnotations());

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
        => new JoinClauseSyntax(this.Kind, this.joinKeyword, this.type, this.identifier, this.inKeyword, this.inExpression, this.onKeyword, this.leftExpression, this.equalsKeyword, this.rightExpression, this.into, GetDiagnostics(), annotations);

    internal JoinClauseSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 10;
      var joinKeyword = (SyntaxToken)reader.ReadValue();
      if (joinKeyword != null)
      {
         AdjustFlagsAndWidth(joinKeyword);
         this.joinKeyword = joinKeyword;
      }
      var type = (TypeSyntax?)reader.ReadValue();
      if (type != null)
      {
         AdjustFlagsAndWidth(type);
         this.type = type;
      }
      var identifier = (SyntaxToken)reader.ReadValue();
      if (identifier != null)
      {
         AdjustFlagsAndWidth(identifier);
         this.identifier = identifier;
      }
      var inKeyword = (SyntaxToken)reader.ReadValue();
      if (inKeyword != null)
      {
         AdjustFlagsAndWidth(inKeyword);
         this.inKeyword = inKeyword;
      }
      var inExpression = (ExpressionSyntax)reader.ReadValue();
      if (inExpression != null)
      {
         AdjustFlagsAndWidth(inExpression);
         this.inExpression = inExpression;
      }
      var onKeyword = (SyntaxToken)reader.ReadValue();
      if (onKeyword != null)
      {
         AdjustFlagsAndWidth(onKeyword);
         this.onKeyword = onKeyword;
      }
      var leftExpression = (ExpressionSyntax)reader.ReadValue();
      if (leftExpression != null)
      {
         AdjustFlagsAndWidth(leftExpression);
         this.leftExpression = leftExpression;
      }
      var equalsKeyword = (SyntaxToken)reader.ReadValue();
      if (equalsKeyword != null)
      {
         AdjustFlagsAndWidth(equalsKeyword);
         this.equalsKeyword = equalsKeyword;
      }
      var rightExpression = (ExpressionSyntax)reader.ReadValue();
      if (rightExpression != null)
      {
         AdjustFlagsAndWidth(rightExpression);
         this.rightExpression = rightExpression;
      }
      var into = (JoinIntoClauseSyntax?)reader.ReadValue();
      if (into != null)
      {
         AdjustFlagsAndWidth(into);
         this.into = into;
      }
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.joinKeyword);
      writer.WriteValue(this.type);
      writer.WriteValue(this.identifier);
      writer.WriteValue(this.inKeyword);
      writer.WriteValue(this.inExpression);
      writer.WriteValue(this.onKeyword);
      writer.WriteValue(this.leftExpression);
      writer.WriteValue(this.equalsKeyword);
      writer.WriteValue(this.rightExpression);
      writer.WriteValue(this.into);
    }

    static JoinClauseSyntax()
    {
       ObjectBinder.RegisterTypeReader(typeof(JoinClauseSyntax), r => new JoinClauseSyntax(r));
    }
  }

  internal sealed partial class JoinIntoClauseSyntax : CSharpSyntaxNode
  {
    internal readonly SyntaxToken intoKeyword;
    internal readonly SyntaxToken identifier;

    internal JoinIntoClauseSyntax(SyntaxKind kind, SyntaxToken intoKeyword, SyntaxToken identifier, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 2;
        this.AdjustFlagsAndWidth(intoKeyword);
        this.intoKeyword = intoKeyword;
        this.AdjustFlagsAndWidth(identifier);
        this.identifier = identifier;
    }


    internal JoinIntoClauseSyntax(SyntaxKind kind, SyntaxToken intoKeyword, SyntaxToken identifier, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 2;
        this.AdjustFlagsAndWidth(intoKeyword);
        this.intoKeyword = intoKeyword;
        this.AdjustFlagsAndWidth(identifier);
        this.identifier = identifier;
    }


    internal JoinIntoClauseSyntax(SyntaxKind kind, SyntaxToken intoKeyword, SyntaxToken identifier)
        : base(kind)
    {
        this.SlotCount = 2;
        this.AdjustFlagsAndWidth(intoKeyword);
        this.intoKeyword = intoKeyword;
        this.AdjustFlagsAndWidth(identifier);
        this.identifier = identifier;
    }

    public SyntaxToken IntoKeyword => this.intoKeyword;
    /// <summary>Gets the identifier.</summary>
    public SyntaxToken Identifier => this.identifier;

    internal override GreenNode? GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.intoKeyword;
            case 1: return this.identifier;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new CSharp.Syntax.JoinIntoClauseSyntax(this, parent, position);

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor) => visitor.VisitJoinIntoClause(this);

    public override void Accept(CSharpSyntaxVisitor visitor) => visitor.VisitJoinIntoClause(this);

    public JoinIntoClauseSyntax Update(SyntaxToken intoKeyword, SyntaxToken identifier)
    {
        if (intoKeyword != this.IntoKeyword || identifier != this.Identifier)
        {
            var newNode = SyntaxFactory.JoinIntoClause(intoKeyword, identifier);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
        => new JoinIntoClauseSyntax(this.Kind, this.intoKeyword, this.identifier, diagnostics, GetAnnotations());

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
        => new JoinIntoClauseSyntax(this.Kind, this.intoKeyword, this.identifier, GetDiagnostics(), annotations);

    internal JoinIntoClauseSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 2;
      var intoKeyword = (SyntaxToken)reader.ReadValue();
      if (intoKeyword != null)
      {
         AdjustFlagsAndWidth(intoKeyword);
         this.intoKeyword = intoKeyword;
      }
      var identifier = (SyntaxToken)reader.ReadValue();
      if (identifier != null)
      {
         AdjustFlagsAndWidth(identifier);
         this.identifier = identifier;
      }
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.intoKeyword);
      writer.WriteValue(this.identifier);
    }

    static JoinIntoClauseSyntax()
    {
       ObjectBinder.RegisterTypeReader(typeof(JoinIntoClauseSyntax), r => new JoinIntoClauseSyntax(r));
    }
  }

  internal sealed partial class WhereClauseSyntax : QueryClauseSyntax
  {
    internal readonly SyntaxToken whereKeyword;
    internal readonly ExpressionSyntax condition;

    internal WhereClauseSyntax(SyntaxKind kind, SyntaxToken whereKeyword, ExpressionSyntax condition, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 2;
        this.AdjustFlagsAndWidth(whereKeyword);
        this.whereKeyword = whereKeyword;
        this.AdjustFlagsAndWidth(condition);
        this.condition = condition;
    }


    internal WhereClauseSyntax(SyntaxKind kind, SyntaxToken whereKeyword, ExpressionSyntax condition, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 2;
        this.AdjustFlagsAndWidth(whereKeyword);
        this.whereKeyword = whereKeyword;
        this.AdjustFlagsAndWidth(condition);
        this.condition = condition;
    }


    internal WhereClauseSyntax(SyntaxKind kind, SyntaxToken whereKeyword, ExpressionSyntax condition)
        : base(kind)
    {
        this.SlotCount = 2;
        this.AdjustFlagsAndWidth(whereKeyword);
        this.whereKeyword = whereKeyword;
        this.AdjustFlagsAndWidth(condition);
        this.condition = condition;
    }

    public SyntaxToken WhereKeyword => this.whereKeyword;
    public ExpressionSyntax Condition => this.condition;

    internal override GreenNode? GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.whereKeyword;
            case 1: return this.condition;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new CSharp.Syntax.WhereClauseSyntax(this, parent, position);

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor) => visitor.VisitWhereClause(this);

    public override void Accept(CSharpSyntaxVisitor visitor) => visitor.VisitWhereClause(this);

    public WhereClauseSyntax Update(SyntaxToken whereKeyword, ExpressionSyntax condition)
    {
        if (whereKeyword != this.WhereKeyword || condition != this.Condition)
        {
            var newNode = SyntaxFactory.WhereClause(whereKeyword, condition);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
        => new WhereClauseSyntax(this.Kind, this.whereKeyword, this.condition, diagnostics, GetAnnotations());

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
        => new WhereClauseSyntax(this.Kind, this.whereKeyword, this.condition, GetDiagnostics(), annotations);

    internal WhereClauseSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 2;
      var whereKeyword = (SyntaxToken)reader.ReadValue();
      if (whereKeyword != null)
      {
         AdjustFlagsAndWidth(whereKeyword);
         this.whereKeyword = whereKeyword;
      }
      var condition = (ExpressionSyntax)reader.ReadValue();
      if (condition != null)
      {
         AdjustFlagsAndWidth(condition);
         this.condition = condition;
      }
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.whereKeyword);
      writer.WriteValue(this.condition);
    }

    static WhereClauseSyntax()
    {
       ObjectBinder.RegisterTypeReader(typeof(WhereClauseSyntax), r => new WhereClauseSyntax(r));
    }
  }

  internal sealed partial class OrderByClauseSyntax : QueryClauseSyntax
  {
    internal readonly SyntaxToken orderByKeyword;
    internal readonly GreenNode? orderings;

    internal OrderByClauseSyntax(SyntaxKind kind, SyntaxToken orderByKeyword, GreenNode? orderings, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 2;
        this.AdjustFlagsAndWidth(orderByKeyword);
        this.orderByKeyword = orderByKeyword;
        if (orderings != null)
        {
            this.AdjustFlagsAndWidth(orderings);
            this.orderings = orderings;
        }
    }


    internal OrderByClauseSyntax(SyntaxKind kind, SyntaxToken orderByKeyword, GreenNode? orderings, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 2;
        this.AdjustFlagsAndWidth(orderByKeyword);
        this.orderByKeyword = orderByKeyword;
        if (orderings != null)
        {
            this.AdjustFlagsAndWidth(orderings);
            this.orderings = orderings;
        }
    }


    internal OrderByClauseSyntax(SyntaxKind kind, SyntaxToken orderByKeyword, GreenNode? orderings)
        : base(kind)
    {
        this.SlotCount = 2;
        this.AdjustFlagsAndWidth(orderByKeyword);
        this.orderByKeyword = orderByKeyword;
        if (orderings != null)
        {
            this.AdjustFlagsAndWidth(orderings);
            this.orderings = orderings;
        }
    }

    public SyntaxToken OrderByKeyword => this.orderByKeyword;
    public Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<OrderingSyntax> Orderings => new Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<OrderingSyntax>(new Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<CSharpSyntaxNode>(this.orderings));

    internal override GreenNode? GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.orderByKeyword;
            case 1: return this.orderings;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new CSharp.Syntax.OrderByClauseSyntax(this, parent, position);

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor) => visitor.VisitOrderByClause(this);

    public override void Accept(CSharpSyntaxVisitor visitor) => visitor.VisitOrderByClause(this);

    public OrderByClauseSyntax Update(SyntaxToken orderByKeyword, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<OrderingSyntax> orderings)
    {
        if (orderByKeyword != this.OrderByKeyword || orderings != this.Orderings)
        {
            var newNode = SyntaxFactory.OrderByClause(orderByKeyword, orderings);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
        => new OrderByClauseSyntax(this.Kind, this.orderByKeyword, this.orderings, diagnostics, GetAnnotations());

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
        => new OrderByClauseSyntax(this.Kind, this.orderByKeyword, this.orderings, GetDiagnostics(), annotations);

    internal OrderByClauseSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 2;
      var orderByKeyword = (SyntaxToken)reader.ReadValue();
      if (orderByKeyword != null)
      {
         AdjustFlagsAndWidth(orderByKeyword);
         this.orderByKeyword = orderByKeyword;
      }
      var orderings = (GreenNode?)reader.ReadValue();
      if (orderings != null)
      {
         AdjustFlagsAndWidth(orderings);
         this.orderings = orderings;
      }
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.orderByKeyword);
      writer.WriteValue(this.orderings);
    }

    static OrderByClauseSyntax()
    {
       ObjectBinder.RegisterTypeReader(typeof(OrderByClauseSyntax), r => new OrderByClauseSyntax(r));
    }
  }

  internal sealed partial class OrderingSyntax : CSharpSyntaxNode
  {
    internal readonly ExpressionSyntax expression;
    internal readonly SyntaxToken? ascendingOrDescendingKeyword;

    internal OrderingSyntax(SyntaxKind kind, ExpressionSyntax expression, SyntaxToken? ascendingOrDescendingKeyword, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 2;
        this.AdjustFlagsAndWidth(expression);
        this.expression = expression;
        if (ascendingOrDescendingKeyword != null)
        {
            this.AdjustFlagsAndWidth(ascendingOrDescendingKeyword);
            this.ascendingOrDescendingKeyword = ascendingOrDescendingKeyword;
        }
    }


    internal OrderingSyntax(SyntaxKind kind, ExpressionSyntax expression, SyntaxToken? ascendingOrDescendingKeyword, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 2;
        this.AdjustFlagsAndWidth(expression);
        this.expression = expression;
        if (ascendingOrDescendingKeyword != null)
        {
            this.AdjustFlagsAndWidth(ascendingOrDescendingKeyword);
            this.ascendingOrDescendingKeyword = ascendingOrDescendingKeyword;
        }
    }


    internal OrderingSyntax(SyntaxKind kind, ExpressionSyntax expression, SyntaxToken? ascendingOrDescendingKeyword)
        : base(kind)
    {
        this.SlotCount = 2;
        this.AdjustFlagsAndWidth(expression);
        this.expression = expression;
        if (ascendingOrDescendingKeyword != null)
        {
            this.AdjustFlagsAndWidth(ascendingOrDescendingKeyword);
            this.ascendingOrDescendingKeyword = ascendingOrDescendingKeyword;
        }
    }

    public ExpressionSyntax Expression => this.expression;
    public SyntaxToken? AscendingOrDescendingKeyword => this.ascendingOrDescendingKeyword;

    internal override GreenNode? GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.expression;
            case 1: return this.ascendingOrDescendingKeyword;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new CSharp.Syntax.OrderingSyntax(this, parent, position);

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor) => visitor.VisitOrdering(this);

    public override void Accept(CSharpSyntaxVisitor visitor) => visitor.VisitOrdering(this);

    public OrderingSyntax Update(ExpressionSyntax expression, SyntaxToken ascendingOrDescendingKeyword)
    {
        if (expression != this.Expression || ascendingOrDescendingKeyword != this.AscendingOrDescendingKeyword)
        {
            var newNode = SyntaxFactory.Ordering(this.Kind, expression, ascendingOrDescendingKeyword);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
        => new OrderingSyntax(this.Kind, this.expression, this.ascendingOrDescendingKeyword, diagnostics, GetAnnotations());

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
        => new OrderingSyntax(this.Kind, this.expression, this.ascendingOrDescendingKeyword, GetDiagnostics(), annotations);

    internal OrderingSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 2;
      var expression = (ExpressionSyntax)reader.ReadValue();
      if (expression != null)
      {
         AdjustFlagsAndWidth(expression);
         this.expression = expression;
      }
      var ascendingOrDescendingKeyword = (SyntaxToken?)reader.ReadValue();
      if (ascendingOrDescendingKeyword != null)
      {
         AdjustFlagsAndWidth(ascendingOrDescendingKeyword);
         this.ascendingOrDescendingKeyword = ascendingOrDescendingKeyword;
      }
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.expression);
      writer.WriteValue(this.ascendingOrDescendingKeyword);
    }

    static OrderingSyntax()
    {
       ObjectBinder.RegisterTypeReader(typeof(OrderingSyntax), r => new OrderingSyntax(r));
    }
  }

  internal sealed partial class SelectClauseSyntax : SelectOrGroupClauseSyntax
  {
    internal readonly SyntaxToken selectKeyword;
    internal readonly ExpressionSyntax expression;

    internal SelectClauseSyntax(SyntaxKind kind, SyntaxToken selectKeyword, ExpressionSyntax expression, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 2;
        this.AdjustFlagsAndWidth(selectKeyword);
        this.selectKeyword = selectKeyword;
        this.AdjustFlagsAndWidth(expression);
        this.expression = expression;
    }


    internal SelectClauseSyntax(SyntaxKind kind, SyntaxToken selectKeyword, ExpressionSyntax expression, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 2;
        this.AdjustFlagsAndWidth(selectKeyword);
        this.selectKeyword = selectKeyword;
        this.AdjustFlagsAndWidth(expression);
        this.expression = expression;
    }


    internal SelectClauseSyntax(SyntaxKind kind, SyntaxToken selectKeyword, ExpressionSyntax expression)
        : base(kind)
    {
        this.SlotCount = 2;
        this.AdjustFlagsAndWidth(selectKeyword);
        this.selectKeyword = selectKeyword;
        this.AdjustFlagsAndWidth(expression);
        this.expression = expression;
    }

    public SyntaxToken SelectKeyword => this.selectKeyword;
    public ExpressionSyntax Expression => this.expression;

    internal override GreenNode? GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.selectKeyword;
            case 1: return this.expression;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new CSharp.Syntax.SelectClauseSyntax(this, parent, position);

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor) => visitor.VisitSelectClause(this);

    public override void Accept(CSharpSyntaxVisitor visitor) => visitor.VisitSelectClause(this);

    public SelectClauseSyntax Update(SyntaxToken selectKeyword, ExpressionSyntax expression)
    {
        if (selectKeyword != this.SelectKeyword || expression != this.Expression)
        {
            var newNode = SyntaxFactory.SelectClause(selectKeyword, expression);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
        => new SelectClauseSyntax(this.Kind, this.selectKeyword, this.expression, diagnostics, GetAnnotations());

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
        => new SelectClauseSyntax(this.Kind, this.selectKeyword, this.expression, GetDiagnostics(), annotations);

    internal SelectClauseSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 2;
      var selectKeyword = (SyntaxToken)reader.ReadValue();
      if (selectKeyword != null)
      {
         AdjustFlagsAndWidth(selectKeyword);
         this.selectKeyword = selectKeyword;
      }
      var expression = (ExpressionSyntax)reader.ReadValue();
      if (expression != null)
      {
         AdjustFlagsAndWidth(expression);
         this.expression = expression;
      }
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.selectKeyword);
      writer.WriteValue(this.expression);
    }

    static SelectClauseSyntax()
    {
       ObjectBinder.RegisterTypeReader(typeof(SelectClauseSyntax), r => new SelectClauseSyntax(r));
    }
  }

  internal sealed partial class GroupClauseSyntax : SelectOrGroupClauseSyntax
  {
    internal readonly SyntaxToken groupKeyword;
    internal readonly ExpressionSyntax groupExpression;
    internal readonly SyntaxToken byKeyword;
    internal readonly ExpressionSyntax byExpression;

    internal GroupClauseSyntax(SyntaxKind kind, SyntaxToken groupKeyword, ExpressionSyntax groupExpression, SyntaxToken byKeyword, ExpressionSyntax byExpression, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 4;
        this.AdjustFlagsAndWidth(groupKeyword);
        this.groupKeyword = groupKeyword;
        this.AdjustFlagsAndWidth(groupExpression);
        this.groupExpression = groupExpression;
        this.AdjustFlagsAndWidth(byKeyword);
        this.byKeyword = byKeyword;
        this.AdjustFlagsAndWidth(byExpression);
        this.byExpression = byExpression;
    }


    internal GroupClauseSyntax(SyntaxKind kind, SyntaxToken groupKeyword, ExpressionSyntax groupExpression, SyntaxToken byKeyword, ExpressionSyntax byExpression, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 4;
        this.AdjustFlagsAndWidth(groupKeyword);
        this.groupKeyword = groupKeyword;
        this.AdjustFlagsAndWidth(groupExpression);
        this.groupExpression = groupExpression;
        this.AdjustFlagsAndWidth(byKeyword);
        this.byKeyword = byKeyword;
        this.AdjustFlagsAndWidth(byExpression);
        this.byExpression = byExpression;
    }


    internal GroupClauseSyntax(SyntaxKind kind, SyntaxToken groupKeyword, ExpressionSyntax groupExpression, SyntaxToken byKeyword, ExpressionSyntax byExpression)
        : base(kind)
    {
        this.SlotCount = 4;
        this.AdjustFlagsAndWidth(groupKeyword);
        this.groupKeyword = groupKeyword;
        this.AdjustFlagsAndWidth(groupExpression);
        this.groupExpression = groupExpression;
        this.AdjustFlagsAndWidth(byKeyword);
        this.byKeyword = byKeyword;
        this.AdjustFlagsAndWidth(byExpression);
        this.byExpression = byExpression;
    }

    public SyntaxToken GroupKeyword => this.groupKeyword;
    public ExpressionSyntax GroupExpression => this.groupExpression;
    public SyntaxToken ByKeyword => this.byKeyword;
    public ExpressionSyntax ByExpression => this.byExpression;

    internal override GreenNode? GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.groupKeyword;
            case 1: return this.groupExpression;
            case 2: return this.byKeyword;
            case 3: return this.byExpression;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new CSharp.Syntax.GroupClauseSyntax(this, parent, position);

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor) => visitor.VisitGroupClause(this);

    public override void Accept(CSharpSyntaxVisitor visitor) => visitor.VisitGroupClause(this);

    public GroupClauseSyntax Update(SyntaxToken groupKeyword, ExpressionSyntax groupExpression, SyntaxToken byKeyword, ExpressionSyntax byExpression)
    {
        if (groupKeyword != this.GroupKeyword || groupExpression != this.GroupExpression || byKeyword != this.ByKeyword || byExpression != this.ByExpression)
        {
            var newNode = SyntaxFactory.GroupClause(groupKeyword, groupExpression, byKeyword, byExpression);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
        => new GroupClauseSyntax(this.Kind, this.groupKeyword, this.groupExpression, this.byKeyword, this.byExpression, diagnostics, GetAnnotations());

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
        => new GroupClauseSyntax(this.Kind, this.groupKeyword, this.groupExpression, this.byKeyword, this.byExpression, GetDiagnostics(), annotations);

    internal GroupClauseSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 4;
      var groupKeyword = (SyntaxToken)reader.ReadValue();
      if (groupKeyword != null)
      {
         AdjustFlagsAndWidth(groupKeyword);
         this.groupKeyword = groupKeyword;
      }
      var groupExpression = (ExpressionSyntax)reader.ReadValue();
      if (groupExpression != null)
      {
         AdjustFlagsAndWidth(groupExpression);
         this.groupExpression = groupExpression;
      }
      var byKeyword = (SyntaxToken)reader.ReadValue();
      if (byKeyword != null)
      {
         AdjustFlagsAndWidth(byKeyword);
         this.byKeyword = byKeyword;
      }
      var byExpression = (ExpressionSyntax)reader.ReadValue();
      if (byExpression != null)
      {
         AdjustFlagsAndWidth(byExpression);
         this.byExpression = byExpression;
      }
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.groupKeyword);
      writer.WriteValue(this.groupExpression);
      writer.WriteValue(this.byKeyword);
      writer.WriteValue(this.byExpression);
    }

    static GroupClauseSyntax()
    {
       ObjectBinder.RegisterTypeReader(typeof(GroupClauseSyntax), r => new GroupClauseSyntax(r));
    }
  }

  internal sealed partial class QueryContinuationSyntax : CSharpSyntaxNode
  {
    internal readonly SyntaxToken intoKeyword;
    internal readonly SyntaxToken identifier;
    internal readonly QueryBodySyntax body;

    internal QueryContinuationSyntax(SyntaxKind kind, SyntaxToken intoKeyword, SyntaxToken identifier, QueryBodySyntax body, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 3;
        this.AdjustFlagsAndWidth(intoKeyword);
        this.intoKeyword = intoKeyword;
        this.AdjustFlagsAndWidth(identifier);
        this.identifier = identifier;
        this.AdjustFlagsAndWidth(body);
        this.body = body;
    }


    internal QueryContinuationSyntax(SyntaxKind kind, SyntaxToken intoKeyword, SyntaxToken identifier, QueryBodySyntax body, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 3;
        this.AdjustFlagsAndWidth(intoKeyword);
        this.intoKeyword = intoKeyword;
        this.AdjustFlagsAndWidth(identifier);
        this.identifier = identifier;
        this.AdjustFlagsAndWidth(body);
        this.body = body;
    }


    internal QueryContinuationSyntax(SyntaxKind kind, SyntaxToken intoKeyword, SyntaxToken identifier, QueryBodySyntax body)
        : base(kind)
    {
        this.SlotCount = 3;
        this.AdjustFlagsAndWidth(intoKeyword);
        this.intoKeyword = intoKeyword;
        this.AdjustFlagsAndWidth(identifier);
        this.identifier = identifier;
        this.AdjustFlagsAndWidth(body);
        this.body = body;
    }

    public SyntaxToken IntoKeyword => this.intoKeyword;
    /// <summary>Gets the identifier.</summary>
    public SyntaxToken Identifier => this.identifier;
    public QueryBodySyntax Body => this.body;

    internal override GreenNode? GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.intoKeyword;
            case 1: return this.identifier;
            case 2: return this.body;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new CSharp.Syntax.QueryContinuationSyntax(this, parent, position);

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor) => visitor.VisitQueryContinuation(this);

    public override void Accept(CSharpSyntaxVisitor visitor) => visitor.VisitQueryContinuation(this);

    public QueryContinuationSyntax Update(SyntaxToken intoKeyword, SyntaxToken identifier, QueryBodySyntax body)
    {
        if (intoKeyword != this.IntoKeyword || identifier != this.Identifier || body != this.Body)
        {
            var newNode = SyntaxFactory.QueryContinuation(intoKeyword, identifier, body);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
        => new QueryContinuationSyntax(this.Kind, this.intoKeyword, this.identifier, this.body, diagnostics, GetAnnotations());

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
        => new QueryContinuationSyntax(this.Kind, this.intoKeyword, this.identifier, this.body, GetDiagnostics(), annotations);

    internal QueryContinuationSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 3;
      var intoKeyword = (SyntaxToken)reader.ReadValue();
      if (intoKeyword != null)
      {
         AdjustFlagsAndWidth(intoKeyword);
         this.intoKeyword = intoKeyword;
      }
      var identifier = (SyntaxToken)reader.ReadValue();
      if (identifier != null)
      {
         AdjustFlagsAndWidth(identifier);
         this.identifier = identifier;
      }
      var body = (QueryBodySyntax)reader.ReadValue();
      if (body != null)
      {
         AdjustFlagsAndWidth(body);
         this.body = body;
      }
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.intoKeyword);
      writer.WriteValue(this.identifier);
      writer.WriteValue(this.body);
    }

    static QueryContinuationSyntax()
    {
       ObjectBinder.RegisterTypeReader(typeof(QueryContinuationSyntax), r => new QueryContinuationSyntax(r));
    }
  }

  /// <summary>Class which represents a placeholder in an array size list.</summary>
  internal sealed partial class OmittedArraySizeExpressionSyntax : ExpressionSyntax
  {
    internal readonly SyntaxToken omittedArraySizeExpressionToken;

    internal OmittedArraySizeExpressionSyntax(SyntaxKind kind, SyntaxToken omittedArraySizeExpressionToken, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 1;
        this.AdjustFlagsAndWidth(omittedArraySizeExpressionToken);
        this.omittedArraySizeExpressionToken = omittedArraySizeExpressionToken;
    }


    internal OmittedArraySizeExpressionSyntax(SyntaxKind kind, SyntaxToken omittedArraySizeExpressionToken, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 1;
        this.AdjustFlagsAndWidth(omittedArraySizeExpressionToken);
        this.omittedArraySizeExpressionToken = omittedArraySizeExpressionToken;
    }


    internal OmittedArraySizeExpressionSyntax(SyntaxKind kind, SyntaxToken omittedArraySizeExpressionToken)
        : base(kind)
    {
        this.SlotCount = 1;
        this.AdjustFlagsAndWidth(omittedArraySizeExpressionToken);
        this.omittedArraySizeExpressionToken = omittedArraySizeExpressionToken;
    }

    /// <summary>SyntaxToken representing the omitted array size expression.</summary>
    public SyntaxToken OmittedArraySizeExpressionToken => this.omittedArraySizeExpressionToken;

    internal override GreenNode? GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.omittedArraySizeExpressionToken;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new CSharp.Syntax.OmittedArraySizeExpressionSyntax(this, parent, position);

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor) => visitor.VisitOmittedArraySizeExpression(this);

    public override void Accept(CSharpSyntaxVisitor visitor) => visitor.VisitOmittedArraySizeExpression(this);

    public OmittedArraySizeExpressionSyntax Update(SyntaxToken omittedArraySizeExpressionToken)
    {
        if (omittedArraySizeExpressionToken != this.OmittedArraySizeExpressionToken)
        {
            var newNode = SyntaxFactory.OmittedArraySizeExpression(omittedArraySizeExpressionToken);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
        => new OmittedArraySizeExpressionSyntax(this.Kind, this.omittedArraySizeExpressionToken, diagnostics, GetAnnotations());

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
        => new OmittedArraySizeExpressionSyntax(this.Kind, this.omittedArraySizeExpressionToken, GetDiagnostics(), annotations);

    internal OmittedArraySizeExpressionSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 1;
      var omittedArraySizeExpressionToken = (SyntaxToken)reader.ReadValue();
      if (omittedArraySizeExpressionToken != null)
      {
         AdjustFlagsAndWidth(omittedArraySizeExpressionToken);
         this.omittedArraySizeExpressionToken = omittedArraySizeExpressionToken;
      }
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.omittedArraySizeExpressionToken);
    }

    static OmittedArraySizeExpressionSyntax()
    {
       ObjectBinder.RegisterTypeReader(typeof(OmittedArraySizeExpressionSyntax), r => new OmittedArraySizeExpressionSyntax(r));
    }
  }

  internal sealed partial class InterpolatedStringExpressionSyntax : ExpressionSyntax
  {
    internal readonly SyntaxToken stringStartToken;
    internal readonly GreenNode? contents;
    internal readonly SyntaxToken stringEndToken;

    internal InterpolatedStringExpressionSyntax(SyntaxKind kind, SyntaxToken stringStartToken, GreenNode? contents, SyntaxToken stringEndToken, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 3;
        this.AdjustFlagsAndWidth(stringStartToken);
        this.stringStartToken = stringStartToken;
        if (contents != null)
        {
            this.AdjustFlagsAndWidth(contents);
            this.contents = contents;
        }
        this.AdjustFlagsAndWidth(stringEndToken);
        this.stringEndToken = stringEndToken;
    }


    internal InterpolatedStringExpressionSyntax(SyntaxKind kind, SyntaxToken stringStartToken, GreenNode? contents, SyntaxToken stringEndToken, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 3;
        this.AdjustFlagsAndWidth(stringStartToken);
        this.stringStartToken = stringStartToken;
        if (contents != null)
        {
            this.AdjustFlagsAndWidth(contents);
            this.contents = contents;
        }
        this.AdjustFlagsAndWidth(stringEndToken);
        this.stringEndToken = stringEndToken;
    }


    internal InterpolatedStringExpressionSyntax(SyntaxKind kind, SyntaxToken stringStartToken, GreenNode? contents, SyntaxToken stringEndToken)
        : base(kind)
    {
        this.SlotCount = 3;
        this.AdjustFlagsAndWidth(stringStartToken);
        this.stringStartToken = stringStartToken;
        if (contents != null)
        {
            this.AdjustFlagsAndWidth(contents);
            this.contents = contents;
        }
        this.AdjustFlagsAndWidth(stringEndToken);
        this.stringEndToken = stringEndToken;
    }

    /// <summary>The first part of an interpolated string, $" or $@"</summary>
    public SyntaxToken StringStartToken => this.stringStartToken;
    /// <summary>List of parts of the interpolated string, each one is either a literal part or an interpolation.</summary>
    public Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<InterpolatedStringContentSyntax> Contents => new Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<InterpolatedStringContentSyntax>(this.contents);
    /// <summary>The closing quote of the interpolated string.</summary>
    public SyntaxToken StringEndToken => this.stringEndToken;

    internal override GreenNode? GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.stringStartToken;
            case 1: return this.contents;
            case 2: return this.stringEndToken;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new CSharp.Syntax.InterpolatedStringExpressionSyntax(this, parent, position);

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor) => visitor.VisitInterpolatedStringExpression(this);

    public override void Accept(CSharpSyntaxVisitor visitor) => visitor.VisitInterpolatedStringExpression(this);

    public InterpolatedStringExpressionSyntax Update(SyntaxToken stringStartToken, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<InterpolatedStringContentSyntax> contents, SyntaxToken stringEndToken)
    {
        if (stringStartToken != this.StringStartToken || contents != this.Contents || stringEndToken != this.StringEndToken)
        {
            var newNode = SyntaxFactory.InterpolatedStringExpression(stringStartToken, contents, stringEndToken);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
        => new InterpolatedStringExpressionSyntax(this.Kind, this.stringStartToken, this.contents, this.stringEndToken, diagnostics, GetAnnotations());

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
        => new InterpolatedStringExpressionSyntax(this.Kind, this.stringStartToken, this.contents, this.stringEndToken, GetDiagnostics(), annotations);

    internal InterpolatedStringExpressionSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 3;
      var stringStartToken = (SyntaxToken)reader.ReadValue();
      if (stringStartToken != null)
      {
         AdjustFlagsAndWidth(stringStartToken);
         this.stringStartToken = stringStartToken;
      }
      var contents = (GreenNode?)reader.ReadValue();
      if (contents != null)
      {
         AdjustFlagsAndWidth(contents);
         this.contents = contents;
      }
      var stringEndToken = (SyntaxToken)reader.ReadValue();
      if (stringEndToken != null)
      {
         AdjustFlagsAndWidth(stringEndToken);
         this.stringEndToken = stringEndToken;
      }
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.stringStartToken);
      writer.WriteValue(this.contents);
      writer.WriteValue(this.stringEndToken);
    }

    static InterpolatedStringExpressionSyntax()
    {
       ObjectBinder.RegisterTypeReader(typeof(InterpolatedStringExpressionSyntax), r => new InterpolatedStringExpressionSyntax(r));
    }
  }

  /// <summary>Class which represents a simple pattern-matching expression using the "is" keyword.</summary>
  internal sealed partial class IsPatternExpressionSyntax : ExpressionSyntax
  {
    internal readonly ExpressionSyntax expression;
    internal readonly SyntaxToken isKeyword;
    internal readonly PatternSyntax pattern;

    internal IsPatternExpressionSyntax(SyntaxKind kind, ExpressionSyntax expression, SyntaxToken isKeyword, PatternSyntax pattern, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 3;
        this.AdjustFlagsAndWidth(expression);
        this.expression = expression;
        this.AdjustFlagsAndWidth(isKeyword);
        this.isKeyword = isKeyword;
        this.AdjustFlagsAndWidth(pattern);
        this.pattern = pattern;
    }


    internal IsPatternExpressionSyntax(SyntaxKind kind, ExpressionSyntax expression, SyntaxToken isKeyword, PatternSyntax pattern, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 3;
        this.AdjustFlagsAndWidth(expression);
        this.expression = expression;
        this.AdjustFlagsAndWidth(isKeyword);
        this.isKeyword = isKeyword;
        this.AdjustFlagsAndWidth(pattern);
        this.pattern = pattern;
    }


    internal IsPatternExpressionSyntax(SyntaxKind kind, ExpressionSyntax expression, SyntaxToken isKeyword, PatternSyntax pattern)
        : base(kind)
    {
        this.SlotCount = 3;
        this.AdjustFlagsAndWidth(expression);
        this.expression = expression;
        this.AdjustFlagsAndWidth(isKeyword);
        this.isKeyword = isKeyword;
        this.AdjustFlagsAndWidth(pattern);
        this.pattern = pattern;
    }

    /// <summary>ExpressionSyntax node representing the expression on the left of the "is" operator.</summary>
    public ExpressionSyntax Expression => this.expression;
    public SyntaxToken IsKeyword => this.isKeyword;
    /// <summary>PatternSyntax node representing the pattern on the right of the "is" operator.</summary>
    public PatternSyntax Pattern => this.pattern;

    internal override GreenNode? GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.expression;
            case 1: return this.isKeyword;
            case 2: return this.pattern;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new CSharp.Syntax.IsPatternExpressionSyntax(this, parent, position);

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor) => visitor.VisitIsPatternExpression(this);

    public override void Accept(CSharpSyntaxVisitor visitor) => visitor.VisitIsPatternExpression(this);

    public IsPatternExpressionSyntax Update(ExpressionSyntax expression, SyntaxToken isKeyword, PatternSyntax pattern)
    {
        if (expression != this.Expression || isKeyword != this.IsKeyword || pattern != this.Pattern)
        {
            var newNode = SyntaxFactory.IsPatternExpression(expression, isKeyword, pattern);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
        => new IsPatternExpressionSyntax(this.Kind, this.expression, this.isKeyword, this.pattern, diagnostics, GetAnnotations());

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
        => new IsPatternExpressionSyntax(this.Kind, this.expression, this.isKeyword, this.pattern, GetDiagnostics(), annotations);

    internal IsPatternExpressionSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 3;
      var expression = (ExpressionSyntax)reader.ReadValue();
      if (expression != null)
      {
         AdjustFlagsAndWidth(expression);
         this.expression = expression;
      }
      var isKeyword = (SyntaxToken)reader.ReadValue();
      if (isKeyword != null)
      {
         AdjustFlagsAndWidth(isKeyword);
         this.isKeyword = isKeyword;
      }
      var pattern = (PatternSyntax)reader.ReadValue();
      if (pattern != null)
      {
         AdjustFlagsAndWidth(pattern);
         this.pattern = pattern;
      }
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.expression);
      writer.WriteValue(this.isKeyword);
      writer.WriteValue(this.pattern);
    }

    static IsPatternExpressionSyntax()
    {
       ObjectBinder.RegisterTypeReader(typeof(IsPatternExpressionSyntax), r => new IsPatternExpressionSyntax(r));
    }
  }

  internal sealed partial class ThrowExpressionSyntax : ExpressionSyntax
  {
    internal readonly SyntaxToken throwKeyword;
    internal readonly ExpressionSyntax expression;

    internal ThrowExpressionSyntax(SyntaxKind kind, SyntaxToken throwKeyword, ExpressionSyntax expression, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 2;
        this.AdjustFlagsAndWidth(throwKeyword);
        this.throwKeyword = throwKeyword;
        this.AdjustFlagsAndWidth(expression);
        this.expression = expression;
    }


    internal ThrowExpressionSyntax(SyntaxKind kind, SyntaxToken throwKeyword, ExpressionSyntax expression, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 2;
        this.AdjustFlagsAndWidth(throwKeyword);
        this.throwKeyword = throwKeyword;
        this.AdjustFlagsAndWidth(expression);
        this.expression = expression;
    }


    internal ThrowExpressionSyntax(SyntaxKind kind, SyntaxToken throwKeyword, ExpressionSyntax expression)
        : base(kind)
    {
        this.SlotCount = 2;
        this.AdjustFlagsAndWidth(throwKeyword);
        this.throwKeyword = throwKeyword;
        this.AdjustFlagsAndWidth(expression);
        this.expression = expression;
    }

    public SyntaxToken ThrowKeyword => this.throwKeyword;
    public ExpressionSyntax Expression => this.expression;

    internal override GreenNode? GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.throwKeyword;
            case 1: return this.expression;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new CSharp.Syntax.ThrowExpressionSyntax(this, parent, position);

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor) => visitor.VisitThrowExpression(this);

    public override void Accept(CSharpSyntaxVisitor visitor) => visitor.VisitThrowExpression(this);

    public ThrowExpressionSyntax Update(SyntaxToken throwKeyword, ExpressionSyntax expression)
    {
        if (throwKeyword != this.ThrowKeyword || expression != this.Expression)
        {
            var newNode = SyntaxFactory.ThrowExpression(throwKeyword, expression);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
        => new ThrowExpressionSyntax(this.Kind, this.throwKeyword, this.expression, diagnostics, GetAnnotations());

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
        => new ThrowExpressionSyntax(this.Kind, this.throwKeyword, this.expression, GetDiagnostics(), annotations);

    internal ThrowExpressionSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 2;
      var throwKeyword = (SyntaxToken)reader.ReadValue();
      if (throwKeyword != null)
      {
         AdjustFlagsAndWidth(throwKeyword);
         this.throwKeyword = throwKeyword;
      }
      var expression = (ExpressionSyntax)reader.ReadValue();
      if (expression != null)
      {
         AdjustFlagsAndWidth(expression);
         this.expression = expression;
      }
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.throwKeyword);
      writer.WriteValue(this.expression);
    }

    static ThrowExpressionSyntax()
    {
       ObjectBinder.RegisterTypeReader(typeof(ThrowExpressionSyntax), r => new ThrowExpressionSyntax(r));
    }
  }

  internal sealed partial class WhenClauseSyntax : CSharpSyntaxNode
  {
    internal readonly SyntaxToken whenKeyword;
    internal readonly ExpressionSyntax condition;

    internal WhenClauseSyntax(SyntaxKind kind, SyntaxToken whenKeyword, ExpressionSyntax condition, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 2;
        this.AdjustFlagsAndWidth(whenKeyword);
        this.whenKeyword = whenKeyword;
        this.AdjustFlagsAndWidth(condition);
        this.condition = condition;
    }


    internal WhenClauseSyntax(SyntaxKind kind, SyntaxToken whenKeyword, ExpressionSyntax condition, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 2;
        this.AdjustFlagsAndWidth(whenKeyword);
        this.whenKeyword = whenKeyword;
        this.AdjustFlagsAndWidth(condition);
        this.condition = condition;
    }


    internal WhenClauseSyntax(SyntaxKind kind, SyntaxToken whenKeyword, ExpressionSyntax condition)
        : base(kind)
    {
        this.SlotCount = 2;
        this.AdjustFlagsAndWidth(whenKeyword);
        this.whenKeyword = whenKeyword;
        this.AdjustFlagsAndWidth(condition);
        this.condition = condition;
    }

    public SyntaxToken WhenKeyword => this.whenKeyword;
    public ExpressionSyntax Condition => this.condition;

    internal override GreenNode? GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.whenKeyword;
            case 1: return this.condition;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new CSharp.Syntax.WhenClauseSyntax(this, parent, position);

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor) => visitor.VisitWhenClause(this);

    public override void Accept(CSharpSyntaxVisitor visitor) => visitor.VisitWhenClause(this);

    public WhenClauseSyntax Update(SyntaxToken whenKeyword, ExpressionSyntax condition)
    {
        if (whenKeyword != this.WhenKeyword || condition != this.Condition)
        {
            var newNode = SyntaxFactory.WhenClause(whenKeyword, condition);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
        => new WhenClauseSyntax(this.Kind, this.whenKeyword, this.condition, diagnostics, GetAnnotations());

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
        => new WhenClauseSyntax(this.Kind, this.whenKeyword, this.condition, GetDiagnostics(), annotations);

    internal WhenClauseSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 2;
      var whenKeyword = (SyntaxToken)reader.ReadValue();
      if (whenKeyword != null)
      {
         AdjustFlagsAndWidth(whenKeyword);
         this.whenKeyword = whenKeyword;
      }
      var condition = (ExpressionSyntax)reader.ReadValue();
      if (condition != null)
      {
         AdjustFlagsAndWidth(condition);
         this.condition = condition;
      }
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.whenKeyword);
      writer.WriteValue(this.condition);
    }

    static WhenClauseSyntax()
    {
       ObjectBinder.RegisterTypeReader(typeof(WhenClauseSyntax), r => new WhenClauseSyntax(r));
    }
  }

  internal abstract partial class PatternSyntax : CSharpSyntaxNode
  {
    internal PatternSyntax(SyntaxKind kind, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
      : base(kind, diagnostics, annotations)
    {
    }
    internal PatternSyntax(SyntaxKind kind)
      : base(kind)
    {
    }

    protected PatternSyntax(ObjectReader reader)
       : base(reader)
    {
    }
  }

  internal sealed partial class DiscardPatternSyntax : PatternSyntax
  {
    internal readonly SyntaxToken underscoreToken;

    internal DiscardPatternSyntax(SyntaxKind kind, SyntaxToken underscoreToken, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 1;
        this.AdjustFlagsAndWidth(underscoreToken);
        this.underscoreToken = underscoreToken;
    }


    internal DiscardPatternSyntax(SyntaxKind kind, SyntaxToken underscoreToken, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 1;
        this.AdjustFlagsAndWidth(underscoreToken);
        this.underscoreToken = underscoreToken;
    }


    internal DiscardPatternSyntax(SyntaxKind kind, SyntaxToken underscoreToken)
        : base(kind)
    {
        this.SlotCount = 1;
        this.AdjustFlagsAndWidth(underscoreToken);
        this.underscoreToken = underscoreToken;
    }

    public SyntaxToken UnderscoreToken => this.underscoreToken;

    internal override GreenNode? GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.underscoreToken;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new CSharp.Syntax.DiscardPatternSyntax(this, parent, position);

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor) => visitor.VisitDiscardPattern(this);

    public override void Accept(CSharpSyntaxVisitor visitor) => visitor.VisitDiscardPattern(this);

    public DiscardPatternSyntax Update(SyntaxToken underscoreToken)
    {
        if (underscoreToken != this.UnderscoreToken)
        {
            var newNode = SyntaxFactory.DiscardPattern(underscoreToken);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
        => new DiscardPatternSyntax(this.Kind, this.underscoreToken, diagnostics, GetAnnotations());

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
        => new DiscardPatternSyntax(this.Kind, this.underscoreToken, GetDiagnostics(), annotations);

    internal DiscardPatternSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 1;
      var underscoreToken = (SyntaxToken)reader.ReadValue();
      if (underscoreToken != null)
      {
         AdjustFlagsAndWidth(underscoreToken);
         this.underscoreToken = underscoreToken;
      }
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.underscoreToken);
    }

    static DiscardPatternSyntax()
    {
       ObjectBinder.RegisterTypeReader(typeof(DiscardPatternSyntax), r => new DiscardPatternSyntax(r));
    }
  }

  internal sealed partial class DeclarationPatternSyntax : PatternSyntax
  {
    internal readonly TypeSyntax type;
    internal readonly VariableDesignationSyntax designation;

    internal DeclarationPatternSyntax(SyntaxKind kind, TypeSyntax type, VariableDesignationSyntax designation, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 2;
        this.AdjustFlagsAndWidth(type);
        this.type = type;
        this.AdjustFlagsAndWidth(designation);
        this.designation = designation;
    }


    internal DeclarationPatternSyntax(SyntaxKind kind, TypeSyntax type, VariableDesignationSyntax designation, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 2;
        this.AdjustFlagsAndWidth(type);
        this.type = type;
        this.AdjustFlagsAndWidth(designation);
        this.designation = designation;
    }


    internal DeclarationPatternSyntax(SyntaxKind kind, TypeSyntax type, VariableDesignationSyntax designation)
        : base(kind)
    {
        this.SlotCount = 2;
        this.AdjustFlagsAndWidth(type);
        this.type = type;
        this.AdjustFlagsAndWidth(designation);
        this.designation = designation;
    }

    public TypeSyntax Type => this.type;
    public VariableDesignationSyntax Designation => this.designation;

    internal override GreenNode? GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.type;
            case 1: return this.designation;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new CSharp.Syntax.DeclarationPatternSyntax(this, parent, position);

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor) => visitor.VisitDeclarationPattern(this);

    public override void Accept(CSharpSyntaxVisitor visitor) => visitor.VisitDeclarationPattern(this);

    public DeclarationPatternSyntax Update(TypeSyntax type, VariableDesignationSyntax designation)
    {
        if (type != this.Type || designation != this.Designation)
        {
            var newNode = SyntaxFactory.DeclarationPattern(type, designation);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
        => new DeclarationPatternSyntax(this.Kind, this.type, this.designation, diagnostics, GetAnnotations());

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
        => new DeclarationPatternSyntax(this.Kind, this.type, this.designation, GetDiagnostics(), annotations);

    internal DeclarationPatternSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 2;
      var type = (TypeSyntax)reader.ReadValue();
      if (type != null)
      {
         AdjustFlagsAndWidth(type);
         this.type = type;
      }
      var designation = (VariableDesignationSyntax)reader.ReadValue();
      if (designation != null)
      {
         AdjustFlagsAndWidth(designation);
         this.designation = designation;
      }
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.type);
      writer.WriteValue(this.designation);
    }

    static DeclarationPatternSyntax()
    {
       ObjectBinder.RegisterTypeReader(typeof(DeclarationPatternSyntax), r => new DeclarationPatternSyntax(r));
    }
  }

  internal sealed partial class VarPatternSyntax : PatternSyntax
  {
    internal readonly SyntaxToken varKeyword;
    internal readonly VariableDesignationSyntax designation;

    internal VarPatternSyntax(SyntaxKind kind, SyntaxToken varKeyword, VariableDesignationSyntax designation, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 2;
        this.AdjustFlagsAndWidth(varKeyword);
        this.varKeyword = varKeyword;
        this.AdjustFlagsAndWidth(designation);
        this.designation = designation;
    }


    internal VarPatternSyntax(SyntaxKind kind, SyntaxToken varKeyword, VariableDesignationSyntax designation, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 2;
        this.AdjustFlagsAndWidth(varKeyword);
        this.varKeyword = varKeyword;
        this.AdjustFlagsAndWidth(designation);
        this.designation = designation;
    }


    internal VarPatternSyntax(SyntaxKind kind, SyntaxToken varKeyword, VariableDesignationSyntax designation)
        : base(kind)
    {
        this.SlotCount = 2;
        this.AdjustFlagsAndWidth(varKeyword);
        this.varKeyword = varKeyword;
        this.AdjustFlagsAndWidth(designation);
        this.designation = designation;
    }

    public SyntaxToken VarKeyword => this.varKeyword;
    public VariableDesignationSyntax Designation => this.designation;

    internal override GreenNode? GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.varKeyword;
            case 1: return this.designation;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new CSharp.Syntax.VarPatternSyntax(this, parent, position);

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor) => visitor.VisitVarPattern(this);

    public override void Accept(CSharpSyntaxVisitor visitor) => visitor.VisitVarPattern(this);

    public VarPatternSyntax Update(SyntaxToken varKeyword, VariableDesignationSyntax designation)
    {
        if (varKeyword != this.VarKeyword || designation != this.Designation)
        {
            var newNode = SyntaxFactory.VarPattern(varKeyword, designation);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
        => new VarPatternSyntax(this.Kind, this.varKeyword, this.designation, diagnostics, GetAnnotations());

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
        => new VarPatternSyntax(this.Kind, this.varKeyword, this.designation, GetDiagnostics(), annotations);

    internal VarPatternSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 2;
      var varKeyword = (SyntaxToken)reader.ReadValue();
      if (varKeyword != null)
      {
         AdjustFlagsAndWidth(varKeyword);
         this.varKeyword = varKeyword;
      }
      var designation = (VariableDesignationSyntax)reader.ReadValue();
      if (designation != null)
      {
         AdjustFlagsAndWidth(designation);
         this.designation = designation;
      }
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.varKeyword);
      writer.WriteValue(this.designation);
    }

    static VarPatternSyntax()
    {
       ObjectBinder.RegisterTypeReader(typeof(VarPatternSyntax), r => new VarPatternSyntax(r));
    }
  }

  internal sealed partial class RecursivePatternSyntax : PatternSyntax
  {
    internal readonly TypeSyntax? type;
    internal readonly PositionalPatternClauseSyntax? positionalPatternClause;
    internal readonly PropertyPatternClauseSyntax? propertyPatternClause;
    internal readonly VariableDesignationSyntax? designation;

    internal RecursivePatternSyntax(SyntaxKind kind, TypeSyntax? type, PositionalPatternClauseSyntax? positionalPatternClause, PropertyPatternClauseSyntax? propertyPatternClause, VariableDesignationSyntax? designation, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 4;
        if (type != null)
        {
            this.AdjustFlagsAndWidth(type);
            this.type = type;
        }
        if (positionalPatternClause != null)
        {
            this.AdjustFlagsAndWidth(positionalPatternClause);
            this.positionalPatternClause = positionalPatternClause;
        }
        if (propertyPatternClause != null)
        {
            this.AdjustFlagsAndWidth(propertyPatternClause);
            this.propertyPatternClause = propertyPatternClause;
        }
        if (designation != null)
        {
            this.AdjustFlagsAndWidth(designation);
            this.designation = designation;
        }
    }


    internal RecursivePatternSyntax(SyntaxKind kind, TypeSyntax? type, PositionalPatternClauseSyntax? positionalPatternClause, PropertyPatternClauseSyntax? propertyPatternClause, VariableDesignationSyntax? designation, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 4;
        if (type != null)
        {
            this.AdjustFlagsAndWidth(type);
            this.type = type;
        }
        if (positionalPatternClause != null)
        {
            this.AdjustFlagsAndWidth(positionalPatternClause);
            this.positionalPatternClause = positionalPatternClause;
        }
        if (propertyPatternClause != null)
        {
            this.AdjustFlagsAndWidth(propertyPatternClause);
            this.propertyPatternClause = propertyPatternClause;
        }
        if (designation != null)
        {
            this.AdjustFlagsAndWidth(designation);
            this.designation = designation;
        }
    }


    internal RecursivePatternSyntax(SyntaxKind kind, TypeSyntax? type, PositionalPatternClauseSyntax? positionalPatternClause, PropertyPatternClauseSyntax? propertyPatternClause, VariableDesignationSyntax? designation)
        : base(kind)
    {
        this.SlotCount = 4;
        if (type != null)
        {
            this.AdjustFlagsAndWidth(type);
            this.type = type;
        }
        if (positionalPatternClause != null)
        {
            this.AdjustFlagsAndWidth(positionalPatternClause);
            this.positionalPatternClause = positionalPatternClause;
        }
        if (propertyPatternClause != null)
        {
            this.AdjustFlagsAndWidth(propertyPatternClause);
            this.propertyPatternClause = propertyPatternClause;
        }
        if (designation != null)
        {
            this.AdjustFlagsAndWidth(designation);
            this.designation = designation;
        }
    }

    public TypeSyntax? Type => this.type;
    public PositionalPatternClauseSyntax? PositionalPatternClause => this.positionalPatternClause;
    public PropertyPatternClauseSyntax? PropertyPatternClause => this.propertyPatternClause;
    public VariableDesignationSyntax? Designation => this.designation;

    internal override GreenNode? GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.type;
            case 1: return this.positionalPatternClause;
            case 2: return this.propertyPatternClause;
            case 3: return this.designation;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new CSharp.Syntax.RecursivePatternSyntax(this, parent, position);

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor) => visitor.VisitRecursivePattern(this);

    public override void Accept(CSharpSyntaxVisitor visitor) => visitor.VisitRecursivePattern(this);

    public RecursivePatternSyntax Update(TypeSyntax type, PositionalPatternClauseSyntax positionalPatternClause, PropertyPatternClauseSyntax propertyPatternClause, VariableDesignationSyntax designation)
    {
        if (type != this.Type || positionalPatternClause != this.PositionalPatternClause || propertyPatternClause != this.PropertyPatternClause || designation != this.Designation)
        {
            var newNode = SyntaxFactory.RecursivePattern(type, positionalPatternClause, propertyPatternClause, designation);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
        => new RecursivePatternSyntax(this.Kind, this.type, this.positionalPatternClause, this.propertyPatternClause, this.designation, diagnostics, GetAnnotations());

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
        => new RecursivePatternSyntax(this.Kind, this.type, this.positionalPatternClause, this.propertyPatternClause, this.designation, GetDiagnostics(), annotations);

    internal RecursivePatternSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 4;
      var type = (TypeSyntax?)reader.ReadValue();
      if (type != null)
      {
         AdjustFlagsAndWidth(type);
         this.type = type;
      }
      var positionalPatternClause = (PositionalPatternClauseSyntax?)reader.ReadValue();
      if (positionalPatternClause != null)
      {
         AdjustFlagsAndWidth(positionalPatternClause);
         this.positionalPatternClause = positionalPatternClause;
      }
      var propertyPatternClause = (PropertyPatternClauseSyntax?)reader.ReadValue();
      if (propertyPatternClause != null)
      {
         AdjustFlagsAndWidth(propertyPatternClause);
         this.propertyPatternClause = propertyPatternClause;
      }
      var designation = (VariableDesignationSyntax?)reader.ReadValue();
      if (designation != null)
      {
         AdjustFlagsAndWidth(designation);
         this.designation = designation;
      }
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.type);
      writer.WriteValue(this.positionalPatternClause);
      writer.WriteValue(this.propertyPatternClause);
      writer.WriteValue(this.designation);
    }

    static RecursivePatternSyntax()
    {
       ObjectBinder.RegisterTypeReader(typeof(RecursivePatternSyntax), r => new RecursivePatternSyntax(r));
    }
  }

  internal sealed partial class PositionalPatternClauseSyntax : CSharpSyntaxNode
  {
    internal readonly SyntaxToken openParenToken;
    internal readonly GreenNode? subpatterns;
    internal readonly SyntaxToken closeParenToken;

    internal PositionalPatternClauseSyntax(SyntaxKind kind, SyntaxToken openParenToken, GreenNode? subpatterns, SyntaxToken closeParenToken, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 3;
        this.AdjustFlagsAndWidth(openParenToken);
        this.openParenToken = openParenToken;
        if (subpatterns != null)
        {
            this.AdjustFlagsAndWidth(subpatterns);
            this.subpatterns = subpatterns;
        }
        this.AdjustFlagsAndWidth(closeParenToken);
        this.closeParenToken = closeParenToken;
    }


    internal PositionalPatternClauseSyntax(SyntaxKind kind, SyntaxToken openParenToken, GreenNode? subpatterns, SyntaxToken closeParenToken, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 3;
        this.AdjustFlagsAndWidth(openParenToken);
        this.openParenToken = openParenToken;
        if (subpatterns != null)
        {
            this.AdjustFlagsAndWidth(subpatterns);
            this.subpatterns = subpatterns;
        }
        this.AdjustFlagsAndWidth(closeParenToken);
        this.closeParenToken = closeParenToken;
    }


    internal PositionalPatternClauseSyntax(SyntaxKind kind, SyntaxToken openParenToken, GreenNode? subpatterns, SyntaxToken closeParenToken)
        : base(kind)
    {
        this.SlotCount = 3;
        this.AdjustFlagsAndWidth(openParenToken);
        this.openParenToken = openParenToken;
        if (subpatterns != null)
        {
            this.AdjustFlagsAndWidth(subpatterns);
            this.subpatterns = subpatterns;
        }
        this.AdjustFlagsAndWidth(closeParenToken);
        this.closeParenToken = closeParenToken;
    }

    public SyntaxToken OpenParenToken => this.openParenToken;
    public Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<SubpatternSyntax> Subpatterns => new Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<SubpatternSyntax>(new Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<CSharpSyntaxNode>(this.subpatterns));
    public SyntaxToken CloseParenToken => this.closeParenToken;

    internal override GreenNode? GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.openParenToken;
            case 1: return this.subpatterns;
            case 2: return this.closeParenToken;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new CSharp.Syntax.PositionalPatternClauseSyntax(this, parent, position);

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor) => visitor.VisitPositionalPatternClause(this);

    public override void Accept(CSharpSyntaxVisitor visitor) => visitor.VisitPositionalPatternClause(this);

    public PositionalPatternClauseSyntax Update(SyntaxToken openParenToken, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<SubpatternSyntax> subpatterns, SyntaxToken closeParenToken)
    {
        if (openParenToken != this.OpenParenToken || subpatterns != this.Subpatterns || closeParenToken != this.CloseParenToken)
        {
            var newNode = SyntaxFactory.PositionalPatternClause(openParenToken, subpatterns, closeParenToken);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
        => new PositionalPatternClauseSyntax(this.Kind, this.openParenToken, this.subpatterns, this.closeParenToken, diagnostics, GetAnnotations());

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
        => new PositionalPatternClauseSyntax(this.Kind, this.openParenToken, this.subpatterns, this.closeParenToken, GetDiagnostics(), annotations);

    internal PositionalPatternClauseSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 3;
      var openParenToken = (SyntaxToken)reader.ReadValue();
      if (openParenToken != null)
      {
         AdjustFlagsAndWidth(openParenToken);
         this.openParenToken = openParenToken;
      }
      var subpatterns = (GreenNode?)reader.ReadValue();
      if (subpatterns != null)
      {
         AdjustFlagsAndWidth(subpatterns);
         this.subpatterns = subpatterns;
      }
      var closeParenToken = (SyntaxToken)reader.ReadValue();
      if (closeParenToken != null)
      {
         AdjustFlagsAndWidth(closeParenToken);
         this.closeParenToken = closeParenToken;
      }
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.openParenToken);
      writer.WriteValue(this.subpatterns);
      writer.WriteValue(this.closeParenToken);
    }

    static PositionalPatternClauseSyntax()
    {
       ObjectBinder.RegisterTypeReader(typeof(PositionalPatternClauseSyntax), r => new PositionalPatternClauseSyntax(r));
    }
  }

  internal sealed partial class PropertyPatternClauseSyntax : CSharpSyntaxNode
  {
    internal readonly SyntaxToken openBraceToken;
    internal readonly GreenNode? subpatterns;
    internal readonly SyntaxToken closeBraceToken;

    internal PropertyPatternClauseSyntax(SyntaxKind kind, SyntaxToken openBraceToken, GreenNode? subpatterns, SyntaxToken closeBraceToken, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 3;
        this.AdjustFlagsAndWidth(openBraceToken);
        this.openBraceToken = openBraceToken;
        if (subpatterns != null)
        {
            this.AdjustFlagsAndWidth(subpatterns);
            this.subpatterns = subpatterns;
        }
        this.AdjustFlagsAndWidth(closeBraceToken);
        this.closeBraceToken = closeBraceToken;
    }


    internal PropertyPatternClauseSyntax(SyntaxKind kind, SyntaxToken openBraceToken, GreenNode? subpatterns, SyntaxToken closeBraceToken, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 3;
        this.AdjustFlagsAndWidth(openBraceToken);
        this.openBraceToken = openBraceToken;
        if (subpatterns != null)
        {
            this.AdjustFlagsAndWidth(subpatterns);
            this.subpatterns = subpatterns;
        }
        this.AdjustFlagsAndWidth(closeBraceToken);
        this.closeBraceToken = closeBraceToken;
    }


    internal PropertyPatternClauseSyntax(SyntaxKind kind, SyntaxToken openBraceToken, GreenNode? subpatterns, SyntaxToken closeBraceToken)
        : base(kind)
    {
        this.SlotCount = 3;
        this.AdjustFlagsAndWidth(openBraceToken);
        this.openBraceToken = openBraceToken;
        if (subpatterns != null)
        {
            this.AdjustFlagsAndWidth(subpatterns);
            this.subpatterns = subpatterns;
        }
        this.AdjustFlagsAndWidth(closeBraceToken);
        this.closeBraceToken = closeBraceToken;
    }

    public SyntaxToken OpenBraceToken => this.openBraceToken;
    public Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<SubpatternSyntax> Subpatterns => new Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<SubpatternSyntax>(new Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<CSharpSyntaxNode>(this.subpatterns));
    public SyntaxToken CloseBraceToken => this.closeBraceToken;

    internal override GreenNode? GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.openBraceToken;
            case 1: return this.subpatterns;
            case 2: return this.closeBraceToken;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new CSharp.Syntax.PropertyPatternClauseSyntax(this, parent, position);

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor) => visitor.VisitPropertyPatternClause(this);

    public override void Accept(CSharpSyntaxVisitor visitor) => visitor.VisitPropertyPatternClause(this);

    public PropertyPatternClauseSyntax Update(SyntaxToken openBraceToken, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<SubpatternSyntax> subpatterns, SyntaxToken closeBraceToken)
    {
        if (openBraceToken != this.OpenBraceToken || subpatterns != this.Subpatterns || closeBraceToken != this.CloseBraceToken)
        {
            var newNode = SyntaxFactory.PropertyPatternClause(openBraceToken, subpatterns, closeBraceToken);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
        => new PropertyPatternClauseSyntax(this.Kind, this.openBraceToken, this.subpatterns, this.closeBraceToken, diagnostics, GetAnnotations());

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
        => new PropertyPatternClauseSyntax(this.Kind, this.openBraceToken, this.subpatterns, this.closeBraceToken, GetDiagnostics(), annotations);

    internal PropertyPatternClauseSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 3;
      var openBraceToken = (SyntaxToken)reader.ReadValue();
      if (openBraceToken != null)
      {
         AdjustFlagsAndWidth(openBraceToken);
         this.openBraceToken = openBraceToken;
      }
      var subpatterns = (GreenNode?)reader.ReadValue();
      if (subpatterns != null)
      {
         AdjustFlagsAndWidth(subpatterns);
         this.subpatterns = subpatterns;
      }
      var closeBraceToken = (SyntaxToken)reader.ReadValue();
      if (closeBraceToken != null)
      {
         AdjustFlagsAndWidth(closeBraceToken);
         this.closeBraceToken = closeBraceToken;
      }
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.openBraceToken);
      writer.WriteValue(this.subpatterns);
      writer.WriteValue(this.closeBraceToken);
    }

    static PropertyPatternClauseSyntax()
    {
       ObjectBinder.RegisterTypeReader(typeof(PropertyPatternClauseSyntax), r => new PropertyPatternClauseSyntax(r));
    }
  }

  internal sealed partial class SubpatternSyntax : CSharpSyntaxNode
  {
    internal readonly NameColonSyntax? nameColon;
    internal readonly PatternSyntax pattern;

    internal SubpatternSyntax(SyntaxKind kind, NameColonSyntax? nameColon, PatternSyntax pattern, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 2;
        if (nameColon != null)
        {
            this.AdjustFlagsAndWidth(nameColon);
            this.nameColon = nameColon;
        }
        this.AdjustFlagsAndWidth(pattern);
        this.pattern = pattern;
    }


    internal SubpatternSyntax(SyntaxKind kind, NameColonSyntax? nameColon, PatternSyntax pattern, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 2;
        if (nameColon != null)
        {
            this.AdjustFlagsAndWidth(nameColon);
            this.nameColon = nameColon;
        }
        this.AdjustFlagsAndWidth(pattern);
        this.pattern = pattern;
    }


    internal SubpatternSyntax(SyntaxKind kind, NameColonSyntax? nameColon, PatternSyntax pattern)
        : base(kind)
    {
        this.SlotCount = 2;
        if (nameColon != null)
        {
            this.AdjustFlagsAndWidth(nameColon);
            this.nameColon = nameColon;
        }
        this.AdjustFlagsAndWidth(pattern);
        this.pattern = pattern;
    }

    public NameColonSyntax? NameColon => this.nameColon;
    public PatternSyntax Pattern => this.pattern;

    internal override GreenNode? GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.nameColon;
            case 1: return this.pattern;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new CSharp.Syntax.SubpatternSyntax(this, parent, position);

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor) => visitor.VisitSubpattern(this);

    public override void Accept(CSharpSyntaxVisitor visitor) => visitor.VisitSubpattern(this);

    public SubpatternSyntax Update(NameColonSyntax nameColon, PatternSyntax pattern)
    {
        if (nameColon != this.NameColon || pattern != this.Pattern)
        {
            var newNode = SyntaxFactory.Subpattern(nameColon, pattern);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
        => new SubpatternSyntax(this.Kind, this.nameColon, this.pattern, diagnostics, GetAnnotations());

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
        => new SubpatternSyntax(this.Kind, this.nameColon, this.pattern, GetDiagnostics(), annotations);

    internal SubpatternSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 2;
      var nameColon = (NameColonSyntax?)reader.ReadValue();
      if (nameColon != null)
      {
         AdjustFlagsAndWidth(nameColon);
         this.nameColon = nameColon;
      }
      var pattern = (PatternSyntax)reader.ReadValue();
      if (pattern != null)
      {
         AdjustFlagsAndWidth(pattern);
         this.pattern = pattern;
      }
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.nameColon);
      writer.WriteValue(this.pattern);
    }

    static SubpatternSyntax()
    {
       ObjectBinder.RegisterTypeReader(typeof(SubpatternSyntax), r => new SubpatternSyntax(r));
    }
  }

  internal sealed partial class ConstantPatternSyntax : PatternSyntax
  {
    internal readonly ExpressionSyntax expression;

    internal ConstantPatternSyntax(SyntaxKind kind, ExpressionSyntax expression, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 1;
        this.AdjustFlagsAndWidth(expression);
        this.expression = expression;
    }


    internal ConstantPatternSyntax(SyntaxKind kind, ExpressionSyntax expression, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 1;
        this.AdjustFlagsAndWidth(expression);
        this.expression = expression;
    }


    internal ConstantPatternSyntax(SyntaxKind kind, ExpressionSyntax expression)
        : base(kind)
    {
        this.SlotCount = 1;
        this.AdjustFlagsAndWidth(expression);
        this.expression = expression;
    }

    /// <summary>ExpressionSyntax node representing the constant expression.</summary>
    public ExpressionSyntax Expression => this.expression;

    internal override GreenNode? GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.expression;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new CSharp.Syntax.ConstantPatternSyntax(this, parent, position);

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor) => visitor.VisitConstantPattern(this);

    public override void Accept(CSharpSyntaxVisitor visitor) => visitor.VisitConstantPattern(this);

    public ConstantPatternSyntax Update(ExpressionSyntax expression)
    {
        if (expression != this.Expression)
        {
            var newNode = SyntaxFactory.ConstantPattern(expression);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
        => new ConstantPatternSyntax(this.Kind, this.expression, diagnostics, GetAnnotations());

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
        => new ConstantPatternSyntax(this.Kind, this.expression, GetDiagnostics(), annotations);

    internal ConstantPatternSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 1;
      var expression = (ExpressionSyntax)reader.ReadValue();
      if (expression != null)
      {
         AdjustFlagsAndWidth(expression);
         this.expression = expression;
      }
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.expression);
    }

    static ConstantPatternSyntax()
    {
       ObjectBinder.RegisterTypeReader(typeof(ConstantPatternSyntax), r => new ConstantPatternSyntax(r));
    }
  }

  internal abstract partial class InterpolatedStringContentSyntax : CSharpSyntaxNode
  {
    internal InterpolatedStringContentSyntax(SyntaxKind kind, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
      : base(kind, diagnostics, annotations)
    {
    }
    internal InterpolatedStringContentSyntax(SyntaxKind kind)
      : base(kind)
    {
    }

    protected InterpolatedStringContentSyntax(ObjectReader reader)
       : base(reader)
    {
    }
  }

  internal sealed partial class InterpolatedStringTextSyntax : InterpolatedStringContentSyntax
  {
    internal readonly SyntaxToken textToken;

    internal InterpolatedStringTextSyntax(SyntaxKind kind, SyntaxToken textToken, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 1;
        this.AdjustFlagsAndWidth(textToken);
        this.textToken = textToken;
    }


    internal InterpolatedStringTextSyntax(SyntaxKind kind, SyntaxToken textToken, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 1;
        this.AdjustFlagsAndWidth(textToken);
        this.textToken = textToken;
    }


    internal InterpolatedStringTextSyntax(SyntaxKind kind, SyntaxToken textToken)
        : base(kind)
    {
        this.SlotCount = 1;
        this.AdjustFlagsAndWidth(textToken);
        this.textToken = textToken;
    }

    /// <summary>The text contents of a part of the interpolated string.</summary>
    public SyntaxToken TextToken => this.textToken;

    internal override GreenNode? GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.textToken;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new CSharp.Syntax.InterpolatedStringTextSyntax(this, parent, position);

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor) => visitor.VisitInterpolatedStringText(this);

    public override void Accept(CSharpSyntaxVisitor visitor) => visitor.VisitInterpolatedStringText(this);

    public InterpolatedStringTextSyntax Update(SyntaxToken textToken)
    {
        if (textToken != this.TextToken)
        {
            var newNode = SyntaxFactory.InterpolatedStringText(textToken);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
        => new InterpolatedStringTextSyntax(this.Kind, this.textToken, diagnostics, GetAnnotations());

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
        => new InterpolatedStringTextSyntax(this.Kind, this.textToken, GetDiagnostics(), annotations);

    internal InterpolatedStringTextSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 1;
      var textToken = (SyntaxToken)reader.ReadValue();
      if (textToken != null)
      {
         AdjustFlagsAndWidth(textToken);
         this.textToken = textToken;
      }
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.textToken);
    }

    static InterpolatedStringTextSyntax()
    {
       ObjectBinder.RegisterTypeReader(typeof(InterpolatedStringTextSyntax), r => new InterpolatedStringTextSyntax(r));
    }
  }

  internal sealed partial class InterpolationSyntax : InterpolatedStringContentSyntax
  {
    internal readonly SyntaxToken openBraceToken;
    internal readonly ExpressionSyntax expression;
    internal readonly InterpolationAlignmentClauseSyntax? alignmentClause;
    internal readonly InterpolationFormatClauseSyntax? formatClause;
    internal readonly SyntaxToken closeBraceToken;

    internal InterpolationSyntax(SyntaxKind kind, SyntaxToken openBraceToken, ExpressionSyntax expression, InterpolationAlignmentClauseSyntax? alignmentClause, InterpolationFormatClauseSyntax? formatClause, SyntaxToken closeBraceToken, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 5;
        this.AdjustFlagsAndWidth(openBraceToken);
        this.openBraceToken = openBraceToken;
        this.AdjustFlagsAndWidth(expression);
        this.expression = expression;
        if (alignmentClause != null)
        {
            this.AdjustFlagsAndWidth(alignmentClause);
            this.alignmentClause = alignmentClause;
        }
        if (formatClause != null)
        {
            this.AdjustFlagsAndWidth(formatClause);
            this.formatClause = formatClause;
        }
        this.AdjustFlagsAndWidth(closeBraceToken);
        this.closeBraceToken = closeBraceToken;
    }


    internal InterpolationSyntax(SyntaxKind kind, SyntaxToken openBraceToken, ExpressionSyntax expression, InterpolationAlignmentClauseSyntax? alignmentClause, InterpolationFormatClauseSyntax? formatClause, SyntaxToken closeBraceToken, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 5;
        this.AdjustFlagsAndWidth(openBraceToken);
        this.openBraceToken = openBraceToken;
        this.AdjustFlagsAndWidth(expression);
        this.expression = expression;
        if (alignmentClause != null)
        {
            this.AdjustFlagsAndWidth(alignmentClause);
            this.alignmentClause = alignmentClause;
        }
        if (formatClause != null)
        {
            this.AdjustFlagsAndWidth(formatClause);
            this.formatClause = formatClause;
        }
        this.AdjustFlagsAndWidth(closeBraceToken);
        this.closeBraceToken = closeBraceToken;
    }


    internal InterpolationSyntax(SyntaxKind kind, SyntaxToken openBraceToken, ExpressionSyntax expression, InterpolationAlignmentClauseSyntax? alignmentClause, InterpolationFormatClauseSyntax? formatClause, SyntaxToken closeBraceToken)
        : base(kind)
    {
        this.SlotCount = 5;
        this.AdjustFlagsAndWidth(openBraceToken);
        this.openBraceToken = openBraceToken;
        this.AdjustFlagsAndWidth(expression);
        this.expression = expression;
        if (alignmentClause != null)
        {
            this.AdjustFlagsAndWidth(alignmentClause);
            this.alignmentClause = alignmentClause;
        }
        if (formatClause != null)
        {
            this.AdjustFlagsAndWidth(formatClause);
            this.formatClause = formatClause;
        }
        this.AdjustFlagsAndWidth(closeBraceToken);
        this.closeBraceToken = closeBraceToken;
    }

    public SyntaxToken OpenBraceToken => this.openBraceToken;
    public ExpressionSyntax Expression => this.expression;
    public InterpolationAlignmentClauseSyntax? AlignmentClause => this.alignmentClause;
    public InterpolationFormatClauseSyntax? FormatClause => this.formatClause;
    public SyntaxToken CloseBraceToken => this.closeBraceToken;

    internal override GreenNode? GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.openBraceToken;
            case 1: return this.expression;
            case 2: return this.alignmentClause;
            case 3: return this.formatClause;
            case 4: return this.closeBraceToken;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new CSharp.Syntax.InterpolationSyntax(this, parent, position);

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor) => visitor.VisitInterpolation(this);

    public override void Accept(CSharpSyntaxVisitor visitor) => visitor.VisitInterpolation(this);

    public InterpolationSyntax Update(SyntaxToken openBraceToken, ExpressionSyntax expression, InterpolationAlignmentClauseSyntax alignmentClause, InterpolationFormatClauseSyntax formatClause, SyntaxToken closeBraceToken)
    {
        if (openBraceToken != this.OpenBraceToken || expression != this.Expression || alignmentClause != this.AlignmentClause || formatClause != this.FormatClause || closeBraceToken != this.CloseBraceToken)
        {
            var newNode = SyntaxFactory.Interpolation(openBraceToken, expression, alignmentClause, formatClause, closeBraceToken);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
        => new InterpolationSyntax(this.Kind, this.openBraceToken, this.expression, this.alignmentClause, this.formatClause, this.closeBraceToken, diagnostics, GetAnnotations());

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
        => new InterpolationSyntax(this.Kind, this.openBraceToken, this.expression, this.alignmentClause, this.formatClause, this.closeBraceToken, GetDiagnostics(), annotations);

    internal InterpolationSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 5;
      var openBraceToken = (SyntaxToken)reader.ReadValue();
      if (openBraceToken != null)
      {
         AdjustFlagsAndWidth(openBraceToken);
         this.openBraceToken = openBraceToken;
      }
      var expression = (ExpressionSyntax)reader.ReadValue();
      if (expression != null)
      {
         AdjustFlagsAndWidth(expression);
         this.expression = expression;
      }
      var alignmentClause = (InterpolationAlignmentClauseSyntax?)reader.ReadValue();
      if (alignmentClause != null)
      {
         AdjustFlagsAndWidth(alignmentClause);
         this.alignmentClause = alignmentClause;
      }
      var formatClause = (InterpolationFormatClauseSyntax?)reader.ReadValue();
      if (formatClause != null)
      {
         AdjustFlagsAndWidth(formatClause);
         this.formatClause = formatClause;
      }
      var closeBraceToken = (SyntaxToken)reader.ReadValue();
      if (closeBraceToken != null)
      {
         AdjustFlagsAndWidth(closeBraceToken);
         this.closeBraceToken = closeBraceToken;
      }
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.openBraceToken);
      writer.WriteValue(this.expression);
      writer.WriteValue(this.alignmentClause);
      writer.WriteValue(this.formatClause);
      writer.WriteValue(this.closeBraceToken);
    }

    static InterpolationSyntax()
    {
       ObjectBinder.RegisterTypeReader(typeof(InterpolationSyntax), r => new InterpolationSyntax(r));
    }
  }

  internal sealed partial class InterpolationAlignmentClauseSyntax : CSharpSyntaxNode
  {
    internal readonly SyntaxToken commaToken;
    internal readonly ExpressionSyntax value;

    internal InterpolationAlignmentClauseSyntax(SyntaxKind kind, SyntaxToken commaToken, ExpressionSyntax value, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 2;
        this.AdjustFlagsAndWidth(commaToken);
        this.commaToken = commaToken;
        this.AdjustFlagsAndWidth(value);
        this.value = value;
    }


    internal InterpolationAlignmentClauseSyntax(SyntaxKind kind, SyntaxToken commaToken, ExpressionSyntax value, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 2;
        this.AdjustFlagsAndWidth(commaToken);
        this.commaToken = commaToken;
        this.AdjustFlagsAndWidth(value);
        this.value = value;
    }


    internal InterpolationAlignmentClauseSyntax(SyntaxKind kind, SyntaxToken commaToken, ExpressionSyntax value)
        : base(kind)
    {
        this.SlotCount = 2;
        this.AdjustFlagsAndWidth(commaToken);
        this.commaToken = commaToken;
        this.AdjustFlagsAndWidth(value);
        this.value = value;
    }

    public SyntaxToken CommaToken => this.commaToken;
    public ExpressionSyntax Value => this.value;

    internal override GreenNode? GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.commaToken;
            case 1: return this.value;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new CSharp.Syntax.InterpolationAlignmentClauseSyntax(this, parent, position);

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor) => visitor.VisitInterpolationAlignmentClause(this);

    public override void Accept(CSharpSyntaxVisitor visitor) => visitor.VisitInterpolationAlignmentClause(this);

    public InterpolationAlignmentClauseSyntax Update(SyntaxToken commaToken, ExpressionSyntax value)
    {
        if (commaToken != this.CommaToken || value != this.Value)
        {
            var newNode = SyntaxFactory.InterpolationAlignmentClause(commaToken, value);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
        => new InterpolationAlignmentClauseSyntax(this.Kind, this.commaToken, this.value, diagnostics, GetAnnotations());

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
        => new InterpolationAlignmentClauseSyntax(this.Kind, this.commaToken, this.value, GetDiagnostics(), annotations);

    internal InterpolationAlignmentClauseSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 2;
      var commaToken = (SyntaxToken)reader.ReadValue();
      if (commaToken != null)
      {
         AdjustFlagsAndWidth(commaToken);
         this.commaToken = commaToken;
      }
      var value = (ExpressionSyntax)reader.ReadValue();
      if (value != null)
      {
         AdjustFlagsAndWidth(value);
         this.value = value;
      }
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.commaToken);
      writer.WriteValue(this.value);
    }

    static InterpolationAlignmentClauseSyntax()
    {
       ObjectBinder.RegisterTypeReader(typeof(InterpolationAlignmentClauseSyntax), r => new InterpolationAlignmentClauseSyntax(r));
    }
  }

  internal sealed partial class InterpolationFormatClauseSyntax : CSharpSyntaxNode
  {
    internal readonly SyntaxToken colonToken;
    internal readonly SyntaxToken formatStringToken;

    internal InterpolationFormatClauseSyntax(SyntaxKind kind, SyntaxToken colonToken, SyntaxToken formatStringToken, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 2;
        this.AdjustFlagsAndWidth(colonToken);
        this.colonToken = colonToken;
        this.AdjustFlagsAndWidth(formatStringToken);
        this.formatStringToken = formatStringToken;
    }


    internal InterpolationFormatClauseSyntax(SyntaxKind kind, SyntaxToken colonToken, SyntaxToken formatStringToken, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 2;
        this.AdjustFlagsAndWidth(colonToken);
        this.colonToken = colonToken;
        this.AdjustFlagsAndWidth(formatStringToken);
        this.formatStringToken = formatStringToken;
    }


    internal InterpolationFormatClauseSyntax(SyntaxKind kind, SyntaxToken colonToken, SyntaxToken formatStringToken)
        : base(kind)
    {
        this.SlotCount = 2;
        this.AdjustFlagsAndWidth(colonToken);
        this.colonToken = colonToken;
        this.AdjustFlagsAndWidth(formatStringToken);
        this.formatStringToken = formatStringToken;
    }

    public SyntaxToken ColonToken => this.colonToken;
    /// <summary>The text contents of the format specifier for an interpolation.</summary>
    public SyntaxToken FormatStringToken => this.formatStringToken;

    internal override GreenNode? GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.colonToken;
            case 1: return this.formatStringToken;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new CSharp.Syntax.InterpolationFormatClauseSyntax(this, parent, position);

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor) => visitor.VisitInterpolationFormatClause(this);

    public override void Accept(CSharpSyntaxVisitor visitor) => visitor.VisitInterpolationFormatClause(this);

    public InterpolationFormatClauseSyntax Update(SyntaxToken colonToken, SyntaxToken formatStringToken)
    {
        if (colonToken != this.ColonToken || formatStringToken != this.FormatStringToken)
        {
            var newNode = SyntaxFactory.InterpolationFormatClause(colonToken, formatStringToken);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
        => new InterpolationFormatClauseSyntax(this.Kind, this.colonToken, this.formatStringToken, diagnostics, GetAnnotations());

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
        => new InterpolationFormatClauseSyntax(this.Kind, this.colonToken, this.formatStringToken, GetDiagnostics(), annotations);

    internal InterpolationFormatClauseSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 2;
      var colonToken = (SyntaxToken)reader.ReadValue();
      if (colonToken != null)
      {
         AdjustFlagsAndWidth(colonToken);
         this.colonToken = colonToken;
      }
      var formatStringToken = (SyntaxToken)reader.ReadValue();
      if (formatStringToken != null)
      {
         AdjustFlagsAndWidth(formatStringToken);
         this.formatStringToken = formatStringToken;
      }
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.colonToken);
      writer.WriteValue(this.formatStringToken);
    }

    static InterpolationFormatClauseSyntax()
    {
       ObjectBinder.RegisterTypeReader(typeof(InterpolationFormatClauseSyntax), r => new InterpolationFormatClauseSyntax(r));
    }
  }

  internal sealed partial class GlobalStatementSyntax : MemberDeclarationSyntax
  {
    internal readonly GreenNode? attributeLists;
    internal readonly GreenNode? modifiers;
    internal readonly StatementSyntax statement;

    internal GlobalStatementSyntax(SyntaxKind kind, GreenNode? attributeLists, GreenNode? modifiers, StatementSyntax statement, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 3;
        if (attributeLists != null)
        {
            this.AdjustFlagsAndWidth(attributeLists);
            this.attributeLists = attributeLists;
        }
        if (modifiers != null)
        {
            this.AdjustFlagsAndWidth(modifiers);
            this.modifiers = modifiers;
        }
        this.AdjustFlagsAndWidth(statement);
        this.statement = statement;
    }


    internal GlobalStatementSyntax(SyntaxKind kind, GreenNode? attributeLists, GreenNode? modifiers, StatementSyntax statement, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 3;
        if (attributeLists != null)
        {
            this.AdjustFlagsAndWidth(attributeLists);
            this.attributeLists = attributeLists;
        }
        if (modifiers != null)
        {
            this.AdjustFlagsAndWidth(modifiers);
            this.modifiers = modifiers;
        }
        this.AdjustFlagsAndWidth(statement);
        this.statement = statement;
    }


    internal GlobalStatementSyntax(SyntaxKind kind, GreenNode? attributeLists, GreenNode? modifiers, StatementSyntax statement)
        : base(kind)
    {
        this.SlotCount = 3;
        if (attributeLists != null)
        {
            this.AdjustFlagsAndWidth(attributeLists);
            this.attributeLists = attributeLists;
        }
        if (modifiers != null)
        {
            this.AdjustFlagsAndWidth(modifiers);
            this.modifiers = modifiers;
        }
        this.AdjustFlagsAndWidth(statement);
        this.statement = statement;
    }

    public override Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<AttributeListSyntax> AttributeLists => new Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<AttributeListSyntax>(this.attributeLists);
    public override Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SyntaxToken> Modifiers => new Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SyntaxToken>(this.modifiers);
    public StatementSyntax Statement => this.statement;

    internal override GreenNode? GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.attributeLists;
            case 1: return this.modifiers;
            case 2: return this.statement;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new CSharp.Syntax.GlobalStatementSyntax(this, parent, position);

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor) => visitor.VisitGlobalStatement(this);

    public override void Accept(CSharpSyntaxVisitor visitor) => visitor.VisitGlobalStatement(this);

    public GlobalStatementSyntax Update(Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<AttributeListSyntax> attributeLists, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SyntaxToken> modifiers, StatementSyntax statement)
    {
        if (attributeLists != this.AttributeLists || modifiers != this.Modifiers || statement != this.Statement)
        {
            var newNode = SyntaxFactory.GlobalStatement(attributeLists, modifiers, statement);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
        => new GlobalStatementSyntax(this.Kind, this.attributeLists, this.modifiers, this.statement, diagnostics, GetAnnotations());

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
        => new GlobalStatementSyntax(this.Kind, this.attributeLists, this.modifiers, this.statement, GetDiagnostics(), annotations);

    internal GlobalStatementSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 3;
      var attributeLists = (GreenNode?)reader.ReadValue();
      if (attributeLists != null)
      {
         AdjustFlagsAndWidth(attributeLists);
         this.attributeLists = attributeLists;
      }
      var modifiers = (GreenNode?)reader.ReadValue();
      if (modifiers != null)
      {
         AdjustFlagsAndWidth(modifiers);
         this.modifiers = modifiers;
      }
      var statement = (StatementSyntax)reader.ReadValue();
      if (statement != null)
      {
         AdjustFlagsAndWidth(statement);
         this.statement = statement;
      }
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.attributeLists);
      writer.WriteValue(this.modifiers);
      writer.WriteValue(this.statement);
    }

    static GlobalStatementSyntax()
    {
       ObjectBinder.RegisterTypeReader(typeof(GlobalStatementSyntax), r => new GlobalStatementSyntax(r));
    }
  }

  /// <summary>Represents the base class for all statements syntax classes.</summary>
  internal abstract partial class StatementSyntax : CSharpSyntaxNode
  {
    internal StatementSyntax(SyntaxKind kind, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
      : base(kind, diagnostics, annotations)
    {
    }
    internal StatementSyntax(SyntaxKind kind)
      : base(kind)
    {
    }

    protected StatementSyntax(ObjectReader reader)
       : base(reader)
    {
    }
  }

  internal sealed partial class BlockSyntax : StatementSyntax
  {
    internal readonly SyntaxToken openBraceToken;
    internal readonly GreenNode? statements;
    internal readonly SyntaxToken closeBraceToken;

    internal BlockSyntax(SyntaxKind kind, SyntaxToken openBraceToken, GreenNode? statements, SyntaxToken closeBraceToken, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 3;
        this.AdjustFlagsAndWidth(openBraceToken);
        this.openBraceToken = openBraceToken;
        if (statements != null)
        {
            this.AdjustFlagsAndWidth(statements);
            this.statements = statements;
        }
        this.AdjustFlagsAndWidth(closeBraceToken);
        this.closeBraceToken = closeBraceToken;
    }


    internal BlockSyntax(SyntaxKind kind, SyntaxToken openBraceToken, GreenNode? statements, SyntaxToken closeBraceToken, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 3;
        this.AdjustFlagsAndWidth(openBraceToken);
        this.openBraceToken = openBraceToken;
        if (statements != null)
        {
            this.AdjustFlagsAndWidth(statements);
            this.statements = statements;
        }
        this.AdjustFlagsAndWidth(closeBraceToken);
        this.closeBraceToken = closeBraceToken;
    }


    internal BlockSyntax(SyntaxKind kind, SyntaxToken openBraceToken, GreenNode? statements, SyntaxToken closeBraceToken)
        : base(kind)
    {
        this.SlotCount = 3;
        this.AdjustFlagsAndWidth(openBraceToken);
        this.openBraceToken = openBraceToken;
        if (statements != null)
        {
            this.AdjustFlagsAndWidth(statements);
            this.statements = statements;
        }
        this.AdjustFlagsAndWidth(closeBraceToken);
        this.closeBraceToken = closeBraceToken;
    }

    public SyntaxToken OpenBraceToken => this.openBraceToken;
    public Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<StatementSyntax> Statements => new Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<StatementSyntax>(this.statements);
    public SyntaxToken CloseBraceToken => this.closeBraceToken;

    internal override GreenNode? GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.openBraceToken;
            case 1: return this.statements;
            case 2: return this.closeBraceToken;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new CSharp.Syntax.BlockSyntax(this, parent, position);

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor) => visitor.VisitBlock(this);

    public override void Accept(CSharpSyntaxVisitor visitor) => visitor.VisitBlock(this);

    public BlockSyntax Update(SyntaxToken openBraceToken, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<StatementSyntax> statements, SyntaxToken closeBraceToken)
    {
        if (openBraceToken != this.OpenBraceToken || statements != this.Statements || closeBraceToken != this.CloseBraceToken)
        {
            var newNode = SyntaxFactory.Block(openBraceToken, statements, closeBraceToken);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
        => new BlockSyntax(this.Kind, this.openBraceToken, this.statements, this.closeBraceToken, diagnostics, GetAnnotations());

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
        => new BlockSyntax(this.Kind, this.openBraceToken, this.statements, this.closeBraceToken, GetDiagnostics(), annotations);

    internal BlockSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 3;
      var openBraceToken = (SyntaxToken)reader.ReadValue();
      if (openBraceToken != null)
      {
         AdjustFlagsAndWidth(openBraceToken);
         this.openBraceToken = openBraceToken;
      }
      var statements = (GreenNode?)reader.ReadValue();
      if (statements != null)
      {
         AdjustFlagsAndWidth(statements);
         this.statements = statements;
      }
      var closeBraceToken = (SyntaxToken)reader.ReadValue();
      if (closeBraceToken != null)
      {
         AdjustFlagsAndWidth(closeBraceToken);
         this.closeBraceToken = closeBraceToken;
      }
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.openBraceToken);
      writer.WriteValue(this.statements);
      writer.WriteValue(this.closeBraceToken);
    }

    static BlockSyntax()
    {
       ObjectBinder.RegisterTypeReader(typeof(BlockSyntax), r => new BlockSyntax(r));
    }
  }

  internal sealed partial class LocalFunctionStatementSyntax : StatementSyntax
  {
    internal readonly GreenNode? modifiers;
    internal readonly TypeSyntax returnType;
    internal readonly SyntaxToken identifier;
    internal readonly TypeParameterListSyntax? typeParameterList;
    internal readonly ParameterListSyntax parameterList;
    internal readonly GreenNode? constraintClauses;
    internal readonly BlockSyntax? body;
    internal readonly ArrowExpressionClauseSyntax? expressionBody;
    internal readonly SyntaxToken? semicolonToken;

    internal LocalFunctionStatementSyntax(SyntaxKind kind, GreenNode? modifiers, TypeSyntax returnType, SyntaxToken identifier, TypeParameterListSyntax? typeParameterList, ParameterListSyntax parameterList, GreenNode? constraintClauses, BlockSyntax? body, ArrowExpressionClauseSyntax? expressionBody, SyntaxToken? semicolonToken, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 9;
        if (modifiers != null)
        {
            this.AdjustFlagsAndWidth(modifiers);
            this.modifiers = modifiers;
        }
        this.AdjustFlagsAndWidth(returnType);
        this.returnType = returnType;
        this.AdjustFlagsAndWidth(identifier);
        this.identifier = identifier;
        if (typeParameterList != null)
        {
            this.AdjustFlagsAndWidth(typeParameterList);
            this.typeParameterList = typeParameterList;
        }
        this.AdjustFlagsAndWidth(parameterList);
        this.parameterList = parameterList;
        if (constraintClauses != null)
        {
            this.AdjustFlagsAndWidth(constraintClauses);
            this.constraintClauses = constraintClauses;
        }
        if (body != null)
        {
            this.AdjustFlagsAndWidth(body);
            this.body = body;
        }
        if (expressionBody != null)
        {
            this.AdjustFlagsAndWidth(expressionBody);
            this.expressionBody = expressionBody;
        }
        if (semicolonToken != null)
        {
            this.AdjustFlagsAndWidth(semicolonToken);
            this.semicolonToken = semicolonToken;
        }
    }


    internal LocalFunctionStatementSyntax(SyntaxKind kind, GreenNode? modifiers, TypeSyntax returnType, SyntaxToken identifier, TypeParameterListSyntax? typeParameterList, ParameterListSyntax parameterList, GreenNode? constraintClauses, BlockSyntax? body, ArrowExpressionClauseSyntax? expressionBody, SyntaxToken? semicolonToken, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 9;
        if (modifiers != null)
        {
            this.AdjustFlagsAndWidth(modifiers);
            this.modifiers = modifiers;
        }
        this.AdjustFlagsAndWidth(returnType);
        this.returnType = returnType;
        this.AdjustFlagsAndWidth(identifier);
        this.identifier = identifier;
        if (typeParameterList != null)
        {
            this.AdjustFlagsAndWidth(typeParameterList);
            this.typeParameterList = typeParameterList;
        }
        this.AdjustFlagsAndWidth(parameterList);
        this.parameterList = parameterList;
        if (constraintClauses != null)
        {
            this.AdjustFlagsAndWidth(constraintClauses);
            this.constraintClauses = constraintClauses;
        }
        if (body != null)
        {
            this.AdjustFlagsAndWidth(body);
            this.body = body;
        }
        if (expressionBody != null)
        {
            this.AdjustFlagsAndWidth(expressionBody);
            this.expressionBody = expressionBody;
        }
        if (semicolonToken != null)
        {
            this.AdjustFlagsAndWidth(semicolonToken);
            this.semicolonToken = semicolonToken;
        }
    }


    internal LocalFunctionStatementSyntax(SyntaxKind kind, GreenNode? modifiers, TypeSyntax returnType, SyntaxToken identifier, TypeParameterListSyntax? typeParameterList, ParameterListSyntax parameterList, GreenNode? constraintClauses, BlockSyntax? body, ArrowExpressionClauseSyntax? expressionBody, SyntaxToken? semicolonToken)
        : base(kind)
    {
        this.SlotCount = 9;
        if (modifiers != null)
        {
            this.AdjustFlagsAndWidth(modifiers);
            this.modifiers = modifiers;
        }
        this.AdjustFlagsAndWidth(returnType);
        this.returnType = returnType;
        this.AdjustFlagsAndWidth(identifier);
        this.identifier = identifier;
        if (typeParameterList != null)
        {
            this.AdjustFlagsAndWidth(typeParameterList);
            this.typeParameterList = typeParameterList;
        }
        this.AdjustFlagsAndWidth(parameterList);
        this.parameterList = parameterList;
        if (constraintClauses != null)
        {
            this.AdjustFlagsAndWidth(constraintClauses);
            this.constraintClauses = constraintClauses;
        }
        if (body != null)
        {
            this.AdjustFlagsAndWidth(body);
            this.body = body;
        }
        if (expressionBody != null)
        {
            this.AdjustFlagsAndWidth(expressionBody);
            this.expressionBody = expressionBody;
        }
        if (semicolonToken != null)
        {
            this.AdjustFlagsAndWidth(semicolonToken);
            this.semicolonToken = semicolonToken;
        }
    }

    public Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SyntaxToken> Modifiers => new Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SyntaxToken>(this.modifiers);
    public TypeSyntax ReturnType => this.returnType;
    /// <summary>Gets the identifier.</summary>
    public SyntaxToken Identifier => this.identifier;
    public TypeParameterListSyntax? TypeParameterList => this.typeParameterList;
    public ParameterListSyntax ParameterList => this.parameterList;
    public Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<TypeParameterConstraintClauseSyntax> ConstraintClauses => new Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<TypeParameterConstraintClauseSyntax>(this.constraintClauses);
    public BlockSyntax? Body => this.body;
    public ArrowExpressionClauseSyntax? ExpressionBody => this.expressionBody;
    /// <summary>Gets the optional semicolon token.</summary>
    public SyntaxToken? SemicolonToken => this.semicolonToken;

    internal override GreenNode? GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.modifiers;
            case 1: return this.returnType;
            case 2: return this.identifier;
            case 3: return this.typeParameterList;
            case 4: return this.parameterList;
            case 5: return this.constraintClauses;
            case 6: return this.body;
            case 7: return this.expressionBody;
            case 8: return this.semicolonToken;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new CSharp.Syntax.LocalFunctionStatementSyntax(this, parent, position);

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor) => visitor.VisitLocalFunctionStatement(this);

    public override void Accept(CSharpSyntaxVisitor visitor) => visitor.VisitLocalFunctionStatement(this);

    public LocalFunctionStatementSyntax Update(Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SyntaxToken> modifiers, TypeSyntax returnType, SyntaxToken identifier, TypeParameterListSyntax typeParameterList, ParameterListSyntax parameterList, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<TypeParameterConstraintClauseSyntax> constraintClauses, BlockSyntax body, ArrowExpressionClauseSyntax expressionBody, SyntaxToken semicolonToken)
    {
        if (modifiers != this.Modifiers || returnType != this.ReturnType || identifier != this.Identifier || typeParameterList != this.TypeParameterList || parameterList != this.ParameterList || constraintClauses != this.ConstraintClauses || body != this.Body || expressionBody != this.ExpressionBody || semicolonToken != this.SemicolonToken)
        {
            var newNode = SyntaxFactory.LocalFunctionStatement(modifiers, returnType, identifier, typeParameterList, parameterList, constraintClauses, body, expressionBody, semicolonToken);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
        => new LocalFunctionStatementSyntax(this.Kind, this.modifiers, this.returnType, this.identifier, this.typeParameterList, this.parameterList, this.constraintClauses, this.body, this.expressionBody, this.semicolonToken, diagnostics, GetAnnotations());

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
        => new LocalFunctionStatementSyntax(this.Kind, this.modifiers, this.returnType, this.identifier, this.typeParameterList, this.parameterList, this.constraintClauses, this.body, this.expressionBody, this.semicolonToken, GetDiagnostics(), annotations);

    internal LocalFunctionStatementSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 9;
      var modifiers = (GreenNode?)reader.ReadValue();
      if (modifiers != null)
      {
         AdjustFlagsAndWidth(modifiers);
         this.modifiers = modifiers;
      }
      var returnType = (TypeSyntax)reader.ReadValue();
      if (returnType != null)
      {
         AdjustFlagsAndWidth(returnType);
         this.returnType = returnType;
      }
      var identifier = (SyntaxToken)reader.ReadValue();
      if (identifier != null)
      {
         AdjustFlagsAndWidth(identifier);
         this.identifier = identifier;
      }
      var typeParameterList = (TypeParameterListSyntax?)reader.ReadValue();
      if (typeParameterList != null)
      {
         AdjustFlagsAndWidth(typeParameterList);
         this.typeParameterList = typeParameterList;
      }
      var parameterList = (ParameterListSyntax)reader.ReadValue();
      if (parameterList != null)
      {
         AdjustFlagsAndWidth(parameterList);
         this.parameterList = parameterList;
      }
      var constraintClauses = (GreenNode?)reader.ReadValue();
      if (constraintClauses != null)
      {
         AdjustFlagsAndWidth(constraintClauses);
         this.constraintClauses = constraintClauses;
      }
      var body = (BlockSyntax?)reader.ReadValue();
      if (body != null)
      {
         AdjustFlagsAndWidth(body);
         this.body = body;
      }
      var expressionBody = (ArrowExpressionClauseSyntax?)reader.ReadValue();
      if (expressionBody != null)
      {
         AdjustFlagsAndWidth(expressionBody);
         this.expressionBody = expressionBody;
      }
      var semicolonToken = (SyntaxToken?)reader.ReadValue();
      if (semicolonToken != null)
      {
         AdjustFlagsAndWidth(semicolonToken);
         this.semicolonToken = semicolonToken;
      }
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.modifiers);
      writer.WriteValue(this.returnType);
      writer.WriteValue(this.identifier);
      writer.WriteValue(this.typeParameterList);
      writer.WriteValue(this.parameterList);
      writer.WriteValue(this.constraintClauses);
      writer.WriteValue(this.body);
      writer.WriteValue(this.expressionBody);
      writer.WriteValue(this.semicolonToken);
    }

    static LocalFunctionStatementSyntax()
    {
       ObjectBinder.RegisterTypeReader(typeof(LocalFunctionStatementSyntax), r => new LocalFunctionStatementSyntax(r));
    }
  }

  internal sealed partial class LocalDeclarationStatementSyntax : StatementSyntax
  {
    internal readonly SyntaxToken? awaitKeyword;
    internal readonly SyntaxToken? usingKeyword;
    internal readonly GreenNode? modifiers;
    internal readonly VariableDeclarationSyntax declaration;
    internal readonly SyntaxToken semicolonToken;

    internal LocalDeclarationStatementSyntax(SyntaxKind kind, SyntaxToken? awaitKeyword, SyntaxToken? usingKeyword, GreenNode? modifiers, VariableDeclarationSyntax declaration, SyntaxToken semicolonToken, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 5;
        if (awaitKeyword != null)
        {
            this.AdjustFlagsAndWidth(awaitKeyword);
            this.awaitKeyword = awaitKeyword;
        }
        if (usingKeyword != null)
        {
            this.AdjustFlagsAndWidth(usingKeyword);
            this.usingKeyword = usingKeyword;
        }
        if (modifiers != null)
        {
            this.AdjustFlagsAndWidth(modifiers);
            this.modifiers = modifiers;
        }
        this.AdjustFlagsAndWidth(declaration);
        this.declaration = declaration;
        this.AdjustFlagsAndWidth(semicolonToken);
        this.semicolonToken = semicolonToken;
    }


    internal LocalDeclarationStatementSyntax(SyntaxKind kind, SyntaxToken? awaitKeyword, SyntaxToken? usingKeyword, GreenNode? modifiers, VariableDeclarationSyntax declaration, SyntaxToken semicolonToken, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 5;
        if (awaitKeyword != null)
        {
            this.AdjustFlagsAndWidth(awaitKeyword);
            this.awaitKeyword = awaitKeyword;
        }
        if (usingKeyword != null)
        {
            this.AdjustFlagsAndWidth(usingKeyword);
            this.usingKeyword = usingKeyword;
        }
        if (modifiers != null)
        {
            this.AdjustFlagsAndWidth(modifiers);
            this.modifiers = modifiers;
        }
        this.AdjustFlagsAndWidth(declaration);
        this.declaration = declaration;
        this.AdjustFlagsAndWidth(semicolonToken);
        this.semicolonToken = semicolonToken;
    }


    internal LocalDeclarationStatementSyntax(SyntaxKind kind, SyntaxToken? awaitKeyword, SyntaxToken? usingKeyword, GreenNode? modifiers, VariableDeclarationSyntax declaration, SyntaxToken semicolonToken)
        : base(kind)
    {
        this.SlotCount = 5;
        if (awaitKeyword != null)
        {
            this.AdjustFlagsAndWidth(awaitKeyword);
            this.awaitKeyword = awaitKeyword;
        }
        if (usingKeyword != null)
        {
            this.AdjustFlagsAndWidth(usingKeyword);
            this.usingKeyword = usingKeyword;
        }
        if (modifiers != null)
        {
            this.AdjustFlagsAndWidth(modifiers);
            this.modifiers = modifiers;
        }
        this.AdjustFlagsAndWidth(declaration);
        this.declaration = declaration;
        this.AdjustFlagsAndWidth(semicolonToken);
        this.semicolonToken = semicolonToken;
    }

    public SyntaxToken? AwaitKeyword => this.awaitKeyword;
    public SyntaxToken? UsingKeyword => this.usingKeyword;
    /// <summary>Gets the modifier list.</summary>
    public Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SyntaxToken> Modifiers => new Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SyntaxToken>(this.modifiers);
    public VariableDeclarationSyntax Declaration => this.declaration;
    public SyntaxToken SemicolonToken => this.semicolonToken;

    internal override GreenNode? GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.awaitKeyword;
            case 1: return this.usingKeyword;
            case 2: return this.modifiers;
            case 3: return this.declaration;
            case 4: return this.semicolonToken;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new CSharp.Syntax.LocalDeclarationStatementSyntax(this, parent, position);

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor) => visitor.VisitLocalDeclarationStatement(this);

    public override void Accept(CSharpSyntaxVisitor visitor) => visitor.VisitLocalDeclarationStatement(this);

    public LocalDeclarationStatementSyntax Update(SyntaxToken awaitKeyword, SyntaxToken usingKeyword, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SyntaxToken> modifiers, VariableDeclarationSyntax declaration, SyntaxToken semicolonToken)
    {
        if (awaitKeyword != this.AwaitKeyword || usingKeyword != this.UsingKeyword || modifiers != this.Modifiers || declaration != this.Declaration || semicolonToken != this.SemicolonToken)
        {
            var newNode = SyntaxFactory.LocalDeclarationStatement(awaitKeyword, usingKeyword, modifiers, declaration, semicolonToken);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
        => new LocalDeclarationStatementSyntax(this.Kind, this.awaitKeyword, this.usingKeyword, this.modifiers, this.declaration, this.semicolonToken, diagnostics, GetAnnotations());

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
        => new LocalDeclarationStatementSyntax(this.Kind, this.awaitKeyword, this.usingKeyword, this.modifiers, this.declaration, this.semicolonToken, GetDiagnostics(), annotations);

    internal LocalDeclarationStatementSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 5;
      var awaitKeyword = (SyntaxToken?)reader.ReadValue();
      if (awaitKeyword != null)
      {
         AdjustFlagsAndWidth(awaitKeyword);
         this.awaitKeyword = awaitKeyword;
      }
      var usingKeyword = (SyntaxToken?)reader.ReadValue();
      if (usingKeyword != null)
      {
         AdjustFlagsAndWidth(usingKeyword);
         this.usingKeyword = usingKeyword;
      }
      var modifiers = (GreenNode?)reader.ReadValue();
      if (modifiers != null)
      {
         AdjustFlagsAndWidth(modifiers);
         this.modifiers = modifiers;
      }
      var declaration = (VariableDeclarationSyntax)reader.ReadValue();
      if (declaration != null)
      {
         AdjustFlagsAndWidth(declaration);
         this.declaration = declaration;
      }
      var semicolonToken = (SyntaxToken)reader.ReadValue();
      if (semicolonToken != null)
      {
         AdjustFlagsAndWidth(semicolonToken);
         this.semicolonToken = semicolonToken;
      }
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.awaitKeyword);
      writer.WriteValue(this.usingKeyword);
      writer.WriteValue(this.modifiers);
      writer.WriteValue(this.declaration);
      writer.WriteValue(this.semicolonToken);
    }

    static LocalDeclarationStatementSyntax()
    {
       ObjectBinder.RegisterTypeReader(typeof(LocalDeclarationStatementSyntax), r => new LocalDeclarationStatementSyntax(r));
    }
  }

  internal sealed partial class VariableDeclarationSyntax : CSharpSyntaxNode
  {
    internal readonly TypeSyntax type;
    internal readonly GreenNode? variables;

    internal VariableDeclarationSyntax(SyntaxKind kind, TypeSyntax type, GreenNode? variables, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 2;
        this.AdjustFlagsAndWidth(type);
        this.type = type;
        if (variables != null)
        {
            this.AdjustFlagsAndWidth(variables);
            this.variables = variables;
        }
    }


    internal VariableDeclarationSyntax(SyntaxKind kind, TypeSyntax type, GreenNode? variables, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 2;
        this.AdjustFlagsAndWidth(type);
        this.type = type;
        if (variables != null)
        {
            this.AdjustFlagsAndWidth(variables);
            this.variables = variables;
        }
    }


    internal VariableDeclarationSyntax(SyntaxKind kind, TypeSyntax type, GreenNode? variables)
        : base(kind)
    {
        this.SlotCount = 2;
        this.AdjustFlagsAndWidth(type);
        this.type = type;
        if (variables != null)
        {
            this.AdjustFlagsAndWidth(variables);
            this.variables = variables;
        }
    }

    public TypeSyntax Type => this.type;
    public Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<VariableDeclaratorSyntax> Variables => new Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<VariableDeclaratorSyntax>(new Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<CSharpSyntaxNode>(this.variables));

    internal override GreenNode? GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.type;
            case 1: return this.variables;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new CSharp.Syntax.VariableDeclarationSyntax(this, parent, position);

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor) => visitor.VisitVariableDeclaration(this);

    public override void Accept(CSharpSyntaxVisitor visitor) => visitor.VisitVariableDeclaration(this);

    public VariableDeclarationSyntax Update(TypeSyntax type, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<VariableDeclaratorSyntax> variables)
    {
        if (type != this.Type || variables != this.Variables)
        {
            var newNode = SyntaxFactory.VariableDeclaration(type, variables);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
        => new VariableDeclarationSyntax(this.Kind, this.type, this.variables, diagnostics, GetAnnotations());

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
        => new VariableDeclarationSyntax(this.Kind, this.type, this.variables, GetDiagnostics(), annotations);

    internal VariableDeclarationSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 2;
      var type = (TypeSyntax)reader.ReadValue();
      if (type != null)
      {
         AdjustFlagsAndWidth(type);
         this.type = type;
      }
      var variables = (GreenNode?)reader.ReadValue();
      if (variables != null)
      {
         AdjustFlagsAndWidth(variables);
         this.variables = variables;
      }
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.type);
      writer.WriteValue(this.variables);
    }

    static VariableDeclarationSyntax()
    {
       ObjectBinder.RegisterTypeReader(typeof(VariableDeclarationSyntax), r => new VariableDeclarationSyntax(r));
    }
  }

  internal sealed partial class VariableDeclaratorSyntax : CSharpSyntaxNode
  {
    internal readonly SyntaxToken identifier;
    internal readonly BracketedArgumentListSyntax? argumentList;
    internal readonly EqualsValueClauseSyntax? initializer;

    internal VariableDeclaratorSyntax(SyntaxKind kind, SyntaxToken identifier, BracketedArgumentListSyntax? argumentList, EqualsValueClauseSyntax? initializer, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 3;
        this.AdjustFlagsAndWidth(identifier);
        this.identifier = identifier;
        if (argumentList != null)
        {
            this.AdjustFlagsAndWidth(argumentList);
            this.argumentList = argumentList;
        }
        if (initializer != null)
        {
            this.AdjustFlagsAndWidth(initializer);
            this.initializer = initializer;
        }
    }


    internal VariableDeclaratorSyntax(SyntaxKind kind, SyntaxToken identifier, BracketedArgumentListSyntax? argumentList, EqualsValueClauseSyntax? initializer, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 3;
        this.AdjustFlagsAndWidth(identifier);
        this.identifier = identifier;
        if (argumentList != null)
        {
            this.AdjustFlagsAndWidth(argumentList);
            this.argumentList = argumentList;
        }
        if (initializer != null)
        {
            this.AdjustFlagsAndWidth(initializer);
            this.initializer = initializer;
        }
    }


    internal VariableDeclaratorSyntax(SyntaxKind kind, SyntaxToken identifier, BracketedArgumentListSyntax? argumentList, EqualsValueClauseSyntax? initializer)
        : base(kind)
    {
        this.SlotCount = 3;
        this.AdjustFlagsAndWidth(identifier);
        this.identifier = identifier;
        if (argumentList != null)
        {
            this.AdjustFlagsAndWidth(argumentList);
            this.argumentList = argumentList;
        }
        if (initializer != null)
        {
            this.AdjustFlagsAndWidth(initializer);
            this.initializer = initializer;
        }
    }

    /// <summary>Gets the identifier.</summary>
    public SyntaxToken Identifier => this.identifier;
    public BracketedArgumentListSyntax? ArgumentList => this.argumentList;
    public EqualsValueClauseSyntax? Initializer => this.initializer;

    internal override GreenNode? GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.identifier;
            case 1: return this.argumentList;
            case 2: return this.initializer;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new CSharp.Syntax.VariableDeclaratorSyntax(this, parent, position);

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor) => visitor.VisitVariableDeclarator(this);

    public override void Accept(CSharpSyntaxVisitor visitor) => visitor.VisitVariableDeclarator(this);

    public VariableDeclaratorSyntax Update(SyntaxToken identifier, BracketedArgumentListSyntax argumentList, EqualsValueClauseSyntax initializer)
    {
        if (identifier != this.Identifier || argumentList != this.ArgumentList || initializer != this.Initializer)
        {
            var newNode = SyntaxFactory.VariableDeclarator(identifier, argumentList, initializer);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
        => new VariableDeclaratorSyntax(this.Kind, this.identifier, this.argumentList, this.initializer, diagnostics, GetAnnotations());

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
        => new VariableDeclaratorSyntax(this.Kind, this.identifier, this.argumentList, this.initializer, GetDiagnostics(), annotations);

    internal VariableDeclaratorSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 3;
      var identifier = (SyntaxToken)reader.ReadValue();
      if (identifier != null)
      {
         AdjustFlagsAndWidth(identifier);
         this.identifier = identifier;
      }
      var argumentList = (BracketedArgumentListSyntax?)reader.ReadValue();
      if (argumentList != null)
      {
         AdjustFlagsAndWidth(argumentList);
         this.argumentList = argumentList;
      }
      var initializer = (EqualsValueClauseSyntax?)reader.ReadValue();
      if (initializer != null)
      {
         AdjustFlagsAndWidth(initializer);
         this.initializer = initializer;
      }
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.identifier);
      writer.WriteValue(this.argumentList);
      writer.WriteValue(this.initializer);
    }

    static VariableDeclaratorSyntax()
    {
       ObjectBinder.RegisterTypeReader(typeof(VariableDeclaratorSyntax), r => new VariableDeclaratorSyntax(r));
    }
  }

  internal sealed partial class EqualsValueClauseSyntax : CSharpSyntaxNode
  {
    internal readonly SyntaxToken equalsToken;
    internal readonly ExpressionSyntax value;

    internal EqualsValueClauseSyntax(SyntaxKind kind, SyntaxToken equalsToken, ExpressionSyntax value, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 2;
        this.AdjustFlagsAndWidth(equalsToken);
        this.equalsToken = equalsToken;
        this.AdjustFlagsAndWidth(value);
        this.value = value;
    }


    internal EqualsValueClauseSyntax(SyntaxKind kind, SyntaxToken equalsToken, ExpressionSyntax value, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 2;
        this.AdjustFlagsAndWidth(equalsToken);
        this.equalsToken = equalsToken;
        this.AdjustFlagsAndWidth(value);
        this.value = value;
    }


    internal EqualsValueClauseSyntax(SyntaxKind kind, SyntaxToken equalsToken, ExpressionSyntax value)
        : base(kind)
    {
        this.SlotCount = 2;
        this.AdjustFlagsAndWidth(equalsToken);
        this.equalsToken = equalsToken;
        this.AdjustFlagsAndWidth(value);
        this.value = value;
    }

    public SyntaxToken EqualsToken => this.equalsToken;
    public ExpressionSyntax Value => this.value;

    internal override GreenNode? GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.equalsToken;
            case 1: return this.value;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new CSharp.Syntax.EqualsValueClauseSyntax(this, parent, position);

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor) => visitor.VisitEqualsValueClause(this);

    public override void Accept(CSharpSyntaxVisitor visitor) => visitor.VisitEqualsValueClause(this);

    public EqualsValueClauseSyntax Update(SyntaxToken equalsToken, ExpressionSyntax value)
    {
        if (equalsToken != this.EqualsToken || value != this.Value)
        {
            var newNode = SyntaxFactory.EqualsValueClause(equalsToken, value);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
        => new EqualsValueClauseSyntax(this.Kind, this.equalsToken, this.value, diagnostics, GetAnnotations());

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
        => new EqualsValueClauseSyntax(this.Kind, this.equalsToken, this.value, GetDiagnostics(), annotations);

    internal EqualsValueClauseSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 2;
      var equalsToken = (SyntaxToken)reader.ReadValue();
      if (equalsToken != null)
      {
         AdjustFlagsAndWidth(equalsToken);
         this.equalsToken = equalsToken;
      }
      var value = (ExpressionSyntax)reader.ReadValue();
      if (value != null)
      {
         AdjustFlagsAndWidth(value);
         this.value = value;
      }
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.equalsToken);
      writer.WriteValue(this.value);
    }

    static EqualsValueClauseSyntax()
    {
       ObjectBinder.RegisterTypeReader(typeof(EqualsValueClauseSyntax), r => new EqualsValueClauseSyntax(r));
    }
  }

  internal abstract partial class VariableDesignationSyntax : CSharpSyntaxNode
  {
    internal VariableDesignationSyntax(SyntaxKind kind, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
      : base(kind, diagnostics, annotations)
    {
    }
    internal VariableDesignationSyntax(SyntaxKind kind)
      : base(kind)
    {
    }

    protected VariableDesignationSyntax(ObjectReader reader)
       : base(reader)
    {
    }
  }

  internal sealed partial class SingleVariableDesignationSyntax : VariableDesignationSyntax
  {
    internal readonly SyntaxToken identifier;

    internal SingleVariableDesignationSyntax(SyntaxKind kind, SyntaxToken identifier, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 1;
        this.AdjustFlagsAndWidth(identifier);
        this.identifier = identifier;
    }


    internal SingleVariableDesignationSyntax(SyntaxKind kind, SyntaxToken identifier, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 1;
        this.AdjustFlagsAndWidth(identifier);
        this.identifier = identifier;
    }


    internal SingleVariableDesignationSyntax(SyntaxKind kind, SyntaxToken identifier)
        : base(kind)
    {
        this.SlotCount = 1;
        this.AdjustFlagsAndWidth(identifier);
        this.identifier = identifier;
    }

    public SyntaxToken Identifier => this.identifier;

    internal override GreenNode? GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.identifier;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new CSharp.Syntax.SingleVariableDesignationSyntax(this, parent, position);

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor) => visitor.VisitSingleVariableDesignation(this);

    public override void Accept(CSharpSyntaxVisitor visitor) => visitor.VisitSingleVariableDesignation(this);

    public SingleVariableDesignationSyntax Update(SyntaxToken identifier)
    {
        if (identifier != this.Identifier)
        {
            var newNode = SyntaxFactory.SingleVariableDesignation(identifier);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
        => new SingleVariableDesignationSyntax(this.Kind, this.identifier, diagnostics, GetAnnotations());

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
        => new SingleVariableDesignationSyntax(this.Kind, this.identifier, GetDiagnostics(), annotations);

    internal SingleVariableDesignationSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 1;
      var identifier = (SyntaxToken)reader.ReadValue();
      if (identifier != null)
      {
         AdjustFlagsAndWidth(identifier);
         this.identifier = identifier;
      }
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.identifier);
    }

    static SingleVariableDesignationSyntax()
    {
       ObjectBinder.RegisterTypeReader(typeof(SingleVariableDesignationSyntax), r => new SingleVariableDesignationSyntax(r));
    }
  }

  internal sealed partial class DiscardDesignationSyntax : VariableDesignationSyntax
  {
    internal readonly SyntaxToken underscoreToken;

    internal DiscardDesignationSyntax(SyntaxKind kind, SyntaxToken underscoreToken, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 1;
        this.AdjustFlagsAndWidth(underscoreToken);
        this.underscoreToken = underscoreToken;
    }


    internal DiscardDesignationSyntax(SyntaxKind kind, SyntaxToken underscoreToken, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 1;
        this.AdjustFlagsAndWidth(underscoreToken);
        this.underscoreToken = underscoreToken;
    }


    internal DiscardDesignationSyntax(SyntaxKind kind, SyntaxToken underscoreToken)
        : base(kind)
    {
        this.SlotCount = 1;
        this.AdjustFlagsAndWidth(underscoreToken);
        this.underscoreToken = underscoreToken;
    }

    public SyntaxToken UnderscoreToken => this.underscoreToken;

    internal override GreenNode? GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.underscoreToken;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new CSharp.Syntax.DiscardDesignationSyntax(this, parent, position);

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor) => visitor.VisitDiscardDesignation(this);

    public override void Accept(CSharpSyntaxVisitor visitor) => visitor.VisitDiscardDesignation(this);

    public DiscardDesignationSyntax Update(SyntaxToken underscoreToken)
    {
        if (underscoreToken != this.UnderscoreToken)
        {
            var newNode = SyntaxFactory.DiscardDesignation(underscoreToken);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
        => new DiscardDesignationSyntax(this.Kind, this.underscoreToken, diagnostics, GetAnnotations());

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
        => new DiscardDesignationSyntax(this.Kind, this.underscoreToken, GetDiagnostics(), annotations);

    internal DiscardDesignationSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 1;
      var underscoreToken = (SyntaxToken)reader.ReadValue();
      if (underscoreToken != null)
      {
         AdjustFlagsAndWidth(underscoreToken);
         this.underscoreToken = underscoreToken;
      }
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.underscoreToken);
    }

    static DiscardDesignationSyntax()
    {
       ObjectBinder.RegisterTypeReader(typeof(DiscardDesignationSyntax), r => new DiscardDesignationSyntax(r));
    }
  }

  internal sealed partial class ParenthesizedVariableDesignationSyntax : VariableDesignationSyntax
  {
    internal readonly SyntaxToken openParenToken;
    internal readonly GreenNode? variables;
    internal readonly SyntaxToken closeParenToken;

    internal ParenthesizedVariableDesignationSyntax(SyntaxKind kind, SyntaxToken openParenToken, GreenNode? variables, SyntaxToken closeParenToken, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 3;
        this.AdjustFlagsAndWidth(openParenToken);
        this.openParenToken = openParenToken;
        if (variables != null)
        {
            this.AdjustFlagsAndWidth(variables);
            this.variables = variables;
        }
        this.AdjustFlagsAndWidth(closeParenToken);
        this.closeParenToken = closeParenToken;
    }


    internal ParenthesizedVariableDesignationSyntax(SyntaxKind kind, SyntaxToken openParenToken, GreenNode? variables, SyntaxToken closeParenToken, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 3;
        this.AdjustFlagsAndWidth(openParenToken);
        this.openParenToken = openParenToken;
        if (variables != null)
        {
            this.AdjustFlagsAndWidth(variables);
            this.variables = variables;
        }
        this.AdjustFlagsAndWidth(closeParenToken);
        this.closeParenToken = closeParenToken;
    }


    internal ParenthesizedVariableDesignationSyntax(SyntaxKind kind, SyntaxToken openParenToken, GreenNode? variables, SyntaxToken closeParenToken)
        : base(kind)
    {
        this.SlotCount = 3;
        this.AdjustFlagsAndWidth(openParenToken);
        this.openParenToken = openParenToken;
        if (variables != null)
        {
            this.AdjustFlagsAndWidth(variables);
            this.variables = variables;
        }
        this.AdjustFlagsAndWidth(closeParenToken);
        this.closeParenToken = closeParenToken;
    }

    public SyntaxToken OpenParenToken => this.openParenToken;
    public Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<VariableDesignationSyntax> Variables => new Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<VariableDesignationSyntax>(new Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<CSharpSyntaxNode>(this.variables));
    public SyntaxToken CloseParenToken => this.closeParenToken;

    internal override GreenNode? GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.openParenToken;
            case 1: return this.variables;
            case 2: return this.closeParenToken;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new CSharp.Syntax.ParenthesizedVariableDesignationSyntax(this, parent, position);

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor) => visitor.VisitParenthesizedVariableDesignation(this);

    public override void Accept(CSharpSyntaxVisitor visitor) => visitor.VisitParenthesizedVariableDesignation(this);

    public ParenthesizedVariableDesignationSyntax Update(SyntaxToken openParenToken, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<VariableDesignationSyntax> variables, SyntaxToken closeParenToken)
    {
        if (openParenToken != this.OpenParenToken || variables != this.Variables || closeParenToken != this.CloseParenToken)
        {
            var newNode = SyntaxFactory.ParenthesizedVariableDesignation(openParenToken, variables, closeParenToken);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
        => new ParenthesizedVariableDesignationSyntax(this.Kind, this.openParenToken, this.variables, this.closeParenToken, diagnostics, GetAnnotations());

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
        => new ParenthesizedVariableDesignationSyntax(this.Kind, this.openParenToken, this.variables, this.closeParenToken, GetDiagnostics(), annotations);

    internal ParenthesizedVariableDesignationSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 3;
      var openParenToken = (SyntaxToken)reader.ReadValue();
      if (openParenToken != null)
      {
         AdjustFlagsAndWidth(openParenToken);
         this.openParenToken = openParenToken;
      }
      var variables = (GreenNode?)reader.ReadValue();
      if (variables != null)
      {
         AdjustFlagsAndWidth(variables);
         this.variables = variables;
      }
      var closeParenToken = (SyntaxToken)reader.ReadValue();
      if (closeParenToken != null)
      {
         AdjustFlagsAndWidth(closeParenToken);
         this.closeParenToken = closeParenToken;
      }
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.openParenToken);
      writer.WriteValue(this.variables);
      writer.WriteValue(this.closeParenToken);
    }

    static ParenthesizedVariableDesignationSyntax()
    {
       ObjectBinder.RegisterTypeReader(typeof(ParenthesizedVariableDesignationSyntax), r => new ParenthesizedVariableDesignationSyntax(r));
    }
  }

  internal sealed partial class ExpressionStatementSyntax : StatementSyntax
  {
    internal readonly ExpressionSyntax expression;
    internal readonly SyntaxToken semicolonToken;

    internal ExpressionStatementSyntax(SyntaxKind kind, ExpressionSyntax expression, SyntaxToken semicolonToken, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 2;
        this.AdjustFlagsAndWidth(expression);
        this.expression = expression;
        this.AdjustFlagsAndWidth(semicolonToken);
        this.semicolonToken = semicolonToken;
    }


    internal ExpressionStatementSyntax(SyntaxKind kind, ExpressionSyntax expression, SyntaxToken semicolonToken, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 2;
        this.AdjustFlagsAndWidth(expression);
        this.expression = expression;
        this.AdjustFlagsAndWidth(semicolonToken);
        this.semicolonToken = semicolonToken;
    }


    internal ExpressionStatementSyntax(SyntaxKind kind, ExpressionSyntax expression, SyntaxToken semicolonToken)
        : base(kind)
    {
        this.SlotCount = 2;
        this.AdjustFlagsAndWidth(expression);
        this.expression = expression;
        this.AdjustFlagsAndWidth(semicolonToken);
        this.semicolonToken = semicolonToken;
    }

    public ExpressionSyntax Expression => this.expression;
    public SyntaxToken SemicolonToken => this.semicolonToken;

    internal override GreenNode? GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.expression;
            case 1: return this.semicolonToken;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new CSharp.Syntax.ExpressionStatementSyntax(this, parent, position);

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor) => visitor.VisitExpressionStatement(this);

    public override void Accept(CSharpSyntaxVisitor visitor) => visitor.VisitExpressionStatement(this);

    public ExpressionStatementSyntax Update(ExpressionSyntax expression, SyntaxToken semicolonToken)
    {
        if (expression != this.Expression || semicolonToken != this.SemicolonToken)
        {
            var newNode = SyntaxFactory.ExpressionStatement(expression, semicolonToken);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
        => new ExpressionStatementSyntax(this.Kind, this.expression, this.semicolonToken, diagnostics, GetAnnotations());

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
        => new ExpressionStatementSyntax(this.Kind, this.expression, this.semicolonToken, GetDiagnostics(), annotations);

    internal ExpressionStatementSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 2;
      var expression = (ExpressionSyntax)reader.ReadValue();
      if (expression != null)
      {
         AdjustFlagsAndWidth(expression);
         this.expression = expression;
      }
      var semicolonToken = (SyntaxToken)reader.ReadValue();
      if (semicolonToken != null)
      {
         AdjustFlagsAndWidth(semicolonToken);
         this.semicolonToken = semicolonToken;
      }
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.expression);
      writer.WriteValue(this.semicolonToken);
    }

    static ExpressionStatementSyntax()
    {
       ObjectBinder.RegisterTypeReader(typeof(ExpressionStatementSyntax), r => new ExpressionStatementSyntax(r));
    }
  }

  internal sealed partial class EmptyStatementSyntax : StatementSyntax
  {
    internal readonly SyntaxToken semicolonToken;

    internal EmptyStatementSyntax(SyntaxKind kind, SyntaxToken semicolonToken, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 1;
        this.AdjustFlagsAndWidth(semicolonToken);
        this.semicolonToken = semicolonToken;
    }


    internal EmptyStatementSyntax(SyntaxKind kind, SyntaxToken semicolonToken, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 1;
        this.AdjustFlagsAndWidth(semicolonToken);
        this.semicolonToken = semicolonToken;
    }


    internal EmptyStatementSyntax(SyntaxKind kind, SyntaxToken semicolonToken)
        : base(kind)
    {
        this.SlotCount = 1;
        this.AdjustFlagsAndWidth(semicolonToken);
        this.semicolonToken = semicolonToken;
    }

    public SyntaxToken SemicolonToken => this.semicolonToken;

    internal override GreenNode? GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.semicolonToken;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new CSharp.Syntax.EmptyStatementSyntax(this, parent, position);

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor) => visitor.VisitEmptyStatement(this);

    public override void Accept(CSharpSyntaxVisitor visitor) => visitor.VisitEmptyStatement(this);

    public EmptyStatementSyntax Update(SyntaxToken semicolonToken)
    {
        if (semicolonToken != this.SemicolonToken)
        {
            var newNode = SyntaxFactory.EmptyStatement(semicolonToken);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
        => new EmptyStatementSyntax(this.Kind, this.semicolonToken, diagnostics, GetAnnotations());

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
        => new EmptyStatementSyntax(this.Kind, this.semicolonToken, GetDiagnostics(), annotations);

    internal EmptyStatementSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 1;
      var semicolonToken = (SyntaxToken)reader.ReadValue();
      if (semicolonToken != null)
      {
         AdjustFlagsAndWidth(semicolonToken);
         this.semicolonToken = semicolonToken;
      }
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.semicolonToken);
    }

    static EmptyStatementSyntax()
    {
       ObjectBinder.RegisterTypeReader(typeof(EmptyStatementSyntax), r => new EmptyStatementSyntax(r));
    }
  }

  /// <summary>Represents a labeled statement syntax.</summary>
  internal sealed partial class LabeledStatementSyntax : StatementSyntax
  {
    internal readonly SyntaxToken identifier;
    internal readonly SyntaxToken colonToken;
    internal readonly StatementSyntax statement;

    internal LabeledStatementSyntax(SyntaxKind kind, SyntaxToken identifier, SyntaxToken colonToken, StatementSyntax statement, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 3;
        this.AdjustFlagsAndWidth(identifier);
        this.identifier = identifier;
        this.AdjustFlagsAndWidth(colonToken);
        this.colonToken = colonToken;
        this.AdjustFlagsAndWidth(statement);
        this.statement = statement;
    }


    internal LabeledStatementSyntax(SyntaxKind kind, SyntaxToken identifier, SyntaxToken colonToken, StatementSyntax statement, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 3;
        this.AdjustFlagsAndWidth(identifier);
        this.identifier = identifier;
        this.AdjustFlagsAndWidth(colonToken);
        this.colonToken = colonToken;
        this.AdjustFlagsAndWidth(statement);
        this.statement = statement;
    }


    internal LabeledStatementSyntax(SyntaxKind kind, SyntaxToken identifier, SyntaxToken colonToken, StatementSyntax statement)
        : base(kind)
    {
        this.SlotCount = 3;
        this.AdjustFlagsAndWidth(identifier);
        this.identifier = identifier;
        this.AdjustFlagsAndWidth(colonToken);
        this.colonToken = colonToken;
        this.AdjustFlagsAndWidth(statement);
        this.statement = statement;
    }

    /// <summary>Gets the identifier.</summary>
    public SyntaxToken Identifier => this.identifier;
    /// <summary>Gets a SyntaxToken that represents the colon following the statement's label.</summary>
    public SyntaxToken ColonToken => this.colonToken;
    public StatementSyntax Statement => this.statement;

    internal override GreenNode? GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.identifier;
            case 1: return this.colonToken;
            case 2: return this.statement;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new CSharp.Syntax.LabeledStatementSyntax(this, parent, position);

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor) => visitor.VisitLabeledStatement(this);

    public override void Accept(CSharpSyntaxVisitor visitor) => visitor.VisitLabeledStatement(this);

    public LabeledStatementSyntax Update(SyntaxToken identifier, SyntaxToken colonToken, StatementSyntax statement)
    {
        if (identifier != this.Identifier || colonToken != this.ColonToken || statement != this.Statement)
        {
            var newNode = SyntaxFactory.LabeledStatement(identifier, colonToken, statement);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
        => new LabeledStatementSyntax(this.Kind, this.identifier, this.colonToken, this.statement, diagnostics, GetAnnotations());

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
        => new LabeledStatementSyntax(this.Kind, this.identifier, this.colonToken, this.statement, GetDiagnostics(), annotations);

    internal LabeledStatementSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 3;
      var identifier = (SyntaxToken)reader.ReadValue();
      if (identifier != null)
      {
         AdjustFlagsAndWidth(identifier);
         this.identifier = identifier;
      }
      var colonToken = (SyntaxToken)reader.ReadValue();
      if (colonToken != null)
      {
         AdjustFlagsAndWidth(colonToken);
         this.colonToken = colonToken;
      }
      var statement = (StatementSyntax)reader.ReadValue();
      if (statement != null)
      {
         AdjustFlagsAndWidth(statement);
         this.statement = statement;
      }
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.identifier);
      writer.WriteValue(this.colonToken);
      writer.WriteValue(this.statement);
    }

    static LabeledStatementSyntax()
    {
       ObjectBinder.RegisterTypeReader(typeof(LabeledStatementSyntax), r => new LabeledStatementSyntax(r));
    }
  }

  /// <summary>
  /// Represents a goto statement syntax
  /// </summary>
  internal sealed partial class GotoStatementSyntax : StatementSyntax
  {
    internal readonly SyntaxToken gotoKeyword;
    internal readonly SyntaxToken? caseOrDefaultKeyword;
    internal readonly ExpressionSyntax? expression;
    internal readonly SyntaxToken semicolonToken;

    internal GotoStatementSyntax(SyntaxKind kind, SyntaxToken gotoKeyword, SyntaxToken? caseOrDefaultKeyword, ExpressionSyntax? expression, SyntaxToken semicolonToken, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 4;
        this.AdjustFlagsAndWidth(gotoKeyword);
        this.gotoKeyword = gotoKeyword;
        if (caseOrDefaultKeyword != null)
        {
            this.AdjustFlagsAndWidth(caseOrDefaultKeyword);
            this.caseOrDefaultKeyword = caseOrDefaultKeyword;
        }
        if (expression != null)
        {
            this.AdjustFlagsAndWidth(expression);
            this.expression = expression;
        }
        this.AdjustFlagsAndWidth(semicolonToken);
        this.semicolonToken = semicolonToken;
    }


    internal GotoStatementSyntax(SyntaxKind kind, SyntaxToken gotoKeyword, SyntaxToken? caseOrDefaultKeyword, ExpressionSyntax? expression, SyntaxToken semicolonToken, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 4;
        this.AdjustFlagsAndWidth(gotoKeyword);
        this.gotoKeyword = gotoKeyword;
        if (caseOrDefaultKeyword != null)
        {
            this.AdjustFlagsAndWidth(caseOrDefaultKeyword);
            this.caseOrDefaultKeyword = caseOrDefaultKeyword;
        }
        if (expression != null)
        {
            this.AdjustFlagsAndWidth(expression);
            this.expression = expression;
        }
        this.AdjustFlagsAndWidth(semicolonToken);
        this.semicolonToken = semicolonToken;
    }


    internal GotoStatementSyntax(SyntaxKind kind, SyntaxToken gotoKeyword, SyntaxToken? caseOrDefaultKeyword, ExpressionSyntax? expression, SyntaxToken semicolonToken)
        : base(kind)
    {
        this.SlotCount = 4;
        this.AdjustFlagsAndWidth(gotoKeyword);
        this.gotoKeyword = gotoKeyword;
        if (caseOrDefaultKeyword != null)
        {
            this.AdjustFlagsAndWidth(caseOrDefaultKeyword);
            this.caseOrDefaultKeyword = caseOrDefaultKeyword;
        }
        if (expression != null)
        {
            this.AdjustFlagsAndWidth(expression);
            this.expression = expression;
        }
        this.AdjustFlagsAndWidth(semicolonToken);
        this.semicolonToken = semicolonToken;
    }

    /// <summary>
    /// Gets a SyntaxToken that represents the goto keyword.
    /// </summary>
    public SyntaxToken GotoKeyword => this.gotoKeyword;
    /// <summary>
    /// Gets a SyntaxToken that represents the case or default keywords if any exists.
    /// </summary>
    public SyntaxToken? CaseOrDefaultKeyword => this.caseOrDefaultKeyword;
    /// <summary>
    /// Gets a constant expression for a goto case statement.
    /// </summary>
    public ExpressionSyntax? Expression => this.expression;
    /// <summary>
    /// Gets a SyntaxToken that represents the semi-colon at the end of the statement.
    /// </summary>
    public SyntaxToken SemicolonToken => this.semicolonToken;

    internal override GreenNode? GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.gotoKeyword;
            case 1: return this.caseOrDefaultKeyword;
            case 2: return this.expression;
            case 3: return this.semicolonToken;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new CSharp.Syntax.GotoStatementSyntax(this, parent, position);

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor) => visitor.VisitGotoStatement(this);

    public override void Accept(CSharpSyntaxVisitor visitor) => visitor.VisitGotoStatement(this);

    public GotoStatementSyntax Update(SyntaxToken gotoKeyword, SyntaxToken caseOrDefaultKeyword, ExpressionSyntax expression, SyntaxToken semicolonToken)
    {
        if (gotoKeyword != this.GotoKeyword || caseOrDefaultKeyword != this.CaseOrDefaultKeyword || expression != this.Expression || semicolonToken != this.SemicolonToken)
        {
            var newNode = SyntaxFactory.GotoStatement(this.Kind, gotoKeyword, caseOrDefaultKeyword, expression, semicolonToken);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
        => new GotoStatementSyntax(this.Kind, this.gotoKeyword, this.caseOrDefaultKeyword, this.expression, this.semicolonToken, diagnostics, GetAnnotations());

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
        => new GotoStatementSyntax(this.Kind, this.gotoKeyword, this.caseOrDefaultKeyword, this.expression, this.semicolonToken, GetDiagnostics(), annotations);

    internal GotoStatementSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 4;
      var gotoKeyword = (SyntaxToken)reader.ReadValue();
      if (gotoKeyword != null)
      {
         AdjustFlagsAndWidth(gotoKeyword);
         this.gotoKeyword = gotoKeyword;
      }
      var caseOrDefaultKeyword = (SyntaxToken?)reader.ReadValue();
      if (caseOrDefaultKeyword != null)
      {
         AdjustFlagsAndWidth(caseOrDefaultKeyword);
         this.caseOrDefaultKeyword = caseOrDefaultKeyword;
      }
      var expression = (ExpressionSyntax?)reader.ReadValue();
      if (expression != null)
      {
         AdjustFlagsAndWidth(expression);
         this.expression = expression;
      }
      var semicolonToken = (SyntaxToken)reader.ReadValue();
      if (semicolonToken != null)
      {
         AdjustFlagsAndWidth(semicolonToken);
         this.semicolonToken = semicolonToken;
      }
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.gotoKeyword);
      writer.WriteValue(this.caseOrDefaultKeyword);
      writer.WriteValue(this.expression);
      writer.WriteValue(this.semicolonToken);
    }

    static GotoStatementSyntax()
    {
       ObjectBinder.RegisterTypeReader(typeof(GotoStatementSyntax), r => new GotoStatementSyntax(r));
    }
  }

  internal sealed partial class BreakStatementSyntax : StatementSyntax
  {
    internal readonly SyntaxToken breakKeyword;
    internal readonly SyntaxToken semicolonToken;

    internal BreakStatementSyntax(SyntaxKind kind, SyntaxToken breakKeyword, SyntaxToken semicolonToken, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 2;
        this.AdjustFlagsAndWidth(breakKeyword);
        this.breakKeyword = breakKeyword;
        this.AdjustFlagsAndWidth(semicolonToken);
        this.semicolonToken = semicolonToken;
    }


    internal BreakStatementSyntax(SyntaxKind kind, SyntaxToken breakKeyword, SyntaxToken semicolonToken, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 2;
        this.AdjustFlagsAndWidth(breakKeyword);
        this.breakKeyword = breakKeyword;
        this.AdjustFlagsAndWidth(semicolonToken);
        this.semicolonToken = semicolonToken;
    }


    internal BreakStatementSyntax(SyntaxKind kind, SyntaxToken breakKeyword, SyntaxToken semicolonToken)
        : base(kind)
    {
        this.SlotCount = 2;
        this.AdjustFlagsAndWidth(breakKeyword);
        this.breakKeyword = breakKeyword;
        this.AdjustFlagsAndWidth(semicolonToken);
        this.semicolonToken = semicolonToken;
    }

    public SyntaxToken BreakKeyword => this.breakKeyword;
    public SyntaxToken SemicolonToken => this.semicolonToken;

    internal override GreenNode? GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.breakKeyword;
            case 1: return this.semicolonToken;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new CSharp.Syntax.BreakStatementSyntax(this, parent, position);

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor) => visitor.VisitBreakStatement(this);

    public override void Accept(CSharpSyntaxVisitor visitor) => visitor.VisitBreakStatement(this);

    public BreakStatementSyntax Update(SyntaxToken breakKeyword, SyntaxToken semicolonToken)
    {
        if (breakKeyword != this.BreakKeyword || semicolonToken != this.SemicolonToken)
        {
            var newNode = SyntaxFactory.BreakStatement(breakKeyword, semicolonToken);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
        => new BreakStatementSyntax(this.Kind, this.breakKeyword, this.semicolonToken, diagnostics, GetAnnotations());

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
        => new BreakStatementSyntax(this.Kind, this.breakKeyword, this.semicolonToken, GetDiagnostics(), annotations);

    internal BreakStatementSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 2;
      var breakKeyword = (SyntaxToken)reader.ReadValue();
      if (breakKeyword != null)
      {
         AdjustFlagsAndWidth(breakKeyword);
         this.breakKeyword = breakKeyword;
      }
      var semicolonToken = (SyntaxToken)reader.ReadValue();
      if (semicolonToken != null)
      {
         AdjustFlagsAndWidth(semicolonToken);
         this.semicolonToken = semicolonToken;
      }
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.breakKeyword);
      writer.WriteValue(this.semicolonToken);
    }

    static BreakStatementSyntax()
    {
       ObjectBinder.RegisterTypeReader(typeof(BreakStatementSyntax), r => new BreakStatementSyntax(r));
    }
  }

  internal sealed partial class ContinueStatementSyntax : StatementSyntax
  {
    internal readonly SyntaxToken continueKeyword;
    internal readonly SyntaxToken semicolonToken;

    internal ContinueStatementSyntax(SyntaxKind kind, SyntaxToken continueKeyword, SyntaxToken semicolonToken, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 2;
        this.AdjustFlagsAndWidth(continueKeyword);
        this.continueKeyword = continueKeyword;
        this.AdjustFlagsAndWidth(semicolonToken);
        this.semicolonToken = semicolonToken;
    }


    internal ContinueStatementSyntax(SyntaxKind kind, SyntaxToken continueKeyword, SyntaxToken semicolonToken, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 2;
        this.AdjustFlagsAndWidth(continueKeyword);
        this.continueKeyword = continueKeyword;
        this.AdjustFlagsAndWidth(semicolonToken);
        this.semicolonToken = semicolonToken;
    }


    internal ContinueStatementSyntax(SyntaxKind kind, SyntaxToken continueKeyword, SyntaxToken semicolonToken)
        : base(kind)
    {
        this.SlotCount = 2;
        this.AdjustFlagsAndWidth(continueKeyword);
        this.continueKeyword = continueKeyword;
        this.AdjustFlagsAndWidth(semicolonToken);
        this.semicolonToken = semicolonToken;
    }

    public SyntaxToken ContinueKeyword => this.continueKeyword;
    public SyntaxToken SemicolonToken => this.semicolonToken;

    internal override GreenNode? GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.continueKeyword;
            case 1: return this.semicolonToken;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new CSharp.Syntax.ContinueStatementSyntax(this, parent, position);

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor) => visitor.VisitContinueStatement(this);

    public override void Accept(CSharpSyntaxVisitor visitor) => visitor.VisitContinueStatement(this);

    public ContinueStatementSyntax Update(SyntaxToken continueKeyword, SyntaxToken semicolonToken)
    {
        if (continueKeyword != this.ContinueKeyword || semicolonToken != this.SemicolonToken)
        {
            var newNode = SyntaxFactory.ContinueStatement(continueKeyword, semicolonToken);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
        => new ContinueStatementSyntax(this.Kind, this.continueKeyword, this.semicolonToken, diagnostics, GetAnnotations());

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
        => new ContinueStatementSyntax(this.Kind, this.continueKeyword, this.semicolonToken, GetDiagnostics(), annotations);

    internal ContinueStatementSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 2;
      var continueKeyword = (SyntaxToken)reader.ReadValue();
      if (continueKeyword != null)
      {
         AdjustFlagsAndWidth(continueKeyword);
         this.continueKeyword = continueKeyword;
      }
      var semicolonToken = (SyntaxToken)reader.ReadValue();
      if (semicolonToken != null)
      {
         AdjustFlagsAndWidth(semicolonToken);
         this.semicolonToken = semicolonToken;
      }
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.continueKeyword);
      writer.WriteValue(this.semicolonToken);
    }

    static ContinueStatementSyntax()
    {
       ObjectBinder.RegisterTypeReader(typeof(ContinueStatementSyntax), r => new ContinueStatementSyntax(r));
    }
  }

  internal sealed partial class ReturnStatementSyntax : StatementSyntax
  {
    internal readonly SyntaxToken returnKeyword;
    internal readonly ExpressionSyntax? expression;
    internal readonly SyntaxToken semicolonToken;

    internal ReturnStatementSyntax(SyntaxKind kind, SyntaxToken returnKeyword, ExpressionSyntax? expression, SyntaxToken semicolonToken, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 3;
        this.AdjustFlagsAndWidth(returnKeyword);
        this.returnKeyword = returnKeyword;
        if (expression != null)
        {
            this.AdjustFlagsAndWidth(expression);
            this.expression = expression;
        }
        this.AdjustFlagsAndWidth(semicolonToken);
        this.semicolonToken = semicolonToken;
    }


    internal ReturnStatementSyntax(SyntaxKind kind, SyntaxToken returnKeyword, ExpressionSyntax? expression, SyntaxToken semicolonToken, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 3;
        this.AdjustFlagsAndWidth(returnKeyword);
        this.returnKeyword = returnKeyword;
        if (expression != null)
        {
            this.AdjustFlagsAndWidth(expression);
            this.expression = expression;
        }
        this.AdjustFlagsAndWidth(semicolonToken);
        this.semicolonToken = semicolonToken;
    }


    internal ReturnStatementSyntax(SyntaxKind kind, SyntaxToken returnKeyword, ExpressionSyntax? expression, SyntaxToken semicolonToken)
        : base(kind)
    {
        this.SlotCount = 3;
        this.AdjustFlagsAndWidth(returnKeyword);
        this.returnKeyword = returnKeyword;
        if (expression != null)
        {
            this.AdjustFlagsAndWidth(expression);
            this.expression = expression;
        }
        this.AdjustFlagsAndWidth(semicolonToken);
        this.semicolonToken = semicolonToken;
    }

    public SyntaxToken ReturnKeyword => this.returnKeyword;
    public ExpressionSyntax? Expression => this.expression;
    public SyntaxToken SemicolonToken => this.semicolonToken;

    internal override GreenNode? GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.returnKeyword;
            case 1: return this.expression;
            case 2: return this.semicolonToken;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new CSharp.Syntax.ReturnStatementSyntax(this, parent, position);

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor) => visitor.VisitReturnStatement(this);

    public override void Accept(CSharpSyntaxVisitor visitor) => visitor.VisitReturnStatement(this);

    public ReturnStatementSyntax Update(SyntaxToken returnKeyword, ExpressionSyntax expression, SyntaxToken semicolonToken)
    {
        if (returnKeyword != this.ReturnKeyword || expression != this.Expression || semicolonToken != this.SemicolonToken)
        {
            var newNode = SyntaxFactory.ReturnStatement(returnKeyword, expression, semicolonToken);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
        => new ReturnStatementSyntax(this.Kind, this.returnKeyword, this.expression, this.semicolonToken, diagnostics, GetAnnotations());

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
        => new ReturnStatementSyntax(this.Kind, this.returnKeyword, this.expression, this.semicolonToken, GetDiagnostics(), annotations);

    internal ReturnStatementSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 3;
      var returnKeyword = (SyntaxToken)reader.ReadValue();
      if (returnKeyword != null)
      {
         AdjustFlagsAndWidth(returnKeyword);
         this.returnKeyword = returnKeyword;
      }
      var expression = (ExpressionSyntax?)reader.ReadValue();
      if (expression != null)
      {
         AdjustFlagsAndWidth(expression);
         this.expression = expression;
      }
      var semicolonToken = (SyntaxToken)reader.ReadValue();
      if (semicolonToken != null)
      {
         AdjustFlagsAndWidth(semicolonToken);
         this.semicolonToken = semicolonToken;
      }
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.returnKeyword);
      writer.WriteValue(this.expression);
      writer.WriteValue(this.semicolonToken);
    }

    static ReturnStatementSyntax()
    {
       ObjectBinder.RegisterTypeReader(typeof(ReturnStatementSyntax), r => new ReturnStatementSyntax(r));
    }
  }

  internal sealed partial class ThrowStatementSyntax : StatementSyntax
  {
    internal readonly SyntaxToken throwKeyword;
    internal readonly ExpressionSyntax? expression;
    internal readonly SyntaxToken semicolonToken;

    internal ThrowStatementSyntax(SyntaxKind kind, SyntaxToken throwKeyword, ExpressionSyntax? expression, SyntaxToken semicolonToken, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 3;
        this.AdjustFlagsAndWidth(throwKeyword);
        this.throwKeyword = throwKeyword;
        if (expression != null)
        {
            this.AdjustFlagsAndWidth(expression);
            this.expression = expression;
        }
        this.AdjustFlagsAndWidth(semicolonToken);
        this.semicolonToken = semicolonToken;
    }


    internal ThrowStatementSyntax(SyntaxKind kind, SyntaxToken throwKeyword, ExpressionSyntax? expression, SyntaxToken semicolonToken, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 3;
        this.AdjustFlagsAndWidth(throwKeyword);
        this.throwKeyword = throwKeyword;
        if (expression != null)
        {
            this.AdjustFlagsAndWidth(expression);
            this.expression = expression;
        }
        this.AdjustFlagsAndWidth(semicolonToken);
        this.semicolonToken = semicolonToken;
    }


    internal ThrowStatementSyntax(SyntaxKind kind, SyntaxToken throwKeyword, ExpressionSyntax? expression, SyntaxToken semicolonToken)
        : base(kind)
    {
        this.SlotCount = 3;
        this.AdjustFlagsAndWidth(throwKeyword);
        this.throwKeyword = throwKeyword;
        if (expression != null)
        {
            this.AdjustFlagsAndWidth(expression);
            this.expression = expression;
        }
        this.AdjustFlagsAndWidth(semicolonToken);
        this.semicolonToken = semicolonToken;
    }

    public SyntaxToken ThrowKeyword => this.throwKeyword;
    public ExpressionSyntax? Expression => this.expression;
    public SyntaxToken SemicolonToken => this.semicolonToken;

    internal override GreenNode? GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.throwKeyword;
            case 1: return this.expression;
            case 2: return this.semicolonToken;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new CSharp.Syntax.ThrowStatementSyntax(this, parent, position);

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor) => visitor.VisitThrowStatement(this);

    public override void Accept(CSharpSyntaxVisitor visitor) => visitor.VisitThrowStatement(this);

    public ThrowStatementSyntax Update(SyntaxToken throwKeyword, ExpressionSyntax expression, SyntaxToken semicolonToken)
    {
        if (throwKeyword != this.ThrowKeyword || expression != this.Expression || semicolonToken != this.SemicolonToken)
        {
            var newNode = SyntaxFactory.ThrowStatement(throwKeyword, expression, semicolonToken);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
        => new ThrowStatementSyntax(this.Kind, this.throwKeyword, this.expression, this.semicolonToken, diagnostics, GetAnnotations());

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
        => new ThrowStatementSyntax(this.Kind, this.throwKeyword, this.expression, this.semicolonToken, GetDiagnostics(), annotations);

    internal ThrowStatementSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 3;
      var throwKeyword = (SyntaxToken)reader.ReadValue();
      if (throwKeyword != null)
      {
         AdjustFlagsAndWidth(throwKeyword);
         this.throwKeyword = throwKeyword;
      }
      var expression = (ExpressionSyntax?)reader.ReadValue();
      if (expression != null)
      {
         AdjustFlagsAndWidth(expression);
         this.expression = expression;
      }
      var semicolonToken = (SyntaxToken)reader.ReadValue();
      if (semicolonToken != null)
      {
         AdjustFlagsAndWidth(semicolonToken);
         this.semicolonToken = semicolonToken;
      }
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.throwKeyword);
      writer.WriteValue(this.expression);
      writer.WriteValue(this.semicolonToken);
    }

    static ThrowStatementSyntax()
    {
       ObjectBinder.RegisterTypeReader(typeof(ThrowStatementSyntax), r => new ThrowStatementSyntax(r));
    }
  }

  internal sealed partial class YieldStatementSyntax : StatementSyntax
  {
    internal readonly SyntaxToken yieldKeyword;
    internal readonly SyntaxToken returnOrBreakKeyword;
    internal readonly ExpressionSyntax? expression;
    internal readonly SyntaxToken semicolonToken;

    internal YieldStatementSyntax(SyntaxKind kind, SyntaxToken yieldKeyword, SyntaxToken returnOrBreakKeyword, ExpressionSyntax? expression, SyntaxToken semicolonToken, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 4;
        this.AdjustFlagsAndWidth(yieldKeyword);
        this.yieldKeyword = yieldKeyword;
        this.AdjustFlagsAndWidth(returnOrBreakKeyword);
        this.returnOrBreakKeyword = returnOrBreakKeyword;
        if (expression != null)
        {
            this.AdjustFlagsAndWidth(expression);
            this.expression = expression;
        }
        this.AdjustFlagsAndWidth(semicolonToken);
        this.semicolonToken = semicolonToken;
    }


    internal YieldStatementSyntax(SyntaxKind kind, SyntaxToken yieldKeyword, SyntaxToken returnOrBreakKeyword, ExpressionSyntax? expression, SyntaxToken semicolonToken, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 4;
        this.AdjustFlagsAndWidth(yieldKeyword);
        this.yieldKeyword = yieldKeyword;
        this.AdjustFlagsAndWidth(returnOrBreakKeyword);
        this.returnOrBreakKeyword = returnOrBreakKeyword;
        if (expression != null)
        {
            this.AdjustFlagsAndWidth(expression);
            this.expression = expression;
        }
        this.AdjustFlagsAndWidth(semicolonToken);
        this.semicolonToken = semicolonToken;
    }


    internal YieldStatementSyntax(SyntaxKind kind, SyntaxToken yieldKeyword, SyntaxToken returnOrBreakKeyword, ExpressionSyntax? expression, SyntaxToken semicolonToken)
        : base(kind)
    {
        this.SlotCount = 4;
        this.AdjustFlagsAndWidth(yieldKeyword);
        this.yieldKeyword = yieldKeyword;
        this.AdjustFlagsAndWidth(returnOrBreakKeyword);
        this.returnOrBreakKeyword = returnOrBreakKeyword;
        if (expression != null)
        {
            this.AdjustFlagsAndWidth(expression);
            this.expression = expression;
        }
        this.AdjustFlagsAndWidth(semicolonToken);
        this.semicolonToken = semicolonToken;
    }

    public SyntaxToken YieldKeyword => this.yieldKeyword;
    public SyntaxToken ReturnOrBreakKeyword => this.returnOrBreakKeyword;
    public ExpressionSyntax? Expression => this.expression;
    public SyntaxToken SemicolonToken => this.semicolonToken;

    internal override GreenNode? GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.yieldKeyword;
            case 1: return this.returnOrBreakKeyword;
            case 2: return this.expression;
            case 3: return this.semicolonToken;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new CSharp.Syntax.YieldStatementSyntax(this, parent, position);

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor) => visitor.VisitYieldStatement(this);

    public override void Accept(CSharpSyntaxVisitor visitor) => visitor.VisitYieldStatement(this);

    public YieldStatementSyntax Update(SyntaxToken yieldKeyword, SyntaxToken returnOrBreakKeyword, ExpressionSyntax expression, SyntaxToken semicolonToken)
    {
        if (yieldKeyword != this.YieldKeyword || returnOrBreakKeyword != this.ReturnOrBreakKeyword || expression != this.Expression || semicolonToken != this.SemicolonToken)
        {
            var newNode = SyntaxFactory.YieldStatement(this.Kind, yieldKeyword, returnOrBreakKeyword, expression, semicolonToken);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
        => new YieldStatementSyntax(this.Kind, this.yieldKeyword, this.returnOrBreakKeyword, this.expression, this.semicolonToken, diagnostics, GetAnnotations());

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
        => new YieldStatementSyntax(this.Kind, this.yieldKeyword, this.returnOrBreakKeyword, this.expression, this.semicolonToken, GetDiagnostics(), annotations);

    internal YieldStatementSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 4;
      var yieldKeyword = (SyntaxToken)reader.ReadValue();
      if (yieldKeyword != null)
      {
         AdjustFlagsAndWidth(yieldKeyword);
         this.yieldKeyword = yieldKeyword;
      }
      var returnOrBreakKeyword = (SyntaxToken)reader.ReadValue();
      if (returnOrBreakKeyword != null)
      {
         AdjustFlagsAndWidth(returnOrBreakKeyword);
         this.returnOrBreakKeyword = returnOrBreakKeyword;
      }
      var expression = (ExpressionSyntax?)reader.ReadValue();
      if (expression != null)
      {
         AdjustFlagsAndWidth(expression);
         this.expression = expression;
      }
      var semicolonToken = (SyntaxToken)reader.ReadValue();
      if (semicolonToken != null)
      {
         AdjustFlagsAndWidth(semicolonToken);
         this.semicolonToken = semicolonToken;
      }
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.yieldKeyword);
      writer.WriteValue(this.returnOrBreakKeyword);
      writer.WriteValue(this.expression);
      writer.WriteValue(this.semicolonToken);
    }

    static YieldStatementSyntax()
    {
       ObjectBinder.RegisterTypeReader(typeof(YieldStatementSyntax), r => new YieldStatementSyntax(r));
    }
  }

  internal sealed partial class WhileStatementSyntax : StatementSyntax
  {
    internal readonly SyntaxToken whileKeyword;
    internal readonly SyntaxToken openParenToken;
    internal readonly ExpressionSyntax condition;
    internal readonly SyntaxToken closeParenToken;
    internal readonly StatementSyntax statement;

    internal WhileStatementSyntax(SyntaxKind kind, SyntaxToken whileKeyword, SyntaxToken openParenToken, ExpressionSyntax condition, SyntaxToken closeParenToken, StatementSyntax statement, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 5;
        this.AdjustFlagsAndWidth(whileKeyword);
        this.whileKeyword = whileKeyword;
        this.AdjustFlagsAndWidth(openParenToken);
        this.openParenToken = openParenToken;
        this.AdjustFlagsAndWidth(condition);
        this.condition = condition;
        this.AdjustFlagsAndWidth(closeParenToken);
        this.closeParenToken = closeParenToken;
        this.AdjustFlagsAndWidth(statement);
        this.statement = statement;
    }


    internal WhileStatementSyntax(SyntaxKind kind, SyntaxToken whileKeyword, SyntaxToken openParenToken, ExpressionSyntax condition, SyntaxToken closeParenToken, StatementSyntax statement, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 5;
        this.AdjustFlagsAndWidth(whileKeyword);
        this.whileKeyword = whileKeyword;
        this.AdjustFlagsAndWidth(openParenToken);
        this.openParenToken = openParenToken;
        this.AdjustFlagsAndWidth(condition);
        this.condition = condition;
        this.AdjustFlagsAndWidth(closeParenToken);
        this.closeParenToken = closeParenToken;
        this.AdjustFlagsAndWidth(statement);
        this.statement = statement;
    }


    internal WhileStatementSyntax(SyntaxKind kind, SyntaxToken whileKeyword, SyntaxToken openParenToken, ExpressionSyntax condition, SyntaxToken closeParenToken, StatementSyntax statement)
        : base(kind)
    {
        this.SlotCount = 5;
        this.AdjustFlagsAndWidth(whileKeyword);
        this.whileKeyword = whileKeyword;
        this.AdjustFlagsAndWidth(openParenToken);
        this.openParenToken = openParenToken;
        this.AdjustFlagsAndWidth(condition);
        this.condition = condition;
        this.AdjustFlagsAndWidth(closeParenToken);
        this.closeParenToken = closeParenToken;
        this.AdjustFlagsAndWidth(statement);
        this.statement = statement;
    }

    public SyntaxToken WhileKeyword => this.whileKeyword;
    public SyntaxToken OpenParenToken => this.openParenToken;
    public ExpressionSyntax Condition => this.condition;
    public SyntaxToken CloseParenToken => this.closeParenToken;
    public StatementSyntax Statement => this.statement;

    internal override GreenNode? GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.whileKeyword;
            case 1: return this.openParenToken;
            case 2: return this.condition;
            case 3: return this.closeParenToken;
            case 4: return this.statement;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new CSharp.Syntax.WhileStatementSyntax(this, parent, position);

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor) => visitor.VisitWhileStatement(this);

    public override void Accept(CSharpSyntaxVisitor visitor) => visitor.VisitWhileStatement(this);

    public WhileStatementSyntax Update(SyntaxToken whileKeyword, SyntaxToken openParenToken, ExpressionSyntax condition, SyntaxToken closeParenToken, StatementSyntax statement)
    {
        if (whileKeyword != this.WhileKeyword || openParenToken != this.OpenParenToken || condition != this.Condition || closeParenToken != this.CloseParenToken || statement != this.Statement)
        {
            var newNode = SyntaxFactory.WhileStatement(whileKeyword, openParenToken, condition, closeParenToken, statement);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
        => new WhileStatementSyntax(this.Kind, this.whileKeyword, this.openParenToken, this.condition, this.closeParenToken, this.statement, diagnostics, GetAnnotations());

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
        => new WhileStatementSyntax(this.Kind, this.whileKeyword, this.openParenToken, this.condition, this.closeParenToken, this.statement, GetDiagnostics(), annotations);

    internal WhileStatementSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 5;
      var whileKeyword = (SyntaxToken)reader.ReadValue();
      if (whileKeyword != null)
      {
         AdjustFlagsAndWidth(whileKeyword);
         this.whileKeyword = whileKeyword;
      }
      var openParenToken = (SyntaxToken)reader.ReadValue();
      if (openParenToken != null)
      {
         AdjustFlagsAndWidth(openParenToken);
         this.openParenToken = openParenToken;
      }
      var condition = (ExpressionSyntax)reader.ReadValue();
      if (condition != null)
      {
         AdjustFlagsAndWidth(condition);
         this.condition = condition;
      }
      var closeParenToken = (SyntaxToken)reader.ReadValue();
      if (closeParenToken != null)
      {
         AdjustFlagsAndWidth(closeParenToken);
         this.closeParenToken = closeParenToken;
      }
      var statement = (StatementSyntax)reader.ReadValue();
      if (statement != null)
      {
         AdjustFlagsAndWidth(statement);
         this.statement = statement;
      }
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.whileKeyword);
      writer.WriteValue(this.openParenToken);
      writer.WriteValue(this.condition);
      writer.WriteValue(this.closeParenToken);
      writer.WriteValue(this.statement);
    }

    static WhileStatementSyntax()
    {
       ObjectBinder.RegisterTypeReader(typeof(WhileStatementSyntax), r => new WhileStatementSyntax(r));
    }
  }

  internal sealed partial class DoStatementSyntax : StatementSyntax
  {
    internal readonly SyntaxToken doKeyword;
    internal readonly StatementSyntax statement;
    internal readonly SyntaxToken whileKeyword;
    internal readonly SyntaxToken openParenToken;
    internal readonly ExpressionSyntax condition;
    internal readonly SyntaxToken closeParenToken;
    internal readonly SyntaxToken semicolonToken;

    internal DoStatementSyntax(SyntaxKind kind, SyntaxToken doKeyword, StatementSyntax statement, SyntaxToken whileKeyword, SyntaxToken openParenToken, ExpressionSyntax condition, SyntaxToken closeParenToken, SyntaxToken semicolonToken, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 7;
        this.AdjustFlagsAndWidth(doKeyword);
        this.doKeyword = doKeyword;
        this.AdjustFlagsAndWidth(statement);
        this.statement = statement;
        this.AdjustFlagsAndWidth(whileKeyword);
        this.whileKeyword = whileKeyword;
        this.AdjustFlagsAndWidth(openParenToken);
        this.openParenToken = openParenToken;
        this.AdjustFlagsAndWidth(condition);
        this.condition = condition;
        this.AdjustFlagsAndWidth(closeParenToken);
        this.closeParenToken = closeParenToken;
        this.AdjustFlagsAndWidth(semicolonToken);
        this.semicolonToken = semicolonToken;
    }


    internal DoStatementSyntax(SyntaxKind kind, SyntaxToken doKeyword, StatementSyntax statement, SyntaxToken whileKeyword, SyntaxToken openParenToken, ExpressionSyntax condition, SyntaxToken closeParenToken, SyntaxToken semicolonToken, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 7;
        this.AdjustFlagsAndWidth(doKeyword);
        this.doKeyword = doKeyword;
        this.AdjustFlagsAndWidth(statement);
        this.statement = statement;
        this.AdjustFlagsAndWidth(whileKeyword);
        this.whileKeyword = whileKeyword;
        this.AdjustFlagsAndWidth(openParenToken);
        this.openParenToken = openParenToken;
        this.AdjustFlagsAndWidth(condition);
        this.condition = condition;
        this.AdjustFlagsAndWidth(closeParenToken);
        this.closeParenToken = closeParenToken;
        this.AdjustFlagsAndWidth(semicolonToken);
        this.semicolonToken = semicolonToken;
    }


    internal DoStatementSyntax(SyntaxKind kind, SyntaxToken doKeyword, StatementSyntax statement, SyntaxToken whileKeyword, SyntaxToken openParenToken, ExpressionSyntax condition, SyntaxToken closeParenToken, SyntaxToken semicolonToken)
        : base(kind)
    {
        this.SlotCount = 7;
        this.AdjustFlagsAndWidth(doKeyword);
        this.doKeyword = doKeyword;
        this.AdjustFlagsAndWidth(statement);
        this.statement = statement;
        this.AdjustFlagsAndWidth(whileKeyword);
        this.whileKeyword = whileKeyword;
        this.AdjustFlagsAndWidth(openParenToken);
        this.openParenToken = openParenToken;
        this.AdjustFlagsAndWidth(condition);
        this.condition = condition;
        this.AdjustFlagsAndWidth(closeParenToken);
        this.closeParenToken = closeParenToken;
        this.AdjustFlagsAndWidth(semicolonToken);
        this.semicolonToken = semicolonToken;
    }

    public SyntaxToken DoKeyword => this.doKeyword;
    public StatementSyntax Statement => this.statement;
    public SyntaxToken WhileKeyword => this.whileKeyword;
    public SyntaxToken OpenParenToken => this.openParenToken;
    public ExpressionSyntax Condition => this.condition;
    public SyntaxToken CloseParenToken => this.closeParenToken;
    public SyntaxToken SemicolonToken => this.semicolonToken;

    internal override GreenNode? GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.doKeyword;
            case 1: return this.statement;
            case 2: return this.whileKeyword;
            case 3: return this.openParenToken;
            case 4: return this.condition;
            case 5: return this.closeParenToken;
            case 6: return this.semicolonToken;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new CSharp.Syntax.DoStatementSyntax(this, parent, position);

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor) => visitor.VisitDoStatement(this);

    public override void Accept(CSharpSyntaxVisitor visitor) => visitor.VisitDoStatement(this);

    public DoStatementSyntax Update(SyntaxToken doKeyword, StatementSyntax statement, SyntaxToken whileKeyword, SyntaxToken openParenToken, ExpressionSyntax condition, SyntaxToken closeParenToken, SyntaxToken semicolonToken)
    {
        if (doKeyword != this.DoKeyword || statement != this.Statement || whileKeyword != this.WhileKeyword || openParenToken != this.OpenParenToken || condition != this.Condition || closeParenToken != this.CloseParenToken || semicolonToken != this.SemicolonToken)
        {
            var newNode = SyntaxFactory.DoStatement(doKeyword, statement, whileKeyword, openParenToken, condition, closeParenToken, semicolonToken);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
        => new DoStatementSyntax(this.Kind, this.doKeyword, this.statement, this.whileKeyword, this.openParenToken, this.condition, this.closeParenToken, this.semicolonToken, diagnostics, GetAnnotations());

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
        => new DoStatementSyntax(this.Kind, this.doKeyword, this.statement, this.whileKeyword, this.openParenToken, this.condition, this.closeParenToken, this.semicolonToken, GetDiagnostics(), annotations);

    internal DoStatementSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 7;
      var doKeyword = (SyntaxToken)reader.ReadValue();
      if (doKeyword != null)
      {
         AdjustFlagsAndWidth(doKeyword);
         this.doKeyword = doKeyword;
      }
      var statement = (StatementSyntax)reader.ReadValue();
      if (statement != null)
      {
         AdjustFlagsAndWidth(statement);
         this.statement = statement;
      }
      var whileKeyword = (SyntaxToken)reader.ReadValue();
      if (whileKeyword != null)
      {
         AdjustFlagsAndWidth(whileKeyword);
         this.whileKeyword = whileKeyword;
      }
      var openParenToken = (SyntaxToken)reader.ReadValue();
      if (openParenToken != null)
      {
         AdjustFlagsAndWidth(openParenToken);
         this.openParenToken = openParenToken;
      }
      var condition = (ExpressionSyntax)reader.ReadValue();
      if (condition != null)
      {
         AdjustFlagsAndWidth(condition);
         this.condition = condition;
      }
      var closeParenToken = (SyntaxToken)reader.ReadValue();
      if (closeParenToken != null)
      {
         AdjustFlagsAndWidth(closeParenToken);
         this.closeParenToken = closeParenToken;
      }
      var semicolonToken = (SyntaxToken)reader.ReadValue();
      if (semicolonToken != null)
      {
         AdjustFlagsAndWidth(semicolonToken);
         this.semicolonToken = semicolonToken;
      }
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.doKeyword);
      writer.WriteValue(this.statement);
      writer.WriteValue(this.whileKeyword);
      writer.WriteValue(this.openParenToken);
      writer.WriteValue(this.condition);
      writer.WriteValue(this.closeParenToken);
      writer.WriteValue(this.semicolonToken);
    }

    static DoStatementSyntax()
    {
       ObjectBinder.RegisterTypeReader(typeof(DoStatementSyntax), r => new DoStatementSyntax(r));
    }
  }

  internal sealed partial class ForStatementSyntax : StatementSyntax
  {
    internal readonly SyntaxToken forKeyword;
    internal readonly SyntaxToken openParenToken;
    internal readonly VariableDeclarationSyntax? declaration;
    internal readonly GreenNode? initializers;
    internal readonly SyntaxToken firstSemicolonToken;
    internal readonly ExpressionSyntax? condition;
    internal readonly SyntaxToken secondSemicolonToken;
    internal readonly GreenNode? incrementors;
    internal readonly SyntaxToken closeParenToken;
    internal readonly StatementSyntax statement;

    internal ForStatementSyntax(SyntaxKind kind, SyntaxToken forKeyword, SyntaxToken openParenToken, VariableDeclarationSyntax? declaration, GreenNode? initializers, SyntaxToken firstSemicolonToken, ExpressionSyntax? condition, SyntaxToken secondSemicolonToken, GreenNode? incrementors, SyntaxToken closeParenToken, StatementSyntax statement, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 10;
        this.AdjustFlagsAndWidth(forKeyword);
        this.forKeyword = forKeyword;
        this.AdjustFlagsAndWidth(openParenToken);
        this.openParenToken = openParenToken;
        if (declaration != null)
        {
            this.AdjustFlagsAndWidth(declaration);
            this.declaration = declaration;
        }
        if (initializers != null)
        {
            this.AdjustFlagsAndWidth(initializers);
            this.initializers = initializers;
        }
        this.AdjustFlagsAndWidth(firstSemicolonToken);
        this.firstSemicolonToken = firstSemicolonToken;
        if (condition != null)
        {
            this.AdjustFlagsAndWidth(condition);
            this.condition = condition;
        }
        this.AdjustFlagsAndWidth(secondSemicolonToken);
        this.secondSemicolonToken = secondSemicolonToken;
        if (incrementors != null)
        {
            this.AdjustFlagsAndWidth(incrementors);
            this.incrementors = incrementors;
        }
        this.AdjustFlagsAndWidth(closeParenToken);
        this.closeParenToken = closeParenToken;
        this.AdjustFlagsAndWidth(statement);
        this.statement = statement;
    }


    internal ForStatementSyntax(SyntaxKind kind, SyntaxToken forKeyword, SyntaxToken openParenToken, VariableDeclarationSyntax? declaration, GreenNode? initializers, SyntaxToken firstSemicolonToken, ExpressionSyntax? condition, SyntaxToken secondSemicolonToken, GreenNode? incrementors, SyntaxToken closeParenToken, StatementSyntax statement, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 10;
        this.AdjustFlagsAndWidth(forKeyword);
        this.forKeyword = forKeyword;
        this.AdjustFlagsAndWidth(openParenToken);
        this.openParenToken = openParenToken;
        if (declaration != null)
        {
            this.AdjustFlagsAndWidth(declaration);
            this.declaration = declaration;
        }
        if (initializers != null)
        {
            this.AdjustFlagsAndWidth(initializers);
            this.initializers = initializers;
        }
        this.AdjustFlagsAndWidth(firstSemicolonToken);
        this.firstSemicolonToken = firstSemicolonToken;
        if (condition != null)
        {
            this.AdjustFlagsAndWidth(condition);
            this.condition = condition;
        }
        this.AdjustFlagsAndWidth(secondSemicolonToken);
        this.secondSemicolonToken = secondSemicolonToken;
        if (incrementors != null)
        {
            this.AdjustFlagsAndWidth(incrementors);
            this.incrementors = incrementors;
        }
        this.AdjustFlagsAndWidth(closeParenToken);
        this.closeParenToken = closeParenToken;
        this.AdjustFlagsAndWidth(statement);
        this.statement = statement;
    }


    internal ForStatementSyntax(SyntaxKind kind, SyntaxToken forKeyword, SyntaxToken openParenToken, VariableDeclarationSyntax? declaration, GreenNode? initializers, SyntaxToken firstSemicolonToken, ExpressionSyntax? condition, SyntaxToken secondSemicolonToken, GreenNode? incrementors, SyntaxToken closeParenToken, StatementSyntax statement)
        : base(kind)
    {
        this.SlotCount = 10;
        this.AdjustFlagsAndWidth(forKeyword);
        this.forKeyword = forKeyword;
        this.AdjustFlagsAndWidth(openParenToken);
        this.openParenToken = openParenToken;
        if (declaration != null)
        {
            this.AdjustFlagsAndWidth(declaration);
            this.declaration = declaration;
        }
        if (initializers != null)
        {
            this.AdjustFlagsAndWidth(initializers);
            this.initializers = initializers;
        }
        this.AdjustFlagsAndWidth(firstSemicolonToken);
        this.firstSemicolonToken = firstSemicolonToken;
        if (condition != null)
        {
            this.AdjustFlagsAndWidth(condition);
            this.condition = condition;
        }
        this.AdjustFlagsAndWidth(secondSemicolonToken);
        this.secondSemicolonToken = secondSemicolonToken;
        if (incrementors != null)
        {
            this.AdjustFlagsAndWidth(incrementors);
            this.incrementors = incrementors;
        }
        this.AdjustFlagsAndWidth(closeParenToken);
        this.closeParenToken = closeParenToken;
        this.AdjustFlagsAndWidth(statement);
        this.statement = statement;
    }

    public SyntaxToken ForKeyword => this.forKeyword;
    public SyntaxToken OpenParenToken => this.openParenToken;
    public VariableDeclarationSyntax? Declaration => this.declaration;
    public Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<ExpressionSyntax> Initializers => new Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<ExpressionSyntax>(new Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<CSharpSyntaxNode>(this.initializers));
    public SyntaxToken FirstSemicolonToken => this.firstSemicolonToken;
    public ExpressionSyntax? Condition => this.condition;
    public SyntaxToken SecondSemicolonToken => this.secondSemicolonToken;
    public Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<ExpressionSyntax> Incrementors => new Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<ExpressionSyntax>(new Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<CSharpSyntaxNode>(this.incrementors));
    public SyntaxToken CloseParenToken => this.closeParenToken;
    public StatementSyntax Statement => this.statement;

    internal override GreenNode? GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.forKeyword;
            case 1: return this.openParenToken;
            case 2: return this.declaration;
            case 3: return this.initializers;
            case 4: return this.firstSemicolonToken;
            case 5: return this.condition;
            case 6: return this.secondSemicolonToken;
            case 7: return this.incrementors;
            case 8: return this.closeParenToken;
            case 9: return this.statement;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new CSharp.Syntax.ForStatementSyntax(this, parent, position);

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor) => visitor.VisitForStatement(this);

    public override void Accept(CSharpSyntaxVisitor visitor) => visitor.VisitForStatement(this);

    public ForStatementSyntax Update(SyntaxToken forKeyword, SyntaxToken openParenToken, VariableDeclarationSyntax declaration, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<ExpressionSyntax> initializers, SyntaxToken firstSemicolonToken, ExpressionSyntax condition, SyntaxToken secondSemicolonToken, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<ExpressionSyntax> incrementors, SyntaxToken closeParenToken, StatementSyntax statement)
    {
        if (forKeyword != this.ForKeyword || openParenToken != this.OpenParenToken || declaration != this.Declaration || initializers != this.Initializers || firstSemicolonToken != this.FirstSemicolonToken || condition != this.Condition || secondSemicolonToken != this.SecondSemicolonToken || incrementors != this.Incrementors || closeParenToken != this.CloseParenToken || statement != this.Statement)
        {
            var newNode = SyntaxFactory.ForStatement(forKeyword, openParenToken, declaration, initializers, firstSemicolonToken, condition, secondSemicolonToken, incrementors, closeParenToken, statement);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
        => new ForStatementSyntax(this.Kind, this.forKeyword, this.openParenToken, this.declaration, this.initializers, this.firstSemicolonToken, this.condition, this.secondSemicolonToken, this.incrementors, this.closeParenToken, this.statement, diagnostics, GetAnnotations());

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
        => new ForStatementSyntax(this.Kind, this.forKeyword, this.openParenToken, this.declaration, this.initializers, this.firstSemicolonToken, this.condition, this.secondSemicolonToken, this.incrementors, this.closeParenToken, this.statement, GetDiagnostics(), annotations);

    internal ForStatementSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 10;
      var forKeyword = (SyntaxToken)reader.ReadValue();
      if (forKeyword != null)
      {
         AdjustFlagsAndWidth(forKeyword);
         this.forKeyword = forKeyword;
      }
      var openParenToken = (SyntaxToken)reader.ReadValue();
      if (openParenToken != null)
      {
         AdjustFlagsAndWidth(openParenToken);
         this.openParenToken = openParenToken;
      }
      var declaration = (VariableDeclarationSyntax?)reader.ReadValue();
      if (declaration != null)
      {
         AdjustFlagsAndWidth(declaration);
         this.declaration = declaration;
      }
      var initializers = (GreenNode?)reader.ReadValue();
      if (initializers != null)
      {
         AdjustFlagsAndWidth(initializers);
         this.initializers = initializers;
      }
      var firstSemicolonToken = (SyntaxToken)reader.ReadValue();
      if (firstSemicolonToken != null)
      {
         AdjustFlagsAndWidth(firstSemicolonToken);
         this.firstSemicolonToken = firstSemicolonToken;
      }
      var condition = (ExpressionSyntax?)reader.ReadValue();
      if (condition != null)
      {
         AdjustFlagsAndWidth(condition);
         this.condition = condition;
      }
      var secondSemicolonToken = (SyntaxToken)reader.ReadValue();
      if (secondSemicolonToken != null)
      {
         AdjustFlagsAndWidth(secondSemicolonToken);
         this.secondSemicolonToken = secondSemicolonToken;
      }
      var incrementors = (GreenNode?)reader.ReadValue();
      if (incrementors != null)
      {
         AdjustFlagsAndWidth(incrementors);
         this.incrementors = incrementors;
      }
      var closeParenToken = (SyntaxToken)reader.ReadValue();
      if (closeParenToken != null)
      {
         AdjustFlagsAndWidth(closeParenToken);
         this.closeParenToken = closeParenToken;
      }
      var statement = (StatementSyntax)reader.ReadValue();
      if (statement != null)
      {
         AdjustFlagsAndWidth(statement);
         this.statement = statement;
      }
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.forKeyword);
      writer.WriteValue(this.openParenToken);
      writer.WriteValue(this.declaration);
      writer.WriteValue(this.initializers);
      writer.WriteValue(this.firstSemicolonToken);
      writer.WriteValue(this.condition);
      writer.WriteValue(this.secondSemicolonToken);
      writer.WriteValue(this.incrementors);
      writer.WriteValue(this.closeParenToken);
      writer.WriteValue(this.statement);
    }

    static ForStatementSyntax()
    {
       ObjectBinder.RegisterTypeReader(typeof(ForStatementSyntax), r => new ForStatementSyntax(r));
    }
  }

  internal abstract partial class CommonForEachStatementSyntax : StatementSyntax
  {
    internal CommonForEachStatementSyntax(SyntaxKind kind, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
      : base(kind, diagnostics, annotations)
    {
    }
    internal CommonForEachStatementSyntax(SyntaxKind kind)
      : base(kind)
    {
    }

    protected CommonForEachStatementSyntax(ObjectReader reader)
       : base(reader)
    {
    }

    public abstract SyntaxToken? AwaitKeyword { get; }

    public abstract SyntaxToken ForEachKeyword { get; }

    public abstract SyntaxToken OpenParenToken { get; }

    public abstract SyntaxToken InKeyword { get; }

    public abstract ExpressionSyntax Expression { get; }

    public abstract SyntaxToken CloseParenToken { get; }

    public abstract StatementSyntax Statement { get; }
  }

  internal sealed partial class ForEachStatementSyntax : CommonForEachStatementSyntax
  {
    internal readonly SyntaxToken? awaitKeyword;
    internal readonly SyntaxToken forEachKeyword;
    internal readonly SyntaxToken openParenToken;
    internal readonly TypeSyntax type;
    internal readonly SyntaxToken identifier;
    internal readonly SyntaxToken inKeyword;
    internal readonly ExpressionSyntax expression;
    internal readonly SyntaxToken closeParenToken;
    internal readonly StatementSyntax statement;

    internal ForEachStatementSyntax(SyntaxKind kind, SyntaxToken? awaitKeyword, SyntaxToken forEachKeyword, SyntaxToken openParenToken, TypeSyntax type, SyntaxToken identifier, SyntaxToken inKeyword, ExpressionSyntax expression, SyntaxToken closeParenToken, StatementSyntax statement, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 9;
        if (awaitKeyword != null)
        {
            this.AdjustFlagsAndWidth(awaitKeyword);
            this.awaitKeyword = awaitKeyword;
        }
        this.AdjustFlagsAndWidth(forEachKeyword);
        this.forEachKeyword = forEachKeyword;
        this.AdjustFlagsAndWidth(openParenToken);
        this.openParenToken = openParenToken;
        this.AdjustFlagsAndWidth(type);
        this.type = type;
        this.AdjustFlagsAndWidth(identifier);
        this.identifier = identifier;
        this.AdjustFlagsAndWidth(inKeyword);
        this.inKeyword = inKeyword;
        this.AdjustFlagsAndWidth(expression);
        this.expression = expression;
        this.AdjustFlagsAndWidth(closeParenToken);
        this.closeParenToken = closeParenToken;
        this.AdjustFlagsAndWidth(statement);
        this.statement = statement;
    }


    internal ForEachStatementSyntax(SyntaxKind kind, SyntaxToken? awaitKeyword, SyntaxToken forEachKeyword, SyntaxToken openParenToken, TypeSyntax type, SyntaxToken identifier, SyntaxToken inKeyword, ExpressionSyntax expression, SyntaxToken closeParenToken, StatementSyntax statement, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 9;
        if (awaitKeyword != null)
        {
            this.AdjustFlagsAndWidth(awaitKeyword);
            this.awaitKeyword = awaitKeyword;
        }
        this.AdjustFlagsAndWidth(forEachKeyword);
        this.forEachKeyword = forEachKeyword;
        this.AdjustFlagsAndWidth(openParenToken);
        this.openParenToken = openParenToken;
        this.AdjustFlagsAndWidth(type);
        this.type = type;
        this.AdjustFlagsAndWidth(identifier);
        this.identifier = identifier;
        this.AdjustFlagsAndWidth(inKeyword);
        this.inKeyword = inKeyword;
        this.AdjustFlagsAndWidth(expression);
        this.expression = expression;
        this.AdjustFlagsAndWidth(closeParenToken);
        this.closeParenToken = closeParenToken;
        this.AdjustFlagsAndWidth(statement);
        this.statement = statement;
    }


    internal ForEachStatementSyntax(SyntaxKind kind, SyntaxToken? awaitKeyword, SyntaxToken forEachKeyword, SyntaxToken openParenToken, TypeSyntax type, SyntaxToken identifier, SyntaxToken inKeyword, ExpressionSyntax expression, SyntaxToken closeParenToken, StatementSyntax statement)
        : base(kind)
    {
        this.SlotCount = 9;
        if (awaitKeyword != null)
        {
            this.AdjustFlagsAndWidth(awaitKeyword);
            this.awaitKeyword = awaitKeyword;
        }
        this.AdjustFlagsAndWidth(forEachKeyword);
        this.forEachKeyword = forEachKeyword;
        this.AdjustFlagsAndWidth(openParenToken);
        this.openParenToken = openParenToken;
        this.AdjustFlagsAndWidth(type);
        this.type = type;
        this.AdjustFlagsAndWidth(identifier);
        this.identifier = identifier;
        this.AdjustFlagsAndWidth(inKeyword);
        this.inKeyword = inKeyword;
        this.AdjustFlagsAndWidth(expression);
        this.expression = expression;
        this.AdjustFlagsAndWidth(closeParenToken);
        this.closeParenToken = closeParenToken;
        this.AdjustFlagsAndWidth(statement);
        this.statement = statement;
    }

    public override SyntaxToken? AwaitKeyword => this.awaitKeyword;
    public override SyntaxToken ForEachKeyword => this.forEachKeyword;
    public override SyntaxToken OpenParenToken => this.openParenToken;
    public TypeSyntax Type => this.type;
    /// <summary>Gets the identifier.</summary>
    public SyntaxToken Identifier => this.identifier;
    public override SyntaxToken InKeyword => this.inKeyword;
    public override ExpressionSyntax Expression => this.expression;
    public override SyntaxToken CloseParenToken => this.closeParenToken;
    public override StatementSyntax Statement => this.statement;

    internal override GreenNode? GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.awaitKeyword;
            case 1: return this.forEachKeyword;
            case 2: return this.openParenToken;
            case 3: return this.type;
            case 4: return this.identifier;
            case 5: return this.inKeyword;
            case 6: return this.expression;
            case 7: return this.closeParenToken;
            case 8: return this.statement;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new CSharp.Syntax.ForEachStatementSyntax(this, parent, position);

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor) => visitor.VisitForEachStatement(this);

    public override void Accept(CSharpSyntaxVisitor visitor) => visitor.VisitForEachStatement(this);

    public ForEachStatementSyntax Update(SyntaxToken awaitKeyword, SyntaxToken forEachKeyword, SyntaxToken openParenToken, TypeSyntax type, SyntaxToken identifier, SyntaxToken inKeyword, ExpressionSyntax expression, SyntaxToken closeParenToken, StatementSyntax statement)
    {
        if (awaitKeyword != this.AwaitKeyword || forEachKeyword != this.ForEachKeyword || openParenToken != this.OpenParenToken || type != this.Type || identifier != this.Identifier || inKeyword != this.InKeyword || expression != this.Expression || closeParenToken != this.CloseParenToken || statement != this.Statement)
        {
            var newNode = SyntaxFactory.ForEachStatement(awaitKeyword, forEachKeyword, openParenToken, type, identifier, inKeyword, expression, closeParenToken, statement);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
        => new ForEachStatementSyntax(this.Kind, this.awaitKeyword, this.forEachKeyword, this.openParenToken, this.type, this.identifier, this.inKeyword, this.expression, this.closeParenToken, this.statement, diagnostics, GetAnnotations());

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
        => new ForEachStatementSyntax(this.Kind, this.awaitKeyword, this.forEachKeyword, this.openParenToken, this.type, this.identifier, this.inKeyword, this.expression, this.closeParenToken, this.statement, GetDiagnostics(), annotations);

    internal ForEachStatementSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 9;
      var awaitKeyword = (SyntaxToken?)reader.ReadValue();
      if (awaitKeyword != null)
      {
         AdjustFlagsAndWidth(awaitKeyword);
         this.awaitKeyword = awaitKeyword;
      }
      var forEachKeyword = (SyntaxToken)reader.ReadValue();
      if (forEachKeyword != null)
      {
         AdjustFlagsAndWidth(forEachKeyword);
         this.forEachKeyword = forEachKeyword;
      }
      var openParenToken = (SyntaxToken)reader.ReadValue();
      if (openParenToken != null)
      {
         AdjustFlagsAndWidth(openParenToken);
         this.openParenToken = openParenToken;
      }
      var type = (TypeSyntax)reader.ReadValue();
      if (type != null)
      {
         AdjustFlagsAndWidth(type);
         this.type = type;
      }
      var identifier = (SyntaxToken)reader.ReadValue();
      if (identifier != null)
      {
         AdjustFlagsAndWidth(identifier);
         this.identifier = identifier;
      }
      var inKeyword = (SyntaxToken)reader.ReadValue();
      if (inKeyword != null)
      {
         AdjustFlagsAndWidth(inKeyword);
         this.inKeyword = inKeyword;
      }
      var expression = (ExpressionSyntax)reader.ReadValue();
      if (expression != null)
      {
         AdjustFlagsAndWidth(expression);
         this.expression = expression;
      }
      var closeParenToken = (SyntaxToken)reader.ReadValue();
      if (closeParenToken != null)
      {
         AdjustFlagsAndWidth(closeParenToken);
         this.closeParenToken = closeParenToken;
      }
      var statement = (StatementSyntax)reader.ReadValue();
      if (statement != null)
      {
         AdjustFlagsAndWidth(statement);
         this.statement = statement;
      }
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.awaitKeyword);
      writer.WriteValue(this.forEachKeyword);
      writer.WriteValue(this.openParenToken);
      writer.WriteValue(this.type);
      writer.WriteValue(this.identifier);
      writer.WriteValue(this.inKeyword);
      writer.WriteValue(this.expression);
      writer.WriteValue(this.closeParenToken);
      writer.WriteValue(this.statement);
    }

    static ForEachStatementSyntax()
    {
       ObjectBinder.RegisterTypeReader(typeof(ForEachStatementSyntax), r => new ForEachStatementSyntax(r));
    }
  }

  internal sealed partial class ForEachVariableStatementSyntax : CommonForEachStatementSyntax
  {
    internal readonly SyntaxToken? awaitKeyword;
    internal readonly SyntaxToken forEachKeyword;
    internal readonly SyntaxToken openParenToken;
    internal readonly ExpressionSyntax variable;
    internal readonly SyntaxToken inKeyword;
    internal readonly ExpressionSyntax expression;
    internal readonly SyntaxToken closeParenToken;
    internal readonly StatementSyntax statement;

    internal ForEachVariableStatementSyntax(SyntaxKind kind, SyntaxToken? awaitKeyword, SyntaxToken forEachKeyword, SyntaxToken openParenToken, ExpressionSyntax variable, SyntaxToken inKeyword, ExpressionSyntax expression, SyntaxToken closeParenToken, StatementSyntax statement, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 8;
        if (awaitKeyword != null)
        {
            this.AdjustFlagsAndWidth(awaitKeyword);
            this.awaitKeyword = awaitKeyword;
        }
        this.AdjustFlagsAndWidth(forEachKeyword);
        this.forEachKeyword = forEachKeyword;
        this.AdjustFlagsAndWidth(openParenToken);
        this.openParenToken = openParenToken;
        this.AdjustFlagsAndWidth(variable);
        this.variable = variable;
        this.AdjustFlagsAndWidth(inKeyword);
        this.inKeyword = inKeyword;
        this.AdjustFlagsAndWidth(expression);
        this.expression = expression;
        this.AdjustFlagsAndWidth(closeParenToken);
        this.closeParenToken = closeParenToken;
        this.AdjustFlagsAndWidth(statement);
        this.statement = statement;
    }


    internal ForEachVariableStatementSyntax(SyntaxKind kind, SyntaxToken? awaitKeyword, SyntaxToken forEachKeyword, SyntaxToken openParenToken, ExpressionSyntax variable, SyntaxToken inKeyword, ExpressionSyntax expression, SyntaxToken closeParenToken, StatementSyntax statement, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 8;
        if (awaitKeyword != null)
        {
            this.AdjustFlagsAndWidth(awaitKeyword);
            this.awaitKeyword = awaitKeyword;
        }
        this.AdjustFlagsAndWidth(forEachKeyword);
        this.forEachKeyword = forEachKeyword;
        this.AdjustFlagsAndWidth(openParenToken);
        this.openParenToken = openParenToken;
        this.AdjustFlagsAndWidth(variable);
        this.variable = variable;
        this.AdjustFlagsAndWidth(inKeyword);
        this.inKeyword = inKeyword;
        this.AdjustFlagsAndWidth(expression);
        this.expression = expression;
        this.AdjustFlagsAndWidth(closeParenToken);
        this.closeParenToken = closeParenToken;
        this.AdjustFlagsAndWidth(statement);
        this.statement = statement;
    }


    internal ForEachVariableStatementSyntax(SyntaxKind kind, SyntaxToken? awaitKeyword, SyntaxToken forEachKeyword, SyntaxToken openParenToken, ExpressionSyntax variable, SyntaxToken inKeyword, ExpressionSyntax expression, SyntaxToken closeParenToken, StatementSyntax statement)
        : base(kind)
    {
        this.SlotCount = 8;
        if (awaitKeyword != null)
        {
            this.AdjustFlagsAndWidth(awaitKeyword);
            this.awaitKeyword = awaitKeyword;
        }
        this.AdjustFlagsAndWidth(forEachKeyword);
        this.forEachKeyword = forEachKeyword;
        this.AdjustFlagsAndWidth(openParenToken);
        this.openParenToken = openParenToken;
        this.AdjustFlagsAndWidth(variable);
        this.variable = variable;
        this.AdjustFlagsAndWidth(inKeyword);
        this.inKeyword = inKeyword;
        this.AdjustFlagsAndWidth(expression);
        this.expression = expression;
        this.AdjustFlagsAndWidth(closeParenToken);
        this.closeParenToken = closeParenToken;
        this.AdjustFlagsAndWidth(statement);
        this.statement = statement;
    }

    public override SyntaxToken? AwaitKeyword => this.awaitKeyword;
    public override SyntaxToken ForEachKeyword => this.forEachKeyword;
    public override SyntaxToken OpenParenToken => this.openParenToken;
    /// <summary>
    /// The variable(s) of the loop. In correct code this is a tuple
    /// literal, declaration expression with a tuple designator, or
    /// a discard syntax in the form of a simple identifier. In broken
    /// code it could be something else.
    /// </summary>
    public ExpressionSyntax Variable => this.variable;
    public override SyntaxToken InKeyword => this.inKeyword;
    public override ExpressionSyntax Expression => this.expression;
    public override SyntaxToken CloseParenToken => this.closeParenToken;
    public override StatementSyntax Statement => this.statement;

    internal override GreenNode? GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.awaitKeyword;
            case 1: return this.forEachKeyword;
            case 2: return this.openParenToken;
            case 3: return this.variable;
            case 4: return this.inKeyword;
            case 5: return this.expression;
            case 6: return this.closeParenToken;
            case 7: return this.statement;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new CSharp.Syntax.ForEachVariableStatementSyntax(this, parent, position);

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor) => visitor.VisitForEachVariableStatement(this);

    public override void Accept(CSharpSyntaxVisitor visitor) => visitor.VisitForEachVariableStatement(this);

    public ForEachVariableStatementSyntax Update(SyntaxToken awaitKeyword, SyntaxToken forEachKeyword, SyntaxToken openParenToken, ExpressionSyntax variable, SyntaxToken inKeyword, ExpressionSyntax expression, SyntaxToken closeParenToken, StatementSyntax statement)
    {
        if (awaitKeyword != this.AwaitKeyword || forEachKeyword != this.ForEachKeyword || openParenToken != this.OpenParenToken || variable != this.Variable || inKeyword != this.InKeyword || expression != this.Expression || closeParenToken != this.CloseParenToken || statement != this.Statement)
        {
            var newNode = SyntaxFactory.ForEachVariableStatement(awaitKeyword, forEachKeyword, openParenToken, variable, inKeyword, expression, closeParenToken, statement);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
        => new ForEachVariableStatementSyntax(this.Kind, this.awaitKeyword, this.forEachKeyword, this.openParenToken, this.variable, this.inKeyword, this.expression, this.closeParenToken, this.statement, diagnostics, GetAnnotations());

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
        => new ForEachVariableStatementSyntax(this.Kind, this.awaitKeyword, this.forEachKeyword, this.openParenToken, this.variable, this.inKeyword, this.expression, this.closeParenToken, this.statement, GetDiagnostics(), annotations);

    internal ForEachVariableStatementSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 8;
      var awaitKeyword = (SyntaxToken?)reader.ReadValue();
      if (awaitKeyword != null)
      {
         AdjustFlagsAndWidth(awaitKeyword);
         this.awaitKeyword = awaitKeyword;
      }
      var forEachKeyword = (SyntaxToken)reader.ReadValue();
      if (forEachKeyword != null)
      {
         AdjustFlagsAndWidth(forEachKeyword);
         this.forEachKeyword = forEachKeyword;
      }
      var openParenToken = (SyntaxToken)reader.ReadValue();
      if (openParenToken != null)
      {
         AdjustFlagsAndWidth(openParenToken);
         this.openParenToken = openParenToken;
      }
      var variable = (ExpressionSyntax)reader.ReadValue();
      if (variable != null)
      {
         AdjustFlagsAndWidth(variable);
         this.variable = variable;
      }
      var inKeyword = (SyntaxToken)reader.ReadValue();
      if (inKeyword != null)
      {
         AdjustFlagsAndWidth(inKeyword);
         this.inKeyword = inKeyword;
      }
      var expression = (ExpressionSyntax)reader.ReadValue();
      if (expression != null)
      {
         AdjustFlagsAndWidth(expression);
         this.expression = expression;
      }
      var closeParenToken = (SyntaxToken)reader.ReadValue();
      if (closeParenToken != null)
      {
         AdjustFlagsAndWidth(closeParenToken);
         this.closeParenToken = closeParenToken;
      }
      var statement = (StatementSyntax)reader.ReadValue();
      if (statement != null)
      {
         AdjustFlagsAndWidth(statement);
         this.statement = statement;
      }
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.awaitKeyword);
      writer.WriteValue(this.forEachKeyword);
      writer.WriteValue(this.openParenToken);
      writer.WriteValue(this.variable);
      writer.WriteValue(this.inKeyword);
      writer.WriteValue(this.expression);
      writer.WriteValue(this.closeParenToken);
      writer.WriteValue(this.statement);
    }

    static ForEachVariableStatementSyntax()
    {
       ObjectBinder.RegisterTypeReader(typeof(ForEachVariableStatementSyntax), r => new ForEachVariableStatementSyntax(r));
    }
  }

  internal sealed partial class UsingStatementSyntax : StatementSyntax
  {
    internal readonly SyntaxToken? awaitKeyword;
    internal readonly SyntaxToken usingKeyword;
    internal readonly SyntaxToken openParenToken;
    internal readonly VariableDeclarationSyntax? declaration;
    internal readonly ExpressionSyntax? expression;
    internal readonly SyntaxToken closeParenToken;
    internal readonly StatementSyntax statement;

    internal UsingStatementSyntax(SyntaxKind kind, SyntaxToken? awaitKeyword, SyntaxToken usingKeyword, SyntaxToken openParenToken, VariableDeclarationSyntax? declaration, ExpressionSyntax? expression, SyntaxToken closeParenToken, StatementSyntax statement, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 7;
        if (awaitKeyword != null)
        {
            this.AdjustFlagsAndWidth(awaitKeyword);
            this.awaitKeyword = awaitKeyword;
        }
        this.AdjustFlagsAndWidth(usingKeyword);
        this.usingKeyword = usingKeyword;
        this.AdjustFlagsAndWidth(openParenToken);
        this.openParenToken = openParenToken;
        if (declaration != null)
        {
            this.AdjustFlagsAndWidth(declaration);
            this.declaration = declaration;
        }
        if (expression != null)
        {
            this.AdjustFlagsAndWidth(expression);
            this.expression = expression;
        }
        this.AdjustFlagsAndWidth(closeParenToken);
        this.closeParenToken = closeParenToken;
        this.AdjustFlagsAndWidth(statement);
        this.statement = statement;
    }


    internal UsingStatementSyntax(SyntaxKind kind, SyntaxToken? awaitKeyword, SyntaxToken usingKeyword, SyntaxToken openParenToken, VariableDeclarationSyntax? declaration, ExpressionSyntax? expression, SyntaxToken closeParenToken, StatementSyntax statement, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 7;
        if (awaitKeyword != null)
        {
            this.AdjustFlagsAndWidth(awaitKeyword);
            this.awaitKeyword = awaitKeyword;
        }
        this.AdjustFlagsAndWidth(usingKeyword);
        this.usingKeyword = usingKeyword;
        this.AdjustFlagsAndWidth(openParenToken);
        this.openParenToken = openParenToken;
        if (declaration != null)
        {
            this.AdjustFlagsAndWidth(declaration);
            this.declaration = declaration;
        }
        if (expression != null)
        {
            this.AdjustFlagsAndWidth(expression);
            this.expression = expression;
        }
        this.AdjustFlagsAndWidth(closeParenToken);
        this.closeParenToken = closeParenToken;
        this.AdjustFlagsAndWidth(statement);
        this.statement = statement;
    }


    internal UsingStatementSyntax(SyntaxKind kind, SyntaxToken? awaitKeyword, SyntaxToken usingKeyword, SyntaxToken openParenToken, VariableDeclarationSyntax? declaration, ExpressionSyntax? expression, SyntaxToken closeParenToken, StatementSyntax statement)
        : base(kind)
    {
        this.SlotCount = 7;
        if (awaitKeyword != null)
        {
            this.AdjustFlagsAndWidth(awaitKeyword);
            this.awaitKeyword = awaitKeyword;
        }
        this.AdjustFlagsAndWidth(usingKeyword);
        this.usingKeyword = usingKeyword;
        this.AdjustFlagsAndWidth(openParenToken);
        this.openParenToken = openParenToken;
        if (declaration != null)
        {
            this.AdjustFlagsAndWidth(declaration);
            this.declaration = declaration;
        }
        if (expression != null)
        {
            this.AdjustFlagsAndWidth(expression);
            this.expression = expression;
        }
        this.AdjustFlagsAndWidth(closeParenToken);
        this.closeParenToken = closeParenToken;
        this.AdjustFlagsAndWidth(statement);
        this.statement = statement;
    }

    public SyntaxToken? AwaitKeyword => this.awaitKeyword;
    public SyntaxToken UsingKeyword => this.usingKeyword;
    public SyntaxToken OpenParenToken => this.openParenToken;
    public VariableDeclarationSyntax? Declaration => this.declaration;
    public ExpressionSyntax? Expression => this.expression;
    public SyntaxToken CloseParenToken => this.closeParenToken;
    public StatementSyntax Statement => this.statement;

    internal override GreenNode? GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.awaitKeyword;
            case 1: return this.usingKeyword;
            case 2: return this.openParenToken;
            case 3: return this.declaration;
            case 4: return this.expression;
            case 5: return this.closeParenToken;
            case 6: return this.statement;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new CSharp.Syntax.UsingStatementSyntax(this, parent, position);

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor) => visitor.VisitUsingStatement(this);

    public override void Accept(CSharpSyntaxVisitor visitor) => visitor.VisitUsingStatement(this);

    public UsingStatementSyntax Update(SyntaxToken awaitKeyword, SyntaxToken usingKeyword, SyntaxToken openParenToken, VariableDeclarationSyntax declaration, ExpressionSyntax expression, SyntaxToken closeParenToken, StatementSyntax statement)
    {
        if (awaitKeyword != this.AwaitKeyword || usingKeyword != this.UsingKeyword || openParenToken != this.OpenParenToken || declaration != this.Declaration || expression != this.Expression || closeParenToken != this.CloseParenToken || statement != this.Statement)
        {
            var newNode = SyntaxFactory.UsingStatement(awaitKeyword, usingKeyword, openParenToken, declaration, expression, closeParenToken, statement);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
        => new UsingStatementSyntax(this.Kind, this.awaitKeyword, this.usingKeyword, this.openParenToken, this.declaration, this.expression, this.closeParenToken, this.statement, diagnostics, GetAnnotations());

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
        => new UsingStatementSyntax(this.Kind, this.awaitKeyword, this.usingKeyword, this.openParenToken, this.declaration, this.expression, this.closeParenToken, this.statement, GetDiagnostics(), annotations);

    internal UsingStatementSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 7;
      var awaitKeyword = (SyntaxToken?)reader.ReadValue();
      if (awaitKeyword != null)
      {
         AdjustFlagsAndWidth(awaitKeyword);
         this.awaitKeyword = awaitKeyword;
      }
      var usingKeyword = (SyntaxToken)reader.ReadValue();
      if (usingKeyword != null)
      {
         AdjustFlagsAndWidth(usingKeyword);
         this.usingKeyword = usingKeyword;
      }
      var openParenToken = (SyntaxToken)reader.ReadValue();
      if (openParenToken != null)
      {
         AdjustFlagsAndWidth(openParenToken);
         this.openParenToken = openParenToken;
      }
      var declaration = (VariableDeclarationSyntax?)reader.ReadValue();
      if (declaration != null)
      {
         AdjustFlagsAndWidth(declaration);
         this.declaration = declaration;
      }
      var expression = (ExpressionSyntax?)reader.ReadValue();
      if (expression != null)
      {
         AdjustFlagsAndWidth(expression);
         this.expression = expression;
      }
      var closeParenToken = (SyntaxToken)reader.ReadValue();
      if (closeParenToken != null)
      {
         AdjustFlagsAndWidth(closeParenToken);
         this.closeParenToken = closeParenToken;
      }
      var statement = (StatementSyntax)reader.ReadValue();
      if (statement != null)
      {
         AdjustFlagsAndWidth(statement);
         this.statement = statement;
      }
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.awaitKeyword);
      writer.WriteValue(this.usingKeyword);
      writer.WriteValue(this.openParenToken);
      writer.WriteValue(this.declaration);
      writer.WriteValue(this.expression);
      writer.WriteValue(this.closeParenToken);
      writer.WriteValue(this.statement);
    }

    static UsingStatementSyntax()
    {
       ObjectBinder.RegisterTypeReader(typeof(UsingStatementSyntax), r => new UsingStatementSyntax(r));
    }
  }

  internal sealed partial class FixedStatementSyntax : StatementSyntax
  {
    internal readonly SyntaxToken fixedKeyword;
    internal readonly SyntaxToken openParenToken;
    internal readonly VariableDeclarationSyntax declaration;
    internal readonly SyntaxToken closeParenToken;
    internal readonly StatementSyntax statement;

    internal FixedStatementSyntax(SyntaxKind kind, SyntaxToken fixedKeyword, SyntaxToken openParenToken, VariableDeclarationSyntax declaration, SyntaxToken closeParenToken, StatementSyntax statement, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 5;
        this.AdjustFlagsAndWidth(fixedKeyword);
        this.fixedKeyword = fixedKeyword;
        this.AdjustFlagsAndWidth(openParenToken);
        this.openParenToken = openParenToken;
        this.AdjustFlagsAndWidth(declaration);
        this.declaration = declaration;
        this.AdjustFlagsAndWidth(closeParenToken);
        this.closeParenToken = closeParenToken;
        this.AdjustFlagsAndWidth(statement);
        this.statement = statement;
    }


    internal FixedStatementSyntax(SyntaxKind kind, SyntaxToken fixedKeyword, SyntaxToken openParenToken, VariableDeclarationSyntax declaration, SyntaxToken closeParenToken, StatementSyntax statement, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 5;
        this.AdjustFlagsAndWidth(fixedKeyword);
        this.fixedKeyword = fixedKeyword;
        this.AdjustFlagsAndWidth(openParenToken);
        this.openParenToken = openParenToken;
        this.AdjustFlagsAndWidth(declaration);
        this.declaration = declaration;
        this.AdjustFlagsAndWidth(closeParenToken);
        this.closeParenToken = closeParenToken;
        this.AdjustFlagsAndWidth(statement);
        this.statement = statement;
    }


    internal FixedStatementSyntax(SyntaxKind kind, SyntaxToken fixedKeyword, SyntaxToken openParenToken, VariableDeclarationSyntax declaration, SyntaxToken closeParenToken, StatementSyntax statement)
        : base(kind)
    {
        this.SlotCount = 5;
        this.AdjustFlagsAndWidth(fixedKeyword);
        this.fixedKeyword = fixedKeyword;
        this.AdjustFlagsAndWidth(openParenToken);
        this.openParenToken = openParenToken;
        this.AdjustFlagsAndWidth(declaration);
        this.declaration = declaration;
        this.AdjustFlagsAndWidth(closeParenToken);
        this.closeParenToken = closeParenToken;
        this.AdjustFlagsAndWidth(statement);
        this.statement = statement;
    }

    public SyntaxToken FixedKeyword => this.fixedKeyword;
    public SyntaxToken OpenParenToken => this.openParenToken;
    public VariableDeclarationSyntax Declaration => this.declaration;
    public SyntaxToken CloseParenToken => this.closeParenToken;
    public StatementSyntax Statement => this.statement;

    internal override GreenNode? GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.fixedKeyword;
            case 1: return this.openParenToken;
            case 2: return this.declaration;
            case 3: return this.closeParenToken;
            case 4: return this.statement;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new CSharp.Syntax.FixedStatementSyntax(this, parent, position);

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor) => visitor.VisitFixedStatement(this);

    public override void Accept(CSharpSyntaxVisitor visitor) => visitor.VisitFixedStatement(this);

    public FixedStatementSyntax Update(SyntaxToken fixedKeyword, SyntaxToken openParenToken, VariableDeclarationSyntax declaration, SyntaxToken closeParenToken, StatementSyntax statement)
    {
        if (fixedKeyword != this.FixedKeyword || openParenToken != this.OpenParenToken || declaration != this.Declaration || closeParenToken != this.CloseParenToken || statement != this.Statement)
        {
            var newNode = SyntaxFactory.FixedStatement(fixedKeyword, openParenToken, declaration, closeParenToken, statement);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
        => new FixedStatementSyntax(this.Kind, this.fixedKeyword, this.openParenToken, this.declaration, this.closeParenToken, this.statement, diagnostics, GetAnnotations());

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
        => new FixedStatementSyntax(this.Kind, this.fixedKeyword, this.openParenToken, this.declaration, this.closeParenToken, this.statement, GetDiagnostics(), annotations);

    internal FixedStatementSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 5;
      var fixedKeyword = (SyntaxToken)reader.ReadValue();
      if (fixedKeyword != null)
      {
         AdjustFlagsAndWidth(fixedKeyword);
         this.fixedKeyword = fixedKeyword;
      }
      var openParenToken = (SyntaxToken)reader.ReadValue();
      if (openParenToken != null)
      {
         AdjustFlagsAndWidth(openParenToken);
         this.openParenToken = openParenToken;
      }
      var declaration = (VariableDeclarationSyntax)reader.ReadValue();
      if (declaration != null)
      {
         AdjustFlagsAndWidth(declaration);
         this.declaration = declaration;
      }
      var closeParenToken = (SyntaxToken)reader.ReadValue();
      if (closeParenToken != null)
      {
         AdjustFlagsAndWidth(closeParenToken);
         this.closeParenToken = closeParenToken;
      }
      var statement = (StatementSyntax)reader.ReadValue();
      if (statement != null)
      {
         AdjustFlagsAndWidth(statement);
         this.statement = statement;
      }
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.fixedKeyword);
      writer.WriteValue(this.openParenToken);
      writer.WriteValue(this.declaration);
      writer.WriteValue(this.closeParenToken);
      writer.WriteValue(this.statement);
    }

    static FixedStatementSyntax()
    {
       ObjectBinder.RegisterTypeReader(typeof(FixedStatementSyntax), r => new FixedStatementSyntax(r));
    }
  }

  internal sealed partial class CheckedStatementSyntax : StatementSyntax
  {
    internal readonly SyntaxToken keyword;
    internal readonly BlockSyntax block;

    internal CheckedStatementSyntax(SyntaxKind kind, SyntaxToken keyword, BlockSyntax block, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 2;
        this.AdjustFlagsAndWidth(keyword);
        this.keyword = keyword;
        this.AdjustFlagsAndWidth(block);
        this.block = block;
    }


    internal CheckedStatementSyntax(SyntaxKind kind, SyntaxToken keyword, BlockSyntax block, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 2;
        this.AdjustFlagsAndWidth(keyword);
        this.keyword = keyword;
        this.AdjustFlagsAndWidth(block);
        this.block = block;
    }


    internal CheckedStatementSyntax(SyntaxKind kind, SyntaxToken keyword, BlockSyntax block)
        : base(kind)
    {
        this.SlotCount = 2;
        this.AdjustFlagsAndWidth(keyword);
        this.keyword = keyword;
        this.AdjustFlagsAndWidth(block);
        this.block = block;
    }

    public SyntaxToken Keyword => this.keyword;
    public BlockSyntax Block => this.block;

    internal override GreenNode? GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.keyword;
            case 1: return this.block;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new CSharp.Syntax.CheckedStatementSyntax(this, parent, position);

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor) => visitor.VisitCheckedStatement(this);

    public override void Accept(CSharpSyntaxVisitor visitor) => visitor.VisitCheckedStatement(this);

    public CheckedStatementSyntax Update(SyntaxToken keyword, BlockSyntax block)
    {
        if (keyword != this.Keyword || block != this.Block)
        {
            var newNode = SyntaxFactory.CheckedStatement(this.Kind, keyword, block);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
        => new CheckedStatementSyntax(this.Kind, this.keyword, this.block, diagnostics, GetAnnotations());

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
        => new CheckedStatementSyntax(this.Kind, this.keyword, this.block, GetDiagnostics(), annotations);

    internal CheckedStatementSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 2;
      var keyword = (SyntaxToken)reader.ReadValue();
      if (keyword != null)
      {
         AdjustFlagsAndWidth(keyword);
         this.keyword = keyword;
      }
      var block = (BlockSyntax)reader.ReadValue();
      if (block != null)
      {
         AdjustFlagsAndWidth(block);
         this.block = block;
      }
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.keyword);
      writer.WriteValue(this.block);
    }

    static CheckedStatementSyntax()
    {
       ObjectBinder.RegisterTypeReader(typeof(CheckedStatementSyntax), r => new CheckedStatementSyntax(r));
    }
  }

  internal sealed partial class UnsafeStatementSyntax : StatementSyntax
  {
    internal readonly SyntaxToken unsafeKeyword;
    internal readonly BlockSyntax block;

    internal UnsafeStatementSyntax(SyntaxKind kind, SyntaxToken unsafeKeyword, BlockSyntax block, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 2;
        this.AdjustFlagsAndWidth(unsafeKeyword);
        this.unsafeKeyword = unsafeKeyword;
        this.AdjustFlagsAndWidth(block);
        this.block = block;
    }


    internal UnsafeStatementSyntax(SyntaxKind kind, SyntaxToken unsafeKeyword, BlockSyntax block, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 2;
        this.AdjustFlagsAndWidth(unsafeKeyword);
        this.unsafeKeyword = unsafeKeyword;
        this.AdjustFlagsAndWidth(block);
        this.block = block;
    }


    internal UnsafeStatementSyntax(SyntaxKind kind, SyntaxToken unsafeKeyword, BlockSyntax block)
        : base(kind)
    {
        this.SlotCount = 2;
        this.AdjustFlagsAndWidth(unsafeKeyword);
        this.unsafeKeyword = unsafeKeyword;
        this.AdjustFlagsAndWidth(block);
        this.block = block;
    }

    public SyntaxToken UnsafeKeyword => this.unsafeKeyword;
    public BlockSyntax Block => this.block;

    internal override GreenNode? GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.unsafeKeyword;
            case 1: return this.block;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new CSharp.Syntax.UnsafeStatementSyntax(this, parent, position);

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor) => visitor.VisitUnsafeStatement(this);

    public override void Accept(CSharpSyntaxVisitor visitor) => visitor.VisitUnsafeStatement(this);

    public UnsafeStatementSyntax Update(SyntaxToken unsafeKeyword, BlockSyntax block)
    {
        if (unsafeKeyword != this.UnsafeKeyword || block != this.Block)
        {
            var newNode = SyntaxFactory.UnsafeStatement(unsafeKeyword, block);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
        => new UnsafeStatementSyntax(this.Kind, this.unsafeKeyword, this.block, diagnostics, GetAnnotations());

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
        => new UnsafeStatementSyntax(this.Kind, this.unsafeKeyword, this.block, GetDiagnostics(), annotations);

    internal UnsafeStatementSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 2;
      var unsafeKeyword = (SyntaxToken)reader.ReadValue();
      if (unsafeKeyword != null)
      {
         AdjustFlagsAndWidth(unsafeKeyword);
         this.unsafeKeyword = unsafeKeyword;
      }
      var block = (BlockSyntax)reader.ReadValue();
      if (block != null)
      {
         AdjustFlagsAndWidth(block);
         this.block = block;
      }
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.unsafeKeyword);
      writer.WriteValue(this.block);
    }

    static UnsafeStatementSyntax()
    {
       ObjectBinder.RegisterTypeReader(typeof(UnsafeStatementSyntax), r => new UnsafeStatementSyntax(r));
    }
  }

  internal sealed partial class LockStatementSyntax : StatementSyntax
  {
    internal readonly SyntaxToken lockKeyword;
    internal readonly SyntaxToken openParenToken;
    internal readonly ExpressionSyntax expression;
    internal readonly SyntaxToken closeParenToken;
    internal readonly StatementSyntax statement;

    internal LockStatementSyntax(SyntaxKind kind, SyntaxToken lockKeyword, SyntaxToken openParenToken, ExpressionSyntax expression, SyntaxToken closeParenToken, StatementSyntax statement, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 5;
        this.AdjustFlagsAndWidth(lockKeyword);
        this.lockKeyword = lockKeyword;
        this.AdjustFlagsAndWidth(openParenToken);
        this.openParenToken = openParenToken;
        this.AdjustFlagsAndWidth(expression);
        this.expression = expression;
        this.AdjustFlagsAndWidth(closeParenToken);
        this.closeParenToken = closeParenToken;
        this.AdjustFlagsAndWidth(statement);
        this.statement = statement;
    }


    internal LockStatementSyntax(SyntaxKind kind, SyntaxToken lockKeyword, SyntaxToken openParenToken, ExpressionSyntax expression, SyntaxToken closeParenToken, StatementSyntax statement, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 5;
        this.AdjustFlagsAndWidth(lockKeyword);
        this.lockKeyword = lockKeyword;
        this.AdjustFlagsAndWidth(openParenToken);
        this.openParenToken = openParenToken;
        this.AdjustFlagsAndWidth(expression);
        this.expression = expression;
        this.AdjustFlagsAndWidth(closeParenToken);
        this.closeParenToken = closeParenToken;
        this.AdjustFlagsAndWidth(statement);
        this.statement = statement;
    }


    internal LockStatementSyntax(SyntaxKind kind, SyntaxToken lockKeyword, SyntaxToken openParenToken, ExpressionSyntax expression, SyntaxToken closeParenToken, StatementSyntax statement)
        : base(kind)
    {
        this.SlotCount = 5;
        this.AdjustFlagsAndWidth(lockKeyword);
        this.lockKeyword = lockKeyword;
        this.AdjustFlagsAndWidth(openParenToken);
        this.openParenToken = openParenToken;
        this.AdjustFlagsAndWidth(expression);
        this.expression = expression;
        this.AdjustFlagsAndWidth(closeParenToken);
        this.closeParenToken = closeParenToken;
        this.AdjustFlagsAndWidth(statement);
        this.statement = statement;
    }

    public SyntaxToken LockKeyword => this.lockKeyword;
    public SyntaxToken OpenParenToken => this.openParenToken;
    public ExpressionSyntax Expression => this.expression;
    public SyntaxToken CloseParenToken => this.closeParenToken;
    public StatementSyntax Statement => this.statement;

    internal override GreenNode? GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.lockKeyword;
            case 1: return this.openParenToken;
            case 2: return this.expression;
            case 3: return this.closeParenToken;
            case 4: return this.statement;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new CSharp.Syntax.LockStatementSyntax(this, parent, position);

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor) => visitor.VisitLockStatement(this);

    public override void Accept(CSharpSyntaxVisitor visitor) => visitor.VisitLockStatement(this);

    public LockStatementSyntax Update(SyntaxToken lockKeyword, SyntaxToken openParenToken, ExpressionSyntax expression, SyntaxToken closeParenToken, StatementSyntax statement)
    {
        if (lockKeyword != this.LockKeyword || openParenToken != this.OpenParenToken || expression != this.Expression || closeParenToken != this.CloseParenToken || statement != this.Statement)
        {
            var newNode = SyntaxFactory.LockStatement(lockKeyword, openParenToken, expression, closeParenToken, statement);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
        => new LockStatementSyntax(this.Kind, this.lockKeyword, this.openParenToken, this.expression, this.closeParenToken, this.statement, diagnostics, GetAnnotations());

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
        => new LockStatementSyntax(this.Kind, this.lockKeyword, this.openParenToken, this.expression, this.closeParenToken, this.statement, GetDiagnostics(), annotations);

    internal LockStatementSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 5;
      var lockKeyword = (SyntaxToken)reader.ReadValue();
      if (lockKeyword != null)
      {
         AdjustFlagsAndWidth(lockKeyword);
         this.lockKeyword = lockKeyword;
      }
      var openParenToken = (SyntaxToken)reader.ReadValue();
      if (openParenToken != null)
      {
         AdjustFlagsAndWidth(openParenToken);
         this.openParenToken = openParenToken;
      }
      var expression = (ExpressionSyntax)reader.ReadValue();
      if (expression != null)
      {
         AdjustFlagsAndWidth(expression);
         this.expression = expression;
      }
      var closeParenToken = (SyntaxToken)reader.ReadValue();
      if (closeParenToken != null)
      {
         AdjustFlagsAndWidth(closeParenToken);
         this.closeParenToken = closeParenToken;
      }
      var statement = (StatementSyntax)reader.ReadValue();
      if (statement != null)
      {
         AdjustFlagsAndWidth(statement);
         this.statement = statement;
      }
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.lockKeyword);
      writer.WriteValue(this.openParenToken);
      writer.WriteValue(this.expression);
      writer.WriteValue(this.closeParenToken);
      writer.WriteValue(this.statement);
    }

    static LockStatementSyntax()
    {
       ObjectBinder.RegisterTypeReader(typeof(LockStatementSyntax), r => new LockStatementSyntax(r));
    }
  }

  /// <summary>
  /// Represents an if statement syntax.
  /// </summary>
  internal sealed partial class IfStatementSyntax : StatementSyntax
  {
    internal readonly SyntaxToken ifKeyword;
    internal readonly SyntaxToken openParenToken;
    internal readonly ExpressionSyntax condition;
    internal readonly SyntaxToken closeParenToken;
    internal readonly StatementSyntax statement;
    internal readonly ElseClauseSyntax? @else;

    internal IfStatementSyntax(SyntaxKind kind, SyntaxToken ifKeyword, SyntaxToken openParenToken, ExpressionSyntax condition, SyntaxToken closeParenToken, StatementSyntax statement, ElseClauseSyntax? @else, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 6;
        this.AdjustFlagsAndWidth(ifKeyword);
        this.ifKeyword = ifKeyword;
        this.AdjustFlagsAndWidth(openParenToken);
        this.openParenToken = openParenToken;
        this.AdjustFlagsAndWidth(condition);
        this.condition = condition;
        this.AdjustFlagsAndWidth(closeParenToken);
        this.closeParenToken = closeParenToken;
        this.AdjustFlagsAndWidth(statement);
        this.statement = statement;
        if (@else != null)
        {
            this.AdjustFlagsAndWidth(@else);
            this.@else = @else;
        }
    }


    internal IfStatementSyntax(SyntaxKind kind, SyntaxToken ifKeyword, SyntaxToken openParenToken, ExpressionSyntax condition, SyntaxToken closeParenToken, StatementSyntax statement, ElseClauseSyntax? @else, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 6;
        this.AdjustFlagsAndWidth(ifKeyword);
        this.ifKeyword = ifKeyword;
        this.AdjustFlagsAndWidth(openParenToken);
        this.openParenToken = openParenToken;
        this.AdjustFlagsAndWidth(condition);
        this.condition = condition;
        this.AdjustFlagsAndWidth(closeParenToken);
        this.closeParenToken = closeParenToken;
        this.AdjustFlagsAndWidth(statement);
        this.statement = statement;
        if (@else != null)
        {
            this.AdjustFlagsAndWidth(@else);
            this.@else = @else;
        }
    }


    internal IfStatementSyntax(SyntaxKind kind, SyntaxToken ifKeyword, SyntaxToken openParenToken, ExpressionSyntax condition, SyntaxToken closeParenToken, StatementSyntax statement, ElseClauseSyntax? @else)
        : base(kind)
    {
        this.SlotCount = 6;
        this.AdjustFlagsAndWidth(ifKeyword);
        this.ifKeyword = ifKeyword;
        this.AdjustFlagsAndWidth(openParenToken);
        this.openParenToken = openParenToken;
        this.AdjustFlagsAndWidth(condition);
        this.condition = condition;
        this.AdjustFlagsAndWidth(closeParenToken);
        this.closeParenToken = closeParenToken;
        this.AdjustFlagsAndWidth(statement);
        this.statement = statement;
        if (@else != null)
        {
            this.AdjustFlagsAndWidth(@else);
            this.@else = @else;
        }
    }

    /// <summary>
    /// Gets a SyntaxToken that represents the if keyword.
    /// </summary>
    public SyntaxToken IfKeyword => this.ifKeyword;
    /// <summary>
    /// Gets a SyntaxToken that represents the open parenthesis before the if statement's condition expression.
    /// </summary>
    public SyntaxToken OpenParenToken => this.openParenToken;
    /// <summary>
    /// Gets an ExpressionSyntax that represents the condition of the if statement.
    /// </summary>
    public ExpressionSyntax Condition => this.condition;
    /// <summary>
    /// Gets a SyntaxToken that represents the close parenthesis after the if statement's condition expression.
    /// </summary>
    public SyntaxToken CloseParenToken => this.closeParenToken;
    /// <summary>
    /// Gets a StatementSyntax the represents the statement to be executed when the condition is true.
    /// </summary>
    public StatementSyntax Statement => this.statement;
    /// <summary>
    /// Gets an ElseClauseSyntax that represents the statement to be executed when the condition is false if such statement exists.
    /// </summary>
    public ElseClauseSyntax? Else => this.@else;

    internal override GreenNode? GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.ifKeyword;
            case 1: return this.openParenToken;
            case 2: return this.condition;
            case 3: return this.closeParenToken;
            case 4: return this.statement;
            case 5: return this.@else;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new CSharp.Syntax.IfStatementSyntax(this, parent, position);

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor) => visitor.VisitIfStatement(this);

    public override void Accept(CSharpSyntaxVisitor visitor) => visitor.VisitIfStatement(this);

    public IfStatementSyntax Update(SyntaxToken ifKeyword, SyntaxToken openParenToken, ExpressionSyntax condition, SyntaxToken closeParenToken, StatementSyntax statement, ElseClauseSyntax @else)
    {
        if (ifKeyword != this.IfKeyword || openParenToken != this.OpenParenToken || condition != this.Condition || closeParenToken != this.CloseParenToken || statement != this.Statement || @else != this.Else)
        {
            var newNode = SyntaxFactory.IfStatement(ifKeyword, openParenToken, condition, closeParenToken, statement, @else);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
        => new IfStatementSyntax(this.Kind, this.ifKeyword, this.openParenToken, this.condition, this.closeParenToken, this.statement, this.@else, diagnostics, GetAnnotations());

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
        => new IfStatementSyntax(this.Kind, this.ifKeyword, this.openParenToken, this.condition, this.closeParenToken, this.statement, this.@else, GetDiagnostics(), annotations);

    internal IfStatementSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 6;
      var ifKeyword = (SyntaxToken)reader.ReadValue();
      if (ifKeyword != null)
      {
         AdjustFlagsAndWidth(ifKeyword);
         this.ifKeyword = ifKeyword;
      }
      var openParenToken = (SyntaxToken)reader.ReadValue();
      if (openParenToken != null)
      {
         AdjustFlagsAndWidth(openParenToken);
         this.openParenToken = openParenToken;
      }
      var condition = (ExpressionSyntax)reader.ReadValue();
      if (condition != null)
      {
         AdjustFlagsAndWidth(condition);
         this.condition = condition;
      }
      var closeParenToken = (SyntaxToken)reader.ReadValue();
      if (closeParenToken != null)
      {
         AdjustFlagsAndWidth(closeParenToken);
         this.closeParenToken = closeParenToken;
      }
      var statement = (StatementSyntax)reader.ReadValue();
      if (statement != null)
      {
         AdjustFlagsAndWidth(statement);
         this.statement = statement;
      }
      var @else = (ElseClauseSyntax?)reader.ReadValue();
      if (@else != null)
      {
         AdjustFlagsAndWidth(@else);
         this.@else = @else;
      }
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.ifKeyword);
      writer.WriteValue(this.openParenToken);
      writer.WriteValue(this.condition);
      writer.WriteValue(this.closeParenToken);
      writer.WriteValue(this.statement);
      writer.WriteValue(this.@else);
    }

    static IfStatementSyntax()
    {
       ObjectBinder.RegisterTypeReader(typeof(IfStatementSyntax), r => new IfStatementSyntax(r));
    }
  }

  /// <summary>Represents an else statement syntax.</summary>
  internal sealed partial class ElseClauseSyntax : CSharpSyntaxNode
  {
    internal readonly SyntaxToken elseKeyword;
    internal readonly StatementSyntax statement;

    internal ElseClauseSyntax(SyntaxKind kind, SyntaxToken elseKeyword, StatementSyntax statement, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 2;
        this.AdjustFlagsAndWidth(elseKeyword);
        this.elseKeyword = elseKeyword;
        this.AdjustFlagsAndWidth(statement);
        this.statement = statement;
    }


    internal ElseClauseSyntax(SyntaxKind kind, SyntaxToken elseKeyword, StatementSyntax statement, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 2;
        this.AdjustFlagsAndWidth(elseKeyword);
        this.elseKeyword = elseKeyword;
        this.AdjustFlagsAndWidth(statement);
        this.statement = statement;
    }


    internal ElseClauseSyntax(SyntaxKind kind, SyntaxToken elseKeyword, StatementSyntax statement)
        : base(kind)
    {
        this.SlotCount = 2;
        this.AdjustFlagsAndWidth(elseKeyword);
        this.elseKeyword = elseKeyword;
        this.AdjustFlagsAndWidth(statement);
        this.statement = statement;
    }

    /// <summary>
    /// Gets a syntax token
    /// </summary>
    public SyntaxToken ElseKeyword => this.elseKeyword;
    public StatementSyntax Statement => this.statement;

    internal override GreenNode? GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.elseKeyword;
            case 1: return this.statement;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new CSharp.Syntax.ElseClauseSyntax(this, parent, position);

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor) => visitor.VisitElseClause(this);

    public override void Accept(CSharpSyntaxVisitor visitor) => visitor.VisitElseClause(this);

    public ElseClauseSyntax Update(SyntaxToken elseKeyword, StatementSyntax statement)
    {
        if (elseKeyword != this.ElseKeyword || statement != this.Statement)
        {
            var newNode = SyntaxFactory.ElseClause(elseKeyword, statement);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
        => new ElseClauseSyntax(this.Kind, this.elseKeyword, this.statement, diagnostics, GetAnnotations());

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
        => new ElseClauseSyntax(this.Kind, this.elseKeyword, this.statement, GetDiagnostics(), annotations);

    internal ElseClauseSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 2;
      var elseKeyword = (SyntaxToken)reader.ReadValue();
      if (elseKeyword != null)
      {
         AdjustFlagsAndWidth(elseKeyword);
         this.elseKeyword = elseKeyword;
      }
      var statement = (StatementSyntax)reader.ReadValue();
      if (statement != null)
      {
         AdjustFlagsAndWidth(statement);
         this.statement = statement;
      }
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.elseKeyword);
      writer.WriteValue(this.statement);
    }

    static ElseClauseSyntax()
    {
       ObjectBinder.RegisterTypeReader(typeof(ElseClauseSyntax), r => new ElseClauseSyntax(r));
    }
  }

  /// <summary>Represents a switch statement syntax.</summary>
  internal sealed partial class SwitchStatementSyntax : StatementSyntax
  {
    internal readonly SyntaxToken switchKeyword;
    internal readonly SyntaxToken? openParenToken;
    internal readonly ExpressionSyntax expression;
    internal readonly SyntaxToken? closeParenToken;
    internal readonly SyntaxToken openBraceToken;
    internal readonly GreenNode? sections;
    internal readonly SyntaxToken closeBraceToken;

    internal SwitchStatementSyntax(SyntaxKind kind, SyntaxToken switchKeyword, SyntaxToken? openParenToken, ExpressionSyntax expression, SyntaxToken? closeParenToken, SyntaxToken openBraceToken, GreenNode? sections, SyntaxToken closeBraceToken, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 7;
        this.AdjustFlagsAndWidth(switchKeyword);
        this.switchKeyword = switchKeyword;
        if (openParenToken != null)
        {
            this.AdjustFlagsAndWidth(openParenToken);
            this.openParenToken = openParenToken;
        }
        this.AdjustFlagsAndWidth(expression);
        this.expression = expression;
        if (closeParenToken != null)
        {
            this.AdjustFlagsAndWidth(closeParenToken);
            this.closeParenToken = closeParenToken;
        }
        this.AdjustFlagsAndWidth(openBraceToken);
        this.openBraceToken = openBraceToken;
        if (sections != null)
        {
            this.AdjustFlagsAndWidth(sections);
            this.sections = sections;
        }
        this.AdjustFlagsAndWidth(closeBraceToken);
        this.closeBraceToken = closeBraceToken;
    }


    internal SwitchStatementSyntax(SyntaxKind kind, SyntaxToken switchKeyword, SyntaxToken? openParenToken, ExpressionSyntax expression, SyntaxToken? closeParenToken, SyntaxToken openBraceToken, GreenNode? sections, SyntaxToken closeBraceToken, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 7;
        this.AdjustFlagsAndWidth(switchKeyword);
        this.switchKeyword = switchKeyword;
        if (openParenToken != null)
        {
            this.AdjustFlagsAndWidth(openParenToken);
            this.openParenToken = openParenToken;
        }
        this.AdjustFlagsAndWidth(expression);
        this.expression = expression;
        if (closeParenToken != null)
        {
            this.AdjustFlagsAndWidth(closeParenToken);
            this.closeParenToken = closeParenToken;
        }
        this.AdjustFlagsAndWidth(openBraceToken);
        this.openBraceToken = openBraceToken;
        if (sections != null)
        {
            this.AdjustFlagsAndWidth(sections);
            this.sections = sections;
        }
        this.AdjustFlagsAndWidth(closeBraceToken);
        this.closeBraceToken = closeBraceToken;
    }


    internal SwitchStatementSyntax(SyntaxKind kind, SyntaxToken switchKeyword, SyntaxToken? openParenToken, ExpressionSyntax expression, SyntaxToken? closeParenToken, SyntaxToken openBraceToken, GreenNode? sections, SyntaxToken closeBraceToken)
        : base(kind)
    {
        this.SlotCount = 7;
        this.AdjustFlagsAndWidth(switchKeyword);
        this.switchKeyword = switchKeyword;
        if (openParenToken != null)
        {
            this.AdjustFlagsAndWidth(openParenToken);
            this.openParenToken = openParenToken;
        }
        this.AdjustFlagsAndWidth(expression);
        this.expression = expression;
        if (closeParenToken != null)
        {
            this.AdjustFlagsAndWidth(closeParenToken);
            this.closeParenToken = closeParenToken;
        }
        this.AdjustFlagsAndWidth(openBraceToken);
        this.openBraceToken = openBraceToken;
        if (sections != null)
        {
            this.AdjustFlagsAndWidth(sections);
            this.sections = sections;
        }
        this.AdjustFlagsAndWidth(closeBraceToken);
        this.closeBraceToken = closeBraceToken;
    }

    /// <summary>
    /// Gets a SyntaxToken that represents the switch keyword.
    /// </summary>
    public SyntaxToken SwitchKeyword => this.switchKeyword;
    /// <summary>
    /// Gets a SyntaxToken that represents the open parenthesis preceding the switch governing expression.
    /// </summary>
    public SyntaxToken? OpenParenToken => this.openParenToken;
    /// <summary>
    /// Gets an ExpressionSyntax representing the expression of the switch statement.
    /// </summary>
    public ExpressionSyntax Expression => this.expression;
    /// <summary>
    /// Gets a SyntaxToken that represents the close parenthesis following the switch governing expression.
    /// </summary>
    public SyntaxToken? CloseParenToken => this.closeParenToken;
    /// <summary>
    /// Gets a SyntaxToken that represents the open braces preceding the switch sections.
    /// </summary>
    public SyntaxToken OpenBraceToken => this.openBraceToken;
    /// <summary>
    /// Gets a SyntaxList of SwitchSectionSyntax's that represents the switch sections of the switch statement.
    /// </summary>
    public Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SwitchSectionSyntax> Sections => new Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SwitchSectionSyntax>(this.sections);
    /// <summary>
    /// Gets a SyntaxToken that represents the open braces following the switch sections.
    /// </summary>
    public SyntaxToken CloseBraceToken => this.closeBraceToken;

    internal override GreenNode? GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.switchKeyword;
            case 1: return this.openParenToken;
            case 2: return this.expression;
            case 3: return this.closeParenToken;
            case 4: return this.openBraceToken;
            case 5: return this.sections;
            case 6: return this.closeBraceToken;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new CSharp.Syntax.SwitchStatementSyntax(this, parent, position);

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor) => visitor.VisitSwitchStatement(this);

    public override void Accept(CSharpSyntaxVisitor visitor) => visitor.VisitSwitchStatement(this);

    public SwitchStatementSyntax Update(SyntaxToken switchKeyword, SyntaxToken openParenToken, ExpressionSyntax expression, SyntaxToken closeParenToken, SyntaxToken openBraceToken, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SwitchSectionSyntax> sections, SyntaxToken closeBraceToken)
    {
        if (switchKeyword != this.SwitchKeyword || openParenToken != this.OpenParenToken || expression != this.Expression || closeParenToken != this.CloseParenToken || openBraceToken != this.OpenBraceToken || sections != this.Sections || closeBraceToken != this.CloseBraceToken)
        {
            var newNode = SyntaxFactory.SwitchStatement(switchKeyword, openParenToken, expression, closeParenToken, openBraceToken, sections, closeBraceToken);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
        => new SwitchStatementSyntax(this.Kind, this.switchKeyword, this.openParenToken, this.expression, this.closeParenToken, this.openBraceToken, this.sections, this.closeBraceToken, diagnostics, GetAnnotations());

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
        => new SwitchStatementSyntax(this.Kind, this.switchKeyword, this.openParenToken, this.expression, this.closeParenToken, this.openBraceToken, this.sections, this.closeBraceToken, GetDiagnostics(), annotations);

    internal SwitchStatementSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 7;
      var switchKeyword = (SyntaxToken)reader.ReadValue();
      if (switchKeyword != null)
      {
         AdjustFlagsAndWidth(switchKeyword);
         this.switchKeyword = switchKeyword;
      }
      var openParenToken = (SyntaxToken?)reader.ReadValue();
      if (openParenToken != null)
      {
         AdjustFlagsAndWidth(openParenToken);
         this.openParenToken = openParenToken;
      }
      var expression = (ExpressionSyntax)reader.ReadValue();
      if (expression != null)
      {
         AdjustFlagsAndWidth(expression);
         this.expression = expression;
      }
      var closeParenToken = (SyntaxToken?)reader.ReadValue();
      if (closeParenToken != null)
      {
         AdjustFlagsAndWidth(closeParenToken);
         this.closeParenToken = closeParenToken;
      }
      var openBraceToken = (SyntaxToken)reader.ReadValue();
      if (openBraceToken != null)
      {
         AdjustFlagsAndWidth(openBraceToken);
         this.openBraceToken = openBraceToken;
      }
      var sections = (GreenNode?)reader.ReadValue();
      if (sections != null)
      {
         AdjustFlagsAndWidth(sections);
         this.sections = sections;
      }
      var closeBraceToken = (SyntaxToken)reader.ReadValue();
      if (closeBraceToken != null)
      {
         AdjustFlagsAndWidth(closeBraceToken);
         this.closeBraceToken = closeBraceToken;
      }
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.switchKeyword);
      writer.WriteValue(this.openParenToken);
      writer.WriteValue(this.expression);
      writer.WriteValue(this.closeParenToken);
      writer.WriteValue(this.openBraceToken);
      writer.WriteValue(this.sections);
      writer.WriteValue(this.closeBraceToken);
    }

    static SwitchStatementSyntax()
    {
       ObjectBinder.RegisterTypeReader(typeof(SwitchStatementSyntax), r => new SwitchStatementSyntax(r));
    }
  }

  /// <summary>Represents a switch section syntax of a switch statement.</summary>
  internal sealed partial class SwitchSectionSyntax : CSharpSyntaxNode
  {
    internal readonly GreenNode? labels;
    internal readonly GreenNode? statements;

    internal SwitchSectionSyntax(SyntaxKind kind, GreenNode? labels, GreenNode? statements, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 2;
        if (labels != null)
        {
            this.AdjustFlagsAndWidth(labels);
            this.labels = labels;
        }
        if (statements != null)
        {
            this.AdjustFlagsAndWidth(statements);
            this.statements = statements;
        }
    }


    internal SwitchSectionSyntax(SyntaxKind kind, GreenNode? labels, GreenNode? statements, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 2;
        if (labels != null)
        {
            this.AdjustFlagsAndWidth(labels);
            this.labels = labels;
        }
        if (statements != null)
        {
            this.AdjustFlagsAndWidth(statements);
            this.statements = statements;
        }
    }


    internal SwitchSectionSyntax(SyntaxKind kind, GreenNode? labels, GreenNode? statements)
        : base(kind)
    {
        this.SlotCount = 2;
        if (labels != null)
        {
            this.AdjustFlagsAndWidth(labels);
            this.labels = labels;
        }
        if (statements != null)
        {
            this.AdjustFlagsAndWidth(statements);
            this.statements = statements;
        }
    }

    /// <summary>
    /// Gets a SyntaxList of SwitchLabelSyntax's the represents the possible labels that control can transfer to within the section.
    /// </summary>
    public Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SwitchLabelSyntax> Labels => new Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SwitchLabelSyntax>(this.labels);
    /// <summary>
    /// Gets a SyntaxList of StatementSyntax's the represents the statements to be executed when control transfer to a label the belongs to the section.
    /// </summary>
    public Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<StatementSyntax> Statements => new Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<StatementSyntax>(this.statements);

    internal override GreenNode? GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.labels;
            case 1: return this.statements;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new CSharp.Syntax.SwitchSectionSyntax(this, parent, position);

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor) => visitor.VisitSwitchSection(this);

    public override void Accept(CSharpSyntaxVisitor visitor) => visitor.VisitSwitchSection(this);

    public SwitchSectionSyntax Update(Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SwitchLabelSyntax> labels, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<StatementSyntax> statements)
    {
        if (labels != this.Labels || statements != this.Statements)
        {
            var newNode = SyntaxFactory.SwitchSection(labels, statements);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
        => new SwitchSectionSyntax(this.Kind, this.labels, this.statements, diagnostics, GetAnnotations());

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
        => new SwitchSectionSyntax(this.Kind, this.labels, this.statements, GetDiagnostics(), annotations);

    internal SwitchSectionSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 2;
      var labels = (GreenNode?)reader.ReadValue();
      if (labels != null)
      {
         AdjustFlagsAndWidth(labels);
         this.labels = labels;
      }
      var statements = (GreenNode?)reader.ReadValue();
      if (statements != null)
      {
         AdjustFlagsAndWidth(statements);
         this.statements = statements;
      }
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.labels);
      writer.WriteValue(this.statements);
    }

    static SwitchSectionSyntax()
    {
       ObjectBinder.RegisterTypeReader(typeof(SwitchSectionSyntax), r => new SwitchSectionSyntax(r));
    }
  }

  /// <summary>Represents a switch label within a switch statement.</summary>
  internal abstract partial class SwitchLabelSyntax : CSharpSyntaxNode
  {
    internal SwitchLabelSyntax(SyntaxKind kind, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
      : base(kind, diagnostics, annotations)
    {
    }
    internal SwitchLabelSyntax(SyntaxKind kind)
      : base(kind)
    {
    }

    protected SwitchLabelSyntax(ObjectReader reader)
       : base(reader)
    {
    }

    /// <summary>
    /// Gets a SyntaxToken that represents a case or default keyword that belongs to a switch label.
    /// </summary>
    public abstract SyntaxToken Keyword { get; }

    /// <summary>
    /// Gets a SyntaxToken that represents the colon that terminates the switch label.
    /// </summary>
    public abstract SyntaxToken ColonToken { get; }
  }

  /// <summary>Represents a case label within a switch statement.</summary>
  internal sealed partial class CasePatternSwitchLabelSyntax : SwitchLabelSyntax
  {
    internal readonly SyntaxToken keyword;
    internal readonly PatternSyntax pattern;
    internal readonly WhenClauseSyntax? whenClause;
    internal readonly SyntaxToken colonToken;

    internal CasePatternSwitchLabelSyntax(SyntaxKind kind, SyntaxToken keyword, PatternSyntax pattern, WhenClauseSyntax? whenClause, SyntaxToken colonToken, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 4;
        this.AdjustFlagsAndWidth(keyword);
        this.keyword = keyword;
        this.AdjustFlagsAndWidth(pattern);
        this.pattern = pattern;
        if (whenClause != null)
        {
            this.AdjustFlagsAndWidth(whenClause);
            this.whenClause = whenClause;
        }
        this.AdjustFlagsAndWidth(colonToken);
        this.colonToken = colonToken;
    }


    internal CasePatternSwitchLabelSyntax(SyntaxKind kind, SyntaxToken keyword, PatternSyntax pattern, WhenClauseSyntax? whenClause, SyntaxToken colonToken, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 4;
        this.AdjustFlagsAndWidth(keyword);
        this.keyword = keyword;
        this.AdjustFlagsAndWidth(pattern);
        this.pattern = pattern;
        if (whenClause != null)
        {
            this.AdjustFlagsAndWidth(whenClause);
            this.whenClause = whenClause;
        }
        this.AdjustFlagsAndWidth(colonToken);
        this.colonToken = colonToken;
    }


    internal CasePatternSwitchLabelSyntax(SyntaxKind kind, SyntaxToken keyword, PatternSyntax pattern, WhenClauseSyntax? whenClause, SyntaxToken colonToken)
        : base(kind)
    {
        this.SlotCount = 4;
        this.AdjustFlagsAndWidth(keyword);
        this.keyword = keyword;
        this.AdjustFlagsAndWidth(pattern);
        this.pattern = pattern;
        if (whenClause != null)
        {
            this.AdjustFlagsAndWidth(whenClause);
            this.whenClause = whenClause;
        }
        this.AdjustFlagsAndWidth(colonToken);
        this.colonToken = colonToken;
    }

    /// <summary>Gets the case keyword token.</summary>
    public override SyntaxToken Keyword => this.keyword;
    /// <summary>
    /// Gets a PatternSyntax that represents the pattern that gets matched for the case label.
    /// </summary>
    public PatternSyntax Pattern => this.pattern;
    public WhenClauseSyntax? WhenClause => this.whenClause;
    public override SyntaxToken ColonToken => this.colonToken;

    internal override GreenNode? GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.keyword;
            case 1: return this.pattern;
            case 2: return this.whenClause;
            case 3: return this.colonToken;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new CSharp.Syntax.CasePatternSwitchLabelSyntax(this, parent, position);

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor) => visitor.VisitCasePatternSwitchLabel(this);

    public override void Accept(CSharpSyntaxVisitor visitor) => visitor.VisitCasePatternSwitchLabel(this);

    public CasePatternSwitchLabelSyntax Update(SyntaxToken keyword, PatternSyntax pattern, WhenClauseSyntax whenClause, SyntaxToken colonToken)
    {
        if (keyword != this.Keyword || pattern != this.Pattern || whenClause != this.WhenClause || colonToken != this.ColonToken)
        {
            var newNode = SyntaxFactory.CasePatternSwitchLabel(keyword, pattern, whenClause, colonToken);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
        => new CasePatternSwitchLabelSyntax(this.Kind, this.keyword, this.pattern, this.whenClause, this.colonToken, diagnostics, GetAnnotations());

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
        => new CasePatternSwitchLabelSyntax(this.Kind, this.keyword, this.pattern, this.whenClause, this.colonToken, GetDiagnostics(), annotations);

    internal CasePatternSwitchLabelSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 4;
      var keyword = (SyntaxToken)reader.ReadValue();
      if (keyword != null)
      {
         AdjustFlagsAndWidth(keyword);
         this.keyword = keyword;
      }
      var pattern = (PatternSyntax)reader.ReadValue();
      if (pattern != null)
      {
         AdjustFlagsAndWidth(pattern);
         this.pattern = pattern;
      }
      var whenClause = (WhenClauseSyntax?)reader.ReadValue();
      if (whenClause != null)
      {
         AdjustFlagsAndWidth(whenClause);
         this.whenClause = whenClause;
      }
      var colonToken = (SyntaxToken)reader.ReadValue();
      if (colonToken != null)
      {
         AdjustFlagsAndWidth(colonToken);
         this.colonToken = colonToken;
      }
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.keyword);
      writer.WriteValue(this.pattern);
      writer.WriteValue(this.whenClause);
      writer.WriteValue(this.colonToken);
    }

    static CasePatternSwitchLabelSyntax()
    {
       ObjectBinder.RegisterTypeReader(typeof(CasePatternSwitchLabelSyntax), r => new CasePatternSwitchLabelSyntax(r));
    }
  }

  /// <summary>Represents a case label within a switch statement.</summary>
  internal sealed partial class CaseSwitchLabelSyntax : SwitchLabelSyntax
  {
    internal readonly SyntaxToken keyword;
    internal readonly ExpressionSyntax value;
    internal readonly SyntaxToken colonToken;

    internal CaseSwitchLabelSyntax(SyntaxKind kind, SyntaxToken keyword, ExpressionSyntax value, SyntaxToken colonToken, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 3;
        this.AdjustFlagsAndWidth(keyword);
        this.keyword = keyword;
        this.AdjustFlagsAndWidth(value);
        this.value = value;
        this.AdjustFlagsAndWidth(colonToken);
        this.colonToken = colonToken;
    }


    internal CaseSwitchLabelSyntax(SyntaxKind kind, SyntaxToken keyword, ExpressionSyntax value, SyntaxToken colonToken, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 3;
        this.AdjustFlagsAndWidth(keyword);
        this.keyword = keyword;
        this.AdjustFlagsAndWidth(value);
        this.value = value;
        this.AdjustFlagsAndWidth(colonToken);
        this.colonToken = colonToken;
    }


    internal CaseSwitchLabelSyntax(SyntaxKind kind, SyntaxToken keyword, ExpressionSyntax value, SyntaxToken colonToken)
        : base(kind)
    {
        this.SlotCount = 3;
        this.AdjustFlagsAndWidth(keyword);
        this.keyword = keyword;
        this.AdjustFlagsAndWidth(value);
        this.value = value;
        this.AdjustFlagsAndWidth(colonToken);
        this.colonToken = colonToken;
    }

    /// <summary>Gets the case keyword token.</summary>
    public override SyntaxToken Keyword => this.keyword;
    /// <summary>
    /// Gets an ExpressionSyntax that represents the constant expression that gets matched for the case label.
    /// </summary>
    public ExpressionSyntax Value => this.value;
    public override SyntaxToken ColonToken => this.colonToken;

    internal override GreenNode? GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.keyword;
            case 1: return this.value;
            case 2: return this.colonToken;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new CSharp.Syntax.CaseSwitchLabelSyntax(this, parent, position);

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor) => visitor.VisitCaseSwitchLabel(this);

    public override void Accept(CSharpSyntaxVisitor visitor) => visitor.VisitCaseSwitchLabel(this);

    public CaseSwitchLabelSyntax Update(SyntaxToken keyword, ExpressionSyntax value, SyntaxToken colonToken)
    {
        if (keyword != this.Keyword || value != this.Value || colonToken != this.ColonToken)
        {
            var newNode = SyntaxFactory.CaseSwitchLabel(keyword, value, colonToken);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
        => new CaseSwitchLabelSyntax(this.Kind, this.keyword, this.value, this.colonToken, diagnostics, GetAnnotations());

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
        => new CaseSwitchLabelSyntax(this.Kind, this.keyword, this.value, this.colonToken, GetDiagnostics(), annotations);

    internal CaseSwitchLabelSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 3;
      var keyword = (SyntaxToken)reader.ReadValue();
      if (keyword != null)
      {
         AdjustFlagsAndWidth(keyword);
         this.keyword = keyword;
      }
      var value = (ExpressionSyntax)reader.ReadValue();
      if (value != null)
      {
         AdjustFlagsAndWidth(value);
         this.value = value;
      }
      var colonToken = (SyntaxToken)reader.ReadValue();
      if (colonToken != null)
      {
         AdjustFlagsAndWidth(colonToken);
         this.colonToken = colonToken;
      }
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.keyword);
      writer.WriteValue(this.value);
      writer.WriteValue(this.colonToken);
    }

    static CaseSwitchLabelSyntax()
    {
       ObjectBinder.RegisterTypeReader(typeof(CaseSwitchLabelSyntax), r => new CaseSwitchLabelSyntax(r));
    }
  }

  /// <summary>Represents a default label within a switch statement.</summary>
  internal sealed partial class DefaultSwitchLabelSyntax : SwitchLabelSyntax
  {
    internal readonly SyntaxToken keyword;
    internal readonly SyntaxToken colonToken;

    internal DefaultSwitchLabelSyntax(SyntaxKind kind, SyntaxToken keyword, SyntaxToken colonToken, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 2;
        this.AdjustFlagsAndWidth(keyword);
        this.keyword = keyword;
        this.AdjustFlagsAndWidth(colonToken);
        this.colonToken = colonToken;
    }


    internal DefaultSwitchLabelSyntax(SyntaxKind kind, SyntaxToken keyword, SyntaxToken colonToken, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 2;
        this.AdjustFlagsAndWidth(keyword);
        this.keyword = keyword;
        this.AdjustFlagsAndWidth(colonToken);
        this.colonToken = colonToken;
    }


    internal DefaultSwitchLabelSyntax(SyntaxKind kind, SyntaxToken keyword, SyntaxToken colonToken)
        : base(kind)
    {
        this.SlotCount = 2;
        this.AdjustFlagsAndWidth(keyword);
        this.keyword = keyword;
        this.AdjustFlagsAndWidth(colonToken);
        this.colonToken = colonToken;
    }

    /// <summary>Gets the default keyword token.</summary>
    public override SyntaxToken Keyword => this.keyword;
    public override SyntaxToken ColonToken => this.colonToken;

    internal override GreenNode? GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.keyword;
            case 1: return this.colonToken;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new CSharp.Syntax.DefaultSwitchLabelSyntax(this, parent, position);

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor) => visitor.VisitDefaultSwitchLabel(this);

    public override void Accept(CSharpSyntaxVisitor visitor) => visitor.VisitDefaultSwitchLabel(this);

    public DefaultSwitchLabelSyntax Update(SyntaxToken keyword, SyntaxToken colonToken)
    {
        if (keyword != this.Keyword || colonToken != this.ColonToken)
        {
            var newNode = SyntaxFactory.DefaultSwitchLabel(keyword, colonToken);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
        => new DefaultSwitchLabelSyntax(this.Kind, this.keyword, this.colonToken, diagnostics, GetAnnotations());

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
        => new DefaultSwitchLabelSyntax(this.Kind, this.keyword, this.colonToken, GetDiagnostics(), annotations);

    internal DefaultSwitchLabelSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 2;
      var keyword = (SyntaxToken)reader.ReadValue();
      if (keyword != null)
      {
         AdjustFlagsAndWidth(keyword);
         this.keyword = keyword;
      }
      var colonToken = (SyntaxToken)reader.ReadValue();
      if (colonToken != null)
      {
         AdjustFlagsAndWidth(colonToken);
         this.colonToken = colonToken;
      }
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.keyword);
      writer.WriteValue(this.colonToken);
    }

    static DefaultSwitchLabelSyntax()
    {
       ObjectBinder.RegisterTypeReader(typeof(DefaultSwitchLabelSyntax), r => new DefaultSwitchLabelSyntax(r));
    }
  }

  internal sealed partial class SwitchExpressionSyntax : ExpressionSyntax
  {
    internal readonly ExpressionSyntax governingExpression;
    internal readonly SyntaxToken switchKeyword;
    internal readonly SyntaxToken openBraceToken;
    internal readonly GreenNode? arms;
    internal readonly SyntaxToken closeBraceToken;

    internal SwitchExpressionSyntax(SyntaxKind kind, ExpressionSyntax governingExpression, SyntaxToken switchKeyword, SyntaxToken openBraceToken, GreenNode? arms, SyntaxToken closeBraceToken, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 5;
        this.AdjustFlagsAndWidth(governingExpression);
        this.governingExpression = governingExpression;
        this.AdjustFlagsAndWidth(switchKeyword);
        this.switchKeyword = switchKeyword;
        this.AdjustFlagsAndWidth(openBraceToken);
        this.openBraceToken = openBraceToken;
        if (arms != null)
        {
            this.AdjustFlagsAndWidth(arms);
            this.arms = arms;
        }
        this.AdjustFlagsAndWidth(closeBraceToken);
        this.closeBraceToken = closeBraceToken;
    }


    internal SwitchExpressionSyntax(SyntaxKind kind, ExpressionSyntax governingExpression, SyntaxToken switchKeyword, SyntaxToken openBraceToken, GreenNode? arms, SyntaxToken closeBraceToken, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 5;
        this.AdjustFlagsAndWidth(governingExpression);
        this.governingExpression = governingExpression;
        this.AdjustFlagsAndWidth(switchKeyword);
        this.switchKeyword = switchKeyword;
        this.AdjustFlagsAndWidth(openBraceToken);
        this.openBraceToken = openBraceToken;
        if (arms != null)
        {
            this.AdjustFlagsAndWidth(arms);
            this.arms = arms;
        }
        this.AdjustFlagsAndWidth(closeBraceToken);
        this.closeBraceToken = closeBraceToken;
    }


    internal SwitchExpressionSyntax(SyntaxKind kind, ExpressionSyntax governingExpression, SyntaxToken switchKeyword, SyntaxToken openBraceToken, GreenNode? arms, SyntaxToken closeBraceToken)
        : base(kind)
    {
        this.SlotCount = 5;
        this.AdjustFlagsAndWidth(governingExpression);
        this.governingExpression = governingExpression;
        this.AdjustFlagsAndWidth(switchKeyword);
        this.switchKeyword = switchKeyword;
        this.AdjustFlagsAndWidth(openBraceToken);
        this.openBraceToken = openBraceToken;
        if (arms != null)
        {
            this.AdjustFlagsAndWidth(arms);
            this.arms = arms;
        }
        this.AdjustFlagsAndWidth(closeBraceToken);
        this.closeBraceToken = closeBraceToken;
    }

    public ExpressionSyntax GoverningExpression => this.governingExpression;
    public SyntaxToken SwitchKeyword => this.switchKeyword;
    public SyntaxToken OpenBraceToken => this.openBraceToken;
    public Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<SwitchExpressionArmSyntax> Arms => new Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<SwitchExpressionArmSyntax>(new Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<CSharpSyntaxNode>(this.arms));
    public SyntaxToken CloseBraceToken => this.closeBraceToken;

    internal override GreenNode? GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.governingExpression;
            case 1: return this.switchKeyword;
            case 2: return this.openBraceToken;
            case 3: return this.arms;
            case 4: return this.closeBraceToken;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new CSharp.Syntax.SwitchExpressionSyntax(this, parent, position);

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor) => visitor.VisitSwitchExpression(this);

    public override void Accept(CSharpSyntaxVisitor visitor) => visitor.VisitSwitchExpression(this);

    public SwitchExpressionSyntax Update(ExpressionSyntax governingExpression, SyntaxToken switchKeyword, SyntaxToken openBraceToken, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<SwitchExpressionArmSyntax> arms, SyntaxToken closeBraceToken)
    {
        if (governingExpression != this.GoverningExpression || switchKeyword != this.SwitchKeyword || openBraceToken != this.OpenBraceToken || arms != this.Arms || closeBraceToken != this.CloseBraceToken)
        {
            var newNode = SyntaxFactory.SwitchExpression(governingExpression, switchKeyword, openBraceToken, arms, closeBraceToken);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
        => new SwitchExpressionSyntax(this.Kind, this.governingExpression, this.switchKeyword, this.openBraceToken, this.arms, this.closeBraceToken, diagnostics, GetAnnotations());

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
        => new SwitchExpressionSyntax(this.Kind, this.governingExpression, this.switchKeyword, this.openBraceToken, this.arms, this.closeBraceToken, GetDiagnostics(), annotations);

    internal SwitchExpressionSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 5;
      var governingExpression = (ExpressionSyntax)reader.ReadValue();
      if (governingExpression != null)
      {
         AdjustFlagsAndWidth(governingExpression);
         this.governingExpression = governingExpression;
      }
      var switchKeyword = (SyntaxToken)reader.ReadValue();
      if (switchKeyword != null)
      {
         AdjustFlagsAndWidth(switchKeyword);
         this.switchKeyword = switchKeyword;
      }
      var openBraceToken = (SyntaxToken)reader.ReadValue();
      if (openBraceToken != null)
      {
         AdjustFlagsAndWidth(openBraceToken);
         this.openBraceToken = openBraceToken;
      }
      var arms = (GreenNode?)reader.ReadValue();
      if (arms != null)
      {
         AdjustFlagsAndWidth(arms);
         this.arms = arms;
      }
      var closeBraceToken = (SyntaxToken)reader.ReadValue();
      if (closeBraceToken != null)
      {
         AdjustFlagsAndWidth(closeBraceToken);
         this.closeBraceToken = closeBraceToken;
      }
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.governingExpression);
      writer.WriteValue(this.switchKeyword);
      writer.WriteValue(this.openBraceToken);
      writer.WriteValue(this.arms);
      writer.WriteValue(this.closeBraceToken);
    }

    static SwitchExpressionSyntax()
    {
       ObjectBinder.RegisterTypeReader(typeof(SwitchExpressionSyntax), r => new SwitchExpressionSyntax(r));
    }
  }

  internal sealed partial class SwitchExpressionArmSyntax : CSharpSyntaxNode
  {
    internal readonly PatternSyntax pattern;
    internal readonly WhenClauseSyntax? whenClause;
    internal readonly SyntaxToken equalsGreaterThanToken;
    internal readonly ExpressionSyntax expression;

    internal SwitchExpressionArmSyntax(SyntaxKind kind, PatternSyntax pattern, WhenClauseSyntax? whenClause, SyntaxToken equalsGreaterThanToken, ExpressionSyntax expression, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 4;
        this.AdjustFlagsAndWidth(pattern);
        this.pattern = pattern;
        if (whenClause != null)
        {
            this.AdjustFlagsAndWidth(whenClause);
            this.whenClause = whenClause;
        }
        this.AdjustFlagsAndWidth(equalsGreaterThanToken);
        this.equalsGreaterThanToken = equalsGreaterThanToken;
        this.AdjustFlagsAndWidth(expression);
        this.expression = expression;
    }


    internal SwitchExpressionArmSyntax(SyntaxKind kind, PatternSyntax pattern, WhenClauseSyntax? whenClause, SyntaxToken equalsGreaterThanToken, ExpressionSyntax expression, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 4;
        this.AdjustFlagsAndWidth(pattern);
        this.pattern = pattern;
        if (whenClause != null)
        {
            this.AdjustFlagsAndWidth(whenClause);
            this.whenClause = whenClause;
        }
        this.AdjustFlagsAndWidth(equalsGreaterThanToken);
        this.equalsGreaterThanToken = equalsGreaterThanToken;
        this.AdjustFlagsAndWidth(expression);
        this.expression = expression;
    }


    internal SwitchExpressionArmSyntax(SyntaxKind kind, PatternSyntax pattern, WhenClauseSyntax? whenClause, SyntaxToken equalsGreaterThanToken, ExpressionSyntax expression)
        : base(kind)
    {
        this.SlotCount = 4;
        this.AdjustFlagsAndWidth(pattern);
        this.pattern = pattern;
        if (whenClause != null)
        {
            this.AdjustFlagsAndWidth(whenClause);
            this.whenClause = whenClause;
        }
        this.AdjustFlagsAndWidth(equalsGreaterThanToken);
        this.equalsGreaterThanToken = equalsGreaterThanToken;
        this.AdjustFlagsAndWidth(expression);
        this.expression = expression;
    }

    public PatternSyntax Pattern => this.pattern;
    public WhenClauseSyntax? WhenClause => this.whenClause;
    public SyntaxToken EqualsGreaterThanToken => this.equalsGreaterThanToken;
    public ExpressionSyntax Expression => this.expression;

    internal override GreenNode? GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.pattern;
            case 1: return this.whenClause;
            case 2: return this.equalsGreaterThanToken;
            case 3: return this.expression;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new CSharp.Syntax.SwitchExpressionArmSyntax(this, parent, position);

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor) => visitor.VisitSwitchExpressionArm(this);

    public override void Accept(CSharpSyntaxVisitor visitor) => visitor.VisitSwitchExpressionArm(this);

    public SwitchExpressionArmSyntax Update(PatternSyntax pattern, WhenClauseSyntax whenClause, SyntaxToken equalsGreaterThanToken, ExpressionSyntax expression)
    {
        if (pattern != this.Pattern || whenClause != this.WhenClause || equalsGreaterThanToken != this.EqualsGreaterThanToken || expression != this.Expression)
        {
            var newNode = SyntaxFactory.SwitchExpressionArm(pattern, whenClause, equalsGreaterThanToken, expression);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
        => new SwitchExpressionArmSyntax(this.Kind, this.pattern, this.whenClause, this.equalsGreaterThanToken, this.expression, diagnostics, GetAnnotations());

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
        => new SwitchExpressionArmSyntax(this.Kind, this.pattern, this.whenClause, this.equalsGreaterThanToken, this.expression, GetDiagnostics(), annotations);

    internal SwitchExpressionArmSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 4;
      var pattern = (PatternSyntax)reader.ReadValue();
      if (pattern != null)
      {
         AdjustFlagsAndWidth(pattern);
         this.pattern = pattern;
      }
      var whenClause = (WhenClauseSyntax?)reader.ReadValue();
      if (whenClause != null)
      {
         AdjustFlagsAndWidth(whenClause);
         this.whenClause = whenClause;
      }
      var equalsGreaterThanToken = (SyntaxToken)reader.ReadValue();
      if (equalsGreaterThanToken != null)
      {
         AdjustFlagsAndWidth(equalsGreaterThanToken);
         this.equalsGreaterThanToken = equalsGreaterThanToken;
      }
      var expression = (ExpressionSyntax)reader.ReadValue();
      if (expression != null)
      {
         AdjustFlagsAndWidth(expression);
         this.expression = expression;
      }
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.pattern);
      writer.WriteValue(this.whenClause);
      writer.WriteValue(this.equalsGreaterThanToken);
      writer.WriteValue(this.expression);
    }

    static SwitchExpressionArmSyntax()
    {
       ObjectBinder.RegisterTypeReader(typeof(SwitchExpressionArmSyntax), r => new SwitchExpressionArmSyntax(r));
    }
  }

  internal sealed partial class TryStatementSyntax : StatementSyntax
  {
    internal readonly SyntaxToken tryKeyword;
    internal readonly BlockSyntax block;
    internal readonly GreenNode? catches;
    internal readonly FinallyClauseSyntax? @finally;

    internal TryStatementSyntax(SyntaxKind kind, SyntaxToken tryKeyword, BlockSyntax block, GreenNode? catches, FinallyClauseSyntax? @finally, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 4;
        this.AdjustFlagsAndWidth(tryKeyword);
        this.tryKeyword = tryKeyword;
        this.AdjustFlagsAndWidth(block);
        this.block = block;
        if (catches != null)
        {
            this.AdjustFlagsAndWidth(catches);
            this.catches = catches;
        }
        if (@finally != null)
        {
            this.AdjustFlagsAndWidth(@finally);
            this.@finally = @finally;
        }
    }


    internal TryStatementSyntax(SyntaxKind kind, SyntaxToken tryKeyword, BlockSyntax block, GreenNode? catches, FinallyClauseSyntax? @finally, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 4;
        this.AdjustFlagsAndWidth(tryKeyword);
        this.tryKeyword = tryKeyword;
        this.AdjustFlagsAndWidth(block);
        this.block = block;
        if (catches != null)
        {
            this.AdjustFlagsAndWidth(catches);
            this.catches = catches;
        }
        if (@finally != null)
        {
            this.AdjustFlagsAndWidth(@finally);
            this.@finally = @finally;
        }
    }


    internal TryStatementSyntax(SyntaxKind kind, SyntaxToken tryKeyword, BlockSyntax block, GreenNode? catches, FinallyClauseSyntax? @finally)
        : base(kind)
    {
        this.SlotCount = 4;
        this.AdjustFlagsAndWidth(tryKeyword);
        this.tryKeyword = tryKeyword;
        this.AdjustFlagsAndWidth(block);
        this.block = block;
        if (catches != null)
        {
            this.AdjustFlagsAndWidth(catches);
            this.catches = catches;
        }
        if (@finally != null)
        {
            this.AdjustFlagsAndWidth(@finally);
            this.@finally = @finally;
        }
    }

    public SyntaxToken TryKeyword => this.tryKeyword;
    public BlockSyntax Block => this.block;
    public Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<CatchClauseSyntax> Catches => new Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<CatchClauseSyntax>(this.catches);
    public FinallyClauseSyntax? Finally => this.@finally;

    internal override GreenNode? GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.tryKeyword;
            case 1: return this.block;
            case 2: return this.catches;
            case 3: return this.@finally;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new CSharp.Syntax.TryStatementSyntax(this, parent, position);

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor) => visitor.VisitTryStatement(this);

    public override void Accept(CSharpSyntaxVisitor visitor) => visitor.VisitTryStatement(this);

    public TryStatementSyntax Update(SyntaxToken tryKeyword, BlockSyntax block, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<CatchClauseSyntax> catches, FinallyClauseSyntax @finally)
    {
        if (tryKeyword != this.TryKeyword || block != this.Block || catches != this.Catches || @finally != this.Finally)
        {
            var newNode = SyntaxFactory.TryStatement(tryKeyword, block, catches, @finally);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
        => new TryStatementSyntax(this.Kind, this.tryKeyword, this.block, this.catches, this.@finally, diagnostics, GetAnnotations());

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
        => new TryStatementSyntax(this.Kind, this.tryKeyword, this.block, this.catches, this.@finally, GetDiagnostics(), annotations);

    internal TryStatementSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 4;
      var tryKeyword = (SyntaxToken)reader.ReadValue();
      if (tryKeyword != null)
      {
         AdjustFlagsAndWidth(tryKeyword);
         this.tryKeyword = tryKeyword;
      }
      var block = (BlockSyntax)reader.ReadValue();
      if (block != null)
      {
         AdjustFlagsAndWidth(block);
         this.block = block;
      }
      var catches = (GreenNode?)reader.ReadValue();
      if (catches != null)
      {
         AdjustFlagsAndWidth(catches);
         this.catches = catches;
      }
      var @finally = (FinallyClauseSyntax?)reader.ReadValue();
      if (@finally != null)
      {
         AdjustFlagsAndWidth(@finally);
         this.@finally = @finally;
      }
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.tryKeyword);
      writer.WriteValue(this.block);
      writer.WriteValue(this.catches);
      writer.WriteValue(this.@finally);
    }

    static TryStatementSyntax()
    {
       ObjectBinder.RegisterTypeReader(typeof(TryStatementSyntax), r => new TryStatementSyntax(r));
    }
  }

  internal sealed partial class CatchClauseSyntax : CSharpSyntaxNode
  {
    internal readonly SyntaxToken catchKeyword;
    internal readonly CatchDeclarationSyntax? declaration;
    internal readonly CatchFilterClauseSyntax? filter;
    internal readonly BlockSyntax block;

    internal CatchClauseSyntax(SyntaxKind kind, SyntaxToken catchKeyword, CatchDeclarationSyntax? declaration, CatchFilterClauseSyntax? filter, BlockSyntax block, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 4;
        this.AdjustFlagsAndWidth(catchKeyword);
        this.catchKeyword = catchKeyword;
        if (declaration != null)
        {
            this.AdjustFlagsAndWidth(declaration);
            this.declaration = declaration;
        }
        if (filter != null)
        {
            this.AdjustFlagsAndWidth(filter);
            this.filter = filter;
        }
        this.AdjustFlagsAndWidth(block);
        this.block = block;
    }


    internal CatchClauseSyntax(SyntaxKind kind, SyntaxToken catchKeyword, CatchDeclarationSyntax? declaration, CatchFilterClauseSyntax? filter, BlockSyntax block, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 4;
        this.AdjustFlagsAndWidth(catchKeyword);
        this.catchKeyword = catchKeyword;
        if (declaration != null)
        {
            this.AdjustFlagsAndWidth(declaration);
            this.declaration = declaration;
        }
        if (filter != null)
        {
            this.AdjustFlagsAndWidth(filter);
            this.filter = filter;
        }
        this.AdjustFlagsAndWidth(block);
        this.block = block;
    }


    internal CatchClauseSyntax(SyntaxKind kind, SyntaxToken catchKeyword, CatchDeclarationSyntax? declaration, CatchFilterClauseSyntax? filter, BlockSyntax block)
        : base(kind)
    {
        this.SlotCount = 4;
        this.AdjustFlagsAndWidth(catchKeyword);
        this.catchKeyword = catchKeyword;
        if (declaration != null)
        {
            this.AdjustFlagsAndWidth(declaration);
            this.declaration = declaration;
        }
        if (filter != null)
        {
            this.AdjustFlagsAndWidth(filter);
            this.filter = filter;
        }
        this.AdjustFlagsAndWidth(block);
        this.block = block;
    }

    public SyntaxToken CatchKeyword => this.catchKeyword;
    public CatchDeclarationSyntax? Declaration => this.declaration;
    public CatchFilterClauseSyntax? Filter => this.filter;
    public BlockSyntax Block => this.block;

    internal override GreenNode? GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.catchKeyword;
            case 1: return this.declaration;
            case 2: return this.filter;
            case 3: return this.block;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new CSharp.Syntax.CatchClauseSyntax(this, parent, position);

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor) => visitor.VisitCatchClause(this);

    public override void Accept(CSharpSyntaxVisitor visitor) => visitor.VisitCatchClause(this);

    public CatchClauseSyntax Update(SyntaxToken catchKeyword, CatchDeclarationSyntax declaration, CatchFilterClauseSyntax filter, BlockSyntax block)
    {
        if (catchKeyword != this.CatchKeyword || declaration != this.Declaration || filter != this.Filter || block != this.Block)
        {
            var newNode = SyntaxFactory.CatchClause(catchKeyword, declaration, filter, block);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
        => new CatchClauseSyntax(this.Kind, this.catchKeyword, this.declaration, this.filter, this.block, diagnostics, GetAnnotations());

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
        => new CatchClauseSyntax(this.Kind, this.catchKeyword, this.declaration, this.filter, this.block, GetDiagnostics(), annotations);

    internal CatchClauseSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 4;
      var catchKeyword = (SyntaxToken)reader.ReadValue();
      if (catchKeyword != null)
      {
         AdjustFlagsAndWidth(catchKeyword);
         this.catchKeyword = catchKeyword;
      }
      var declaration = (CatchDeclarationSyntax?)reader.ReadValue();
      if (declaration != null)
      {
         AdjustFlagsAndWidth(declaration);
         this.declaration = declaration;
      }
      var filter = (CatchFilterClauseSyntax?)reader.ReadValue();
      if (filter != null)
      {
         AdjustFlagsAndWidth(filter);
         this.filter = filter;
      }
      var block = (BlockSyntax)reader.ReadValue();
      if (block != null)
      {
         AdjustFlagsAndWidth(block);
         this.block = block;
      }
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.catchKeyword);
      writer.WriteValue(this.declaration);
      writer.WriteValue(this.filter);
      writer.WriteValue(this.block);
    }

    static CatchClauseSyntax()
    {
       ObjectBinder.RegisterTypeReader(typeof(CatchClauseSyntax), r => new CatchClauseSyntax(r));
    }
  }

  internal sealed partial class CatchDeclarationSyntax : CSharpSyntaxNode
  {
    internal readonly SyntaxToken openParenToken;
    internal readonly TypeSyntax type;
    internal readonly SyntaxToken? identifier;
    internal readonly SyntaxToken closeParenToken;

    internal CatchDeclarationSyntax(SyntaxKind kind, SyntaxToken openParenToken, TypeSyntax type, SyntaxToken? identifier, SyntaxToken closeParenToken, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 4;
        this.AdjustFlagsAndWidth(openParenToken);
        this.openParenToken = openParenToken;
        this.AdjustFlagsAndWidth(type);
        this.type = type;
        if (identifier != null)
        {
            this.AdjustFlagsAndWidth(identifier);
            this.identifier = identifier;
        }
        this.AdjustFlagsAndWidth(closeParenToken);
        this.closeParenToken = closeParenToken;
    }


    internal CatchDeclarationSyntax(SyntaxKind kind, SyntaxToken openParenToken, TypeSyntax type, SyntaxToken? identifier, SyntaxToken closeParenToken, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 4;
        this.AdjustFlagsAndWidth(openParenToken);
        this.openParenToken = openParenToken;
        this.AdjustFlagsAndWidth(type);
        this.type = type;
        if (identifier != null)
        {
            this.AdjustFlagsAndWidth(identifier);
            this.identifier = identifier;
        }
        this.AdjustFlagsAndWidth(closeParenToken);
        this.closeParenToken = closeParenToken;
    }


    internal CatchDeclarationSyntax(SyntaxKind kind, SyntaxToken openParenToken, TypeSyntax type, SyntaxToken? identifier, SyntaxToken closeParenToken)
        : base(kind)
    {
        this.SlotCount = 4;
        this.AdjustFlagsAndWidth(openParenToken);
        this.openParenToken = openParenToken;
        this.AdjustFlagsAndWidth(type);
        this.type = type;
        if (identifier != null)
        {
            this.AdjustFlagsAndWidth(identifier);
            this.identifier = identifier;
        }
        this.AdjustFlagsAndWidth(closeParenToken);
        this.closeParenToken = closeParenToken;
    }

    public SyntaxToken OpenParenToken => this.openParenToken;
    public TypeSyntax Type => this.type;
    public SyntaxToken? Identifier => this.identifier;
    public SyntaxToken CloseParenToken => this.closeParenToken;

    internal override GreenNode? GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.openParenToken;
            case 1: return this.type;
            case 2: return this.identifier;
            case 3: return this.closeParenToken;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new CSharp.Syntax.CatchDeclarationSyntax(this, parent, position);

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor) => visitor.VisitCatchDeclaration(this);

    public override void Accept(CSharpSyntaxVisitor visitor) => visitor.VisitCatchDeclaration(this);

    public CatchDeclarationSyntax Update(SyntaxToken openParenToken, TypeSyntax type, SyntaxToken identifier, SyntaxToken closeParenToken)
    {
        if (openParenToken != this.OpenParenToken || type != this.Type || identifier != this.Identifier || closeParenToken != this.CloseParenToken)
        {
            var newNode = SyntaxFactory.CatchDeclaration(openParenToken, type, identifier, closeParenToken);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
        => new CatchDeclarationSyntax(this.Kind, this.openParenToken, this.type, this.identifier, this.closeParenToken, diagnostics, GetAnnotations());

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
        => new CatchDeclarationSyntax(this.Kind, this.openParenToken, this.type, this.identifier, this.closeParenToken, GetDiagnostics(), annotations);

    internal CatchDeclarationSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 4;
      var openParenToken = (SyntaxToken)reader.ReadValue();
      if (openParenToken != null)
      {
         AdjustFlagsAndWidth(openParenToken);
         this.openParenToken = openParenToken;
      }
      var type = (TypeSyntax)reader.ReadValue();
      if (type != null)
      {
         AdjustFlagsAndWidth(type);
         this.type = type;
      }
      var identifier = (SyntaxToken?)reader.ReadValue();
      if (identifier != null)
      {
         AdjustFlagsAndWidth(identifier);
         this.identifier = identifier;
      }
      var closeParenToken = (SyntaxToken)reader.ReadValue();
      if (closeParenToken != null)
      {
         AdjustFlagsAndWidth(closeParenToken);
         this.closeParenToken = closeParenToken;
      }
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.openParenToken);
      writer.WriteValue(this.type);
      writer.WriteValue(this.identifier);
      writer.WriteValue(this.closeParenToken);
    }

    static CatchDeclarationSyntax()
    {
       ObjectBinder.RegisterTypeReader(typeof(CatchDeclarationSyntax), r => new CatchDeclarationSyntax(r));
    }
  }

  internal sealed partial class CatchFilterClauseSyntax : CSharpSyntaxNode
  {
    internal readonly SyntaxToken whenKeyword;
    internal readonly SyntaxToken openParenToken;
    internal readonly ExpressionSyntax filterExpression;
    internal readonly SyntaxToken closeParenToken;

    internal CatchFilterClauseSyntax(SyntaxKind kind, SyntaxToken whenKeyword, SyntaxToken openParenToken, ExpressionSyntax filterExpression, SyntaxToken closeParenToken, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 4;
        this.AdjustFlagsAndWidth(whenKeyword);
        this.whenKeyword = whenKeyword;
        this.AdjustFlagsAndWidth(openParenToken);
        this.openParenToken = openParenToken;
        this.AdjustFlagsAndWidth(filterExpression);
        this.filterExpression = filterExpression;
        this.AdjustFlagsAndWidth(closeParenToken);
        this.closeParenToken = closeParenToken;
    }


    internal CatchFilterClauseSyntax(SyntaxKind kind, SyntaxToken whenKeyword, SyntaxToken openParenToken, ExpressionSyntax filterExpression, SyntaxToken closeParenToken, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 4;
        this.AdjustFlagsAndWidth(whenKeyword);
        this.whenKeyword = whenKeyword;
        this.AdjustFlagsAndWidth(openParenToken);
        this.openParenToken = openParenToken;
        this.AdjustFlagsAndWidth(filterExpression);
        this.filterExpression = filterExpression;
        this.AdjustFlagsAndWidth(closeParenToken);
        this.closeParenToken = closeParenToken;
    }


    internal CatchFilterClauseSyntax(SyntaxKind kind, SyntaxToken whenKeyword, SyntaxToken openParenToken, ExpressionSyntax filterExpression, SyntaxToken closeParenToken)
        : base(kind)
    {
        this.SlotCount = 4;
        this.AdjustFlagsAndWidth(whenKeyword);
        this.whenKeyword = whenKeyword;
        this.AdjustFlagsAndWidth(openParenToken);
        this.openParenToken = openParenToken;
        this.AdjustFlagsAndWidth(filterExpression);
        this.filterExpression = filterExpression;
        this.AdjustFlagsAndWidth(closeParenToken);
        this.closeParenToken = closeParenToken;
    }

    public SyntaxToken WhenKeyword => this.whenKeyword;
    public SyntaxToken OpenParenToken => this.openParenToken;
    public ExpressionSyntax FilterExpression => this.filterExpression;
    public SyntaxToken CloseParenToken => this.closeParenToken;

    internal override GreenNode? GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.whenKeyword;
            case 1: return this.openParenToken;
            case 2: return this.filterExpression;
            case 3: return this.closeParenToken;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new CSharp.Syntax.CatchFilterClauseSyntax(this, parent, position);

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor) => visitor.VisitCatchFilterClause(this);

    public override void Accept(CSharpSyntaxVisitor visitor) => visitor.VisitCatchFilterClause(this);

    public CatchFilterClauseSyntax Update(SyntaxToken whenKeyword, SyntaxToken openParenToken, ExpressionSyntax filterExpression, SyntaxToken closeParenToken)
    {
        if (whenKeyword != this.WhenKeyword || openParenToken != this.OpenParenToken || filterExpression != this.FilterExpression || closeParenToken != this.CloseParenToken)
        {
            var newNode = SyntaxFactory.CatchFilterClause(whenKeyword, openParenToken, filterExpression, closeParenToken);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
        => new CatchFilterClauseSyntax(this.Kind, this.whenKeyword, this.openParenToken, this.filterExpression, this.closeParenToken, diagnostics, GetAnnotations());

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
        => new CatchFilterClauseSyntax(this.Kind, this.whenKeyword, this.openParenToken, this.filterExpression, this.closeParenToken, GetDiagnostics(), annotations);

    internal CatchFilterClauseSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 4;
      var whenKeyword = (SyntaxToken)reader.ReadValue();
      if (whenKeyword != null)
      {
         AdjustFlagsAndWidth(whenKeyword);
         this.whenKeyword = whenKeyword;
      }
      var openParenToken = (SyntaxToken)reader.ReadValue();
      if (openParenToken != null)
      {
         AdjustFlagsAndWidth(openParenToken);
         this.openParenToken = openParenToken;
      }
      var filterExpression = (ExpressionSyntax)reader.ReadValue();
      if (filterExpression != null)
      {
         AdjustFlagsAndWidth(filterExpression);
         this.filterExpression = filterExpression;
      }
      var closeParenToken = (SyntaxToken)reader.ReadValue();
      if (closeParenToken != null)
      {
         AdjustFlagsAndWidth(closeParenToken);
         this.closeParenToken = closeParenToken;
      }
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.whenKeyword);
      writer.WriteValue(this.openParenToken);
      writer.WriteValue(this.filterExpression);
      writer.WriteValue(this.closeParenToken);
    }

    static CatchFilterClauseSyntax()
    {
       ObjectBinder.RegisterTypeReader(typeof(CatchFilterClauseSyntax), r => new CatchFilterClauseSyntax(r));
    }
  }

  internal sealed partial class FinallyClauseSyntax : CSharpSyntaxNode
  {
    internal readonly SyntaxToken finallyKeyword;
    internal readonly BlockSyntax block;

    internal FinallyClauseSyntax(SyntaxKind kind, SyntaxToken finallyKeyword, BlockSyntax block, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 2;
        this.AdjustFlagsAndWidth(finallyKeyword);
        this.finallyKeyword = finallyKeyword;
        this.AdjustFlagsAndWidth(block);
        this.block = block;
    }


    internal FinallyClauseSyntax(SyntaxKind kind, SyntaxToken finallyKeyword, BlockSyntax block, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 2;
        this.AdjustFlagsAndWidth(finallyKeyword);
        this.finallyKeyword = finallyKeyword;
        this.AdjustFlagsAndWidth(block);
        this.block = block;
    }


    internal FinallyClauseSyntax(SyntaxKind kind, SyntaxToken finallyKeyword, BlockSyntax block)
        : base(kind)
    {
        this.SlotCount = 2;
        this.AdjustFlagsAndWidth(finallyKeyword);
        this.finallyKeyword = finallyKeyword;
        this.AdjustFlagsAndWidth(block);
        this.block = block;
    }

    public SyntaxToken FinallyKeyword => this.finallyKeyword;
    public BlockSyntax Block => this.block;

    internal override GreenNode? GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.finallyKeyword;
            case 1: return this.block;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new CSharp.Syntax.FinallyClauseSyntax(this, parent, position);

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor) => visitor.VisitFinallyClause(this);

    public override void Accept(CSharpSyntaxVisitor visitor) => visitor.VisitFinallyClause(this);

    public FinallyClauseSyntax Update(SyntaxToken finallyKeyword, BlockSyntax block)
    {
        if (finallyKeyword != this.FinallyKeyword || block != this.Block)
        {
            var newNode = SyntaxFactory.FinallyClause(finallyKeyword, block);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
        => new FinallyClauseSyntax(this.Kind, this.finallyKeyword, this.block, diagnostics, GetAnnotations());

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
        => new FinallyClauseSyntax(this.Kind, this.finallyKeyword, this.block, GetDiagnostics(), annotations);

    internal FinallyClauseSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 2;
      var finallyKeyword = (SyntaxToken)reader.ReadValue();
      if (finallyKeyword != null)
      {
         AdjustFlagsAndWidth(finallyKeyword);
         this.finallyKeyword = finallyKeyword;
      }
      var block = (BlockSyntax)reader.ReadValue();
      if (block != null)
      {
         AdjustFlagsAndWidth(block);
         this.block = block;
      }
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.finallyKeyword);
      writer.WriteValue(this.block);
    }

    static FinallyClauseSyntax()
    {
       ObjectBinder.RegisterTypeReader(typeof(FinallyClauseSyntax), r => new FinallyClauseSyntax(r));
    }
  }

  internal sealed partial class CompilationUnitSyntax : CSharpSyntaxNode
  {
    internal readonly GreenNode? externs;
    internal readonly GreenNode? usings;
    internal readonly GreenNode? attributeLists;
    internal readonly GreenNode? members;
    internal readonly SyntaxToken endOfFileToken;

    internal CompilationUnitSyntax(SyntaxKind kind, GreenNode? externs, GreenNode? usings, GreenNode? attributeLists, GreenNode? members, SyntaxToken endOfFileToken, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 5;
        if (externs != null)
        {
            this.AdjustFlagsAndWidth(externs);
            this.externs = externs;
        }
        if (usings != null)
        {
            this.AdjustFlagsAndWidth(usings);
            this.usings = usings;
        }
        if (attributeLists != null)
        {
            this.AdjustFlagsAndWidth(attributeLists);
            this.attributeLists = attributeLists;
        }
        if (members != null)
        {
            this.AdjustFlagsAndWidth(members);
            this.members = members;
        }
        this.AdjustFlagsAndWidth(endOfFileToken);
        this.endOfFileToken = endOfFileToken;
    }


    internal CompilationUnitSyntax(SyntaxKind kind, GreenNode? externs, GreenNode? usings, GreenNode? attributeLists, GreenNode? members, SyntaxToken endOfFileToken, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 5;
        if (externs != null)
        {
            this.AdjustFlagsAndWidth(externs);
            this.externs = externs;
        }
        if (usings != null)
        {
            this.AdjustFlagsAndWidth(usings);
            this.usings = usings;
        }
        if (attributeLists != null)
        {
            this.AdjustFlagsAndWidth(attributeLists);
            this.attributeLists = attributeLists;
        }
        if (members != null)
        {
            this.AdjustFlagsAndWidth(members);
            this.members = members;
        }
        this.AdjustFlagsAndWidth(endOfFileToken);
        this.endOfFileToken = endOfFileToken;
    }


    internal CompilationUnitSyntax(SyntaxKind kind, GreenNode? externs, GreenNode? usings, GreenNode? attributeLists, GreenNode? members, SyntaxToken endOfFileToken)
        : base(kind)
    {
        this.SlotCount = 5;
        if (externs != null)
        {
            this.AdjustFlagsAndWidth(externs);
            this.externs = externs;
        }
        if (usings != null)
        {
            this.AdjustFlagsAndWidth(usings);
            this.usings = usings;
        }
        if (attributeLists != null)
        {
            this.AdjustFlagsAndWidth(attributeLists);
            this.attributeLists = attributeLists;
        }
        if (members != null)
        {
            this.AdjustFlagsAndWidth(members);
            this.members = members;
        }
        this.AdjustFlagsAndWidth(endOfFileToken);
        this.endOfFileToken = endOfFileToken;
    }

    public Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<ExternAliasDirectiveSyntax> Externs => new Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<ExternAliasDirectiveSyntax>(this.externs);
    public Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<UsingDirectiveSyntax> Usings => new Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<UsingDirectiveSyntax>(this.usings);
    /// <summary>Gets the attribute declaration list.</summary>
    public Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<AttributeListSyntax> AttributeLists => new Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<AttributeListSyntax>(this.attributeLists);
    public Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<MemberDeclarationSyntax> Members => new Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<MemberDeclarationSyntax>(this.members);
    public SyntaxToken EndOfFileToken => this.endOfFileToken;

    internal override GreenNode? GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.externs;
            case 1: return this.usings;
            case 2: return this.attributeLists;
            case 3: return this.members;
            case 4: return this.endOfFileToken;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new CSharp.Syntax.CompilationUnitSyntax(this, parent, position);

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor) => visitor.VisitCompilationUnit(this);

    public override void Accept(CSharpSyntaxVisitor visitor) => visitor.VisitCompilationUnit(this);

    public CompilationUnitSyntax Update(Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<ExternAliasDirectiveSyntax> externs, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<UsingDirectiveSyntax> usings, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<AttributeListSyntax> attributeLists, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<MemberDeclarationSyntax> members, SyntaxToken endOfFileToken)
    {
        if (externs != this.Externs || usings != this.Usings || attributeLists != this.AttributeLists || members != this.Members || endOfFileToken != this.EndOfFileToken)
        {
            var newNode = SyntaxFactory.CompilationUnit(externs, usings, attributeLists, members, endOfFileToken);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
        => new CompilationUnitSyntax(this.Kind, this.externs, this.usings, this.attributeLists, this.members, this.endOfFileToken, diagnostics, GetAnnotations());

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
        => new CompilationUnitSyntax(this.Kind, this.externs, this.usings, this.attributeLists, this.members, this.endOfFileToken, GetDiagnostics(), annotations);

    internal CompilationUnitSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 5;
      var externs = (GreenNode?)reader.ReadValue();
      if (externs != null)
      {
         AdjustFlagsAndWidth(externs);
         this.externs = externs;
      }
      var usings = (GreenNode?)reader.ReadValue();
      if (usings != null)
      {
         AdjustFlagsAndWidth(usings);
         this.usings = usings;
      }
      var attributeLists = (GreenNode?)reader.ReadValue();
      if (attributeLists != null)
      {
         AdjustFlagsAndWidth(attributeLists);
         this.attributeLists = attributeLists;
      }
      var members = (GreenNode?)reader.ReadValue();
      if (members != null)
      {
         AdjustFlagsAndWidth(members);
         this.members = members;
      }
      var endOfFileToken = (SyntaxToken)reader.ReadValue();
      if (endOfFileToken != null)
      {
         AdjustFlagsAndWidth(endOfFileToken);
         this.endOfFileToken = endOfFileToken;
      }
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.externs);
      writer.WriteValue(this.usings);
      writer.WriteValue(this.attributeLists);
      writer.WriteValue(this.members);
      writer.WriteValue(this.endOfFileToken);
    }

    static CompilationUnitSyntax()
    {
       ObjectBinder.RegisterTypeReader(typeof(CompilationUnitSyntax), r => new CompilationUnitSyntax(r));
    }
  }

  /// <summary>
  /// Represents an ExternAlias directive syntax, e.g. "extern alias MyAlias;" with specifying "/r:MyAlias=SomeAssembly.dll " on the compiler command line.
  /// </summary>
  internal sealed partial class ExternAliasDirectiveSyntax : CSharpSyntaxNode
  {
    internal readonly SyntaxToken externKeyword;
    internal readonly SyntaxToken aliasKeyword;
    internal readonly SyntaxToken identifier;
    internal readonly SyntaxToken semicolonToken;

    internal ExternAliasDirectiveSyntax(SyntaxKind kind, SyntaxToken externKeyword, SyntaxToken aliasKeyword, SyntaxToken identifier, SyntaxToken semicolonToken, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 4;
        this.AdjustFlagsAndWidth(externKeyword);
        this.externKeyword = externKeyword;
        this.AdjustFlagsAndWidth(aliasKeyword);
        this.aliasKeyword = aliasKeyword;
        this.AdjustFlagsAndWidth(identifier);
        this.identifier = identifier;
        this.AdjustFlagsAndWidth(semicolonToken);
        this.semicolonToken = semicolonToken;
    }


    internal ExternAliasDirectiveSyntax(SyntaxKind kind, SyntaxToken externKeyword, SyntaxToken aliasKeyword, SyntaxToken identifier, SyntaxToken semicolonToken, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 4;
        this.AdjustFlagsAndWidth(externKeyword);
        this.externKeyword = externKeyword;
        this.AdjustFlagsAndWidth(aliasKeyword);
        this.aliasKeyword = aliasKeyword;
        this.AdjustFlagsAndWidth(identifier);
        this.identifier = identifier;
        this.AdjustFlagsAndWidth(semicolonToken);
        this.semicolonToken = semicolonToken;
    }


    internal ExternAliasDirectiveSyntax(SyntaxKind kind, SyntaxToken externKeyword, SyntaxToken aliasKeyword, SyntaxToken identifier, SyntaxToken semicolonToken)
        : base(kind)
    {
        this.SlotCount = 4;
        this.AdjustFlagsAndWidth(externKeyword);
        this.externKeyword = externKeyword;
        this.AdjustFlagsAndWidth(aliasKeyword);
        this.aliasKeyword = aliasKeyword;
        this.AdjustFlagsAndWidth(identifier);
        this.identifier = identifier;
        this.AdjustFlagsAndWidth(semicolonToken);
        this.semicolonToken = semicolonToken;
    }

    /// <summary>SyntaxToken representing the extern keyword.</summary>
    public SyntaxToken ExternKeyword => this.externKeyword;
    /// <summary>SyntaxToken representing the alias keyword.</summary>
    public SyntaxToken AliasKeyword => this.aliasKeyword;
    /// <summary>Gets the identifier.</summary>
    public SyntaxToken Identifier => this.identifier;
    /// <summary>SyntaxToken representing the semicolon token.</summary>
    public SyntaxToken SemicolonToken => this.semicolonToken;

    internal override GreenNode? GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.externKeyword;
            case 1: return this.aliasKeyword;
            case 2: return this.identifier;
            case 3: return this.semicolonToken;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new CSharp.Syntax.ExternAliasDirectiveSyntax(this, parent, position);

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor) => visitor.VisitExternAliasDirective(this);

    public override void Accept(CSharpSyntaxVisitor visitor) => visitor.VisitExternAliasDirective(this);

    public ExternAliasDirectiveSyntax Update(SyntaxToken externKeyword, SyntaxToken aliasKeyword, SyntaxToken identifier, SyntaxToken semicolonToken)
    {
        if (externKeyword != this.ExternKeyword || aliasKeyword != this.AliasKeyword || identifier != this.Identifier || semicolonToken != this.SemicolonToken)
        {
            var newNode = SyntaxFactory.ExternAliasDirective(externKeyword, aliasKeyword, identifier, semicolonToken);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
        => new ExternAliasDirectiveSyntax(this.Kind, this.externKeyword, this.aliasKeyword, this.identifier, this.semicolonToken, diagnostics, GetAnnotations());

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
        => new ExternAliasDirectiveSyntax(this.Kind, this.externKeyword, this.aliasKeyword, this.identifier, this.semicolonToken, GetDiagnostics(), annotations);

    internal ExternAliasDirectiveSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 4;
      var externKeyword = (SyntaxToken)reader.ReadValue();
      if (externKeyword != null)
      {
         AdjustFlagsAndWidth(externKeyword);
         this.externKeyword = externKeyword;
      }
      var aliasKeyword = (SyntaxToken)reader.ReadValue();
      if (aliasKeyword != null)
      {
         AdjustFlagsAndWidth(aliasKeyword);
         this.aliasKeyword = aliasKeyword;
      }
      var identifier = (SyntaxToken)reader.ReadValue();
      if (identifier != null)
      {
         AdjustFlagsAndWidth(identifier);
         this.identifier = identifier;
      }
      var semicolonToken = (SyntaxToken)reader.ReadValue();
      if (semicolonToken != null)
      {
         AdjustFlagsAndWidth(semicolonToken);
         this.semicolonToken = semicolonToken;
      }
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.externKeyword);
      writer.WriteValue(this.aliasKeyword);
      writer.WriteValue(this.identifier);
      writer.WriteValue(this.semicolonToken);
    }

    static ExternAliasDirectiveSyntax()
    {
       ObjectBinder.RegisterTypeReader(typeof(ExternAliasDirectiveSyntax), r => new ExternAliasDirectiveSyntax(r));
    }
  }

  internal sealed partial class UsingDirectiveSyntax : CSharpSyntaxNode
  {
    internal readonly SyntaxToken usingKeyword;
    internal readonly SyntaxToken? staticKeyword;
    internal readonly NameEqualsSyntax? alias;
    internal readonly NameSyntax name;
    internal readonly SyntaxToken semicolonToken;

    internal UsingDirectiveSyntax(SyntaxKind kind, SyntaxToken usingKeyword, SyntaxToken? staticKeyword, NameEqualsSyntax? alias, NameSyntax name, SyntaxToken semicolonToken, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 5;
        this.AdjustFlagsAndWidth(usingKeyword);
        this.usingKeyword = usingKeyword;
        if (staticKeyword != null)
        {
            this.AdjustFlagsAndWidth(staticKeyword);
            this.staticKeyword = staticKeyword;
        }
        if (alias != null)
        {
            this.AdjustFlagsAndWidth(alias);
            this.alias = alias;
        }
        this.AdjustFlagsAndWidth(name);
        this.name = name;
        this.AdjustFlagsAndWidth(semicolonToken);
        this.semicolonToken = semicolonToken;
    }


    internal UsingDirectiveSyntax(SyntaxKind kind, SyntaxToken usingKeyword, SyntaxToken? staticKeyword, NameEqualsSyntax? alias, NameSyntax name, SyntaxToken semicolonToken, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 5;
        this.AdjustFlagsAndWidth(usingKeyword);
        this.usingKeyword = usingKeyword;
        if (staticKeyword != null)
        {
            this.AdjustFlagsAndWidth(staticKeyword);
            this.staticKeyword = staticKeyword;
        }
        if (alias != null)
        {
            this.AdjustFlagsAndWidth(alias);
            this.alias = alias;
        }
        this.AdjustFlagsAndWidth(name);
        this.name = name;
        this.AdjustFlagsAndWidth(semicolonToken);
        this.semicolonToken = semicolonToken;
    }


    internal UsingDirectiveSyntax(SyntaxKind kind, SyntaxToken usingKeyword, SyntaxToken? staticKeyword, NameEqualsSyntax? alias, NameSyntax name, SyntaxToken semicolonToken)
        : base(kind)
    {
        this.SlotCount = 5;
        this.AdjustFlagsAndWidth(usingKeyword);
        this.usingKeyword = usingKeyword;
        if (staticKeyword != null)
        {
            this.AdjustFlagsAndWidth(staticKeyword);
            this.staticKeyword = staticKeyword;
        }
        if (alias != null)
        {
            this.AdjustFlagsAndWidth(alias);
            this.alias = alias;
        }
        this.AdjustFlagsAndWidth(name);
        this.name = name;
        this.AdjustFlagsAndWidth(semicolonToken);
        this.semicolonToken = semicolonToken;
    }

    public SyntaxToken UsingKeyword => this.usingKeyword;
    public SyntaxToken? StaticKeyword => this.staticKeyword;
    public NameEqualsSyntax? Alias => this.alias;
    public NameSyntax Name => this.name;
    public SyntaxToken SemicolonToken => this.semicolonToken;

    internal override GreenNode? GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.usingKeyword;
            case 1: return this.staticKeyword;
            case 2: return this.alias;
            case 3: return this.name;
            case 4: return this.semicolonToken;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new CSharp.Syntax.UsingDirectiveSyntax(this, parent, position);

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor) => visitor.VisitUsingDirective(this);

    public override void Accept(CSharpSyntaxVisitor visitor) => visitor.VisitUsingDirective(this);

    public UsingDirectiveSyntax Update(SyntaxToken usingKeyword, SyntaxToken staticKeyword, NameEqualsSyntax alias, NameSyntax name, SyntaxToken semicolonToken)
    {
        if (usingKeyword != this.UsingKeyword || staticKeyword != this.StaticKeyword || alias != this.Alias || name != this.Name || semicolonToken != this.SemicolonToken)
        {
            var newNode = SyntaxFactory.UsingDirective(usingKeyword, staticKeyword, alias, name, semicolonToken);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
        => new UsingDirectiveSyntax(this.Kind, this.usingKeyword, this.staticKeyword, this.alias, this.name, this.semicolonToken, diagnostics, GetAnnotations());

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
        => new UsingDirectiveSyntax(this.Kind, this.usingKeyword, this.staticKeyword, this.alias, this.name, this.semicolonToken, GetDiagnostics(), annotations);

    internal UsingDirectiveSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 5;
      var usingKeyword = (SyntaxToken)reader.ReadValue();
      if (usingKeyword != null)
      {
         AdjustFlagsAndWidth(usingKeyword);
         this.usingKeyword = usingKeyword;
      }
      var staticKeyword = (SyntaxToken?)reader.ReadValue();
      if (staticKeyword != null)
      {
         AdjustFlagsAndWidth(staticKeyword);
         this.staticKeyword = staticKeyword;
      }
      var alias = (NameEqualsSyntax?)reader.ReadValue();
      if (alias != null)
      {
         AdjustFlagsAndWidth(alias);
         this.alias = alias;
      }
      var name = (NameSyntax)reader.ReadValue();
      if (name != null)
      {
         AdjustFlagsAndWidth(name);
         this.name = name;
      }
      var semicolonToken = (SyntaxToken)reader.ReadValue();
      if (semicolonToken != null)
      {
         AdjustFlagsAndWidth(semicolonToken);
         this.semicolonToken = semicolonToken;
      }
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.usingKeyword);
      writer.WriteValue(this.staticKeyword);
      writer.WriteValue(this.alias);
      writer.WriteValue(this.name);
      writer.WriteValue(this.semicolonToken);
    }

    static UsingDirectiveSyntax()
    {
       ObjectBinder.RegisterTypeReader(typeof(UsingDirectiveSyntax), r => new UsingDirectiveSyntax(r));
    }
  }

  /// <summary>Member declaration syntax.</summary>
  internal abstract partial class MemberDeclarationSyntax : CSharpSyntaxNode
  {
    internal MemberDeclarationSyntax(SyntaxKind kind, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
      : base(kind, diagnostics, annotations)
    {
    }
    internal MemberDeclarationSyntax(SyntaxKind kind)
      : base(kind)
    {
    }

    protected MemberDeclarationSyntax(ObjectReader reader)
       : base(reader)
    {
    }

    /// <summary>Gets the attribute declaration list.</summary>
    public abstract Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<AttributeListSyntax> AttributeLists { get; }

    /// <summary>Gets the modifier list.</summary>
    public abstract Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SyntaxToken> Modifiers { get; }
  }

  internal sealed partial class NamespaceDeclarationSyntax : MemberDeclarationSyntax
  {
    internal readonly GreenNode? attributeLists;
    internal readonly GreenNode? modifiers;
    internal readonly SyntaxToken namespaceKeyword;
    internal readonly NameSyntax name;
    internal readonly SyntaxToken openBraceToken;
    internal readonly GreenNode? externs;
    internal readonly GreenNode? usings;
    internal readonly GreenNode? members;
    internal readonly SyntaxToken closeBraceToken;
    internal readonly SyntaxToken? semicolonToken;

    internal NamespaceDeclarationSyntax(SyntaxKind kind, GreenNode? attributeLists, GreenNode? modifiers, SyntaxToken namespaceKeyword, NameSyntax name, SyntaxToken openBraceToken, GreenNode? externs, GreenNode? usings, GreenNode? members, SyntaxToken closeBraceToken, SyntaxToken? semicolonToken, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 10;
        if (attributeLists != null)
        {
            this.AdjustFlagsAndWidth(attributeLists);
            this.attributeLists = attributeLists;
        }
        if (modifiers != null)
        {
            this.AdjustFlagsAndWidth(modifiers);
            this.modifiers = modifiers;
        }
        this.AdjustFlagsAndWidth(namespaceKeyword);
        this.namespaceKeyword = namespaceKeyword;
        this.AdjustFlagsAndWidth(name);
        this.name = name;
        this.AdjustFlagsAndWidth(openBraceToken);
        this.openBraceToken = openBraceToken;
        if (externs != null)
        {
            this.AdjustFlagsAndWidth(externs);
            this.externs = externs;
        }
        if (usings != null)
        {
            this.AdjustFlagsAndWidth(usings);
            this.usings = usings;
        }
        if (members != null)
        {
            this.AdjustFlagsAndWidth(members);
            this.members = members;
        }
        this.AdjustFlagsAndWidth(closeBraceToken);
        this.closeBraceToken = closeBraceToken;
        if (semicolonToken != null)
        {
            this.AdjustFlagsAndWidth(semicolonToken);
            this.semicolonToken = semicolonToken;
        }
    }


    internal NamespaceDeclarationSyntax(SyntaxKind kind, GreenNode? attributeLists, GreenNode? modifiers, SyntaxToken namespaceKeyword, NameSyntax name, SyntaxToken openBraceToken, GreenNode? externs, GreenNode? usings, GreenNode? members, SyntaxToken closeBraceToken, SyntaxToken? semicolonToken, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 10;
        if (attributeLists != null)
        {
            this.AdjustFlagsAndWidth(attributeLists);
            this.attributeLists = attributeLists;
        }
        if (modifiers != null)
        {
            this.AdjustFlagsAndWidth(modifiers);
            this.modifiers = modifiers;
        }
        this.AdjustFlagsAndWidth(namespaceKeyword);
        this.namespaceKeyword = namespaceKeyword;
        this.AdjustFlagsAndWidth(name);
        this.name = name;
        this.AdjustFlagsAndWidth(openBraceToken);
        this.openBraceToken = openBraceToken;
        if (externs != null)
        {
            this.AdjustFlagsAndWidth(externs);
            this.externs = externs;
        }
        if (usings != null)
        {
            this.AdjustFlagsAndWidth(usings);
            this.usings = usings;
        }
        if (members != null)
        {
            this.AdjustFlagsAndWidth(members);
            this.members = members;
        }
        this.AdjustFlagsAndWidth(closeBraceToken);
        this.closeBraceToken = closeBraceToken;
        if (semicolonToken != null)
        {
            this.AdjustFlagsAndWidth(semicolonToken);
            this.semicolonToken = semicolonToken;
        }
    }


    internal NamespaceDeclarationSyntax(SyntaxKind kind, GreenNode? attributeLists, GreenNode? modifiers, SyntaxToken namespaceKeyword, NameSyntax name, SyntaxToken openBraceToken, GreenNode? externs, GreenNode? usings, GreenNode? members, SyntaxToken closeBraceToken, SyntaxToken? semicolonToken)
        : base(kind)
    {
        this.SlotCount = 10;
        if (attributeLists != null)
        {
            this.AdjustFlagsAndWidth(attributeLists);
            this.attributeLists = attributeLists;
        }
        if (modifiers != null)
        {
            this.AdjustFlagsAndWidth(modifiers);
            this.modifiers = modifiers;
        }
        this.AdjustFlagsAndWidth(namespaceKeyword);
        this.namespaceKeyword = namespaceKeyword;
        this.AdjustFlagsAndWidth(name);
        this.name = name;
        this.AdjustFlagsAndWidth(openBraceToken);
        this.openBraceToken = openBraceToken;
        if (externs != null)
        {
            this.AdjustFlagsAndWidth(externs);
            this.externs = externs;
        }
        if (usings != null)
        {
            this.AdjustFlagsAndWidth(usings);
            this.usings = usings;
        }
        if (members != null)
        {
            this.AdjustFlagsAndWidth(members);
            this.members = members;
        }
        this.AdjustFlagsAndWidth(closeBraceToken);
        this.closeBraceToken = closeBraceToken;
        if (semicolonToken != null)
        {
            this.AdjustFlagsAndWidth(semicolonToken);
            this.semicolonToken = semicolonToken;
        }
    }

    public override Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<AttributeListSyntax> AttributeLists => new Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<AttributeListSyntax>(this.attributeLists);
    public override Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SyntaxToken> Modifiers => new Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SyntaxToken>(this.modifiers);
    public SyntaxToken NamespaceKeyword => this.namespaceKeyword;
    public NameSyntax Name => this.name;
    public SyntaxToken OpenBraceToken => this.openBraceToken;
    public Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<ExternAliasDirectiveSyntax> Externs => new Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<ExternAliasDirectiveSyntax>(this.externs);
    public Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<UsingDirectiveSyntax> Usings => new Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<UsingDirectiveSyntax>(this.usings);
    public Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<MemberDeclarationSyntax> Members => new Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<MemberDeclarationSyntax>(this.members);
    public SyntaxToken CloseBraceToken => this.closeBraceToken;
    /// <summary>Gets the optional semicolon token.</summary>
    public SyntaxToken? SemicolonToken => this.semicolonToken;

    internal override GreenNode? GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.attributeLists;
            case 1: return this.modifiers;
            case 2: return this.namespaceKeyword;
            case 3: return this.name;
            case 4: return this.openBraceToken;
            case 5: return this.externs;
            case 6: return this.usings;
            case 7: return this.members;
            case 8: return this.closeBraceToken;
            case 9: return this.semicolonToken;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new CSharp.Syntax.NamespaceDeclarationSyntax(this, parent, position);

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor) => visitor.VisitNamespaceDeclaration(this);

    public override void Accept(CSharpSyntaxVisitor visitor) => visitor.VisitNamespaceDeclaration(this);

    public NamespaceDeclarationSyntax Update(Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<AttributeListSyntax> attributeLists, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SyntaxToken> modifiers, SyntaxToken namespaceKeyword, NameSyntax name, SyntaxToken openBraceToken, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<ExternAliasDirectiveSyntax> externs, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<UsingDirectiveSyntax> usings, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<MemberDeclarationSyntax> members, SyntaxToken closeBraceToken, SyntaxToken semicolonToken)
    {
        if (attributeLists != this.AttributeLists || modifiers != this.Modifiers || namespaceKeyword != this.NamespaceKeyword || name != this.Name || openBraceToken != this.OpenBraceToken || externs != this.Externs || usings != this.Usings || members != this.Members || closeBraceToken != this.CloseBraceToken || semicolonToken != this.SemicolonToken)
        {
            var newNode = SyntaxFactory.NamespaceDeclaration(attributeLists, modifiers, namespaceKeyword, name, openBraceToken, externs, usings, members, closeBraceToken, semicolonToken);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
        => new NamespaceDeclarationSyntax(this.Kind, this.attributeLists, this.modifiers, this.namespaceKeyword, this.name, this.openBraceToken, this.externs, this.usings, this.members, this.closeBraceToken, this.semicolonToken, diagnostics, GetAnnotations());

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
        => new NamespaceDeclarationSyntax(this.Kind, this.attributeLists, this.modifiers, this.namespaceKeyword, this.name, this.openBraceToken, this.externs, this.usings, this.members, this.closeBraceToken, this.semicolonToken, GetDiagnostics(), annotations);

    internal NamespaceDeclarationSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 10;
      var attributeLists = (GreenNode?)reader.ReadValue();
      if (attributeLists != null)
      {
         AdjustFlagsAndWidth(attributeLists);
         this.attributeLists = attributeLists;
      }
      var modifiers = (GreenNode?)reader.ReadValue();
      if (modifiers != null)
      {
         AdjustFlagsAndWidth(modifiers);
         this.modifiers = modifiers;
      }
      var namespaceKeyword = (SyntaxToken)reader.ReadValue();
      if (namespaceKeyword != null)
      {
         AdjustFlagsAndWidth(namespaceKeyword);
         this.namespaceKeyword = namespaceKeyword;
      }
      var name = (NameSyntax)reader.ReadValue();
      if (name != null)
      {
         AdjustFlagsAndWidth(name);
         this.name = name;
      }
      var openBraceToken = (SyntaxToken)reader.ReadValue();
      if (openBraceToken != null)
      {
         AdjustFlagsAndWidth(openBraceToken);
         this.openBraceToken = openBraceToken;
      }
      var externs = (GreenNode?)reader.ReadValue();
      if (externs != null)
      {
         AdjustFlagsAndWidth(externs);
         this.externs = externs;
      }
      var usings = (GreenNode?)reader.ReadValue();
      if (usings != null)
      {
         AdjustFlagsAndWidth(usings);
         this.usings = usings;
      }
      var members = (GreenNode?)reader.ReadValue();
      if (members != null)
      {
         AdjustFlagsAndWidth(members);
         this.members = members;
      }
      var closeBraceToken = (SyntaxToken)reader.ReadValue();
      if (closeBraceToken != null)
      {
         AdjustFlagsAndWidth(closeBraceToken);
         this.closeBraceToken = closeBraceToken;
      }
      var semicolonToken = (SyntaxToken?)reader.ReadValue();
      if (semicolonToken != null)
      {
         AdjustFlagsAndWidth(semicolonToken);
         this.semicolonToken = semicolonToken;
      }
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.attributeLists);
      writer.WriteValue(this.modifiers);
      writer.WriteValue(this.namespaceKeyword);
      writer.WriteValue(this.name);
      writer.WriteValue(this.openBraceToken);
      writer.WriteValue(this.externs);
      writer.WriteValue(this.usings);
      writer.WriteValue(this.members);
      writer.WriteValue(this.closeBraceToken);
      writer.WriteValue(this.semicolonToken);
    }

    static NamespaceDeclarationSyntax()
    {
       ObjectBinder.RegisterTypeReader(typeof(NamespaceDeclarationSyntax), r => new NamespaceDeclarationSyntax(r));
    }
  }

  /// <summary>Class representing one or more attributes applied to a language construct.</summary>
  internal sealed partial class AttributeListSyntax : CSharpSyntaxNode
  {
    internal readonly SyntaxToken openBracketToken;
    internal readonly AttributeTargetSpecifierSyntax? target;
    internal readonly GreenNode? attributes;
    internal readonly SyntaxToken closeBracketToken;

    internal AttributeListSyntax(SyntaxKind kind, SyntaxToken openBracketToken, AttributeTargetSpecifierSyntax? target, GreenNode? attributes, SyntaxToken closeBracketToken, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 4;
        this.AdjustFlagsAndWidth(openBracketToken);
        this.openBracketToken = openBracketToken;
        if (target != null)
        {
            this.AdjustFlagsAndWidth(target);
            this.target = target;
        }
        if (attributes != null)
        {
            this.AdjustFlagsAndWidth(attributes);
            this.attributes = attributes;
        }
        this.AdjustFlagsAndWidth(closeBracketToken);
        this.closeBracketToken = closeBracketToken;
    }


    internal AttributeListSyntax(SyntaxKind kind, SyntaxToken openBracketToken, AttributeTargetSpecifierSyntax? target, GreenNode? attributes, SyntaxToken closeBracketToken, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 4;
        this.AdjustFlagsAndWidth(openBracketToken);
        this.openBracketToken = openBracketToken;
        if (target != null)
        {
            this.AdjustFlagsAndWidth(target);
            this.target = target;
        }
        if (attributes != null)
        {
            this.AdjustFlagsAndWidth(attributes);
            this.attributes = attributes;
        }
        this.AdjustFlagsAndWidth(closeBracketToken);
        this.closeBracketToken = closeBracketToken;
    }


    internal AttributeListSyntax(SyntaxKind kind, SyntaxToken openBracketToken, AttributeTargetSpecifierSyntax? target, GreenNode? attributes, SyntaxToken closeBracketToken)
        : base(kind)
    {
        this.SlotCount = 4;
        this.AdjustFlagsAndWidth(openBracketToken);
        this.openBracketToken = openBracketToken;
        if (target != null)
        {
            this.AdjustFlagsAndWidth(target);
            this.target = target;
        }
        if (attributes != null)
        {
            this.AdjustFlagsAndWidth(attributes);
            this.attributes = attributes;
        }
        this.AdjustFlagsAndWidth(closeBracketToken);
        this.closeBracketToken = closeBracketToken;
    }

    /// <summary>Gets the open bracket token.</summary>
    public SyntaxToken OpenBracketToken => this.openBracketToken;
    /// <summary>Gets the optional construct targeted by the attribute.</summary>
    public AttributeTargetSpecifierSyntax? Target => this.target;
    /// <summary>Gets the attribute declaration list.</summary>
    public Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<AttributeSyntax> Attributes => new Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<AttributeSyntax>(new Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<CSharpSyntaxNode>(this.attributes));
    /// <summary>Gets the close bracket token.</summary>
    public SyntaxToken CloseBracketToken => this.closeBracketToken;

    internal override GreenNode? GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.openBracketToken;
            case 1: return this.target;
            case 2: return this.attributes;
            case 3: return this.closeBracketToken;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new CSharp.Syntax.AttributeListSyntax(this, parent, position);

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor) => visitor.VisitAttributeList(this);

    public override void Accept(CSharpSyntaxVisitor visitor) => visitor.VisitAttributeList(this);

    public AttributeListSyntax Update(SyntaxToken openBracketToken, AttributeTargetSpecifierSyntax target, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<AttributeSyntax> attributes, SyntaxToken closeBracketToken)
    {
        if (openBracketToken != this.OpenBracketToken || target != this.Target || attributes != this.Attributes || closeBracketToken != this.CloseBracketToken)
        {
            var newNode = SyntaxFactory.AttributeList(openBracketToken, target, attributes, closeBracketToken);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
        => new AttributeListSyntax(this.Kind, this.openBracketToken, this.target, this.attributes, this.closeBracketToken, diagnostics, GetAnnotations());

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
        => new AttributeListSyntax(this.Kind, this.openBracketToken, this.target, this.attributes, this.closeBracketToken, GetDiagnostics(), annotations);

    internal AttributeListSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 4;
      var openBracketToken = (SyntaxToken)reader.ReadValue();
      if (openBracketToken != null)
      {
         AdjustFlagsAndWidth(openBracketToken);
         this.openBracketToken = openBracketToken;
      }
      var target = (AttributeTargetSpecifierSyntax?)reader.ReadValue();
      if (target != null)
      {
         AdjustFlagsAndWidth(target);
         this.target = target;
      }
      var attributes = (GreenNode?)reader.ReadValue();
      if (attributes != null)
      {
         AdjustFlagsAndWidth(attributes);
         this.attributes = attributes;
      }
      var closeBracketToken = (SyntaxToken)reader.ReadValue();
      if (closeBracketToken != null)
      {
         AdjustFlagsAndWidth(closeBracketToken);
         this.closeBracketToken = closeBracketToken;
      }
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.openBracketToken);
      writer.WriteValue(this.target);
      writer.WriteValue(this.attributes);
      writer.WriteValue(this.closeBracketToken);
    }

    static AttributeListSyntax()
    {
       ObjectBinder.RegisterTypeReader(typeof(AttributeListSyntax), r => new AttributeListSyntax(r));
    }
  }

  /// <summary>Class representing what language construct an attribute targets.</summary>
  internal sealed partial class AttributeTargetSpecifierSyntax : CSharpSyntaxNode
  {
    internal readonly SyntaxToken identifier;
    internal readonly SyntaxToken colonToken;

    internal AttributeTargetSpecifierSyntax(SyntaxKind kind, SyntaxToken identifier, SyntaxToken colonToken, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 2;
        this.AdjustFlagsAndWidth(identifier);
        this.identifier = identifier;
        this.AdjustFlagsAndWidth(colonToken);
        this.colonToken = colonToken;
    }


    internal AttributeTargetSpecifierSyntax(SyntaxKind kind, SyntaxToken identifier, SyntaxToken colonToken, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 2;
        this.AdjustFlagsAndWidth(identifier);
        this.identifier = identifier;
        this.AdjustFlagsAndWidth(colonToken);
        this.colonToken = colonToken;
    }


    internal AttributeTargetSpecifierSyntax(SyntaxKind kind, SyntaxToken identifier, SyntaxToken colonToken)
        : base(kind)
    {
        this.SlotCount = 2;
        this.AdjustFlagsAndWidth(identifier);
        this.identifier = identifier;
        this.AdjustFlagsAndWidth(colonToken);
        this.colonToken = colonToken;
    }

    /// <summary>Gets the identifier.</summary>
    public SyntaxToken Identifier => this.identifier;
    /// <summary>Gets the colon token.</summary>
    public SyntaxToken ColonToken => this.colonToken;

    internal override GreenNode? GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.identifier;
            case 1: return this.colonToken;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new CSharp.Syntax.AttributeTargetSpecifierSyntax(this, parent, position);

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor) => visitor.VisitAttributeTargetSpecifier(this);

    public override void Accept(CSharpSyntaxVisitor visitor) => visitor.VisitAttributeTargetSpecifier(this);

    public AttributeTargetSpecifierSyntax Update(SyntaxToken identifier, SyntaxToken colonToken)
    {
        if (identifier != this.Identifier || colonToken != this.ColonToken)
        {
            var newNode = SyntaxFactory.AttributeTargetSpecifier(identifier, colonToken);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
        => new AttributeTargetSpecifierSyntax(this.Kind, this.identifier, this.colonToken, diagnostics, GetAnnotations());

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
        => new AttributeTargetSpecifierSyntax(this.Kind, this.identifier, this.colonToken, GetDiagnostics(), annotations);

    internal AttributeTargetSpecifierSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 2;
      var identifier = (SyntaxToken)reader.ReadValue();
      if (identifier != null)
      {
         AdjustFlagsAndWidth(identifier);
         this.identifier = identifier;
      }
      var colonToken = (SyntaxToken)reader.ReadValue();
      if (colonToken != null)
      {
         AdjustFlagsAndWidth(colonToken);
         this.colonToken = colonToken;
      }
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.identifier);
      writer.WriteValue(this.colonToken);
    }

    static AttributeTargetSpecifierSyntax()
    {
       ObjectBinder.RegisterTypeReader(typeof(AttributeTargetSpecifierSyntax), r => new AttributeTargetSpecifierSyntax(r));
    }
  }

  /// <summary>Attribute syntax.</summary>
  internal sealed partial class AttributeSyntax : CSharpSyntaxNode
  {
    internal readonly NameSyntax name;
    internal readonly AttributeArgumentListSyntax? argumentList;

    internal AttributeSyntax(SyntaxKind kind, NameSyntax name, AttributeArgumentListSyntax? argumentList, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 2;
        this.AdjustFlagsAndWidth(name);
        this.name = name;
        if (argumentList != null)
        {
            this.AdjustFlagsAndWidth(argumentList);
            this.argumentList = argumentList;
        }
    }


    internal AttributeSyntax(SyntaxKind kind, NameSyntax name, AttributeArgumentListSyntax? argumentList, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 2;
        this.AdjustFlagsAndWidth(name);
        this.name = name;
        if (argumentList != null)
        {
            this.AdjustFlagsAndWidth(argumentList);
            this.argumentList = argumentList;
        }
    }


    internal AttributeSyntax(SyntaxKind kind, NameSyntax name, AttributeArgumentListSyntax? argumentList)
        : base(kind)
    {
        this.SlotCount = 2;
        this.AdjustFlagsAndWidth(name);
        this.name = name;
        if (argumentList != null)
        {
            this.AdjustFlagsAndWidth(argumentList);
            this.argumentList = argumentList;
        }
    }

    /// <summary>Gets the name.</summary>
    public NameSyntax Name => this.name;
    public AttributeArgumentListSyntax? ArgumentList => this.argumentList;

    internal override GreenNode? GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.name;
            case 1: return this.argumentList;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new CSharp.Syntax.AttributeSyntax(this, parent, position);

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor) => visitor.VisitAttribute(this);

    public override void Accept(CSharpSyntaxVisitor visitor) => visitor.VisitAttribute(this);

    public AttributeSyntax Update(NameSyntax name, AttributeArgumentListSyntax argumentList)
    {
        if (name != this.Name || argumentList != this.ArgumentList)
        {
            var newNode = SyntaxFactory.Attribute(name, argumentList);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
        => new AttributeSyntax(this.Kind, this.name, this.argumentList, diagnostics, GetAnnotations());

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
        => new AttributeSyntax(this.Kind, this.name, this.argumentList, GetDiagnostics(), annotations);

    internal AttributeSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 2;
      var name = (NameSyntax)reader.ReadValue();
      if (name != null)
      {
         AdjustFlagsAndWidth(name);
         this.name = name;
      }
      var argumentList = (AttributeArgumentListSyntax?)reader.ReadValue();
      if (argumentList != null)
      {
         AdjustFlagsAndWidth(argumentList);
         this.argumentList = argumentList;
      }
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.name);
      writer.WriteValue(this.argumentList);
    }

    static AttributeSyntax()
    {
       ObjectBinder.RegisterTypeReader(typeof(AttributeSyntax), r => new AttributeSyntax(r));
    }
  }

  /// <summary>Attribute argument list syntax.</summary>
  internal sealed partial class AttributeArgumentListSyntax : CSharpSyntaxNode
  {
    internal readonly SyntaxToken openParenToken;
    internal readonly GreenNode? arguments;
    internal readonly SyntaxToken closeParenToken;

    internal AttributeArgumentListSyntax(SyntaxKind kind, SyntaxToken openParenToken, GreenNode? arguments, SyntaxToken closeParenToken, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 3;
        this.AdjustFlagsAndWidth(openParenToken);
        this.openParenToken = openParenToken;
        if (arguments != null)
        {
            this.AdjustFlagsAndWidth(arguments);
            this.arguments = arguments;
        }
        this.AdjustFlagsAndWidth(closeParenToken);
        this.closeParenToken = closeParenToken;
    }


    internal AttributeArgumentListSyntax(SyntaxKind kind, SyntaxToken openParenToken, GreenNode? arguments, SyntaxToken closeParenToken, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 3;
        this.AdjustFlagsAndWidth(openParenToken);
        this.openParenToken = openParenToken;
        if (arguments != null)
        {
            this.AdjustFlagsAndWidth(arguments);
            this.arguments = arguments;
        }
        this.AdjustFlagsAndWidth(closeParenToken);
        this.closeParenToken = closeParenToken;
    }


    internal AttributeArgumentListSyntax(SyntaxKind kind, SyntaxToken openParenToken, GreenNode? arguments, SyntaxToken closeParenToken)
        : base(kind)
    {
        this.SlotCount = 3;
        this.AdjustFlagsAndWidth(openParenToken);
        this.openParenToken = openParenToken;
        if (arguments != null)
        {
            this.AdjustFlagsAndWidth(arguments);
            this.arguments = arguments;
        }
        this.AdjustFlagsAndWidth(closeParenToken);
        this.closeParenToken = closeParenToken;
    }

    /// <summary>Gets the open paren token.</summary>
    public SyntaxToken OpenParenToken => this.openParenToken;
    /// <summary>Gets the arguments syntax list.</summary>
    public Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<AttributeArgumentSyntax> Arguments => new Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<AttributeArgumentSyntax>(new Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<CSharpSyntaxNode>(this.arguments));
    /// <summary>Gets the close paren token.</summary>
    public SyntaxToken CloseParenToken => this.closeParenToken;

    internal override GreenNode? GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.openParenToken;
            case 1: return this.arguments;
            case 2: return this.closeParenToken;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new CSharp.Syntax.AttributeArgumentListSyntax(this, parent, position);

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor) => visitor.VisitAttributeArgumentList(this);

    public override void Accept(CSharpSyntaxVisitor visitor) => visitor.VisitAttributeArgumentList(this);

    public AttributeArgumentListSyntax Update(SyntaxToken openParenToken, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<AttributeArgumentSyntax> arguments, SyntaxToken closeParenToken)
    {
        if (openParenToken != this.OpenParenToken || arguments != this.Arguments || closeParenToken != this.CloseParenToken)
        {
            var newNode = SyntaxFactory.AttributeArgumentList(openParenToken, arguments, closeParenToken);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
        => new AttributeArgumentListSyntax(this.Kind, this.openParenToken, this.arguments, this.closeParenToken, diagnostics, GetAnnotations());

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
        => new AttributeArgumentListSyntax(this.Kind, this.openParenToken, this.arguments, this.closeParenToken, GetDiagnostics(), annotations);

    internal AttributeArgumentListSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 3;
      var openParenToken = (SyntaxToken)reader.ReadValue();
      if (openParenToken != null)
      {
         AdjustFlagsAndWidth(openParenToken);
         this.openParenToken = openParenToken;
      }
      var arguments = (GreenNode?)reader.ReadValue();
      if (arguments != null)
      {
         AdjustFlagsAndWidth(arguments);
         this.arguments = arguments;
      }
      var closeParenToken = (SyntaxToken)reader.ReadValue();
      if (closeParenToken != null)
      {
         AdjustFlagsAndWidth(closeParenToken);
         this.closeParenToken = closeParenToken;
      }
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.openParenToken);
      writer.WriteValue(this.arguments);
      writer.WriteValue(this.closeParenToken);
    }

    static AttributeArgumentListSyntax()
    {
       ObjectBinder.RegisterTypeReader(typeof(AttributeArgumentListSyntax), r => new AttributeArgumentListSyntax(r));
    }
  }

  /// <summary>Attribute argument syntax.</summary>
  internal sealed partial class AttributeArgumentSyntax : CSharpSyntaxNode
  {
    internal readonly NameEqualsSyntax? nameEquals;
    internal readonly NameColonSyntax? nameColon;
    internal readonly ExpressionSyntax expression;

    internal AttributeArgumentSyntax(SyntaxKind kind, NameEqualsSyntax? nameEquals, NameColonSyntax? nameColon, ExpressionSyntax expression, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 3;
        if (nameEquals != null)
        {
            this.AdjustFlagsAndWidth(nameEquals);
            this.nameEquals = nameEquals;
        }
        if (nameColon != null)
        {
            this.AdjustFlagsAndWidth(nameColon);
            this.nameColon = nameColon;
        }
        this.AdjustFlagsAndWidth(expression);
        this.expression = expression;
    }


    internal AttributeArgumentSyntax(SyntaxKind kind, NameEqualsSyntax? nameEquals, NameColonSyntax? nameColon, ExpressionSyntax expression, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 3;
        if (nameEquals != null)
        {
            this.AdjustFlagsAndWidth(nameEquals);
            this.nameEquals = nameEquals;
        }
        if (nameColon != null)
        {
            this.AdjustFlagsAndWidth(nameColon);
            this.nameColon = nameColon;
        }
        this.AdjustFlagsAndWidth(expression);
        this.expression = expression;
    }


    internal AttributeArgumentSyntax(SyntaxKind kind, NameEqualsSyntax? nameEquals, NameColonSyntax? nameColon, ExpressionSyntax expression)
        : base(kind)
    {
        this.SlotCount = 3;
        if (nameEquals != null)
        {
            this.AdjustFlagsAndWidth(nameEquals);
            this.nameEquals = nameEquals;
        }
        if (nameColon != null)
        {
            this.AdjustFlagsAndWidth(nameColon);
            this.nameColon = nameColon;
        }
        this.AdjustFlagsAndWidth(expression);
        this.expression = expression;
    }

    public NameEqualsSyntax? NameEquals => this.nameEquals;
    public NameColonSyntax? NameColon => this.nameColon;
    /// <summary>Gets the expression.</summary>
    public ExpressionSyntax Expression => this.expression;

    internal override GreenNode? GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.nameEquals;
            case 1: return this.nameColon;
            case 2: return this.expression;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new CSharp.Syntax.AttributeArgumentSyntax(this, parent, position);

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor) => visitor.VisitAttributeArgument(this);

    public override void Accept(CSharpSyntaxVisitor visitor) => visitor.VisitAttributeArgument(this);

    public AttributeArgumentSyntax Update(NameEqualsSyntax nameEquals, NameColonSyntax nameColon, ExpressionSyntax expression)
    {
        if (nameEquals != this.NameEquals || nameColon != this.NameColon || expression != this.Expression)
        {
            var newNode = SyntaxFactory.AttributeArgument(nameEquals, nameColon, expression);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
        => new AttributeArgumentSyntax(this.Kind, this.nameEquals, this.nameColon, this.expression, diagnostics, GetAnnotations());

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
        => new AttributeArgumentSyntax(this.Kind, this.nameEquals, this.nameColon, this.expression, GetDiagnostics(), annotations);

    internal AttributeArgumentSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 3;
      var nameEquals = (NameEqualsSyntax?)reader.ReadValue();
      if (nameEquals != null)
      {
         AdjustFlagsAndWidth(nameEquals);
         this.nameEquals = nameEquals;
      }
      var nameColon = (NameColonSyntax?)reader.ReadValue();
      if (nameColon != null)
      {
         AdjustFlagsAndWidth(nameColon);
         this.nameColon = nameColon;
      }
      var expression = (ExpressionSyntax)reader.ReadValue();
      if (expression != null)
      {
         AdjustFlagsAndWidth(expression);
         this.expression = expression;
      }
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.nameEquals);
      writer.WriteValue(this.nameColon);
      writer.WriteValue(this.expression);
    }

    static AttributeArgumentSyntax()
    {
       ObjectBinder.RegisterTypeReader(typeof(AttributeArgumentSyntax), r => new AttributeArgumentSyntax(r));
    }
  }

  /// <summary>Class representing an identifier name followed by an equals token.</summary>
  internal sealed partial class NameEqualsSyntax : CSharpSyntaxNode
  {
    internal readonly IdentifierNameSyntax name;
    internal readonly SyntaxToken equalsToken;

    internal NameEqualsSyntax(SyntaxKind kind, IdentifierNameSyntax name, SyntaxToken equalsToken, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 2;
        this.AdjustFlagsAndWidth(name);
        this.name = name;
        this.AdjustFlagsAndWidth(equalsToken);
        this.equalsToken = equalsToken;
    }


    internal NameEqualsSyntax(SyntaxKind kind, IdentifierNameSyntax name, SyntaxToken equalsToken, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 2;
        this.AdjustFlagsAndWidth(name);
        this.name = name;
        this.AdjustFlagsAndWidth(equalsToken);
        this.equalsToken = equalsToken;
    }


    internal NameEqualsSyntax(SyntaxKind kind, IdentifierNameSyntax name, SyntaxToken equalsToken)
        : base(kind)
    {
        this.SlotCount = 2;
        this.AdjustFlagsAndWidth(name);
        this.name = name;
        this.AdjustFlagsAndWidth(equalsToken);
        this.equalsToken = equalsToken;
    }

    /// <summary>Gets the identifier name.</summary>
    public IdentifierNameSyntax Name => this.name;
    public SyntaxToken EqualsToken => this.equalsToken;

    internal override GreenNode? GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.name;
            case 1: return this.equalsToken;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new CSharp.Syntax.NameEqualsSyntax(this, parent, position);

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor) => visitor.VisitNameEquals(this);

    public override void Accept(CSharpSyntaxVisitor visitor) => visitor.VisitNameEquals(this);

    public NameEqualsSyntax Update(IdentifierNameSyntax name, SyntaxToken equalsToken)
    {
        if (name != this.Name || equalsToken != this.EqualsToken)
        {
            var newNode = SyntaxFactory.NameEquals(name, equalsToken);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
        => new NameEqualsSyntax(this.Kind, this.name, this.equalsToken, diagnostics, GetAnnotations());

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
        => new NameEqualsSyntax(this.Kind, this.name, this.equalsToken, GetDiagnostics(), annotations);

    internal NameEqualsSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 2;
      var name = (IdentifierNameSyntax)reader.ReadValue();
      if (name != null)
      {
         AdjustFlagsAndWidth(name);
         this.name = name;
      }
      var equalsToken = (SyntaxToken)reader.ReadValue();
      if (equalsToken != null)
      {
         AdjustFlagsAndWidth(equalsToken);
         this.equalsToken = equalsToken;
      }
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.name);
      writer.WriteValue(this.equalsToken);
    }

    static NameEqualsSyntax()
    {
       ObjectBinder.RegisterTypeReader(typeof(NameEqualsSyntax), r => new NameEqualsSyntax(r));
    }
  }

  /// <summary>Type parameter list syntax.</summary>
  internal sealed partial class TypeParameterListSyntax : CSharpSyntaxNode
  {
    internal readonly SyntaxToken lessThanToken;
    internal readonly GreenNode? parameters;
    internal readonly SyntaxToken greaterThanToken;

    internal TypeParameterListSyntax(SyntaxKind kind, SyntaxToken lessThanToken, GreenNode? parameters, SyntaxToken greaterThanToken, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 3;
        this.AdjustFlagsAndWidth(lessThanToken);
        this.lessThanToken = lessThanToken;
        if (parameters != null)
        {
            this.AdjustFlagsAndWidth(parameters);
            this.parameters = parameters;
        }
        this.AdjustFlagsAndWidth(greaterThanToken);
        this.greaterThanToken = greaterThanToken;
    }


    internal TypeParameterListSyntax(SyntaxKind kind, SyntaxToken lessThanToken, GreenNode? parameters, SyntaxToken greaterThanToken, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 3;
        this.AdjustFlagsAndWidth(lessThanToken);
        this.lessThanToken = lessThanToken;
        if (parameters != null)
        {
            this.AdjustFlagsAndWidth(parameters);
            this.parameters = parameters;
        }
        this.AdjustFlagsAndWidth(greaterThanToken);
        this.greaterThanToken = greaterThanToken;
    }


    internal TypeParameterListSyntax(SyntaxKind kind, SyntaxToken lessThanToken, GreenNode? parameters, SyntaxToken greaterThanToken)
        : base(kind)
    {
        this.SlotCount = 3;
        this.AdjustFlagsAndWidth(lessThanToken);
        this.lessThanToken = lessThanToken;
        if (parameters != null)
        {
            this.AdjustFlagsAndWidth(parameters);
            this.parameters = parameters;
        }
        this.AdjustFlagsAndWidth(greaterThanToken);
        this.greaterThanToken = greaterThanToken;
    }

    /// <summary>Gets the &lt; token.</summary>
    public SyntaxToken LessThanToken => this.lessThanToken;
    /// <summary>Gets the parameter list.</summary>
    public Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<TypeParameterSyntax> Parameters => new Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<TypeParameterSyntax>(new Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<CSharpSyntaxNode>(this.parameters));
    /// <summary>Gets the &gt; token.</summary>
    public SyntaxToken GreaterThanToken => this.greaterThanToken;

    internal override GreenNode? GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.lessThanToken;
            case 1: return this.parameters;
            case 2: return this.greaterThanToken;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new CSharp.Syntax.TypeParameterListSyntax(this, parent, position);

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor) => visitor.VisitTypeParameterList(this);

    public override void Accept(CSharpSyntaxVisitor visitor) => visitor.VisitTypeParameterList(this);

    public TypeParameterListSyntax Update(SyntaxToken lessThanToken, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<TypeParameterSyntax> parameters, SyntaxToken greaterThanToken)
    {
        if (lessThanToken != this.LessThanToken || parameters != this.Parameters || greaterThanToken != this.GreaterThanToken)
        {
            var newNode = SyntaxFactory.TypeParameterList(lessThanToken, parameters, greaterThanToken);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
        => new TypeParameterListSyntax(this.Kind, this.lessThanToken, this.parameters, this.greaterThanToken, diagnostics, GetAnnotations());

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
        => new TypeParameterListSyntax(this.Kind, this.lessThanToken, this.parameters, this.greaterThanToken, GetDiagnostics(), annotations);

    internal TypeParameterListSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 3;
      var lessThanToken = (SyntaxToken)reader.ReadValue();
      if (lessThanToken != null)
      {
         AdjustFlagsAndWidth(lessThanToken);
         this.lessThanToken = lessThanToken;
      }
      var parameters = (GreenNode?)reader.ReadValue();
      if (parameters != null)
      {
         AdjustFlagsAndWidth(parameters);
         this.parameters = parameters;
      }
      var greaterThanToken = (SyntaxToken)reader.ReadValue();
      if (greaterThanToken != null)
      {
         AdjustFlagsAndWidth(greaterThanToken);
         this.greaterThanToken = greaterThanToken;
      }
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.lessThanToken);
      writer.WriteValue(this.parameters);
      writer.WriteValue(this.greaterThanToken);
    }

    static TypeParameterListSyntax()
    {
       ObjectBinder.RegisterTypeReader(typeof(TypeParameterListSyntax), r => new TypeParameterListSyntax(r));
    }
  }

  /// <summary>Type parameter syntax.</summary>
  internal sealed partial class TypeParameterSyntax : CSharpSyntaxNode
  {
    internal readonly GreenNode? attributeLists;
    internal readonly SyntaxToken? varianceKeyword;
    internal readonly SyntaxToken identifier;

    internal TypeParameterSyntax(SyntaxKind kind, GreenNode? attributeLists, SyntaxToken? varianceKeyword, SyntaxToken identifier, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 3;
        if (attributeLists != null)
        {
            this.AdjustFlagsAndWidth(attributeLists);
            this.attributeLists = attributeLists;
        }
        if (varianceKeyword != null)
        {
            this.AdjustFlagsAndWidth(varianceKeyword);
            this.varianceKeyword = varianceKeyword;
        }
        this.AdjustFlagsAndWidth(identifier);
        this.identifier = identifier;
    }


    internal TypeParameterSyntax(SyntaxKind kind, GreenNode? attributeLists, SyntaxToken? varianceKeyword, SyntaxToken identifier, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 3;
        if (attributeLists != null)
        {
            this.AdjustFlagsAndWidth(attributeLists);
            this.attributeLists = attributeLists;
        }
        if (varianceKeyword != null)
        {
            this.AdjustFlagsAndWidth(varianceKeyword);
            this.varianceKeyword = varianceKeyword;
        }
        this.AdjustFlagsAndWidth(identifier);
        this.identifier = identifier;
    }


    internal TypeParameterSyntax(SyntaxKind kind, GreenNode? attributeLists, SyntaxToken? varianceKeyword, SyntaxToken identifier)
        : base(kind)
    {
        this.SlotCount = 3;
        if (attributeLists != null)
        {
            this.AdjustFlagsAndWidth(attributeLists);
            this.attributeLists = attributeLists;
        }
        if (varianceKeyword != null)
        {
            this.AdjustFlagsAndWidth(varianceKeyword);
            this.varianceKeyword = varianceKeyword;
        }
        this.AdjustFlagsAndWidth(identifier);
        this.identifier = identifier;
    }

    /// <summary>Gets the attribute declaration list.</summary>
    public Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<AttributeListSyntax> AttributeLists => new Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<AttributeListSyntax>(this.attributeLists);
    public SyntaxToken? VarianceKeyword => this.varianceKeyword;
    /// <summary>Gets the identifier.</summary>
    public SyntaxToken Identifier => this.identifier;

    internal override GreenNode? GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.attributeLists;
            case 1: return this.varianceKeyword;
            case 2: return this.identifier;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new CSharp.Syntax.TypeParameterSyntax(this, parent, position);

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor) => visitor.VisitTypeParameter(this);

    public override void Accept(CSharpSyntaxVisitor visitor) => visitor.VisitTypeParameter(this);

    public TypeParameterSyntax Update(Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<AttributeListSyntax> attributeLists, SyntaxToken varianceKeyword, SyntaxToken identifier)
    {
        if (attributeLists != this.AttributeLists || varianceKeyword != this.VarianceKeyword || identifier != this.Identifier)
        {
            var newNode = SyntaxFactory.TypeParameter(attributeLists, varianceKeyword, identifier);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
        => new TypeParameterSyntax(this.Kind, this.attributeLists, this.varianceKeyword, this.identifier, diagnostics, GetAnnotations());

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
        => new TypeParameterSyntax(this.Kind, this.attributeLists, this.varianceKeyword, this.identifier, GetDiagnostics(), annotations);

    internal TypeParameterSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 3;
      var attributeLists = (GreenNode?)reader.ReadValue();
      if (attributeLists != null)
      {
         AdjustFlagsAndWidth(attributeLists);
         this.attributeLists = attributeLists;
      }
      var varianceKeyword = (SyntaxToken?)reader.ReadValue();
      if (varianceKeyword != null)
      {
         AdjustFlagsAndWidth(varianceKeyword);
         this.varianceKeyword = varianceKeyword;
      }
      var identifier = (SyntaxToken)reader.ReadValue();
      if (identifier != null)
      {
         AdjustFlagsAndWidth(identifier);
         this.identifier = identifier;
      }
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.attributeLists);
      writer.WriteValue(this.varianceKeyword);
      writer.WriteValue(this.identifier);
    }

    static TypeParameterSyntax()
    {
       ObjectBinder.RegisterTypeReader(typeof(TypeParameterSyntax), r => new TypeParameterSyntax(r));
    }
  }

  /// <summary>Base class for type declaration syntax.</summary>
  internal abstract partial class BaseTypeDeclarationSyntax : MemberDeclarationSyntax
  {
    internal BaseTypeDeclarationSyntax(SyntaxKind kind, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
      : base(kind, diagnostics, annotations)
    {
    }
    internal BaseTypeDeclarationSyntax(SyntaxKind kind)
      : base(kind)
    {
    }

    protected BaseTypeDeclarationSyntax(ObjectReader reader)
       : base(reader)
    {
    }

    /// <summary>Gets the identifier.</summary>
    public abstract SyntaxToken Identifier { get; }

    /// <summary>Gets the base type list.</summary>
    public abstract BaseListSyntax? BaseList { get; }

    /// <summary>Gets the open brace token.</summary>
    public abstract SyntaxToken OpenBraceToken { get; }

    /// <summary>Gets the close brace token.</summary>
    public abstract SyntaxToken CloseBraceToken { get; }

    /// <summary>Gets the optional semicolon token.</summary>
    public abstract SyntaxToken? SemicolonToken { get; }
  }

  /// <summary>Base class for type declaration syntax (class, struct, interface).</summary>
  internal abstract partial class TypeDeclarationSyntax : BaseTypeDeclarationSyntax
  {
    internal TypeDeclarationSyntax(SyntaxKind kind, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
      : base(kind, diagnostics, annotations)
    {
    }
    internal TypeDeclarationSyntax(SyntaxKind kind)
      : base(kind)
    {
    }

    protected TypeDeclarationSyntax(ObjectReader reader)
       : base(reader)
    {
    }

    /// <summary>Gets the type keyword token ("class", "struct", "interface").</summary>
    public abstract SyntaxToken Keyword { get; }

    public abstract TypeParameterListSyntax? TypeParameterList { get; }

    /// <summary>Gets the type constraint list.</summary>
    public abstract Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<TypeParameterConstraintClauseSyntax> ConstraintClauses { get; }

    /// <summary>Gets the member declarations.</summary>
    public abstract Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<MemberDeclarationSyntax> Members { get; }
  }

  /// <summary>Class type declaration syntax.</summary>
  internal sealed partial class ClassDeclarationSyntax : TypeDeclarationSyntax
  {
    internal readonly GreenNode? attributeLists;
    internal readonly GreenNode? modifiers;
    internal readonly SyntaxToken keyword;
    internal readonly SyntaxToken identifier;
    internal readonly TypeParameterListSyntax? typeParameterList;
    internal readonly BaseListSyntax? baseList;
    internal readonly GreenNode? constraintClauses;
    internal readonly SyntaxToken openBraceToken;
    internal readonly GreenNode? members;
    internal readonly SyntaxToken closeBraceToken;
    internal readonly SyntaxToken? semicolonToken;

    internal ClassDeclarationSyntax(SyntaxKind kind, GreenNode? attributeLists, GreenNode? modifiers, SyntaxToken keyword, SyntaxToken identifier, TypeParameterListSyntax? typeParameterList, BaseListSyntax? baseList, GreenNode? constraintClauses, SyntaxToken openBraceToken, GreenNode? members, SyntaxToken closeBraceToken, SyntaxToken? semicolonToken, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 11;
        if (attributeLists != null)
        {
            this.AdjustFlagsAndWidth(attributeLists);
            this.attributeLists = attributeLists;
        }
        if (modifiers != null)
        {
            this.AdjustFlagsAndWidth(modifiers);
            this.modifiers = modifiers;
        }
        this.AdjustFlagsAndWidth(keyword);
        this.keyword = keyword;
        this.AdjustFlagsAndWidth(identifier);
        this.identifier = identifier;
        if (typeParameterList != null)
        {
            this.AdjustFlagsAndWidth(typeParameterList);
            this.typeParameterList = typeParameterList;
        }
        if (baseList != null)
        {
            this.AdjustFlagsAndWidth(baseList);
            this.baseList = baseList;
        }
        if (constraintClauses != null)
        {
            this.AdjustFlagsAndWidth(constraintClauses);
            this.constraintClauses = constraintClauses;
        }
        this.AdjustFlagsAndWidth(openBraceToken);
        this.openBraceToken = openBraceToken;
        if (members != null)
        {
            this.AdjustFlagsAndWidth(members);
            this.members = members;
        }
        this.AdjustFlagsAndWidth(closeBraceToken);
        this.closeBraceToken = closeBraceToken;
        if (semicolonToken != null)
        {
            this.AdjustFlagsAndWidth(semicolonToken);
            this.semicolonToken = semicolonToken;
        }
    }


    internal ClassDeclarationSyntax(SyntaxKind kind, GreenNode? attributeLists, GreenNode? modifiers, SyntaxToken keyword, SyntaxToken identifier, TypeParameterListSyntax? typeParameterList, BaseListSyntax? baseList, GreenNode? constraintClauses, SyntaxToken openBraceToken, GreenNode? members, SyntaxToken closeBraceToken, SyntaxToken? semicolonToken, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 11;
        if (attributeLists != null)
        {
            this.AdjustFlagsAndWidth(attributeLists);
            this.attributeLists = attributeLists;
        }
        if (modifiers != null)
        {
            this.AdjustFlagsAndWidth(modifiers);
            this.modifiers = modifiers;
        }
        this.AdjustFlagsAndWidth(keyword);
        this.keyword = keyword;
        this.AdjustFlagsAndWidth(identifier);
        this.identifier = identifier;
        if (typeParameterList != null)
        {
            this.AdjustFlagsAndWidth(typeParameterList);
            this.typeParameterList = typeParameterList;
        }
        if (baseList != null)
        {
            this.AdjustFlagsAndWidth(baseList);
            this.baseList = baseList;
        }
        if (constraintClauses != null)
        {
            this.AdjustFlagsAndWidth(constraintClauses);
            this.constraintClauses = constraintClauses;
        }
        this.AdjustFlagsAndWidth(openBraceToken);
        this.openBraceToken = openBraceToken;
        if (members != null)
        {
            this.AdjustFlagsAndWidth(members);
            this.members = members;
        }
        this.AdjustFlagsAndWidth(closeBraceToken);
        this.closeBraceToken = closeBraceToken;
        if (semicolonToken != null)
        {
            this.AdjustFlagsAndWidth(semicolonToken);
            this.semicolonToken = semicolonToken;
        }
    }


    internal ClassDeclarationSyntax(SyntaxKind kind, GreenNode? attributeLists, GreenNode? modifiers, SyntaxToken keyword, SyntaxToken identifier, TypeParameterListSyntax? typeParameterList, BaseListSyntax? baseList, GreenNode? constraintClauses, SyntaxToken openBraceToken, GreenNode? members, SyntaxToken closeBraceToken, SyntaxToken? semicolonToken)
        : base(kind)
    {
        this.SlotCount = 11;
        if (attributeLists != null)
        {
            this.AdjustFlagsAndWidth(attributeLists);
            this.attributeLists = attributeLists;
        }
        if (modifiers != null)
        {
            this.AdjustFlagsAndWidth(modifiers);
            this.modifiers = modifiers;
        }
        this.AdjustFlagsAndWidth(keyword);
        this.keyword = keyword;
        this.AdjustFlagsAndWidth(identifier);
        this.identifier = identifier;
        if (typeParameterList != null)
        {
            this.AdjustFlagsAndWidth(typeParameterList);
            this.typeParameterList = typeParameterList;
        }
        if (baseList != null)
        {
            this.AdjustFlagsAndWidth(baseList);
            this.baseList = baseList;
        }
        if (constraintClauses != null)
        {
            this.AdjustFlagsAndWidth(constraintClauses);
            this.constraintClauses = constraintClauses;
        }
        this.AdjustFlagsAndWidth(openBraceToken);
        this.openBraceToken = openBraceToken;
        if (members != null)
        {
            this.AdjustFlagsAndWidth(members);
            this.members = members;
        }
        this.AdjustFlagsAndWidth(closeBraceToken);
        this.closeBraceToken = closeBraceToken;
        if (semicolonToken != null)
        {
            this.AdjustFlagsAndWidth(semicolonToken);
            this.semicolonToken = semicolonToken;
        }
    }

    public override Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<AttributeListSyntax> AttributeLists => new Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<AttributeListSyntax>(this.attributeLists);
    public override Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SyntaxToken> Modifiers => new Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SyntaxToken>(this.modifiers);
    /// <summary>Gets the class keyword token.</summary>
    public override SyntaxToken Keyword => this.keyword;
    public override SyntaxToken Identifier => this.identifier;
    public override TypeParameterListSyntax? TypeParameterList => this.typeParameterList;
    public override BaseListSyntax? BaseList => this.baseList;
    public override Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<TypeParameterConstraintClauseSyntax> ConstraintClauses => new Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<TypeParameterConstraintClauseSyntax>(this.constraintClauses);
    public override SyntaxToken OpenBraceToken => this.openBraceToken;
    public override Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<MemberDeclarationSyntax> Members => new Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<MemberDeclarationSyntax>(this.members);
    public override SyntaxToken CloseBraceToken => this.closeBraceToken;
    public override SyntaxToken? SemicolonToken => this.semicolonToken;

    internal override GreenNode? GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.attributeLists;
            case 1: return this.modifiers;
            case 2: return this.keyword;
            case 3: return this.identifier;
            case 4: return this.typeParameterList;
            case 5: return this.baseList;
            case 6: return this.constraintClauses;
            case 7: return this.openBraceToken;
            case 8: return this.members;
            case 9: return this.closeBraceToken;
            case 10: return this.semicolonToken;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new CSharp.Syntax.ClassDeclarationSyntax(this, parent, position);

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor) => visitor.VisitClassDeclaration(this);

    public override void Accept(CSharpSyntaxVisitor visitor) => visitor.VisitClassDeclaration(this);

    public ClassDeclarationSyntax Update(Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<AttributeListSyntax> attributeLists, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SyntaxToken> modifiers, SyntaxToken keyword, SyntaxToken identifier, TypeParameterListSyntax typeParameterList, BaseListSyntax baseList, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<TypeParameterConstraintClauseSyntax> constraintClauses, SyntaxToken openBraceToken, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<MemberDeclarationSyntax> members, SyntaxToken closeBraceToken, SyntaxToken semicolonToken)
    {
        if (attributeLists != this.AttributeLists || modifiers != this.Modifiers || keyword != this.Keyword || identifier != this.Identifier || typeParameterList != this.TypeParameterList || baseList != this.BaseList || constraintClauses != this.ConstraintClauses || openBraceToken != this.OpenBraceToken || members != this.Members || closeBraceToken != this.CloseBraceToken || semicolonToken != this.SemicolonToken)
        {
            var newNode = SyntaxFactory.ClassDeclaration(attributeLists, modifiers, keyword, identifier, typeParameterList, baseList, constraintClauses, openBraceToken, members, closeBraceToken, semicolonToken);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
        => new ClassDeclarationSyntax(this.Kind, this.attributeLists, this.modifiers, this.keyword, this.identifier, this.typeParameterList, this.baseList, this.constraintClauses, this.openBraceToken, this.members, this.closeBraceToken, this.semicolonToken, diagnostics, GetAnnotations());

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
        => new ClassDeclarationSyntax(this.Kind, this.attributeLists, this.modifiers, this.keyword, this.identifier, this.typeParameterList, this.baseList, this.constraintClauses, this.openBraceToken, this.members, this.closeBraceToken, this.semicolonToken, GetDiagnostics(), annotations);

    internal ClassDeclarationSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 11;
      var attributeLists = (GreenNode?)reader.ReadValue();
      if (attributeLists != null)
      {
         AdjustFlagsAndWidth(attributeLists);
         this.attributeLists = attributeLists;
      }
      var modifiers = (GreenNode?)reader.ReadValue();
      if (modifiers != null)
      {
         AdjustFlagsAndWidth(modifiers);
         this.modifiers = modifiers;
      }
      var keyword = (SyntaxToken)reader.ReadValue();
      if (keyword != null)
      {
         AdjustFlagsAndWidth(keyword);
         this.keyword = keyword;
      }
      var identifier = (SyntaxToken)reader.ReadValue();
      if (identifier != null)
      {
         AdjustFlagsAndWidth(identifier);
         this.identifier = identifier;
      }
      var typeParameterList = (TypeParameterListSyntax?)reader.ReadValue();
      if (typeParameterList != null)
      {
         AdjustFlagsAndWidth(typeParameterList);
         this.typeParameterList = typeParameterList;
      }
      var baseList = (BaseListSyntax?)reader.ReadValue();
      if (baseList != null)
      {
         AdjustFlagsAndWidth(baseList);
         this.baseList = baseList;
      }
      var constraintClauses = (GreenNode?)reader.ReadValue();
      if (constraintClauses != null)
      {
         AdjustFlagsAndWidth(constraintClauses);
         this.constraintClauses = constraintClauses;
      }
      var openBraceToken = (SyntaxToken)reader.ReadValue();
      if (openBraceToken != null)
      {
         AdjustFlagsAndWidth(openBraceToken);
         this.openBraceToken = openBraceToken;
      }
      var members = (GreenNode?)reader.ReadValue();
      if (members != null)
      {
         AdjustFlagsAndWidth(members);
         this.members = members;
      }
      var closeBraceToken = (SyntaxToken)reader.ReadValue();
      if (closeBraceToken != null)
      {
         AdjustFlagsAndWidth(closeBraceToken);
         this.closeBraceToken = closeBraceToken;
      }
      var semicolonToken = (SyntaxToken?)reader.ReadValue();
      if (semicolonToken != null)
      {
         AdjustFlagsAndWidth(semicolonToken);
         this.semicolonToken = semicolonToken;
      }
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.attributeLists);
      writer.WriteValue(this.modifiers);
      writer.WriteValue(this.keyword);
      writer.WriteValue(this.identifier);
      writer.WriteValue(this.typeParameterList);
      writer.WriteValue(this.baseList);
      writer.WriteValue(this.constraintClauses);
      writer.WriteValue(this.openBraceToken);
      writer.WriteValue(this.members);
      writer.WriteValue(this.closeBraceToken);
      writer.WriteValue(this.semicolonToken);
    }

    static ClassDeclarationSyntax()
    {
       ObjectBinder.RegisterTypeReader(typeof(ClassDeclarationSyntax), r => new ClassDeclarationSyntax(r));
    }
  }

  /// <summary>Struct type declaration syntax.</summary>
  internal sealed partial class StructDeclarationSyntax : TypeDeclarationSyntax
  {
    internal readonly GreenNode? attributeLists;
    internal readonly GreenNode? modifiers;
    internal readonly SyntaxToken keyword;
    internal readonly SyntaxToken identifier;
    internal readonly TypeParameterListSyntax? typeParameterList;
    internal readonly BaseListSyntax? baseList;
    internal readonly GreenNode? constraintClauses;
    internal readonly SyntaxToken openBraceToken;
    internal readonly GreenNode? members;
    internal readonly SyntaxToken closeBraceToken;
    internal readonly SyntaxToken? semicolonToken;

    internal StructDeclarationSyntax(SyntaxKind kind, GreenNode? attributeLists, GreenNode? modifiers, SyntaxToken keyword, SyntaxToken identifier, TypeParameterListSyntax? typeParameterList, BaseListSyntax? baseList, GreenNode? constraintClauses, SyntaxToken openBraceToken, GreenNode? members, SyntaxToken closeBraceToken, SyntaxToken? semicolonToken, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 11;
        if (attributeLists != null)
        {
            this.AdjustFlagsAndWidth(attributeLists);
            this.attributeLists = attributeLists;
        }
        if (modifiers != null)
        {
            this.AdjustFlagsAndWidth(modifiers);
            this.modifiers = modifiers;
        }
        this.AdjustFlagsAndWidth(keyword);
        this.keyword = keyword;
        this.AdjustFlagsAndWidth(identifier);
        this.identifier = identifier;
        if (typeParameterList != null)
        {
            this.AdjustFlagsAndWidth(typeParameterList);
            this.typeParameterList = typeParameterList;
        }
        if (baseList != null)
        {
            this.AdjustFlagsAndWidth(baseList);
            this.baseList = baseList;
        }
        if (constraintClauses != null)
        {
            this.AdjustFlagsAndWidth(constraintClauses);
            this.constraintClauses = constraintClauses;
        }
        this.AdjustFlagsAndWidth(openBraceToken);
        this.openBraceToken = openBraceToken;
        if (members != null)
        {
            this.AdjustFlagsAndWidth(members);
            this.members = members;
        }
        this.AdjustFlagsAndWidth(closeBraceToken);
        this.closeBraceToken = closeBraceToken;
        if (semicolonToken != null)
        {
            this.AdjustFlagsAndWidth(semicolonToken);
            this.semicolonToken = semicolonToken;
        }
    }


    internal StructDeclarationSyntax(SyntaxKind kind, GreenNode? attributeLists, GreenNode? modifiers, SyntaxToken keyword, SyntaxToken identifier, TypeParameterListSyntax? typeParameterList, BaseListSyntax? baseList, GreenNode? constraintClauses, SyntaxToken openBraceToken, GreenNode? members, SyntaxToken closeBraceToken, SyntaxToken? semicolonToken, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 11;
        if (attributeLists != null)
        {
            this.AdjustFlagsAndWidth(attributeLists);
            this.attributeLists = attributeLists;
        }
        if (modifiers != null)
        {
            this.AdjustFlagsAndWidth(modifiers);
            this.modifiers = modifiers;
        }
        this.AdjustFlagsAndWidth(keyword);
        this.keyword = keyword;
        this.AdjustFlagsAndWidth(identifier);
        this.identifier = identifier;
        if (typeParameterList != null)
        {
            this.AdjustFlagsAndWidth(typeParameterList);
            this.typeParameterList = typeParameterList;
        }
        if (baseList != null)
        {
            this.AdjustFlagsAndWidth(baseList);
            this.baseList = baseList;
        }
        if (constraintClauses != null)
        {
            this.AdjustFlagsAndWidth(constraintClauses);
            this.constraintClauses = constraintClauses;
        }
        this.AdjustFlagsAndWidth(openBraceToken);
        this.openBraceToken = openBraceToken;
        if (members != null)
        {
            this.AdjustFlagsAndWidth(members);
            this.members = members;
        }
        this.AdjustFlagsAndWidth(closeBraceToken);
        this.closeBraceToken = closeBraceToken;
        if (semicolonToken != null)
        {
            this.AdjustFlagsAndWidth(semicolonToken);
            this.semicolonToken = semicolonToken;
        }
    }


    internal StructDeclarationSyntax(SyntaxKind kind, GreenNode? attributeLists, GreenNode? modifiers, SyntaxToken keyword, SyntaxToken identifier, TypeParameterListSyntax? typeParameterList, BaseListSyntax? baseList, GreenNode? constraintClauses, SyntaxToken openBraceToken, GreenNode? members, SyntaxToken closeBraceToken, SyntaxToken? semicolonToken)
        : base(kind)
    {
        this.SlotCount = 11;
        if (attributeLists != null)
        {
            this.AdjustFlagsAndWidth(attributeLists);
            this.attributeLists = attributeLists;
        }
        if (modifiers != null)
        {
            this.AdjustFlagsAndWidth(modifiers);
            this.modifiers = modifiers;
        }
        this.AdjustFlagsAndWidth(keyword);
        this.keyword = keyword;
        this.AdjustFlagsAndWidth(identifier);
        this.identifier = identifier;
        if (typeParameterList != null)
        {
            this.AdjustFlagsAndWidth(typeParameterList);
            this.typeParameterList = typeParameterList;
        }
        if (baseList != null)
        {
            this.AdjustFlagsAndWidth(baseList);
            this.baseList = baseList;
        }
        if (constraintClauses != null)
        {
            this.AdjustFlagsAndWidth(constraintClauses);
            this.constraintClauses = constraintClauses;
        }
        this.AdjustFlagsAndWidth(openBraceToken);
        this.openBraceToken = openBraceToken;
        if (members != null)
        {
            this.AdjustFlagsAndWidth(members);
            this.members = members;
        }
        this.AdjustFlagsAndWidth(closeBraceToken);
        this.closeBraceToken = closeBraceToken;
        if (semicolonToken != null)
        {
            this.AdjustFlagsAndWidth(semicolonToken);
            this.semicolonToken = semicolonToken;
        }
    }

    public override Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<AttributeListSyntax> AttributeLists => new Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<AttributeListSyntax>(this.attributeLists);
    public override Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SyntaxToken> Modifiers => new Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SyntaxToken>(this.modifiers);
    /// <summary>Gets the struct keyword token.</summary>
    public override SyntaxToken Keyword => this.keyword;
    public override SyntaxToken Identifier => this.identifier;
    public override TypeParameterListSyntax? TypeParameterList => this.typeParameterList;
    public override BaseListSyntax? BaseList => this.baseList;
    public override Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<TypeParameterConstraintClauseSyntax> ConstraintClauses => new Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<TypeParameterConstraintClauseSyntax>(this.constraintClauses);
    public override SyntaxToken OpenBraceToken => this.openBraceToken;
    public override Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<MemberDeclarationSyntax> Members => new Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<MemberDeclarationSyntax>(this.members);
    public override SyntaxToken CloseBraceToken => this.closeBraceToken;
    public override SyntaxToken? SemicolonToken => this.semicolonToken;

    internal override GreenNode? GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.attributeLists;
            case 1: return this.modifiers;
            case 2: return this.keyword;
            case 3: return this.identifier;
            case 4: return this.typeParameterList;
            case 5: return this.baseList;
            case 6: return this.constraintClauses;
            case 7: return this.openBraceToken;
            case 8: return this.members;
            case 9: return this.closeBraceToken;
            case 10: return this.semicolonToken;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new CSharp.Syntax.StructDeclarationSyntax(this, parent, position);

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor) => visitor.VisitStructDeclaration(this);

    public override void Accept(CSharpSyntaxVisitor visitor) => visitor.VisitStructDeclaration(this);

    public StructDeclarationSyntax Update(Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<AttributeListSyntax> attributeLists, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SyntaxToken> modifiers, SyntaxToken keyword, SyntaxToken identifier, TypeParameterListSyntax typeParameterList, BaseListSyntax baseList, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<TypeParameterConstraintClauseSyntax> constraintClauses, SyntaxToken openBraceToken, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<MemberDeclarationSyntax> members, SyntaxToken closeBraceToken, SyntaxToken semicolonToken)
    {
        if (attributeLists != this.AttributeLists || modifiers != this.Modifiers || keyword != this.Keyword || identifier != this.Identifier || typeParameterList != this.TypeParameterList || baseList != this.BaseList || constraintClauses != this.ConstraintClauses || openBraceToken != this.OpenBraceToken || members != this.Members || closeBraceToken != this.CloseBraceToken || semicolonToken != this.SemicolonToken)
        {
            var newNode = SyntaxFactory.StructDeclaration(attributeLists, modifiers, keyword, identifier, typeParameterList, baseList, constraintClauses, openBraceToken, members, closeBraceToken, semicolonToken);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
        => new StructDeclarationSyntax(this.Kind, this.attributeLists, this.modifiers, this.keyword, this.identifier, this.typeParameterList, this.baseList, this.constraintClauses, this.openBraceToken, this.members, this.closeBraceToken, this.semicolonToken, diagnostics, GetAnnotations());

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
        => new StructDeclarationSyntax(this.Kind, this.attributeLists, this.modifiers, this.keyword, this.identifier, this.typeParameterList, this.baseList, this.constraintClauses, this.openBraceToken, this.members, this.closeBraceToken, this.semicolonToken, GetDiagnostics(), annotations);

    internal StructDeclarationSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 11;
      var attributeLists = (GreenNode?)reader.ReadValue();
      if (attributeLists != null)
      {
         AdjustFlagsAndWidth(attributeLists);
         this.attributeLists = attributeLists;
      }
      var modifiers = (GreenNode?)reader.ReadValue();
      if (modifiers != null)
      {
         AdjustFlagsAndWidth(modifiers);
         this.modifiers = modifiers;
      }
      var keyword = (SyntaxToken)reader.ReadValue();
      if (keyword != null)
      {
         AdjustFlagsAndWidth(keyword);
         this.keyword = keyword;
      }
      var identifier = (SyntaxToken)reader.ReadValue();
      if (identifier != null)
      {
         AdjustFlagsAndWidth(identifier);
         this.identifier = identifier;
      }
      var typeParameterList = (TypeParameterListSyntax?)reader.ReadValue();
      if (typeParameterList != null)
      {
         AdjustFlagsAndWidth(typeParameterList);
         this.typeParameterList = typeParameterList;
      }
      var baseList = (BaseListSyntax?)reader.ReadValue();
      if (baseList != null)
      {
         AdjustFlagsAndWidth(baseList);
         this.baseList = baseList;
      }
      var constraintClauses = (GreenNode?)reader.ReadValue();
      if (constraintClauses != null)
      {
         AdjustFlagsAndWidth(constraintClauses);
         this.constraintClauses = constraintClauses;
      }
      var openBraceToken = (SyntaxToken)reader.ReadValue();
      if (openBraceToken != null)
      {
         AdjustFlagsAndWidth(openBraceToken);
         this.openBraceToken = openBraceToken;
      }
      var members = (GreenNode?)reader.ReadValue();
      if (members != null)
      {
         AdjustFlagsAndWidth(members);
         this.members = members;
      }
      var closeBraceToken = (SyntaxToken)reader.ReadValue();
      if (closeBraceToken != null)
      {
         AdjustFlagsAndWidth(closeBraceToken);
         this.closeBraceToken = closeBraceToken;
      }
      var semicolonToken = (SyntaxToken?)reader.ReadValue();
      if (semicolonToken != null)
      {
         AdjustFlagsAndWidth(semicolonToken);
         this.semicolonToken = semicolonToken;
      }
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.attributeLists);
      writer.WriteValue(this.modifiers);
      writer.WriteValue(this.keyword);
      writer.WriteValue(this.identifier);
      writer.WriteValue(this.typeParameterList);
      writer.WriteValue(this.baseList);
      writer.WriteValue(this.constraintClauses);
      writer.WriteValue(this.openBraceToken);
      writer.WriteValue(this.members);
      writer.WriteValue(this.closeBraceToken);
      writer.WriteValue(this.semicolonToken);
    }

    static StructDeclarationSyntax()
    {
       ObjectBinder.RegisterTypeReader(typeof(StructDeclarationSyntax), r => new StructDeclarationSyntax(r));
    }
  }

  /// <summary>Interface type declaration syntax.</summary>
  internal sealed partial class InterfaceDeclarationSyntax : TypeDeclarationSyntax
  {
    internal readonly GreenNode? attributeLists;
    internal readonly GreenNode? modifiers;
    internal readonly SyntaxToken keyword;
    internal readonly SyntaxToken identifier;
    internal readonly TypeParameterListSyntax? typeParameterList;
    internal readonly BaseListSyntax? baseList;
    internal readonly GreenNode? constraintClauses;
    internal readonly SyntaxToken openBraceToken;
    internal readonly GreenNode? members;
    internal readonly SyntaxToken closeBraceToken;
    internal readonly SyntaxToken? semicolonToken;

    internal InterfaceDeclarationSyntax(SyntaxKind kind, GreenNode? attributeLists, GreenNode? modifiers, SyntaxToken keyword, SyntaxToken identifier, TypeParameterListSyntax? typeParameterList, BaseListSyntax? baseList, GreenNode? constraintClauses, SyntaxToken openBraceToken, GreenNode? members, SyntaxToken closeBraceToken, SyntaxToken? semicolonToken, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 11;
        if (attributeLists != null)
        {
            this.AdjustFlagsAndWidth(attributeLists);
            this.attributeLists = attributeLists;
        }
        if (modifiers != null)
        {
            this.AdjustFlagsAndWidth(modifiers);
            this.modifiers = modifiers;
        }
        this.AdjustFlagsAndWidth(keyword);
        this.keyword = keyword;
        this.AdjustFlagsAndWidth(identifier);
        this.identifier = identifier;
        if (typeParameterList != null)
        {
            this.AdjustFlagsAndWidth(typeParameterList);
            this.typeParameterList = typeParameterList;
        }
        if (baseList != null)
        {
            this.AdjustFlagsAndWidth(baseList);
            this.baseList = baseList;
        }
        if (constraintClauses != null)
        {
            this.AdjustFlagsAndWidth(constraintClauses);
            this.constraintClauses = constraintClauses;
        }
        this.AdjustFlagsAndWidth(openBraceToken);
        this.openBraceToken = openBraceToken;
        if (members != null)
        {
            this.AdjustFlagsAndWidth(members);
            this.members = members;
        }
        this.AdjustFlagsAndWidth(closeBraceToken);
        this.closeBraceToken = closeBraceToken;
        if (semicolonToken != null)
        {
            this.AdjustFlagsAndWidth(semicolonToken);
            this.semicolonToken = semicolonToken;
        }
    }


    internal InterfaceDeclarationSyntax(SyntaxKind kind, GreenNode? attributeLists, GreenNode? modifiers, SyntaxToken keyword, SyntaxToken identifier, TypeParameterListSyntax? typeParameterList, BaseListSyntax? baseList, GreenNode? constraintClauses, SyntaxToken openBraceToken, GreenNode? members, SyntaxToken closeBraceToken, SyntaxToken? semicolonToken, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 11;
        if (attributeLists != null)
        {
            this.AdjustFlagsAndWidth(attributeLists);
            this.attributeLists = attributeLists;
        }
        if (modifiers != null)
        {
            this.AdjustFlagsAndWidth(modifiers);
            this.modifiers = modifiers;
        }
        this.AdjustFlagsAndWidth(keyword);
        this.keyword = keyword;
        this.AdjustFlagsAndWidth(identifier);
        this.identifier = identifier;
        if (typeParameterList != null)
        {
            this.AdjustFlagsAndWidth(typeParameterList);
            this.typeParameterList = typeParameterList;
        }
        if (baseList != null)
        {
            this.AdjustFlagsAndWidth(baseList);
            this.baseList = baseList;
        }
        if (constraintClauses != null)
        {
            this.AdjustFlagsAndWidth(constraintClauses);
            this.constraintClauses = constraintClauses;
        }
        this.AdjustFlagsAndWidth(openBraceToken);
        this.openBraceToken = openBraceToken;
        if (members != null)
        {
            this.AdjustFlagsAndWidth(members);
            this.members = members;
        }
        this.AdjustFlagsAndWidth(closeBraceToken);
        this.closeBraceToken = closeBraceToken;
        if (semicolonToken != null)
        {
            this.AdjustFlagsAndWidth(semicolonToken);
            this.semicolonToken = semicolonToken;
        }
    }


    internal InterfaceDeclarationSyntax(SyntaxKind kind, GreenNode? attributeLists, GreenNode? modifiers, SyntaxToken keyword, SyntaxToken identifier, TypeParameterListSyntax? typeParameterList, BaseListSyntax? baseList, GreenNode? constraintClauses, SyntaxToken openBraceToken, GreenNode? members, SyntaxToken closeBraceToken, SyntaxToken? semicolonToken)
        : base(kind)
    {
        this.SlotCount = 11;
        if (attributeLists != null)
        {
            this.AdjustFlagsAndWidth(attributeLists);
            this.attributeLists = attributeLists;
        }
        if (modifiers != null)
        {
            this.AdjustFlagsAndWidth(modifiers);
            this.modifiers = modifiers;
        }
        this.AdjustFlagsAndWidth(keyword);
        this.keyword = keyword;
        this.AdjustFlagsAndWidth(identifier);
        this.identifier = identifier;
        if (typeParameterList != null)
        {
            this.AdjustFlagsAndWidth(typeParameterList);
            this.typeParameterList = typeParameterList;
        }
        if (baseList != null)
        {
            this.AdjustFlagsAndWidth(baseList);
            this.baseList = baseList;
        }
        if (constraintClauses != null)
        {
            this.AdjustFlagsAndWidth(constraintClauses);
            this.constraintClauses = constraintClauses;
        }
        this.AdjustFlagsAndWidth(openBraceToken);
        this.openBraceToken = openBraceToken;
        if (members != null)
        {
            this.AdjustFlagsAndWidth(members);
            this.members = members;
        }
        this.AdjustFlagsAndWidth(closeBraceToken);
        this.closeBraceToken = closeBraceToken;
        if (semicolonToken != null)
        {
            this.AdjustFlagsAndWidth(semicolonToken);
            this.semicolonToken = semicolonToken;
        }
    }

    public override Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<AttributeListSyntax> AttributeLists => new Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<AttributeListSyntax>(this.attributeLists);
    public override Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SyntaxToken> Modifiers => new Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SyntaxToken>(this.modifiers);
    /// <summary>Gets the interface keyword token.</summary>
    public override SyntaxToken Keyword => this.keyword;
    public override SyntaxToken Identifier => this.identifier;
    public override TypeParameterListSyntax? TypeParameterList => this.typeParameterList;
    public override BaseListSyntax? BaseList => this.baseList;
    public override Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<TypeParameterConstraintClauseSyntax> ConstraintClauses => new Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<TypeParameterConstraintClauseSyntax>(this.constraintClauses);
    public override SyntaxToken OpenBraceToken => this.openBraceToken;
    public override Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<MemberDeclarationSyntax> Members => new Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<MemberDeclarationSyntax>(this.members);
    public override SyntaxToken CloseBraceToken => this.closeBraceToken;
    public override SyntaxToken? SemicolonToken => this.semicolonToken;

    internal override GreenNode? GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.attributeLists;
            case 1: return this.modifiers;
            case 2: return this.keyword;
            case 3: return this.identifier;
            case 4: return this.typeParameterList;
            case 5: return this.baseList;
            case 6: return this.constraintClauses;
            case 7: return this.openBraceToken;
            case 8: return this.members;
            case 9: return this.closeBraceToken;
            case 10: return this.semicolonToken;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new CSharp.Syntax.InterfaceDeclarationSyntax(this, parent, position);

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor) => visitor.VisitInterfaceDeclaration(this);

    public override void Accept(CSharpSyntaxVisitor visitor) => visitor.VisitInterfaceDeclaration(this);

    public InterfaceDeclarationSyntax Update(Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<AttributeListSyntax> attributeLists, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SyntaxToken> modifiers, SyntaxToken keyword, SyntaxToken identifier, TypeParameterListSyntax typeParameterList, BaseListSyntax baseList, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<TypeParameterConstraintClauseSyntax> constraintClauses, SyntaxToken openBraceToken, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<MemberDeclarationSyntax> members, SyntaxToken closeBraceToken, SyntaxToken semicolonToken)
    {
        if (attributeLists != this.AttributeLists || modifiers != this.Modifiers || keyword != this.Keyword || identifier != this.Identifier || typeParameterList != this.TypeParameterList || baseList != this.BaseList || constraintClauses != this.ConstraintClauses || openBraceToken != this.OpenBraceToken || members != this.Members || closeBraceToken != this.CloseBraceToken || semicolonToken != this.SemicolonToken)
        {
            var newNode = SyntaxFactory.InterfaceDeclaration(attributeLists, modifiers, keyword, identifier, typeParameterList, baseList, constraintClauses, openBraceToken, members, closeBraceToken, semicolonToken);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
        => new InterfaceDeclarationSyntax(this.Kind, this.attributeLists, this.modifiers, this.keyword, this.identifier, this.typeParameterList, this.baseList, this.constraintClauses, this.openBraceToken, this.members, this.closeBraceToken, this.semicolonToken, diagnostics, GetAnnotations());

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
        => new InterfaceDeclarationSyntax(this.Kind, this.attributeLists, this.modifiers, this.keyword, this.identifier, this.typeParameterList, this.baseList, this.constraintClauses, this.openBraceToken, this.members, this.closeBraceToken, this.semicolonToken, GetDiagnostics(), annotations);

    internal InterfaceDeclarationSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 11;
      var attributeLists = (GreenNode?)reader.ReadValue();
      if (attributeLists != null)
      {
         AdjustFlagsAndWidth(attributeLists);
         this.attributeLists = attributeLists;
      }
      var modifiers = (GreenNode?)reader.ReadValue();
      if (modifiers != null)
      {
         AdjustFlagsAndWidth(modifiers);
         this.modifiers = modifiers;
      }
      var keyword = (SyntaxToken)reader.ReadValue();
      if (keyword != null)
      {
         AdjustFlagsAndWidth(keyword);
         this.keyword = keyword;
      }
      var identifier = (SyntaxToken)reader.ReadValue();
      if (identifier != null)
      {
         AdjustFlagsAndWidth(identifier);
         this.identifier = identifier;
      }
      var typeParameterList = (TypeParameterListSyntax?)reader.ReadValue();
      if (typeParameterList != null)
      {
         AdjustFlagsAndWidth(typeParameterList);
         this.typeParameterList = typeParameterList;
      }
      var baseList = (BaseListSyntax?)reader.ReadValue();
      if (baseList != null)
      {
         AdjustFlagsAndWidth(baseList);
         this.baseList = baseList;
      }
      var constraintClauses = (GreenNode?)reader.ReadValue();
      if (constraintClauses != null)
      {
         AdjustFlagsAndWidth(constraintClauses);
         this.constraintClauses = constraintClauses;
      }
      var openBraceToken = (SyntaxToken)reader.ReadValue();
      if (openBraceToken != null)
      {
         AdjustFlagsAndWidth(openBraceToken);
         this.openBraceToken = openBraceToken;
      }
      var members = (GreenNode?)reader.ReadValue();
      if (members != null)
      {
         AdjustFlagsAndWidth(members);
         this.members = members;
      }
      var closeBraceToken = (SyntaxToken)reader.ReadValue();
      if (closeBraceToken != null)
      {
         AdjustFlagsAndWidth(closeBraceToken);
         this.closeBraceToken = closeBraceToken;
      }
      var semicolonToken = (SyntaxToken?)reader.ReadValue();
      if (semicolonToken != null)
      {
         AdjustFlagsAndWidth(semicolonToken);
         this.semicolonToken = semicolonToken;
      }
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.attributeLists);
      writer.WriteValue(this.modifiers);
      writer.WriteValue(this.keyword);
      writer.WriteValue(this.identifier);
      writer.WriteValue(this.typeParameterList);
      writer.WriteValue(this.baseList);
      writer.WriteValue(this.constraintClauses);
      writer.WriteValue(this.openBraceToken);
      writer.WriteValue(this.members);
      writer.WriteValue(this.closeBraceToken);
      writer.WriteValue(this.semicolonToken);
    }

    static InterfaceDeclarationSyntax()
    {
       ObjectBinder.RegisterTypeReader(typeof(InterfaceDeclarationSyntax), r => new InterfaceDeclarationSyntax(r));
    }
  }

  /// <summary>Enum type declaration syntax.</summary>
  internal sealed partial class EnumDeclarationSyntax : BaseTypeDeclarationSyntax
  {
    internal readonly GreenNode? attributeLists;
    internal readonly GreenNode? modifiers;
    internal readonly SyntaxToken enumKeyword;
    internal readonly SyntaxToken identifier;
    internal readonly BaseListSyntax? baseList;
    internal readonly SyntaxToken openBraceToken;
    internal readonly GreenNode? members;
    internal readonly SyntaxToken closeBraceToken;
    internal readonly SyntaxToken? semicolonToken;

    internal EnumDeclarationSyntax(SyntaxKind kind, GreenNode? attributeLists, GreenNode? modifiers, SyntaxToken enumKeyword, SyntaxToken identifier, BaseListSyntax? baseList, SyntaxToken openBraceToken, GreenNode? members, SyntaxToken closeBraceToken, SyntaxToken? semicolonToken, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 9;
        if (attributeLists != null)
        {
            this.AdjustFlagsAndWidth(attributeLists);
            this.attributeLists = attributeLists;
        }
        if (modifiers != null)
        {
            this.AdjustFlagsAndWidth(modifiers);
            this.modifiers = modifiers;
        }
        this.AdjustFlagsAndWidth(enumKeyword);
        this.enumKeyword = enumKeyword;
        this.AdjustFlagsAndWidth(identifier);
        this.identifier = identifier;
        if (baseList != null)
        {
            this.AdjustFlagsAndWidth(baseList);
            this.baseList = baseList;
        }
        this.AdjustFlagsAndWidth(openBraceToken);
        this.openBraceToken = openBraceToken;
        if (members != null)
        {
            this.AdjustFlagsAndWidth(members);
            this.members = members;
        }
        this.AdjustFlagsAndWidth(closeBraceToken);
        this.closeBraceToken = closeBraceToken;
        if (semicolonToken != null)
        {
            this.AdjustFlagsAndWidth(semicolonToken);
            this.semicolonToken = semicolonToken;
        }
    }


    internal EnumDeclarationSyntax(SyntaxKind kind, GreenNode? attributeLists, GreenNode? modifiers, SyntaxToken enumKeyword, SyntaxToken identifier, BaseListSyntax? baseList, SyntaxToken openBraceToken, GreenNode? members, SyntaxToken closeBraceToken, SyntaxToken? semicolonToken, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 9;
        if (attributeLists != null)
        {
            this.AdjustFlagsAndWidth(attributeLists);
            this.attributeLists = attributeLists;
        }
        if (modifiers != null)
        {
            this.AdjustFlagsAndWidth(modifiers);
            this.modifiers = modifiers;
        }
        this.AdjustFlagsAndWidth(enumKeyword);
        this.enumKeyword = enumKeyword;
        this.AdjustFlagsAndWidth(identifier);
        this.identifier = identifier;
        if (baseList != null)
        {
            this.AdjustFlagsAndWidth(baseList);
            this.baseList = baseList;
        }
        this.AdjustFlagsAndWidth(openBraceToken);
        this.openBraceToken = openBraceToken;
        if (members != null)
        {
            this.AdjustFlagsAndWidth(members);
            this.members = members;
        }
        this.AdjustFlagsAndWidth(closeBraceToken);
        this.closeBraceToken = closeBraceToken;
        if (semicolonToken != null)
        {
            this.AdjustFlagsAndWidth(semicolonToken);
            this.semicolonToken = semicolonToken;
        }
    }


    internal EnumDeclarationSyntax(SyntaxKind kind, GreenNode? attributeLists, GreenNode? modifiers, SyntaxToken enumKeyword, SyntaxToken identifier, BaseListSyntax? baseList, SyntaxToken openBraceToken, GreenNode? members, SyntaxToken closeBraceToken, SyntaxToken? semicolonToken)
        : base(kind)
    {
        this.SlotCount = 9;
        if (attributeLists != null)
        {
            this.AdjustFlagsAndWidth(attributeLists);
            this.attributeLists = attributeLists;
        }
        if (modifiers != null)
        {
            this.AdjustFlagsAndWidth(modifiers);
            this.modifiers = modifiers;
        }
        this.AdjustFlagsAndWidth(enumKeyword);
        this.enumKeyword = enumKeyword;
        this.AdjustFlagsAndWidth(identifier);
        this.identifier = identifier;
        if (baseList != null)
        {
            this.AdjustFlagsAndWidth(baseList);
            this.baseList = baseList;
        }
        this.AdjustFlagsAndWidth(openBraceToken);
        this.openBraceToken = openBraceToken;
        if (members != null)
        {
            this.AdjustFlagsAndWidth(members);
            this.members = members;
        }
        this.AdjustFlagsAndWidth(closeBraceToken);
        this.closeBraceToken = closeBraceToken;
        if (semicolonToken != null)
        {
            this.AdjustFlagsAndWidth(semicolonToken);
            this.semicolonToken = semicolonToken;
        }
    }

    public override Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<AttributeListSyntax> AttributeLists => new Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<AttributeListSyntax>(this.attributeLists);
    public override Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SyntaxToken> Modifiers => new Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SyntaxToken>(this.modifiers);
    /// <summary>Gets the enum keyword token.</summary>
    public SyntaxToken EnumKeyword => this.enumKeyword;
    public override SyntaxToken Identifier => this.identifier;
    public override BaseListSyntax? BaseList => this.baseList;
    public override SyntaxToken OpenBraceToken => this.openBraceToken;
    /// <summary>Gets the members declaration list.</summary>
    public Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<EnumMemberDeclarationSyntax> Members => new Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<EnumMemberDeclarationSyntax>(new Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<CSharpSyntaxNode>(this.members));
    public override SyntaxToken CloseBraceToken => this.closeBraceToken;
    /// <summary>Gets the optional semicolon token.</summary>
    public override SyntaxToken? SemicolonToken => this.semicolonToken;

    internal override GreenNode? GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.attributeLists;
            case 1: return this.modifiers;
            case 2: return this.enumKeyword;
            case 3: return this.identifier;
            case 4: return this.baseList;
            case 5: return this.openBraceToken;
            case 6: return this.members;
            case 7: return this.closeBraceToken;
            case 8: return this.semicolonToken;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new CSharp.Syntax.EnumDeclarationSyntax(this, parent, position);

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor) => visitor.VisitEnumDeclaration(this);

    public override void Accept(CSharpSyntaxVisitor visitor) => visitor.VisitEnumDeclaration(this);

    public EnumDeclarationSyntax Update(Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<AttributeListSyntax> attributeLists, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SyntaxToken> modifiers, SyntaxToken enumKeyword, SyntaxToken identifier, BaseListSyntax baseList, SyntaxToken openBraceToken, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<EnumMemberDeclarationSyntax> members, SyntaxToken closeBraceToken, SyntaxToken semicolonToken)
    {
        if (attributeLists != this.AttributeLists || modifiers != this.Modifiers || enumKeyword != this.EnumKeyword || identifier != this.Identifier || baseList != this.BaseList || openBraceToken != this.OpenBraceToken || members != this.Members || closeBraceToken != this.CloseBraceToken || semicolonToken != this.SemicolonToken)
        {
            var newNode = SyntaxFactory.EnumDeclaration(attributeLists, modifiers, enumKeyword, identifier, baseList, openBraceToken, members, closeBraceToken, semicolonToken);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
        => new EnumDeclarationSyntax(this.Kind, this.attributeLists, this.modifiers, this.enumKeyword, this.identifier, this.baseList, this.openBraceToken, this.members, this.closeBraceToken, this.semicolonToken, diagnostics, GetAnnotations());

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
        => new EnumDeclarationSyntax(this.Kind, this.attributeLists, this.modifiers, this.enumKeyword, this.identifier, this.baseList, this.openBraceToken, this.members, this.closeBraceToken, this.semicolonToken, GetDiagnostics(), annotations);

    internal EnumDeclarationSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 9;
      var attributeLists = (GreenNode?)reader.ReadValue();
      if (attributeLists != null)
      {
         AdjustFlagsAndWidth(attributeLists);
         this.attributeLists = attributeLists;
      }
      var modifiers = (GreenNode?)reader.ReadValue();
      if (modifiers != null)
      {
         AdjustFlagsAndWidth(modifiers);
         this.modifiers = modifiers;
      }
      var enumKeyword = (SyntaxToken)reader.ReadValue();
      if (enumKeyword != null)
      {
         AdjustFlagsAndWidth(enumKeyword);
         this.enumKeyword = enumKeyword;
      }
      var identifier = (SyntaxToken)reader.ReadValue();
      if (identifier != null)
      {
         AdjustFlagsAndWidth(identifier);
         this.identifier = identifier;
      }
      var baseList = (BaseListSyntax?)reader.ReadValue();
      if (baseList != null)
      {
         AdjustFlagsAndWidth(baseList);
         this.baseList = baseList;
      }
      var openBraceToken = (SyntaxToken)reader.ReadValue();
      if (openBraceToken != null)
      {
         AdjustFlagsAndWidth(openBraceToken);
         this.openBraceToken = openBraceToken;
      }
      var members = (GreenNode?)reader.ReadValue();
      if (members != null)
      {
         AdjustFlagsAndWidth(members);
         this.members = members;
      }
      var closeBraceToken = (SyntaxToken)reader.ReadValue();
      if (closeBraceToken != null)
      {
         AdjustFlagsAndWidth(closeBraceToken);
         this.closeBraceToken = closeBraceToken;
      }
      var semicolonToken = (SyntaxToken?)reader.ReadValue();
      if (semicolonToken != null)
      {
         AdjustFlagsAndWidth(semicolonToken);
         this.semicolonToken = semicolonToken;
      }
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.attributeLists);
      writer.WriteValue(this.modifiers);
      writer.WriteValue(this.enumKeyword);
      writer.WriteValue(this.identifier);
      writer.WriteValue(this.baseList);
      writer.WriteValue(this.openBraceToken);
      writer.WriteValue(this.members);
      writer.WriteValue(this.closeBraceToken);
      writer.WriteValue(this.semicolonToken);
    }

    static EnumDeclarationSyntax()
    {
       ObjectBinder.RegisterTypeReader(typeof(EnumDeclarationSyntax), r => new EnumDeclarationSyntax(r));
    }
  }

  /// <summary>Delegate declaration syntax.</summary>
  internal sealed partial class DelegateDeclarationSyntax : MemberDeclarationSyntax
  {
    internal readonly GreenNode? attributeLists;
    internal readonly GreenNode? modifiers;
    internal readonly SyntaxToken delegateKeyword;
    internal readonly TypeSyntax returnType;
    internal readonly SyntaxToken identifier;
    internal readonly TypeParameterListSyntax? typeParameterList;
    internal readonly ParameterListSyntax parameterList;
    internal readonly GreenNode? constraintClauses;
    internal readonly SyntaxToken semicolonToken;

    internal DelegateDeclarationSyntax(SyntaxKind kind, GreenNode? attributeLists, GreenNode? modifiers, SyntaxToken delegateKeyword, TypeSyntax returnType, SyntaxToken identifier, TypeParameterListSyntax? typeParameterList, ParameterListSyntax parameterList, GreenNode? constraintClauses, SyntaxToken semicolonToken, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 9;
        if (attributeLists != null)
        {
            this.AdjustFlagsAndWidth(attributeLists);
            this.attributeLists = attributeLists;
        }
        if (modifiers != null)
        {
            this.AdjustFlagsAndWidth(modifiers);
            this.modifiers = modifiers;
        }
        this.AdjustFlagsAndWidth(delegateKeyword);
        this.delegateKeyword = delegateKeyword;
        this.AdjustFlagsAndWidth(returnType);
        this.returnType = returnType;
        this.AdjustFlagsAndWidth(identifier);
        this.identifier = identifier;
        if (typeParameterList != null)
        {
            this.AdjustFlagsAndWidth(typeParameterList);
            this.typeParameterList = typeParameterList;
        }
        this.AdjustFlagsAndWidth(parameterList);
        this.parameterList = parameterList;
        if (constraintClauses != null)
        {
            this.AdjustFlagsAndWidth(constraintClauses);
            this.constraintClauses = constraintClauses;
        }
        this.AdjustFlagsAndWidth(semicolonToken);
        this.semicolonToken = semicolonToken;
    }


    internal DelegateDeclarationSyntax(SyntaxKind kind, GreenNode? attributeLists, GreenNode? modifiers, SyntaxToken delegateKeyword, TypeSyntax returnType, SyntaxToken identifier, TypeParameterListSyntax? typeParameterList, ParameterListSyntax parameterList, GreenNode? constraintClauses, SyntaxToken semicolonToken, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 9;
        if (attributeLists != null)
        {
            this.AdjustFlagsAndWidth(attributeLists);
            this.attributeLists = attributeLists;
        }
        if (modifiers != null)
        {
            this.AdjustFlagsAndWidth(modifiers);
            this.modifiers = modifiers;
        }
        this.AdjustFlagsAndWidth(delegateKeyword);
        this.delegateKeyword = delegateKeyword;
        this.AdjustFlagsAndWidth(returnType);
        this.returnType = returnType;
        this.AdjustFlagsAndWidth(identifier);
        this.identifier = identifier;
        if (typeParameterList != null)
        {
            this.AdjustFlagsAndWidth(typeParameterList);
            this.typeParameterList = typeParameterList;
        }
        this.AdjustFlagsAndWidth(parameterList);
        this.parameterList = parameterList;
        if (constraintClauses != null)
        {
            this.AdjustFlagsAndWidth(constraintClauses);
            this.constraintClauses = constraintClauses;
        }
        this.AdjustFlagsAndWidth(semicolonToken);
        this.semicolonToken = semicolonToken;
    }


    internal DelegateDeclarationSyntax(SyntaxKind kind, GreenNode? attributeLists, GreenNode? modifiers, SyntaxToken delegateKeyword, TypeSyntax returnType, SyntaxToken identifier, TypeParameterListSyntax? typeParameterList, ParameterListSyntax parameterList, GreenNode? constraintClauses, SyntaxToken semicolonToken)
        : base(kind)
    {
        this.SlotCount = 9;
        if (attributeLists != null)
        {
            this.AdjustFlagsAndWidth(attributeLists);
            this.attributeLists = attributeLists;
        }
        if (modifiers != null)
        {
            this.AdjustFlagsAndWidth(modifiers);
            this.modifiers = modifiers;
        }
        this.AdjustFlagsAndWidth(delegateKeyword);
        this.delegateKeyword = delegateKeyword;
        this.AdjustFlagsAndWidth(returnType);
        this.returnType = returnType;
        this.AdjustFlagsAndWidth(identifier);
        this.identifier = identifier;
        if (typeParameterList != null)
        {
            this.AdjustFlagsAndWidth(typeParameterList);
            this.typeParameterList = typeParameterList;
        }
        this.AdjustFlagsAndWidth(parameterList);
        this.parameterList = parameterList;
        if (constraintClauses != null)
        {
            this.AdjustFlagsAndWidth(constraintClauses);
            this.constraintClauses = constraintClauses;
        }
        this.AdjustFlagsAndWidth(semicolonToken);
        this.semicolonToken = semicolonToken;
    }

    public override Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<AttributeListSyntax> AttributeLists => new Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<AttributeListSyntax>(this.attributeLists);
    public override Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SyntaxToken> Modifiers => new Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SyntaxToken>(this.modifiers);
    /// <summary>Gets the "delegate" keyword.</summary>
    public SyntaxToken DelegateKeyword => this.delegateKeyword;
    /// <summary>Gets the return type.</summary>
    public TypeSyntax ReturnType => this.returnType;
    /// <summary>Gets the identifier.</summary>
    public SyntaxToken Identifier => this.identifier;
    public TypeParameterListSyntax? TypeParameterList => this.typeParameterList;
    /// <summary>Gets the parameter list.</summary>
    public ParameterListSyntax ParameterList => this.parameterList;
    /// <summary>Gets the constraint clause list.</summary>
    public Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<TypeParameterConstraintClauseSyntax> ConstraintClauses => new Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<TypeParameterConstraintClauseSyntax>(this.constraintClauses);
    /// <summary>Gets the semicolon token.</summary>
    public SyntaxToken SemicolonToken => this.semicolonToken;

    internal override GreenNode? GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.attributeLists;
            case 1: return this.modifiers;
            case 2: return this.delegateKeyword;
            case 3: return this.returnType;
            case 4: return this.identifier;
            case 5: return this.typeParameterList;
            case 6: return this.parameterList;
            case 7: return this.constraintClauses;
            case 8: return this.semicolonToken;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new CSharp.Syntax.DelegateDeclarationSyntax(this, parent, position);

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor) => visitor.VisitDelegateDeclaration(this);

    public override void Accept(CSharpSyntaxVisitor visitor) => visitor.VisitDelegateDeclaration(this);

    public DelegateDeclarationSyntax Update(Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<AttributeListSyntax> attributeLists, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SyntaxToken> modifiers, SyntaxToken delegateKeyword, TypeSyntax returnType, SyntaxToken identifier, TypeParameterListSyntax typeParameterList, ParameterListSyntax parameterList, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<TypeParameterConstraintClauseSyntax> constraintClauses, SyntaxToken semicolonToken)
    {
        if (attributeLists != this.AttributeLists || modifiers != this.Modifiers || delegateKeyword != this.DelegateKeyword || returnType != this.ReturnType || identifier != this.Identifier || typeParameterList != this.TypeParameterList || parameterList != this.ParameterList || constraintClauses != this.ConstraintClauses || semicolonToken != this.SemicolonToken)
        {
            var newNode = SyntaxFactory.DelegateDeclaration(attributeLists, modifiers, delegateKeyword, returnType, identifier, typeParameterList, parameterList, constraintClauses, semicolonToken);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
        => new DelegateDeclarationSyntax(this.Kind, this.attributeLists, this.modifiers, this.delegateKeyword, this.returnType, this.identifier, this.typeParameterList, this.parameterList, this.constraintClauses, this.semicolonToken, diagnostics, GetAnnotations());

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
        => new DelegateDeclarationSyntax(this.Kind, this.attributeLists, this.modifiers, this.delegateKeyword, this.returnType, this.identifier, this.typeParameterList, this.parameterList, this.constraintClauses, this.semicolonToken, GetDiagnostics(), annotations);

    internal DelegateDeclarationSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 9;
      var attributeLists = (GreenNode?)reader.ReadValue();
      if (attributeLists != null)
      {
         AdjustFlagsAndWidth(attributeLists);
         this.attributeLists = attributeLists;
      }
      var modifiers = (GreenNode?)reader.ReadValue();
      if (modifiers != null)
      {
         AdjustFlagsAndWidth(modifiers);
         this.modifiers = modifiers;
      }
      var delegateKeyword = (SyntaxToken)reader.ReadValue();
      if (delegateKeyword != null)
      {
         AdjustFlagsAndWidth(delegateKeyword);
         this.delegateKeyword = delegateKeyword;
      }
      var returnType = (TypeSyntax)reader.ReadValue();
      if (returnType != null)
      {
         AdjustFlagsAndWidth(returnType);
         this.returnType = returnType;
      }
      var identifier = (SyntaxToken)reader.ReadValue();
      if (identifier != null)
      {
         AdjustFlagsAndWidth(identifier);
         this.identifier = identifier;
      }
      var typeParameterList = (TypeParameterListSyntax?)reader.ReadValue();
      if (typeParameterList != null)
      {
         AdjustFlagsAndWidth(typeParameterList);
         this.typeParameterList = typeParameterList;
      }
      var parameterList = (ParameterListSyntax)reader.ReadValue();
      if (parameterList != null)
      {
         AdjustFlagsAndWidth(parameterList);
         this.parameterList = parameterList;
      }
      var constraintClauses = (GreenNode?)reader.ReadValue();
      if (constraintClauses != null)
      {
         AdjustFlagsAndWidth(constraintClauses);
         this.constraintClauses = constraintClauses;
      }
      var semicolonToken = (SyntaxToken)reader.ReadValue();
      if (semicolonToken != null)
      {
         AdjustFlagsAndWidth(semicolonToken);
         this.semicolonToken = semicolonToken;
      }
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.attributeLists);
      writer.WriteValue(this.modifiers);
      writer.WriteValue(this.delegateKeyword);
      writer.WriteValue(this.returnType);
      writer.WriteValue(this.identifier);
      writer.WriteValue(this.typeParameterList);
      writer.WriteValue(this.parameterList);
      writer.WriteValue(this.constraintClauses);
      writer.WriteValue(this.semicolonToken);
    }

    static DelegateDeclarationSyntax()
    {
       ObjectBinder.RegisterTypeReader(typeof(DelegateDeclarationSyntax), r => new DelegateDeclarationSyntax(r));
    }
  }

  internal sealed partial class EnumMemberDeclarationSyntax : MemberDeclarationSyntax
  {
    internal readonly GreenNode? attributeLists;
    internal readonly GreenNode? modifiers;
    internal readonly SyntaxToken identifier;
    internal readonly EqualsValueClauseSyntax? equalsValue;

    internal EnumMemberDeclarationSyntax(SyntaxKind kind, GreenNode? attributeLists, GreenNode? modifiers, SyntaxToken identifier, EqualsValueClauseSyntax? equalsValue, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 4;
        if (attributeLists != null)
        {
            this.AdjustFlagsAndWidth(attributeLists);
            this.attributeLists = attributeLists;
        }
        if (modifiers != null)
        {
            this.AdjustFlagsAndWidth(modifiers);
            this.modifiers = modifiers;
        }
        this.AdjustFlagsAndWidth(identifier);
        this.identifier = identifier;
        if (equalsValue != null)
        {
            this.AdjustFlagsAndWidth(equalsValue);
            this.equalsValue = equalsValue;
        }
    }


    internal EnumMemberDeclarationSyntax(SyntaxKind kind, GreenNode? attributeLists, GreenNode? modifiers, SyntaxToken identifier, EqualsValueClauseSyntax? equalsValue, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 4;
        if (attributeLists != null)
        {
            this.AdjustFlagsAndWidth(attributeLists);
            this.attributeLists = attributeLists;
        }
        if (modifiers != null)
        {
            this.AdjustFlagsAndWidth(modifiers);
            this.modifiers = modifiers;
        }
        this.AdjustFlagsAndWidth(identifier);
        this.identifier = identifier;
        if (equalsValue != null)
        {
            this.AdjustFlagsAndWidth(equalsValue);
            this.equalsValue = equalsValue;
        }
    }


    internal EnumMemberDeclarationSyntax(SyntaxKind kind, GreenNode? attributeLists, GreenNode? modifiers, SyntaxToken identifier, EqualsValueClauseSyntax? equalsValue)
        : base(kind)
    {
        this.SlotCount = 4;
        if (attributeLists != null)
        {
            this.AdjustFlagsAndWidth(attributeLists);
            this.attributeLists = attributeLists;
        }
        if (modifiers != null)
        {
            this.AdjustFlagsAndWidth(modifiers);
            this.modifiers = modifiers;
        }
        this.AdjustFlagsAndWidth(identifier);
        this.identifier = identifier;
        if (equalsValue != null)
        {
            this.AdjustFlagsAndWidth(equalsValue);
            this.equalsValue = equalsValue;
        }
    }

    public override Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<AttributeListSyntax> AttributeLists => new Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<AttributeListSyntax>(this.attributeLists);
    public override Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SyntaxToken> Modifiers => new Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SyntaxToken>(this.modifiers);
    /// <summary>Gets the identifier.</summary>
    public SyntaxToken Identifier => this.identifier;
    public EqualsValueClauseSyntax? EqualsValue => this.equalsValue;

    internal override GreenNode? GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.attributeLists;
            case 1: return this.modifiers;
            case 2: return this.identifier;
            case 3: return this.equalsValue;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new CSharp.Syntax.EnumMemberDeclarationSyntax(this, parent, position);

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor) => visitor.VisitEnumMemberDeclaration(this);

    public override void Accept(CSharpSyntaxVisitor visitor) => visitor.VisitEnumMemberDeclaration(this);

    public EnumMemberDeclarationSyntax Update(Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<AttributeListSyntax> attributeLists, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SyntaxToken> modifiers, SyntaxToken identifier, EqualsValueClauseSyntax equalsValue)
    {
        if (attributeLists != this.AttributeLists || modifiers != this.Modifiers || identifier != this.Identifier || equalsValue != this.EqualsValue)
        {
            var newNode = SyntaxFactory.EnumMemberDeclaration(attributeLists, modifiers, identifier, equalsValue);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
        => new EnumMemberDeclarationSyntax(this.Kind, this.attributeLists, this.modifiers, this.identifier, this.equalsValue, diagnostics, GetAnnotations());

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
        => new EnumMemberDeclarationSyntax(this.Kind, this.attributeLists, this.modifiers, this.identifier, this.equalsValue, GetDiagnostics(), annotations);

    internal EnumMemberDeclarationSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 4;
      var attributeLists = (GreenNode?)reader.ReadValue();
      if (attributeLists != null)
      {
         AdjustFlagsAndWidth(attributeLists);
         this.attributeLists = attributeLists;
      }
      var modifiers = (GreenNode?)reader.ReadValue();
      if (modifiers != null)
      {
         AdjustFlagsAndWidth(modifiers);
         this.modifiers = modifiers;
      }
      var identifier = (SyntaxToken)reader.ReadValue();
      if (identifier != null)
      {
         AdjustFlagsAndWidth(identifier);
         this.identifier = identifier;
      }
      var equalsValue = (EqualsValueClauseSyntax?)reader.ReadValue();
      if (equalsValue != null)
      {
         AdjustFlagsAndWidth(equalsValue);
         this.equalsValue = equalsValue;
      }
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.attributeLists);
      writer.WriteValue(this.modifiers);
      writer.WriteValue(this.identifier);
      writer.WriteValue(this.equalsValue);
    }

    static EnumMemberDeclarationSyntax()
    {
       ObjectBinder.RegisterTypeReader(typeof(EnumMemberDeclarationSyntax), r => new EnumMemberDeclarationSyntax(r));
    }
  }

  /// <summary>Base list syntax.</summary>
  internal sealed partial class BaseListSyntax : CSharpSyntaxNode
  {
    internal readonly SyntaxToken colonToken;
    internal readonly GreenNode? types;

    internal BaseListSyntax(SyntaxKind kind, SyntaxToken colonToken, GreenNode? types, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 2;
        this.AdjustFlagsAndWidth(colonToken);
        this.colonToken = colonToken;
        if (types != null)
        {
            this.AdjustFlagsAndWidth(types);
            this.types = types;
        }
    }


    internal BaseListSyntax(SyntaxKind kind, SyntaxToken colonToken, GreenNode? types, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 2;
        this.AdjustFlagsAndWidth(colonToken);
        this.colonToken = colonToken;
        if (types != null)
        {
            this.AdjustFlagsAndWidth(types);
            this.types = types;
        }
    }


    internal BaseListSyntax(SyntaxKind kind, SyntaxToken colonToken, GreenNode? types)
        : base(kind)
    {
        this.SlotCount = 2;
        this.AdjustFlagsAndWidth(colonToken);
        this.colonToken = colonToken;
        if (types != null)
        {
            this.AdjustFlagsAndWidth(types);
            this.types = types;
        }
    }

    /// <summary>Gets the colon token.</summary>
    public SyntaxToken ColonToken => this.colonToken;
    /// <summary>Gets the base type references.</summary>
    public Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<BaseTypeSyntax> Types => new Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<BaseTypeSyntax>(new Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<CSharpSyntaxNode>(this.types));

    internal override GreenNode? GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.colonToken;
            case 1: return this.types;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new CSharp.Syntax.BaseListSyntax(this, parent, position);

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor) => visitor.VisitBaseList(this);

    public override void Accept(CSharpSyntaxVisitor visitor) => visitor.VisitBaseList(this);

    public BaseListSyntax Update(SyntaxToken colonToken, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<BaseTypeSyntax> types)
    {
        if (colonToken != this.ColonToken || types != this.Types)
        {
            var newNode = SyntaxFactory.BaseList(colonToken, types);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
        => new BaseListSyntax(this.Kind, this.colonToken, this.types, diagnostics, GetAnnotations());

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
        => new BaseListSyntax(this.Kind, this.colonToken, this.types, GetDiagnostics(), annotations);

    internal BaseListSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 2;
      var colonToken = (SyntaxToken)reader.ReadValue();
      if (colonToken != null)
      {
         AdjustFlagsAndWidth(colonToken);
         this.colonToken = colonToken;
      }
      var types = (GreenNode?)reader.ReadValue();
      if (types != null)
      {
         AdjustFlagsAndWidth(types);
         this.types = types;
      }
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.colonToken);
      writer.WriteValue(this.types);
    }

    static BaseListSyntax()
    {
       ObjectBinder.RegisterTypeReader(typeof(BaseListSyntax), r => new BaseListSyntax(r));
    }
  }

  /// <summary>Provides the base class from which the classes that represent base type syntax nodes are derived. This is an abstract class.</summary>
  internal abstract partial class BaseTypeSyntax : CSharpSyntaxNode
  {
    internal BaseTypeSyntax(SyntaxKind kind, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
      : base(kind, diagnostics, annotations)
    {
    }
    internal BaseTypeSyntax(SyntaxKind kind)
      : base(kind)
    {
    }

    protected BaseTypeSyntax(ObjectReader reader)
       : base(reader)
    {
    }

    public abstract TypeSyntax Type { get; }
  }

  internal sealed partial class SimpleBaseTypeSyntax : BaseTypeSyntax
  {
    internal readonly TypeSyntax type;

    internal SimpleBaseTypeSyntax(SyntaxKind kind, TypeSyntax type, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 1;
        this.AdjustFlagsAndWidth(type);
        this.type = type;
    }


    internal SimpleBaseTypeSyntax(SyntaxKind kind, TypeSyntax type, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 1;
        this.AdjustFlagsAndWidth(type);
        this.type = type;
    }


    internal SimpleBaseTypeSyntax(SyntaxKind kind, TypeSyntax type)
        : base(kind)
    {
        this.SlotCount = 1;
        this.AdjustFlagsAndWidth(type);
        this.type = type;
    }

    public override TypeSyntax Type => this.type;

    internal override GreenNode? GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.type;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new CSharp.Syntax.SimpleBaseTypeSyntax(this, parent, position);

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor) => visitor.VisitSimpleBaseType(this);

    public override void Accept(CSharpSyntaxVisitor visitor) => visitor.VisitSimpleBaseType(this);

    public SimpleBaseTypeSyntax Update(TypeSyntax type)
    {
        if (type != this.Type)
        {
            var newNode = SyntaxFactory.SimpleBaseType(type);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
        => new SimpleBaseTypeSyntax(this.Kind, this.type, diagnostics, GetAnnotations());

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
        => new SimpleBaseTypeSyntax(this.Kind, this.type, GetDiagnostics(), annotations);

    internal SimpleBaseTypeSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 1;
      var type = (TypeSyntax)reader.ReadValue();
      if (type != null)
      {
         AdjustFlagsAndWidth(type);
         this.type = type;
      }
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.type);
    }

    static SimpleBaseTypeSyntax()
    {
       ObjectBinder.RegisterTypeReader(typeof(SimpleBaseTypeSyntax), r => new SimpleBaseTypeSyntax(r));
    }
  }

  /// <summary>Type parameter constraint clause.</summary>
  internal sealed partial class TypeParameterConstraintClauseSyntax : CSharpSyntaxNode
  {
    internal readonly SyntaxToken whereKeyword;
    internal readonly IdentifierNameSyntax name;
    internal readonly SyntaxToken colonToken;
    internal readonly GreenNode? constraints;

    internal TypeParameterConstraintClauseSyntax(SyntaxKind kind, SyntaxToken whereKeyword, IdentifierNameSyntax name, SyntaxToken colonToken, GreenNode? constraints, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 4;
        this.AdjustFlagsAndWidth(whereKeyword);
        this.whereKeyword = whereKeyword;
        this.AdjustFlagsAndWidth(name);
        this.name = name;
        this.AdjustFlagsAndWidth(colonToken);
        this.colonToken = colonToken;
        if (constraints != null)
        {
            this.AdjustFlagsAndWidth(constraints);
            this.constraints = constraints;
        }
    }


    internal TypeParameterConstraintClauseSyntax(SyntaxKind kind, SyntaxToken whereKeyword, IdentifierNameSyntax name, SyntaxToken colonToken, GreenNode? constraints, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 4;
        this.AdjustFlagsAndWidth(whereKeyword);
        this.whereKeyword = whereKeyword;
        this.AdjustFlagsAndWidth(name);
        this.name = name;
        this.AdjustFlagsAndWidth(colonToken);
        this.colonToken = colonToken;
        if (constraints != null)
        {
            this.AdjustFlagsAndWidth(constraints);
            this.constraints = constraints;
        }
    }


    internal TypeParameterConstraintClauseSyntax(SyntaxKind kind, SyntaxToken whereKeyword, IdentifierNameSyntax name, SyntaxToken colonToken, GreenNode? constraints)
        : base(kind)
    {
        this.SlotCount = 4;
        this.AdjustFlagsAndWidth(whereKeyword);
        this.whereKeyword = whereKeyword;
        this.AdjustFlagsAndWidth(name);
        this.name = name;
        this.AdjustFlagsAndWidth(colonToken);
        this.colonToken = colonToken;
        if (constraints != null)
        {
            this.AdjustFlagsAndWidth(constraints);
            this.constraints = constraints;
        }
    }

    public SyntaxToken WhereKeyword => this.whereKeyword;
    /// <summary>Gets the identifier.</summary>
    public IdentifierNameSyntax Name => this.name;
    /// <summary>Gets the colon token.</summary>
    public SyntaxToken ColonToken => this.colonToken;
    /// <summary>Gets the constraints list.</summary>
    public Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<TypeParameterConstraintSyntax> Constraints => new Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<TypeParameterConstraintSyntax>(new Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<CSharpSyntaxNode>(this.constraints));

    internal override GreenNode? GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.whereKeyword;
            case 1: return this.name;
            case 2: return this.colonToken;
            case 3: return this.constraints;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new CSharp.Syntax.TypeParameterConstraintClauseSyntax(this, parent, position);

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor) => visitor.VisitTypeParameterConstraintClause(this);

    public override void Accept(CSharpSyntaxVisitor visitor) => visitor.VisitTypeParameterConstraintClause(this);

    public TypeParameterConstraintClauseSyntax Update(SyntaxToken whereKeyword, IdentifierNameSyntax name, SyntaxToken colonToken, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<TypeParameterConstraintSyntax> constraints)
    {
        if (whereKeyword != this.WhereKeyword || name != this.Name || colonToken != this.ColonToken || constraints != this.Constraints)
        {
            var newNode = SyntaxFactory.TypeParameterConstraintClause(whereKeyword, name, colonToken, constraints);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
        => new TypeParameterConstraintClauseSyntax(this.Kind, this.whereKeyword, this.name, this.colonToken, this.constraints, diagnostics, GetAnnotations());

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
        => new TypeParameterConstraintClauseSyntax(this.Kind, this.whereKeyword, this.name, this.colonToken, this.constraints, GetDiagnostics(), annotations);

    internal TypeParameterConstraintClauseSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 4;
      var whereKeyword = (SyntaxToken)reader.ReadValue();
      if (whereKeyword != null)
      {
         AdjustFlagsAndWidth(whereKeyword);
         this.whereKeyword = whereKeyword;
      }
      var name = (IdentifierNameSyntax)reader.ReadValue();
      if (name != null)
      {
         AdjustFlagsAndWidth(name);
         this.name = name;
      }
      var colonToken = (SyntaxToken)reader.ReadValue();
      if (colonToken != null)
      {
         AdjustFlagsAndWidth(colonToken);
         this.colonToken = colonToken;
      }
      var constraints = (GreenNode?)reader.ReadValue();
      if (constraints != null)
      {
         AdjustFlagsAndWidth(constraints);
         this.constraints = constraints;
      }
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.whereKeyword);
      writer.WriteValue(this.name);
      writer.WriteValue(this.colonToken);
      writer.WriteValue(this.constraints);
    }

    static TypeParameterConstraintClauseSyntax()
    {
       ObjectBinder.RegisterTypeReader(typeof(TypeParameterConstraintClauseSyntax), r => new TypeParameterConstraintClauseSyntax(r));
    }
  }

  /// <summary>Base type for type parameter constraint syntax.</summary>
  internal abstract partial class TypeParameterConstraintSyntax : CSharpSyntaxNode
  {
    internal TypeParameterConstraintSyntax(SyntaxKind kind, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
      : base(kind, diagnostics, annotations)
    {
    }
    internal TypeParameterConstraintSyntax(SyntaxKind kind)
      : base(kind)
    {
    }

    protected TypeParameterConstraintSyntax(ObjectReader reader)
       : base(reader)
    {
    }
  }

  /// <summary>Constructor constraint syntax.</summary>
  internal sealed partial class ConstructorConstraintSyntax : TypeParameterConstraintSyntax
  {
    internal readonly SyntaxToken newKeyword;
    internal readonly SyntaxToken openParenToken;
    internal readonly SyntaxToken closeParenToken;

    internal ConstructorConstraintSyntax(SyntaxKind kind, SyntaxToken newKeyword, SyntaxToken openParenToken, SyntaxToken closeParenToken, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 3;
        this.AdjustFlagsAndWidth(newKeyword);
        this.newKeyword = newKeyword;
        this.AdjustFlagsAndWidth(openParenToken);
        this.openParenToken = openParenToken;
        this.AdjustFlagsAndWidth(closeParenToken);
        this.closeParenToken = closeParenToken;
    }


    internal ConstructorConstraintSyntax(SyntaxKind kind, SyntaxToken newKeyword, SyntaxToken openParenToken, SyntaxToken closeParenToken, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 3;
        this.AdjustFlagsAndWidth(newKeyword);
        this.newKeyword = newKeyword;
        this.AdjustFlagsAndWidth(openParenToken);
        this.openParenToken = openParenToken;
        this.AdjustFlagsAndWidth(closeParenToken);
        this.closeParenToken = closeParenToken;
    }


    internal ConstructorConstraintSyntax(SyntaxKind kind, SyntaxToken newKeyword, SyntaxToken openParenToken, SyntaxToken closeParenToken)
        : base(kind)
    {
        this.SlotCount = 3;
        this.AdjustFlagsAndWidth(newKeyword);
        this.newKeyword = newKeyword;
        this.AdjustFlagsAndWidth(openParenToken);
        this.openParenToken = openParenToken;
        this.AdjustFlagsAndWidth(closeParenToken);
        this.closeParenToken = closeParenToken;
    }

    /// <summary>Gets the "new" keyword.</summary>
    public SyntaxToken NewKeyword => this.newKeyword;
    /// <summary>Gets the open paren keyword.</summary>
    public SyntaxToken OpenParenToken => this.openParenToken;
    /// <summary>Gets the close paren keyword.</summary>
    public SyntaxToken CloseParenToken => this.closeParenToken;

    internal override GreenNode? GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.newKeyword;
            case 1: return this.openParenToken;
            case 2: return this.closeParenToken;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new CSharp.Syntax.ConstructorConstraintSyntax(this, parent, position);

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor) => visitor.VisitConstructorConstraint(this);

    public override void Accept(CSharpSyntaxVisitor visitor) => visitor.VisitConstructorConstraint(this);

    public ConstructorConstraintSyntax Update(SyntaxToken newKeyword, SyntaxToken openParenToken, SyntaxToken closeParenToken)
    {
        if (newKeyword != this.NewKeyword || openParenToken != this.OpenParenToken || closeParenToken != this.CloseParenToken)
        {
            var newNode = SyntaxFactory.ConstructorConstraint(newKeyword, openParenToken, closeParenToken);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
        => new ConstructorConstraintSyntax(this.Kind, this.newKeyword, this.openParenToken, this.closeParenToken, diagnostics, GetAnnotations());

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
        => new ConstructorConstraintSyntax(this.Kind, this.newKeyword, this.openParenToken, this.closeParenToken, GetDiagnostics(), annotations);

    internal ConstructorConstraintSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 3;
      var newKeyword = (SyntaxToken)reader.ReadValue();
      if (newKeyword != null)
      {
         AdjustFlagsAndWidth(newKeyword);
         this.newKeyword = newKeyword;
      }
      var openParenToken = (SyntaxToken)reader.ReadValue();
      if (openParenToken != null)
      {
         AdjustFlagsAndWidth(openParenToken);
         this.openParenToken = openParenToken;
      }
      var closeParenToken = (SyntaxToken)reader.ReadValue();
      if (closeParenToken != null)
      {
         AdjustFlagsAndWidth(closeParenToken);
         this.closeParenToken = closeParenToken;
      }
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.newKeyword);
      writer.WriteValue(this.openParenToken);
      writer.WriteValue(this.closeParenToken);
    }

    static ConstructorConstraintSyntax()
    {
       ObjectBinder.RegisterTypeReader(typeof(ConstructorConstraintSyntax), r => new ConstructorConstraintSyntax(r));
    }
  }

  /// <summary>Base type for class or struct constraint syntax.</summary>
  internal sealed partial class ClassOrStructConstraintSyntax : TypeParameterConstraintSyntax
  {
    internal readonly SyntaxToken classOrStructKeyword;
    internal readonly SyntaxToken? questionToken;

    internal ClassOrStructConstraintSyntax(SyntaxKind kind, SyntaxToken classOrStructKeyword, SyntaxToken? questionToken, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 2;
        this.AdjustFlagsAndWidth(classOrStructKeyword);
        this.classOrStructKeyword = classOrStructKeyword;
        if (questionToken != null)
        {
            this.AdjustFlagsAndWidth(questionToken);
            this.questionToken = questionToken;
        }
    }


    internal ClassOrStructConstraintSyntax(SyntaxKind kind, SyntaxToken classOrStructKeyword, SyntaxToken? questionToken, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 2;
        this.AdjustFlagsAndWidth(classOrStructKeyword);
        this.classOrStructKeyword = classOrStructKeyword;
        if (questionToken != null)
        {
            this.AdjustFlagsAndWidth(questionToken);
            this.questionToken = questionToken;
        }
    }


    internal ClassOrStructConstraintSyntax(SyntaxKind kind, SyntaxToken classOrStructKeyword, SyntaxToken? questionToken)
        : base(kind)
    {
        this.SlotCount = 2;
        this.AdjustFlagsAndWidth(classOrStructKeyword);
        this.classOrStructKeyword = classOrStructKeyword;
        if (questionToken != null)
        {
            this.AdjustFlagsAndWidth(questionToken);
            this.questionToken = questionToken;
        }
    }

    /// <summary>Gets the constraint keyword ("class" or "struct").</summary>
    public SyntaxToken ClassOrStructKeyword => this.classOrStructKeyword;
    /// <summary>SyntaxToken representing the question mark.</summary>
    public SyntaxToken? QuestionToken => this.questionToken;

    internal override GreenNode? GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.classOrStructKeyword;
            case 1: return this.questionToken;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new CSharp.Syntax.ClassOrStructConstraintSyntax(this, parent, position);

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor) => visitor.VisitClassOrStructConstraint(this);

    public override void Accept(CSharpSyntaxVisitor visitor) => visitor.VisitClassOrStructConstraint(this);

    public ClassOrStructConstraintSyntax Update(SyntaxToken classOrStructKeyword, SyntaxToken questionToken)
    {
        if (classOrStructKeyword != this.ClassOrStructKeyword || questionToken != this.QuestionToken)
        {
            var newNode = SyntaxFactory.ClassOrStructConstraint(this.Kind, classOrStructKeyword, questionToken);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
        => new ClassOrStructConstraintSyntax(this.Kind, this.classOrStructKeyword, this.questionToken, diagnostics, GetAnnotations());

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
        => new ClassOrStructConstraintSyntax(this.Kind, this.classOrStructKeyword, this.questionToken, GetDiagnostics(), annotations);

    internal ClassOrStructConstraintSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 2;
      var classOrStructKeyword = (SyntaxToken)reader.ReadValue();
      if (classOrStructKeyword != null)
      {
         AdjustFlagsAndWidth(classOrStructKeyword);
         this.classOrStructKeyword = classOrStructKeyword;
      }
      var questionToken = (SyntaxToken?)reader.ReadValue();
      if (questionToken != null)
      {
         AdjustFlagsAndWidth(questionToken);
         this.questionToken = questionToken;
      }
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.classOrStructKeyword);
      writer.WriteValue(this.questionToken);
    }

    static ClassOrStructConstraintSyntax()
    {
       ObjectBinder.RegisterTypeReader(typeof(ClassOrStructConstraintSyntax), r => new ClassOrStructConstraintSyntax(r));
    }
  }

  /// <summary>Type constraint syntax.</summary>
  internal sealed partial class TypeConstraintSyntax : TypeParameterConstraintSyntax
  {
    internal readonly TypeSyntax type;

    internal TypeConstraintSyntax(SyntaxKind kind, TypeSyntax type, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 1;
        this.AdjustFlagsAndWidth(type);
        this.type = type;
    }


    internal TypeConstraintSyntax(SyntaxKind kind, TypeSyntax type, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 1;
        this.AdjustFlagsAndWidth(type);
        this.type = type;
    }


    internal TypeConstraintSyntax(SyntaxKind kind, TypeSyntax type)
        : base(kind)
    {
        this.SlotCount = 1;
        this.AdjustFlagsAndWidth(type);
        this.type = type;
    }

    /// <summary>Gets the type syntax.</summary>
    public TypeSyntax Type => this.type;

    internal override GreenNode? GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.type;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new CSharp.Syntax.TypeConstraintSyntax(this, parent, position);

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor) => visitor.VisitTypeConstraint(this);

    public override void Accept(CSharpSyntaxVisitor visitor) => visitor.VisitTypeConstraint(this);

    public TypeConstraintSyntax Update(TypeSyntax type)
    {
        if (type != this.Type)
        {
            var newNode = SyntaxFactory.TypeConstraint(type);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
        => new TypeConstraintSyntax(this.Kind, this.type, diagnostics, GetAnnotations());

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
        => new TypeConstraintSyntax(this.Kind, this.type, GetDiagnostics(), annotations);

    internal TypeConstraintSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 1;
      var type = (TypeSyntax)reader.ReadValue();
      if (type != null)
      {
         AdjustFlagsAndWidth(type);
         this.type = type;
      }
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.type);
    }

    static TypeConstraintSyntax()
    {
       ObjectBinder.RegisterTypeReader(typeof(TypeConstraintSyntax), r => new TypeConstraintSyntax(r));
    }
  }

  internal abstract partial class BaseFieldDeclarationSyntax : MemberDeclarationSyntax
  {
    internal BaseFieldDeclarationSyntax(SyntaxKind kind, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
      : base(kind, diagnostics, annotations)
    {
    }
    internal BaseFieldDeclarationSyntax(SyntaxKind kind)
      : base(kind)
    {
    }

    protected BaseFieldDeclarationSyntax(ObjectReader reader)
       : base(reader)
    {
    }

    public abstract VariableDeclarationSyntax Declaration { get; }

    public abstract SyntaxToken SemicolonToken { get; }
  }

  internal sealed partial class FieldDeclarationSyntax : BaseFieldDeclarationSyntax
  {
    internal readonly GreenNode? attributeLists;
    internal readonly GreenNode? modifiers;
    internal readonly VariableDeclarationSyntax declaration;
    internal readonly SyntaxToken semicolonToken;

    internal FieldDeclarationSyntax(SyntaxKind kind, GreenNode? attributeLists, GreenNode? modifiers, VariableDeclarationSyntax declaration, SyntaxToken semicolonToken, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 4;
        if (attributeLists != null)
        {
            this.AdjustFlagsAndWidth(attributeLists);
            this.attributeLists = attributeLists;
        }
        if (modifiers != null)
        {
            this.AdjustFlagsAndWidth(modifiers);
            this.modifiers = modifiers;
        }
        this.AdjustFlagsAndWidth(declaration);
        this.declaration = declaration;
        this.AdjustFlagsAndWidth(semicolonToken);
        this.semicolonToken = semicolonToken;
    }


    internal FieldDeclarationSyntax(SyntaxKind kind, GreenNode? attributeLists, GreenNode? modifiers, VariableDeclarationSyntax declaration, SyntaxToken semicolonToken, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 4;
        if (attributeLists != null)
        {
            this.AdjustFlagsAndWidth(attributeLists);
            this.attributeLists = attributeLists;
        }
        if (modifiers != null)
        {
            this.AdjustFlagsAndWidth(modifiers);
            this.modifiers = modifiers;
        }
        this.AdjustFlagsAndWidth(declaration);
        this.declaration = declaration;
        this.AdjustFlagsAndWidth(semicolonToken);
        this.semicolonToken = semicolonToken;
    }


    internal FieldDeclarationSyntax(SyntaxKind kind, GreenNode? attributeLists, GreenNode? modifiers, VariableDeclarationSyntax declaration, SyntaxToken semicolonToken)
        : base(kind)
    {
        this.SlotCount = 4;
        if (attributeLists != null)
        {
            this.AdjustFlagsAndWidth(attributeLists);
            this.attributeLists = attributeLists;
        }
        if (modifiers != null)
        {
            this.AdjustFlagsAndWidth(modifiers);
            this.modifiers = modifiers;
        }
        this.AdjustFlagsAndWidth(declaration);
        this.declaration = declaration;
        this.AdjustFlagsAndWidth(semicolonToken);
        this.semicolonToken = semicolonToken;
    }

    public override Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<AttributeListSyntax> AttributeLists => new Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<AttributeListSyntax>(this.attributeLists);
    public override Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SyntaxToken> Modifiers => new Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SyntaxToken>(this.modifiers);
    public override VariableDeclarationSyntax Declaration => this.declaration;
    public override SyntaxToken SemicolonToken => this.semicolonToken;

    internal override GreenNode? GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.attributeLists;
            case 1: return this.modifiers;
            case 2: return this.declaration;
            case 3: return this.semicolonToken;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new CSharp.Syntax.FieldDeclarationSyntax(this, parent, position);

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor) => visitor.VisitFieldDeclaration(this);

    public override void Accept(CSharpSyntaxVisitor visitor) => visitor.VisitFieldDeclaration(this);

    public FieldDeclarationSyntax Update(Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<AttributeListSyntax> attributeLists, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SyntaxToken> modifiers, VariableDeclarationSyntax declaration, SyntaxToken semicolonToken)
    {
        if (attributeLists != this.AttributeLists || modifiers != this.Modifiers || declaration != this.Declaration || semicolonToken != this.SemicolonToken)
        {
            var newNode = SyntaxFactory.FieldDeclaration(attributeLists, modifiers, declaration, semicolonToken);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
        => new FieldDeclarationSyntax(this.Kind, this.attributeLists, this.modifiers, this.declaration, this.semicolonToken, diagnostics, GetAnnotations());

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
        => new FieldDeclarationSyntax(this.Kind, this.attributeLists, this.modifiers, this.declaration, this.semicolonToken, GetDiagnostics(), annotations);

    internal FieldDeclarationSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 4;
      var attributeLists = (GreenNode?)reader.ReadValue();
      if (attributeLists != null)
      {
         AdjustFlagsAndWidth(attributeLists);
         this.attributeLists = attributeLists;
      }
      var modifiers = (GreenNode?)reader.ReadValue();
      if (modifiers != null)
      {
         AdjustFlagsAndWidth(modifiers);
         this.modifiers = modifiers;
      }
      var declaration = (VariableDeclarationSyntax)reader.ReadValue();
      if (declaration != null)
      {
         AdjustFlagsAndWidth(declaration);
         this.declaration = declaration;
      }
      var semicolonToken = (SyntaxToken)reader.ReadValue();
      if (semicolonToken != null)
      {
         AdjustFlagsAndWidth(semicolonToken);
         this.semicolonToken = semicolonToken;
      }
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.attributeLists);
      writer.WriteValue(this.modifiers);
      writer.WriteValue(this.declaration);
      writer.WriteValue(this.semicolonToken);
    }

    static FieldDeclarationSyntax()
    {
       ObjectBinder.RegisterTypeReader(typeof(FieldDeclarationSyntax), r => new FieldDeclarationSyntax(r));
    }
  }

  internal sealed partial class EventFieldDeclarationSyntax : BaseFieldDeclarationSyntax
  {
    internal readonly GreenNode? attributeLists;
    internal readonly GreenNode? modifiers;
    internal readonly SyntaxToken eventKeyword;
    internal readonly VariableDeclarationSyntax declaration;
    internal readonly SyntaxToken semicolonToken;

    internal EventFieldDeclarationSyntax(SyntaxKind kind, GreenNode? attributeLists, GreenNode? modifiers, SyntaxToken eventKeyword, VariableDeclarationSyntax declaration, SyntaxToken semicolonToken, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 5;
        if (attributeLists != null)
        {
            this.AdjustFlagsAndWidth(attributeLists);
            this.attributeLists = attributeLists;
        }
        if (modifiers != null)
        {
            this.AdjustFlagsAndWidth(modifiers);
            this.modifiers = modifiers;
        }
        this.AdjustFlagsAndWidth(eventKeyword);
        this.eventKeyword = eventKeyword;
        this.AdjustFlagsAndWidth(declaration);
        this.declaration = declaration;
        this.AdjustFlagsAndWidth(semicolonToken);
        this.semicolonToken = semicolonToken;
    }


    internal EventFieldDeclarationSyntax(SyntaxKind kind, GreenNode? attributeLists, GreenNode? modifiers, SyntaxToken eventKeyword, VariableDeclarationSyntax declaration, SyntaxToken semicolonToken, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 5;
        if (attributeLists != null)
        {
            this.AdjustFlagsAndWidth(attributeLists);
            this.attributeLists = attributeLists;
        }
        if (modifiers != null)
        {
            this.AdjustFlagsAndWidth(modifiers);
            this.modifiers = modifiers;
        }
        this.AdjustFlagsAndWidth(eventKeyword);
        this.eventKeyword = eventKeyword;
        this.AdjustFlagsAndWidth(declaration);
        this.declaration = declaration;
        this.AdjustFlagsAndWidth(semicolonToken);
        this.semicolonToken = semicolonToken;
    }


    internal EventFieldDeclarationSyntax(SyntaxKind kind, GreenNode? attributeLists, GreenNode? modifiers, SyntaxToken eventKeyword, VariableDeclarationSyntax declaration, SyntaxToken semicolonToken)
        : base(kind)
    {
        this.SlotCount = 5;
        if (attributeLists != null)
        {
            this.AdjustFlagsAndWidth(attributeLists);
            this.attributeLists = attributeLists;
        }
        if (modifiers != null)
        {
            this.AdjustFlagsAndWidth(modifiers);
            this.modifiers = modifiers;
        }
        this.AdjustFlagsAndWidth(eventKeyword);
        this.eventKeyword = eventKeyword;
        this.AdjustFlagsAndWidth(declaration);
        this.declaration = declaration;
        this.AdjustFlagsAndWidth(semicolonToken);
        this.semicolonToken = semicolonToken;
    }

    public override Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<AttributeListSyntax> AttributeLists => new Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<AttributeListSyntax>(this.attributeLists);
    public override Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SyntaxToken> Modifiers => new Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SyntaxToken>(this.modifiers);
    public SyntaxToken EventKeyword => this.eventKeyword;
    public override VariableDeclarationSyntax Declaration => this.declaration;
    public override SyntaxToken SemicolonToken => this.semicolonToken;

    internal override GreenNode? GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.attributeLists;
            case 1: return this.modifiers;
            case 2: return this.eventKeyword;
            case 3: return this.declaration;
            case 4: return this.semicolonToken;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new CSharp.Syntax.EventFieldDeclarationSyntax(this, parent, position);

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor) => visitor.VisitEventFieldDeclaration(this);

    public override void Accept(CSharpSyntaxVisitor visitor) => visitor.VisitEventFieldDeclaration(this);

    public EventFieldDeclarationSyntax Update(Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<AttributeListSyntax> attributeLists, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SyntaxToken> modifiers, SyntaxToken eventKeyword, VariableDeclarationSyntax declaration, SyntaxToken semicolonToken)
    {
        if (attributeLists != this.AttributeLists || modifiers != this.Modifiers || eventKeyword != this.EventKeyword || declaration != this.Declaration || semicolonToken != this.SemicolonToken)
        {
            var newNode = SyntaxFactory.EventFieldDeclaration(attributeLists, modifiers, eventKeyword, declaration, semicolonToken);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
        => new EventFieldDeclarationSyntax(this.Kind, this.attributeLists, this.modifiers, this.eventKeyword, this.declaration, this.semicolonToken, diagnostics, GetAnnotations());

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
        => new EventFieldDeclarationSyntax(this.Kind, this.attributeLists, this.modifiers, this.eventKeyword, this.declaration, this.semicolonToken, GetDiagnostics(), annotations);

    internal EventFieldDeclarationSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 5;
      var attributeLists = (GreenNode?)reader.ReadValue();
      if (attributeLists != null)
      {
         AdjustFlagsAndWidth(attributeLists);
         this.attributeLists = attributeLists;
      }
      var modifiers = (GreenNode?)reader.ReadValue();
      if (modifiers != null)
      {
         AdjustFlagsAndWidth(modifiers);
         this.modifiers = modifiers;
      }
      var eventKeyword = (SyntaxToken)reader.ReadValue();
      if (eventKeyword != null)
      {
         AdjustFlagsAndWidth(eventKeyword);
         this.eventKeyword = eventKeyword;
      }
      var declaration = (VariableDeclarationSyntax)reader.ReadValue();
      if (declaration != null)
      {
         AdjustFlagsAndWidth(declaration);
         this.declaration = declaration;
      }
      var semicolonToken = (SyntaxToken)reader.ReadValue();
      if (semicolonToken != null)
      {
         AdjustFlagsAndWidth(semicolonToken);
         this.semicolonToken = semicolonToken;
      }
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.attributeLists);
      writer.WriteValue(this.modifiers);
      writer.WriteValue(this.eventKeyword);
      writer.WriteValue(this.declaration);
      writer.WriteValue(this.semicolonToken);
    }

    static EventFieldDeclarationSyntax()
    {
       ObjectBinder.RegisterTypeReader(typeof(EventFieldDeclarationSyntax), r => new EventFieldDeclarationSyntax(r));
    }
  }

  internal sealed partial class ExplicitInterfaceSpecifierSyntax : CSharpSyntaxNode
  {
    internal readonly NameSyntax name;
    internal readonly SyntaxToken dotToken;

    internal ExplicitInterfaceSpecifierSyntax(SyntaxKind kind, NameSyntax name, SyntaxToken dotToken, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 2;
        this.AdjustFlagsAndWidth(name);
        this.name = name;
        this.AdjustFlagsAndWidth(dotToken);
        this.dotToken = dotToken;
    }


    internal ExplicitInterfaceSpecifierSyntax(SyntaxKind kind, NameSyntax name, SyntaxToken dotToken, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 2;
        this.AdjustFlagsAndWidth(name);
        this.name = name;
        this.AdjustFlagsAndWidth(dotToken);
        this.dotToken = dotToken;
    }


    internal ExplicitInterfaceSpecifierSyntax(SyntaxKind kind, NameSyntax name, SyntaxToken dotToken)
        : base(kind)
    {
        this.SlotCount = 2;
        this.AdjustFlagsAndWidth(name);
        this.name = name;
        this.AdjustFlagsAndWidth(dotToken);
        this.dotToken = dotToken;
    }

    public NameSyntax Name => this.name;
    public SyntaxToken DotToken => this.dotToken;

    internal override GreenNode? GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.name;
            case 1: return this.dotToken;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new CSharp.Syntax.ExplicitInterfaceSpecifierSyntax(this, parent, position);

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor) => visitor.VisitExplicitInterfaceSpecifier(this);

    public override void Accept(CSharpSyntaxVisitor visitor) => visitor.VisitExplicitInterfaceSpecifier(this);

    public ExplicitInterfaceSpecifierSyntax Update(NameSyntax name, SyntaxToken dotToken)
    {
        if (name != this.Name || dotToken != this.DotToken)
        {
            var newNode = SyntaxFactory.ExplicitInterfaceSpecifier(name, dotToken);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
        => new ExplicitInterfaceSpecifierSyntax(this.Kind, this.name, this.dotToken, diagnostics, GetAnnotations());

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
        => new ExplicitInterfaceSpecifierSyntax(this.Kind, this.name, this.dotToken, GetDiagnostics(), annotations);

    internal ExplicitInterfaceSpecifierSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 2;
      var name = (NameSyntax)reader.ReadValue();
      if (name != null)
      {
         AdjustFlagsAndWidth(name);
         this.name = name;
      }
      var dotToken = (SyntaxToken)reader.ReadValue();
      if (dotToken != null)
      {
         AdjustFlagsAndWidth(dotToken);
         this.dotToken = dotToken;
      }
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.name);
      writer.WriteValue(this.dotToken);
    }

    static ExplicitInterfaceSpecifierSyntax()
    {
       ObjectBinder.RegisterTypeReader(typeof(ExplicitInterfaceSpecifierSyntax), r => new ExplicitInterfaceSpecifierSyntax(r));
    }
  }

  /// <summary>Base type for method declaration syntax.</summary>
  internal abstract partial class BaseMethodDeclarationSyntax : MemberDeclarationSyntax
  {
    internal BaseMethodDeclarationSyntax(SyntaxKind kind, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
      : base(kind, diagnostics, annotations)
    {
    }
    internal BaseMethodDeclarationSyntax(SyntaxKind kind)
      : base(kind)
    {
    }

    protected BaseMethodDeclarationSyntax(ObjectReader reader)
       : base(reader)
    {
    }

    /// <summary>Gets the parameter list.</summary>
    public abstract ParameterListSyntax ParameterList { get; }

    public abstract BlockSyntax? Body { get; }

    public abstract ArrowExpressionClauseSyntax? ExpressionBody { get; }

    /// <summary>Gets the optional semicolon token.</summary>
    public abstract SyntaxToken? SemicolonToken { get; }
  }

  /// <summary>Method declaration syntax.</summary>
  internal sealed partial class MethodDeclarationSyntax : BaseMethodDeclarationSyntax
  {
    internal readonly GreenNode? attributeLists;
    internal readonly GreenNode? modifiers;
    internal readonly TypeSyntax returnType;
    internal readonly ExplicitInterfaceSpecifierSyntax? explicitInterfaceSpecifier;
    internal readonly SyntaxToken identifier;
    internal readonly TypeParameterListSyntax? typeParameterList;
    internal readonly ParameterListSyntax parameterList;
    internal readonly GreenNode? constraintClauses;
    internal readonly BlockSyntax? body;
    internal readonly ArrowExpressionClauseSyntax? expressionBody;
    internal readonly SyntaxToken? semicolonToken;

    internal MethodDeclarationSyntax(SyntaxKind kind, GreenNode? attributeLists, GreenNode? modifiers, TypeSyntax returnType, ExplicitInterfaceSpecifierSyntax? explicitInterfaceSpecifier, SyntaxToken identifier, TypeParameterListSyntax? typeParameterList, ParameterListSyntax parameterList, GreenNode? constraintClauses, BlockSyntax? body, ArrowExpressionClauseSyntax? expressionBody, SyntaxToken? semicolonToken, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 11;
        if (attributeLists != null)
        {
            this.AdjustFlagsAndWidth(attributeLists);
            this.attributeLists = attributeLists;
        }
        if (modifiers != null)
        {
            this.AdjustFlagsAndWidth(modifiers);
            this.modifiers = modifiers;
        }
        this.AdjustFlagsAndWidth(returnType);
        this.returnType = returnType;
        if (explicitInterfaceSpecifier != null)
        {
            this.AdjustFlagsAndWidth(explicitInterfaceSpecifier);
            this.explicitInterfaceSpecifier = explicitInterfaceSpecifier;
        }
        this.AdjustFlagsAndWidth(identifier);
        this.identifier = identifier;
        if (typeParameterList != null)
        {
            this.AdjustFlagsAndWidth(typeParameterList);
            this.typeParameterList = typeParameterList;
        }
        this.AdjustFlagsAndWidth(parameterList);
        this.parameterList = parameterList;
        if (constraintClauses != null)
        {
            this.AdjustFlagsAndWidth(constraintClauses);
            this.constraintClauses = constraintClauses;
        }
        if (body != null)
        {
            this.AdjustFlagsAndWidth(body);
            this.body = body;
        }
        if (expressionBody != null)
        {
            this.AdjustFlagsAndWidth(expressionBody);
            this.expressionBody = expressionBody;
        }
        if (semicolonToken != null)
        {
            this.AdjustFlagsAndWidth(semicolonToken);
            this.semicolonToken = semicolonToken;
        }
    }


    internal MethodDeclarationSyntax(SyntaxKind kind, GreenNode? attributeLists, GreenNode? modifiers, TypeSyntax returnType, ExplicitInterfaceSpecifierSyntax? explicitInterfaceSpecifier, SyntaxToken identifier, TypeParameterListSyntax? typeParameterList, ParameterListSyntax parameterList, GreenNode? constraintClauses, BlockSyntax? body, ArrowExpressionClauseSyntax? expressionBody, SyntaxToken? semicolonToken, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 11;
        if (attributeLists != null)
        {
            this.AdjustFlagsAndWidth(attributeLists);
            this.attributeLists = attributeLists;
        }
        if (modifiers != null)
        {
            this.AdjustFlagsAndWidth(modifiers);
            this.modifiers = modifiers;
        }
        this.AdjustFlagsAndWidth(returnType);
        this.returnType = returnType;
        if (explicitInterfaceSpecifier != null)
        {
            this.AdjustFlagsAndWidth(explicitInterfaceSpecifier);
            this.explicitInterfaceSpecifier = explicitInterfaceSpecifier;
        }
        this.AdjustFlagsAndWidth(identifier);
        this.identifier = identifier;
        if (typeParameterList != null)
        {
            this.AdjustFlagsAndWidth(typeParameterList);
            this.typeParameterList = typeParameterList;
        }
        this.AdjustFlagsAndWidth(parameterList);
        this.parameterList = parameterList;
        if (constraintClauses != null)
        {
            this.AdjustFlagsAndWidth(constraintClauses);
            this.constraintClauses = constraintClauses;
        }
        if (body != null)
        {
            this.AdjustFlagsAndWidth(body);
            this.body = body;
        }
        if (expressionBody != null)
        {
            this.AdjustFlagsAndWidth(expressionBody);
            this.expressionBody = expressionBody;
        }
        if (semicolonToken != null)
        {
            this.AdjustFlagsAndWidth(semicolonToken);
            this.semicolonToken = semicolonToken;
        }
    }


    internal MethodDeclarationSyntax(SyntaxKind kind, GreenNode? attributeLists, GreenNode? modifiers, TypeSyntax returnType, ExplicitInterfaceSpecifierSyntax? explicitInterfaceSpecifier, SyntaxToken identifier, TypeParameterListSyntax? typeParameterList, ParameterListSyntax parameterList, GreenNode? constraintClauses, BlockSyntax? body, ArrowExpressionClauseSyntax? expressionBody, SyntaxToken? semicolonToken)
        : base(kind)
    {
        this.SlotCount = 11;
        if (attributeLists != null)
        {
            this.AdjustFlagsAndWidth(attributeLists);
            this.attributeLists = attributeLists;
        }
        if (modifiers != null)
        {
            this.AdjustFlagsAndWidth(modifiers);
            this.modifiers = modifiers;
        }
        this.AdjustFlagsAndWidth(returnType);
        this.returnType = returnType;
        if (explicitInterfaceSpecifier != null)
        {
            this.AdjustFlagsAndWidth(explicitInterfaceSpecifier);
            this.explicitInterfaceSpecifier = explicitInterfaceSpecifier;
        }
        this.AdjustFlagsAndWidth(identifier);
        this.identifier = identifier;
        if (typeParameterList != null)
        {
            this.AdjustFlagsAndWidth(typeParameterList);
            this.typeParameterList = typeParameterList;
        }
        this.AdjustFlagsAndWidth(parameterList);
        this.parameterList = parameterList;
        if (constraintClauses != null)
        {
            this.AdjustFlagsAndWidth(constraintClauses);
            this.constraintClauses = constraintClauses;
        }
        if (body != null)
        {
            this.AdjustFlagsAndWidth(body);
            this.body = body;
        }
        if (expressionBody != null)
        {
            this.AdjustFlagsAndWidth(expressionBody);
            this.expressionBody = expressionBody;
        }
        if (semicolonToken != null)
        {
            this.AdjustFlagsAndWidth(semicolonToken);
            this.semicolonToken = semicolonToken;
        }
    }

    public override Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<AttributeListSyntax> AttributeLists => new Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<AttributeListSyntax>(this.attributeLists);
    public override Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SyntaxToken> Modifiers => new Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SyntaxToken>(this.modifiers);
    /// <summary>Gets the return type syntax.</summary>
    public TypeSyntax ReturnType => this.returnType;
    public ExplicitInterfaceSpecifierSyntax? ExplicitInterfaceSpecifier => this.explicitInterfaceSpecifier;
    /// <summary>Gets the identifier.</summary>
    public SyntaxToken Identifier => this.identifier;
    public TypeParameterListSyntax? TypeParameterList => this.typeParameterList;
    public override ParameterListSyntax ParameterList => this.parameterList;
    /// <summary>Gets the constraint clause list.</summary>
    public Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<TypeParameterConstraintClauseSyntax> ConstraintClauses => new Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<TypeParameterConstraintClauseSyntax>(this.constraintClauses);
    public override BlockSyntax? Body => this.body;
    public override ArrowExpressionClauseSyntax? ExpressionBody => this.expressionBody;
    /// <summary>Gets the optional semicolon token.</summary>
    public override SyntaxToken? SemicolonToken => this.semicolonToken;

    internal override GreenNode? GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.attributeLists;
            case 1: return this.modifiers;
            case 2: return this.returnType;
            case 3: return this.explicitInterfaceSpecifier;
            case 4: return this.identifier;
            case 5: return this.typeParameterList;
            case 6: return this.parameterList;
            case 7: return this.constraintClauses;
            case 8: return this.body;
            case 9: return this.expressionBody;
            case 10: return this.semicolonToken;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new CSharp.Syntax.MethodDeclarationSyntax(this, parent, position);

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor) => visitor.VisitMethodDeclaration(this);

    public override void Accept(CSharpSyntaxVisitor visitor) => visitor.VisitMethodDeclaration(this);

    public MethodDeclarationSyntax Update(Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<AttributeListSyntax> attributeLists, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SyntaxToken> modifiers, TypeSyntax returnType, ExplicitInterfaceSpecifierSyntax explicitInterfaceSpecifier, SyntaxToken identifier, TypeParameterListSyntax typeParameterList, ParameterListSyntax parameterList, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<TypeParameterConstraintClauseSyntax> constraintClauses, BlockSyntax body, ArrowExpressionClauseSyntax expressionBody, SyntaxToken semicolonToken)
    {
        if (attributeLists != this.AttributeLists || modifiers != this.Modifiers || returnType != this.ReturnType || explicitInterfaceSpecifier != this.ExplicitInterfaceSpecifier || identifier != this.Identifier || typeParameterList != this.TypeParameterList || parameterList != this.ParameterList || constraintClauses != this.ConstraintClauses || body != this.Body || expressionBody != this.ExpressionBody || semicolonToken != this.SemicolonToken)
        {
            var newNode = SyntaxFactory.MethodDeclaration(attributeLists, modifiers, returnType, explicitInterfaceSpecifier, identifier, typeParameterList, parameterList, constraintClauses, body, expressionBody, semicolonToken);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
        => new MethodDeclarationSyntax(this.Kind, this.attributeLists, this.modifiers, this.returnType, this.explicitInterfaceSpecifier, this.identifier, this.typeParameterList, this.parameterList, this.constraintClauses, this.body, this.expressionBody, this.semicolonToken, diagnostics, GetAnnotations());

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
        => new MethodDeclarationSyntax(this.Kind, this.attributeLists, this.modifiers, this.returnType, this.explicitInterfaceSpecifier, this.identifier, this.typeParameterList, this.parameterList, this.constraintClauses, this.body, this.expressionBody, this.semicolonToken, GetDiagnostics(), annotations);

    internal MethodDeclarationSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 11;
      var attributeLists = (GreenNode?)reader.ReadValue();
      if (attributeLists != null)
      {
         AdjustFlagsAndWidth(attributeLists);
         this.attributeLists = attributeLists;
      }
      var modifiers = (GreenNode?)reader.ReadValue();
      if (modifiers != null)
      {
         AdjustFlagsAndWidth(modifiers);
         this.modifiers = modifiers;
      }
      var returnType = (TypeSyntax)reader.ReadValue();
      if (returnType != null)
      {
         AdjustFlagsAndWidth(returnType);
         this.returnType = returnType;
      }
      var explicitInterfaceSpecifier = (ExplicitInterfaceSpecifierSyntax?)reader.ReadValue();
      if (explicitInterfaceSpecifier != null)
      {
         AdjustFlagsAndWidth(explicitInterfaceSpecifier);
         this.explicitInterfaceSpecifier = explicitInterfaceSpecifier;
      }
      var identifier = (SyntaxToken)reader.ReadValue();
      if (identifier != null)
      {
         AdjustFlagsAndWidth(identifier);
         this.identifier = identifier;
      }
      var typeParameterList = (TypeParameterListSyntax?)reader.ReadValue();
      if (typeParameterList != null)
      {
         AdjustFlagsAndWidth(typeParameterList);
         this.typeParameterList = typeParameterList;
      }
      var parameterList = (ParameterListSyntax)reader.ReadValue();
      if (parameterList != null)
      {
         AdjustFlagsAndWidth(parameterList);
         this.parameterList = parameterList;
      }
      var constraintClauses = (GreenNode?)reader.ReadValue();
      if (constraintClauses != null)
      {
         AdjustFlagsAndWidth(constraintClauses);
         this.constraintClauses = constraintClauses;
      }
      var body = (BlockSyntax?)reader.ReadValue();
      if (body != null)
      {
         AdjustFlagsAndWidth(body);
         this.body = body;
      }
      var expressionBody = (ArrowExpressionClauseSyntax?)reader.ReadValue();
      if (expressionBody != null)
      {
         AdjustFlagsAndWidth(expressionBody);
         this.expressionBody = expressionBody;
      }
      var semicolonToken = (SyntaxToken?)reader.ReadValue();
      if (semicolonToken != null)
      {
         AdjustFlagsAndWidth(semicolonToken);
         this.semicolonToken = semicolonToken;
      }
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.attributeLists);
      writer.WriteValue(this.modifiers);
      writer.WriteValue(this.returnType);
      writer.WriteValue(this.explicitInterfaceSpecifier);
      writer.WriteValue(this.identifier);
      writer.WriteValue(this.typeParameterList);
      writer.WriteValue(this.parameterList);
      writer.WriteValue(this.constraintClauses);
      writer.WriteValue(this.body);
      writer.WriteValue(this.expressionBody);
      writer.WriteValue(this.semicolonToken);
    }

    static MethodDeclarationSyntax()
    {
       ObjectBinder.RegisterTypeReader(typeof(MethodDeclarationSyntax), r => new MethodDeclarationSyntax(r));
    }
  }

  /// <summary>Operator declaration syntax.</summary>
  internal sealed partial class OperatorDeclarationSyntax : BaseMethodDeclarationSyntax
  {
    internal readonly GreenNode? attributeLists;
    internal readonly GreenNode? modifiers;
    internal readonly TypeSyntax returnType;
    internal readonly SyntaxToken operatorKeyword;
    internal readonly SyntaxToken operatorToken;
    internal readonly ParameterListSyntax parameterList;
    internal readonly BlockSyntax? body;
    internal readonly ArrowExpressionClauseSyntax? expressionBody;
    internal readonly SyntaxToken? semicolonToken;

    internal OperatorDeclarationSyntax(SyntaxKind kind, GreenNode? attributeLists, GreenNode? modifiers, TypeSyntax returnType, SyntaxToken operatorKeyword, SyntaxToken operatorToken, ParameterListSyntax parameterList, BlockSyntax? body, ArrowExpressionClauseSyntax? expressionBody, SyntaxToken? semicolonToken, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 9;
        if (attributeLists != null)
        {
            this.AdjustFlagsAndWidth(attributeLists);
            this.attributeLists = attributeLists;
        }
        if (modifiers != null)
        {
            this.AdjustFlagsAndWidth(modifiers);
            this.modifiers = modifiers;
        }
        this.AdjustFlagsAndWidth(returnType);
        this.returnType = returnType;
        this.AdjustFlagsAndWidth(operatorKeyword);
        this.operatorKeyword = operatorKeyword;
        this.AdjustFlagsAndWidth(operatorToken);
        this.operatorToken = operatorToken;
        this.AdjustFlagsAndWidth(parameterList);
        this.parameterList = parameterList;
        if (body != null)
        {
            this.AdjustFlagsAndWidth(body);
            this.body = body;
        }
        if (expressionBody != null)
        {
            this.AdjustFlagsAndWidth(expressionBody);
            this.expressionBody = expressionBody;
        }
        if (semicolonToken != null)
        {
            this.AdjustFlagsAndWidth(semicolonToken);
            this.semicolonToken = semicolonToken;
        }
    }


    internal OperatorDeclarationSyntax(SyntaxKind kind, GreenNode? attributeLists, GreenNode? modifiers, TypeSyntax returnType, SyntaxToken operatorKeyword, SyntaxToken operatorToken, ParameterListSyntax parameterList, BlockSyntax? body, ArrowExpressionClauseSyntax? expressionBody, SyntaxToken? semicolonToken, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 9;
        if (attributeLists != null)
        {
            this.AdjustFlagsAndWidth(attributeLists);
            this.attributeLists = attributeLists;
        }
        if (modifiers != null)
        {
            this.AdjustFlagsAndWidth(modifiers);
            this.modifiers = modifiers;
        }
        this.AdjustFlagsAndWidth(returnType);
        this.returnType = returnType;
        this.AdjustFlagsAndWidth(operatorKeyword);
        this.operatorKeyword = operatorKeyword;
        this.AdjustFlagsAndWidth(operatorToken);
        this.operatorToken = operatorToken;
        this.AdjustFlagsAndWidth(parameterList);
        this.parameterList = parameterList;
        if (body != null)
        {
            this.AdjustFlagsAndWidth(body);
            this.body = body;
        }
        if (expressionBody != null)
        {
            this.AdjustFlagsAndWidth(expressionBody);
            this.expressionBody = expressionBody;
        }
        if (semicolonToken != null)
        {
            this.AdjustFlagsAndWidth(semicolonToken);
            this.semicolonToken = semicolonToken;
        }
    }


    internal OperatorDeclarationSyntax(SyntaxKind kind, GreenNode? attributeLists, GreenNode? modifiers, TypeSyntax returnType, SyntaxToken operatorKeyword, SyntaxToken operatorToken, ParameterListSyntax parameterList, BlockSyntax? body, ArrowExpressionClauseSyntax? expressionBody, SyntaxToken? semicolonToken)
        : base(kind)
    {
        this.SlotCount = 9;
        if (attributeLists != null)
        {
            this.AdjustFlagsAndWidth(attributeLists);
            this.attributeLists = attributeLists;
        }
        if (modifiers != null)
        {
            this.AdjustFlagsAndWidth(modifiers);
            this.modifiers = modifiers;
        }
        this.AdjustFlagsAndWidth(returnType);
        this.returnType = returnType;
        this.AdjustFlagsAndWidth(operatorKeyword);
        this.operatorKeyword = operatorKeyword;
        this.AdjustFlagsAndWidth(operatorToken);
        this.operatorToken = operatorToken;
        this.AdjustFlagsAndWidth(parameterList);
        this.parameterList = parameterList;
        if (body != null)
        {
            this.AdjustFlagsAndWidth(body);
            this.body = body;
        }
        if (expressionBody != null)
        {
            this.AdjustFlagsAndWidth(expressionBody);
            this.expressionBody = expressionBody;
        }
        if (semicolonToken != null)
        {
            this.AdjustFlagsAndWidth(semicolonToken);
            this.semicolonToken = semicolonToken;
        }
    }

    public override Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<AttributeListSyntax> AttributeLists => new Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<AttributeListSyntax>(this.attributeLists);
    public override Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SyntaxToken> Modifiers => new Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SyntaxToken>(this.modifiers);
    /// <summary>Gets the return type.</summary>
    public TypeSyntax ReturnType => this.returnType;
    /// <summary>Gets the "operator" keyword.</summary>
    public SyntaxToken OperatorKeyword => this.operatorKeyword;
    /// <summary>Gets the operator token.</summary>
    public SyntaxToken OperatorToken => this.operatorToken;
    public override ParameterListSyntax ParameterList => this.parameterList;
    public override BlockSyntax? Body => this.body;
    public override ArrowExpressionClauseSyntax? ExpressionBody => this.expressionBody;
    public override SyntaxToken? SemicolonToken => this.semicolonToken;

    internal override GreenNode? GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.attributeLists;
            case 1: return this.modifiers;
            case 2: return this.returnType;
            case 3: return this.operatorKeyword;
            case 4: return this.operatorToken;
            case 5: return this.parameterList;
            case 6: return this.body;
            case 7: return this.expressionBody;
            case 8: return this.semicolonToken;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new CSharp.Syntax.OperatorDeclarationSyntax(this, parent, position);

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor) => visitor.VisitOperatorDeclaration(this);

    public override void Accept(CSharpSyntaxVisitor visitor) => visitor.VisitOperatorDeclaration(this);

    public OperatorDeclarationSyntax Update(Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<AttributeListSyntax> attributeLists, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SyntaxToken> modifiers, TypeSyntax returnType, SyntaxToken operatorKeyword, SyntaxToken operatorToken, ParameterListSyntax parameterList, BlockSyntax body, ArrowExpressionClauseSyntax expressionBody, SyntaxToken semicolonToken)
    {
        if (attributeLists != this.AttributeLists || modifiers != this.Modifiers || returnType != this.ReturnType || operatorKeyword != this.OperatorKeyword || operatorToken != this.OperatorToken || parameterList != this.ParameterList || body != this.Body || expressionBody != this.ExpressionBody || semicolonToken != this.SemicolonToken)
        {
            var newNode = SyntaxFactory.OperatorDeclaration(attributeLists, modifiers, returnType, operatorKeyword, operatorToken, parameterList, body, expressionBody, semicolonToken);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
        => new OperatorDeclarationSyntax(this.Kind, this.attributeLists, this.modifiers, this.returnType, this.operatorKeyword, this.operatorToken, this.parameterList, this.body, this.expressionBody, this.semicolonToken, diagnostics, GetAnnotations());

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
        => new OperatorDeclarationSyntax(this.Kind, this.attributeLists, this.modifiers, this.returnType, this.operatorKeyword, this.operatorToken, this.parameterList, this.body, this.expressionBody, this.semicolonToken, GetDiagnostics(), annotations);

    internal OperatorDeclarationSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 9;
      var attributeLists = (GreenNode?)reader.ReadValue();
      if (attributeLists != null)
      {
         AdjustFlagsAndWidth(attributeLists);
         this.attributeLists = attributeLists;
      }
      var modifiers = (GreenNode?)reader.ReadValue();
      if (modifiers != null)
      {
         AdjustFlagsAndWidth(modifiers);
         this.modifiers = modifiers;
      }
      var returnType = (TypeSyntax)reader.ReadValue();
      if (returnType != null)
      {
         AdjustFlagsAndWidth(returnType);
         this.returnType = returnType;
      }
      var operatorKeyword = (SyntaxToken)reader.ReadValue();
      if (operatorKeyword != null)
      {
         AdjustFlagsAndWidth(operatorKeyword);
         this.operatorKeyword = operatorKeyword;
      }
      var operatorToken = (SyntaxToken)reader.ReadValue();
      if (operatorToken != null)
      {
         AdjustFlagsAndWidth(operatorToken);
         this.operatorToken = operatorToken;
      }
      var parameterList = (ParameterListSyntax)reader.ReadValue();
      if (parameterList != null)
      {
         AdjustFlagsAndWidth(parameterList);
         this.parameterList = parameterList;
      }
      var body = (BlockSyntax?)reader.ReadValue();
      if (body != null)
      {
         AdjustFlagsAndWidth(body);
         this.body = body;
      }
      var expressionBody = (ArrowExpressionClauseSyntax?)reader.ReadValue();
      if (expressionBody != null)
      {
         AdjustFlagsAndWidth(expressionBody);
         this.expressionBody = expressionBody;
      }
      var semicolonToken = (SyntaxToken?)reader.ReadValue();
      if (semicolonToken != null)
      {
         AdjustFlagsAndWidth(semicolonToken);
         this.semicolonToken = semicolonToken;
      }
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.attributeLists);
      writer.WriteValue(this.modifiers);
      writer.WriteValue(this.returnType);
      writer.WriteValue(this.operatorKeyword);
      writer.WriteValue(this.operatorToken);
      writer.WriteValue(this.parameterList);
      writer.WriteValue(this.body);
      writer.WriteValue(this.expressionBody);
      writer.WriteValue(this.semicolonToken);
    }

    static OperatorDeclarationSyntax()
    {
       ObjectBinder.RegisterTypeReader(typeof(OperatorDeclarationSyntax), r => new OperatorDeclarationSyntax(r));
    }
  }

  /// <summary>Conversion operator declaration syntax.</summary>
  internal sealed partial class ConversionOperatorDeclarationSyntax : BaseMethodDeclarationSyntax
  {
    internal readonly GreenNode? attributeLists;
    internal readonly GreenNode? modifiers;
    internal readonly SyntaxToken implicitOrExplicitKeyword;
    internal readonly SyntaxToken operatorKeyword;
    internal readonly TypeSyntax type;
    internal readonly ParameterListSyntax parameterList;
    internal readonly BlockSyntax? body;
    internal readonly ArrowExpressionClauseSyntax? expressionBody;
    internal readonly SyntaxToken? semicolonToken;

    internal ConversionOperatorDeclarationSyntax(SyntaxKind kind, GreenNode? attributeLists, GreenNode? modifiers, SyntaxToken implicitOrExplicitKeyword, SyntaxToken operatorKeyword, TypeSyntax type, ParameterListSyntax parameterList, BlockSyntax? body, ArrowExpressionClauseSyntax? expressionBody, SyntaxToken? semicolonToken, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 9;
        if (attributeLists != null)
        {
            this.AdjustFlagsAndWidth(attributeLists);
            this.attributeLists = attributeLists;
        }
        if (modifiers != null)
        {
            this.AdjustFlagsAndWidth(modifiers);
            this.modifiers = modifiers;
        }
        this.AdjustFlagsAndWidth(implicitOrExplicitKeyword);
        this.implicitOrExplicitKeyword = implicitOrExplicitKeyword;
        this.AdjustFlagsAndWidth(operatorKeyword);
        this.operatorKeyword = operatorKeyword;
        this.AdjustFlagsAndWidth(type);
        this.type = type;
        this.AdjustFlagsAndWidth(parameterList);
        this.parameterList = parameterList;
        if (body != null)
        {
            this.AdjustFlagsAndWidth(body);
            this.body = body;
        }
        if (expressionBody != null)
        {
            this.AdjustFlagsAndWidth(expressionBody);
            this.expressionBody = expressionBody;
        }
        if (semicolonToken != null)
        {
            this.AdjustFlagsAndWidth(semicolonToken);
            this.semicolonToken = semicolonToken;
        }
    }


    internal ConversionOperatorDeclarationSyntax(SyntaxKind kind, GreenNode? attributeLists, GreenNode? modifiers, SyntaxToken implicitOrExplicitKeyword, SyntaxToken operatorKeyword, TypeSyntax type, ParameterListSyntax parameterList, BlockSyntax? body, ArrowExpressionClauseSyntax? expressionBody, SyntaxToken? semicolonToken, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 9;
        if (attributeLists != null)
        {
            this.AdjustFlagsAndWidth(attributeLists);
            this.attributeLists = attributeLists;
        }
        if (modifiers != null)
        {
            this.AdjustFlagsAndWidth(modifiers);
            this.modifiers = modifiers;
        }
        this.AdjustFlagsAndWidth(implicitOrExplicitKeyword);
        this.implicitOrExplicitKeyword = implicitOrExplicitKeyword;
        this.AdjustFlagsAndWidth(operatorKeyword);
        this.operatorKeyword = operatorKeyword;
        this.AdjustFlagsAndWidth(type);
        this.type = type;
        this.AdjustFlagsAndWidth(parameterList);
        this.parameterList = parameterList;
        if (body != null)
        {
            this.AdjustFlagsAndWidth(body);
            this.body = body;
        }
        if (expressionBody != null)
        {
            this.AdjustFlagsAndWidth(expressionBody);
            this.expressionBody = expressionBody;
        }
        if (semicolonToken != null)
        {
            this.AdjustFlagsAndWidth(semicolonToken);
            this.semicolonToken = semicolonToken;
        }
    }


    internal ConversionOperatorDeclarationSyntax(SyntaxKind kind, GreenNode? attributeLists, GreenNode? modifiers, SyntaxToken implicitOrExplicitKeyword, SyntaxToken operatorKeyword, TypeSyntax type, ParameterListSyntax parameterList, BlockSyntax? body, ArrowExpressionClauseSyntax? expressionBody, SyntaxToken? semicolonToken)
        : base(kind)
    {
        this.SlotCount = 9;
        if (attributeLists != null)
        {
            this.AdjustFlagsAndWidth(attributeLists);
            this.attributeLists = attributeLists;
        }
        if (modifiers != null)
        {
            this.AdjustFlagsAndWidth(modifiers);
            this.modifiers = modifiers;
        }
        this.AdjustFlagsAndWidth(implicitOrExplicitKeyword);
        this.implicitOrExplicitKeyword = implicitOrExplicitKeyword;
        this.AdjustFlagsAndWidth(operatorKeyword);
        this.operatorKeyword = operatorKeyword;
        this.AdjustFlagsAndWidth(type);
        this.type = type;
        this.AdjustFlagsAndWidth(parameterList);
        this.parameterList = parameterList;
        if (body != null)
        {
            this.AdjustFlagsAndWidth(body);
            this.body = body;
        }
        if (expressionBody != null)
        {
            this.AdjustFlagsAndWidth(expressionBody);
            this.expressionBody = expressionBody;
        }
        if (semicolonToken != null)
        {
            this.AdjustFlagsAndWidth(semicolonToken);
            this.semicolonToken = semicolonToken;
        }
    }

    public override Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<AttributeListSyntax> AttributeLists => new Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<AttributeListSyntax>(this.attributeLists);
    public override Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SyntaxToken> Modifiers => new Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SyntaxToken>(this.modifiers);
    /// <summary>Gets the "implicit" or "explicit" token.</summary>
    public SyntaxToken ImplicitOrExplicitKeyword => this.implicitOrExplicitKeyword;
    /// <summary>Gets the "operator" token.</summary>
    public SyntaxToken OperatorKeyword => this.operatorKeyword;
    /// <summary>Gets the type.</summary>
    public TypeSyntax Type => this.type;
    public override ParameterListSyntax ParameterList => this.parameterList;
    public override BlockSyntax? Body => this.body;
    public override ArrowExpressionClauseSyntax? ExpressionBody => this.expressionBody;
    /// <summary>Gets the optional semicolon token.</summary>
    public override SyntaxToken? SemicolonToken => this.semicolonToken;

    internal override GreenNode? GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.attributeLists;
            case 1: return this.modifiers;
            case 2: return this.implicitOrExplicitKeyword;
            case 3: return this.operatorKeyword;
            case 4: return this.type;
            case 5: return this.parameterList;
            case 6: return this.body;
            case 7: return this.expressionBody;
            case 8: return this.semicolonToken;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new CSharp.Syntax.ConversionOperatorDeclarationSyntax(this, parent, position);

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor) => visitor.VisitConversionOperatorDeclaration(this);

    public override void Accept(CSharpSyntaxVisitor visitor) => visitor.VisitConversionOperatorDeclaration(this);

    public ConversionOperatorDeclarationSyntax Update(Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<AttributeListSyntax> attributeLists, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SyntaxToken> modifiers, SyntaxToken implicitOrExplicitKeyword, SyntaxToken operatorKeyword, TypeSyntax type, ParameterListSyntax parameterList, BlockSyntax body, ArrowExpressionClauseSyntax expressionBody, SyntaxToken semicolonToken)
    {
        if (attributeLists != this.AttributeLists || modifiers != this.Modifiers || implicitOrExplicitKeyword != this.ImplicitOrExplicitKeyword || operatorKeyword != this.OperatorKeyword || type != this.Type || parameterList != this.ParameterList || body != this.Body || expressionBody != this.ExpressionBody || semicolonToken != this.SemicolonToken)
        {
            var newNode = SyntaxFactory.ConversionOperatorDeclaration(attributeLists, modifiers, implicitOrExplicitKeyword, operatorKeyword, type, parameterList, body, expressionBody, semicolonToken);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
        => new ConversionOperatorDeclarationSyntax(this.Kind, this.attributeLists, this.modifiers, this.implicitOrExplicitKeyword, this.operatorKeyword, this.type, this.parameterList, this.body, this.expressionBody, this.semicolonToken, diagnostics, GetAnnotations());

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
        => new ConversionOperatorDeclarationSyntax(this.Kind, this.attributeLists, this.modifiers, this.implicitOrExplicitKeyword, this.operatorKeyword, this.type, this.parameterList, this.body, this.expressionBody, this.semicolonToken, GetDiagnostics(), annotations);

    internal ConversionOperatorDeclarationSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 9;
      var attributeLists = (GreenNode?)reader.ReadValue();
      if (attributeLists != null)
      {
         AdjustFlagsAndWidth(attributeLists);
         this.attributeLists = attributeLists;
      }
      var modifiers = (GreenNode?)reader.ReadValue();
      if (modifiers != null)
      {
         AdjustFlagsAndWidth(modifiers);
         this.modifiers = modifiers;
      }
      var implicitOrExplicitKeyword = (SyntaxToken)reader.ReadValue();
      if (implicitOrExplicitKeyword != null)
      {
         AdjustFlagsAndWidth(implicitOrExplicitKeyword);
         this.implicitOrExplicitKeyword = implicitOrExplicitKeyword;
      }
      var operatorKeyword = (SyntaxToken)reader.ReadValue();
      if (operatorKeyword != null)
      {
         AdjustFlagsAndWidth(operatorKeyword);
         this.operatorKeyword = operatorKeyword;
      }
      var type = (TypeSyntax)reader.ReadValue();
      if (type != null)
      {
         AdjustFlagsAndWidth(type);
         this.type = type;
      }
      var parameterList = (ParameterListSyntax)reader.ReadValue();
      if (parameterList != null)
      {
         AdjustFlagsAndWidth(parameterList);
         this.parameterList = parameterList;
      }
      var body = (BlockSyntax?)reader.ReadValue();
      if (body != null)
      {
         AdjustFlagsAndWidth(body);
         this.body = body;
      }
      var expressionBody = (ArrowExpressionClauseSyntax?)reader.ReadValue();
      if (expressionBody != null)
      {
         AdjustFlagsAndWidth(expressionBody);
         this.expressionBody = expressionBody;
      }
      var semicolonToken = (SyntaxToken?)reader.ReadValue();
      if (semicolonToken != null)
      {
         AdjustFlagsAndWidth(semicolonToken);
         this.semicolonToken = semicolonToken;
      }
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.attributeLists);
      writer.WriteValue(this.modifiers);
      writer.WriteValue(this.implicitOrExplicitKeyword);
      writer.WriteValue(this.operatorKeyword);
      writer.WriteValue(this.type);
      writer.WriteValue(this.parameterList);
      writer.WriteValue(this.body);
      writer.WriteValue(this.expressionBody);
      writer.WriteValue(this.semicolonToken);
    }

    static ConversionOperatorDeclarationSyntax()
    {
       ObjectBinder.RegisterTypeReader(typeof(ConversionOperatorDeclarationSyntax), r => new ConversionOperatorDeclarationSyntax(r));
    }
  }

  /// <summary>Constructor declaration syntax.</summary>
  internal sealed partial class ConstructorDeclarationSyntax : BaseMethodDeclarationSyntax
  {
    internal readonly GreenNode? attributeLists;
    internal readonly GreenNode? modifiers;
    internal readonly SyntaxToken identifier;
    internal readonly ParameterListSyntax parameterList;
    internal readonly ConstructorInitializerSyntax? initializer;
    internal readonly BlockSyntax? body;
    internal readonly ArrowExpressionClauseSyntax? expressionBody;
    internal readonly SyntaxToken? semicolonToken;

    internal ConstructorDeclarationSyntax(SyntaxKind kind, GreenNode? attributeLists, GreenNode? modifiers, SyntaxToken identifier, ParameterListSyntax parameterList, ConstructorInitializerSyntax? initializer, BlockSyntax? body, ArrowExpressionClauseSyntax? expressionBody, SyntaxToken? semicolonToken, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 8;
        if (attributeLists != null)
        {
            this.AdjustFlagsAndWidth(attributeLists);
            this.attributeLists = attributeLists;
        }
        if (modifiers != null)
        {
            this.AdjustFlagsAndWidth(modifiers);
            this.modifiers = modifiers;
        }
        this.AdjustFlagsAndWidth(identifier);
        this.identifier = identifier;
        this.AdjustFlagsAndWidth(parameterList);
        this.parameterList = parameterList;
        if (initializer != null)
        {
            this.AdjustFlagsAndWidth(initializer);
            this.initializer = initializer;
        }
        if (body != null)
        {
            this.AdjustFlagsAndWidth(body);
            this.body = body;
        }
        if (expressionBody != null)
        {
            this.AdjustFlagsAndWidth(expressionBody);
            this.expressionBody = expressionBody;
        }
        if (semicolonToken != null)
        {
            this.AdjustFlagsAndWidth(semicolonToken);
            this.semicolonToken = semicolonToken;
        }
    }


    internal ConstructorDeclarationSyntax(SyntaxKind kind, GreenNode? attributeLists, GreenNode? modifiers, SyntaxToken identifier, ParameterListSyntax parameterList, ConstructorInitializerSyntax? initializer, BlockSyntax? body, ArrowExpressionClauseSyntax? expressionBody, SyntaxToken? semicolonToken, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 8;
        if (attributeLists != null)
        {
            this.AdjustFlagsAndWidth(attributeLists);
            this.attributeLists = attributeLists;
        }
        if (modifiers != null)
        {
            this.AdjustFlagsAndWidth(modifiers);
            this.modifiers = modifiers;
        }
        this.AdjustFlagsAndWidth(identifier);
        this.identifier = identifier;
        this.AdjustFlagsAndWidth(parameterList);
        this.parameterList = parameterList;
        if (initializer != null)
        {
            this.AdjustFlagsAndWidth(initializer);
            this.initializer = initializer;
        }
        if (body != null)
        {
            this.AdjustFlagsAndWidth(body);
            this.body = body;
        }
        if (expressionBody != null)
        {
            this.AdjustFlagsAndWidth(expressionBody);
            this.expressionBody = expressionBody;
        }
        if (semicolonToken != null)
        {
            this.AdjustFlagsAndWidth(semicolonToken);
            this.semicolonToken = semicolonToken;
        }
    }


    internal ConstructorDeclarationSyntax(SyntaxKind kind, GreenNode? attributeLists, GreenNode? modifiers, SyntaxToken identifier, ParameterListSyntax parameterList, ConstructorInitializerSyntax? initializer, BlockSyntax? body, ArrowExpressionClauseSyntax? expressionBody, SyntaxToken? semicolonToken)
        : base(kind)
    {
        this.SlotCount = 8;
        if (attributeLists != null)
        {
            this.AdjustFlagsAndWidth(attributeLists);
            this.attributeLists = attributeLists;
        }
        if (modifiers != null)
        {
            this.AdjustFlagsAndWidth(modifiers);
            this.modifiers = modifiers;
        }
        this.AdjustFlagsAndWidth(identifier);
        this.identifier = identifier;
        this.AdjustFlagsAndWidth(parameterList);
        this.parameterList = parameterList;
        if (initializer != null)
        {
            this.AdjustFlagsAndWidth(initializer);
            this.initializer = initializer;
        }
        if (body != null)
        {
            this.AdjustFlagsAndWidth(body);
            this.body = body;
        }
        if (expressionBody != null)
        {
            this.AdjustFlagsAndWidth(expressionBody);
            this.expressionBody = expressionBody;
        }
        if (semicolonToken != null)
        {
            this.AdjustFlagsAndWidth(semicolonToken);
            this.semicolonToken = semicolonToken;
        }
    }

    public override Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<AttributeListSyntax> AttributeLists => new Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<AttributeListSyntax>(this.attributeLists);
    public override Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SyntaxToken> Modifiers => new Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SyntaxToken>(this.modifiers);
    /// <summary>Gets the identifier.</summary>
    public SyntaxToken Identifier => this.identifier;
    public override ParameterListSyntax ParameterList => this.parameterList;
    public ConstructorInitializerSyntax? Initializer => this.initializer;
    public override BlockSyntax? Body => this.body;
    public override ArrowExpressionClauseSyntax? ExpressionBody => this.expressionBody;
    /// <summary>Gets the optional semicolon token.</summary>
    public override SyntaxToken? SemicolonToken => this.semicolonToken;

    internal override GreenNode? GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.attributeLists;
            case 1: return this.modifiers;
            case 2: return this.identifier;
            case 3: return this.parameterList;
            case 4: return this.initializer;
            case 5: return this.body;
            case 6: return this.expressionBody;
            case 7: return this.semicolonToken;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new CSharp.Syntax.ConstructorDeclarationSyntax(this, parent, position);

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor) => visitor.VisitConstructorDeclaration(this);

    public override void Accept(CSharpSyntaxVisitor visitor) => visitor.VisitConstructorDeclaration(this);

    public ConstructorDeclarationSyntax Update(Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<AttributeListSyntax> attributeLists, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SyntaxToken> modifiers, SyntaxToken identifier, ParameterListSyntax parameterList, ConstructorInitializerSyntax initializer, BlockSyntax body, ArrowExpressionClauseSyntax expressionBody, SyntaxToken semicolonToken)
    {
        if (attributeLists != this.AttributeLists || modifiers != this.Modifiers || identifier != this.Identifier || parameterList != this.ParameterList || initializer != this.Initializer || body != this.Body || expressionBody != this.ExpressionBody || semicolonToken != this.SemicolonToken)
        {
            var newNode = SyntaxFactory.ConstructorDeclaration(attributeLists, modifiers, identifier, parameterList, initializer, body, expressionBody, semicolonToken);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
        => new ConstructorDeclarationSyntax(this.Kind, this.attributeLists, this.modifiers, this.identifier, this.parameterList, this.initializer, this.body, this.expressionBody, this.semicolonToken, diagnostics, GetAnnotations());

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
        => new ConstructorDeclarationSyntax(this.Kind, this.attributeLists, this.modifiers, this.identifier, this.parameterList, this.initializer, this.body, this.expressionBody, this.semicolonToken, GetDiagnostics(), annotations);

    internal ConstructorDeclarationSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 8;
      var attributeLists = (GreenNode?)reader.ReadValue();
      if (attributeLists != null)
      {
         AdjustFlagsAndWidth(attributeLists);
         this.attributeLists = attributeLists;
      }
      var modifiers = (GreenNode?)reader.ReadValue();
      if (modifiers != null)
      {
         AdjustFlagsAndWidth(modifiers);
         this.modifiers = modifiers;
      }
      var identifier = (SyntaxToken)reader.ReadValue();
      if (identifier != null)
      {
         AdjustFlagsAndWidth(identifier);
         this.identifier = identifier;
      }
      var parameterList = (ParameterListSyntax)reader.ReadValue();
      if (parameterList != null)
      {
         AdjustFlagsAndWidth(parameterList);
         this.parameterList = parameterList;
      }
      var initializer = (ConstructorInitializerSyntax?)reader.ReadValue();
      if (initializer != null)
      {
         AdjustFlagsAndWidth(initializer);
         this.initializer = initializer;
      }
      var body = (BlockSyntax?)reader.ReadValue();
      if (body != null)
      {
         AdjustFlagsAndWidth(body);
         this.body = body;
      }
      var expressionBody = (ArrowExpressionClauseSyntax?)reader.ReadValue();
      if (expressionBody != null)
      {
         AdjustFlagsAndWidth(expressionBody);
         this.expressionBody = expressionBody;
      }
      var semicolonToken = (SyntaxToken?)reader.ReadValue();
      if (semicolonToken != null)
      {
         AdjustFlagsAndWidth(semicolonToken);
         this.semicolonToken = semicolonToken;
      }
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.attributeLists);
      writer.WriteValue(this.modifiers);
      writer.WriteValue(this.identifier);
      writer.WriteValue(this.parameterList);
      writer.WriteValue(this.initializer);
      writer.WriteValue(this.body);
      writer.WriteValue(this.expressionBody);
      writer.WriteValue(this.semicolonToken);
    }

    static ConstructorDeclarationSyntax()
    {
       ObjectBinder.RegisterTypeReader(typeof(ConstructorDeclarationSyntax), r => new ConstructorDeclarationSyntax(r));
    }
  }

  /// <summary>Constructor initializer syntax.</summary>
  internal sealed partial class ConstructorInitializerSyntax : CSharpSyntaxNode
  {
    internal readonly SyntaxToken colonToken;
    internal readonly SyntaxToken thisOrBaseKeyword;
    internal readonly ArgumentListSyntax argumentList;

    internal ConstructorInitializerSyntax(SyntaxKind kind, SyntaxToken colonToken, SyntaxToken thisOrBaseKeyword, ArgumentListSyntax argumentList, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 3;
        this.AdjustFlagsAndWidth(colonToken);
        this.colonToken = colonToken;
        this.AdjustFlagsAndWidth(thisOrBaseKeyword);
        this.thisOrBaseKeyword = thisOrBaseKeyword;
        this.AdjustFlagsAndWidth(argumentList);
        this.argumentList = argumentList;
    }


    internal ConstructorInitializerSyntax(SyntaxKind kind, SyntaxToken colonToken, SyntaxToken thisOrBaseKeyword, ArgumentListSyntax argumentList, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 3;
        this.AdjustFlagsAndWidth(colonToken);
        this.colonToken = colonToken;
        this.AdjustFlagsAndWidth(thisOrBaseKeyword);
        this.thisOrBaseKeyword = thisOrBaseKeyword;
        this.AdjustFlagsAndWidth(argumentList);
        this.argumentList = argumentList;
    }


    internal ConstructorInitializerSyntax(SyntaxKind kind, SyntaxToken colonToken, SyntaxToken thisOrBaseKeyword, ArgumentListSyntax argumentList)
        : base(kind)
    {
        this.SlotCount = 3;
        this.AdjustFlagsAndWidth(colonToken);
        this.colonToken = colonToken;
        this.AdjustFlagsAndWidth(thisOrBaseKeyword);
        this.thisOrBaseKeyword = thisOrBaseKeyword;
        this.AdjustFlagsAndWidth(argumentList);
        this.argumentList = argumentList;
    }

    /// <summary>Gets the colon token.</summary>
    public SyntaxToken ColonToken => this.colonToken;
    /// <summary>Gets the "this" or "base" keyword.</summary>
    public SyntaxToken ThisOrBaseKeyword => this.thisOrBaseKeyword;
    public ArgumentListSyntax ArgumentList => this.argumentList;

    internal override GreenNode? GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.colonToken;
            case 1: return this.thisOrBaseKeyword;
            case 2: return this.argumentList;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new CSharp.Syntax.ConstructorInitializerSyntax(this, parent, position);

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor) => visitor.VisitConstructorInitializer(this);

    public override void Accept(CSharpSyntaxVisitor visitor) => visitor.VisitConstructorInitializer(this);

    public ConstructorInitializerSyntax Update(SyntaxToken colonToken, SyntaxToken thisOrBaseKeyword, ArgumentListSyntax argumentList)
    {
        if (colonToken != this.ColonToken || thisOrBaseKeyword != this.ThisOrBaseKeyword || argumentList != this.ArgumentList)
        {
            var newNode = SyntaxFactory.ConstructorInitializer(this.Kind, colonToken, thisOrBaseKeyword, argumentList);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
        => new ConstructorInitializerSyntax(this.Kind, this.colonToken, this.thisOrBaseKeyword, this.argumentList, diagnostics, GetAnnotations());

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
        => new ConstructorInitializerSyntax(this.Kind, this.colonToken, this.thisOrBaseKeyword, this.argumentList, GetDiagnostics(), annotations);

    internal ConstructorInitializerSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 3;
      var colonToken = (SyntaxToken)reader.ReadValue();
      if (colonToken != null)
      {
         AdjustFlagsAndWidth(colonToken);
         this.colonToken = colonToken;
      }
      var thisOrBaseKeyword = (SyntaxToken)reader.ReadValue();
      if (thisOrBaseKeyword != null)
      {
         AdjustFlagsAndWidth(thisOrBaseKeyword);
         this.thisOrBaseKeyword = thisOrBaseKeyword;
      }
      var argumentList = (ArgumentListSyntax)reader.ReadValue();
      if (argumentList != null)
      {
         AdjustFlagsAndWidth(argumentList);
         this.argumentList = argumentList;
      }
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.colonToken);
      writer.WriteValue(this.thisOrBaseKeyword);
      writer.WriteValue(this.argumentList);
    }

    static ConstructorInitializerSyntax()
    {
       ObjectBinder.RegisterTypeReader(typeof(ConstructorInitializerSyntax), r => new ConstructorInitializerSyntax(r));
    }
  }

  /// <summary>Destructor declaration syntax.</summary>
  internal sealed partial class DestructorDeclarationSyntax : BaseMethodDeclarationSyntax
  {
    internal readonly GreenNode? attributeLists;
    internal readonly GreenNode? modifiers;
    internal readonly SyntaxToken tildeToken;
    internal readonly SyntaxToken identifier;
    internal readonly ParameterListSyntax parameterList;
    internal readonly BlockSyntax? body;
    internal readonly ArrowExpressionClauseSyntax? expressionBody;
    internal readonly SyntaxToken? semicolonToken;

    internal DestructorDeclarationSyntax(SyntaxKind kind, GreenNode? attributeLists, GreenNode? modifiers, SyntaxToken tildeToken, SyntaxToken identifier, ParameterListSyntax parameterList, BlockSyntax? body, ArrowExpressionClauseSyntax? expressionBody, SyntaxToken? semicolonToken, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 8;
        if (attributeLists != null)
        {
            this.AdjustFlagsAndWidth(attributeLists);
            this.attributeLists = attributeLists;
        }
        if (modifiers != null)
        {
            this.AdjustFlagsAndWidth(modifiers);
            this.modifiers = modifiers;
        }
        this.AdjustFlagsAndWidth(tildeToken);
        this.tildeToken = tildeToken;
        this.AdjustFlagsAndWidth(identifier);
        this.identifier = identifier;
        this.AdjustFlagsAndWidth(parameterList);
        this.parameterList = parameterList;
        if (body != null)
        {
            this.AdjustFlagsAndWidth(body);
            this.body = body;
        }
        if (expressionBody != null)
        {
            this.AdjustFlagsAndWidth(expressionBody);
            this.expressionBody = expressionBody;
        }
        if (semicolonToken != null)
        {
            this.AdjustFlagsAndWidth(semicolonToken);
            this.semicolonToken = semicolonToken;
        }
    }


    internal DestructorDeclarationSyntax(SyntaxKind kind, GreenNode? attributeLists, GreenNode? modifiers, SyntaxToken tildeToken, SyntaxToken identifier, ParameterListSyntax parameterList, BlockSyntax? body, ArrowExpressionClauseSyntax? expressionBody, SyntaxToken? semicolonToken, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 8;
        if (attributeLists != null)
        {
            this.AdjustFlagsAndWidth(attributeLists);
            this.attributeLists = attributeLists;
        }
        if (modifiers != null)
        {
            this.AdjustFlagsAndWidth(modifiers);
            this.modifiers = modifiers;
        }
        this.AdjustFlagsAndWidth(tildeToken);
        this.tildeToken = tildeToken;
        this.AdjustFlagsAndWidth(identifier);
        this.identifier = identifier;
        this.AdjustFlagsAndWidth(parameterList);
        this.parameterList = parameterList;
        if (body != null)
        {
            this.AdjustFlagsAndWidth(body);
            this.body = body;
        }
        if (expressionBody != null)
        {
            this.AdjustFlagsAndWidth(expressionBody);
            this.expressionBody = expressionBody;
        }
        if (semicolonToken != null)
        {
            this.AdjustFlagsAndWidth(semicolonToken);
            this.semicolonToken = semicolonToken;
        }
    }


    internal DestructorDeclarationSyntax(SyntaxKind kind, GreenNode? attributeLists, GreenNode? modifiers, SyntaxToken tildeToken, SyntaxToken identifier, ParameterListSyntax parameterList, BlockSyntax? body, ArrowExpressionClauseSyntax? expressionBody, SyntaxToken? semicolonToken)
        : base(kind)
    {
        this.SlotCount = 8;
        if (attributeLists != null)
        {
            this.AdjustFlagsAndWidth(attributeLists);
            this.attributeLists = attributeLists;
        }
        if (modifiers != null)
        {
            this.AdjustFlagsAndWidth(modifiers);
            this.modifiers = modifiers;
        }
        this.AdjustFlagsAndWidth(tildeToken);
        this.tildeToken = tildeToken;
        this.AdjustFlagsAndWidth(identifier);
        this.identifier = identifier;
        this.AdjustFlagsAndWidth(parameterList);
        this.parameterList = parameterList;
        if (body != null)
        {
            this.AdjustFlagsAndWidth(body);
            this.body = body;
        }
        if (expressionBody != null)
        {
            this.AdjustFlagsAndWidth(expressionBody);
            this.expressionBody = expressionBody;
        }
        if (semicolonToken != null)
        {
            this.AdjustFlagsAndWidth(semicolonToken);
            this.semicolonToken = semicolonToken;
        }
    }

    public override Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<AttributeListSyntax> AttributeLists => new Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<AttributeListSyntax>(this.attributeLists);
    public override Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SyntaxToken> Modifiers => new Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SyntaxToken>(this.modifiers);
    /// <summary>Gets the tilde token.</summary>
    public SyntaxToken TildeToken => this.tildeToken;
    /// <summary>Gets the identifier.</summary>
    public SyntaxToken Identifier => this.identifier;
    public override ParameterListSyntax ParameterList => this.parameterList;
    public override BlockSyntax? Body => this.body;
    public override ArrowExpressionClauseSyntax? ExpressionBody => this.expressionBody;
    /// <summary>Gets the optional semicolon token.</summary>
    public override SyntaxToken? SemicolonToken => this.semicolonToken;

    internal override GreenNode? GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.attributeLists;
            case 1: return this.modifiers;
            case 2: return this.tildeToken;
            case 3: return this.identifier;
            case 4: return this.parameterList;
            case 5: return this.body;
            case 6: return this.expressionBody;
            case 7: return this.semicolonToken;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new CSharp.Syntax.DestructorDeclarationSyntax(this, parent, position);

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor) => visitor.VisitDestructorDeclaration(this);

    public override void Accept(CSharpSyntaxVisitor visitor) => visitor.VisitDestructorDeclaration(this);

    public DestructorDeclarationSyntax Update(Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<AttributeListSyntax> attributeLists, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SyntaxToken> modifiers, SyntaxToken tildeToken, SyntaxToken identifier, ParameterListSyntax parameterList, BlockSyntax body, ArrowExpressionClauseSyntax expressionBody, SyntaxToken semicolonToken)
    {
        if (attributeLists != this.AttributeLists || modifiers != this.Modifiers || tildeToken != this.TildeToken || identifier != this.Identifier || parameterList != this.ParameterList || body != this.Body || expressionBody != this.ExpressionBody || semicolonToken != this.SemicolonToken)
        {
            var newNode = SyntaxFactory.DestructorDeclaration(attributeLists, modifiers, tildeToken, identifier, parameterList, body, expressionBody, semicolonToken);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
        => new DestructorDeclarationSyntax(this.Kind, this.attributeLists, this.modifiers, this.tildeToken, this.identifier, this.parameterList, this.body, this.expressionBody, this.semicolonToken, diagnostics, GetAnnotations());

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
        => new DestructorDeclarationSyntax(this.Kind, this.attributeLists, this.modifiers, this.tildeToken, this.identifier, this.parameterList, this.body, this.expressionBody, this.semicolonToken, GetDiagnostics(), annotations);

    internal DestructorDeclarationSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 8;
      var attributeLists = (GreenNode?)reader.ReadValue();
      if (attributeLists != null)
      {
         AdjustFlagsAndWidth(attributeLists);
         this.attributeLists = attributeLists;
      }
      var modifiers = (GreenNode?)reader.ReadValue();
      if (modifiers != null)
      {
         AdjustFlagsAndWidth(modifiers);
         this.modifiers = modifiers;
      }
      var tildeToken = (SyntaxToken)reader.ReadValue();
      if (tildeToken != null)
      {
         AdjustFlagsAndWidth(tildeToken);
         this.tildeToken = tildeToken;
      }
      var identifier = (SyntaxToken)reader.ReadValue();
      if (identifier != null)
      {
         AdjustFlagsAndWidth(identifier);
         this.identifier = identifier;
      }
      var parameterList = (ParameterListSyntax)reader.ReadValue();
      if (parameterList != null)
      {
         AdjustFlagsAndWidth(parameterList);
         this.parameterList = parameterList;
      }
      var body = (BlockSyntax?)reader.ReadValue();
      if (body != null)
      {
         AdjustFlagsAndWidth(body);
         this.body = body;
      }
      var expressionBody = (ArrowExpressionClauseSyntax?)reader.ReadValue();
      if (expressionBody != null)
      {
         AdjustFlagsAndWidth(expressionBody);
         this.expressionBody = expressionBody;
      }
      var semicolonToken = (SyntaxToken?)reader.ReadValue();
      if (semicolonToken != null)
      {
         AdjustFlagsAndWidth(semicolonToken);
         this.semicolonToken = semicolonToken;
      }
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.attributeLists);
      writer.WriteValue(this.modifiers);
      writer.WriteValue(this.tildeToken);
      writer.WriteValue(this.identifier);
      writer.WriteValue(this.parameterList);
      writer.WriteValue(this.body);
      writer.WriteValue(this.expressionBody);
      writer.WriteValue(this.semicolonToken);
    }

    static DestructorDeclarationSyntax()
    {
       ObjectBinder.RegisterTypeReader(typeof(DestructorDeclarationSyntax), r => new DestructorDeclarationSyntax(r));
    }
  }

  /// <summary>Base type for property declaration syntax.</summary>
  internal abstract partial class BasePropertyDeclarationSyntax : MemberDeclarationSyntax
  {
    internal BasePropertyDeclarationSyntax(SyntaxKind kind, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
      : base(kind, diagnostics, annotations)
    {
    }
    internal BasePropertyDeclarationSyntax(SyntaxKind kind)
      : base(kind)
    {
    }

    protected BasePropertyDeclarationSyntax(ObjectReader reader)
       : base(reader)
    {
    }

    /// <summary>Gets the type syntax.</summary>
    public abstract TypeSyntax Type { get; }

    /// <summary>Gets the optional explicit interface specifier.</summary>
    public abstract ExplicitInterfaceSpecifierSyntax? ExplicitInterfaceSpecifier { get; }

    public abstract AccessorListSyntax? AccessorList { get; }
  }

  internal sealed partial class PropertyDeclarationSyntax : BasePropertyDeclarationSyntax
  {
    internal readonly GreenNode? attributeLists;
    internal readonly GreenNode? modifiers;
    internal readonly TypeSyntax type;
    internal readonly ExplicitInterfaceSpecifierSyntax? explicitInterfaceSpecifier;
    internal readonly SyntaxToken identifier;
    internal readonly AccessorListSyntax? accessorList;
    internal readonly ArrowExpressionClauseSyntax? expressionBody;
    internal readonly EqualsValueClauseSyntax? initializer;
    internal readonly SyntaxToken? semicolonToken;

    internal PropertyDeclarationSyntax(SyntaxKind kind, GreenNode? attributeLists, GreenNode? modifiers, TypeSyntax type, ExplicitInterfaceSpecifierSyntax? explicitInterfaceSpecifier, SyntaxToken identifier, AccessorListSyntax? accessorList, ArrowExpressionClauseSyntax? expressionBody, EqualsValueClauseSyntax? initializer, SyntaxToken? semicolonToken, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 9;
        if (attributeLists != null)
        {
            this.AdjustFlagsAndWidth(attributeLists);
            this.attributeLists = attributeLists;
        }
        if (modifiers != null)
        {
            this.AdjustFlagsAndWidth(modifiers);
            this.modifiers = modifiers;
        }
        this.AdjustFlagsAndWidth(type);
        this.type = type;
        if (explicitInterfaceSpecifier != null)
        {
            this.AdjustFlagsAndWidth(explicitInterfaceSpecifier);
            this.explicitInterfaceSpecifier = explicitInterfaceSpecifier;
        }
        this.AdjustFlagsAndWidth(identifier);
        this.identifier = identifier;
        if (accessorList != null)
        {
            this.AdjustFlagsAndWidth(accessorList);
            this.accessorList = accessorList;
        }
        if (expressionBody != null)
        {
            this.AdjustFlagsAndWidth(expressionBody);
            this.expressionBody = expressionBody;
        }
        if (initializer != null)
        {
            this.AdjustFlagsAndWidth(initializer);
            this.initializer = initializer;
        }
        if (semicolonToken != null)
        {
            this.AdjustFlagsAndWidth(semicolonToken);
            this.semicolonToken = semicolonToken;
        }
    }


    internal PropertyDeclarationSyntax(SyntaxKind kind, GreenNode? attributeLists, GreenNode? modifiers, TypeSyntax type, ExplicitInterfaceSpecifierSyntax? explicitInterfaceSpecifier, SyntaxToken identifier, AccessorListSyntax? accessorList, ArrowExpressionClauseSyntax? expressionBody, EqualsValueClauseSyntax? initializer, SyntaxToken? semicolonToken, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 9;
        if (attributeLists != null)
        {
            this.AdjustFlagsAndWidth(attributeLists);
            this.attributeLists = attributeLists;
        }
        if (modifiers != null)
        {
            this.AdjustFlagsAndWidth(modifiers);
            this.modifiers = modifiers;
        }
        this.AdjustFlagsAndWidth(type);
        this.type = type;
        if (explicitInterfaceSpecifier != null)
        {
            this.AdjustFlagsAndWidth(explicitInterfaceSpecifier);
            this.explicitInterfaceSpecifier = explicitInterfaceSpecifier;
        }
        this.AdjustFlagsAndWidth(identifier);
        this.identifier = identifier;
        if (accessorList != null)
        {
            this.AdjustFlagsAndWidth(accessorList);
            this.accessorList = accessorList;
        }
        if (expressionBody != null)
        {
            this.AdjustFlagsAndWidth(expressionBody);
            this.expressionBody = expressionBody;
        }
        if (initializer != null)
        {
            this.AdjustFlagsAndWidth(initializer);
            this.initializer = initializer;
        }
        if (semicolonToken != null)
        {
            this.AdjustFlagsAndWidth(semicolonToken);
            this.semicolonToken = semicolonToken;
        }
    }


    internal PropertyDeclarationSyntax(SyntaxKind kind, GreenNode? attributeLists, GreenNode? modifiers, TypeSyntax type, ExplicitInterfaceSpecifierSyntax? explicitInterfaceSpecifier, SyntaxToken identifier, AccessorListSyntax? accessorList, ArrowExpressionClauseSyntax? expressionBody, EqualsValueClauseSyntax? initializer, SyntaxToken? semicolonToken)
        : base(kind)
    {
        this.SlotCount = 9;
        if (attributeLists != null)
        {
            this.AdjustFlagsAndWidth(attributeLists);
            this.attributeLists = attributeLists;
        }
        if (modifiers != null)
        {
            this.AdjustFlagsAndWidth(modifiers);
            this.modifiers = modifiers;
        }
        this.AdjustFlagsAndWidth(type);
        this.type = type;
        if (explicitInterfaceSpecifier != null)
        {
            this.AdjustFlagsAndWidth(explicitInterfaceSpecifier);
            this.explicitInterfaceSpecifier = explicitInterfaceSpecifier;
        }
        this.AdjustFlagsAndWidth(identifier);
        this.identifier = identifier;
        if (accessorList != null)
        {
            this.AdjustFlagsAndWidth(accessorList);
            this.accessorList = accessorList;
        }
        if (expressionBody != null)
        {
            this.AdjustFlagsAndWidth(expressionBody);
            this.expressionBody = expressionBody;
        }
        if (initializer != null)
        {
            this.AdjustFlagsAndWidth(initializer);
            this.initializer = initializer;
        }
        if (semicolonToken != null)
        {
            this.AdjustFlagsAndWidth(semicolonToken);
            this.semicolonToken = semicolonToken;
        }
    }

    public override Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<AttributeListSyntax> AttributeLists => new Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<AttributeListSyntax>(this.attributeLists);
    public override Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SyntaxToken> Modifiers => new Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SyntaxToken>(this.modifiers);
    public override TypeSyntax Type => this.type;
    public override ExplicitInterfaceSpecifierSyntax? ExplicitInterfaceSpecifier => this.explicitInterfaceSpecifier;
    /// <summary>Gets the identifier.</summary>
    public SyntaxToken Identifier => this.identifier;
    public override AccessorListSyntax? AccessorList => this.accessorList;
    public ArrowExpressionClauseSyntax? ExpressionBody => this.expressionBody;
    public EqualsValueClauseSyntax? Initializer => this.initializer;
    public SyntaxToken? SemicolonToken => this.semicolonToken;

    internal override GreenNode? GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.attributeLists;
            case 1: return this.modifiers;
            case 2: return this.type;
            case 3: return this.explicitInterfaceSpecifier;
            case 4: return this.identifier;
            case 5: return this.accessorList;
            case 6: return this.expressionBody;
            case 7: return this.initializer;
            case 8: return this.semicolonToken;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new CSharp.Syntax.PropertyDeclarationSyntax(this, parent, position);

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor) => visitor.VisitPropertyDeclaration(this);

    public override void Accept(CSharpSyntaxVisitor visitor) => visitor.VisitPropertyDeclaration(this);

    public PropertyDeclarationSyntax Update(Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<AttributeListSyntax> attributeLists, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SyntaxToken> modifiers, TypeSyntax type, ExplicitInterfaceSpecifierSyntax explicitInterfaceSpecifier, SyntaxToken identifier, AccessorListSyntax accessorList, ArrowExpressionClauseSyntax expressionBody, EqualsValueClauseSyntax initializer, SyntaxToken semicolonToken)
    {
        if (attributeLists != this.AttributeLists || modifiers != this.Modifiers || type != this.Type || explicitInterfaceSpecifier != this.ExplicitInterfaceSpecifier || identifier != this.Identifier || accessorList != this.AccessorList || expressionBody != this.ExpressionBody || initializer != this.Initializer || semicolonToken != this.SemicolonToken)
        {
            var newNode = SyntaxFactory.PropertyDeclaration(attributeLists, modifiers, type, explicitInterfaceSpecifier, identifier, accessorList, expressionBody, initializer, semicolonToken);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
        => new PropertyDeclarationSyntax(this.Kind, this.attributeLists, this.modifiers, this.type, this.explicitInterfaceSpecifier, this.identifier, this.accessorList, this.expressionBody, this.initializer, this.semicolonToken, diagnostics, GetAnnotations());

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
        => new PropertyDeclarationSyntax(this.Kind, this.attributeLists, this.modifiers, this.type, this.explicitInterfaceSpecifier, this.identifier, this.accessorList, this.expressionBody, this.initializer, this.semicolonToken, GetDiagnostics(), annotations);

    internal PropertyDeclarationSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 9;
      var attributeLists = (GreenNode?)reader.ReadValue();
      if (attributeLists != null)
      {
         AdjustFlagsAndWidth(attributeLists);
         this.attributeLists = attributeLists;
      }
      var modifiers = (GreenNode?)reader.ReadValue();
      if (modifiers != null)
      {
         AdjustFlagsAndWidth(modifiers);
         this.modifiers = modifiers;
      }
      var type = (TypeSyntax)reader.ReadValue();
      if (type != null)
      {
         AdjustFlagsAndWidth(type);
         this.type = type;
      }
      var explicitInterfaceSpecifier = (ExplicitInterfaceSpecifierSyntax?)reader.ReadValue();
      if (explicitInterfaceSpecifier != null)
      {
         AdjustFlagsAndWidth(explicitInterfaceSpecifier);
         this.explicitInterfaceSpecifier = explicitInterfaceSpecifier;
      }
      var identifier = (SyntaxToken)reader.ReadValue();
      if (identifier != null)
      {
         AdjustFlagsAndWidth(identifier);
         this.identifier = identifier;
      }
      var accessorList = (AccessorListSyntax?)reader.ReadValue();
      if (accessorList != null)
      {
         AdjustFlagsAndWidth(accessorList);
         this.accessorList = accessorList;
      }
      var expressionBody = (ArrowExpressionClauseSyntax?)reader.ReadValue();
      if (expressionBody != null)
      {
         AdjustFlagsAndWidth(expressionBody);
         this.expressionBody = expressionBody;
      }
      var initializer = (EqualsValueClauseSyntax?)reader.ReadValue();
      if (initializer != null)
      {
         AdjustFlagsAndWidth(initializer);
         this.initializer = initializer;
      }
      var semicolonToken = (SyntaxToken?)reader.ReadValue();
      if (semicolonToken != null)
      {
         AdjustFlagsAndWidth(semicolonToken);
         this.semicolonToken = semicolonToken;
      }
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.attributeLists);
      writer.WriteValue(this.modifiers);
      writer.WriteValue(this.type);
      writer.WriteValue(this.explicitInterfaceSpecifier);
      writer.WriteValue(this.identifier);
      writer.WriteValue(this.accessorList);
      writer.WriteValue(this.expressionBody);
      writer.WriteValue(this.initializer);
      writer.WriteValue(this.semicolonToken);
    }

    static PropertyDeclarationSyntax()
    {
       ObjectBinder.RegisterTypeReader(typeof(PropertyDeclarationSyntax), r => new PropertyDeclarationSyntax(r));
    }
  }

  /// <summary>The syntax for the expression body of an expression-bodied member.</summary>
  internal sealed partial class ArrowExpressionClauseSyntax : CSharpSyntaxNode
  {
    internal readonly SyntaxToken arrowToken;
    internal readonly ExpressionSyntax expression;

    internal ArrowExpressionClauseSyntax(SyntaxKind kind, SyntaxToken arrowToken, ExpressionSyntax expression, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 2;
        this.AdjustFlagsAndWidth(arrowToken);
        this.arrowToken = arrowToken;
        this.AdjustFlagsAndWidth(expression);
        this.expression = expression;
    }


    internal ArrowExpressionClauseSyntax(SyntaxKind kind, SyntaxToken arrowToken, ExpressionSyntax expression, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 2;
        this.AdjustFlagsAndWidth(arrowToken);
        this.arrowToken = arrowToken;
        this.AdjustFlagsAndWidth(expression);
        this.expression = expression;
    }


    internal ArrowExpressionClauseSyntax(SyntaxKind kind, SyntaxToken arrowToken, ExpressionSyntax expression)
        : base(kind)
    {
        this.SlotCount = 2;
        this.AdjustFlagsAndWidth(arrowToken);
        this.arrowToken = arrowToken;
        this.AdjustFlagsAndWidth(expression);
        this.expression = expression;
    }

    public SyntaxToken ArrowToken => this.arrowToken;
    public ExpressionSyntax Expression => this.expression;

    internal override GreenNode? GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.arrowToken;
            case 1: return this.expression;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new CSharp.Syntax.ArrowExpressionClauseSyntax(this, parent, position);

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor) => visitor.VisitArrowExpressionClause(this);

    public override void Accept(CSharpSyntaxVisitor visitor) => visitor.VisitArrowExpressionClause(this);

    public ArrowExpressionClauseSyntax Update(SyntaxToken arrowToken, ExpressionSyntax expression)
    {
        if (arrowToken != this.ArrowToken || expression != this.Expression)
        {
            var newNode = SyntaxFactory.ArrowExpressionClause(arrowToken, expression);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
        => new ArrowExpressionClauseSyntax(this.Kind, this.arrowToken, this.expression, diagnostics, GetAnnotations());

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
        => new ArrowExpressionClauseSyntax(this.Kind, this.arrowToken, this.expression, GetDiagnostics(), annotations);

    internal ArrowExpressionClauseSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 2;
      var arrowToken = (SyntaxToken)reader.ReadValue();
      if (arrowToken != null)
      {
         AdjustFlagsAndWidth(arrowToken);
         this.arrowToken = arrowToken;
      }
      var expression = (ExpressionSyntax)reader.ReadValue();
      if (expression != null)
      {
         AdjustFlagsAndWidth(expression);
         this.expression = expression;
      }
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.arrowToken);
      writer.WriteValue(this.expression);
    }

    static ArrowExpressionClauseSyntax()
    {
       ObjectBinder.RegisterTypeReader(typeof(ArrowExpressionClauseSyntax), r => new ArrowExpressionClauseSyntax(r));
    }
  }

  internal sealed partial class EventDeclarationSyntax : BasePropertyDeclarationSyntax
  {
    internal readonly GreenNode? attributeLists;
    internal readonly GreenNode? modifiers;
    internal readonly SyntaxToken eventKeyword;
    internal readonly TypeSyntax type;
    internal readonly ExplicitInterfaceSpecifierSyntax? explicitInterfaceSpecifier;
    internal readonly SyntaxToken identifier;
    internal readonly AccessorListSyntax? accessorList;
    internal readonly SyntaxToken? semicolonToken;

    internal EventDeclarationSyntax(SyntaxKind kind, GreenNode? attributeLists, GreenNode? modifiers, SyntaxToken eventKeyword, TypeSyntax type, ExplicitInterfaceSpecifierSyntax? explicitInterfaceSpecifier, SyntaxToken identifier, AccessorListSyntax? accessorList, SyntaxToken? semicolonToken, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 8;
        if (attributeLists != null)
        {
            this.AdjustFlagsAndWidth(attributeLists);
            this.attributeLists = attributeLists;
        }
        if (modifiers != null)
        {
            this.AdjustFlagsAndWidth(modifiers);
            this.modifiers = modifiers;
        }
        this.AdjustFlagsAndWidth(eventKeyword);
        this.eventKeyword = eventKeyword;
        this.AdjustFlagsAndWidth(type);
        this.type = type;
        if (explicitInterfaceSpecifier != null)
        {
            this.AdjustFlagsAndWidth(explicitInterfaceSpecifier);
            this.explicitInterfaceSpecifier = explicitInterfaceSpecifier;
        }
        this.AdjustFlagsAndWidth(identifier);
        this.identifier = identifier;
        if (accessorList != null)
        {
            this.AdjustFlagsAndWidth(accessorList);
            this.accessorList = accessorList;
        }
        if (semicolonToken != null)
        {
            this.AdjustFlagsAndWidth(semicolonToken);
            this.semicolonToken = semicolonToken;
        }
    }


    internal EventDeclarationSyntax(SyntaxKind kind, GreenNode? attributeLists, GreenNode? modifiers, SyntaxToken eventKeyword, TypeSyntax type, ExplicitInterfaceSpecifierSyntax? explicitInterfaceSpecifier, SyntaxToken identifier, AccessorListSyntax? accessorList, SyntaxToken? semicolonToken, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 8;
        if (attributeLists != null)
        {
            this.AdjustFlagsAndWidth(attributeLists);
            this.attributeLists = attributeLists;
        }
        if (modifiers != null)
        {
            this.AdjustFlagsAndWidth(modifiers);
            this.modifiers = modifiers;
        }
        this.AdjustFlagsAndWidth(eventKeyword);
        this.eventKeyword = eventKeyword;
        this.AdjustFlagsAndWidth(type);
        this.type = type;
        if (explicitInterfaceSpecifier != null)
        {
            this.AdjustFlagsAndWidth(explicitInterfaceSpecifier);
            this.explicitInterfaceSpecifier = explicitInterfaceSpecifier;
        }
        this.AdjustFlagsAndWidth(identifier);
        this.identifier = identifier;
        if (accessorList != null)
        {
            this.AdjustFlagsAndWidth(accessorList);
            this.accessorList = accessorList;
        }
        if (semicolonToken != null)
        {
            this.AdjustFlagsAndWidth(semicolonToken);
            this.semicolonToken = semicolonToken;
        }
    }


    internal EventDeclarationSyntax(SyntaxKind kind, GreenNode? attributeLists, GreenNode? modifiers, SyntaxToken eventKeyword, TypeSyntax type, ExplicitInterfaceSpecifierSyntax? explicitInterfaceSpecifier, SyntaxToken identifier, AccessorListSyntax? accessorList, SyntaxToken? semicolonToken)
        : base(kind)
    {
        this.SlotCount = 8;
        if (attributeLists != null)
        {
            this.AdjustFlagsAndWidth(attributeLists);
            this.attributeLists = attributeLists;
        }
        if (modifiers != null)
        {
            this.AdjustFlagsAndWidth(modifiers);
            this.modifiers = modifiers;
        }
        this.AdjustFlagsAndWidth(eventKeyword);
        this.eventKeyword = eventKeyword;
        this.AdjustFlagsAndWidth(type);
        this.type = type;
        if (explicitInterfaceSpecifier != null)
        {
            this.AdjustFlagsAndWidth(explicitInterfaceSpecifier);
            this.explicitInterfaceSpecifier = explicitInterfaceSpecifier;
        }
        this.AdjustFlagsAndWidth(identifier);
        this.identifier = identifier;
        if (accessorList != null)
        {
            this.AdjustFlagsAndWidth(accessorList);
            this.accessorList = accessorList;
        }
        if (semicolonToken != null)
        {
            this.AdjustFlagsAndWidth(semicolonToken);
            this.semicolonToken = semicolonToken;
        }
    }

    public override Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<AttributeListSyntax> AttributeLists => new Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<AttributeListSyntax>(this.attributeLists);
    public override Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SyntaxToken> Modifiers => new Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SyntaxToken>(this.modifiers);
    public SyntaxToken EventKeyword => this.eventKeyword;
    public override TypeSyntax Type => this.type;
    public override ExplicitInterfaceSpecifierSyntax? ExplicitInterfaceSpecifier => this.explicitInterfaceSpecifier;
    /// <summary>Gets the identifier.</summary>
    public SyntaxToken Identifier => this.identifier;
    public override AccessorListSyntax? AccessorList => this.accessorList;
    public SyntaxToken? SemicolonToken => this.semicolonToken;

    internal override GreenNode? GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.attributeLists;
            case 1: return this.modifiers;
            case 2: return this.eventKeyword;
            case 3: return this.type;
            case 4: return this.explicitInterfaceSpecifier;
            case 5: return this.identifier;
            case 6: return this.accessorList;
            case 7: return this.semicolonToken;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new CSharp.Syntax.EventDeclarationSyntax(this, parent, position);

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor) => visitor.VisitEventDeclaration(this);

    public override void Accept(CSharpSyntaxVisitor visitor) => visitor.VisitEventDeclaration(this);

    public EventDeclarationSyntax Update(Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<AttributeListSyntax> attributeLists, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SyntaxToken> modifiers, SyntaxToken eventKeyword, TypeSyntax type, ExplicitInterfaceSpecifierSyntax explicitInterfaceSpecifier, SyntaxToken identifier, AccessorListSyntax accessorList, SyntaxToken semicolonToken)
    {
        if (attributeLists != this.AttributeLists || modifiers != this.Modifiers || eventKeyword != this.EventKeyword || type != this.Type || explicitInterfaceSpecifier != this.ExplicitInterfaceSpecifier || identifier != this.Identifier || accessorList != this.AccessorList || semicolonToken != this.SemicolonToken)
        {
            var newNode = SyntaxFactory.EventDeclaration(attributeLists, modifiers, eventKeyword, type, explicitInterfaceSpecifier, identifier, accessorList, semicolonToken);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
        => new EventDeclarationSyntax(this.Kind, this.attributeLists, this.modifiers, this.eventKeyword, this.type, this.explicitInterfaceSpecifier, this.identifier, this.accessorList, this.semicolonToken, diagnostics, GetAnnotations());

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
        => new EventDeclarationSyntax(this.Kind, this.attributeLists, this.modifiers, this.eventKeyword, this.type, this.explicitInterfaceSpecifier, this.identifier, this.accessorList, this.semicolonToken, GetDiagnostics(), annotations);

    internal EventDeclarationSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 8;
      var attributeLists = (GreenNode?)reader.ReadValue();
      if (attributeLists != null)
      {
         AdjustFlagsAndWidth(attributeLists);
         this.attributeLists = attributeLists;
      }
      var modifiers = (GreenNode?)reader.ReadValue();
      if (modifiers != null)
      {
         AdjustFlagsAndWidth(modifiers);
         this.modifiers = modifiers;
      }
      var eventKeyword = (SyntaxToken)reader.ReadValue();
      if (eventKeyword != null)
      {
         AdjustFlagsAndWidth(eventKeyword);
         this.eventKeyword = eventKeyword;
      }
      var type = (TypeSyntax)reader.ReadValue();
      if (type != null)
      {
         AdjustFlagsAndWidth(type);
         this.type = type;
      }
      var explicitInterfaceSpecifier = (ExplicitInterfaceSpecifierSyntax?)reader.ReadValue();
      if (explicitInterfaceSpecifier != null)
      {
         AdjustFlagsAndWidth(explicitInterfaceSpecifier);
         this.explicitInterfaceSpecifier = explicitInterfaceSpecifier;
      }
      var identifier = (SyntaxToken)reader.ReadValue();
      if (identifier != null)
      {
         AdjustFlagsAndWidth(identifier);
         this.identifier = identifier;
      }
      var accessorList = (AccessorListSyntax?)reader.ReadValue();
      if (accessorList != null)
      {
         AdjustFlagsAndWidth(accessorList);
         this.accessorList = accessorList;
      }
      var semicolonToken = (SyntaxToken?)reader.ReadValue();
      if (semicolonToken != null)
      {
         AdjustFlagsAndWidth(semicolonToken);
         this.semicolonToken = semicolonToken;
      }
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.attributeLists);
      writer.WriteValue(this.modifiers);
      writer.WriteValue(this.eventKeyword);
      writer.WriteValue(this.type);
      writer.WriteValue(this.explicitInterfaceSpecifier);
      writer.WriteValue(this.identifier);
      writer.WriteValue(this.accessorList);
      writer.WriteValue(this.semicolonToken);
    }

    static EventDeclarationSyntax()
    {
       ObjectBinder.RegisterTypeReader(typeof(EventDeclarationSyntax), r => new EventDeclarationSyntax(r));
    }
  }

  internal sealed partial class IndexerDeclarationSyntax : BasePropertyDeclarationSyntax
  {
    internal readonly GreenNode? attributeLists;
    internal readonly GreenNode? modifiers;
    internal readonly TypeSyntax type;
    internal readonly ExplicitInterfaceSpecifierSyntax? explicitInterfaceSpecifier;
    internal readonly SyntaxToken thisKeyword;
    internal readonly BracketedParameterListSyntax parameterList;
    internal readonly AccessorListSyntax? accessorList;
    internal readonly ArrowExpressionClauseSyntax? expressionBody;
    internal readonly SyntaxToken? semicolonToken;

    internal IndexerDeclarationSyntax(SyntaxKind kind, GreenNode? attributeLists, GreenNode? modifiers, TypeSyntax type, ExplicitInterfaceSpecifierSyntax? explicitInterfaceSpecifier, SyntaxToken thisKeyword, BracketedParameterListSyntax parameterList, AccessorListSyntax? accessorList, ArrowExpressionClauseSyntax? expressionBody, SyntaxToken? semicolonToken, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 9;
        if (attributeLists != null)
        {
            this.AdjustFlagsAndWidth(attributeLists);
            this.attributeLists = attributeLists;
        }
        if (modifiers != null)
        {
            this.AdjustFlagsAndWidth(modifiers);
            this.modifiers = modifiers;
        }
        this.AdjustFlagsAndWidth(type);
        this.type = type;
        if (explicitInterfaceSpecifier != null)
        {
            this.AdjustFlagsAndWidth(explicitInterfaceSpecifier);
            this.explicitInterfaceSpecifier = explicitInterfaceSpecifier;
        }
        this.AdjustFlagsAndWidth(thisKeyword);
        this.thisKeyword = thisKeyword;
        this.AdjustFlagsAndWidth(parameterList);
        this.parameterList = parameterList;
        if (accessorList != null)
        {
            this.AdjustFlagsAndWidth(accessorList);
            this.accessorList = accessorList;
        }
        if (expressionBody != null)
        {
            this.AdjustFlagsAndWidth(expressionBody);
            this.expressionBody = expressionBody;
        }
        if (semicolonToken != null)
        {
            this.AdjustFlagsAndWidth(semicolonToken);
            this.semicolonToken = semicolonToken;
        }
    }


    internal IndexerDeclarationSyntax(SyntaxKind kind, GreenNode? attributeLists, GreenNode? modifiers, TypeSyntax type, ExplicitInterfaceSpecifierSyntax? explicitInterfaceSpecifier, SyntaxToken thisKeyword, BracketedParameterListSyntax parameterList, AccessorListSyntax? accessorList, ArrowExpressionClauseSyntax? expressionBody, SyntaxToken? semicolonToken, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 9;
        if (attributeLists != null)
        {
            this.AdjustFlagsAndWidth(attributeLists);
            this.attributeLists = attributeLists;
        }
        if (modifiers != null)
        {
            this.AdjustFlagsAndWidth(modifiers);
            this.modifiers = modifiers;
        }
        this.AdjustFlagsAndWidth(type);
        this.type = type;
        if (explicitInterfaceSpecifier != null)
        {
            this.AdjustFlagsAndWidth(explicitInterfaceSpecifier);
            this.explicitInterfaceSpecifier = explicitInterfaceSpecifier;
        }
        this.AdjustFlagsAndWidth(thisKeyword);
        this.thisKeyword = thisKeyword;
        this.AdjustFlagsAndWidth(parameterList);
        this.parameterList = parameterList;
        if (accessorList != null)
        {
            this.AdjustFlagsAndWidth(accessorList);
            this.accessorList = accessorList;
        }
        if (expressionBody != null)
        {
            this.AdjustFlagsAndWidth(expressionBody);
            this.expressionBody = expressionBody;
        }
        if (semicolonToken != null)
        {
            this.AdjustFlagsAndWidth(semicolonToken);
            this.semicolonToken = semicolonToken;
        }
    }


    internal IndexerDeclarationSyntax(SyntaxKind kind, GreenNode? attributeLists, GreenNode? modifiers, TypeSyntax type, ExplicitInterfaceSpecifierSyntax? explicitInterfaceSpecifier, SyntaxToken thisKeyword, BracketedParameterListSyntax parameterList, AccessorListSyntax? accessorList, ArrowExpressionClauseSyntax? expressionBody, SyntaxToken? semicolonToken)
        : base(kind)
    {
        this.SlotCount = 9;
        if (attributeLists != null)
        {
            this.AdjustFlagsAndWidth(attributeLists);
            this.attributeLists = attributeLists;
        }
        if (modifiers != null)
        {
            this.AdjustFlagsAndWidth(modifiers);
            this.modifiers = modifiers;
        }
        this.AdjustFlagsAndWidth(type);
        this.type = type;
        if (explicitInterfaceSpecifier != null)
        {
            this.AdjustFlagsAndWidth(explicitInterfaceSpecifier);
            this.explicitInterfaceSpecifier = explicitInterfaceSpecifier;
        }
        this.AdjustFlagsAndWidth(thisKeyword);
        this.thisKeyword = thisKeyword;
        this.AdjustFlagsAndWidth(parameterList);
        this.parameterList = parameterList;
        if (accessorList != null)
        {
            this.AdjustFlagsAndWidth(accessorList);
            this.accessorList = accessorList;
        }
        if (expressionBody != null)
        {
            this.AdjustFlagsAndWidth(expressionBody);
            this.expressionBody = expressionBody;
        }
        if (semicolonToken != null)
        {
            this.AdjustFlagsAndWidth(semicolonToken);
            this.semicolonToken = semicolonToken;
        }
    }

    public override Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<AttributeListSyntax> AttributeLists => new Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<AttributeListSyntax>(this.attributeLists);
    public override Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SyntaxToken> Modifiers => new Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SyntaxToken>(this.modifiers);
    public override TypeSyntax Type => this.type;
    public override ExplicitInterfaceSpecifierSyntax? ExplicitInterfaceSpecifier => this.explicitInterfaceSpecifier;
    public SyntaxToken ThisKeyword => this.thisKeyword;
    /// <summary>Gets the parameter list.</summary>
    public BracketedParameterListSyntax ParameterList => this.parameterList;
    public override AccessorListSyntax? AccessorList => this.accessorList;
    public ArrowExpressionClauseSyntax? ExpressionBody => this.expressionBody;
    public SyntaxToken? SemicolonToken => this.semicolonToken;

    internal override GreenNode? GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.attributeLists;
            case 1: return this.modifiers;
            case 2: return this.type;
            case 3: return this.explicitInterfaceSpecifier;
            case 4: return this.thisKeyword;
            case 5: return this.parameterList;
            case 6: return this.accessorList;
            case 7: return this.expressionBody;
            case 8: return this.semicolonToken;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new CSharp.Syntax.IndexerDeclarationSyntax(this, parent, position);

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor) => visitor.VisitIndexerDeclaration(this);

    public override void Accept(CSharpSyntaxVisitor visitor) => visitor.VisitIndexerDeclaration(this);

    public IndexerDeclarationSyntax Update(Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<AttributeListSyntax> attributeLists, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SyntaxToken> modifiers, TypeSyntax type, ExplicitInterfaceSpecifierSyntax explicitInterfaceSpecifier, SyntaxToken thisKeyword, BracketedParameterListSyntax parameterList, AccessorListSyntax accessorList, ArrowExpressionClauseSyntax expressionBody, SyntaxToken semicolonToken)
    {
        if (attributeLists != this.AttributeLists || modifiers != this.Modifiers || type != this.Type || explicitInterfaceSpecifier != this.ExplicitInterfaceSpecifier || thisKeyword != this.ThisKeyword || parameterList != this.ParameterList || accessorList != this.AccessorList || expressionBody != this.ExpressionBody || semicolonToken != this.SemicolonToken)
        {
            var newNode = SyntaxFactory.IndexerDeclaration(attributeLists, modifiers, type, explicitInterfaceSpecifier, thisKeyword, parameterList, accessorList, expressionBody, semicolonToken);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
        => new IndexerDeclarationSyntax(this.Kind, this.attributeLists, this.modifiers, this.type, this.explicitInterfaceSpecifier, this.thisKeyword, this.parameterList, this.accessorList, this.expressionBody, this.semicolonToken, diagnostics, GetAnnotations());

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
        => new IndexerDeclarationSyntax(this.Kind, this.attributeLists, this.modifiers, this.type, this.explicitInterfaceSpecifier, this.thisKeyword, this.parameterList, this.accessorList, this.expressionBody, this.semicolonToken, GetDiagnostics(), annotations);

    internal IndexerDeclarationSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 9;
      var attributeLists = (GreenNode?)reader.ReadValue();
      if (attributeLists != null)
      {
         AdjustFlagsAndWidth(attributeLists);
         this.attributeLists = attributeLists;
      }
      var modifiers = (GreenNode?)reader.ReadValue();
      if (modifiers != null)
      {
         AdjustFlagsAndWidth(modifiers);
         this.modifiers = modifiers;
      }
      var type = (TypeSyntax)reader.ReadValue();
      if (type != null)
      {
         AdjustFlagsAndWidth(type);
         this.type = type;
      }
      var explicitInterfaceSpecifier = (ExplicitInterfaceSpecifierSyntax?)reader.ReadValue();
      if (explicitInterfaceSpecifier != null)
      {
         AdjustFlagsAndWidth(explicitInterfaceSpecifier);
         this.explicitInterfaceSpecifier = explicitInterfaceSpecifier;
      }
      var thisKeyword = (SyntaxToken)reader.ReadValue();
      if (thisKeyword != null)
      {
         AdjustFlagsAndWidth(thisKeyword);
         this.thisKeyword = thisKeyword;
      }
      var parameterList = (BracketedParameterListSyntax)reader.ReadValue();
      if (parameterList != null)
      {
         AdjustFlagsAndWidth(parameterList);
         this.parameterList = parameterList;
      }
      var accessorList = (AccessorListSyntax?)reader.ReadValue();
      if (accessorList != null)
      {
         AdjustFlagsAndWidth(accessorList);
         this.accessorList = accessorList;
      }
      var expressionBody = (ArrowExpressionClauseSyntax?)reader.ReadValue();
      if (expressionBody != null)
      {
         AdjustFlagsAndWidth(expressionBody);
         this.expressionBody = expressionBody;
      }
      var semicolonToken = (SyntaxToken?)reader.ReadValue();
      if (semicolonToken != null)
      {
         AdjustFlagsAndWidth(semicolonToken);
         this.semicolonToken = semicolonToken;
      }
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.attributeLists);
      writer.WriteValue(this.modifiers);
      writer.WriteValue(this.type);
      writer.WriteValue(this.explicitInterfaceSpecifier);
      writer.WriteValue(this.thisKeyword);
      writer.WriteValue(this.parameterList);
      writer.WriteValue(this.accessorList);
      writer.WriteValue(this.expressionBody);
      writer.WriteValue(this.semicolonToken);
    }

    static IndexerDeclarationSyntax()
    {
       ObjectBinder.RegisterTypeReader(typeof(IndexerDeclarationSyntax), r => new IndexerDeclarationSyntax(r));
    }
  }

  internal sealed partial class AccessorListSyntax : CSharpSyntaxNode
  {
    internal readonly SyntaxToken openBraceToken;
    internal readonly GreenNode? accessors;
    internal readonly SyntaxToken closeBraceToken;

    internal AccessorListSyntax(SyntaxKind kind, SyntaxToken openBraceToken, GreenNode? accessors, SyntaxToken closeBraceToken, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 3;
        this.AdjustFlagsAndWidth(openBraceToken);
        this.openBraceToken = openBraceToken;
        if (accessors != null)
        {
            this.AdjustFlagsAndWidth(accessors);
            this.accessors = accessors;
        }
        this.AdjustFlagsAndWidth(closeBraceToken);
        this.closeBraceToken = closeBraceToken;
    }


    internal AccessorListSyntax(SyntaxKind kind, SyntaxToken openBraceToken, GreenNode? accessors, SyntaxToken closeBraceToken, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 3;
        this.AdjustFlagsAndWidth(openBraceToken);
        this.openBraceToken = openBraceToken;
        if (accessors != null)
        {
            this.AdjustFlagsAndWidth(accessors);
            this.accessors = accessors;
        }
        this.AdjustFlagsAndWidth(closeBraceToken);
        this.closeBraceToken = closeBraceToken;
    }


    internal AccessorListSyntax(SyntaxKind kind, SyntaxToken openBraceToken, GreenNode? accessors, SyntaxToken closeBraceToken)
        : base(kind)
    {
        this.SlotCount = 3;
        this.AdjustFlagsAndWidth(openBraceToken);
        this.openBraceToken = openBraceToken;
        if (accessors != null)
        {
            this.AdjustFlagsAndWidth(accessors);
            this.accessors = accessors;
        }
        this.AdjustFlagsAndWidth(closeBraceToken);
        this.closeBraceToken = closeBraceToken;
    }

    public SyntaxToken OpenBraceToken => this.openBraceToken;
    public Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<AccessorDeclarationSyntax> Accessors => new Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<AccessorDeclarationSyntax>(this.accessors);
    public SyntaxToken CloseBraceToken => this.closeBraceToken;

    internal override GreenNode? GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.openBraceToken;
            case 1: return this.accessors;
            case 2: return this.closeBraceToken;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new CSharp.Syntax.AccessorListSyntax(this, parent, position);

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor) => visitor.VisitAccessorList(this);

    public override void Accept(CSharpSyntaxVisitor visitor) => visitor.VisitAccessorList(this);

    public AccessorListSyntax Update(SyntaxToken openBraceToken, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<AccessorDeclarationSyntax> accessors, SyntaxToken closeBraceToken)
    {
        if (openBraceToken != this.OpenBraceToken || accessors != this.Accessors || closeBraceToken != this.CloseBraceToken)
        {
            var newNode = SyntaxFactory.AccessorList(openBraceToken, accessors, closeBraceToken);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
        => new AccessorListSyntax(this.Kind, this.openBraceToken, this.accessors, this.closeBraceToken, diagnostics, GetAnnotations());

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
        => new AccessorListSyntax(this.Kind, this.openBraceToken, this.accessors, this.closeBraceToken, GetDiagnostics(), annotations);

    internal AccessorListSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 3;
      var openBraceToken = (SyntaxToken)reader.ReadValue();
      if (openBraceToken != null)
      {
         AdjustFlagsAndWidth(openBraceToken);
         this.openBraceToken = openBraceToken;
      }
      var accessors = (GreenNode?)reader.ReadValue();
      if (accessors != null)
      {
         AdjustFlagsAndWidth(accessors);
         this.accessors = accessors;
      }
      var closeBraceToken = (SyntaxToken)reader.ReadValue();
      if (closeBraceToken != null)
      {
         AdjustFlagsAndWidth(closeBraceToken);
         this.closeBraceToken = closeBraceToken;
      }
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.openBraceToken);
      writer.WriteValue(this.accessors);
      writer.WriteValue(this.closeBraceToken);
    }

    static AccessorListSyntax()
    {
       ObjectBinder.RegisterTypeReader(typeof(AccessorListSyntax), r => new AccessorListSyntax(r));
    }
  }

  internal sealed partial class AccessorDeclarationSyntax : CSharpSyntaxNode
  {
    internal readonly GreenNode? attributeLists;
    internal readonly GreenNode? modifiers;
    internal readonly SyntaxToken keyword;
    internal readonly BlockSyntax? body;
    internal readonly ArrowExpressionClauseSyntax? expressionBody;
    internal readonly SyntaxToken? semicolonToken;

    internal AccessorDeclarationSyntax(SyntaxKind kind, GreenNode? attributeLists, GreenNode? modifiers, SyntaxToken keyword, BlockSyntax? body, ArrowExpressionClauseSyntax? expressionBody, SyntaxToken? semicolonToken, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 6;
        if (attributeLists != null)
        {
            this.AdjustFlagsAndWidth(attributeLists);
            this.attributeLists = attributeLists;
        }
        if (modifiers != null)
        {
            this.AdjustFlagsAndWidth(modifiers);
            this.modifiers = modifiers;
        }
        this.AdjustFlagsAndWidth(keyword);
        this.keyword = keyword;
        if (body != null)
        {
            this.AdjustFlagsAndWidth(body);
            this.body = body;
        }
        if (expressionBody != null)
        {
            this.AdjustFlagsAndWidth(expressionBody);
            this.expressionBody = expressionBody;
        }
        if (semicolonToken != null)
        {
            this.AdjustFlagsAndWidth(semicolonToken);
            this.semicolonToken = semicolonToken;
        }
    }


    internal AccessorDeclarationSyntax(SyntaxKind kind, GreenNode? attributeLists, GreenNode? modifiers, SyntaxToken keyword, BlockSyntax? body, ArrowExpressionClauseSyntax? expressionBody, SyntaxToken? semicolonToken, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 6;
        if (attributeLists != null)
        {
            this.AdjustFlagsAndWidth(attributeLists);
            this.attributeLists = attributeLists;
        }
        if (modifiers != null)
        {
            this.AdjustFlagsAndWidth(modifiers);
            this.modifiers = modifiers;
        }
        this.AdjustFlagsAndWidth(keyword);
        this.keyword = keyword;
        if (body != null)
        {
            this.AdjustFlagsAndWidth(body);
            this.body = body;
        }
        if (expressionBody != null)
        {
            this.AdjustFlagsAndWidth(expressionBody);
            this.expressionBody = expressionBody;
        }
        if (semicolonToken != null)
        {
            this.AdjustFlagsAndWidth(semicolonToken);
            this.semicolonToken = semicolonToken;
        }
    }


    internal AccessorDeclarationSyntax(SyntaxKind kind, GreenNode? attributeLists, GreenNode? modifiers, SyntaxToken keyword, BlockSyntax? body, ArrowExpressionClauseSyntax? expressionBody, SyntaxToken? semicolonToken)
        : base(kind)
    {
        this.SlotCount = 6;
        if (attributeLists != null)
        {
            this.AdjustFlagsAndWidth(attributeLists);
            this.attributeLists = attributeLists;
        }
        if (modifiers != null)
        {
            this.AdjustFlagsAndWidth(modifiers);
            this.modifiers = modifiers;
        }
        this.AdjustFlagsAndWidth(keyword);
        this.keyword = keyword;
        if (body != null)
        {
            this.AdjustFlagsAndWidth(body);
            this.body = body;
        }
        if (expressionBody != null)
        {
            this.AdjustFlagsAndWidth(expressionBody);
            this.expressionBody = expressionBody;
        }
        if (semicolonToken != null)
        {
            this.AdjustFlagsAndWidth(semicolonToken);
            this.semicolonToken = semicolonToken;
        }
    }

    /// <summary>Gets the attribute declaration list.</summary>
    public Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<AttributeListSyntax> AttributeLists => new Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<AttributeListSyntax>(this.attributeLists);
    /// <summary>Gets the modifier list.</summary>
    public Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SyntaxToken> Modifiers => new Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SyntaxToken>(this.modifiers);
    /// <summary>Gets the keyword token, or identifier if an erroneous accessor declaration.</summary>
    public SyntaxToken Keyword => this.keyword;
    /// <summary>Gets the optional body block which may be empty, but it is null if there are no braces.</summary>
    public BlockSyntax? Body => this.body;
    /// <summary>Gets the optional expression body.</summary>
    public ArrowExpressionClauseSyntax? ExpressionBody => this.expressionBody;
    /// <summary>Gets the optional semicolon token.</summary>
    public SyntaxToken? SemicolonToken => this.semicolonToken;

    internal override GreenNode? GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.attributeLists;
            case 1: return this.modifiers;
            case 2: return this.keyword;
            case 3: return this.body;
            case 4: return this.expressionBody;
            case 5: return this.semicolonToken;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new CSharp.Syntax.AccessorDeclarationSyntax(this, parent, position);

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor) => visitor.VisitAccessorDeclaration(this);

    public override void Accept(CSharpSyntaxVisitor visitor) => visitor.VisitAccessorDeclaration(this);

    public AccessorDeclarationSyntax Update(Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<AttributeListSyntax> attributeLists, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SyntaxToken> modifiers, SyntaxToken keyword, BlockSyntax body, ArrowExpressionClauseSyntax expressionBody, SyntaxToken semicolonToken)
    {
        if (attributeLists != this.AttributeLists || modifiers != this.Modifiers || keyword != this.Keyword || body != this.Body || expressionBody != this.ExpressionBody || semicolonToken != this.SemicolonToken)
        {
            var newNode = SyntaxFactory.AccessorDeclaration(this.Kind, attributeLists, modifiers, keyword, body, expressionBody, semicolonToken);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
        => new AccessorDeclarationSyntax(this.Kind, this.attributeLists, this.modifiers, this.keyword, this.body, this.expressionBody, this.semicolonToken, diagnostics, GetAnnotations());

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
        => new AccessorDeclarationSyntax(this.Kind, this.attributeLists, this.modifiers, this.keyword, this.body, this.expressionBody, this.semicolonToken, GetDiagnostics(), annotations);

    internal AccessorDeclarationSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 6;
      var attributeLists = (GreenNode?)reader.ReadValue();
      if (attributeLists != null)
      {
         AdjustFlagsAndWidth(attributeLists);
         this.attributeLists = attributeLists;
      }
      var modifiers = (GreenNode?)reader.ReadValue();
      if (modifiers != null)
      {
         AdjustFlagsAndWidth(modifiers);
         this.modifiers = modifiers;
      }
      var keyword = (SyntaxToken)reader.ReadValue();
      if (keyword != null)
      {
         AdjustFlagsAndWidth(keyword);
         this.keyword = keyword;
      }
      var body = (BlockSyntax?)reader.ReadValue();
      if (body != null)
      {
         AdjustFlagsAndWidth(body);
         this.body = body;
      }
      var expressionBody = (ArrowExpressionClauseSyntax?)reader.ReadValue();
      if (expressionBody != null)
      {
         AdjustFlagsAndWidth(expressionBody);
         this.expressionBody = expressionBody;
      }
      var semicolonToken = (SyntaxToken?)reader.ReadValue();
      if (semicolonToken != null)
      {
         AdjustFlagsAndWidth(semicolonToken);
         this.semicolonToken = semicolonToken;
      }
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.attributeLists);
      writer.WriteValue(this.modifiers);
      writer.WriteValue(this.keyword);
      writer.WriteValue(this.body);
      writer.WriteValue(this.expressionBody);
      writer.WriteValue(this.semicolonToken);
    }

    static AccessorDeclarationSyntax()
    {
       ObjectBinder.RegisterTypeReader(typeof(AccessorDeclarationSyntax), r => new AccessorDeclarationSyntax(r));
    }
  }

  /// <summary>Base type for parameter list syntax.</summary>
  internal abstract partial class BaseParameterListSyntax : CSharpSyntaxNode
  {
    internal BaseParameterListSyntax(SyntaxKind kind, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
      : base(kind, diagnostics, annotations)
    {
    }
    internal BaseParameterListSyntax(SyntaxKind kind)
      : base(kind)
    {
    }

    protected BaseParameterListSyntax(ObjectReader reader)
       : base(reader)
    {
    }

    /// <summary>Gets the parameter list.</summary>
    public abstract Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<ParameterSyntax> Parameters { get; }
  }

  /// <summary>Parameter list syntax.</summary>
  internal sealed partial class ParameterListSyntax : BaseParameterListSyntax
  {
    internal readonly SyntaxToken openParenToken;
    internal readonly GreenNode? parameters;
    internal readonly SyntaxToken closeParenToken;

    internal ParameterListSyntax(SyntaxKind kind, SyntaxToken openParenToken, GreenNode? parameters, SyntaxToken closeParenToken, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 3;
        this.AdjustFlagsAndWidth(openParenToken);
        this.openParenToken = openParenToken;
        if (parameters != null)
        {
            this.AdjustFlagsAndWidth(parameters);
            this.parameters = parameters;
        }
        this.AdjustFlagsAndWidth(closeParenToken);
        this.closeParenToken = closeParenToken;
    }


    internal ParameterListSyntax(SyntaxKind kind, SyntaxToken openParenToken, GreenNode? parameters, SyntaxToken closeParenToken, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 3;
        this.AdjustFlagsAndWidth(openParenToken);
        this.openParenToken = openParenToken;
        if (parameters != null)
        {
            this.AdjustFlagsAndWidth(parameters);
            this.parameters = parameters;
        }
        this.AdjustFlagsAndWidth(closeParenToken);
        this.closeParenToken = closeParenToken;
    }


    internal ParameterListSyntax(SyntaxKind kind, SyntaxToken openParenToken, GreenNode? parameters, SyntaxToken closeParenToken)
        : base(kind)
    {
        this.SlotCount = 3;
        this.AdjustFlagsAndWidth(openParenToken);
        this.openParenToken = openParenToken;
        if (parameters != null)
        {
            this.AdjustFlagsAndWidth(parameters);
            this.parameters = parameters;
        }
        this.AdjustFlagsAndWidth(closeParenToken);
        this.closeParenToken = closeParenToken;
    }

    /// <summary>Gets the open paren token.</summary>
    public SyntaxToken OpenParenToken => this.openParenToken;
    public override Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<ParameterSyntax> Parameters => new Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<ParameterSyntax>(new Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<CSharpSyntaxNode>(this.parameters));
    /// <summary>Gets the close paren token.</summary>
    public SyntaxToken CloseParenToken => this.closeParenToken;

    internal override GreenNode? GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.openParenToken;
            case 1: return this.parameters;
            case 2: return this.closeParenToken;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new CSharp.Syntax.ParameterListSyntax(this, parent, position);

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor) => visitor.VisitParameterList(this);

    public override void Accept(CSharpSyntaxVisitor visitor) => visitor.VisitParameterList(this);

    public ParameterListSyntax Update(SyntaxToken openParenToken, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<ParameterSyntax> parameters, SyntaxToken closeParenToken)
    {
        if (openParenToken != this.OpenParenToken || parameters != this.Parameters || closeParenToken != this.CloseParenToken)
        {
            var newNode = SyntaxFactory.ParameterList(openParenToken, parameters, closeParenToken);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
        => new ParameterListSyntax(this.Kind, this.openParenToken, this.parameters, this.closeParenToken, diagnostics, GetAnnotations());

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
        => new ParameterListSyntax(this.Kind, this.openParenToken, this.parameters, this.closeParenToken, GetDiagnostics(), annotations);

    internal ParameterListSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 3;
      var openParenToken = (SyntaxToken)reader.ReadValue();
      if (openParenToken != null)
      {
         AdjustFlagsAndWidth(openParenToken);
         this.openParenToken = openParenToken;
      }
      var parameters = (GreenNode?)reader.ReadValue();
      if (parameters != null)
      {
         AdjustFlagsAndWidth(parameters);
         this.parameters = parameters;
      }
      var closeParenToken = (SyntaxToken)reader.ReadValue();
      if (closeParenToken != null)
      {
         AdjustFlagsAndWidth(closeParenToken);
         this.closeParenToken = closeParenToken;
      }
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.openParenToken);
      writer.WriteValue(this.parameters);
      writer.WriteValue(this.closeParenToken);
    }

    static ParameterListSyntax()
    {
       ObjectBinder.RegisterTypeReader(typeof(ParameterListSyntax), r => new ParameterListSyntax(r));
    }
  }

  /// <summary>Parameter list syntax with surrounding brackets.</summary>
  internal sealed partial class BracketedParameterListSyntax : BaseParameterListSyntax
  {
    internal readonly SyntaxToken openBracketToken;
    internal readonly GreenNode? parameters;
    internal readonly SyntaxToken closeBracketToken;

    internal BracketedParameterListSyntax(SyntaxKind kind, SyntaxToken openBracketToken, GreenNode? parameters, SyntaxToken closeBracketToken, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 3;
        this.AdjustFlagsAndWidth(openBracketToken);
        this.openBracketToken = openBracketToken;
        if (parameters != null)
        {
            this.AdjustFlagsAndWidth(parameters);
            this.parameters = parameters;
        }
        this.AdjustFlagsAndWidth(closeBracketToken);
        this.closeBracketToken = closeBracketToken;
    }


    internal BracketedParameterListSyntax(SyntaxKind kind, SyntaxToken openBracketToken, GreenNode? parameters, SyntaxToken closeBracketToken, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 3;
        this.AdjustFlagsAndWidth(openBracketToken);
        this.openBracketToken = openBracketToken;
        if (parameters != null)
        {
            this.AdjustFlagsAndWidth(parameters);
            this.parameters = parameters;
        }
        this.AdjustFlagsAndWidth(closeBracketToken);
        this.closeBracketToken = closeBracketToken;
    }


    internal BracketedParameterListSyntax(SyntaxKind kind, SyntaxToken openBracketToken, GreenNode? parameters, SyntaxToken closeBracketToken)
        : base(kind)
    {
        this.SlotCount = 3;
        this.AdjustFlagsAndWidth(openBracketToken);
        this.openBracketToken = openBracketToken;
        if (parameters != null)
        {
            this.AdjustFlagsAndWidth(parameters);
            this.parameters = parameters;
        }
        this.AdjustFlagsAndWidth(closeBracketToken);
        this.closeBracketToken = closeBracketToken;
    }

    /// <summary>Gets the open bracket token.</summary>
    public SyntaxToken OpenBracketToken => this.openBracketToken;
    public override Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<ParameterSyntax> Parameters => new Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<ParameterSyntax>(new Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<CSharpSyntaxNode>(this.parameters));
    /// <summary>Gets the close bracket token.</summary>
    public SyntaxToken CloseBracketToken => this.closeBracketToken;

    internal override GreenNode? GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.openBracketToken;
            case 1: return this.parameters;
            case 2: return this.closeBracketToken;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new CSharp.Syntax.BracketedParameterListSyntax(this, parent, position);

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor) => visitor.VisitBracketedParameterList(this);

    public override void Accept(CSharpSyntaxVisitor visitor) => visitor.VisitBracketedParameterList(this);

    public BracketedParameterListSyntax Update(SyntaxToken openBracketToken, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<ParameterSyntax> parameters, SyntaxToken closeBracketToken)
    {
        if (openBracketToken != this.OpenBracketToken || parameters != this.Parameters || closeBracketToken != this.CloseBracketToken)
        {
            var newNode = SyntaxFactory.BracketedParameterList(openBracketToken, parameters, closeBracketToken);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
        => new BracketedParameterListSyntax(this.Kind, this.openBracketToken, this.parameters, this.closeBracketToken, diagnostics, GetAnnotations());

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
        => new BracketedParameterListSyntax(this.Kind, this.openBracketToken, this.parameters, this.closeBracketToken, GetDiagnostics(), annotations);

    internal BracketedParameterListSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 3;
      var openBracketToken = (SyntaxToken)reader.ReadValue();
      if (openBracketToken != null)
      {
         AdjustFlagsAndWidth(openBracketToken);
         this.openBracketToken = openBracketToken;
      }
      var parameters = (GreenNode?)reader.ReadValue();
      if (parameters != null)
      {
         AdjustFlagsAndWidth(parameters);
         this.parameters = parameters;
      }
      var closeBracketToken = (SyntaxToken)reader.ReadValue();
      if (closeBracketToken != null)
      {
         AdjustFlagsAndWidth(closeBracketToken);
         this.closeBracketToken = closeBracketToken;
      }
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.openBracketToken);
      writer.WriteValue(this.parameters);
      writer.WriteValue(this.closeBracketToken);
    }

    static BracketedParameterListSyntax()
    {
       ObjectBinder.RegisterTypeReader(typeof(BracketedParameterListSyntax), r => new BracketedParameterListSyntax(r));
    }
  }

  /// <summary>Parameter syntax.</summary>
  internal sealed partial class ParameterSyntax : CSharpSyntaxNode
  {
    internal readonly GreenNode? attributeLists;
    internal readonly GreenNode? modifiers;
    internal readonly TypeSyntax? type;
    internal readonly SyntaxToken identifier;
    internal readonly EqualsValueClauseSyntax? @default;

    internal ParameterSyntax(SyntaxKind kind, GreenNode? attributeLists, GreenNode? modifiers, TypeSyntax? type, SyntaxToken identifier, EqualsValueClauseSyntax? @default, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 5;
        if (attributeLists != null)
        {
            this.AdjustFlagsAndWidth(attributeLists);
            this.attributeLists = attributeLists;
        }
        if (modifiers != null)
        {
            this.AdjustFlagsAndWidth(modifiers);
            this.modifiers = modifiers;
        }
        if (type != null)
        {
            this.AdjustFlagsAndWidth(type);
            this.type = type;
        }
        this.AdjustFlagsAndWidth(identifier);
        this.identifier = identifier;
        if (@default != null)
        {
            this.AdjustFlagsAndWidth(@default);
            this.@default = @default;
        }
    }


    internal ParameterSyntax(SyntaxKind kind, GreenNode? attributeLists, GreenNode? modifiers, TypeSyntax? type, SyntaxToken identifier, EqualsValueClauseSyntax? @default, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 5;
        if (attributeLists != null)
        {
            this.AdjustFlagsAndWidth(attributeLists);
            this.attributeLists = attributeLists;
        }
        if (modifiers != null)
        {
            this.AdjustFlagsAndWidth(modifiers);
            this.modifiers = modifiers;
        }
        if (type != null)
        {
            this.AdjustFlagsAndWidth(type);
            this.type = type;
        }
        this.AdjustFlagsAndWidth(identifier);
        this.identifier = identifier;
        if (@default != null)
        {
            this.AdjustFlagsAndWidth(@default);
            this.@default = @default;
        }
    }


    internal ParameterSyntax(SyntaxKind kind, GreenNode? attributeLists, GreenNode? modifiers, TypeSyntax? type, SyntaxToken identifier, EqualsValueClauseSyntax? @default)
        : base(kind)
    {
        this.SlotCount = 5;
        if (attributeLists != null)
        {
            this.AdjustFlagsAndWidth(attributeLists);
            this.attributeLists = attributeLists;
        }
        if (modifiers != null)
        {
            this.AdjustFlagsAndWidth(modifiers);
            this.modifiers = modifiers;
        }
        if (type != null)
        {
            this.AdjustFlagsAndWidth(type);
            this.type = type;
        }
        this.AdjustFlagsAndWidth(identifier);
        this.identifier = identifier;
        if (@default != null)
        {
            this.AdjustFlagsAndWidth(@default);
            this.@default = @default;
        }
    }

    /// <summary>Gets the attribute declaration list.</summary>
    public Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<AttributeListSyntax> AttributeLists => new Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<AttributeListSyntax>(this.attributeLists);
    /// <summary>Gets the modifier list.</summary>
    public Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SyntaxToken> Modifiers => new Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SyntaxToken>(this.modifiers);
    public TypeSyntax? Type => this.type;
    /// <summary>Gets the identifier.</summary>
    public SyntaxToken Identifier => this.identifier;
    public EqualsValueClauseSyntax? Default => this.@default;

    internal override GreenNode? GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.attributeLists;
            case 1: return this.modifiers;
            case 2: return this.type;
            case 3: return this.identifier;
            case 4: return this.@default;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new CSharp.Syntax.ParameterSyntax(this, parent, position);

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor) => visitor.VisitParameter(this);

    public override void Accept(CSharpSyntaxVisitor visitor) => visitor.VisitParameter(this);

    public ParameterSyntax Update(Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<AttributeListSyntax> attributeLists, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SyntaxToken> modifiers, TypeSyntax type, SyntaxToken identifier, EqualsValueClauseSyntax @default)
    {
        if (attributeLists != this.AttributeLists || modifiers != this.Modifiers || type != this.Type || identifier != this.Identifier || @default != this.Default)
        {
            var newNode = SyntaxFactory.Parameter(attributeLists, modifiers, type, identifier, @default);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
        => new ParameterSyntax(this.Kind, this.attributeLists, this.modifiers, this.type, this.identifier, this.@default, diagnostics, GetAnnotations());

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
        => new ParameterSyntax(this.Kind, this.attributeLists, this.modifiers, this.type, this.identifier, this.@default, GetDiagnostics(), annotations);

    internal ParameterSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 5;
      var attributeLists = (GreenNode?)reader.ReadValue();
      if (attributeLists != null)
      {
         AdjustFlagsAndWidth(attributeLists);
         this.attributeLists = attributeLists;
      }
      var modifiers = (GreenNode?)reader.ReadValue();
      if (modifiers != null)
      {
         AdjustFlagsAndWidth(modifiers);
         this.modifiers = modifiers;
      }
      var type = (TypeSyntax?)reader.ReadValue();
      if (type != null)
      {
         AdjustFlagsAndWidth(type);
         this.type = type;
      }
      var identifier = (SyntaxToken)reader.ReadValue();
      if (identifier != null)
      {
         AdjustFlagsAndWidth(identifier);
         this.identifier = identifier;
      }
      var @default = (EqualsValueClauseSyntax?)reader.ReadValue();
      if (@default != null)
      {
         AdjustFlagsAndWidth(@default);
         this.@default = @default;
      }
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.attributeLists);
      writer.WriteValue(this.modifiers);
      writer.WriteValue(this.type);
      writer.WriteValue(this.identifier);
      writer.WriteValue(this.@default);
    }

    static ParameterSyntax()
    {
       ObjectBinder.RegisterTypeReader(typeof(ParameterSyntax), r => new ParameterSyntax(r));
    }
  }

  internal sealed partial class IncompleteMemberSyntax : MemberDeclarationSyntax
  {
    internal readonly GreenNode? attributeLists;
    internal readonly GreenNode? modifiers;
    internal readonly TypeSyntax? type;

    internal IncompleteMemberSyntax(SyntaxKind kind, GreenNode? attributeLists, GreenNode? modifiers, TypeSyntax? type, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 3;
        if (attributeLists != null)
        {
            this.AdjustFlagsAndWidth(attributeLists);
            this.attributeLists = attributeLists;
        }
        if (modifiers != null)
        {
            this.AdjustFlagsAndWidth(modifiers);
            this.modifiers = modifiers;
        }
        if (type != null)
        {
            this.AdjustFlagsAndWidth(type);
            this.type = type;
        }
    }


    internal IncompleteMemberSyntax(SyntaxKind kind, GreenNode? attributeLists, GreenNode? modifiers, TypeSyntax? type, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 3;
        if (attributeLists != null)
        {
            this.AdjustFlagsAndWidth(attributeLists);
            this.attributeLists = attributeLists;
        }
        if (modifiers != null)
        {
            this.AdjustFlagsAndWidth(modifiers);
            this.modifiers = modifiers;
        }
        if (type != null)
        {
            this.AdjustFlagsAndWidth(type);
            this.type = type;
        }
    }


    internal IncompleteMemberSyntax(SyntaxKind kind, GreenNode? attributeLists, GreenNode? modifiers, TypeSyntax? type)
        : base(kind)
    {
        this.SlotCount = 3;
        if (attributeLists != null)
        {
            this.AdjustFlagsAndWidth(attributeLists);
            this.attributeLists = attributeLists;
        }
        if (modifiers != null)
        {
            this.AdjustFlagsAndWidth(modifiers);
            this.modifiers = modifiers;
        }
        if (type != null)
        {
            this.AdjustFlagsAndWidth(type);
            this.type = type;
        }
    }

    public override Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<AttributeListSyntax> AttributeLists => new Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<AttributeListSyntax>(this.attributeLists);
    public override Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SyntaxToken> Modifiers => new Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SyntaxToken>(this.modifiers);
    public TypeSyntax? Type => this.type;

    internal override GreenNode? GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.attributeLists;
            case 1: return this.modifiers;
            case 2: return this.type;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new CSharp.Syntax.IncompleteMemberSyntax(this, parent, position);

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor) => visitor.VisitIncompleteMember(this);

    public override void Accept(CSharpSyntaxVisitor visitor) => visitor.VisitIncompleteMember(this);

    public IncompleteMemberSyntax Update(Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<AttributeListSyntax> attributeLists, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SyntaxToken> modifiers, TypeSyntax type)
    {
        if (attributeLists != this.AttributeLists || modifiers != this.Modifiers || type != this.Type)
        {
            var newNode = SyntaxFactory.IncompleteMember(attributeLists, modifiers, type);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
        => new IncompleteMemberSyntax(this.Kind, this.attributeLists, this.modifiers, this.type, diagnostics, GetAnnotations());

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
        => new IncompleteMemberSyntax(this.Kind, this.attributeLists, this.modifiers, this.type, GetDiagnostics(), annotations);

    internal IncompleteMemberSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 3;
      var attributeLists = (GreenNode?)reader.ReadValue();
      if (attributeLists != null)
      {
         AdjustFlagsAndWidth(attributeLists);
         this.attributeLists = attributeLists;
      }
      var modifiers = (GreenNode?)reader.ReadValue();
      if (modifiers != null)
      {
         AdjustFlagsAndWidth(modifiers);
         this.modifiers = modifiers;
      }
      var type = (TypeSyntax?)reader.ReadValue();
      if (type != null)
      {
         AdjustFlagsAndWidth(type);
         this.type = type;
      }
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.attributeLists);
      writer.WriteValue(this.modifiers);
      writer.WriteValue(this.type);
    }

    static IncompleteMemberSyntax()
    {
       ObjectBinder.RegisterTypeReader(typeof(IncompleteMemberSyntax), r => new IncompleteMemberSyntax(r));
    }
  }

  internal sealed partial class SkippedTokensTriviaSyntax : StructuredTriviaSyntax
  {
    internal readonly GreenNode? tokens;

    internal SkippedTokensTriviaSyntax(SyntaxKind kind, GreenNode? tokens, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 1;
        if (tokens != null)
        {
            this.AdjustFlagsAndWidth(tokens);
            this.tokens = tokens;
        }
    }


    internal SkippedTokensTriviaSyntax(SyntaxKind kind, GreenNode? tokens, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 1;
        if (tokens != null)
        {
            this.AdjustFlagsAndWidth(tokens);
            this.tokens = tokens;
        }
    }


    internal SkippedTokensTriviaSyntax(SyntaxKind kind, GreenNode? tokens)
        : base(kind)
    {
        this.SlotCount = 1;
        if (tokens != null)
        {
            this.AdjustFlagsAndWidth(tokens);
            this.tokens = tokens;
        }
    }

    public Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SyntaxToken> Tokens => new Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SyntaxToken>(this.tokens);

    internal override GreenNode? GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.tokens;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new CSharp.Syntax.SkippedTokensTriviaSyntax(this, parent, position);

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor) => visitor.VisitSkippedTokensTrivia(this);

    public override void Accept(CSharpSyntaxVisitor visitor) => visitor.VisitSkippedTokensTrivia(this);

    public SkippedTokensTriviaSyntax Update(Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SyntaxToken> tokens)
    {
        if (tokens != this.Tokens)
        {
            var newNode = SyntaxFactory.SkippedTokensTrivia(tokens);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
        => new SkippedTokensTriviaSyntax(this.Kind, this.tokens, diagnostics, GetAnnotations());

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
        => new SkippedTokensTriviaSyntax(this.Kind, this.tokens, GetDiagnostics(), annotations);

    internal SkippedTokensTriviaSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 1;
      var tokens = (GreenNode?)reader.ReadValue();
      if (tokens != null)
      {
         AdjustFlagsAndWidth(tokens);
         this.tokens = tokens;
      }
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.tokens);
    }

    static SkippedTokensTriviaSyntax()
    {
       ObjectBinder.RegisterTypeReader(typeof(SkippedTokensTriviaSyntax), r => new SkippedTokensTriviaSyntax(r));
    }
  }

  internal sealed partial class DocumentationCommentTriviaSyntax : StructuredTriviaSyntax
  {
    internal readonly GreenNode? content;
    internal readonly SyntaxToken endOfComment;

    internal DocumentationCommentTriviaSyntax(SyntaxKind kind, GreenNode? content, SyntaxToken endOfComment, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 2;
        if (content != null)
        {
            this.AdjustFlagsAndWidth(content);
            this.content = content;
        }
        this.AdjustFlagsAndWidth(endOfComment);
        this.endOfComment = endOfComment;
    }


    internal DocumentationCommentTriviaSyntax(SyntaxKind kind, GreenNode? content, SyntaxToken endOfComment, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 2;
        if (content != null)
        {
            this.AdjustFlagsAndWidth(content);
            this.content = content;
        }
        this.AdjustFlagsAndWidth(endOfComment);
        this.endOfComment = endOfComment;
    }


    internal DocumentationCommentTriviaSyntax(SyntaxKind kind, GreenNode? content, SyntaxToken endOfComment)
        : base(kind)
    {
        this.SlotCount = 2;
        if (content != null)
        {
            this.AdjustFlagsAndWidth(content);
            this.content = content;
        }
        this.AdjustFlagsAndWidth(endOfComment);
        this.endOfComment = endOfComment;
    }

    public Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<XmlNodeSyntax> Content => new Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<XmlNodeSyntax>(this.content);
    public SyntaxToken EndOfComment => this.endOfComment;

    internal override GreenNode? GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.content;
            case 1: return this.endOfComment;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new CSharp.Syntax.DocumentationCommentTriviaSyntax(this, parent, position);

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor) => visitor.VisitDocumentationCommentTrivia(this);

    public override void Accept(CSharpSyntaxVisitor visitor) => visitor.VisitDocumentationCommentTrivia(this);

    public DocumentationCommentTriviaSyntax Update(Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<XmlNodeSyntax> content, SyntaxToken endOfComment)
    {
        if (content != this.Content || endOfComment != this.EndOfComment)
        {
            var newNode = SyntaxFactory.DocumentationCommentTrivia(this.Kind, content, endOfComment);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
        => new DocumentationCommentTriviaSyntax(this.Kind, this.content, this.endOfComment, diagnostics, GetAnnotations());

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
        => new DocumentationCommentTriviaSyntax(this.Kind, this.content, this.endOfComment, GetDiagnostics(), annotations);

    internal DocumentationCommentTriviaSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 2;
      var content = (GreenNode?)reader.ReadValue();
      if (content != null)
      {
         AdjustFlagsAndWidth(content);
         this.content = content;
      }
      var endOfComment = (SyntaxToken)reader.ReadValue();
      if (endOfComment != null)
      {
         AdjustFlagsAndWidth(endOfComment);
         this.endOfComment = endOfComment;
      }
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.content);
      writer.WriteValue(this.endOfComment);
    }

    static DocumentationCommentTriviaSyntax()
    {
       ObjectBinder.RegisterTypeReader(typeof(DocumentationCommentTriviaSyntax), r => new DocumentationCommentTriviaSyntax(r));
    }
  }

  /// <summary>
  /// A symbol referenced by a cref attribute (e.g. in a &lt;see&gt; or &lt;seealso&gt; documentation comment tag).
  /// For example, the M in &lt;see cref="M" /&gt;.
  /// </summary>
  internal abstract partial class CrefSyntax : CSharpSyntaxNode
  {
    internal CrefSyntax(SyntaxKind kind, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
      : base(kind, diagnostics, annotations)
    {
    }
    internal CrefSyntax(SyntaxKind kind)
      : base(kind)
    {
    }

    protected CrefSyntax(ObjectReader reader)
       : base(reader)
    {
    }
  }

  /// <summary>
  /// A symbol reference that definitely refers to a type.
  /// For example, "int", "A::B", "A.B", "A&lt;T&gt;", but not "M()" (has parameter list) or "this" (indexer).
  /// NOTE: TypeCrefSyntax, QualifiedCrefSyntax, and MemberCrefSyntax overlap.  The syntax in a TypeCrefSyntax
  /// will always be bound as type, so it's safer to use QualifiedCrefSyntax or MemberCrefSyntax if the symbol
  /// might be a non-type member.
  /// </summary>
  internal sealed partial class TypeCrefSyntax : CrefSyntax
  {
    internal readonly TypeSyntax type;

    internal TypeCrefSyntax(SyntaxKind kind, TypeSyntax type, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 1;
        this.AdjustFlagsAndWidth(type);
        this.type = type;
    }


    internal TypeCrefSyntax(SyntaxKind kind, TypeSyntax type, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 1;
        this.AdjustFlagsAndWidth(type);
        this.type = type;
    }


    internal TypeCrefSyntax(SyntaxKind kind, TypeSyntax type)
        : base(kind)
    {
        this.SlotCount = 1;
        this.AdjustFlagsAndWidth(type);
        this.type = type;
    }

    public TypeSyntax Type => this.type;

    internal override GreenNode? GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.type;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new CSharp.Syntax.TypeCrefSyntax(this, parent, position);

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor) => visitor.VisitTypeCref(this);

    public override void Accept(CSharpSyntaxVisitor visitor) => visitor.VisitTypeCref(this);

    public TypeCrefSyntax Update(TypeSyntax type)
    {
        if (type != this.Type)
        {
            var newNode = SyntaxFactory.TypeCref(type);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
        => new TypeCrefSyntax(this.Kind, this.type, diagnostics, GetAnnotations());

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
        => new TypeCrefSyntax(this.Kind, this.type, GetDiagnostics(), annotations);

    internal TypeCrefSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 1;
      var type = (TypeSyntax)reader.ReadValue();
      if (type != null)
      {
         AdjustFlagsAndWidth(type);
         this.type = type;
      }
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.type);
    }

    static TypeCrefSyntax()
    {
       ObjectBinder.RegisterTypeReader(typeof(TypeCrefSyntax), r => new TypeCrefSyntax(r));
    }
  }

  /// <summary>
  /// A symbol reference to a type or non-type member that is qualified by an enclosing type or namespace.
  /// For example, cref="System.String.ToString()".
  /// NOTE: TypeCrefSyntax, QualifiedCrefSyntax, and MemberCrefSyntax overlap.  The syntax in a TypeCrefSyntax
  /// will always be bound as type, so it's safer to use QualifiedCrefSyntax or MemberCrefSyntax if the symbol
  /// might be a non-type member.
  /// </summary>
  internal sealed partial class QualifiedCrefSyntax : CrefSyntax
  {
    internal readonly TypeSyntax container;
    internal readonly SyntaxToken dotToken;
    internal readonly MemberCrefSyntax member;

    internal QualifiedCrefSyntax(SyntaxKind kind, TypeSyntax container, SyntaxToken dotToken, MemberCrefSyntax member, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 3;
        this.AdjustFlagsAndWidth(container);
        this.container = container;
        this.AdjustFlagsAndWidth(dotToken);
        this.dotToken = dotToken;
        this.AdjustFlagsAndWidth(member);
        this.member = member;
    }


    internal QualifiedCrefSyntax(SyntaxKind kind, TypeSyntax container, SyntaxToken dotToken, MemberCrefSyntax member, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 3;
        this.AdjustFlagsAndWidth(container);
        this.container = container;
        this.AdjustFlagsAndWidth(dotToken);
        this.dotToken = dotToken;
        this.AdjustFlagsAndWidth(member);
        this.member = member;
    }


    internal QualifiedCrefSyntax(SyntaxKind kind, TypeSyntax container, SyntaxToken dotToken, MemberCrefSyntax member)
        : base(kind)
    {
        this.SlotCount = 3;
        this.AdjustFlagsAndWidth(container);
        this.container = container;
        this.AdjustFlagsAndWidth(dotToken);
        this.dotToken = dotToken;
        this.AdjustFlagsAndWidth(member);
        this.member = member;
    }

    public TypeSyntax Container => this.container;
    public SyntaxToken DotToken => this.dotToken;
    public MemberCrefSyntax Member => this.member;

    internal override GreenNode? GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.container;
            case 1: return this.dotToken;
            case 2: return this.member;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new CSharp.Syntax.QualifiedCrefSyntax(this, parent, position);

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor) => visitor.VisitQualifiedCref(this);

    public override void Accept(CSharpSyntaxVisitor visitor) => visitor.VisitQualifiedCref(this);

    public QualifiedCrefSyntax Update(TypeSyntax container, SyntaxToken dotToken, MemberCrefSyntax member)
    {
        if (container != this.Container || dotToken != this.DotToken || member != this.Member)
        {
            var newNode = SyntaxFactory.QualifiedCref(container, dotToken, member);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
        => new QualifiedCrefSyntax(this.Kind, this.container, this.dotToken, this.member, diagnostics, GetAnnotations());

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
        => new QualifiedCrefSyntax(this.Kind, this.container, this.dotToken, this.member, GetDiagnostics(), annotations);

    internal QualifiedCrefSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 3;
      var container = (TypeSyntax)reader.ReadValue();
      if (container != null)
      {
         AdjustFlagsAndWidth(container);
         this.container = container;
      }
      var dotToken = (SyntaxToken)reader.ReadValue();
      if (dotToken != null)
      {
         AdjustFlagsAndWidth(dotToken);
         this.dotToken = dotToken;
      }
      var member = (MemberCrefSyntax)reader.ReadValue();
      if (member != null)
      {
         AdjustFlagsAndWidth(member);
         this.member = member;
      }
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.container);
      writer.WriteValue(this.dotToken);
      writer.WriteValue(this.member);
    }

    static QualifiedCrefSyntax()
    {
       ObjectBinder.RegisterTypeReader(typeof(QualifiedCrefSyntax), r => new QualifiedCrefSyntax(r));
    }
  }

  /// <summary>
  /// The unqualified part of a CrefSyntax.
  /// For example, "ToString()" in "object.ToString()".
  /// NOTE: TypeCrefSyntax, QualifiedCrefSyntax, and MemberCrefSyntax overlap.  The syntax in a TypeCrefSyntax
  /// will always be bound as type, so it's safer to use QualifiedCrefSyntax or MemberCrefSyntax if the symbol
  /// might be a non-type member.
  /// </summary>
  internal abstract partial class MemberCrefSyntax : CrefSyntax
  {
    internal MemberCrefSyntax(SyntaxKind kind, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
      : base(kind, diagnostics, annotations)
    {
    }
    internal MemberCrefSyntax(SyntaxKind kind)
      : base(kind)
    {
    }

    protected MemberCrefSyntax(ObjectReader reader)
       : base(reader)
    {
    }
  }

  /// <summary>
  /// A MemberCrefSyntax specified by a name (an identifier, predefined type keyword, or an alias-qualified name,
  /// with an optional type parameter list) and an optional parameter list.
  /// For example, "M", "M&lt;T&gt;" or "M(int)".
  /// Also, "A::B()" or "string()".
  /// </summary>
  internal sealed partial class NameMemberCrefSyntax : MemberCrefSyntax
  {
    internal readonly TypeSyntax name;
    internal readonly CrefParameterListSyntax? parameters;

    internal NameMemberCrefSyntax(SyntaxKind kind, TypeSyntax name, CrefParameterListSyntax? parameters, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 2;
        this.AdjustFlagsAndWidth(name);
        this.name = name;
        if (parameters != null)
        {
            this.AdjustFlagsAndWidth(parameters);
            this.parameters = parameters;
        }
    }


    internal NameMemberCrefSyntax(SyntaxKind kind, TypeSyntax name, CrefParameterListSyntax? parameters, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 2;
        this.AdjustFlagsAndWidth(name);
        this.name = name;
        if (parameters != null)
        {
            this.AdjustFlagsAndWidth(parameters);
            this.parameters = parameters;
        }
    }


    internal NameMemberCrefSyntax(SyntaxKind kind, TypeSyntax name, CrefParameterListSyntax? parameters)
        : base(kind)
    {
        this.SlotCount = 2;
        this.AdjustFlagsAndWidth(name);
        this.name = name;
        if (parameters != null)
        {
            this.AdjustFlagsAndWidth(parameters);
            this.parameters = parameters;
        }
    }

    public TypeSyntax Name => this.name;
    public CrefParameterListSyntax? Parameters => this.parameters;

    internal override GreenNode? GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.name;
            case 1: return this.parameters;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new CSharp.Syntax.NameMemberCrefSyntax(this, parent, position);

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor) => visitor.VisitNameMemberCref(this);

    public override void Accept(CSharpSyntaxVisitor visitor) => visitor.VisitNameMemberCref(this);

    public NameMemberCrefSyntax Update(TypeSyntax name, CrefParameterListSyntax parameters)
    {
        if (name != this.Name || parameters != this.Parameters)
        {
            var newNode = SyntaxFactory.NameMemberCref(name, parameters);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
        => new NameMemberCrefSyntax(this.Kind, this.name, this.parameters, diagnostics, GetAnnotations());

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
        => new NameMemberCrefSyntax(this.Kind, this.name, this.parameters, GetDiagnostics(), annotations);

    internal NameMemberCrefSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 2;
      var name = (TypeSyntax)reader.ReadValue();
      if (name != null)
      {
         AdjustFlagsAndWidth(name);
         this.name = name;
      }
      var parameters = (CrefParameterListSyntax?)reader.ReadValue();
      if (parameters != null)
      {
         AdjustFlagsAndWidth(parameters);
         this.parameters = parameters;
      }
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.name);
      writer.WriteValue(this.parameters);
    }

    static NameMemberCrefSyntax()
    {
       ObjectBinder.RegisterTypeReader(typeof(NameMemberCrefSyntax), r => new NameMemberCrefSyntax(r));
    }
  }

  /// <summary>
  /// A MemberCrefSyntax specified by a this keyword and an optional parameter list.
  /// For example, "this" or "this[int]".
  /// </summary>
  internal sealed partial class IndexerMemberCrefSyntax : MemberCrefSyntax
  {
    internal readonly SyntaxToken thisKeyword;
    internal readonly CrefBracketedParameterListSyntax? parameters;

    internal IndexerMemberCrefSyntax(SyntaxKind kind, SyntaxToken thisKeyword, CrefBracketedParameterListSyntax? parameters, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 2;
        this.AdjustFlagsAndWidth(thisKeyword);
        this.thisKeyword = thisKeyword;
        if (parameters != null)
        {
            this.AdjustFlagsAndWidth(parameters);
            this.parameters = parameters;
        }
    }


    internal IndexerMemberCrefSyntax(SyntaxKind kind, SyntaxToken thisKeyword, CrefBracketedParameterListSyntax? parameters, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 2;
        this.AdjustFlagsAndWidth(thisKeyword);
        this.thisKeyword = thisKeyword;
        if (parameters != null)
        {
            this.AdjustFlagsAndWidth(parameters);
            this.parameters = parameters;
        }
    }


    internal IndexerMemberCrefSyntax(SyntaxKind kind, SyntaxToken thisKeyword, CrefBracketedParameterListSyntax? parameters)
        : base(kind)
    {
        this.SlotCount = 2;
        this.AdjustFlagsAndWidth(thisKeyword);
        this.thisKeyword = thisKeyword;
        if (parameters != null)
        {
            this.AdjustFlagsAndWidth(parameters);
            this.parameters = parameters;
        }
    }

    public SyntaxToken ThisKeyword => this.thisKeyword;
    public CrefBracketedParameterListSyntax? Parameters => this.parameters;

    internal override GreenNode? GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.thisKeyword;
            case 1: return this.parameters;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new CSharp.Syntax.IndexerMemberCrefSyntax(this, parent, position);

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor) => visitor.VisitIndexerMemberCref(this);

    public override void Accept(CSharpSyntaxVisitor visitor) => visitor.VisitIndexerMemberCref(this);

    public IndexerMemberCrefSyntax Update(SyntaxToken thisKeyword, CrefBracketedParameterListSyntax parameters)
    {
        if (thisKeyword != this.ThisKeyword || parameters != this.Parameters)
        {
            var newNode = SyntaxFactory.IndexerMemberCref(thisKeyword, parameters);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
        => new IndexerMemberCrefSyntax(this.Kind, this.thisKeyword, this.parameters, diagnostics, GetAnnotations());

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
        => new IndexerMemberCrefSyntax(this.Kind, this.thisKeyword, this.parameters, GetDiagnostics(), annotations);

    internal IndexerMemberCrefSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 2;
      var thisKeyword = (SyntaxToken)reader.ReadValue();
      if (thisKeyword != null)
      {
         AdjustFlagsAndWidth(thisKeyword);
         this.thisKeyword = thisKeyword;
      }
      var parameters = (CrefBracketedParameterListSyntax?)reader.ReadValue();
      if (parameters != null)
      {
         AdjustFlagsAndWidth(parameters);
         this.parameters = parameters;
      }
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.thisKeyword);
      writer.WriteValue(this.parameters);
    }

    static IndexerMemberCrefSyntax()
    {
       ObjectBinder.RegisterTypeReader(typeof(IndexerMemberCrefSyntax), r => new IndexerMemberCrefSyntax(r));
    }
  }

  /// <summary>
  /// A MemberCrefSyntax specified by an operator keyword, an operator symbol and an optional parameter list.
  /// For example, "operator +" or "operator -[int]".
  /// NOTE: the operator must be overloadable.
  /// </summary>
  internal sealed partial class OperatorMemberCrefSyntax : MemberCrefSyntax
  {
    internal readonly SyntaxToken operatorKeyword;
    internal readonly SyntaxToken operatorToken;
    internal readonly CrefParameterListSyntax? parameters;

    internal OperatorMemberCrefSyntax(SyntaxKind kind, SyntaxToken operatorKeyword, SyntaxToken operatorToken, CrefParameterListSyntax? parameters, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 3;
        this.AdjustFlagsAndWidth(operatorKeyword);
        this.operatorKeyword = operatorKeyword;
        this.AdjustFlagsAndWidth(operatorToken);
        this.operatorToken = operatorToken;
        if (parameters != null)
        {
            this.AdjustFlagsAndWidth(parameters);
            this.parameters = parameters;
        }
    }


    internal OperatorMemberCrefSyntax(SyntaxKind kind, SyntaxToken operatorKeyword, SyntaxToken operatorToken, CrefParameterListSyntax? parameters, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 3;
        this.AdjustFlagsAndWidth(operatorKeyword);
        this.operatorKeyword = operatorKeyword;
        this.AdjustFlagsAndWidth(operatorToken);
        this.operatorToken = operatorToken;
        if (parameters != null)
        {
            this.AdjustFlagsAndWidth(parameters);
            this.parameters = parameters;
        }
    }


    internal OperatorMemberCrefSyntax(SyntaxKind kind, SyntaxToken operatorKeyword, SyntaxToken operatorToken, CrefParameterListSyntax? parameters)
        : base(kind)
    {
        this.SlotCount = 3;
        this.AdjustFlagsAndWidth(operatorKeyword);
        this.operatorKeyword = operatorKeyword;
        this.AdjustFlagsAndWidth(operatorToken);
        this.operatorToken = operatorToken;
        if (parameters != null)
        {
            this.AdjustFlagsAndWidth(parameters);
            this.parameters = parameters;
        }
    }

    public SyntaxToken OperatorKeyword => this.operatorKeyword;
    /// <summary>Gets the operator token.</summary>
    public SyntaxToken OperatorToken => this.operatorToken;
    public CrefParameterListSyntax? Parameters => this.parameters;

    internal override GreenNode? GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.operatorKeyword;
            case 1: return this.operatorToken;
            case 2: return this.parameters;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new CSharp.Syntax.OperatorMemberCrefSyntax(this, parent, position);

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor) => visitor.VisitOperatorMemberCref(this);

    public override void Accept(CSharpSyntaxVisitor visitor) => visitor.VisitOperatorMemberCref(this);

    public OperatorMemberCrefSyntax Update(SyntaxToken operatorKeyword, SyntaxToken operatorToken, CrefParameterListSyntax parameters)
    {
        if (operatorKeyword != this.OperatorKeyword || operatorToken != this.OperatorToken || parameters != this.Parameters)
        {
            var newNode = SyntaxFactory.OperatorMemberCref(operatorKeyword, operatorToken, parameters);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
        => new OperatorMemberCrefSyntax(this.Kind, this.operatorKeyword, this.operatorToken, this.parameters, diagnostics, GetAnnotations());

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
        => new OperatorMemberCrefSyntax(this.Kind, this.operatorKeyword, this.operatorToken, this.parameters, GetDiagnostics(), annotations);

    internal OperatorMemberCrefSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 3;
      var operatorKeyword = (SyntaxToken)reader.ReadValue();
      if (operatorKeyword != null)
      {
         AdjustFlagsAndWidth(operatorKeyword);
         this.operatorKeyword = operatorKeyword;
      }
      var operatorToken = (SyntaxToken)reader.ReadValue();
      if (operatorToken != null)
      {
         AdjustFlagsAndWidth(operatorToken);
         this.operatorToken = operatorToken;
      }
      var parameters = (CrefParameterListSyntax?)reader.ReadValue();
      if (parameters != null)
      {
         AdjustFlagsAndWidth(parameters);
         this.parameters = parameters;
      }
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.operatorKeyword);
      writer.WriteValue(this.operatorToken);
      writer.WriteValue(this.parameters);
    }

    static OperatorMemberCrefSyntax()
    {
       ObjectBinder.RegisterTypeReader(typeof(OperatorMemberCrefSyntax), r => new OperatorMemberCrefSyntax(r));
    }
  }

  /// <summary>
  /// A MemberCrefSyntax specified by an implicit or explicit keyword, an operator keyword, a destination type, and an optional parameter list.
  /// For example, "implicit operator int" or "explicit operator MyType(int)".
  /// </summary>
  internal sealed partial class ConversionOperatorMemberCrefSyntax : MemberCrefSyntax
  {
    internal readonly SyntaxToken implicitOrExplicitKeyword;
    internal readonly SyntaxToken operatorKeyword;
    internal readonly TypeSyntax type;
    internal readonly CrefParameterListSyntax? parameters;

    internal ConversionOperatorMemberCrefSyntax(SyntaxKind kind, SyntaxToken implicitOrExplicitKeyword, SyntaxToken operatorKeyword, TypeSyntax type, CrefParameterListSyntax? parameters, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 4;
        this.AdjustFlagsAndWidth(implicitOrExplicitKeyword);
        this.implicitOrExplicitKeyword = implicitOrExplicitKeyword;
        this.AdjustFlagsAndWidth(operatorKeyword);
        this.operatorKeyword = operatorKeyword;
        this.AdjustFlagsAndWidth(type);
        this.type = type;
        if (parameters != null)
        {
            this.AdjustFlagsAndWidth(parameters);
            this.parameters = parameters;
        }
    }


    internal ConversionOperatorMemberCrefSyntax(SyntaxKind kind, SyntaxToken implicitOrExplicitKeyword, SyntaxToken operatorKeyword, TypeSyntax type, CrefParameterListSyntax? parameters, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 4;
        this.AdjustFlagsAndWidth(implicitOrExplicitKeyword);
        this.implicitOrExplicitKeyword = implicitOrExplicitKeyword;
        this.AdjustFlagsAndWidth(operatorKeyword);
        this.operatorKeyword = operatorKeyword;
        this.AdjustFlagsAndWidth(type);
        this.type = type;
        if (parameters != null)
        {
            this.AdjustFlagsAndWidth(parameters);
            this.parameters = parameters;
        }
    }


    internal ConversionOperatorMemberCrefSyntax(SyntaxKind kind, SyntaxToken implicitOrExplicitKeyword, SyntaxToken operatorKeyword, TypeSyntax type, CrefParameterListSyntax? parameters)
        : base(kind)
    {
        this.SlotCount = 4;
        this.AdjustFlagsAndWidth(implicitOrExplicitKeyword);
        this.implicitOrExplicitKeyword = implicitOrExplicitKeyword;
        this.AdjustFlagsAndWidth(operatorKeyword);
        this.operatorKeyword = operatorKeyword;
        this.AdjustFlagsAndWidth(type);
        this.type = type;
        if (parameters != null)
        {
            this.AdjustFlagsAndWidth(parameters);
            this.parameters = parameters;
        }
    }

    public SyntaxToken ImplicitOrExplicitKeyword => this.implicitOrExplicitKeyword;
    public SyntaxToken OperatorKeyword => this.operatorKeyword;
    public TypeSyntax Type => this.type;
    public CrefParameterListSyntax? Parameters => this.parameters;

    internal override GreenNode? GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.implicitOrExplicitKeyword;
            case 1: return this.operatorKeyword;
            case 2: return this.type;
            case 3: return this.parameters;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new CSharp.Syntax.ConversionOperatorMemberCrefSyntax(this, parent, position);

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor) => visitor.VisitConversionOperatorMemberCref(this);

    public override void Accept(CSharpSyntaxVisitor visitor) => visitor.VisitConversionOperatorMemberCref(this);

    public ConversionOperatorMemberCrefSyntax Update(SyntaxToken implicitOrExplicitKeyword, SyntaxToken operatorKeyword, TypeSyntax type, CrefParameterListSyntax parameters)
    {
        if (implicitOrExplicitKeyword != this.ImplicitOrExplicitKeyword || operatorKeyword != this.OperatorKeyword || type != this.Type || parameters != this.Parameters)
        {
            var newNode = SyntaxFactory.ConversionOperatorMemberCref(implicitOrExplicitKeyword, operatorKeyword, type, parameters);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
        => new ConversionOperatorMemberCrefSyntax(this.Kind, this.implicitOrExplicitKeyword, this.operatorKeyword, this.type, this.parameters, diagnostics, GetAnnotations());

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
        => new ConversionOperatorMemberCrefSyntax(this.Kind, this.implicitOrExplicitKeyword, this.operatorKeyword, this.type, this.parameters, GetDiagnostics(), annotations);

    internal ConversionOperatorMemberCrefSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 4;
      var implicitOrExplicitKeyword = (SyntaxToken)reader.ReadValue();
      if (implicitOrExplicitKeyword != null)
      {
         AdjustFlagsAndWidth(implicitOrExplicitKeyword);
         this.implicitOrExplicitKeyword = implicitOrExplicitKeyword;
      }
      var operatorKeyword = (SyntaxToken)reader.ReadValue();
      if (operatorKeyword != null)
      {
         AdjustFlagsAndWidth(operatorKeyword);
         this.operatorKeyword = operatorKeyword;
      }
      var type = (TypeSyntax)reader.ReadValue();
      if (type != null)
      {
         AdjustFlagsAndWidth(type);
         this.type = type;
      }
      var parameters = (CrefParameterListSyntax?)reader.ReadValue();
      if (parameters != null)
      {
         AdjustFlagsAndWidth(parameters);
         this.parameters = parameters;
      }
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.implicitOrExplicitKeyword);
      writer.WriteValue(this.operatorKeyword);
      writer.WriteValue(this.type);
      writer.WriteValue(this.parameters);
    }

    static ConversionOperatorMemberCrefSyntax()
    {
       ObjectBinder.RegisterTypeReader(typeof(ConversionOperatorMemberCrefSyntax), r => new ConversionOperatorMemberCrefSyntax(r));
    }
  }

  /// <summary>
  /// A list of cref parameters with surrounding punctuation.
  /// Unlike regular parameters, cref parameters do not have names.
  /// </summary>
  internal abstract partial class BaseCrefParameterListSyntax : CSharpSyntaxNode
  {
    internal BaseCrefParameterListSyntax(SyntaxKind kind, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
      : base(kind, diagnostics, annotations)
    {
    }
    internal BaseCrefParameterListSyntax(SyntaxKind kind)
      : base(kind)
    {
    }

    protected BaseCrefParameterListSyntax(ObjectReader reader)
       : base(reader)
    {
    }

    /// <summary>Gets the parameter list.</summary>
    public abstract Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<CrefParameterSyntax> Parameters { get; }
  }

  /// <summary>
  /// A parenthesized list of cref parameters.
  /// </summary>
  internal sealed partial class CrefParameterListSyntax : BaseCrefParameterListSyntax
  {
    internal readonly SyntaxToken openParenToken;
    internal readonly GreenNode? parameters;
    internal readonly SyntaxToken closeParenToken;

    internal CrefParameterListSyntax(SyntaxKind kind, SyntaxToken openParenToken, GreenNode? parameters, SyntaxToken closeParenToken, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 3;
        this.AdjustFlagsAndWidth(openParenToken);
        this.openParenToken = openParenToken;
        if (parameters != null)
        {
            this.AdjustFlagsAndWidth(parameters);
            this.parameters = parameters;
        }
        this.AdjustFlagsAndWidth(closeParenToken);
        this.closeParenToken = closeParenToken;
    }


    internal CrefParameterListSyntax(SyntaxKind kind, SyntaxToken openParenToken, GreenNode? parameters, SyntaxToken closeParenToken, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 3;
        this.AdjustFlagsAndWidth(openParenToken);
        this.openParenToken = openParenToken;
        if (parameters != null)
        {
            this.AdjustFlagsAndWidth(parameters);
            this.parameters = parameters;
        }
        this.AdjustFlagsAndWidth(closeParenToken);
        this.closeParenToken = closeParenToken;
    }


    internal CrefParameterListSyntax(SyntaxKind kind, SyntaxToken openParenToken, GreenNode? parameters, SyntaxToken closeParenToken)
        : base(kind)
    {
        this.SlotCount = 3;
        this.AdjustFlagsAndWidth(openParenToken);
        this.openParenToken = openParenToken;
        if (parameters != null)
        {
            this.AdjustFlagsAndWidth(parameters);
            this.parameters = parameters;
        }
        this.AdjustFlagsAndWidth(closeParenToken);
        this.closeParenToken = closeParenToken;
    }

    /// <summary>Gets the open paren token.</summary>
    public SyntaxToken OpenParenToken => this.openParenToken;
    public override Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<CrefParameterSyntax> Parameters => new Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<CrefParameterSyntax>(new Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<CSharpSyntaxNode>(this.parameters));
    /// <summary>Gets the close paren token.</summary>
    public SyntaxToken CloseParenToken => this.closeParenToken;

    internal override GreenNode? GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.openParenToken;
            case 1: return this.parameters;
            case 2: return this.closeParenToken;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new CSharp.Syntax.CrefParameterListSyntax(this, parent, position);

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor) => visitor.VisitCrefParameterList(this);

    public override void Accept(CSharpSyntaxVisitor visitor) => visitor.VisitCrefParameterList(this);

    public CrefParameterListSyntax Update(SyntaxToken openParenToken, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<CrefParameterSyntax> parameters, SyntaxToken closeParenToken)
    {
        if (openParenToken != this.OpenParenToken || parameters != this.Parameters || closeParenToken != this.CloseParenToken)
        {
            var newNode = SyntaxFactory.CrefParameterList(openParenToken, parameters, closeParenToken);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
        => new CrefParameterListSyntax(this.Kind, this.openParenToken, this.parameters, this.closeParenToken, diagnostics, GetAnnotations());

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
        => new CrefParameterListSyntax(this.Kind, this.openParenToken, this.parameters, this.closeParenToken, GetDiagnostics(), annotations);

    internal CrefParameterListSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 3;
      var openParenToken = (SyntaxToken)reader.ReadValue();
      if (openParenToken != null)
      {
         AdjustFlagsAndWidth(openParenToken);
         this.openParenToken = openParenToken;
      }
      var parameters = (GreenNode?)reader.ReadValue();
      if (parameters != null)
      {
         AdjustFlagsAndWidth(parameters);
         this.parameters = parameters;
      }
      var closeParenToken = (SyntaxToken)reader.ReadValue();
      if (closeParenToken != null)
      {
         AdjustFlagsAndWidth(closeParenToken);
         this.closeParenToken = closeParenToken;
      }
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.openParenToken);
      writer.WriteValue(this.parameters);
      writer.WriteValue(this.closeParenToken);
    }

    static CrefParameterListSyntax()
    {
       ObjectBinder.RegisterTypeReader(typeof(CrefParameterListSyntax), r => new CrefParameterListSyntax(r));
    }
  }

  /// <summary>
  /// A bracketed list of cref parameters.
  /// </summary>
  internal sealed partial class CrefBracketedParameterListSyntax : BaseCrefParameterListSyntax
  {
    internal readonly SyntaxToken openBracketToken;
    internal readonly GreenNode? parameters;
    internal readonly SyntaxToken closeBracketToken;

    internal CrefBracketedParameterListSyntax(SyntaxKind kind, SyntaxToken openBracketToken, GreenNode? parameters, SyntaxToken closeBracketToken, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 3;
        this.AdjustFlagsAndWidth(openBracketToken);
        this.openBracketToken = openBracketToken;
        if (parameters != null)
        {
            this.AdjustFlagsAndWidth(parameters);
            this.parameters = parameters;
        }
        this.AdjustFlagsAndWidth(closeBracketToken);
        this.closeBracketToken = closeBracketToken;
    }


    internal CrefBracketedParameterListSyntax(SyntaxKind kind, SyntaxToken openBracketToken, GreenNode? parameters, SyntaxToken closeBracketToken, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 3;
        this.AdjustFlagsAndWidth(openBracketToken);
        this.openBracketToken = openBracketToken;
        if (parameters != null)
        {
            this.AdjustFlagsAndWidth(parameters);
            this.parameters = parameters;
        }
        this.AdjustFlagsAndWidth(closeBracketToken);
        this.closeBracketToken = closeBracketToken;
    }


    internal CrefBracketedParameterListSyntax(SyntaxKind kind, SyntaxToken openBracketToken, GreenNode? parameters, SyntaxToken closeBracketToken)
        : base(kind)
    {
        this.SlotCount = 3;
        this.AdjustFlagsAndWidth(openBracketToken);
        this.openBracketToken = openBracketToken;
        if (parameters != null)
        {
            this.AdjustFlagsAndWidth(parameters);
            this.parameters = parameters;
        }
        this.AdjustFlagsAndWidth(closeBracketToken);
        this.closeBracketToken = closeBracketToken;
    }

    /// <summary>Gets the open bracket token.</summary>
    public SyntaxToken OpenBracketToken => this.openBracketToken;
    public override Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<CrefParameterSyntax> Parameters => new Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<CrefParameterSyntax>(new Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<CSharpSyntaxNode>(this.parameters));
    /// <summary>Gets the close bracket token.</summary>
    public SyntaxToken CloseBracketToken => this.closeBracketToken;

    internal override GreenNode? GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.openBracketToken;
            case 1: return this.parameters;
            case 2: return this.closeBracketToken;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new CSharp.Syntax.CrefBracketedParameterListSyntax(this, parent, position);

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor) => visitor.VisitCrefBracketedParameterList(this);

    public override void Accept(CSharpSyntaxVisitor visitor) => visitor.VisitCrefBracketedParameterList(this);

    public CrefBracketedParameterListSyntax Update(SyntaxToken openBracketToken, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<CrefParameterSyntax> parameters, SyntaxToken closeBracketToken)
    {
        if (openBracketToken != this.OpenBracketToken || parameters != this.Parameters || closeBracketToken != this.CloseBracketToken)
        {
            var newNode = SyntaxFactory.CrefBracketedParameterList(openBracketToken, parameters, closeBracketToken);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
        => new CrefBracketedParameterListSyntax(this.Kind, this.openBracketToken, this.parameters, this.closeBracketToken, diagnostics, GetAnnotations());

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
        => new CrefBracketedParameterListSyntax(this.Kind, this.openBracketToken, this.parameters, this.closeBracketToken, GetDiagnostics(), annotations);

    internal CrefBracketedParameterListSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 3;
      var openBracketToken = (SyntaxToken)reader.ReadValue();
      if (openBracketToken != null)
      {
         AdjustFlagsAndWidth(openBracketToken);
         this.openBracketToken = openBracketToken;
      }
      var parameters = (GreenNode?)reader.ReadValue();
      if (parameters != null)
      {
         AdjustFlagsAndWidth(parameters);
         this.parameters = parameters;
      }
      var closeBracketToken = (SyntaxToken)reader.ReadValue();
      if (closeBracketToken != null)
      {
         AdjustFlagsAndWidth(closeBracketToken);
         this.closeBracketToken = closeBracketToken;
      }
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.openBracketToken);
      writer.WriteValue(this.parameters);
      writer.WriteValue(this.closeBracketToken);
    }

    static CrefBracketedParameterListSyntax()
    {
       ObjectBinder.RegisterTypeReader(typeof(CrefBracketedParameterListSyntax), r => new CrefBracketedParameterListSyntax(r));
    }
  }

  /// <summary>
  /// An element of a BaseCrefParameterListSyntax.
  /// Unlike a regular parameter, a cref parameter has only an optional ref or out keyword and a type -
  /// there is no name and there are no attributes or other modifiers.
  /// </summary>
  internal sealed partial class CrefParameterSyntax : CSharpSyntaxNode
  {
    internal readonly SyntaxToken? refKindKeyword;
    internal readonly TypeSyntax type;

    internal CrefParameterSyntax(SyntaxKind kind, SyntaxToken? refKindKeyword, TypeSyntax type, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 2;
        if (refKindKeyword != null)
        {
            this.AdjustFlagsAndWidth(refKindKeyword);
            this.refKindKeyword = refKindKeyword;
        }
        this.AdjustFlagsAndWidth(type);
        this.type = type;
    }


    internal CrefParameterSyntax(SyntaxKind kind, SyntaxToken? refKindKeyword, TypeSyntax type, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 2;
        if (refKindKeyword != null)
        {
            this.AdjustFlagsAndWidth(refKindKeyword);
            this.refKindKeyword = refKindKeyword;
        }
        this.AdjustFlagsAndWidth(type);
        this.type = type;
    }


    internal CrefParameterSyntax(SyntaxKind kind, SyntaxToken? refKindKeyword, TypeSyntax type)
        : base(kind)
    {
        this.SlotCount = 2;
        if (refKindKeyword != null)
        {
            this.AdjustFlagsAndWidth(refKindKeyword);
            this.refKindKeyword = refKindKeyword;
        }
        this.AdjustFlagsAndWidth(type);
        this.type = type;
    }

    public SyntaxToken? RefKindKeyword => this.refKindKeyword;
    public TypeSyntax Type => this.type;

    internal override GreenNode? GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.refKindKeyword;
            case 1: return this.type;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new CSharp.Syntax.CrefParameterSyntax(this, parent, position);

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor) => visitor.VisitCrefParameter(this);

    public override void Accept(CSharpSyntaxVisitor visitor) => visitor.VisitCrefParameter(this);

    public CrefParameterSyntax Update(SyntaxToken refKindKeyword, TypeSyntax type)
    {
        if (refKindKeyword != this.RefKindKeyword || type != this.Type)
        {
            var newNode = SyntaxFactory.CrefParameter(refKindKeyword, type);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
        => new CrefParameterSyntax(this.Kind, this.refKindKeyword, this.type, diagnostics, GetAnnotations());

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
        => new CrefParameterSyntax(this.Kind, this.refKindKeyword, this.type, GetDiagnostics(), annotations);

    internal CrefParameterSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 2;
      var refKindKeyword = (SyntaxToken?)reader.ReadValue();
      if (refKindKeyword != null)
      {
         AdjustFlagsAndWidth(refKindKeyword);
         this.refKindKeyword = refKindKeyword;
      }
      var type = (TypeSyntax)reader.ReadValue();
      if (type != null)
      {
         AdjustFlagsAndWidth(type);
         this.type = type;
      }
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.refKindKeyword);
      writer.WriteValue(this.type);
    }

    static CrefParameterSyntax()
    {
       ObjectBinder.RegisterTypeReader(typeof(CrefParameterSyntax), r => new CrefParameterSyntax(r));
    }
  }

  internal abstract partial class XmlNodeSyntax : CSharpSyntaxNode
  {
    internal XmlNodeSyntax(SyntaxKind kind, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
      : base(kind, diagnostics, annotations)
    {
    }
    internal XmlNodeSyntax(SyntaxKind kind)
      : base(kind)
    {
    }

    protected XmlNodeSyntax(ObjectReader reader)
       : base(reader)
    {
    }
  }

  internal sealed partial class XmlElementSyntax : XmlNodeSyntax
  {
    internal readonly XmlElementStartTagSyntax startTag;
    internal readonly GreenNode? content;
    internal readonly XmlElementEndTagSyntax endTag;

    internal XmlElementSyntax(SyntaxKind kind, XmlElementStartTagSyntax startTag, GreenNode? content, XmlElementEndTagSyntax endTag, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 3;
        this.AdjustFlagsAndWidth(startTag);
        this.startTag = startTag;
        if (content != null)
        {
            this.AdjustFlagsAndWidth(content);
            this.content = content;
        }
        this.AdjustFlagsAndWidth(endTag);
        this.endTag = endTag;
    }


    internal XmlElementSyntax(SyntaxKind kind, XmlElementStartTagSyntax startTag, GreenNode? content, XmlElementEndTagSyntax endTag, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 3;
        this.AdjustFlagsAndWidth(startTag);
        this.startTag = startTag;
        if (content != null)
        {
            this.AdjustFlagsAndWidth(content);
            this.content = content;
        }
        this.AdjustFlagsAndWidth(endTag);
        this.endTag = endTag;
    }


    internal XmlElementSyntax(SyntaxKind kind, XmlElementStartTagSyntax startTag, GreenNode? content, XmlElementEndTagSyntax endTag)
        : base(kind)
    {
        this.SlotCount = 3;
        this.AdjustFlagsAndWidth(startTag);
        this.startTag = startTag;
        if (content != null)
        {
            this.AdjustFlagsAndWidth(content);
            this.content = content;
        }
        this.AdjustFlagsAndWidth(endTag);
        this.endTag = endTag;
    }

    public XmlElementStartTagSyntax StartTag => this.startTag;
    public Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<XmlNodeSyntax> Content => new Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<XmlNodeSyntax>(this.content);
    public XmlElementEndTagSyntax EndTag => this.endTag;

    internal override GreenNode? GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.startTag;
            case 1: return this.content;
            case 2: return this.endTag;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new CSharp.Syntax.XmlElementSyntax(this, parent, position);

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor) => visitor.VisitXmlElement(this);

    public override void Accept(CSharpSyntaxVisitor visitor) => visitor.VisitXmlElement(this);

    public XmlElementSyntax Update(XmlElementStartTagSyntax startTag, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<XmlNodeSyntax> content, XmlElementEndTagSyntax endTag)
    {
        if (startTag != this.StartTag || content != this.Content || endTag != this.EndTag)
        {
            var newNode = SyntaxFactory.XmlElement(startTag, content, endTag);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
        => new XmlElementSyntax(this.Kind, this.startTag, this.content, this.endTag, diagnostics, GetAnnotations());

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
        => new XmlElementSyntax(this.Kind, this.startTag, this.content, this.endTag, GetDiagnostics(), annotations);

    internal XmlElementSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 3;
      var startTag = (XmlElementStartTagSyntax)reader.ReadValue();
      if (startTag != null)
      {
         AdjustFlagsAndWidth(startTag);
         this.startTag = startTag;
      }
      var content = (GreenNode?)reader.ReadValue();
      if (content != null)
      {
         AdjustFlagsAndWidth(content);
         this.content = content;
      }
      var endTag = (XmlElementEndTagSyntax)reader.ReadValue();
      if (endTag != null)
      {
         AdjustFlagsAndWidth(endTag);
         this.endTag = endTag;
      }
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.startTag);
      writer.WriteValue(this.content);
      writer.WriteValue(this.endTag);
    }

    static XmlElementSyntax()
    {
       ObjectBinder.RegisterTypeReader(typeof(XmlElementSyntax), r => new XmlElementSyntax(r));
    }
  }

  internal sealed partial class XmlElementStartTagSyntax : CSharpSyntaxNode
  {
    internal readonly SyntaxToken lessThanToken;
    internal readonly XmlNameSyntax name;
    internal readonly GreenNode? attributes;
    internal readonly SyntaxToken greaterThanToken;

    internal XmlElementStartTagSyntax(SyntaxKind kind, SyntaxToken lessThanToken, XmlNameSyntax name, GreenNode? attributes, SyntaxToken greaterThanToken, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 4;
        this.AdjustFlagsAndWidth(lessThanToken);
        this.lessThanToken = lessThanToken;
        this.AdjustFlagsAndWidth(name);
        this.name = name;
        if (attributes != null)
        {
            this.AdjustFlagsAndWidth(attributes);
            this.attributes = attributes;
        }
        this.AdjustFlagsAndWidth(greaterThanToken);
        this.greaterThanToken = greaterThanToken;
    }


    internal XmlElementStartTagSyntax(SyntaxKind kind, SyntaxToken lessThanToken, XmlNameSyntax name, GreenNode? attributes, SyntaxToken greaterThanToken, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 4;
        this.AdjustFlagsAndWidth(lessThanToken);
        this.lessThanToken = lessThanToken;
        this.AdjustFlagsAndWidth(name);
        this.name = name;
        if (attributes != null)
        {
            this.AdjustFlagsAndWidth(attributes);
            this.attributes = attributes;
        }
        this.AdjustFlagsAndWidth(greaterThanToken);
        this.greaterThanToken = greaterThanToken;
    }


    internal XmlElementStartTagSyntax(SyntaxKind kind, SyntaxToken lessThanToken, XmlNameSyntax name, GreenNode? attributes, SyntaxToken greaterThanToken)
        : base(kind)
    {
        this.SlotCount = 4;
        this.AdjustFlagsAndWidth(lessThanToken);
        this.lessThanToken = lessThanToken;
        this.AdjustFlagsAndWidth(name);
        this.name = name;
        if (attributes != null)
        {
            this.AdjustFlagsAndWidth(attributes);
            this.attributes = attributes;
        }
        this.AdjustFlagsAndWidth(greaterThanToken);
        this.greaterThanToken = greaterThanToken;
    }

    public SyntaxToken LessThanToken => this.lessThanToken;
    public XmlNameSyntax Name => this.name;
    public Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<XmlAttributeSyntax> Attributes => new Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<XmlAttributeSyntax>(this.attributes);
    public SyntaxToken GreaterThanToken => this.greaterThanToken;

    internal override GreenNode? GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.lessThanToken;
            case 1: return this.name;
            case 2: return this.attributes;
            case 3: return this.greaterThanToken;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new CSharp.Syntax.XmlElementStartTagSyntax(this, parent, position);

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor) => visitor.VisitXmlElementStartTag(this);

    public override void Accept(CSharpSyntaxVisitor visitor) => visitor.VisitXmlElementStartTag(this);

    public XmlElementStartTagSyntax Update(SyntaxToken lessThanToken, XmlNameSyntax name, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<XmlAttributeSyntax> attributes, SyntaxToken greaterThanToken)
    {
        if (lessThanToken != this.LessThanToken || name != this.Name || attributes != this.Attributes || greaterThanToken != this.GreaterThanToken)
        {
            var newNode = SyntaxFactory.XmlElementStartTag(lessThanToken, name, attributes, greaterThanToken);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
        => new XmlElementStartTagSyntax(this.Kind, this.lessThanToken, this.name, this.attributes, this.greaterThanToken, diagnostics, GetAnnotations());

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
        => new XmlElementStartTagSyntax(this.Kind, this.lessThanToken, this.name, this.attributes, this.greaterThanToken, GetDiagnostics(), annotations);

    internal XmlElementStartTagSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 4;
      var lessThanToken = (SyntaxToken)reader.ReadValue();
      if (lessThanToken != null)
      {
         AdjustFlagsAndWidth(lessThanToken);
         this.lessThanToken = lessThanToken;
      }
      var name = (XmlNameSyntax)reader.ReadValue();
      if (name != null)
      {
         AdjustFlagsAndWidth(name);
         this.name = name;
      }
      var attributes = (GreenNode?)reader.ReadValue();
      if (attributes != null)
      {
         AdjustFlagsAndWidth(attributes);
         this.attributes = attributes;
      }
      var greaterThanToken = (SyntaxToken)reader.ReadValue();
      if (greaterThanToken != null)
      {
         AdjustFlagsAndWidth(greaterThanToken);
         this.greaterThanToken = greaterThanToken;
      }
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.lessThanToken);
      writer.WriteValue(this.name);
      writer.WriteValue(this.attributes);
      writer.WriteValue(this.greaterThanToken);
    }

    static XmlElementStartTagSyntax()
    {
       ObjectBinder.RegisterTypeReader(typeof(XmlElementStartTagSyntax), r => new XmlElementStartTagSyntax(r));
    }
  }

  internal sealed partial class XmlElementEndTagSyntax : CSharpSyntaxNode
  {
    internal readonly SyntaxToken lessThanSlashToken;
    internal readonly XmlNameSyntax name;
    internal readonly SyntaxToken greaterThanToken;

    internal XmlElementEndTagSyntax(SyntaxKind kind, SyntaxToken lessThanSlashToken, XmlNameSyntax name, SyntaxToken greaterThanToken, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 3;
        this.AdjustFlagsAndWidth(lessThanSlashToken);
        this.lessThanSlashToken = lessThanSlashToken;
        this.AdjustFlagsAndWidth(name);
        this.name = name;
        this.AdjustFlagsAndWidth(greaterThanToken);
        this.greaterThanToken = greaterThanToken;
    }


    internal XmlElementEndTagSyntax(SyntaxKind kind, SyntaxToken lessThanSlashToken, XmlNameSyntax name, SyntaxToken greaterThanToken, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 3;
        this.AdjustFlagsAndWidth(lessThanSlashToken);
        this.lessThanSlashToken = lessThanSlashToken;
        this.AdjustFlagsAndWidth(name);
        this.name = name;
        this.AdjustFlagsAndWidth(greaterThanToken);
        this.greaterThanToken = greaterThanToken;
    }


    internal XmlElementEndTagSyntax(SyntaxKind kind, SyntaxToken lessThanSlashToken, XmlNameSyntax name, SyntaxToken greaterThanToken)
        : base(kind)
    {
        this.SlotCount = 3;
        this.AdjustFlagsAndWidth(lessThanSlashToken);
        this.lessThanSlashToken = lessThanSlashToken;
        this.AdjustFlagsAndWidth(name);
        this.name = name;
        this.AdjustFlagsAndWidth(greaterThanToken);
        this.greaterThanToken = greaterThanToken;
    }

    public SyntaxToken LessThanSlashToken => this.lessThanSlashToken;
    public XmlNameSyntax Name => this.name;
    public SyntaxToken GreaterThanToken => this.greaterThanToken;

    internal override GreenNode? GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.lessThanSlashToken;
            case 1: return this.name;
            case 2: return this.greaterThanToken;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new CSharp.Syntax.XmlElementEndTagSyntax(this, parent, position);

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor) => visitor.VisitXmlElementEndTag(this);

    public override void Accept(CSharpSyntaxVisitor visitor) => visitor.VisitXmlElementEndTag(this);

    public XmlElementEndTagSyntax Update(SyntaxToken lessThanSlashToken, XmlNameSyntax name, SyntaxToken greaterThanToken)
    {
        if (lessThanSlashToken != this.LessThanSlashToken || name != this.Name || greaterThanToken != this.GreaterThanToken)
        {
            var newNode = SyntaxFactory.XmlElementEndTag(lessThanSlashToken, name, greaterThanToken);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
        => new XmlElementEndTagSyntax(this.Kind, this.lessThanSlashToken, this.name, this.greaterThanToken, diagnostics, GetAnnotations());

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
        => new XmlElementEndTagSyntax(this.Kind, this.lessThanSlashToken, this.name, this.greaterThanToken, GetDiagnostics(), annotations);

    internal XmlElementEndTagSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 3;
      var lessThanSlashToken = (SyntaxToken)reader.ReadValue();
      if (lessThanSlashToken != null)
      {
         AdjustFlagsAndWidth(lessThanSlashToken);
         this.lessThanSlashToken = lessThanSlashToken;
      }
      var name = (XmlNameSyntax)reader.ReadValue();
      if (name != null)
      {
         AdjustFlagsAndWidth(name);
         this.name = name;
      }
      var greaterThanToken = (SyntaxToken)reader.ReadValue();
      if (greaterThanToken != null)
      {
         AdjustFlagsAndWidth(greaterThanToken);
         this.greaterThanToken = greaterThanToken;
      }
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.lessThanSlashToken);
      writer.WriteValue(this.name);
      writer.WriteValue(this.greaterThanToken);
    }

    static XmlElementEndTagSyntax()
    {
       ObjectBinder.RegisterTypeReader(typeof(XmlElementEndTagSyntax), r => new XmlElementEndTagSyntax(r));
    }
  }

  internal sealed partial class XmlEmptyElementSyntax : XmlNodeSyntax
  {
    internal readonly SyntaxToken lessThanToken;
    internal readonly XmlNameSyntax name;
    internal readonly GreenNode? attributes;
    internal readonly SyntaxToken slashGreaterThanToken;

    internal XmlEmptyElementSyntax(SyntaxKind kind, SyntaxToken lessThanToken, XmlNameSyntax name, GreenNode? attributes, SyntaxToken slashGreaterThanToken, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 4;
        this.AdjustFlagsAndWidth(lessThanToken);
        this.lessThanToken = lessThanToken;
        this.AdjustFlagsAndWidth(name);
        this.name = name;
        if (attributes != null)
        {
            this.AdjustFlagsAndWidth(attributes);
            this.attributes = attributes;
        }
        this.AdjustFlagsAndWidth(slashGreaterThanToken);
        this.slashGreaterThanToken = slashGreaterThanToken;
    }


    internal XmlEmptyElementSyntax(SyntaxKind kind, SyntaxToken lessThanToken, XmlNameSyntax name, GreenNode? attributes, SyntaxToken slashGreaterThanToken, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 4;
        this.AdjustFlagsAndWidth(lessThanToken);
        this.lessThanToken = lessThanToken;
        this.AdjustFlagsAndWidth(name);
        this.name = name;
        if (attributes != null)
        {
            this.AdjustFlagsAndWidth(attributes);
            this.attributes = attributes;
        }
        this.AdjustFlagsAndWidth(slashGreaterThanToken);
        this.slashGreaterThanToken = slashGreaterThanToken;
    }


    internal XmlEmptyElementSyntax(SyntaxKind kind, SyntaxToken lessThanToken, XmlNameSyntax name, GreenNode? attributes, SyntaxToken slashGreaterThanToken)
        : base(kind)
    {
        this.SlotCount = 4;
        this.AdjustFlagsAndWidth(lessThanToken);
        this.lessThanToken = lessThanToken;
        this.AdjustFlagsAndWidth(name);
        this.name = name;
        if (attributes != null)
        {
            this.AdjustFlagsAndWidth(attributes);
            this.attributes = attributes;
        }
        this.AdjustFlagsAndWidth(slashGreaterThanToken);
        this.slashGreaterThanToken = slashGreaterThanToken;
    }

    public SyntaxToken LessThanToken => this.lessThanToken;
    public XmlNameSyntax Name => this.name;
    public Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<XmlAttributeSyntax> Attributes => new Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<XmlAttributeSyntax>(this.attributes);
    public SyntaxToken SlashGreaterThanToken => this.slashGreaterThanToken;

    internal override GreenNode? GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.lessThanToken;
            case 1: return this.name;
            case 2: return this.attributes;
            case 3: return this.slashGreaterThanToken;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new CSharp.Syntax.XmlEmptyElementSyntax(this, parent, position);

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor) => visitor.VisitXmlEmptyElement(this);

    public override void Accept(CSharpSyntaxVisitor visitor) => visitor.VisitXmlEmptyElement(this);

    public XmlEmptyElementSyntax Update(SyntaxToken lessThanToken, XmlNameSyntax name, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<XmlAttributeSyntax> attributes, SyntaxToken slashGreaterThanToken)
    {
        if (lessThanToken != this.LessThanToken || name != this.Name || attributes != this.Attributes || slashGreaterThanToken != this.SlashGreaterThanToken)
        {
            var newNode = SyntaxFactory.XmlEmptyElement(lessThanToken, name, attributes, slashGreaterThanToken);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
        => new XmlEmptyElementSyntax(this.Kind, this.lessThanToken, this.name, this.attributes, this.slashGreaterThanToken, diagnostics, GetAnnotations());

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
        => new XmlEmptyElementSyntax(this.Kind, this.lessThanToken, this.name, this.attributes, this.slashGreaterThanToken, GetDiagnostics(), annotations);

    internal XmlEmptyElementSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 4;
      var lessThanToken = (SyntaxToken)reader.ReadValue();
      if (lessThanToken != null)
      {
         AdjustFlagsAndWidth(lessThanToken);
         this.lessThanToken = lessThanToken;
      }
      var name = (XmlNameSyntax)reader.ReadValue();
      if (name != null)
      {
         AdjustFlagsAndWidth(name);
         this.name = name;
      }
      var attributes = (GreenNode?)reader.ReadValue();
      if (attributes != null)
      {
         AdjustFlagsAndWidth(attributes);
         this.attributes = attributes;
      }
      var slashGreaterThanToken = (SyntaxToken)reader.ReadValue();
      if (slashGreaterThanToken != null)
      {
         AdjustFlagsAndWidth(slashGreaterThanToken);
         this.slashGreaterThanToken = slashGreaterThanToken;
      }
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.lessThanToken);
      writer.WriteValue(this.name);
      writer.WriteValue(this.attributes);
      writer.WriteValue(this.slashGreaterThanToken);
    }

    static XmlEmptyElementSyntax()
    {
       ObjectBinder.RegisterTypeReader(typeof(XmlEmptyElementSyntax), r => new XmlEmptyElementSyntax(r));
    }
  }

  internal sealed partial class XmlNameSyntax : CSharpSyntaxNode
  {
    internal readonly XmlPrefixSyntax? prefix;
    internal readonly SyntaxToken localName;

    internal XmlNameSyntax(SyntaxKind kind, XmlPrefixSyntax? prefix, SyntaxToken localName, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 2;
        if (prefix != null)
        {
            this.AdjustFlagsAndWidth(prefix);
            this.prefix = prefix;
        }
        this.AdjustFlagsAndWidth(localName);
        this.localName = localName;
    }


    internal XmlNameSyntax(SyntaxKind kind, XmlPrefixSyntax? prefix, SyntaxToken localName, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 2;
        if (prefix != null)
        {
            this.AdjustFlagsAndWidth(prefix);
            this.prefix = prefix;
        }
        this.AdjustFlagsAndWidth(localName);
        this.localName = localName;
    }


    internal XmlNameSyntax(SyntaxKind kind, XmlPrefixSyntax? prefix, SyntaxToken localName)
        : base(kind)
    {
        this.SlotCount = 2;
        if (prefix != null)
        {
            this.AdjustFlagsAndWidth(prefix);
            this.prefix = prefix;
        }
        this.AdjustFlagsAndWidth(localName);
        this.localName = localName;
    }

    public XmlPrefixSyntax? Prefix => this.prefix;
    public SyntaxToken LocalName => this.localName;

    internal override GreenNode? GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.prefix;
            case 1: return this.localName;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new CSharp.Syntax.XmlNameSyntax(this, parent, position);

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor) => visitor.VisitXmlName(this);

    public override void Accept(CSharpSyntaxVisitor visitor) => visitor.VisitXmlName(this);

    public XmlNameSyntax Update(XmlPrefixSyntax prefix, SyntaxToken localName)
    {
        if (prefix != this.Prefix || localName != this.LocalName)
        {
            var newNode = SyntaxFactory.XmlName(prefix, localName);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
        => new XmlNameSyntax(this.Kind, this.prefix, this.localName, diagnostics, GetAnnotations());

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
        => new XmlNameSyntax(this.Kind, this.prefix, this.localName, GetDiagnostics(), annotations);

    internal XmlNameSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 2;
      var prefix = (XmlPrefixSyntax?)reader.ReadValue();
      if (prefix != null)
      {
         AdjustFlagsAndWidth(prefix);
         this.prefix = prefix;
      }
      var localName = (SyntaxToken)reader.ReadValue();
      if (localName != null)
      {
         AdjustFlagsAndWidth(localName);
         this.localName = localName;
      }
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.prefix);
      writer.WriteValue(this.localName);
    }

    static XmlNameSyntax()
    {
       ObjectBinder.RegisterTypeReader(typeof(XmlNameSyntax), r => new XmlNameSyntax(r));
    }
  }

  internal sealed partial class XmlPrefixSyntax : CSharpSyntaxNode
  {
    internal readonly SyntaxToken prefix;
    internal readonly SyntaxToken colonToken;

    internal XmlPrefixSyntax(SyntaxKind kind, SyntaxToken prefix, SyntaxToken colonToken, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 2;
        this.AdjustFlagsAndWidth(prefix);
        this.prefix = prefix;
        this.AdjustFlagsAndWidth(colonToken);
        this.colonToken = colonToken;
    }


    internal XmlPrefixSyntax(SyntaxKind kind, SyntaxToken prefix, SyntaxToken colonToken, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 2;
        this.AdjustFlagsAndWidth(prefix);
        this.prefix = prefix;
        this.AdjustFlagsAndWidth(colonToken);
        this.colonToken = colonToken;
    }


    internal XmlPrefixSyntax(SyntaxKind kind, SyntaxToken prefix, SyntaxToken colonToken)
        : base(kind)
    {
        this.SlotCount = 2;
        this.AdjustFlagsAndWidth(prefix);
        this.prefix = prefix;
        this.AdjustFlagsAndWidth(colonToken);
        this.colonToken = colonToken;
    }

    public SyntaxToken Prefix => this.prefix;
    public SyntaxToken ColonToken => this.colonToken;

    internal override GreenNode? GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.prefix;
            case 1: return this.colonToken;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new CSharp.Syntax.XmlPrefixSyntax(this, parent, position);

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor) => visitor.VisitXmlPrefix(this);

    public override void Accept(CSharpSyntaxVisitor visitor) => visitor.VisitXmlPrefix(this);

    public XmlPrefixSyntax Update(SyntaxToken prefix, SyntaxToken colonToken)
    {
        if (prefix != this.Prefix || colonToken != this.ColonToken)
        {
            var newNode = SyntaxFactory.XmlPrefix(prefix, colonToken);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
        => new XmlPrefixSyntax(this.Kind, this.prefix, this.colonToken, diagnostics, GetAnnotations());

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
        => new XmlPrefixSyntax(this.Kind, this.prefix, this.colonToken, GetDiagnostics(), annotations);

    internal XmlPrefixSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 2;
      var prefix = (SyntaxToken)reader.ReadValue();
      if (prefix != null)
      {
         AdjustFlagsAndWidth(prefix);
         this.prefix = prefix;
      }
      var colonToken = (SyntaxToken)reader.ReadValue();
      if (colonToken != null)
      {
         AdjustFlagsAndWidth(colonToken);
         this.colonToken = colonToken;
      }
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.prefix);
      writer.WriteValue(this.colonToken);
    }

    static XmlPrefixSyntax()
    {
       ObjectBinder.RegisterTypeReader(typeof(XmlPrefixSyntax), r => new XmlPrefixSyntax(r));
    }
  }

  internal abstract partial class XmlAttributeSyntax : CSharpSyntaxNode
  {
    internal XmlAttributeSyntax(SyntaxKind kind, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
      : base(kind, diagnostics, annotations)
    {
    }
    internal XmlAttributeSyntax(SyntaxKind kind)
      : base(kind)
    {
    }

    protected XmlAttributeSyntax(ObjectReader reader)
       : base(reader)
    {
    }

    public abstract XmlNameSyntax Name { get; }

    public abstract SyntaxToken EqualsToken { get; }

    public abstract SyntaxToken StartQuoteToken { get; }

    public abstract SyntaxToken EndQuoteToken { get; }
  }

  internal sealed partial class XmlTextAttributeSyntax : XmlAttributeSyntax
  {
    internal readonly XmlNameSyntax name;
    internal readonly SyntaxToken equalsToken;
    internal readonly SyntaxToken startQuoteToken;
    internal readonly GreenNode? textTokens;
    internal readonly SyntaxToken endQuoteToken;

    internal XmlTextAttributeSyntax(SyntaxKind kind, XmlNameSyntax name, SyntaxToken equalsToken, SyntaxToken startQuoteToken, GreenNode? textTokens, SyntaxToken endQuoteToken, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 5;
        this.AdjustFlagsAndWidth(name);
        this.name = name;
        this.AdjustFlagsAndWidth(equalsToken);
        this.equalsToken = equalsToken;
        this.AdjustFlagsAndWidth(startQuoteToken);
        this.startQuoteToken = startQuoteToken;
        if (textTokens != null)
        {
            this.AdjustFlagsAndWidth(textTokens);
            this.textTokens = textTokens;
        }
        this.AdjustFlagsAndWidth(endQuoteToken);
        this.endQuoteToken = endQuoteToken;
    }


    internal XmlTextAttributeSyntax(SyntaxKind kind, XmlNameSyntax name, SyntaxToken equalsToken, SyntaxToken startQuoteToken, GreenNode? textTokens, SyntaxToken endQuoteToken, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 5;
        this.AdjustFlagsAndWidth(name);
        this.name = name;
        this.AdjustFlagsAndWidth(equalsToken);
        this.equalsToken = equalsToken;
        this.AdjustFlagsAndWidth(startQuoteToken);
        this.startQuoteToken = startQuoteToken;
        if (textTokens != null)
        {
            this.AdjustFlagsAndWidth(textTokens);
            this.textTokens = textTokens;
        }
        this.AdjustFlagsAndWidth(endQuoteToken);
        this.endQuoteToken = endQuoteToken;
    }


    internal XmlTextAttributeSyntax(SyntaxKind kind, XmlNameSyntax name, SyntaxToken equalsToken, SyntaxToken startQuoteToken, GreenNode? textTokens, SyntaxToken endQuoteToken)
        : base(kind)
    {
        this.SlotCount = 5;
        this.AdjustFlagsAndWidth(name);
        this.name = name;
        this.AdjustFlagsAndWidth(equalsToken);
        this.equalsToken = equalsToken;
        this.AdjustFlagsAndWidth(startQuoteToken);
        this.startQuoteToken = startQuoteToken;
        if (textTokens != null)
        {
            this.AdjustFlagsAndWidth(textTokens);
            this.textTokens = textTokens;
        }
        this.AdjustFlagsAndWidth(endQuoteToken);
        this.endQuoteToken = endQuoteToken;
    }

    public override XmlNameSyntax Name => this.name;
    public override SyntaxToken EqualsToken => this.equalsToken;
    public override SyntaxToken StartQuoteToken => this.startQuoteToken;
    public Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SyntaxToken> TextTokens => new Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SyntaxToken>(this.textTokens);
    public override SyntaxToken EndQuoteToken => this.endQuoteToken;

    internal override GreenNode? GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.name;
            case 1: return this.equalsToken;
            case 2: return this.startQuoteToken;
            case 3: return this.textTokens;
            case 4: return this.endQuoteToken;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new CSharp.Syntax.XmlTextAttributeSyntax(this, parent, position);

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor) => visitor.VisitXmlTextAttribute(this);

    public override void Accept(CSharpSyntaxVisitor visitor) => visitor.VisitXmlTextAttribute(this);

    public XmlTextAttributeSyntax Update(XmlNameSyntax name, SyntaxToken equalsToken, SyntaxToken startQuoteToken, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SyntaxToken> textTokens, SyntaxToken endQuoteToken)
    {
        if (name != this.Name || equalsToken != this.EqualsToken || startQuoteToken != this.StartQuoteToken || textTokens != this.TextTokens || endQuoteToken != this.EndQuoteToken)
        {
            var newNode = SyntaxFactory.XmlTextAttribute(name, equalsToken, startQuoteToken, textTokens, endQuoteToken);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
        => new XmlTextAttributeSyntax(this.Kind, this.name, this.equalsToken, this.startQuoteToken, this.textTokens, this.endQuoteToken, diagnostics, GetAnnotations());

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
        => new XmlTextAttributeSyntax(this.Kind, this.name, this.equalsToken, this.startQuoteToken, this.textTokens, this.endQuoteToken, GetDiagnostics(), annotations);

    internal XmlTextAttributeSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 5;
      var name = (XmlNameSyntax)reader.ReadValue();
      if (name != null)
      {
         AdjustFlagsAndWidth(name);
         this.name = name;
      }
      var equalsToken = (SyntaxToken)reader.ReadValue();
      if (equalsToken != null)
      {
         AdjustFlagsAndWidth(equalsToken);
         this.equalsToken = equalsToken;
      }
      var startQuoteToken = (SyntaxToken)reader.ReadValue();
      if (startQuoteToken != null)
      {
         AdjustFlagsAndWidth(startQuoteToken);
         this.startQuoteToken = startQuoteToken;
      }
      var textTokens = (GreenNode?)reader.ReadValue();
      if (textTokens != null)
      {
         AdjustFlagsAndWidth(textTokens);
         this.textTokens = textTokens;
      }
      var endQuoteToken = (SyntaxToken)reader.ReadValue();
      if (endQuoteToken != null)
      {
         AdjustFlagsAndWidth(endQuoteToken);
         this.endQuoteToken = endQuoteToken;
      }
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.name);
      writer.WriteValue(this.equalsToken);
      writer.WriteValue(this.startQuoteToken);
      writer.WriteValue(this.textTokens);
      writer.WriteValue(this.endQuoteToken);
    }

    static XmlTextAttributeSyntax()
    {
       ObjectBinder.RegisterTypeReader(typeof(XmlTextAttributeSyntax), r => new XmlTextAttributeSyntax(r));
    }
  }

  internal sealed partial class XmlCrefAttributeSyntax : XmlAttributeSyntax
  {
    internal readonly XmlNameSyntax name;
    internal readonly SyntaxToken equalsToken;
    internal readonly SyntaxToken startQuoteToken;
    internal readonly CrefSyntax cref;
    internal readonly SyntaxToken endQuoteToken;

    internal XmlCrefAttributeSyntax(SyntaxKind kind, XmlNameSyntax name, SyntaxToken equalsToken, SyntaxToken startQuoteToken, CrefSyntax cref, SyntaxToken endQuoteToken, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 5;
        this.AdjustFlagsAndWidth(name);
        this.name = name;
        this.AdjustFlagsAndWidth(equalsToken);
        this.equalsToken = equalsToken;
        this.AdjustFlagsAndWidth(startQuoteToken);
        this.startQuoteToken = startQuoteToken;
        this.AdjustFlagsAndWidth(cref);
        this.cref = cref;
        this.AdjustFlagsAndWidth(endQuoteToken);
        this.endQuoteToken = endQuoteToken;
    }


    internal XmlCrefAttributeSyntax(SyntaxKind kind, XmlNameSyntax name, SyntaxToken equalsToken, SyntaxToken startQuoteToken, CrefSyntax cref, SyntaxToken endQuoteToken, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 5;
        this.AdjustFlagsAndWidth(name);
        this.name = name;
        this.AdjustFlagsAndWidth(equalsToken);
        this.equalsToken = equalsToken;
        this.AdjustFlagsAndWidth(startQuoteToken);
        this.startQuoteToken = startQuoteToken;
        this.AdjustFlagsAndWidth(cref);
        this.cref = cref;
        this.AdjustFlagsAndWidth(endQuoteToken);
        this.endQuoteToken = endQuoteToken;
    }


    internal XmlCrefAttributeSyntax(SyntaxKind kind, XmlNameSyntax name, SyntaxToken equalsToken, SyntaxToken startQuoteToken, CrefSyntax cref, SyntaxToken endQuoteToken)
        : base(kind)
    {
        this.SlotCount = 5;
        this.AdjustFlagsAndWidth(name);
        this.name = name;
        this.AdjustFlagsAndWidth(equalsToken);
        this.equalsToken = equalsToken;
        this.AdjustFlagsAndWidth(startQuoteToken);
        this.startQuoteToken = startQuoteToken;
        this.AdjustFlagsAndWidth(cref);
        this.cref = cref;
        this.AdjustFlagsAndWidth(endQuoteToken);
        this.endQuoteToken = endQuoteToken;
    }

    public override XmlNameSyntax Name => this.name;
    public override SyntaxToken EqualsToken => this.equalsToken;
    public override SyntaxToken StartQuoteToken => this.startQuoteToken;
    public CrefSyntax Cref => this.cref;
    public override SyntaxToken EndQuoteToken => this.endQuoteToken;

    internal override GreenNode? GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.name;
            case 1: return this.equalsToken;
            case 2: return this.startQuoteToken;
            case 3: return this.cref;
            case 4: return this.endQuoteToken;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new CSharp.Syntax.XmlCrefAttributeSyntax(this, parent, position);

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor) => visitor.VisitXmlCrefAttribute(this);

    public override void Accept(CSharpSyntaxVisitor visitor) => visitor.VisitXmlCrefAttribute(this);

    public XmlCrefAttributeSyntax Update(XmlNameSyntax name, SyntaxToken equalsToken, SyntaxToken startQuoteToken, CrefSyntax cref, SyntaxToken endQuoteToken)
    {
        if (name != this.Name || equalsToken != this.EqualsToken || startQuoteToken != this.StartQuoteToken || cref != this.Cref || endQuoteToken != this.EndQuoteToken)
        {
            var newNode = SyntaxFactory.XmlCrefAttribute(name, equalsToken, startQuoteToken, cref, endQuoteToken);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
        => new XmlCrefAttributeSyntax(this.Kind, this.name, this.equalsToken, this.startQuoteToken, this.cref, this.endQuoteToken, diagnostics, GetAnnotations());

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
        => new XmlCrefAttributeSyntax(this.Kind, this.name, this.equalsToken, this.startQuoteToken, this.cref, this.endQuoteToken, GetDiagnostics(), annotations);

    internal XmlCrefAttributeSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 5;
      var name = (XmlNameSyntax)reader.ReadValue();
      if (name != null)
      {
         AdjustFlagsAndWidth(name);
         this.name = name;
      }
      var equalsToken = (SyntaxToken)reader.ReadValue();
      if (equalsToken != null)
      {
         AdjustFlagsAndWidth(equalsToken);
         this.equalsToken = equalsToken;
      }
      var startQuoteToken = (SyntaxToken)reader.ReadValue();
      if (startQuoteToken != null)
      {
         AdjustFlagsAndWidth(startQuoteToken);
         this.startQuoteToken = startQuoteToken;
      }
      var cref = (CrefSyntax)reader.ReadValue();
      if (cref != null)
      {
         AdjustFlagsAndWidth(cref);
         this.cref = cref;
      }
      var endQuoteToken = (SyntaxToken)reader.ReadValue();
      if (endQuoteToken != null)
      {
         AdjustFlagsAndWidth(endQuoteToken);
         this.endQuoteToken = endQuoteToken;
      }
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.name);
      writer.WriteValue(this.equalsToken);
      writer.WriteValue(this.startQuoteToken);
      writer.WriteValue(this.cref);
      writer.WriteValue(this.endQuoteToken);
    }

    static XmlCrefAttributeSyntax()
    {
       ObjectBinder.RegisterTypeReader(typeof(XmlCrefAttributeSyntax), r => new XmlCrefAttributeSyntax(r));
    }
  }

  internal sealed partial class XmlNameAttributeSyntax : XmlAttributeSyntax
  {
    internal readonly XmlNameSyntax name;
    internal readonly SyntaxToken equalsToken;
    internal readonly SyntaxToken startQuoteToken;
    internal readonly IdentifierNameSyntax identifier;
    internal readonly SyntaxToken endQuoteToken;

    internal XmlNameAttributeSyntax(SyntaxKind kind, XmlNameSyntax name, SyntaxToken equalsToken, SyntaxToken startQuoteToken, IdentifierNameSyntax identifier, SyntaxToken endQuoteToken, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 5;
        this.AdjustFlagsAndWidth(name);
        this.name = name;
        this.AdjustFlagsAndWidth(equalsToken);
        this.equalsToken = equalsToken;
        this.AdjustFlagsAndWidth(startQuoteToken);
        this.startQuoteToken = startQuoteToken;
        this.AdjustFlagsAndWidth(identifier);
        this.identifier = identifier;
        this.AdjustFlagsAndWidth(endQuoteToken);
        this.endQuoteToken = endQuoteToken;
    }


    internal XmlNameAttributeSyntax(SyntaxKind kind, XmlNameSyntax name, SyntaxToken equalsToken, SyntaxToken startQuoteToken, IdentifierNameSyntax identifier, SyntaxToken endQuoteToken, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 5;
        this.AdjustFlagsAndWidth(name);
        this.name = name;
        this.AdjustFlagsAndWidth(equalsToken);
        this.equalsToken = equalsToken;
        this.AdjustFlagsAndWidth(startQuoteToken);
        this.startQuoteToken = startQuoteToken;
        this.AdjustFlagsAndWidth(identifier);
        this.identifier = identifier;
        this.AdjustFlagsAndWidth(endQuoteToken);
        this.endQuoteToken = endQuoteToken;
    }


    internal XmlNameAttributeSyntax(SyntaxKind kind, XmlNameSyntax name, SyntaxToken equalsToken, SyntaxToken startQuoteToken, IdentifierNameSyntax identifier, SyntaxToken endQuoteToken)
        : base(kind)
    {
        this.SlotCount = 5;
        this.AdjustFlagsAndWidth(name);
        this.name = name;
        this.AdjustFlagsAndWidth(equalsToken);
        this.equalsToken = equalsToken;
        this.AdjustFlagsAndWidth(startQuoteToken);
        this.startQuoteToken = startQuoteToken;
        this.AdjustFlagsAndWidth(identifier);
        this.identifier = identifier;
        this.AdjustFlagsAndWidth(endQuoteToken);
        this.endQuoteToken = endQuoteToken;
    }

    public override XmlNameSyntax Name => this.name;
    public override SyntaxToken EqualsToken => this.equalsToken;
    public override SyntaxToken StartQuoteToken => this.startQuoteToken;
    public IdentifierNameSyntax Identifier => this.identifier;
    public override SyntaxToken EndQuoteToken => this.endQuoteToken;

    internal override GreenNode? GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.name;
            case 1: return this.equalsToken;
            case 2: return this.startQuoteToken;
            case 3: return this.identifier;
            case 4: return this.endQuoteToken;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new CSharp.Syntax.XmlNameAttributeSyntax(this, parent, position);

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor) => visitor.VisitXmlNameAttribute(this);

    public override void Accept(CSharpSyntaxVisitor visitor) => visitor.VisitXmlNameAttribute(this);

    public XmlNameAttributeSyntax Update(XmlNameSyntax name, SyntaxToken equalsToken, SyntaxToken startQuoteToken, IdentifierNameSyntax identifier, SyntaxToken endQuoteToken)
    {
        if (name != this.Name || equalsToken != this.EqualsToken || startQuoteToken != this.StartQuoteToken || identifier != this.Identifier || endQuoteToken != this.EndQuoteToken)
        {
            var newNode = SyntaxFactory.XmlNameAttribute(name, equalsToken, startQuoteToken, identifier, endQuoteToken);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
        => new XmlNameAttributeSyntax(this.Kind, this.name, this.equalsToken, this.startQuoteToken, this.identifier, this.endQuoteToken, diagnostics, GetAnnotations());

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
        => new XmlNameAttributeSyntax(this.Kind, this.name, this.equalsToken, this.startQuoteToken, this.identifier, this.endQuoteToken, GetDiagnostics(), annotations);

    internal XmlNameAttributeSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 5;
      var name = (XmlNameSyntax)reader.ReadValue();
      if (name != null)
      {
         AdjustFlagsAndWidth(name);
         this.name = name;
      }
      var equalsToken = (SyntaxToken)reader.ReadValue();
      if (equalsToken != null)
      {
         AdjustFlagsAndWidth(equalsToken);
         this.equalsToken = equalsToken;
      }
      var startQuoteToken = (SyntaxToken)reader.ReadValue();
      if (startQuoteToken != null)
      {
         AdjustFlagsAndWidth(startQuoteToken);
         this.startQuoteToken = startQuoteToken;
      }
      var identifier = (IdentifierNameSyntax)reader.ReadValue();
      if (identifier != null)
      {
         AdjustFlagsAndWidth(identifier);
         this.identifier = identifier;
      }
      var endQuoteToken = (SyntaxToken)reader.ReadValue();
      if (endQuoteToken != null)
      {
         AdjustFlagsAndWidth(endQuoteToken);
         this.endQuoteToken = endQuoteToken;
      }
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.name);
      writer.WriteValue(this.equalsToken);
      writer.WriteValue(this.startQuoteToken);
      writer.WriteValue(this.identifier);
      writer.WriteValue(this.endQuoteToken);
    }

    static XmlNameAttributeSyntax()
    {
       ObjectBinder.RegisterTypeReader(typeof(XmlNameAttributeSyntax), r => new XmlNameAttributeSyntax(r));
    }
  }

  internal sealed partial class XmlTextSyntax : XmlNodeSyntax
  {
    internal readonly GreenNode? textTokens;

    internal XmlTextSyntax(SyntaxKind kind, GreenNode? textTokens, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 1;
        if (textTokens != null)
        {
            this.AdjustFlagsAndWidth(textTokens);
            this.textTokens = textTokens;
        }
    }


    internal XmlTextSyntax(SyntaxKind kind, GreenNode? textTokens, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 1;
        if (textTokens != null)
        {
            this.AdjustFlagsAndWidth(textTokens);
            this.textTokens = textTokens;
        }
    }


    internal XmlTextSyntax(SyntaxKind kind, GreenNode? textTokens)
        : base(kind)
    {
        this.SlotCount = 1;
        if (textTokens != null)
        {
            this.AdjustFlagsAndWidth(textTokens);
            this.textTokens = textTokens;
        }
    }

    public Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SyntaxToken> TextTokens => new Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SyntaxToken>(this.textTokens);

    internal override GreenNode? GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.textTokens;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new CSharp.Syntax.XmlTextSyntax(this, parent, position);

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor) => visitor.VisitXmlText(this);

    public override void Accept(CSharpSyntaxVisitor visitor) => visitor.VisitXmlText(this);

    public XmlTextSyntax Update(Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SyntaxToken> textTokens)
    {
        if (textTokens != this.TextTokens)
        {
            var newNode = SyntaxFactory.XmlText(textTokens);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
        => new XmlTextSyntax(this.Kind, this.textTokens, diagnostics, GetAnnotations());

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
        => new XmlTextSyntax(this.Kind, this.textTokens, GetDiagnostics(), annotations);

    internal XmlTextSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 1;
      var textTokens = (GreenNode?)reader.ReadValue();
      if (textTokens != null)
      {
         AdjustFlagsAndWidth(textTokens);
         this.textTokens = textTokens;
      }
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.textTokens);
    }

    static XmlTextSyntax()
    {
       ObjectBinder.RegisterTypeReader(typeof(XmlTextSyntax), r => new XmlTextSyntax(r));
    }
  }

  internal sealed partial class XmlCDataSectionSyntax : XmlNodeSyntax
  {
    internal readonly SyntaxToken startCDataToken;
    internal readonly GreenNode? textTokens;
    internal readonly SyntaxToken endCDataToken;

    internal XmlCDataSectionSyntax(SyntaxKind kind, SyntaxToken startCDataToken, GreenNode? textTokens, SyntaxToken endCDataToken, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 3;
        this.AdjustFlagsAndWidth(startCDataToken);
        this.startCDataToken = startCDataToken;
        if (textTokens != null)
        {
            this.AdjustFlagsAndWidth(textTokens);
            this.textTokens = textTokens;
        }
        this.AdjustFlagsAndWidth(endCDataToken);
        this.endCDataToken = endCDataToken;
    }


    internal XmlCDataSectionSyntax(SyntaxKind kind, SyntaxToken startCDataToken, GreenNode? textTokens, SyntaxToken endCDataToken, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 3;
        this.AdjustFlagsAndWidth(startCDataToken);
        this.startCDataToken = startCDataToken;
        if (textTokens != null)
        {
            this.AdjustFlagsAndWidth(textTokens);
            this.textTokens = textTokens;
        }
        this.AdjustFlagsAndWidth(endCDataToken);
        this.endCDataToken = endCDataToken;
    }


    internal XmlCDataSectionSyntax(SyntaxKind kind, SyntaxToken startCDataToken, GreenNode? textTokens, SyntaxToken endCDataToken)
        : base(kind)
    {
        this.SlotCount = 3;
        this.AdjustFlagsAndWidth(startCDataToken);
        this.startCDataToken = startCDataToken;
        if (textTokens != null)
        {
            this.AdjustFlagsAndWidth(textTokens);
            this.textTokens = textTokens;
        }
        this.AdjustFlagsAndWidth(endCDataToken);
        this.endCDataToken = endCDataToken;
    }

    public SyntaxToken StartCDataToken => this.startCDataToken;
    public Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SyntaxToken> TextTokens => new Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SyntaxToken>(this.textTokens);
    public SyntaxToken EndCDataToken => this.endCDataToken;

    internal override GreenNode? GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.startCDataToken;
            case 1: return this.textTokens;
            case 2: return this.endCDataToken;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new CSharp.Syntax.XmlCDataSectionSyntax(this, parent, position);

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor) => visitor.VisitXmlCDataSection(this);

    public override void Accept(CSharpSyntaxVisitor visitor) => visitor.VisitXmlCDataSection(this);

    public XmlCDataSectionSyntax Update(SyntaxToken startCDataToken, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SyntaxToken> textTokens, SyntaxToken endCDataToken)
    {
        if (startCDataToken != this.StartCDataToken || textTokens != this.TextTokens || endCDataToken != this.EndCDataToken)
        {
            var newNode = SyntaxFactory.XmlCDataSection(startCDataToken, textTokens, endCDataToken);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
        => new XmlCDataSectionSyntax(this.Kind, this.startCDataToken, this.textTokens, this.endCDataToken, diagnostics, GetAnnotations());

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
        => new XmlCDataSectionSyntax(this.Kind, this.startCDataToken, this.textTokens, this.endCDataToken, GetDiagnostics(), annotations);

    internal XmlCDataSectionSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 3;
      var startCDataToken = (SyntaxToken)reader.ReadValue();
      if (startCDataToken != null)
      {
         AdjustFlagsAndWidth(startCDataToken);
         this.startCDataToken = startCDataToken;
      }
      var textTokens = (GreenNode?)reader.ReadValue();
      if (textTokens != null)
      {
         AdjustFlagsAndWidth(textTokens);
         this.textTokens = textTokens;
      }
      var endCDataToken = (SyntaxToken)reader.ReadValue();
      if (endCDataToken != null)
      {
         AdjustFlagsAndWidth(endCDataToken);
         this.endCDataToken = endCDataToken;
      }
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.startCDataToken);
      writer.WriteValue(this.textTokens);
      writer.WriteValue(this.endCDataToken);
    }

    static XmlCDataSectionSyntax()
    {
       ObjectBinder.RegisterTypeReader(typeof(XmlCDataSectionSyntax), r => new XmlCDataSectionSyntax(r));
    }
  }

  internal sealed partial class XmlProcessingInstructionSyntax : XmlNodeSyntax
  {
    internal readonly SyntaxToken startProcessingInstructionToken;
    internal readonly XmlNameSyntax name;
    internal readonly GreenNode? textTokens;
    internal readonly SyntaxToken endProcessingInstructionToken;

    internal XmlProcessingInstructionSyntax(SyntaxKind kind, SyntaxToken startProcessingInstructionToken, XmlNameSyntax name, GreenNode? textTokens, SyntaxToken endProcessingInstructionToken, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 4;
        this.AdjustFlagsAndWidth(startProcessingInstructionToken);
        this.startProcessingInstructionToken = startProcessingInstructionToken;
        this.AdjustFlagsAndWidth(name);
        this.name = name;
        if (textTokens != null)
        {
            this.AdjustFlagsAndWidth(textTokens);
            this.textTokens = textTokens;
        }
        this.AdjustFlagsAndWidth(endProcessingInstructionToken);
        this.endProcessingInstructionToken = endProcessingInstructionToken;
    }


    internal XmlProcessingInstructionSyntax(SyntaxKind kind, SyntaxToken startProcessingInstructionToken, XmlNameSyntax name, GreenNode? textTokens, SyntaxToken endProcessingInstructionToken, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 4;
        this.AdjustFlagsAndWidth(startProcessingInstructionToken);
        this.startProcessingInstructionToken = startProcessingInstructionToken;
        this.AdjustFlagsAndWidth(name);
        this.name = name;
        if (textTokens != null)
        {
            this.AdjustFlagsAndWidth(textTokens);
            this.textTokens = textTokens;
        }
        this.AdjustFlagsAndWidth(endProcessingInstructionToken);
        this.endProcessingInstructionToken = endProcessingInstructionToken;
    }


    internal XmlProcessingInstructionSyntax(SyntaxKind kind, SyntaxToken startProcessingInstructionToken, XmlNameSyntax name, GreenNode? textTokens, SyntaxToken endProcessingInstructionToken)
        : base(kind)
    {
        this.SlotCount = 4;
        this.AdjustFlagsAndWidth(startProcessingInstructionToken);
        this.startProcessingInstructionToken = startProcessingInstructionToken;
        this.AdjustFlagsAndWidth(name);
        this.name = name;
        if (textTokens != null)
        {
            this.AdjustFlagsAndWidth(textTokens);
            this.textTokens = textTokens;
        }
        this.AdjustFlagsAndWidth(endProcessingInstructionToken);
        this.endProcessingInstructionToken = endProcessingInstructionToken;
    }

    public SyntaxToken StartProcessingInstructionToken => this.startProcessingInstructionToken;
    public XmlNameSyntax Name => this.name;
    public Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SyntaxToken> TextTokens => new Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SyntaxToken>(this.textTokens);
    public SyntaxToken EndProcessingInstructionToken => this.endProcessingInstructionToken;

    internal override GreenNode? GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.startProcessingInstructionToken;
            case 1: return this.name;
            case 2: return this.textTokens;
            case 3: return this.endProcessingInstructionToken;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new CSharp.Syntax.XmlProcessingInstructionSyntax(this, parent, position);

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor) => visitor.VisitXmlProcessingInstruction(this);

    public override void Accept(CSharpSyntaxVisitor visitor) => visitor.VisitXmlProcessingInstruction(this);

    public XmlProcessingInstructionSyntax Update(SyntaxToken startProcessingInstructionToken, XmlNameSyntax name, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SyntaxToken> textTokens, SyntaxToken endProcessingInstructionToken)
    {
        if (startProcessingInstructionToken != this.StartProcessingInstructionToken || name != this.Name || textTokens != this.TextTokens || endProcessingInstructionToken != this.EndProcessingInstructionToken)
        {
            var newNode = SyntaxFactory.XmlProcessingInstruction(startProcessingInstructionToken, name, textTokens, endProcessingInstructionToken);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
        => new XmlProcessingInstructionSyntax(this.Kind, this.startProcessingInstructionToken, this.name, this.textTokens, this.endProcessingInstructionToken, diagnostics, GetAnnotations());

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
        => new XmlProcessingInstructionSyntax(this.Kind, this.startProcessingInstructionToken, this.name, this.textTokens, this.endProcessingInstructionToken, GetDiagnostics(), annotations);

    internal XmlProcessingInstructionSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 4;
      var startProcessingInstructionToken = (SyntaxToken)reader.ReadValue();
      if (startProcessingInstructionToken != null)
      {
         AdjustFlagsAndWidth(startProcessingInstructionToken);
         this.startProcessingInstructionToken = startProcessingInstructionToken;
      }
      var name = (XmlNameSyntax)reader.ReadValue();
      if (name != null)
      {
         AdjustFlagsAndWidth(name);
         this.name = name;
      }
      var textTokens = (GreenNode?)reader.ReadValue();
      if (textTokens != null)
      {
         AdjustFlagsAndWidth(textTokens);
         this.textTokens = textTokens;
      }
      var endProcessingInstructionToken = (SyntaxToken)reader.ReadValue();
      if (endProcessingInstructionToken != null)
      {
         AdjustFlagsAndWidth(endProcessingInstructionToken);
         this.endProcessingInstructionToken = endProcessingInstructionToken;
      }
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.startProcessingInstructionToken);
      writer.WriteValue(this.name);
      writer.WriteValue(this.textTokens);
      writer.WriteValue(this.endProcessingInstructionToken);
    }

    static XmlProcessingInstructionSyntax()
    {
       ObjectBinder.RegisterTypeReader(typeof(XmlProcessingInstructionSyntax), r => new XmlProcessingInstructionSyntax(r));
    }
  }

  internal sealed partial class XmlCommentSyntax : XmlNodeSyntax
  {
    internal readonly SyntaxToken lessThanExclamationMinusMinusToken;
    internal readonly GreenNode? textTokens;
    internal readonly SyntaxToken minusMinusGreaterThanToken;

    internal XmlCommentSyntax(SyntaxKind kind, SyntaxToken lessThanExclamationMinusMinusToken, GreenNode? textTokens, SyntaxToken minusMinusGreaterThanToken, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 3;
        this.AdjustFlagsAndWidth(lessThanExclamationMinusMinusToken);
        this.lessThanExclamationMinusMinusToken = lessThanExclamationMinusMinusToken;
        if (textTokens != null)
        {
            this.AdjustFlagsAndWidth(textTokens);
            this.textTokens = textTokens;
        }
        this.AdjustFlagsAndWidth(minusMinusGreaterThanToken);
        this.minusMinusGreaterThanToken = minusMinusGreaterThanToken;
    }


    internal XmlCommentSyntax(SyntaxKind kind, SyntaxToken lessThanExclamationMinusMinusToken, GreenNode? textTokens, SyntaxToken minusMinusGreaterThanToken, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 3;
        this.AdjustFlagsAndWidth(lessThanExclamationMinusMinusToken);
        this.lessThanExclamationMinusMinusToken = lessThanExclamationMinusMinusToken;
        if (textTokens != null)
        {
            this.AdjustFlagsAndWidth(textTokens);
            this.textTokens = textTokens;
        }
        this.AdjustFlagsAndWidth(minusMinusGreaterThanToken);
        this.minusMinusGreaterThanToken = minusMinusGreaterThanToken;
    }


    internal XmlCommentSyntax(SyntaxKind kind, SyntaxToken lessThanExclamationMinusMinusToken, GreenNode? textTokens, SyntaxToken minusMinusGreaterThanToken)
        : base(kind)
    {
        this.SlotCount = 3;
        this.AdjustFlagsAndWidth(lessThanExclamationMinusMinusToken);
        this.lessThanExclamationMinusMinusToken = lessThanExclamationMinusMinusToken;
        if (textTokens != null)
        {
            this.AdjustFlagsAndWidth(textTokens);
            this.textTokens = textTokens;
        }
        this.AdjustFlagsAndWidth(minusMinusGreaterThanToken);
        this.minusMinusGreaterThanToken = minusMinusGreaterThanToken;
    }

    public SyntaxToken LessThanExclamationMinusMinusToken => this.lessThanExclamationMinusMinusToken;
    public Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SyntaxToken> TextTokens => new Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SyntaxToken>(this.textTokens);
    public SyntaxToken MinusMinusGreaterThanToken => this.minusMinusGreaterThanToken;

    internal override GreenNode? GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.lessThanExclamationMinusMinusToken;
            case 1: return this.textTokens;
            case 2: return this.minusMinusGreaterThanToken;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new CSharp.Syntax.XmlCommentSyntax(this, parent, position);

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor) => visitor.VisitXmlComment(this);

    public override void Accept(CSharpSyntaxVisitor visitor) => visitor.VisitXmlComment(this);

    public XmlCommentSyntax Update(SyntaxToken lessThanExclamationMinusMinusToken, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SyntaxToken> textTokens, SyntaxToken minusMinusGreaterThanToken)
    {
        if (lessThanExclamationMinusMinusToken != this.LessThanExclamationMinusMinusToken || textTokens != this.TextTokens || minusMinusGreaterThanToken != this.MinusMinusGreaterThanToken)
        {
            var newNode = SyntaxFactory.XmlComment(lessThanExclamationMinusMinusToken, textTokens, minusMinusGreaterThanToken);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
        => new XmlCommentSyntax(this.Kind, this.lessThanExclamationMinusMinusToken, this.textTokens, this.minusMinusGreaterThanToken, diagnostics, GetAnnotations());

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
        => new XmlCommentSyntax(this.Kind, this.lessThanExclamationMinusMinusToken, this.textTokens, this.minusMinusGreaterThanToken, GetDiagnostics(), annotations);

    internal XmlCommentSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 3;
      var lessThanExclamationMinusMinusToken = (SyntaxToken)reader.ReadValue();
      if (lessThanExclamationMinusMinusToken != null)
      {
         AdjustFlagsAndWidth(lessThanExclamationMinusMinusToken);
         this.lessThanExclamationMinusMinusToken = lessThanExclamationMinusMinusToken;
      }
      var textTokens = (GreenNode?)reader.ReadValue();
      if (textTokens != null)
      {
         AdjustFlagsAndWidth(textTokens);
         this.textTokens = textTokens;
      }
      var minusMinusGreaterThanToken = (SyntaxToken)reader.ReadValue();
      if (minusMinusGreaterThanToken != null)
      {
         AdjustFlagsAndWidth(minusMinusGreaterThanToken);
         this.minusMinusGreaterThanToken = minusMinusGreaterThanToken;
      }
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.lessThanExclamationMinusMinusToken);
      writer.WriteValue(this.textTokens);
      writer.WriteValue(this.minusMinusGreaterThanToken);
    }

    static XmlCommentSyntax()
    {
       ObjectBinder.RegisterTypeReader(typeof(XmlCommentSyntax), r => new XmlCommentSyntax(r));
    }
  }

  internal abstract partial class DirectiveTriviaSyntax : StructuredTriviaSyntax
  {
    internal DirectiveTriviaSyntax(SyntaxKind kind, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
      : base(kind, diagnostics, annotations)
    {
      this.flags |= NodeFlags.ContainsDirectives;
    }
    internal DirectiveTriviaSyntax(SyntaxKind kind)
      : base(kind)
    {
      this.flags |= NodeFlags.ContainsDirectives;
    }

    protected DirectiveTriviaSyntax(ObjectReader reader)
       : base(reader)
    {
      this.flags |= NodeFlags.ContainsDirectives;
    }

    public abstract SyntaxToken HashToken { get; }

    public abstract SyntaxToken EndOfDirectiveToken { get; }

   public abstract bool IsActive { get; }
  }

  internal abstract partial class BranchingDirectiveTriviaSyntax : DirectiveTriviaSyntax
  {
    internal BranchingDirectiveTriviaSyntax(SyntaxKind kind, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
      : base(kind, diagnostics, annotations)
    {
    }
    internal BranchingDirectiveTriviaSyntax(SyntaxKind kind)
      : base(kind)
    {
    }

    protected BranchingDirectiveTriviaSyntax(ObjectReader reader)
       : base(reader)
    {
    }

   public abstract bool BranchTaken { get; }
  }

  internal abstract partial class ConditionalDirectiveTriviaSyntax : BranchingDirectiveTriviaSyntax
  {
    internal ConditionalDirectiveTriviaSyntax(SyntaxKind kind, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
      : base(kind, diagnostics, annotations)
    {
    }
    internal ConditionalDirectiveTriviaSyntax(SyntaxKind kind)
      : base(kind)
    {
    }

    protected ConditionalDirectiveTriviaSyntax(ObjectReader reader)
       : base(reader)
    {
    }

    public abstract ExpressionSyntax Condition { get; }

   public abstract bool ConditionValue { get; }
  }

  internal sealed partial class IfDirectiveTriviaSyntax : ConditionalDirectiveTriviaSyntax
  {
    internal readonly SyntaxToken hashToken;
    internal readonly SyntaxToken ifKeyword;
    internal readonly ExpressionSyntax condition;
    internal readonly SyntaxToken endOfDirectiveToken;
    internal readonly bool isActive;
    internal readonly bool branchTaken;
    internal readonly bool conditionValue;

    internal IfDirectiveTriviaSyntax(SyntaxKind kind, SyntaxToken hashToken, SyntaxToken ifKeyword, ExpressionSyntax condition, SyntaxToken endOfDirectiveToken, bool isActive, bool branchTaken, bool conditionValue, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 4;
        this.AdjustFlagsAndWidth(hashToken);
        this.hashToken = hashToken;
        this.AdjustFlagsAndWidth(ifKeyword);
        this.ifKeyword = ifKeyword;
        this.AdjustFlagsAndWidth(condition);
        this.condition = condition;
        this.AdjustFlagsAndWidth(endOfDirectiveToken);
        this.endOfDirectiveToken = endOfDirectiveToken;
        this.isActive = isActive;
        this.branchTaken = branchTaken;
        this.conditionValue = conditionValue;
    }


    internal IfDirectiveTriviaSyntax(SyntaxKind kind, SyntaxToken hashToken, SyntaxToken ifKeyword, ExpressionSyntax condition, SyntaxToken endOfDirectiveToken, bool isActive, bool branchTaken, bool conditionValue, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 4;
        this.AdjustFlagsAndWidth(hashToken);
        this.hashToken = hashToken;
        this.AdjustFlagsAndWidth(ifKeyword);
        this.ifKeyword = ifKeyword;
        this.AdjustFlagsAndWidth(condition);
        this.condition = condition;
        this.AdjustFlagsAndWidth(endOfDirectiveToken);
        this.endOfDirectiveToken = endOfDirectiveToken;
        this.isActive = isActive;
        this.branchTaken = branchTaken;
        this.conditionValue = conditionValue;
    }


    internal IfDirectiveTriviaSyntax(SyntaxKind kind, SyntaxToken hashToken, SyntaxToken ifKeyword, ExpressionSyntax condition, SyntaxToken endOfDirectiveToken, bool isActive, bool branchTaken, bool conditionValue)
        : base(kind)
    {
        this.SlotCount = 4;
        this.AdjustFlagsAndWidth(hashToken);
        this.hashToken = hashToken;
        this.AdjustFlagsAndWidth(ifKeyword);
        this.ifKeyword = ifKeyword;
        this.AdjustFlagsAndWidth(condition);
        this.condition = condition;
        this.AdjustFlagsAndWidth(endOfDirectiveToken);
        this.endOfDirectiveToken = endOfDirectiveToken;
        this.isActive = isActive;
        this.branchTaken = branchTaken;
        this.conditionValue = conditionValue;
    }

    public override SyntaxToken HashToken => this.hashToken;
    public SyntaxToken IfKeyword => this.ifKeyword;
    public override ExpressionSyntax Condition => this.condition;
    public override SyntaxToken EndOfDirectiveToken => this.endOfDirectiveToken;
    public override bool IsActive => this.isActive;
    public override bool BranchTaken => this.branchTaken;
    public override bool ConditionValue => this.conditionValue;

    internal override GreenNode? GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.hashToken;
            case 1: return this.ifKeyword;
            case 2: return this.condition;
            case 3: return this.endOfDirectiveToken;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new CSharp.Syntax.IfDirectiveTriviaSyntax(this, parent, position);

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor) => visitor.VisitIfDirectiveTrivia(this);

    public override void Accept(CSharpSyntaxVisitor visitor) => visitor.VisitIfDirectiveTrivia(this);

    public IfDirectiveTriviaSyntax Update(SyntaxToken hashToken, SyntaxToken ifKeyword, ExpressionSyntax condition, SyntaxToken endOfDirectiveToken, bool isActive, bool branchTaken, bool conditionValue)
    {
        if (hashToken != this.HashToken || ifKeyword != this.IfKeyword || condition != this.Condition || endOfDirectiveToken != this.EndOfDirectiveToken)
        {
            var newNode = SyntaxFactory.IfDirectiveTrivia(hashToken, ifKeyword, condition, endOfDirectiveToken, isActive, branchTaken, conditionValue);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
        => new IfDirectiveTriviaSyntax(this.Kind, this.hashToken, this.ifKeyword, this.condition, this.endOfDirectiveToken, this.isActive, this.branchTaken, this.conditionValue, diagnostics, GetAnnotations());

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
        => new IfDirectiveTriviaSyntax(this.Kind, this.hashToken, this.ifKeyword, this.condition, this.endOfDirectiveToken, this.isActive, this.branchTaken, this.conditionValue, GetDiagnostics(), annotations);

    internal IfDirectiveTriviaSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 4;
      var hashToken = (SyntaxToken)reader.ReadValue();
      if (hashToken != null)
      {
         AdjustFlagsAndWidth(hashToken);
         this.hashToken = hashToken;
      }
      var ifKeyword = (SyntaxToken)reader.ReadValue();
      if (ifKeyword != null)
      {
         AdjustFlagsAndWidth(ifKeyword);
         this.ifKeyword = ifKeyword;
      }
      var condition = (ExpressionSyntax)reader.ReadValue();
      if (condition != null)
      {
         AdjustFlagsAndWidth(condition);
         this.condition = condition;
      }
      var endOfDirectiveToken = (SyntaxToken)reader.ReadValue();
      if (endOfDirectiveToken != null)
      {
         AdjustFlagsAndWidth(endOfDirectiveToken);
         this.endOfDirectiveToken = endOfDirectiveToken;
      }
      this.isActive = (bool)reader.ReadBoolean();
      this.branchTaken = (bool)reader.ReadBoolean();
      this.conditionValue = (bool)reader.ReadBoolean();
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.hashToken);
      writer.WriteValue(this.ifKeyword);
      writer.WriteValue(this.condition);
      writer.WriteValue(this.endOfDirectiveToken);
      writer.WriteBoolean(this.isActive);
      writer.WriteBoolean(this.branchTaken);
      writer.WriteBoolean(this.conditionValue);
    }

    static IfDirectiveTriviaSyntax()
    {
       ObjectBinder.RegisterTypeReader(typeof(IfDirectiveTriviaSyntax), r => new IfDirectiveTriviaSyntax(r));
    }
  }

  internal sealed partial class ElifDirectiveTriviaSyntax : ConditionalDirectiveTriviaSyntax
  {
    internal readonly SyntaxToken hashToken;
    internal readonly SyntaxToken elifKeyword;
    internal readonly ExpressionSyntax condition;
    internal readonly SyntaxToken endOfDirectiveToken;
    internal readonly bool isActive;
    internal readonly bool branchTaken;
    internal readonly bool conditionValue;

    internal ElifDirectiveTriviaSyntax(SyntaxKind kind, SyntaxToken hashToken, SyntaxToken elifKeyword, ExpressionSyntax condition, SyntaxToken endOfDirectiveToken, bool isActive, bool branchTaken, bool conditionValue, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 4;
        this.AdjustFlagsAndWidth(hashToken);
        this.hashToken = hashToken;
        this.AdjustFlagsAndWidth(elifKeyword);
        this.elifKeyword = elifKeyword;
        this.AdjustFlagsAndWidth(condition);
        this.condition = condition;
        this.AdjustFlagsAndWidth(endOfDirectiveToken);
        this.endOfDirectiveToken = endOfDirectiveToken;
        this.isActive = isActive;
        this.branchTaken = branchTaken;
        this.conditionValue = conditionValue;
    }


    internal ElifDirectiveTriviaSyntax(SyntaxKind kind, SyntaxToken hashToken, SyntaxToken elifKeyword, ExpressionSyntax condition, SyntaxToken endOfDirectiveToken, bool isActive, bool branchTaken, bool conditionValue, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 4;
        this.AdjustFlagsAndWidth(hashToken);
        this.hashToken = hashToken;
        this.AdjustFlagsAndWidth(elifKeyword);
        this.elifKeyword = elifKeyword;
        this.AdjustFlagsAndWidth(condition);
        this.condition = condition;
        this.AdjustFlagsAndWidth(endOfDirectiveToken);
        this.endOfDirectiveToken = endOfDirectiveToken;
        this.isActive = isActive;
        this.branchTaken = branchTaken;
        this.conditionValue = conditionValue;
    }


    internal ElifDirectiveTriviaSyntax(SyntaxKind kind, SyntaxToken hashToken, SyntaxToken elifKeyword, ExpressionSyntax condition, SyntaxToken endOfDirectiveToken, bool isActive, bool branchTaken, bool conditionValue)
        : base(kind)
    {
        this.SlotCount = 4;
        this.AdjustFlagsAndWidth(hashToken);
        this.hashToken = hashToken;
        this.AdjustFlagsAndWidth(elifKeyword);
        this.elifKeyword = elifKeyword;
        this.AdjustFlagsAndWidth(condition);
        this.condition = condition;
        this.AdjustFlagsAndWidth(endOfDirectiveToken);
        this.endOfDirectiveToken = endOfDirectiveToken;
        this.isActive = isActive;
        this.branchTaken = branchTaken;
        this.conditionValue = conditionValue;
    }

    public override SyntaxToken HashToken => this.hashToken;
    public SyntaxToken ElifKeyword => this.elifKeyword;
    public override ExpressionSyntax Condition => this.condition;
    public override SyntaxToken EndOfDirectiveToken => this.endOfDirectiveToken;
    public override bool IsActive => this.isActive;
    public override bool BranchTaken => this.branchTaken;
    public override bool ConditionValue => this.conditionValue;

    internal override GreenNode? GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.hashToken;
            case 1: return this.elifKeyword;
            case 2: return this.condition;
            case 3: return this.endOfDirectiveToken;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new CSharp.Syntax.ElifDirectiveTriviaSyntax(this, parent, position);

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor) => visitor.VisitElifDirectiveTrivia(this);

    public override void Accept(CSharpSyntaxVisitor visitor) => visitor.VisitElifDirectiveTrivia(this);

    public ElifDirectiveTriviaSyntax Update(SyntaxToken hashToken, SyntaxToken elifKeyword, ExpressionSyntax condition, SyntaxToken endOfDirectiveToken, bool isActive, bool branchTaken, bool conditionValue)
    {
        if (hashToken != this.HashToken || elifKeyword != this.ElifKeyword || condition != this.Condition || endOfDirectiveToken != this.EndOfDirectiveToken)
        {
            var newNode = SyntaxFactory.ElifDirectiveTrivia(hashToken, elifKeyword, condition, endOfDirectiveToken, isActive, branchTaken, conditionValue);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
        => new ElifDirectiveTriviaSyntax(this.Kind, this.hashToken, this.elifKeyword, this.condition, this.endOfDirectiveToken, this.isActive, this.branchTaken, this.conditionValue, diagnostics, GetAnnotations());

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
        => new ElifDirectiveTriviaSyntax(this.Kind, this.hashToken, this.elifKeyword, this.condition, this.endOfDirectiveToken, this.isActive, this.branchTaken, this.conditionValue, GetDiagnostics(), annotations);

    internal ElifDirectiveTriviaSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 4;
      var hashToken = (SyntaxToken)reader.ReadValue();
      if (hashToken != null)
      {
         AdjustFlagsAndWidth(hashToken);
         this.hashToken = hashToken;
      }
      var elifKeyword = (SyntaxToken)reader.ReadValue();
      if (elifKeyword != null)
      {
         AdjustFlagsAndWidth(elifKeyword);
         this.elifKeyword = elifKeyword;
      }
      var condition = (ExpressionSyntax)reader.ReadValue();
      if (condition != null)
      {
         AdjustFlagsAndWidth(condition);
         this.condition = condition;
      }
      var endOfDirectiveToken = (SyntaxToken)reader.ReadValue();
      if (endOfDirectiveToken != null)
      {
         AdjustFlagsAndWidth(endOfDirectiveToken);
         this.endOfDirectiveToken = endOfDirectiveToken;
      }
      this.isActive = (bool)reader.ReadBoolean();
      this.branchTaken = (bool)reader.ReadBoolean();
      this.conditionValue = (bool)reader.ReadBoolean();
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.hashToken);
      writer.WriteValue(this.elifKeyword);
      writer.WriteValue(this.condition);
      writer.WriteValue(this.endOfDirectiveToken);
      writer.WriteBoolean(this.isActive);
      writer.WriteBoolean(this.branchTaken);
      writer.WriteBoolean(this.conditionValue);
    }

    static ElifDirectiveTriviaSyntax()
    {
       ObjectBinder.RegisterTypeReader(typeof(ElifDirectiveTriviaSyntax), r => new ElifDirectiveTriviaSyntax(r));
    }
  }

  internal sealed partial class ElseDirectiveTriviaSyntax : BranchingDirectiveTriviaSyntax
  {
    internal readonly SyntaxToken hashToken;
    internal readonly SyntaxToken elseKeyword;
    internal readonly SyntaxToken endOfDirectiveToken;
    internal readonly bool isActive;
    internal readonly bool branchTaken;

    internal ElseDirectiveTriviaSyntax(SyntaxKind kind, SyntaxToken hashToken, SyntaxToken elseKeyword, SyntaxToken endOfDirectiveToken, bool isActive, bool branchTaken, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 3;
        this.AdjustFlagsAndWidth(hashToken);
        this.hashToken = hashToken;
        this.AdjustFlagsAndWidth(elseKeyword);
        this.elseKeyword = elseKeyword;
        this.AdjustFlagsAndWidth(endOfDirectiveToken);
        this.endOfDirectiveToken = endOfDirectiveToken;
        this.isActive = isActive;
        this.branchTaken = branchTaken;
    }


    internal ElseDirectiveTriviaSyntax(SyntaxKind kind, SyntaxToken hashToken, SyntaxToken elseKeyword, SyntaxToken endOfDirectiveToken, bool isActive, bool branchTaken, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 3;
        this.AdjustFlagsAndWidth(hashToken);
        this.hashToken = hashToken;
        this.AdjustFlagsAndWidth(elseKeyword);
        this.elseKeyword = elseKeyword;
        this.AdjustFlagsAndWidth(endOfDirectiveToken);
        this.endOfDirectiveToken = endOfDirectiveToken;
        this.isActive = isActive;
        this.branchTaken = branchTaken;
    }


    internal ElseDirectiveTriviaSyntax(SyntaxKind kind, SyntaxToken hashToken, SyntaxToken elseKeyword, SyntaxToken endOfDirectiveToken, bool isActive, bool branchTaken)
        : base(kind)
    {
        this.SlotCount = 3;
        this.AdjustFlagsAndWidth(hashToken);
        this.hashToken = hashToken;
        this.AdjustFlagsAndWidth(elseKeyword);
        this.elseKeyword = elseKeyword;
        this.AdjustFlagsAndWidth(endOfDirectiveToken);
        this.endOfDirectiveToken = endOfDirectiveToken;
        this.isActive = isActive;
        this.branchTaken = branchTaken;
    }

    public override SyntaxToken HashToken => this.hashToken;
    public SyntaxToken ElseKeyword => this.elseKeyword;
    public override SyntaxToken EndOfDirectiveToken => this.endOfDirectiveToken;
    public override bool IsActive => this.isActive;
    public override bool BranchTaken => this.branchTaken;

    internal override GreenNode? GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.hashToken;
            case 1: return this.elseKeyword;
            case 2: return this.endOfDirectiveToken;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new CSharp.Syntax.ElseDirectiveTriviaSyntax(this, parent, position);

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor) => visitor.VisitElseDirectiveTrivia(this);

    public override void Accept(CSharpSyntaxVisitor visitor) => visitor.VisitElseDirectiveTrivia(this);

    public ElseDirectiveTriviaSyntax Update(SyntaxToken hashToken, SyntaxToken elseKeyword, SyntaxToken endOfDirectiveToken, bool isActive, bool branchTaken)
    {
        if (hashToken != this.HashToken || elseKeyword != this.ElseKeyword || endOfDirectiveToken != this.EndOfDirectiveToken)
        {
            var newNode = SyntaxFactory.ElseDirectiveTrivia(hashToken, elseKeyword, endOfDirectiveToken, isActive, branchTaken);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
        => new ElseDirectiveTriviaSyntax(this.Kind, this.hashToken, this.elseKeyword, this.endOfDirectiveToken, this.isActive, this.branchTaken, diagnostics, GetAnnotations());

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
        => new ElseDirectiveTriviaSyntax(this.Kind, this.hashToken, this.elseKeyword, this.endOfDirectiveToken, this.isActive, this.branchTaken, GetDiagnostics(), annotations);

    internal ElseDirectiveTriviaSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 3;
      var hashToken = (SyntaxToken)reader.ReadValue();
      if (hashToken != null)
      {
         AdjustFlagsAndWidth(hashToken);
         this.hashToken = hashToken;
      }
      var elseKeyword = (SyntaxToken)reader.ReadValue();
      if (elseKeyword != null)
      {
         AdjustFlagsAndWidth(elseKeyword);
         this.elseKeyword = elseKeyword;
      }
      var endOfDirectiveToken = (SyntaxToken)reader.ReadValue();
      if (endOfDirectiveToken != null)
      {
         AdjustFlagsAndWidth(endOfDirectiveToken);
         this.endOfDirectiveToken = endOfDirectiveToken;
      }
      this.isActive = (bool)reader.ReadBoolean();
      this.branchTaken = (bool)reader.ReadBoolean();
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.hashToken);
      writer.WriteValue(this.elseKeyword);
      writer.WriteValue(this.endOfDirectiveToken);
      writer.WriteBoolean(this.isActive);
      writer.WriteBoolean(this.branchTaken);
    }

    static ElseDirectiveTriviaSyntax()
    {
       ObjectBinder.RegisterTypeReader(typeof(ElseDirectiveTriviaSyntax), r => new ElseDirectiveTriviaSyntax(r));
    }
  }

  internal sealed partial class EndIfDirectiveTriviaSyntax : DirectiveTriviaSyntax
  {
    internal readonly SyntaxToken hashToken;
    internal readonly SyntaxToken endIfKeyword;
    internal readonly SyntaxToken endOfDirectiveToken;
    internal readonly bool isActive;

    internal EndIfDirectiveTriviaSyntax(SyntaxKind kind, SyntaxToken hashToken, SyntaxToken endIfKeyword, SyntaxToken endOfDirectiveToken, bool isActive, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 3;
        this.AdjustFlagsAndWidth(hashToken);
        this.hashToken = hashToken;
        this.AdjustFlagsAndWidth(endIfKeyword);
        this.endIfKeyword = endIfKeyword;
        this.AdjustFlagsAndWidth(endOfDirectiveToken);
        this.endOfDirectiveToken = endOfDirectiveToken;
        this.isActive = isActive;
    }


    internal EndIfDirectiveTriviaSyntax(SyntaxKind kind, SyntaxToken hashToken, SyntaxToken endIfKeyword, SyntaxToken endOfDirectiveToken, bool isActive, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 3;
        this.AdjustFlagsAndWidth(hashToken);
        this.hashToken = hashToken;
        this.AdjustFlagsAndWidth(endIfKeyword);
        this.endIfKeyword = endIfKeyword;
        this.AdjustFlagsAndWidth(endOfDirectiveToken);
        this.endOfDirectiveToken = endOfDirectiveToken;
        this.isActive = isActive;
    }


    internal EndIfDirectiveTriviaSyntax(SyntaxKind kind, SyntaxToken hashToken, SyntaxToken endIfKeyword, SyntaxToken endOfDirectiveToken, bool isActive)
        : base(kind)
    {
        this.SlotCount = 3;
        this.AdjustFlagsAndWidth(hashToken);
        this.hashToken = hashToken;
        this.AdjustFlagsAndWidth(endIfKeyword);
        this.endIfKeyword = endIfKeyword;
        this.AdjustFlagsAndWidth(endOfDirectiveToken);
        this.endOfDirectiveToken = endOfDirectiveToken;
        this.isActive = isActive;
    }

    public override SyntaxToken HashToken => this.hashToken;
    public SyntaxToken EndIfKeyword => this.endIfKeyword;
    public override SyntaxToken EndOfDirectiveToken => this.endOfDirectiveToken;
    public override bool IsActive => this.isActive;

    internal override GreenNode? GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.hashToken;
            case 1: return this.endIfKeyword;
            case 2: return this.endOfDirectiveToken;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new CSharp.Syntax.EndIfDirectiveTriviaSyntax(this, parent, position);

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor) => visitor.VisitEndIfDirectiveTrivia(this);

    public override void Accept(CSharpSyntaxVisitor visitor) => visitor.VisitEndIfDirectiveTrivia(this);

    public EndIfDirectiveTriviaSyntax Update(SyntaxToken hashToken, SyntaxToken endIfKeyword, SyntaxToken endOfDirectiveToken, bool isActive)
    {
        if (hashToken != this.HashToken || endIfKeyword != this.EndIfKeyword || endOfDirectiveToken != this.EndOfDirectiveToken)
        {
            var newNode = SyntaxFactory.EndIfDirectiveTrivia(hashToken, endIfKeyword, endOfDirectiveToken, isActive);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
        => new EndIfDirectiveTriviaSyntax(this.Kind, this.hashToken, this.endIfKeyword, this.endOfDirectiveToken, this.isActive, diagnostics, GetAnnotations());

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
        => new EndIfDirectiveTriviaSyntax(this.Kind, this.hashToken, this.endIfKeyword, this.endOfDirectiveToken, this.isActive, GetDiagnostics(), annotations);

    internal EndIfDirectiveTriviaSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 3;
      var hashToken = (SyntaxToken)reader.ReadValue();
      if (hashToken != null)
      {
         AdjustFlagsAndWidth(hashToken);
         this.hashToken = hashToken;
      }
      var endIfKeyword = (SyntaxToken)reader.ReadValue();
      if (endIfKeyword != null)
      {
         AdjustFlagsAndWidth(endIfKeyword);
         this.endIfKeyword = endIfKeyword;
      }
      var endOfDirectiveToken = (SyntaxToken)reader.ReadValue();
      if (endOfDirectiveToken != null)
      {
         AdjustFlagsAndWidth(endOfDirectiveToken);
         this.endOfDirectiveToken = endOfDirectiveToken;
      }
      this.isActive = (bool)reader.ReadBoolean();
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.hashToken);
      writer.WriteValue(this.endIfKeyword);
      writer.WriteValue(this.endOfDirectiveToken);
      writer.WriteBoolean(this.isActive);
    }

    static EndIfDirectiveTriviaSyntax()
    {
       ObjectBinder.RegisterTypeReader(typeof(EndIfDirectiveTriviaSyntax), r => new EndIfDirectiveTriviaSyntax(r));
    }
  }

  internal sealed partial class RegionDirectiveTriviaSyntax : DirectiveTriviaSyntax
  {
    internal readonly SyntaxToken hashToken;
    internal readonly SyntaxToken regionKeyword;
    internal readonly SyntaxToken endOfDirectiveToken;
    internal readonly bool isActive;

    internal RegionDirectiveTriviaSyntax(SyntaxKind kind, SyntaxToken hashToken, SyntaxToken regionKeyword, SyntaxToken endOfDirectiveToken, bool isActive, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 3;
        this.AdjustFlagsAndWidth(hashToken);
        this.hashToken = hashToken;
        this.AdjustFlagsAndWidth(regionKeyword);
        this.regionKeyword = regionKeyword;
        this.AdjustFlagsAndWidth(endOfDirectiveToken);
        this.endOfDirectiveToken = endOfDirectiveToken;
        this.isActive = isActive;
    }


    internal RegionDirectiveTriviaSyntax(SyntaxKind kind, SyntaxToken hashToken, SyntaxToken regionKeyword, SyntaxToken endOfDirectiveToken, bool isActive, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 3;
        this.AdjustFlagsAndWidth(hashToken);
        this.hashToken = hashToken;
        this.AdjustFlagsAndWidth(regionKeyword);
        this.regionKeyword = regionKeyword;
        this.AdjustFlagsAndWidth(endOfDirectiveToken);
        this.endOfDirectiveToken = endOfDirectiveToken;
        this.isActive = isActive;
    }


    internal RegionDirectiveTriviaSyntax(SyntaxKind kind, SyntaxToken hashToken, SyntaxToken regionKeyword, SyntaxToken endOfDirectiveToken, bool isActive)
        : base(kind)
    {
        this.SlotCount = 3;
        this.AdjustFlagsAndWidth(hashToken);
        this.hashToken = hashToken;
        this.AdjustFlagsAndWidth(regionKeyword);
        this.regionKeyword = regionKeyword;
        this.AdjustFlagsAndWidth(endOfDirectiveToken);
        this.endOfDirectiveToken = endOfDirectiveToken;
        this.isActive = isActive;
    }

    public override SyntaxToken HashToken => this.hashToken;
    public SyntaxToken RegionKeyword => this.regionKeyword;
    public override SyntaxToken EndOfDirectiveToken => this.endOfDirectiveToken;
    public override bool IsActive => this.isActive;

    internal override GreenNode? GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.hashToken;
            case 1: return this.regionKeyword;
            case 2: return this.endOfDirectiveToken;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new CSharp.Syntax.RegionDirectiveTriviaSyntax(this, parent, position);

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor) => visitor.VisitRegionDirectiveTrivia(this);

    public override void Accept(CSharpSyntaxVisitor visitor) => visitor.VisitRegionDirectiveTrivia(this);

    public RegionDirectiveTriviaSyntax Update(SyntaxToken hashToken, SyntaxToken regionKeyword, SyntaxToken endOfDirectiveToken, bool isActive)
    {
        if (hashToken != this.HashToken || regionKeyword != this.RegionKeyword || endOfDirectiveToken != this.EndOfDirectiveToken)
        {
            var newNode = SyntaxFactory.RegionDirectiveTrivia(hashToken, regionKeyword, endOfDirectiveToken, isActive);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
        => new RegionDirectiveTriviaSyntax(this.Kind, this.hashToken, this.regionKeyword, this.endOfDirectiveToken, this.isActive, diagnostics, GetAnnotations());

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
        => new RegionDirectiveTriviaSyntax(this.Kind, this.hashToken, this.regionKeyword, this.endOfDirectiveToken, this.isActive, GetDiagnostics(), annotations);

    internal RegionDirectiveTriviaSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 3;
      var hashToken = (SyntaxToken)reader.ReadValue();
      if (hashToken != null)
      {
         AdjustFlagsAndWidth(hashToken);
         this.hashToken = hashToken;
      }
      var regionKeyword = (SyntaxToken)reader.ReadValue();
      if (regionKeyword != null)
      {
         AdjustFlagsAndWidth(regionKeyword);
         this.regionKeyword = regionKeyword;
      }
      var endOfDirectiveToken = (SyntaxToken)reader.ReadValue();
      if (endOfDirectiveToken != null)
      {
         AdjustFlagsAndWidth(endOfDirectiveToken);
         this.endOfDirectiveToken = endOfDirectiveToken;
      }
      this.isActive = (bool)reader.ReadBoolean();
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.hashToken);
      writer.WriteValue(this.regionKeyword);
      writer.WriteValue(this.endOfDirectiveToken);
      writer.WriteBoolean(this.isActive);
    }

    static RegionDirectiveTriviaSyntax()
    {
       ObjectBinder.RegisterTypeReader(typeof(RegionDirectiveTriviaSyntax), r => new RegionDirectiveTriviaSyntax(r));
    }
  }

  internal sealed partial class EndRegionDirectiveTriviaSyntax : DirectiveTriviaSyntax
  {
    internal readonly SyntaxToken hashToken;
    internal readonly SyntaxToken endRegionKeyword;
    internal readonly SyntaxToken endOfDirectiveToken;
    internal readonly bool isActive;

    internal EndRegionDirectiveTriviaSyntax(SyntaxKind kind, SyntaxToken hashToken, SyntaxToken endRegionKeyword, SyntaxToken endOfDirectiveToken, bool isActive, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 3;
        this.AdjustFlagsAndWidth(hashToken);
        this.hashToken = hashToken;
        this.AdjustFlagsAndWidth(endRegionKeyword);
        this.endRegionKeyword = endRegionKeyword;
        this.AdjustFlagsAndWidth(endOfDirectiveToken);
        this.endOfDirectiveToken = endOfDirectiveToken;
        this.isActive = isActive;
    }


    internal EndRegionDirectiveTriviaSyntax(SyntaxKind kind, SyntaxToken hashToken, SyntaxToken endRegionKeyword, SyntaxToken endOfDirectiveToken, bool isActive, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 3;
        this.AdjustFlagsAndWidth(hashToken);
        this.hashToken = hashToken;
        this.AdjustFlagsAndWidth(endRegionKeyword);
        this.endRegionKeyword = endRegionKeyword;
        this.AdjustFlagsAndWidth(endOfDirectiveToken);
        this.endOfDirectiveToken = endOfDirectiveToken;
        this.isActive = isActive;
    }


    internal EndRegionDirectiveTriviaSyntax(SyntaxKind kind, SyntaxToken hashToken, SyntaxToken endRegionKeyword, SyntaxToken endOfDirectiveToken, bool isActive)
        : base(kind)
    {
        this.SlotCount = 3;
        this.AdjustFlagsAndWidth(hashToken);
        this.hashToken = hashToken;
        this.AdjustFlagsAndWidth(endRegionKeyword);
        this.endRegionKeyword = endRegionKeyword;
        this.AdjustFlagsAndWidth(endOfDirectiveToken);
        this.endOfDirectiveToken = endOfDirectiveToken;
        this.isActive = isActive;
    }

    public override SyntaxToken HashToken => this.hashToken;
    public SyntaxToken EndRegionKeyword => this.endRegionKeyword;
    public override SyntaxToken EndOfDirectiveToken => this.endOfDirectiveToken;
    public override bool IsActive => this.isActive;

    internal override GreenNode? GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.hashToken;
            case 1: return this.endRegionKeyword;
            case 2: return this.endOfDirectiveToken;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new CSharp.Syntax.EndRegionDirectiveTriviaSyntax(this, parent, position);

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor) => visitor.VisitEndRegionDirectiveTrivia(this);

    public override void Accept(CSharpSyntaxVisitor visitor) => visitor.VisitEndRegionDirectiveTrivia(this);

    public EndRegionDirectiveTriviaSyntax Update(SyntaxToken hashToken, SyntaxToken endRegionKeyword, SyntaxToken endOfDirectiveToken, bool isActive)
    {
        if (hashToken != this.HashToken || endRegionKeyword != this.EndRegionKeyword || endOfDirectiveToken != this.EndOfDirectiveToken)
        {
            var newNode = SyntaxFactory.EndRegionDirectiveTrivia(hashToken, endRegionKeyword, endOfDirectiveToken, isActive);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
        => new EndRegionDirectiveTriviaSyntax(this.Kind, this.hashToken, this.endRegionKeyword, this.endOfDirectiveToken, this.isActive, diagnostics, GetAnnotations());

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
        => new EndRegionDirectiveTriviaSyntax(this.Kind, this.hashToken, this.endRegionKeyword, this.endOfDirectiveToken, this.isActive, GetDiagnostics(), annotations);

    internal EndRegionDirectiveTriviaSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 3;
      var hashToken = (SyntaxToken)reader.ReadValue();
      if (hashToken != null)
      {
         AdjustFlagsAndWidth(hashToken);
         this.hashToken = hashToken;
      }
      var endRegionKeyword = (SyntaxToken)reader.ReadValue();
      if (endRegionKeyword != null)
      {
         AdjustFlagsAndWidth(endRegionKeyword);
         this.endRegionKeyword = endRegionKeyword;
      }
      var endOfDirectiveToken = (SyntaxToken)reader.ReadValue();
      if (endOfDirectiveToken != null)
      {
         AdjustFlagsAndWidth(endOfDirectiveToken);
         this.endOfDirectiveToken = endOfDirectiveToken;
      }
      this.isActive = (bool)reader.ReadBoolean();
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.hashToken);
      writer.WriteValue(this.endRegionKeyword);
      writer.WriteValue(this.endOfDirectiveToken);
      writer.WriteBoolean(this.isActive);
    }

    static EndRegionDirectiveTriviaSyntax()
    {
       ObjectBinder.RegisterTypeReader(typeof(EndRegionDirectiveTriviaSyntax), r => new EndRegionDirectiveTriviaSyntax(r));
    }
  }

  internal sealed partial class ErrorDirectiveTriviaSyntax : DirectiveTriviaSyntax
  {
    internal readonly SyntaxToken hashToken;
    internal readonly SyntaxToken errorKeyword;
    internal readonly SyntaxToken endOfDirectiveToken;
    internal readonly bool isActive;

    internal ErrorDirectiveTriviaSyntax(SyntaxKind kind, SyntaxToken hashToken, SyntaxToken errorKeyword, SyntaxToken endOfDirectiveToken, bool isActive, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 3;
        this.AdjustFlagsAndWidth(hashToken);
        this.hashToken = hashToken;
        this.AdjustFlagsAndWidth(errorKeyword);
        this.errorKeyword = errorKeyword;
        this.AdjustFlagsAndWidth(endOfDirectiveToken);
        this.endOfDirectiveToken = endOfDirectiveToken;
        this.isActive = isActive;
    }


    internal ErrorDirectiveTriviaSyntax(SyntaxKind kind, SyntaxToken hashToken, SyntaxToken errorKeyword, SyntaxToken endOfDirectiveToken, bool isActive, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 3;
        this.AdjustFlagsAndWidth(hashToken);
        this.hashToken = hashToken;
        this.AdjustFlagsAndWidth(errorKeyword);
        this.errorKeyword = errorKeyword;
        this.AdjustFlagsAndWidth(endOfDirectiveToken);
        this.endOfDirectiveToken = endOfDirectiveToken;
        this.isActive = isActive;
    }


    internal ErrorDirectiveTriviaSyntax(SyntaxKind kind, SyntaxToken hashToken, SyntaxToken errorKeyword, SyntaxToken endOfDirectiveToken, bool isActive)
        : base(kind)
    {
        this.SlotCount = 3;
        this.AdjustFlagsAndWidth(hashToken);
        this.hashToken = hashToken;
        this.AdjustFlagsAndWidth(errorKeyword);
        this.errorKeyword = errorKeyword;
        this.AdjustFlagsAndWidth(endOfDirectiveToken);
        this.endOfDirectiveToken = endOfDirectiveToken;
        this.isActive = isActive;
    }

    public override SyntaxToken HashToken => this.hashToken;
    public SyntaxToken ErrorKeyword => this.errorKeyword;
    public override SyntaxToken EndOfDirectiveToken => this.endOfDirectiveToken;
    public override bool IsActive => this.isActive;

    internal override GreenNode? GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.hashToken;
            case 1: return this.errorKeyword;
            case 2: return this.endOfDirectiveToken;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new CSharp.Syntax.ErrorDirectiveTriviaSyntax(this, parent, position);

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor) => visitor.VisitErrorDirectiveTrivia(this);

    public override void Accept(CSharpSyntaxVisitor visitor) => visitor.VisitErrorDirectiveTrivia(this);

    public ErrorDirectiveTriviaSyntax Update(SyntaxToken hashToken, SyntaxToken errorKeyword, SyntaxToken endOfDirectiveToken, bool isActive)
    {
        if (hashToken != this.HashToken || errorKeyword != this.ErrorKeyword || endOfDirectiveToken != this.EndOfDirectiveToken)
        {
            var newNode = SyntaxFactory.ErrorDirectiveTrivia(hashToken, errorKeyword, endOfDirectiveToken, isActive);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
        => new ErrorDirectiveTriviaSyntax(this.Kind, this.hashToken, this.errorKeyword, this.endOfDirectiveToken, this.isActive, diagnostics, GetAnnotations());

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
        => new ErrorDirectiveTriviaSyntax(this.Kind, this.hashToken, this.errorKeyword, this.endOfDirectiveToken, this.isActive, GetDiagnostics(), annotations);

    internal ErrorDirectiveTriviaSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 3;
      var hashToken = (SyntaxToken)reader.ReadValue();
      if (hashToken != null)
      {
         AdjustFlagsAndWidth(hashToken);
         this.hashToken = hashToken;
      }
      var errorKeyword = (SyntaxToken)reader.ReadValue();
      if (errorKeyword != null)
      {
         AdjustFlagsAndWidth(errorKeyword);
         this.errorKeyword = errorKeyword;
      }
      var endOfDirectiveToken = (SyntaxToken)reader.ReadValue();
      if (endOfDirectiveToken != null)
      {
         AdjustFlagsAndWidth(endOfDirectiveToken);
         this.endOfDirectiveToken = endOfDirectiveToken;
      }
      this.isActive = (bool)reader.ReadBoolean();
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.hashToken);
      writer.WriteValue(this.errorKeyword);
      writer.WriteValue(this.endOfDirectiveToken);
      writer.WriteBoolean(this.isActive);
    }

    static ErrorDirectiveTriviaSyntax()
    {
       ObjectBinder.RegisterTypeReader(typeof(ErrorDirectiveTriviaSyntax), r => new ErrorDirectiveTriviaSyntax(r));
    }
  }

  internal sealed partial class WarningDirectiveTriviaSyntax : DirectiveTriviaSyntax
  {
    internal readonly SyntaxToken hashToken;
    internal readonly SyntaxToken warningKeyword;
    internal readonly SyntaxToken endOfDirectiveToken;
    internal readonly bool isActive;

    internal WarningDirectiveTriviaSyntax(SyntaxKind kind, SyntaxToken hashToken, SyntaxToken warningKeyword, SyntaxToken endOfDirectiveToken, bool isActive, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 3;
        this.AdjustFlagsAndWidth(hashToken);
        this.hashToken = hashToken;
        this.AdjustFlagsAndWidth(warningKeyword);
        this.warningKeyword = warningKeyword;
        this.AdjustFlagsAndWidth(endOfDirectiveToken);
        this.endOfDirectiveToken = endOfDirectiveToken;
        this.isActive = isActive;
    }


    internal WarningDirectiveTriviaSyntax(SyntaxKind kind, SyntaxToken hashToken, SyntaxToken warningKeyword, SyntaxToken endOfDirectiveToken, bool isActive, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 3;
        this.AdjustFlagsAndWidth(hashToken);
        this.hashToken = hashToken;
        this.AdjustFlagsAndWidth(warningKeyword);
        this.warningKeyword = warningKeyword;
        this.AdjustFlagsAndWidth(endOfDirectiveToken);
        this.endOfDirectiveToken = endOfDirectiveToken;
        this.isActive = isActive;
    }


    internal WarningDirectiveTriviaSyntax(SyntaxKind kind, SyntaxToken hashToken, SyntaxToken warningKeyword, SyntaxToken endOfDirectiveToken, bool isActive)
        : base(kind)
    {
        this.SlotCount = 3;
        this.AdjustFlagsAndWidth(hashToken);
        this.hashToken = hashToken;
        this.AdjustFlagsAndWidth(warningKeyword);
        this.warningKeyword = warningKeyword;
        this.AdjustFlagsAndWidth(endOfDirectiveToken);
        this.endOfDirectiveToken = endOfDirectiveToken;
        this.isActive = isActive;
    }

    public override SyntaxToken HashToken => this.hashToken;
    public SyntaxToken WarningKeyword => this.warningKeyword;
    public override SyntaxToken EndOfDirectiveToken => this.endOfDirectiveToken;
    public override bool IsActive => this.isActive;

    internal override GreenNode? GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.hashToken;
            case 1: return this.warningKeyword;
            case 2: return this.endOfDirectiveToken;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new CSharp.Syntax.WarningDirectiveTriviaSyntax(this, parent, position);

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor) => visitor.VisitWarningDirectiveTrivia(this);

    public override void Accept(CSharpSyntaxVisitor visitor) => visitor.VisitWarningDirectiveTrivia(this);

    public WarningDirectiveTriviaSyntax Update(SyntaxToken hashToken, SyntaxToken warningKeyword, SyntaxToken endOfDirectiveToken, bool isActive)
    {
        if (hashToken != this.HashToken || warningKeyword != this.WarningKeyword || endOfDirectiveToken != this.EndOfDirectiveToken)
        {
            var newNode = SyntaxFactory.WarningDirectiveTrivia(hashToken, warningKeyword, endOfDirectiveToken, isActive);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
        => new WarningDirectiveTriviaSyntax(this.Kind, this.hashToken, this.warningKeyword, this.endOfDirectiveToken, this.isActive, diagnostics, GetAnnotations());

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
        => new WarningDirectiveTriviaSyntax(this.Kind, this.hashToken, this.warningKeyword, this.endOfDirectiveToken, this.isActive, GetDiagnostics(), annotations);

    internal WarningDirectiveTriviaSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 3;
      var hashToken = (SyntaxToken)reader.ReadValue();
      if (hashToken != null)
      {
         AdjustFlagsAndWidth(hashToken);
         this.hashToken = hashToken;
      }
      var warningKeyword = (SyntaxToken)reader.ReadValue();
      if (warningKeyword != null)
      {
         AdjustFlagsAndWidth(warningKeyword);
         this.warningKeyword = warningKeyword;
      }
      var endOfDirectiveToken = (SyntaxToken)reader.ReadValue();
      if (endOfDirectiveToken != null)
      {
         AdjustFlagsAndWidth(endOfDirectiveToken);
         this.endOfDirectiveToken = endOfDirectiveToken;
      }
      this.isActive = (bool)reader.ReadBoolean();
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.hashToken);
      writer.WriteValue(this.warningKeyword);
      writer.WriteValue(this.endOfDirectiveToken);
      writer.WriteBoolean(this.isActive);
    }

    static WarningDirectiveTriviaSyntax()
    {
       ObjectBinder.RegisterTypeReader(typeof(WarningDirectiveTriviaSyntax), r => new WarningDirectiveTriviaSyntax(r));
    }
  }

  internal sealed partial class BadDirectiveTriviaSyntax : DirectiveTriviaSyntax
  {
    internal readonly SyntaxToken hashToken;
    internal readonly SyntaxToken identifier;
    internal readonly SyntaxToken endOfDirectiveToken;
    internal readonly bool isActive;

    internal BadDirectiveTriviaSyntax(SyntaxKind kind, SyntaxToken hashToken, SyntaxToken identifier, SyntaxToken endOfDirectiveToken, bool isActive, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 3;
        this.AdjustFlagsAndWidth(hashToken);
        this.hashToken = hashToken;
        this.AdjustFlagsAndWidth(identifier);
        this.identifier = identifier;
        this.AdjustFlagsAndWidth(endOfDirectiveToken);
        this.endOfDirectiveToken = endOfDirectiveToken;
        this.isActive = isActive;
    }


    internal BadDirectiveTriviaSyntax(SyntaxKind kind, SyntaxToken hashToken, SyntaxToken identifier, SyntaxToken endOfDirectiveToken, bool isActive, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 3;
        this.AdjustFlagsAndWidth(hashToken);
        this.hashToken = hashToken;
        this.AdjustFlagsAndWidth(identifier);
        this.identifier = identifier;
        this.AdjustFlagsAndWidth(endOfDirectiveToken);
        this.endOfDirectiveToken = endOfDirectiveToken;
        this.isActive = isActive;
    }


    internal BadDirectiveTriviaSyntax(SyntaxKind kind, SyntaxToken hashToken, SyntaxToken identifier, SyntaxToken endOfDirectiveToken, bool isActive)
        : base(kind)
    {
        this.SlotCount = 3;
        this.AdjustFlagsAndWidth(hashToken);
        this.hashToken = hashToken;
        this.AdjustFlagsAndWidth(identifier);
        this.identifier = identifier;
        this.AdjustFlagsAndWidth(endOfDirectiveToken);
        this.endOfDirectiveToken = endOfDirectiveToken;
        this.isActive = isActive;
    }

    public override SyntaxToken HashToken => this.hashToken;
    public SyntaxToken Identifier => this.identifier;
    public override SyntaxToken EndOfDirectiveToken => this.endOfDirectiveToken;
    public override bool IsActive => this.isActive;

    internal override GreenNode? GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.hashToken;
            case 1: return this.identifier;
            case 2: return this.endOfDirectiveToken;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new CSharp.Syntax.BadDirectiveTriviaSyntax(this, parent, position);

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor) => visitor.VisitBadDirectiveTrivia(this);

    public override void Accept(CSharpSyntaxVisitor visitor) => visitor.VisitBadDirectiveTrivia(this);

    public BadDirectiveTriviaSyntax Update(SyntaxToken hashToken, SyntaxToken identifier, SyntaxToken endOfDirectiveToken, bool isActive)
    {
        if (hashToken != this.HashToken || identifier != this.Identifier || endOfDirectiveToken != this.EndOfDirectiveToken)
        {
            var newNode = SyntaxFactory.BadDirectiveTrivia(hashToken, identifier, endOfDirectiveToken, isActive);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
        => new BadDirectiveTriviaSyntax(this.Kind, this.hashToken, this.identifier, this.endOfDirectiveToken, this.isActive, diagnostics, GetAnnotations());

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
        => new BadDirectiveTriviaSyntax(this.Kind, this.hashToken, this.identifier, this.endOfDirectiveToken, this.isActive, GetDiagnostics(), annotations);

    internal BadDirectiveTriviaSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 3;
      var hashToken = (SyntaxToken)reader.ReadValue();
      if (hashToken != null)
      {
         AdjustFlagsAndWidth(hashToken);
         this.hashToken = hashToken;
      }
      var identifier = (SyntaxToken)reader.ReadValue();
      if (identifier != null)
      {
         AdjustFlagsAndWidth(identifier);
         this.identifier = identifier;
      }
      var endOfDirectiveToken = (SyntaxToken)reader.ReadValue();
      if (endOfDirectiveToken != null)
      {
         AdjustFlagsAndWidth(endOfDirectiveToken);
         this.endOfDirectiveToken = endOfDirectiveToken;
      }
      this.isActive = (bool)reader.ReadBoolean();
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.hashToken);
      writer.WriteValue(this.identifier);
      writer.WriteValue(this.endOfDirectiveToken);
      writer.WriteBoolean(this.isActive);
    }

    static BadDirectiveTriviaSyntax()
    {
       ObjectBinder.RegisterTypeReader(typeof(BadDirectiveTriviaSyntax), r => new BadDirectiveTriviaSyntax(r));
    }
  }

  internal sealed partial class DefineDirectiveTriviaSyntax : DirectiveTriviaSyntax
  {
    internal readonly SyntaxToken hashToken;
    internal readonly SyntaxToken defineKeyword;
    internal readonly SyntaxToken name;
    internal readonly SyntaxToken endOfDirectiveToken;
    internal readonly bool isActive;

    internal DefineDirectiveTriviaSyntax(SyntaxKind kind, SyntaxToken hashToken, SyntaxToken defineKeyword, SyntaxToken name, SyntaxToken endOfDirectiveToken, bool isActive, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 4;
        this.AdjustFlagsAndWidth(hashToken);
        this.hashToken = hashToken;
        this.AdjustFlagsAndWidth(defineKeyword);
        this.defineKeyword = defineKeyword;
        this.AdjustFlagsAndWidth(name);
        this.name = name;
        this.AdjustFlagsAndWidth(endOfDirectiveToken);
        this.endOfDirectiveToken = endOfDirectiveToken;
        this.isActive = isActive;
    }


    internal DefineDirectiveTriviaSyntax(SyntaxKind kind, SyntaxToken hashToken, SyntaxToken defineKeyword, SyntaxToken name, SyntaxToken endOfDirectiveToken, bool isActive, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 4;
        this.AdjustFlagsAndWidth(hashToken);
        this.hashToken = hashToken;
        this.AdjustFlagsAndWidth(defineKeyword);
        this.defineKeyword = defineKeyword;
        this.AdjustFlagsAndWidth(name);
        this.name = name;
        this.AdjustFlagsAndWidth(endOfDirectiveToken);
        this.endOfDirectiveToken = endOfDirectiveToken;
        this.isActive = isActive;
    }


    internal DefineDirectiveTriviaSyntax(SyntaxKind kind, SyntaxToken hashToken, SyntaxToken defineKeyword, SyntaxToken name, SyntaxToken endOfDirectiveToken, bool isActive)
        : base(kind)
    {
        this.SlotCount = 4;
        this.AdjustFlagsAndWidth(hashToken);
        this.hashToken = hashToken;
        this.AdjustFlagsAndWidth(defineKeyword);
        this.defineKeyword = defineKeyword;
        this.AdjustFlagsAndWidth(name);
        this.name = name;
        this.AdjustFlagsAndWidth(endOfDirectiveToken);
        this.endOfDirectiveToken = endOfDirectiveToken;
        this.isActive = isActive;
    }

    public override SyntaxToken HashToken => this.hashToken;
    public SyntaxToken DefineKeyword => this.defineKeyword;
    public SyntaxToken Name => this.name;
    public override SyntaxToken EndOfDirectiveToken => this.endOfDirectiveToken;
    public override bool IsActive => this.isActive;

    internal override GreenNode? GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.hashToken;
            case 1: return this.defineKeyword;
            case 2: return this.name;
            case 3: return this.endOfDirectiveToken;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new CSharp.Syntax.DefineDirectiveTriviaSyntax(this, parent, position);

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor) => visitor.VisitDefineDirectiveTrivia(this);

    public override void Accept(CSharpSyntaxVisitor visitor) => visitor.VisitDefineDirectiveTrivia(this);

    public DefineDirectiveTriviaSyntax Update(SyntaxToken hashToken, SyntaxToken defineKeyword, SyntaxToken name, SyntaxToken endOfDirectiveToken, bool isActive)
    {
        if (hashToken != this.HashToken || defineKeyword != this.DefineKeyword || name != this.Name || endOfDirectiveToken != this.EndOfDirectiveToken)
        {
            var newNode = SyntaxFactory.DefineDirectiveTrivia(hashToken, defineKeyword, name, endOfDirectiveToken, isActive);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
        => new DefineDirectiveTriviaSyntax(this.Kind, this.hashToken, this.defineKeyword, this.name, this.endOfDirectiveToken, this.isActive, diagnostics, GetAnnotations());

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
        => new DefineDirectiveTriviaSyntax(this.Kind, this.hashToken, this.defineKeyword, this.name, this.endOfDirectiveToken, this.isActive, GetDiagnostics(), annotations);

    internal DefineDirectiveTriviaSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 4;
      var hashToken = (SyntaxToken)reader.ReadValue();
      if (hashToken != null)
      {
         AdjustFlagsAndWidth(hashToken);
         this.hashToken = hashToken;
      }
      var defineKeyword = (SyntaxToken)reader.ReadValue();
      if (defineKeyword != null)
      {
         AdjustFlagsAndWidth(defineKeyword);
         this.defineKeyword = defineKeyword;
      }
      var name = (SyntaxToken)reader.ReadValue();
      if (name != null)
      {
         AdjustFlagsAndWidth(name);
         this.name = name;
      }
      var endOfDirectiveToken = (SyntaxToken)reader.ReadValue();
      if (endOfDirectiveToken != null)
      {
         AdjustFlagsAndWidth(endOfDirectiveToken);
         this.endOfDirectiveToken = endOfDirectiveToken;
      }
      this.isActive = (bool)reader.ReadBoolean();
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.hashToken);
      writer.WriteValue(this.defineKeyword);
      writer.WriteValue(this.name);
      writer.WriteValue(this.endOfDirectiveToken);
      writer.WriteBoolean(this.isActive);
    }

    static DefineDirectiveTriviaSyntax()
    {
       ObjectBinder.RegisterTypeReader(typeof(DefineDirectiveTriviaSyntax), r => new DefineDirectiveTriviaSyntax(r));
    }
  }

  internal sealed partial class UndefDirectiveTriviaSyntax : DirectiveTriviaSyntax
  {
    internal readonly SyntaxToken hashToken;
    internal readonly SyntaxToken undefKeyword;
    internal readonly SyntaxToken name;
    internal readonly SyntaxToken endOfDirectiveToken;
    internal readonly bool isActive;

    internal UndefDirectiveTriviaSyntax(SyntaxKind kind, SyntaxToken hashToken, SyntaxToken undefKeyword, SyntaxToken name, SyntaxToken endOfDirectiveToken, bool isActive, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 4;
        this.AdjustFlagsAndWidth(hashToken);
        this.hashToken = hashToken;
        this.AdjustFlagsAndWidth(undefKeyword);
        this.undefKeyword = undefKeyword;
        this.AdjustFlagsAndWidth(name);
        this.name = name;
        this.AdjustFlagsAndWidth(endOfDirectiveToken);
        this.endOfDirectiveToken = endOfDirectiveToken;
        this.isActive = isActive;
    }


    internal UndefDirectiveTriviaSyntax(SyntaxKind kind, SyntaxToken hashToken, SyntaxToken undefKeyword, SyntaxToken name, SyntaxToken endOfDirectiveToken, bool isActive, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 4;
        this.AdjustFlagsAndWidth(hashToken);
        this.hashToken = hashToken;
        this.AdjustFlagsAndWidth(undefKeyword);
        this.undefKeyword = undefKeyword;
        this.AdjustFlagsAndWidth(name);
        this.name = name;
        this.AdjustFlagsAndWidth(endOfDirectiveToken);
        this.endOfDirectiveToken = endOfDirectiveToken;
        this.isActive = isActive;
    }


    internal UndefDirectiveTriviaSyntax(SyntaxKind kind, SyntaxToken hashToken, SyntaxToken undefKeyword, SyntaxToken name, SyntaxToken endOfDirectiveToken, bool isActive)
        : base(kind)
    {
        this.SlotCount = 4;
        this.AdjustFlagsAndWidth(hashToken);
        this.hashToken = hashToken;
        this.AdjustFlagsAndWidth(undefKeyword);
        this.undefKeyword = undefKeyword;
        this.AdjustFlagsAndWidth(name);
        this.name = name;
        this.AdjustFlagsAndWidth(endOfDirectiveToken);
        this.endOfDirectiveToken = endOfDirectiveToken;
        this.isActive = isActive;
    }

    public override SyntaxToken HashToken => this.hashToken;
    public SyntaxToken UndefKeyword => this.undefKeyword;
    public SyntaxToken Name => this.name;
    public override SyntaxToken EndOfDirectiveToken => this.endOfDirectiveToken;
    public override bool IsActive => this.isActive;

    internal override GreenNode? GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.hashToken;
            case 1: return this.undefKeyword;
            case 2: return this.name;
            case 3: return this.endOfDirectiveToken;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new CSharp.Syntax.UndefDirectiveTriviaSyntax(this, parent, position);

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor) => visitor.VisitUndefDirectiveTrivia(this);

    public override void Accept(CSharpSyntaxVisitor visitor) => visitor.VisitUndefDirectiveTrivia(this);

    public UndefDirectiveTriviaSyntax Update(SyntaxToken hashToken, SyntaxToken undefKeyword, SyntaxToken name, SyntaxToken endOfDirectiveToken, bool isActive)
    {
        if (hashToken != this.HashToken || undefKeyword != this.UndefKeyword || name != this.Name || endOfDirectiveToken != this.EndOfDirectiveToken)
        {
            var newNode = SyntaxFactory.UndefDirectiveTrivia(hashToken, undefKeyword, name, endOfDirectiveToken, isActive);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
        => new UndefDirectiveTriviaSyntax(this.Kind, this.hashToken, this.undefKeyword, this.name, this.endOfDirectiveToken, this.isActive, diagnostics, GetAnnotations());

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
        => new UndefDirectiveTriviaSyntax(this.Kind, this.hashToken, this.undefKeyword, this.name, this.endOfDirectiveToken, this.isActive, GetDiagnostics(), annotations);

    internal UndefDirectiveTriviaSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 4;
      var hashToken = (SyntaxToken)reader.ReadValue();
      if (hashToken != null)
      {
         AdjustFlagsAndWidth(hashToken);
         this.hashToken = hashToken;
      }
      var undefKeyword = (SyntaxToken)reader.ReadValue();
      if (undefKeyword != null)
      {
         AdjustFlagsAndWidth(undefKeyword);
         this.undefKeyword = undefKeyword;
      }
      var name = (SyntaxToken)reader.ReadValue();
      if (name != null)
      {
         AdjustFlagsAndWidth(name);
         this.name = name;
      }
      var endOfDirectiveToken = (SyntaxToken)reader.ReadValue();
      if (endOfDirectiveToken != null)
      {
         AdjustFlagsAndWidth(endOfDirectiveToken);
         this.endOfDirectiveToken = endOfDirectiveToken;
      }
      this.isActive = (bool)reader.ReadBoolean();
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.hashToken);
      writer.WriteValue(this.undefKeyword);
      writer.WriteValue(this.name);
      writer.WriteValue(this.endOfDirectiveToken);
      writer.WriteBoolean(this.isActive);
    }

    static UndefDirectiveTriviaSyntax()
    {
       ObjectBinder.RegisterTypeReader(typeof(UndefDirectiveTriviaSyntax), r => new UndefDirectiveTriviaSyntax(r));
    }
  }

  internal sealed partial class LineDirectiveTriviaSyntax : DirectiveTriviaSyntax
  {
    internal readonly SyntaxToken hashToken;
    internal readonly SyntaxToken lineKeyword;
    internal readonly SyntaxToken line;
    internal readonly SyntaxToken? file;
    internal readonly SyntaxToken endOfDirectiveToken;
    internal readonly bool isActive;

    internal LineDirectiveTriviaSyntax(SyntaxKind kind, SyntaxToken hashToken, SyntaxToken lineKeyword, SyntaxToken line, SyntaxToken? file, SyntaxToken endOfDirectiveToken, bool isActive, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 5;
        this.AdjustFlagsAndWidth(hashToken);
        this.hashToken = hashToken;
        this.AdjustFlagsAndWidth(lineKeyword);
        this.lineKeyword = lineKeyword;
        this.AdjustFlagsAndWidth(line);
        this.line = line;
        if (file != null)
        {
            this.AdjustFlagsAndWidth(file);
            this.file = file;
        }
        this.AdjustFlagsAndWidth(endOfDirectiveToken);
        this.endOfDirectiveToken = endOfDirectiveToken;
        this.isActive = isActive;
    }


    internal LineDirectiveTriviaSyntax(SyntaxKind kind, SyntaxToken hashToken, SyntaxToken lineKeyword, SyntaxToken line, SyntaxToken? file, SyntaxToken endOfDirectiveToken, bool isActive, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 5;
        this.AdjustFlagsAndWidth(hashToken);
        this.hashToken = hashToken;
        this.AdjustFlagsAndWidth(lineKeyword);
        this.lineKeyword = lineKeyword;
        this.AdjustFlagsAndWidth(line);
        this.line = line;
        if (file != null)
        {
            this.AdjustFlagsAndWidth(file);
            this.file = file;
        }
        this.AdjustFlagsAndWidth(endOfDirectiveToken);
        this.endOfDirectiveToken = endOfDirectiveToken;
        this.isActive = isActive;
    }


    internal LineDirectiveTriviaSyntax(SyntaxKind kind, SyntaxToken hashToken, SyntaxToken lineKeyword, SyntaxToken line, SyntaxToken? file, SyntaxToken endOfDirectiveToken, bool isActive)
        : base(kind)
    {
        this.SlotCount = 5;
        this.AdjustFlagsAndWidth(hashToken);
        this.hashToken = hashToken;
        this.AdjustFlagsAndWidth(lineKeyword);
        this.lineKeyword = lineKeyword;
        this.AdjustFlagsAndWidth(line);
        this.line = line;
        if (file != null)
        {
            this.AdjustFlagsAndWidth(file);
            this.file = file;
        }
        this.AdjustFlagsAndWidth(endOfDirectiveToken);
        this.endOfDirectiveToken = endOfDirectiveToken;
        this.isActive = isActive;
    }

    public override SyntaxToken HashToken => this.hashToken;
    public SyntaxToken LineKeyword => this.lineKeyword;
    public SyntaxToken Line => this.line;
    public SyntaxToken? File => this.file;
    public override SyntaxToken EndOfDirectiveToken => this.endOfDirectiveToken;
    public override bool IsActive => this.isActive;

    internal override GreenNode? GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.hashToken;
            case 1: return this.lineKeyword;
            case 2: return this.line;
            case 3: return this.file;
            case 4: return this.endOfDirectiveToken;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new CSharp.Syntax.LineDirectiveTriviaSyntax(this, parent, position);

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor) => visitor.VisitLineDirectiveTrivia(this);

    public override void Accept(CSharpSyntaxVisitor visitor) => visitor.VisitLineDirectiveTrivia(this);

    public LineDirectiveTriviaSyntax Update(SyntaxToken hashToken, SyntaxToken lineKeyword, SyntaxToken line, SyntaxToken file, SyntaxToken endOfDirectiveToken, bool isActive)
    {
        if (hashToken != this.HashToken || lineKeyword != this.LineKeyword || line != this.Line || file != this.File || endOfDirectiveToken != this.EndOfDirectiveToken)
        {
            var newNode = SyntaxFactory.LineDirectiveTrivia(hashToken, lineKeyword, line, file, endOfDirectiveToken, isActive);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
        => new LineDirectiveTriviaSyntax(this.Kind, this.hashToken, this.lineKeyword, this.line, this.file, this.endOfDirectiveToken, this.isActive, diagnostics, GetAnnotations());

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
        => new LineDirectiveTriviaSyntax(this.Kind, this.hashToken, this.lineKeyword, this.line, this.file, this.endOfDirectiveToken, this.isActive, GetDiagnostics(), annotations);

    internal LineDirectiveTriviaSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 5;
      var hashToken = (SyntaxToken)reader.ReadValue();
      if (hashToken != null)
      {
         AdjustFlagsAndWidth(hashToken);
         this.hashToken = hashToken;
      }
      var lineKeyword = (SyntaxToken)reader.ReadValue();
      if (lineKeyword != null)
      {
         AdjustFlagsAndWidth(lineKeyword);
         this.lineKeyword = lineKeyword;
      }
      var line = (SyntaxToken)reader.ReadValue();
      if (line != null)
      {
         AdjustFlagsAndWidth(line);
         this.line = line;
      }
      var file = (SyntaxToken?)reader.ReadValue();
      if (file != null)
      {
         AdjustFlagsAndWidth(file);
         this.file = file;
      }
      var endOfDirectiveToken = (SyntaxToken)reader.ReadValue();
      if (endOfDirectiveToken != null)
      {
         AdjustFlagsAndWidth(endOfDirectiveToken);
         this.endOfDirectiveToken = endOfDirectiveToken;
      }
      this.isActive = (bool)reader.ReadBoolean();
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.hashToken);
      writer.WriteValue(this.lineKeyword);
      writer.WriteValue(this.line);
      writer.WriteValue(this.file);
      writer.WriteValue(this.endOfDirectiveToken);
      writer.WriteBoolean(this.isActive);
    }

    static LineDirectiveTriviaSyntax()
    {
       ObjectBinder.RegisterTypeReader(typeof(LineDirectiveTriviaSyntax), r => new LineDirectiveTriviaSyntax(r));
    }
  }

  internal sealed partial class PragmaWarningDirectiveTriviaSyntax : DirectiveTriviaSyntax
  {
    internal readonly SyntaxToken hashToken;
    internal readonly SyntaxToken pragmaKeyword;
    internal readonly SyntaxToken warningKeyword;
    internal readonly SyntaxToken disableOrRestoreKeyword;
    internal readonly GreenNode? errorCodes;
    internal readonly SyntaxToken endOfDirectiveToken;
    internal readonly bool isActive;

    internal PragmaWarningDirectiveTriviaSyntax(SyntaxKind kind, SyntaxToken hashToken, SyntaxToken pragmaKeyword, SyntaxToken warningKeyword, SyntaxToken disableOrRestoreKeyword, GreenNode? errorCodes, SyntaxToken endOfDirectiveToken, bool isActive, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 6;
        this.AdjustFlagsAndWidth(hashToken);
        this.hashToken = hashToken;
        this.AdjustFlagsAndWidth(pragmaKeyword);
        this.pragmaKeyword = pragmaKeyword;
        this.AdjustFlagsAndWidth(warningKeyword);
        this.warningKeyword = warningKeyword;
        this.AdjustFlagsAndWidth(disableOrRestoreKeyword);
        this.disableOrRestoreKeyword = disableOrRestoreKeyword;
        if (errorCodes != null)
        {
            this.AdjustFlagsAndWidth(errorCodes);
            this.errorCodes = errorCodes;
        }
        this.AdjustFlagsAndWidth(endOfDirectiveToken);
        this.endOfDirectiveToken = endOfDirectiveToken;
        this.isActive = isActive;
    }


    internal PragmaWarningDirectiveTriviaSyntax(SyntaxKind kind, SyntaxToken hashToken, SyntaxToken pragmaKeyword, SyntaxToken warningKeyword, SyntaxToken disableOrRestoreKeyword, GreenNode? errorCodes, SyntaxToken endOfDirectiveToken, bool isActive, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 6;
        this.AdjustFlagsAndWidth(hashToken);
        this.hashToken = hashToken;
        this.AdjustFlagsAndWidth(pragmaKeyword);
        this.pragmaKeyword = pragmaKeyword;
        this.AdjustFlagsAndWidth(warningKeyword);
        this.warningKeyword = warningKeyword;
        this.AdjustFlagsAndWidth(disableOrRestoreKeyword);
        this.disableOrRestoreKeyword = disableOrRestoreKeyword;
        if (errorCodes != null)
        {
            this.AdjustFlagsAndWidth(errorCodes);
            this.errorCodes = errorCodes;
        }
        this.AdjustFlagsAndWidth(endOfDirectiveToken);
        this.endOfDirectiveToken = endOfDirectiveToken;
        this.isActive = isActive;
    }


    internal PragmaWarningDirectiveTriviaSyntax(SyntaxKind kind, SyntaxToken hashToken, SyntaxToken pragmaKeyword, SyntaxToken warningKeyword, SyntaxToken disableOrRestoreKeyword, GreenNode? errorCodes, SyntaxToken endOfDirectiveToken, bool isActive)
        : base(kind)
    {
        this.SlotCount = 6;
        this.AdjustFlagsAndWidth(hashToken);
        this.hashToken = hashToken;
        this.AdjustFlagsAndWidth(pragmaKeyword);
        this.pragmaKeyword = pragmaKeyword;
        this.AdjustFlagsAndWidth(warningKeyword);
        this.warningKeyword = warningKeyword;
        this.AdjustFlagsAndWidth(disableOrRestoreKeyword);
        this.disableOrRestoreKeyword = disableOrRestoreKeyword;
        if (errorCodes != null)
        {
            this.AdjustFlagsAndWidth(errorCodes);
            this.errorCodes = errorCodes;
        }
        this.AdjustFlagsAndWidth(endOfDirectiveToken);
        this.endOfDirectiveToken = endOfDirectiveToken;
        this.isActive = isActive;
    }

    public override SyntaxToken HashToken => this.hashToken;
    public SyntaxToken PragmaKeyword => this.pragmaKeyword;
    public SyntaxToken WarningKeyword => this.warningKeyword;
    public SyntaxToken DisableOrRestoreKeyword => this.disableOrRestoreKeyword;
    public Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<ExpressionSyntax> ErrorCodes => new Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<ExpressionSyntax>(new Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<CSharpSyntaxNode>(this.errorCodes));
    public override SyntaxToken EndOfDirectiveToken => this.endOfDirectiveToken;
    public override bool IsActive => this.isActive;

    internal override GreenNode? GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.hashToken;
            case 1: return this.pragmaKeyword;
            case 2: return this.warningKeyword;
            case 3: return this.disableOrRestoreKeyword;
            case 4: return this.errorCodes;
            case 5: return this.endOfDirectiveToken;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new CSharp.Syntax.PragmaWarningDirectiveTriviaSyntax(this, parent, position);

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor) => visitor.VisitPragmaWarningDirectiveTrivia(this);

    public override void Accept(CSharpSyntaxVisitor visitor) => visitor.VisitPragmaWarningDirectiveTrivia(this);

    public PragmaWarningDirectiveTriviaSyntax Update(SyntaxToken hashToken, SyntaxToken pragmaKeyword, SyntaxToken warningKeyword, SyntaxToken disableOrRestoreKeyword, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<ExpressionSyntax> errorCodes, SyntaxToken endOfDirectiveToken, bool isActive)
    {
        if (hashToken != this.HashToken || pragmaKeyword != this.PragmaKeyword || warningKeyword != this.WarningKeyword || disableOrRestoreKeyword != this.DisableOrRestoreKeyword || errorCodes != this.ErrorCodes || endOfDirectiveToken != this.EndOfDirectiveToken)
        {
            var newNode = SyntaxFactory.PragmaWarningDirectiveTrivia(hashToken, pragmaKeyword, warningKeyword, disableOrRestoreKeyword, errorCodes, endOfDirectiveToken, isActive);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
        => new PragmaWarningDirectiveTriviaSyntax(this.Kind, this.hashToken, this.pragmaKeyword, this.warningKeyword, this.disableOrRestoreKeyword, this.errorCodes, this.endOfDirectiveToken, this.isActive, diagnostics, GetAnnotations());

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
        => new PragmaWarningDirectiveTriviaSyntax(this.Kind, this.hashToken, this.pragmaKeyword, this.warningKeyword, this.disableOrRestoreKeyword, this.errorCodes, this.endOfDirectiveToken, this.isActive, GetDiagnostics(), annotations);

    internal PragmaWarningDirectiveTriviaSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 6;
      var hashToken = (SyntaxToken)reader.ReadValue();
      if (hashToken != null)
      {
         AdjustFlagsAndWidth(hashToken);
         this.hashToken = hashToken;
      }
      var pragmaKeyword = (SyntaxToken)reader.ReadValue();
      if (pragmaKeyword != null)
      {
         AdjustFlagsAndWidth(pragmaKeyword);
         this.pragmaKeyword = pragmaKeyword;
      }
      var warningKeyword = (SyntaxToken)reader.ReadValue();
      if (warningKeyword != null)
      {
         AdjustFlagsAndWidth(warningKeyword);
         this.warningKeyword = warningKeyword;
      }
      var disableOrRestoreKeyword = (SyntaxToken)reader.ReadValue();
      if (disableOrRestoreKeyword != null)
      {
         AdjustFlagsAndWidth(disableOrRestoreKeyword);
         this.disableOrRestoreKeyword = disableOrRestoreKeyword;
      }
      var errorCodes = (GreenNode?)reader.ReadValue();
      if (errorCodes != null)
      {
         AdjustFlagsAndWidth(errorCodes);
         this.errorCodes = errorCodes;
      }
      var endOfDirectiveToken = (SyntaxToken)reader.ReadValue();
      if (endOfDirectiveToken != null)
      {
         AdjustFlagsAndWidth(endOfDirectiveToken);
         this.endOfDirectiveToken = endOfDirectiveToken;
      }
      this.isActive = (bool)reader.ReadBoolean();
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.hashToken);
      writer.WriteValue(this.pragmaKeyword);
      writer.WriteValue(this.warningKeyword);
      writer.WriteValue(this.disableOrRestoreKeyword);
      writer.WriteValue(this.errorCodes);
      writer.WriteValue(this.endOfDirectiveToken);
      writer.WriteBoolean(this.isActive);
    }

    static PragmaWarningDirectiveTriviaSyntax()
    {
       ObjectBinder.RegisterTypeReader(typeof(PragmaWarningDirectiveTriviaSyntax), r => new PragmaWarningDirectiveTriviaSyntax(r));
    }
  }

  internal sealed partial class PragmaChecksumDirectiveTriviaSyntax : DirectiveTriviaSyntax
  {
    internal readonly SyntaxToken hashToken;
    internal readonly SyntaxToken pragmaKeyword;
    internal readonly SyntaxToken checksumKeyword;
    internal readonly SyntaxToken file;
    internal readonly SyntaxToken guid;
    internal readonly SyntaxToken bytes;
    internal readonly SyntaxToken endOfDirectiveToken;
    internal readonly bool isActive;

    internal PragmaChecksumDirectiveTriviaSyntax(SyntaxKind kind, SyntaxToken hashToken, SyntaxToken pragmaKeyword, SyntaxToken checksumKeyword, SyntaxToken file, SyntaxToken guid, SyntaxToken bytes, SyntaxToken endOfDirectiveToken, bool isActive, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 7;
        this.AdjustFlagsAndWidth(hashToken);
        this.hashToken = hashToken;
        this.AdjustFlagsAndWidth(pragmaKeyword);
        this.pragmaKeyword = pragmaKeyword;
        this.AdjustFlagsAndWidth(checksumKeyword);
        this.checksumKeyword = checksumKeyword;
        this.AdjustFlagsAndWidth(file);
        this.file = file;
        this.AdjustFlagsAndWidth(guid);
        this.guid = guid;
        this.AdjustFlagsAndWidth(bytes);
        this.bytes = bytes;
        this.AdjustFlagsAndWidth(endOfDirectiveToken);
        this.endOfDirectiveToken = endOfDirectiveToken;
        this.isActive = isActive;
    }


    internal PragmaChecksumDirectiveTriviaSyntax(SyntaxKind kind, SyntaxToken hashToken, SyntaxToken pragmaKeyword, SyntaxToken checksumKeyword, SyntaxToken file, SyntaxToken guid, SyntaxToken bytes, SyntaxToken endOfDirectiveToken, bool isActive, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 7;
        this.AdjustFlagsAndWidth(hashToken);
        this.hashToken = hashToken;
        this.AdjustFlagsAndWidth(pragmaKeyword);
        this.pragmaKeyword = pragmaKeyword;
        this.AdjustFlagsAndWidth(checksumKeyword);
        this.checksumKeyword = checksumKeyword;
        this.AdjustFlagsAndWidth(file);
        this.file = file;
        this.AdjustFlagsAndWidth(guid);
        this.guid = guid;
        this.AdjustFlagsAndWidth(bytes);
        this.bytes = bytes;
        this.AdjustFlagsAndWidth(endOfDirectiveToken);
        this.endOfDirectiveToken = endOfDirectiveToken;
        this.isActive = isActive;
    }


    internal PragmaChecksumDirectiveTriviaSyntax(SyntaxKind kind, SyntaxToken hashToken, SyntaxToken pragmaKeyword, SyntaxToken checksumKeyword, SyntaxToken file, SyntaxToken guid, SyntaxToken bytes, SyntaxToken endOfDirectiveToken, bool isActive)
        : base(kind)
    {
        this.SlotCount = 7;
        this.AdjustFlagsAndWidth(hashToken);
        this.hashToken = hashToken;
        this.AdjustFlagsAndWidth(pragmaKeyword);
        this.pragmaKeyword = pragmaKeyword;
        this.AdjustFlagsAndWidth(checksumKeyword);
        this.checksumKeyword = checksumKeyword;
        this.AdjustFlagsAndWidth(file);
        this.file = file;
        this.AdjustFlagsAndWidth(guid);
        this.guid = guid;
        this.AdjustFlagsAndWidth(bytes);
        this.bytes = bytes;
        this.AdjustFlagsAndWidth(endOfDirectiveToken);
        this.endOfDirectiveToken = endOfDirectiveToken;
        this.isActive = isActive;
    }

    public override SyntaxToken HashToken => this.hashToken;
    public SyntaxToken PragmaKeyword => this.pragmaKeyword;
    public SyntaxToken ChecksumKeyword => this.checksumKeyword;
    public SyntaxToken File => this.file;
    public SyntaxToken Guid => this.guid;
    public SyntaxToken Bytes => this.bytes;
    public override SyntaxToken EndOfDirectiveToken => this.endOfDirectiveToken;
    public override bool IsActive => this.isActive;

    internal override GreenNode? GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.hashToken;
            case 1: return this.pragmaKeyword;
            case 2: return this.checksumKeyword;
            case 3: return this.file;
            case 4: return this.guid;
            case 5: return this.bytes;
            case 6: return this.endOfDirectiveToken;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new CSharp.Syntax.PragmaChecksumDirectiveTriviaSyntax(this, parent, position);

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor) => visitor.VisitPragmaChecksumDirectiveTrivia(this);

    public override void Accept(CSharpSyntaxVisitor visitor) => visitor.VisitPragmaChecksumDirectiveTrivia(this);

    public PragmaChecksumDirectiveTriviaSyntax Update(SyntaxToken hashToken, SyntaxToken pragmaKeyword, SyntaxToken checksumKeyword, SyntaxToken file, SyntaxToken guid, SyntaxToken bytes, SyntaxToken endOfDirectiveToken, bool isActive)
    {
        if (hashToken != this.HashToken || pragmaKeyword != this.PragmaKeyword || checksumKeyword != this.ChecksumKeyword || file != this.File || guid != this.Guid || bytes != this.Bytes || endOfDirectiveToken != this.EndOfDirectiveToken)
        {
            var newNode = SyntaxFactory.PragmaChecksumDirectiveTrivia(hashToken, pragmaKeyword, checksumKeyword, file, guid, bytes, endOfDirectiveToken, isActive);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
        => new PragmaChecksumDirectiveTriviaSyntax(this.Kind, this.hashToken, this.pragmaKeyword, this.checksumKeyword, this.file, this.guid, this.bytes, this.endOfDirectiveToken, this.isActive, diagnostics, GetAnnotations());

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
        => new PragmaChecksumDirectiveTriviaSyntax(this.Kind, this.hashToken, this.pragmaKeyword, this.checksumKeyword, this.file, this.guid, this.bytes, this.endOfDirectiveToken, this.isActive, GetDiagnostics(), annotations);

    internal PragmaChecksumDirectiveTriviaSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 7;
      var hashToken = (SyntaxToken)reader.ReadValue();
      if (hashToken != null)
      {
         AdjustFlagsAndWidth(hashToken);
         this.hashToken = hashToken;
      }
      var pragmaKeyword = (SyntaxToken)reader.ReadValue();
      if (pragmaKeyword != null)
      {
         AdjustFlagsAndWidth(pragmaKeyword);
         this.pragmaKeyword = pragmaKeyword;
      }
      var checksumKeyword = (SyntaxToken)reader.ReadValue();
      if (checksumKeyword != null)
      {
         AdjustFlagsAndWidth(checksumKeyword);
         this.checksumKeyword = checksumKeyword;
      }
      var file = (SyntaxToken)reader.ReadValue();
      if (file != null)
      {
         AdjustFlagsAndWidth(file);
         this.file = file;
      }
      var guid = (SyntaxToken)reader.ReadValue();
      if (guid != null)
      {
         AdjustFlagsAndWidth(guid);
         this.guid = guid;
      }
      var bytes = (SyntaxToken)reader.ReadValue();
      if (bytes != null)
      {
         AdjustFlagsAndWidth(bytes);
         this.bytes = bytes;
      }
      var endOfDirectiveToken = (SyntaxToken)reader.ReadValue();
      if (endOfDirectiveToken != null)
      {
         AdjustFlagsAndWidth(endOfDirectiveToken);
         this.endOfDirectiveToken = endOfDirectiveToken;
      }
      this.isActive = (bool)reader.ReadBoolean();
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.hashToken);
      writer.WriteValue(this.pragmaKeyword);
      writer.WriteValue(this.checksumKeyword);
      writer.WriteValue(this.file);
      writer.WriteValue(this.guid);
      writer.WriteValue(this.bytes);
      writer.WriteValue(this.endOfDirectiveToken);
      writer.WriteBoolean(this.isActive);
    }

    static PragmaChecksumDirectiveTriviaSyntax()
    {
       ObjectBinder.RegisterTypeReader(typeof(PragmaChecksumDirectiveTriviaSyntax), r => new PragmaChecksumDirectiveTriviaSyntax(r));
    }
  }

  internal sealed partial class ReferenceDirectiveTriviaSyntax : DirectiveTriviaSyntax
  {
    internal readonly SyntaxToken hashToken;
    internal readonly SyntaxToken referenceKeyword;
    internal readonly SyntaxToken file;
    internal readonly SyntaxToken endOfDirectiveToken;
    internal readonly bool isActive;

    internal ReferenceDirectiveTriviaSyntax(SyntaxKind kind, SyntaxToken hashToken, SyntaxToken referenceKeyword, SyntaxToken file, SyntaxToken endOfDirectiveToken, bool isActive, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 4;
        this.AdjustFlagsAndWidth(hashToken);
        this.hashToken = hashToken;
        this.AdjustFlagsAndWidth(referenceKeyword);
        this.referenceKeyword = referenceKeyword;
        this.AdjustFlagsAndWidth(file);
        this.file = file;
        this.AdjustFlagsAndWidth(endOfDirectiveToken);
        this.endOfDirectiveToken = endOfDirectiveToken;
        this.isActive = isActive;
    }


    internal ReferenceDirectiveTriviaSyntax(SyntaxKind kind, SyntaxToken hashToken, SyntaxToken referenceKeyword, SyntaxToken file, SyntaxToken endOfDirectiveToken, bool isActive, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 4;
        this.AdjustFlagsAndWidth(hashToken);
        this.hashToken = hashToken;
        this.AdjustFlagsAndWidth(referenceKeyword);
        this.referenceKeyword = referenceKeyword;
        this.AdjustFlagsAndWidth(file);
        this.file = file;
        this.AdjustFlagsAndWidth(endOfDirectiveToken);
        this.endOfDirectiveToken = endOfDirectiveToken;
        this.isActive = isActive;
    }


    internal ReferenceDirectiveTriviaSyntax(SyntaxKind kind, SyntaxToken hashToken, SyntaxToken referenceKeyword, SyntaxToken file, SyntaxToken endOfDirectiveToken, bool isActive)
        : base(kind)
    {
        this.SlotCount = 4;
        this.AdjustFlagsAndWidth(hashToken);
        this.hashToken = hashToken;
        this.AdjustFlagsAndWidth(referenceKeyword);
        this.referenceKeyword = referenceKeyword;
        this.AdjustFlagsAndWidth(file);
        this.file = file;
        this.AdjustFlagsAndWidth(endOfDirectiveToken);
        this.endOfDirectiveToken = endOfDirectiveToken;
        this.isActive = isActive;
    }

    public override SyntaxToken HashToken => this.hashToken;
    public SyntaxToken ReferenceKeyword => this.referenceKeyword;
    public SyntaxToken File => this.file;
    public override SyntaxToken EndOfDirectiveToken => this.endOfDirectiveToken;
    public override bool IsActive => this.isActive;

    internal override GreenNode? GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.hashToken;
            case 1: return this.referenceKeyword;
            case 2: return this.file;
            case 3: return this.endOfDirectiveToken;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new CSharp.Syntax.ReferenceDirectiveTriviaSyntax(this, parent, position);

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor) => visitor.VisitReferenceDirectiveTrivia(this);

    public override void Accept(CSharpSyntaxVisitor visitor) => visitor.VisitReferenceDirectiveTrivia(this);

    public ReferenceDirectiveTriviaSyntax Update(SyntaxToken hashToken, SyntaxToken referenceKeyword, SyntaxToken file, SyntaxToken endOfDirectiveToken, bool isActive)
    {
        if (hashToken != this.HashToken || referenceKeyword != this.ReferenceKeyword || file != this.File || endOfDirectiveToken != this.EndOfDirectiveToken)
        {
            var newNode = SyntaxFactory.ReferenceDirectiveTrivia(hashToken, referenceKeyword, file, endOfDirectiveToken, isActive);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
        => new ReferenceDirectiveTriviaSyntax(this.Kind, this.hashToken, this.referenceKeyword, this.file, this.endOfDirectiveToken, this.isActive, diagnostics, GetAnnotations());

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
        => new ReferenceDirectiveTriviaSyntax(this.Kind, this.hashToken, this.referenceKeyword, this.file, this.endOfDirectiveToken, this.isActive, GetDiagnostics(), annotations);

    internal ReferenceDirectiveTriviaSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 4;
      var hashToken = (SyntaxToken)reader.ReadValue();
      if (hashToken != null)
      {
         AdjustFlagsAndWidth(hashToken);
         this.hashToken = hashToken;
      }
      var referenceKeyword = (SyntaxToken)reader.ReadValue();
      if (referenceKeyword != null)
      {
         AdjustFlagsAndWidth(referenceKeyword);
         this.referenceKeyword = referenceKeyword;
      }
      var file = (SyntaxToken)reader.ReadValue();
      if (file != null)
      {
         AdjustFlagsAndWidth(file);
         this.file = file;
      }
      var endOfDirectiveToken = (SyntaxToken)reader.ReadValue();
      if (endOfDirectiveToken != null)
      {
         AdjustFlagsAndWidth(endOfDirectiveToken);
         this.endOfDirectiveToken = endOfDirectiveToken;
      }
      this.isActive = (bool)reader.ReadBoolean();
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.hashToken);
      writer.WriteValue(this.referenceKeyword);
      writer.WriteValue(this.file);
      writer.WriteValue(this.endOfDirectiveToken);
      writer.WriteBoolean(this.isActive);
    }

    static ReferenceDirectiveTriviaSyntax()
    {
       ObjectBinder.RegisterTypeReader(typeof(ReferenceDirectiveTriviaSyntax), r => new ReferenceDirectiveTriviaSyntax(r));
    }
  }

  internal sealed partial class LoadDirectiveTriviaSyntax : DirectiveTriviaSyntax
  {
    internal readonly SyntaxToken hashToken;
    internal readonly SyntaxToken loadKeyword;
    internal readonly SyntaxToken file;
    internal readonly SyntaxToken endOfDirectiveToken;
    internal readonly bool isActive;

    internal LoadDirectiveTriviaSyntax(SyntaxKind kind, SyntaxToken hashToken, SyntaxToken loadKeyword, SyntaxToken file, SyntaxToken endOfDirectiveToken, bool isActive, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 4;
        this.AdjustFlagsAndWidth(hashToken);
        this.hashToken = hashToken;
        this.AdjustFlagsAndWidth(loadKeyword);
        this.loadKeyword = loadKeyword;
        this.AdjustFlagsAndWidth(file);
        this.file = file;
        this.AdjustFlagsAndWidth(endOfDirectiveToken);
        this.endOfDirectiveToken = endOfDirectiveToken;
        this.isActive = isActive;
    }


    internal LoadDirectiveTriviaSyntax(SyntaxKind kind, SyntaxToken hashToken, SyntaxToken loadKeyword, SyntaxToken file, SyntaxToken endOfDirectiveToken, bool isActive, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 4;
        this.AdjustFlagsAndWidth(hashToken);
        this.hashToken = hashToken;
        this.AdjustFlagsAndWidth(loadKeyword);
        this.loadKeyword = loadKeyword;
        this.AdjustFlagsAndWidth(file);
        this.file = file;
        this.AdjustFlagsAndWidth(endOfDirectiveToken);
        this.endOfDirectiveToken = endOfDirectiveToken;
        this.isActive = isActive;
    }


    internal LoadDirectiveTriviaSyntax(SyntaxKind kind, SyntaxToken hashToken, SyntaxToken loadKeyword, SyntaxToken file, SyntaxToken endOfDirectiveToken, bool isActive)
        : base(kind)
    {
        this.SlotCount = 4;
        this.AdjustFlagsAndWidth(hashToken);
        this.hashToken = hashToken;
        this.AdjustFlagsAndWidth(loadKeyword);
        this.loadKeyword = loadKeyword;
        this.AdjustFlagsAndWidth(file);
        this.file = file;
        this.AdjustFlagsAndWidth(endOfDirectiveToken);
        this.endOfDirectiveToken = endOfDirectiveToken;
        this.isActive = isActive;
    }

    public override SyntaxToken HashToken => this.hashToken;
    public SyntaxToken LoadKeyword => this.loadKeyword;
    public SyntaxToken File => this.file;
    public override SyntaxToken EndOfDirectiveToken => this.endOfDirectiveToken;
    public override bool IsActive => this.isActive;

    internal override GreenNode? GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.hashToken;
            case 1: return this.loadKeyword;
            case 2: return this.file;
            case 3: return this.endOfDirectiveToken;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new CSharp.Syntax.LoadDirectiveTriviaSyntax(this, parent, position);

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor) => visitor.VisitLoadDirectiveTrivia(this);

    public override void Accept(CSharpSyntaxVisitor visitor) => visitor.VisitLoadDirectiveTrivia(this);

    public LoadDirectiveTriviaSyntax Update(SyntaxToken hashToken, SyntaxToken loadKeyword, SyntaxToken file, SyntaxToken endOfDirectiveToken, bool isActive)
    {
        if (hashToken != this.HashToken || loadKeyword != this.LoadKeyword || file != this.File || endOfDirectiveToken != this.EndOfDirectiveToken)
        {
            var newNode = SyntaxFactory.LoadDirectiveTrivia(hashToken, loadKeyword, file, endOfDirectiveToken, isActive);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
        => new LoadDirectiveTriviaSyntax(this.Kind, this.hashToken, this.loadKeyword, this.file, this.endOfDirectiveToken, this.isActive, diagnostics, GetAnnotations());

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
        => new LoadDirectiveTriviaSyntax(this.Kind, this.hashToken, this.loadKeyword, this.file, this.endOfDirectiveToken, this.isActive, GetDiagnostics(), annotations);

    internal LoadDirectiveTriviaSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 4;
      var hashToken = (SyntaxToken)reader.ReadValue();
      if (hashToken != null)
      {
         AdjustFlagsAndWidth(hashToken);
         this.hashToken = hashToken;
      }
      var loadKeyword = (SyntaxToken)reader.ReadValue();
      if (loadKeyword != null)
      {
         AdjustFlagsAndWidth(loadKeyword);
         this.loadKeyword = loadKeyword;
      }
      var file = (SyntaxToken)reader.ReadValue();
      if (file != null)
      {
         AdjustFlagsAndWidth(file);
         this.file = file;
      }
      var endOfDirectiveToken = (SyntaxToken)reader.ReadValue();
      if (endOfDirectiveToken != null)
      {
         AdjustFlagsAndWidth(endOfDirectiveToken);
         this.endOfDirectiveToken = endOfDirectiveToken;
      }
      this.isActive = (bool)reader.ReadBoolean();
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.hashToken);
      writer.WriteValue(this.loadKeyword);
      writer.WriteValue(this.file);
      writer.WriteValue(this.endOfDirectiveToken);
      writer.WriteBoolean(this.isActive);
    }

    static LoadDirectiveTriviaSyntax()
    {
       ObjectBinder.RegisterTypeReader(typeof(LoadDirectiveTriviaSyntax), r => new LoadDirectiveTriviaSyntax(r));
    }
  }

  internal sealed partial class ShebangDirectiveTriviaSyntax : DirectiveTriviaSyntax
  {
    internal readonly SyntaxToken hashToken;
    internal readonly SyntaxToken exclamationToken;
    internal readonly SyntaxToken endOfDirectiveToken;
    internal readonly bool isActive;

    internal ShebangDirectiveTriviaSyntax(SyntaxKind kind, SyntaxToken hashToken, SyntaxToken exclamationToken, SyntaxToken endOfDirectiveToken, bool isActive, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 3;
        this.AdjustFlagsAndWidth(hashToken);
        this.hashToken = hashToken;
        this.AdjustFlagsAndWidth(exclamationToken);
        this.exclamationToken = exclamationToken;
        this.AdjustFlagsAndWidth(endOfDirectiveToken);
        this.endOfDirectiveToken = endOfDirectiveToken;
        this.isActive = isActive;
    }


    internal ShebangDirectiveTriviaSyntax(SyntaxKind kind, SyntaxToken hashToken, SyntaxToken exclamationToken, SyntaxToken endOfDirectiveToken, bool isActive, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 3;
        this.AdjustFlagsAndWidth(hashToken);
        this.hashToken = hashToken;
        this.AdjustFlagsAndWidth(exclamationToken);
        this.exclamationToken = exclamationToken;
        this.AdjustFlagsAndWidth(endOfDirectiveToken);
        this.endOfDirectiveToken = endOfDirectiveToken;
        this.isActive = isActive;
    }


    internal ShebangDirectiveTriviaSyntax(SyntaxKind kind, SyntaxToken hashToken, SyntaxToken exclamationToken, SyntaxToken endOfDirectiveToken, bool isActive)
        : base(kind)
    {
        this.SlotCount = 3;
        this.AdjustFlagsAndWidth(hashToken);
        this.hashToken = hashToken;
        this.AdjustFlagsAndWidth(exclamationToken);
        this.exclamationToken = exclamationToken;
        this.AdjustFlagsAndWidth(endOfDirectiveToken);
        this.endOfDirectiveToken = endOfDirectiveToken;
        this.isActive = isActive;
    }

    public override SyntaxToken HashToken => this.hashToken;
    public SyntaxToken ExclamationToken => this.exclamationToken;
    public override SyntaxToken EndOfDirectiveToken => this.endOfDirectiveToken;
    public override bool IsActive => this.isActive;

    internal override GreenNode? GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.hashToken;
            case 1: return this.exclamationToken;
            case 2: return this.endOfDirectiveToken;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new CSharp.Syntax.ShebangDirectiveTriviaSyntax(this, parent, position);

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor) => visitor.VisitShebangDirectiveTrivia(this);

    public override void Accept(CSharpSyntaxVisitor visitor) => visitor.VisitShebangDirectiveTrivia(this);

    public ShebangDirectiveTriviaSyntax Update(SyntaxToken hashToken, SyntaxToken exclamationToken, SyntaxToken endOfDirectiveToken, bool isActive)
    {
        if (hashToken != this.HashToken || exclamationToken != this.ExclamationToken || endOfDirectiveToken != this.EndOfDirectiveToken)
        {
            var newNode = SyntaxFactory.ShebangDirectiveTrivia(hashToken, exclamationToken, endOfDirectiveToken, isActive);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
        => new ShebangDirectiveTriviaSyntax(this.Kind, this.hashToken, this.exclamationToken, this.endOfDirectiveToken, this.isActive, diagnostics, GetAnnotations());

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
        => new ShebangDirectiveTriviaSyntax(this.Kind, this.hashToken, this.exclamationToken, this.endOfDirectiveToken, this.isActive, GetDiagnostics(), annotations);

    internal ShebangDirectiveTriviaSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 3;
      var hashToken = (SyntaxToken)reader.ReadValue();
      if (hashToken != null)
      {
         AdjustFlagsAndWidth(hashToken);
         this.hashToken = hashToken;
      }
      var exclamationToken = (SyntaxToken)reader.ReadValue();
      if (exclamationToken != null)
      {
         AdjustFlagsAndWidth(exclamationToken);
         this.exclamationToken = exclamationToken;
      }
      var endOfDirectiveToken = (SyntaxToken)reader.ReadValue();
      if (endOfDirectiveToken != null)
      {
         AdjustFlagsAndWidth(endOfDirectiveToken);
         this.endOfDirectiveToken = endOfDirectiveToken;
      }
      this.isActive = (bool)reader.ReadBoolean();
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.hashToken);
      writer.WriteValue(this.exclamationToken);
      writer.WriteValue(this.endOfDirectiveToken);
      writer.WriteBoolean(this.isActive);
    }

    static ShebangDirectiveTriviaSyntax()
    {
       ObjectBinder.RegisterTypeReader(typeof(ShebangDirectiveTriviaSyntax), r => new ShebangDirectiveTriviaSyntax(r));
    }
  }

  internal sealed partial class NullableDirectiveTriviaSyntax : DirectiveTriviaSyntax
  {
    internal readonly SyntaxToken hashToken;
    internal readonly SyntaxToken nullableKeyword;
    internal readonly SyntaxToken settingToken;
    internal readonly SyntaxToken? targetToken;
    internal readonly SyntaxToken endOfDirectiveToken;
    internal readonly bool isActive;

    internal NullableDirectiveTriviaSyntax(SyntaxKind kind, SyntaxToken hashToken, SyntaxToken nullableKeyword, SyntaxToken settingToken, SyntaxToken? targetToken, SyntaxToken endOfDirectiveToken, bool isActive, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 5;
        this.AdjustFlagsAndWidth(hashToken);
        this.hashToken = hashToken;
        this.AdjustFlagsAndWidth(nullableKeyword);
        this.nullableKeyword = nullableKeyword;
        this.AdjustFlagsAndWidth(settingToken);
        this.settingToken = settingToken;
        if (targetToken != null)
        {
            this.AdjustFlagsAndWidth(targetToken);
            this.targetToken = targetToken;
        }
        this.AdjustFlagsAndWidth(endOfDirectiveToken);
        this.endOfDirectiveToken = endOfDirectiveToken;
        this.isActive = isActive;
    }


    internal NullableDirectiveTriviaSyntax(SyntaxKind kind, SyntaxToken hashToken, SyntaxToken nullableKeyword, SyntaxToken settingToken, SyntaxToken? targetToken, SyntaxToken endOfDirectiveToken, bool isActive, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 5;
        this.AdjustFlagsAndWidth(hashToken);
        this.hashToken = hashToken;
        this.AdjustFlagsAndWidth(nullableKeyword);
        this.nullableKeyword = nullableKeyword;
        this.AdjustFlagsAndWidth(settingToken);
        this.settingToken = settingToken;
        if (targetToken != null)
        {
            this.AdjustFlagsAndWidth(targetToken);
            this.targetToken = targetToken;
        }
        this.AdjustFlagsAndWidth(endOfDirectiveToken);
        this.endOfDirectiveToken = endOfDirectiveToken;
        this.isActive = isActive;
    }


    internal NullableDirectiveTriviaSyntax(SyntaxKind kind, SyntaxToken hashToken, SyntaxToken nullableKeyword, SyntaxToken settingToken, SyntaxToken? targetToken, SyntaxToken endOfDirectiveToken, bool isActive)
        : base(kind)
    {
        this.SlotCount = 5;
        this.AdjustFlagsAndWidth(hashToken);
        this.hashToken = hashToken;
        this.AdjustFlagsAndWidth(nullableKeyword);
        this.nullableKeyword = nullableKeyword;
        this.AdjustFlagsAndWidth(settingToken);
        this.settingToken = settingToken;
        if (targetToken != null)
        {
            this.AdjustFlagsAndWidth(targetToken);
            this.targetToken = targetToken;
        }
        this.AdjustFlagsAndWidth(endOfDirectiveToken);
        this.endOfDirectiveToken = endOfDirectiveToken;
        this.isActive = isActive;
    }

    public override SyntaxToken HashToken => this.hashToken;
    public SyntaxToken NullableKeyword => this.nullableKeyword;
    public SyntaxToken SettingToken => this.settingToken;
    public SyntaxToken? TargetToken => this.targetToken;
    public override SyntaxToken EndOfDirectiveToken => this.endOfDirectiveToken;
    public override bool IsActive => this.isActive;

    internal override GreenNode? GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.hashToken;
            case 1: return this.nullableKeyword;
            case 2: return this.settingToken;
            case 3: return this.targetToken;
            case 4: return this.endOfDirectiveToken;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new CSharp.Syntax.NullableDirectiveTriviaSyntax(this, parent, position);

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor) => visitor.VisitNullableDirectiveTrivia(this);

    public override void Accept(CSharpSyntaxVisitor visitor) => visitor.VisitNullableDirectiveTrivia(this);

    public NullableDirectiveTriviaSyntax Update(SyntaxToken hashToken, SyntaxToken nullableKeyword, SyntaxToken settingToken, SyntaxToken targetToken, SyntaxToken endOfDirectiveToken, bool isActive)
    {
        if (hashToken != this.HashToken || nullableKeyword != this.NullableKeyword || settingToken != this.SettingToken || targetToken != this.TargetToken || endOfDirectiveToken != this.EndOfDirectiveToken)
        {
            var newNode = SyntaxFactory.NullableDirectiveTrivia(hashToken, nullableKeyword, settingToken, targetToken, endOfDirectiveToken, isActive);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
        => new NullableDirectiveTriviaSyntax(this.Kind, this.hashToken, this.nullableKeyword, this.settingToken, this.targetToken, this.endOfDirectiveToken, this.isActive, diagnostics, GetAnnotations());

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
        => new NullableDirectiveTriviaSyntax(this.Kind, this.hashToken, this.nullableKeyword, this.settingToken, this.targetToken, this.endOfDirectiveToken, this.isActive, GetDiagnostics(), annotations);

    internal NullableDirectiveTriviaSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 5;
      var hashToken = (SyntaxToken)reader.ReadValue();
      if (hashToken != null)
      {
         AdjustFlagsAndWidth(hashToken);
         this.hashToken = hashToken;
      }
      var nullableKeyword = (SyntaxToken)reader.ReadValue();
      if (nullableKeyword != null)
      {
         AdjustFlagsAndWidth(nullableKeyword);
         this.nullableKeyword = nullableKeyword;
      }
      var settingToken = (SyntaxToken)reader.ReadValue();
      if (settingToken != null)
      {
         AdjustFlagsAndWidth(settingToken);
         this.settingToken = settingToken;
      }
      var targetToken = (SyntaxToken?)reader.ReadValue();
      if (targetToken != null)
      {
         AdjustFlagsAndWidth(targetToken);
         this.targetToken = targetToken;
      }
      var endOfDirectiveToken = (SyntaxToken)reader.ReadValue();
      if (endOfDirectiveToken != null)
      {
         AdjustFlagsAndWidth(endOfDirectiveToken);
         this.endOfDirectiveToken = endOfDirectiveToken;
      }
      this.isActive = (bool)reader.ReadBoolean();
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.hashToken);
      writer.WriteValue(this.nullableKeyword);
      writer.WriteValue(this.settingToken);
      writer.WriteValue(this.targetToken);
      writer.WriteValue(this.endOfDirectiveToken);
      writer.WriteBoolean(this.isActive);
    }

    static NullableDirectiveTriviaSyntax()
    {
       ObjectBinder.RegisterTypeReader(typeof(NullableDirectiveTriviaSyntax), r => new NullableDirectiveTriviaSyntax(r));
    }
  }

  internal partial class CSharpSyntaxVisitor<TResult>
  {
    public virtual TResult VisitIdentifierName(IdentifierNameSyntax node) => this.DefaultVisit(node);

    public virtual TResult VisitQualifiedName(QualifiedNameSyntax node) => this.DefaultVisit(node);

    public virtual TResult VisitGenericName(GenericNameSyntax node) => this.DefaultVisit(node);

    public virtual TResult VisitTypeArgumentList(TypeArgumentListSyntax node) => this.DefaultVisit(node);

    public virtual TResult VisitAliasQualifiedName(AliasQualifiedNameSyntax node) => this.DefaultVisit(node);

    public virtual TResult VisitPredefinedType(PredefinedTypeSyntax node) => this.DefaultVisit(node);

    public virtual TResult VisitArrayType(ArrayTypeSyntax node) => this.DefaultVisit(node);

    public virtual TResult VisitArrayRankSpecifier(ArrayRankSpecifierSyntax node) => this.DefaultVisit(node);

    public virtual TResult VisitPointerType(PointerTypeSyntax node) => this.DefaultVisit(node);

    public virtual TResult VisitNullableType(NullableTypeSyntax node) => this.DefaultVisit(node);

    public virtual TResult VisitTupleType(TupleTypeSyntax node) => this.DefaultVisit(node);

    public virtual TResult VisitTupleElement(TupleElementSyntax node) => this.DefaultVisit(node);

    public virtual TResult VisitOmittedTypeArgument(OmittedTypeArgumentSyntax node) => this.DefaultVisit(node);

    public virtual TResult VisitRefType(RefTypeSyntax node) => this.DefaultVisit(node);

    public virtual TResult VisitParenthesizedExpression(ParenthesizedExpressionSyntax node) => this.DefaultVisit(node);

    public virtual TResult VisitTupleExpression(TupleExpressionSyntax node) => this.DefaultVisit(node);

    public virtual TResult VisitPrefixUnaryExpression(PrefixUnaryExpressionSyntax node) => this.DefaultVisit(node);

    public virtual TResult VisitAwaitExpression(AwaitExpressionSyntax node) => this.DefaultVisit(node);

    public virtual TResult VisitPostfixUnaryExpression(PostfixUnaryExpressionSyntax node) => this.DefaultVisit(node);

    public virtual TResult VisitMemberAccessExpression(MemberAccessExpressionSyntax node) => this.DefaultVisit(node);

    public virtual TResult VisitConditionalAccessExpression(ConditionalAccessExpressionSyntax node) => this.DefaultVisit(node);

    public virtual TResult VisitMemberBindingExpression(MemberBindingExpressionSyntax node) => this.DefaultVisit(node);

    public virtual TResult VisitElementBindingExpression(ElementBindingExpressionSyntax node) => this.DefaultVisit(node);

    public virtual TResult VisitRangeExpression(RangeExpressionSyntax node) => this.DefaultVisit(node);

    public virtual TResult VisitImplicitElementAccess(ImplicitElementAccessSyntax node) => this.DefaultVisit(node);

    public virtual TResult VisitBinaryExpression(BinaryExpressionSyntax node) => this.DefaultVisit(node);

    public virtual TResult VisitAssignmentExpression(AssignmentExpressionSyntax node) => this.DefaultVisit(node);

    public virtual TResult VisitConditionalExpression(ConditionalExpressionSyntax node) => this.DefaultVisit(node);

    public virtual TResult VisitThisExpression(ThisExpressionSyntax node) => this.DefaultVisit(node);

    public virtual TResult VisitBaseExpression(BaseExpressionSyntax node) => this.DefaultVisit(node);

    public virtual TResult VisitLiteralExpression(LiteralExpressionSyntax node) => this.DefaultVisit(node);

    public virtual TResult VisitMakeRefExpression(MakeRefExpressionSyntax node) => this.DefaultVisit(node);

    public virtual TResult VisitRefTypeExpression(RefTypeExpressionSyntax node) => this.DefaultVisit(node);

    public virtual TResult VisitRefValueExpression(RefValueExpressionSyntax node) => this.DefaultVisit(node);

    public virtual TResult VisitCheckedExpression(CheckedExpressionSyntax node) => this.DefaultVisit(node);

    public virtual TResult VisitDefaultExpression(DefaultExpressionSyntax node) => this.DefaultVisit(node);

    public virtual TResult VisitTypeOfExpression(TypeOfExpressionSyntax node) => this.DefaultVisit(node);

    public virtual TResult VisitSizeOfExpression(SizeOfExpressionSyntax node) => this.DefaultVisit(node);

    public virtual TResult VisitInvocationExpression(InvocationExpressionSyntax node) => this.DefaultVisit(node);

    public virtual TResult VisitElementAccessExpression(ElementAccessExpressionSyntax node) => this.DefaultVisit(node);

    public virtual TResult VisitArgumentList(ArgumentListSyntax node) => this.DefaultVisit(node);

    public virtual TResult VisitBracketedArgumentList(BracketedArgumentListSyntax node) => this.DefaultVisit(node);

    public virtual TResult VisitArgument(ArgumentSyntax node) => this.DefaultVisit(node);

    public virtual TResult VisitNameColon(NameColonSyntax node) => this.DefaultVisit(node);

    public virtual TResult VisitDeclarationExpression(DeclarationExpressionSyntax node) => this.DefaultVisit(node);

    public virtual TResult VisitCastExpression(CastExpressionSyntax node) => this.DefaultVisit(node);

    public virtual TResult VisitAnonymousMethodExpression(AnonymousMethodExpressionSyntax node) => this.DefaultVisit(node);

    public virtual TResult VisitSimpleLambdaExpression(SimpleLambdaExpressionSyntax node) => this.DefaultVisit(node);

    public virtual TResult VisitRefExpression(RefExpressionSyntax node) => this.DefaultVisit(node);

    public virtual TResult VisitParenthesizedLambdaExpression(ParenthesizedLambdaExpressionSyntax node) => this.DefaultVisit(node);

    public virtual TResult VisitInitializerExpression(InitializerExpressionSyntax node) => this.DefaultVisit(node);

    public virtual TResult VisitObjectCreationExpression(ObjectCreationExpressionSyntax node) => this.DefaultVisit(node);

    public virtual TResult VisitAnonymousObjectMemberDeclarator(AnonymousObjectMemberDeclaratorSyntax node) => this.DefaultVisit(node);

    public virtual TResult VisitAnonymousObjectCreationExpression(AnonymousObjectCreationExpressionSyntax node) => this.DefaultVisit(node);

    public virtual TResult VisitArrayCreationExpression(ArrayCreationExpressionSyntax node) => this.DefaultVisit(node);

    public virtual TResult VisitImplicitArrayCreationExpression(ImplicitArrayCreationExpressionSyntax node) => this.DefaultVisit(node);

    public virtual TResult VisitStackAllocArrayCreationExpression(StackAllocArrayCreationExpressionSyntax node) => this.DefaultVisit(node);

    public virtual TResult VisitImplicitStackAllocArrayCreationExpression(ImplicitStackAllocArrayCreationExpressionSyntax node) => this.DefaultVisit(node);

    public virtual TResult VisitQueryExpression(QueryExpressionSyntax node) => this.DefaultVisit(node);

    public virtual TResult VisitQueryBody(QueryBodySyntax node) => this.DefaultVisit(node);

    public virtual TResult VisitFromClause(FromClauseSyntax node) => this.DefaultVisit(node);

    public virtual TResult VisitLetClause(LetClauseSyntax node) => this.DefaultVisit(node);

    public virtual TResult VisitJoinClause(JoinClauseSyntax node) => this.DefaultVisit(node);

    public virtual TResult VisitJoinIntoClause(JoinIntoClauseSyntax node) => this.DefaultVisit(node);

    public virtual TResult VisitWhereClause(WhereClauseSyntax node) => this.DefaultVisit(node);

    public virtual TResult VisitOrderByClause(OrderByClauseSyntax node) => this.DefaultVisit(node);

    public virtual TResult VisitOrdering(OrderingSyntax node) => this.DefaultVisit(node);

    public virtual TResult VisitSelectClause(SelectClauseSyntax node) => this.DefaultVisit(node);

    public virtual TResult VisitGroupClause(GroupClauseSyntax node) => this.DefaultVisit(node);

    public virtual TResult VisitQueryContinuation(QueryContinuationSyntax node) => this.DefaultVisit(node);

    public virtual TResult VisitOmittedArraySizeExpression(OmittedArraySizeExpressionSyntax node) => this.DefaultVisit(node);

    public virtual TResult VisitInterpolatedStringExpression(InterpolatedStringExpressionSyntax node) => this.DefaultVisit(node);

    public virtual TResult VisitIsPatternExpression(IsPatternExpressionSyntax node) => this.DefaultVisit(node);

    public virtual TResult VisitThrowExpression(ThrowExpressionSyntax node) => this.DefaultVisit(node);

    public virtual TResult VisitWhenClause(WhenClauseSyntax node) => this.DefaultVisit(node);

    public virtual TResult VisitDiscardPattern(DiscardPatternSyntax node) => this.DefaultVisit(node);

    public virtual TResult VisitDeclarationPattern(DeclarationPatternSyntax node) => this.DefaultVisit(node);

    public virtual TResult VisitVarPattern(VarPatternSyntax node) => this.DefaultVisit(node);

    public virtual TResult VisitRecursivePattern(RecursivePatternSyntax node) => this.DefaultVisit(node);

    public virtual TResult VisitPositionalPatternClause(PositionalPatternClauseSyntax node) => this.DefaultVisit(node);

    public virtual TResult VisitPropertyPatternClause(PropertyPatternClauseSyntax node) => this.DefaultVisit(node);

    public virtual TResult VisitSubpattern(SubpatternSyntax node) => this.DefaultVisit(node);

    public virtual TResult VisitConstantPattern(ConstantPatternSyntax node) => this.DefaultVisit(node);

    public virtual TResult VisitInterpolatedStringText(InterpolatedStringTextSyntax node) => this.DefaultVisit(node);

    public virtual TResult VisitInterpolation(InterpolationSyntax node) => this.DefaultVisit(node);

    public virtual TResult VisitInterpolationAlignmentClause(InterpolationAlignmentClauseSyntax node) => this.DefaultVisit(node);

    public virtual TResult VisitInterpolationFormatClause(InterpolationFormatClauseSyntax node) => this.DefaultVisit(node);

    public virtual TResult VisitGlobalStatement(GlobalStatementSyntax node) => this.DefaultVisit(node);

    public virtual TResult VisitBlock(BlockSyntax node) => this.DefaultVisit(node);

    public virtual TResult VisitLocalFunctionStatement(LocalFunctionStatementSyntax node) => this.DefaultVisit(node);

    public virtual TResult VisitLocalDeclarationStatement(LocalDeclarationStatementSyntax node) => this.DefaultVisit(node);

    public virtual TResult VisitVariableDeclaration(VariableDeclarationSyntax node) => this.DefaultVisit(node);

    public virtual TResult VisitVariableDeclarator(VariableDeclaratorSyntax node) => this.DefaultVisit(node);

    public virtual TResult VisitEqualsValueClause(EqualsValueClauseSyntax node) => this.DefaultVisit(node);

    public virtual TResult VisitSingleVariableDesignation(SingleVariableDesignationSyntax node) => this.DefaultVisit(node);

    public virtual TResult VisitDiscardDesignation(DiscardDesignationSyntax node) => this.DefaultVisit(node);

    public virtual TResult VisitParenthesizedVariableDesignation(ParenthesizedVariableDesignationSyntax node) => this.DefaultVisit(node);

    public virtual TResult VisitExpressionStatement(ExpressionStatementSyntax node) => this.DefaultVisit(node);

    public virtual TResult VisitEmptyStatement(EmptyStatementSyntax node) => this.DefaultVisit(node);

    public virtual TResult VisitLabeledStatement(LabeledStatementSyntax node) => this.DefaultVisit(node);

    public virtual TResult VisitGotoStatement(GotoStatementSyntax node) => this.DefaultVisit(node);

    public virtual TResult VisitBreakStatement(BreakStatementSyntax node) => this.DefaultVisit(node);

    public virtual TResult VisitContinueStatement(ContinueStatementSyntax node) => this.DefaultVisit(node);

    public virtual TResult VisitReturnStatement(ReturnStatementSyntax node) => this.DefaultVisit(node);

    public virtual TResult VisitThrowStatement(ThrowStatementSyntax node) => this.DefaultVisit(node);

    public virtual TResult VisitYieldStatement(YieldStatementSyntax node) => this.DefaultVisit(node);

    public virtual TResult VisitWhileStatement(WhileStatementSyntax node) => this.DefaultVisit(node);

    public virtual TResult VisitDoStatement(DoStatementSyntax node) => this.DefaultVisit(node);

    public virtual TResult VisitForStatement(ForStatementSyntax node) => this.DefaultVisit(node);

    public virtual TResult VisitForEachStatement(ForEachStatementSyntax node) => this.DefaultVisit(node);

    public virtual TResult VisitForEachVariableStatement(ForEachVariableStatementSyntax node) => this.DefaultVisit(node);

    public virtual TResult VisitUsingStatement(UsingStatementSyntax node) => this.DefaultVisit(node);

    public virtual TResult VisitFixedStatement(FixedStatementSyntax node) => this.DefaultVisit(node);

    public virtual TResult VisitCheckedStatement(CheckedStatementSyntax node) => this.DefaultVisit(node);

    public virtual TResult VisitUnsafeStatement(UnsafeStatementSyntax node) => this.DefaultVisit(node);

    public virtual TResult VisitLockStatement(LockStatementSyntax node) => this.DefaultVisit(node);

    public virtual TResult VisitIfStatement(IfStatementSyntax node) => this.DefaultVisit(node);

    public virtual TResult VisitElseClause(ElseClauseSyntax node) => this.DefaultVisit(node);

    public virtual TResult VisitSwitchStatement(SwitchStatementSyntax node) => this.DefaultVisit(node);

    public virtual TResult VisitSwitchSection(SwitchSectionSyntax node) => this.DefaultVisit(node);

    public virtual TResult VisitCasePatternSwitchLabel(CasePatternSwitchLabelSyntax node) => this.DefaultVisit(node);

    public virtual TResult VisitCaseSwitchLabel(CaseSwitchLabelSyntax node) => this.DefaultVisit(node);

    public virtual TResult VisitDefaultSwitchLabel(DefaultSwitchLabelSyntax node) => this.DefaultVisit(node);

    public virtual TResult VisitSwitchExpression(SwitchExpressionSyntax node) => this.DefaultVisit(node);

    public virtual TResult VisitSwitchExpressionArm(SwitchExpressionArmSyntax node) => this.DefaultVisit(node);

    public virtual TResult VisitTryStatement(TryStatementSyntax node) => this.DefaultVisit(node);

    public virtual TResult VisitCatchClause(CatchClauseSyntax node) => this.DefaultVisit(node);

    public virtual TResult VisitCatchDeclaration(CatchDeclarationSyntax node) => this.DefaultVisit(node);

    public virtual TResult VisitCatchFilterClause(CatchFilterClauseSyntax node) => this.DefaultVisit(node);

    public virtual TResult VisitFinallyClause(FinallyClauseSyntax node) => this.DefaultVisit(node);

    public virtual TResult VisitCompilationUnit(CompilationUnitSyntax node) => this.DefaultVisit(node);

    public virtual TResult VisitExternAliasDirective(ExternAliasDirectiveSyntax node) => this.DefaultVisit(node);

    public virtual TResult VisitUsingDirective(UsingDirectiveSyntax node) => this.DefaultVisit(node);

    public virtual TResult VisitNamespaceDeclaration(NamespaceDeclarationSyntax node) => this.DefaultVisit(node);

    public virtual TResult VisitAttributeList(AttributeListSyntax node) => this.DefaultVisit(node);

    public virtual TResult VisitAttributeTargetSpecifier(AttributeTargetSpecifierSyntax node) => this.DefaultVisit(node);

    public virtual TResult VisitAttribute(AttributeSyntax node) => this.DefaultVisit(node);

    public virtual TResult VisitAttributeArgumentList(AttributeArgumentListSyntax node) => this.DefaultVisit(node);

    public virtual TResult VisitAttributeArgument(AttributeArgumentSyntax node) => this.DefaultVisit(node);

    public virtual TResult VisitNameEquals(NameEqualsSyntax node) => this.DefaultVisit(node);

    public virtual TResult VisitTypeParameterList(TypeParameterListSyntax node) => this.DefaultVisit(node);

    public virtual TResult VisitTypeParameter(TypeParameterSyntax node) => this.DefaultVisit(node);

    public virtual TResult VisitClassDeclaration(ClassDeclarationSyntax node) => this.DefaultVisit(node);

    public virtual TResult VisitStructDeclaration(StructDeclarationSyntax node) => this.DefaultVisit(node);

    public virtual TResult VisitInterfaceDeclaration(InterfaceDeclarationSyntax node) => this.DefaultVisit(node);

    public virtual TResult VisitEnumDeclaration(EnumDeclarationSyntax node) => this.DefaultVisit(node);

    public virtual TResult VisitDelegateDeclaration(DelegateDeclarationSyntax node) => this.DefaultVisit(node);

    public virtual TResult VisitEnumMemberDeclaration(EnumMemberDeclarationSyntax node) => this.DefaultVisit(node);

    public virtual TResult VisitBaseList(BaseListSyntax node) => this.DefaultVisit(node);

    public virtual TResult VisitSimpleBaseType(SimpleBaseTypeSyntax node) => this.DefaultVisit(node);

    public virtual TResult VisitTypeParameterConstraintClause(TypeParameterConstraintClauseSyntax node) => this.DefaultVisit(node);

    public virtual TResult VisitConstructorConstraint(ConstructorConstraintSyntax node) => this.DefaultVisit(node);

    public virtual TResult VisitClassOrStructConstraint(ClassOrStructConstraintSyntax node) => this.DefaultVisit(node);

    public virtual TResult VisitTypeConstraint(TypeConstraintSyntax node) => this.DefaultVisit(node);

    public virtual TResult VisitFieldDeclaration(FieldDeclarationSyntax node) => this.DefaultVisit(node);

    public virtual TResult VisitEventFieldDeclaration(EventFieldDeclarationSyntax node) => this.DefaultVisit(node);

    public virtual TResult VisitExplicitInterfaceSpecifier(ExplicitInterfaceSpecifierSyntax node) => this.DefaultVisit(node);

    public virtual TResult VisitMethodDeclaration(MethodDeclarationSyntax node) => this.DefaultVisit(node);

    public virtual TResult VisitOperatorDeclaration(OperatorDeclarationSyntax node) => this.DefaultVisit(node);

    public virtual TResult VisitConversionOperatorDeclaration(ConversionOperatorDeclarationSyntax node) => this.DefaultVisit(node);

    public virtual TResult VisitConstructorDeclaration(ConstructorDeclarationSyntax node) => this.DefaultVisit(node);

    public virtual TResult VisitConstructorInitializer(ConstructorInitializerSyntax node) => this.DefaultVisit(node);

    public virtual TResult VisitDestructorDeclaration(DestructorDeclarationSyntax node) => this.DefaultVisit(node);

    public virtual TResult VisitPropertyDeclaration(PropertyDeclarationSyntax node) => this.DefaultVisit(node);

    public virtual TResult VisitArrowExpressionClause(ArrowExpressionClauseSyntax node) => this.DefaultVisit(node);

    public virtual TResult VisitEventDeclaration(EventDeclarationSyntax node) => this.DefaultVisit(node);

    public virtual TResult VisitIndexerDeclaration(IndexerDeclarationSyntax node) => this.DefaultVisit(node);

    public virtual TResult VisitAccessorList(AccessorListSyntax node) => this.DefaultVisit(node);

    public virtual TResult VisitAccessorDeclaration(AccessorDeclarationSyntax node) => this.DefaultVisit(node);

    public virtual TResult VisitParameterList(ParameterListSyntax node) => this.DefaultVisit(node);

    public virtual TResult VisitBracketedParameterList(BracketedParameterListSyntax node) => this.DefaultVisit(node);

    public virtual TResult VisitParameter(ParameterSyntax node) => this.DefaultVisit(node);

    public virtual TResult VisitIncompleteMember(IncompleteMemberSyntax node) => this.DefaultVisit(node);

    public virtual TResult VisitSkippedTokensTrivia(SkippedTokensTriviaSyntax node) => this.DefaultVisit(node);

    public virtual TResult VisitDocumentationCommentTrivia(DocumentationCommentTriviaSyntax node) => this.DefaultVisit(node);

    public virtual TResult VisitTypeCref(TypeCrefSyntax node) => this.DefaultVisit(node);

    public virtual TResult VisitQualifiedCref(QualifiedCrefSyntax node) => this.DefaultVisit(node);

    public virtual TResult VisitNameMemberCref(NameMemberCrefSyntax node) => this.DefaultVisit(node);

    public virtual TResult VisitIndexerMemberCref(IndexerMemberCrefSyntax node) => this.DefaultVisit(node);

    public virtual TResult VisitOperatorMemberCref(OperatorMemberCrefSyntax node) => this.DefaultVisit(node);

    public virtual TResult VisitConversionOperatorMemberCref(ConversionOperatorMemberCrefSyntax node) => this.DefaultVisit(node);

    public virtual TResult VisitCrefParameterList(CrefParameterListSyntax node) => this.DefaultVisit(node);

    public virtual TResult VisitCrefBracketedParameterList(CrefBracketedParameterListSyntax node) => this.DefaultVisit(node);

    public virtual TResult VisitCrefParameter(CrefParameterSyntax node) => this.DefaultVisit(node);

    public virtual TResult VisitXmlElement(XmlElementSyntax node) => this.DefaultVisit(node);

    public virtual TResult VisitXmlElementStartTag(XmlElementStartTagSyntax node) => this.DefaultVisit(node);

    public virtual TResult VisitXmlElementEndTag(XmlElementEndTagSyntax node) => this.DefaultVisit(node);

    public virtual TResult VisitXmlEmptyElement(XmlEmptyElementSyntax node) => this.DefaultVisit(node);

    public virtual TResult VisitXmlName(XmlNameSyntax node) => this.DefaultVisit(node);

    public virtual TResult VisitXmlPrefix(XmlPrefixSyntax node) => this.DefaultVisit(node);

    public virtual TResult VisitXmlTextAttribute(XmlTextAttributeSyntax node) => this.DefaultVisit(node);

    public virtual TResult VisitXmlCrefAttribute(XmlCrefAttributeSyntax node) => this.DefaultVisit(node);

    public virtual TResult VisitXmlNameAttribute(XmlNameAttributeSyntax node) => this.DefaultVisit(node);

    public virtual TResult VisitXmlText(XmlTextSyntax node) => this.DefaultVisit(node);

    public virtual TResult VisitXmlCDataSection(XmlCDataSectionSyntax node) => this.DefaultVisit(node);

    public virtual TResult VisitXmlProcessingInstruction(XmlProcessingInstructionSyntax node) => this.DefaultVisit(node);

    public virtual TResult VisitXmlComment(XmlCommentSyntax node) => this.DefaultVisit(node);

    public virtual TResult VisitIfDirectiveTrivia(IfDirectiveTriviaSyntax node) => this.DefaultVisit(node);

    public virtual TResult VisitElifDirectiveTrivia(ElifDirectiveTriviaSyntax node) => this.DefaultVisit(node);

    public virtual TResult VisitElseDirectiveTrivia(ElseDirectiveTriviaSyntax node) => this.DefaultVisit(node);

    public virtual TResult VisitEndIfDirectiveTrivia(EndIfDirectiveTriviaSyntax node) => this.DefaultVisit(node);

    public virtual TResult VisitRegionDirectiveTrivia(RegionDirectiveTriviaSyntax node) => this.DefaultVisit(node);

    public virtual TResult VisitEndRegionDirectiveTrivia(EndRegionDirectiveTriviaSyntax node) => this.DefaultVisit(node);

    public virtual TResult VisitErrorDirectiveTrivia(ErrorDirectiveTriviaSyntax node) => this.DefaultVisit(node);

    public virtual TResult VisitWarningDirectiveTrivia(WarningDirectiveTriviaSyntax node) => this.DefaultVisit(node);

    public virtual TResult VisitBadDirectiveTrivia(BadDirectiveTriviaSyntax node) => this.DefaultVisit(node);

    public virtual TResult VisitDefineDirectiveTrivia(DefineDirectiveTriviaSyntax node) => this.DefaultVisit(node);

    public virtual TResult VisitUndefDirectiveTrivia(UndefDirectiveTriviaSyntax node) => this.DefaultVisit(node);

    public virtual TResult VisitLineDirectiveTrivia(LineDirectiveTriviaSyntax node) => this.DefaultVisit(node);

    public virtual TResult VisitPragmaWarningDirectiveTrivia(PragmaWarningDirectiveTriviaSyntax node) => this.DefaultVisit(node);

    public virtual TResult VisitPragmaChecksumDirectiveTrivia(PragmaChecksumDirectiveTriviaSyntax node) => this.DefaultVisit(node);

    public virtual TResult VisitReferenceDirectiveTrivia(ReferenceDirectiveTriviaSyntax node) => this.DefaultVisit(node);

    public virtual TResult VisitLoadDirectiveTrivia(LoadDirectiveTriviaSyntax node) => this.DefaultVisit(node);

    public virtual TResult VisitShebangDirectiveTrivia(ShebangDirectiveTriviaSyntax node) => this.DefaultVisit(node);

    public virtual TResult VisitNullableDirectiveTrivia(NullableDirectiveTriviaSyntax node) => this.DefaultVisit(node);
  }


  internal partial class CSharpSyntaxVisitor
  {
    public virtual void VisitIdentifierName(IdentifierNameSyntax node) => this.DefaultVisit(node);

    public virtual void VisitQualifiedName(QualifiedNameSyntax node) => this.DefaultVisit(node);

    public virtual void VisitGenericName(GenericNameSyntax node) => this.DefaultVisit(node);

    public virtual void VisitTypeArgumentList(TypeArgumentListSyntax node) => this.DefaultVisit(node);

    public virtual void VisitAliasQualifiedName(AliasQualifiedNameSyntax node) => this.DefaultVisit(node);

    public virtual void VisitPredefinedType(PredefinedTypeSyntax node) => this.DefaultVisit(node);

    public virtual void VisitArrayType(ArrayTypeSyntax node) => this.DefaultVisit(node);

    public virtual void VisitArrayRankSpecifier(ArrayRankSpecifierSyntax node) => this.DefaultVisit(node);

    public virtual void VisitPointerType(PointerTypeSyntax node) => this.DefaultVisit(node);

    public virtual void VisitNullableType(NullableTypeSyntax node) => this.DefaultVisit(node);

    public virtual void VisitTupleType(TupleTypeSyntax node) => this.DefaultVisit(node);

    public virtual void VisitTupleElement(TupleElementSyntax node) => this.DefaultVisit(node);

    public virtual void VisitOmittedTypeArgument(OmittedTypeArgumentSyntax node) => this.DefaultVisit(node);

    public virtual void VisitRefType(RefTypeSyntax node) => this.DefaultVisit(node);

    public virtual void VisitParenthesizedExpression(ParenthesizedExpressionSyntax node) => this.DefaultVisit(node);

    public virtual void VisitTupleExpression(TupleExpressionSyntax node) => this.DefaultVisit(node);

    public virtual void VisitPrefixUnaryExpression(PrefixUnaryExpressionSyntax node) => this.DefaultVisit(node);

    public virtual void VisitAwaitExpression(AwaitExpressionSyntax node) => this.DefaultVisit(node);

    public virtual void VisitPostfixUnaryExpression(PostfixUnaryExpressionSyntax node) => this.DefaultVisit(node);

    public virtual void VisitMemberAccessExpression(MemberAccessExpressionSyntax node) => this.DefaultVisit(node);

    public virtual void VisitConditionalAccessExpression(ConditionalAccessExpressionSyntax node) => this.DefaultVisit(node);

    public virtual void VisitMemberBindingExpression(MemberBindingExpressionSyntax node) => this.DefaultVisit(node);

    public virtual void VisitElementBindingExpression(ElementBindingExpressionSyntax node) => this.DefaultVisit(node);

    public virtual void VisitRangeExpression(RangeExpressionSyntax node) => this.DefaultVisit(node);

    public virtual void VisitImplicitElementAccess(ImplicitElementAccessSyntax node) => this.DefaultVisit(node);

    public virtual void VisitBinaryExpression(BinaryExpressionSyntax node) => this.DefaultVisit(node);

    public virtual void VisitAssignmentExpression(AssignmentExpressionSyntax node) => this.DefaultVisit(node);

    public virtual void VisitConditionalExpression(ConditionalExpressionSyntax node) => this.DefaultVisit(node);

    public virtual void VisitThisExpression(ThisExpressionSyntax node) => this.DefaultVisit(node);

    public virtual void VisitBaseExpression(BaseExpressionSyntax node) => this.DefaultVisit(node);

    public virtual void VisitLiteralExpression(LiteralExpressionSyntax node) => this.DefaultVisit(node);

    public virtual void VisitMakeRefExpression(MakeRefExpressionSyntax node) => this.DefaultVisit(node);

    public virtual void VisitRefTypeExpression(RefTypeExpressionSyntax node) => this.DefaultVisit(node);

    public virtual void VisitRefValueExpression(RefValueExpressionSyntax node) => this.DefaultVisit(node);

    public virtual void VisitCheckedExpression(CheckedExpressionSyntax node) => this.DefaultVisit(node);

    public virtual void VisitDefaultExpression(DefaultExpressionSyntax node) => this.DefaultVisit(node);

    public virtual void VisitTypeOfExpression(TypeOfExpressionSyntax node) => this.DefaultVisit(node);

    public virtual void VisitSizeOfExpression(SizeOfExpressionSyntax node) => this.DefaultVisit(node);

    public virtual void VisitInvocationExpression(InvocationExpressionSyntax node) => this.DefaultVisit(node);

    public virtual void VisitElementAccessExpression(ElementAccessExpressionSyntax node) => this.DefaultVisit(node);

    public virtual void VisitArgumentList(ArgumentListSyntax node) => this.DefaultVisit(node);

    public virtual void VisitBracketedArgumentList(BracketedArgumentListSyntax node) => this.DefaultVisit(node);

    public virtual void VisitArgument(ArgumentSyntax node) => this.DefaultVisit(node);

    public virtual void VisitNameColon(NameColonSyntax node) => this.DefaultVisit(node);

    public virtual void VisitDeclarationExpression(DeclarationExpressionSyntax node) => this.DefaultVisit(node);

    public virtual void VisitCastExpression(CastExpressionSyntax node) => this.DefaultVisit(node);

    public virtual void VisitAnonymousMethodExpression(AnonymousMethodExpressionSyntax node) => this.DefaultVisit(node);

    public virtual void VisitSimpleLambdaExpression(SimpleLambdaExpressionSyntax node) => this.DefaultVisit(node);

    public virtual void VisitRefExpression(RefExpressionSyntax node) => this.DefaultVisit(node);

    public virtual void VisitParenthesizedLambdaExpression(ParenthesizedLambdaExpressionSyntax node) => this.DefaultVisit(node);

    public virtual void VisitInitializerExpression(InitializerExpressionSyntax node) => this.DefaultVisit(node);

    public virtual void VisitObjectCreationExpression(ObjectCreationExpressionSyntax node) => this.DefaultVisit(node);

    public virtual void VisitAnonymousObjectMemberDeclarator(AnonymousObjectMemberDeclaratorSyntax node) => this.DefaultVisit(node);

    public virtual void VisitAnonymousObjectCreationExpression(AnonymousObjectCreationExpressionSyntax node) => this.DefaultVisit(node);

    public virtual void VisitArrayCreationExpression(ArrayCreationExpressionSyntax node) => this.DefaultVisit(node);

    public virtual void VisitImplicitArrayCreationExpression(ImplicitArrayCreationExpressionSyntax node) => this.DefaultVisit(node);

    public virtual void VisitStackAllocArrayCreationExpression(StackAllocArrayCreationExpressionSyntax node) => this.DefaultVisit(node);

    public virtual void VisitImplicitStackAllocArrayCreationExpression(ImplicitStackAllocArrayCreationExpressionSyntax node) => this.DefaultVisit(node);

    public virtual void VisitQueryExpression(QueryExpressionSyntax node) => this.DefaultVisit(node);

    public virtual void VisitQueryBody(QueryBodySyntax node) => this.DefaultVisit(node);

    public virtual void VisitFromClause(FromClauseSyntax node) => this.DefaultVisit(node);

    public virtual void VisitLetClause(LetClauseSyntax node) => this.DefaultVisit(node);

    public virtual void VisitJoinClause(JoinClauseSyntax node) => this.DefaultVisit(node);

    public virtual void VisitJoinIntoClause(JoinIntoClauseSyntax node) => this.DefaultVisit(node);

    public virtual void VisitWhereClause(WhereClauseSyntax node) => this.DefaultVisit(node);

    public virtual void VisitOrderByClause(OrderByClauseSyntax node) => this.DefaultVisit(node);

    public virtual void VisitOrdering(OrderingSyntax node) => this.DefaultVisit(node);

    public virtual void VisitSelectClause(SelectClauseSyntax node) => this.DefaultVisit(node);

    public virtual void VisitGroupClause(GroupClauseSyntax node) => this.DefaultVisit(node);

    public virtual void VisitQueryContinuation(QueryContinuationSyntax node) => this.DefaultVisit(node);

    public virtual void VisitOmittedArraySizeExpression(OmittedArraySizeExpressionSyntax node) => this.DefaultVisit(node);

    public virtual void VisitInterpolatedStringExpression(InterpolatedStringExpressionSyntax node) => this.DefaultVisit(node);

    public virtual void VisitIsPatternExpression(IsPatternExpressionSyntax node) => this.DefaultVisit(node);

    public virtual void VisitThrowExpression(ThrowExpressionSyntax node) => this.DefaultVisit(node);

    public virtual void VisitWhenClause(WhenClauseSyntax node) => this.DefaultVisit(node);

    public virtual void VisitDiscardPattern(DiscardPatternSyntax node) => this.DefaultVisit(node);

    public virtual void VisitDeclarationPattern(DeclarationPatternSyntax node) => this.DefaultVisit(node);

    public virtual void VisitVarPattern(VarPatternSyntax node) => this.DefaultVisit(node);

    public virtual void VisitRecursivePattern(RecursivePatternSyntax node) => this.DefaultVisit(node);

    public virtual void VisitPositionalPatternClause(PositionalPatternClauseSyntax node) => this.DefaultVisit(node);

    public virtual void VisitPropertyPatternClause(PropertyPatternClauseSyntax node) => this.DefaultVisit(node);

    public virtual void VisitSubpattern(SubpatternSyntax node) => this.DefaultVisit(node);

    public virtual void VisitConstantPattern(ConstantPatternSyntax node) => this.DefaultVisit(node);

    public virtual void VisitInterpolatedStringText(InterpolatedStringTextSyntax node) => this.DefaultVisit(node);

    public virtual void VisitInterpolation(InterpolationSyntax node) => this.DefaultVisit(node);

    public virtual void VisitInterpolationAlignmentClause(InterpolationAlignmentClauseSyntax node) => this.DefaultVisit(node);

    public virtual void VisitInterpolationFormatClause(InterpolationFormatClauseSyntax node) => this.DefaultVisit(node);

    public virtual void VisitGlobalStatement(GlobalStatementSyntax node) => this.DefaultVisit(node);

    public virtual void VisitBlock(BlockSyntax node) => this.DefaultVisit(node);

    public virtual void VisitLocalFunctionStatement(LocalFunctionStatementSyntax node) => this.DefaultVisit(node);

    public virtual void VisitLocalDeclarationStatement(LocalDeclarationStatementSyntax node) => this.DefaultVisit(node);

    public virtual void VisitVariableDeclaration(VariableDeclarationSyntax node) => this.DefaultVisit(node);

    public virtual void VisitVariableDeclarator(VariableDeclaratorSyntax node) => this.DefaultVisit(node);

    public virtual void VisitEqualsValueClause(EqualsValueClauseSyntax node) => this.DefaultVisit(node);

    public virtual void VisitSingleVariableDesignation(SingleVariableDesignationSyntax node) => this.DefaultVisit(node);

    public virtual void VisitDiscardDesignation(DiscardDesignationSyntax node) => this.DefaultVisit(node);

    public virtual void VisitParenthesizedVariableDesignation(ParenthesizedVariableDesignationSyntax node) => this.DefaultVisit(node);

    public virtual void VisitExpressionStatement(ExpressionStatementSyntax node) => this.DefaultVisit(node);

    public virtual void VisitEmptyStatement(EmptyStatementSyntax node) => this.DefaultVisit(node);

    public virtual void VisitLabeledStatement(LabeledStatementSyntax node) => this.DefaultVisit(node);

    public virtual void VisitGotoStatement(GotoStatementSyntax node) => this.DefaultVisit(node);

    public virtual void VisitBreakStatement(BreakStatementSyntax node) => this.DefaultVisit(node);

    public virtual void VisitContinueStatement(ContinueStatementSyntax node) => this.DefaultVisit(node);

    public virtual void VisitReturnStatement(ReturnStatementSyntax node) => this.DefaultVisit(node);

    public virtual void VisitThrowStatement(ThrowStatementSyntax node) => this.DefaultVisit(node);

    public virtual void VisitYieldStatement(YieldStatementSyntax node) => this.DefaultVisit(node);

    public virtual void VisitWhileStatement(WhileStatementSyntax node) => this.DefaultVisit(node);

    public virtual void VisitDoStatement(DoStatementSyntax node) => this.DefaultVisit(node);

    public virtual void VisitForStatement(ForStatementSyntax node) => this.DefaultVisit(node);

    public virtual void VisitForEachStatement(ForEachStatementSyntax node) => this.DefaultVisit(node);

    public virtual void VisitForEachVariableStatement(ForEachVariableStatementSyntax node) => this.DefaultVisit(node);

    public virtual void VisitUsingStatement(UsingStatementSyntax node) => this.DefaultVisit(node);

    public virtual void VisitFixedStatement(FixedStatementSyntax node) => this.DefaultVisit(node);

    public virtual void VisitCheckedStatement(CheckedStatementSyntax node) => this.DefaultVisit(node);

    public virtual void VisitUnsafeStatement(UnsafeStatementSyntax node) => this.DefaultVisit(node);

    public virtual void VisitLockStatement(LockStatementSyntax node) => this.DefaultVisit(node);

    public virtual void VisitIfStatement(IfStatementSyntax node) => this.DefaultVisit(node);

    public virtual void VisitElseClause(ElseClauseSyntax node) => this.DefaultVisit(node);

    public virtual void VisitSwitchStatement(SwitchStatementSyntax node) => this.DefaultVisit(node);

    public virtual void VisitSwitchSection(SwitchSectionSyntax node) => this.DefaultVisit(node);

    public virtual void VisitCasePatternSwitchLabel(CasePatternSwitchLabelSyntax node) => this.DefaultVisit(node);

    public virtual void VisitCaseSwitchLabel(CaseSwitchLabelSyntax node) => this.DefaultVisit(node);

    public virtual void VisitDefaultSwitchLabel(DefaultSwitchLabelSyntax node) => this.DefaultVisit(node);

    public virtual void VisitSwitchExpression(SwitchExpressionSyntax node) => this.DefaultVisit(node);

    public virtual void VisitSwitchExpressionArm(SwitchExpressionArmSyntax node) => this.DefaultVisit(node);

    public virtual void VisitTryStatement(TryStatementSyntax node) => this.DefaultVisit(node);

    public virtual void VisitCatchClause(CatchClauseSyntax node) => this.DefaultVisit(node);

    public virtual void VisitCatchDeclaration(CatchDeclarationSyntax node) => this.DefaultVisit(node);

    public virtual void VisitCatchFilterClause(CatchFilterClauseSyntax node) => this.DefaultVisit(node);

    public virtual void VisitFinallyClause(FinallyClauseSyntax node) => this.DefaultVisit(node);

    public virtual void VisitCompilationUnit(CompilationUnitSyntax node) => this.DefaultVisit(node);

    public virtual void VisitExternAliasDirective(ExternAliasDirectiveSyntax node) => this.DefaultVisit(node);

    public virtual void VisitUsingDirective(UsingDirectiveSyntax node) => this.DefaultVisit(node);

    public virtual void VisitNamespaceDeclaration(NamespaceDeclarationSyntax node) => this.DefaultVisit(node);

    public virtual void VisitAttributeList(AttributeListSyntax node) => this.DefaultVisit(node);

    public virtual void VisitAttributeTargetSpecifier(AttributeTargetSpecifierSyntax node) => this.DefaultVisit(node);

    public virtual void VisitAttribute(AttributeSyntax node) => this.DefaultVisit(node);

    public virtual void VisitAttributeArgumentList(AttributeArgumentListSyntax node) => this.DefaultVisit(node);

    public virtual void VisitAttributeArgument(AttributeArgumentSyntax node) => this.DefaultVisit(node);

    public virtual void VisitNameEquals(NameEqualsSyntax node) => this.DefaultVisit(node);

    public virtual void VisitTypeParameterList(TypeParameterListSyntax node) => this.DefaultVisit(node);

    public virtual void VisitTypeParameter(TypeParameterSyntax node) => this.DefaultVisit(node);

    public virtual void VisitClassDeclaration(ClassDeclarationSyntax node) => this.DefaultVisit(node);

    public virtual void VisitStructDeclaration(StructDeclarationSyntax node) => this.DefaultVisit(node);

    public virtual void VisitInterfaceDeclaration(InterfaceDeclarationSyntax node) => this.DefaultVisit(node);

    public virtual void VisitEnumDeclaration(EnumDeclarationSyntax node) => this.DefaultVisit(node);

    public virtual void VisitDelegateDeclaration(DelegateDeclarationSyntax node) => this.DefaultVisit(node);

    public virtual void VisitEnumMemberDeclaration(EnumMemberDeclarationSyntax node) => this.DefaultVisit(node);

    public virtual void VisitBaseList(BaseListSyntax node) => this.DefaultVisit(node);

    public virtual void VisitSimpleBaseType(SimpleBaseTypeSyntax node) => this.DefaultVisit(node);

    public virtual void VisitTypeParameterConstraintClause(TypeParameterConstraintClauseSyntax node) => this.DefaultVisit(node);

    public virtual void VisitConstructorConstraint(ConstructorConstraintSyntax node) => this.DefaultVisit(node);

    public virtual void VisitClassOrStructConstraint(ClassOrStructConstraintSyntax node) => this.DefaultVisit(node);

    public virtual void VisitTypeConstraint(TypeConstraintSyntax node) => this.DefaultVisit(node);

    public virtual void VisitFieldDeclaration(FieldDeclarationSyntax node) => this.DefaultVisit(node);

    public virtual void VisitEventFieldDeclaration(EventFieldDeclarationSyntax node) => this.DefaultVisit(node);

    public virtual void VisitExplicitInterfaceSpecifier(ExplicitInterfaceSpecifierSyntax node) => this.DefaultVisit(node);

    public virtual void VisitMethodDeclaration(MethodDeclarationSyntax node) => this.DefaultVisit(node);

    public virtual void VisitOperatorDeclaration(OperatorDeclarationSyntax node) => this.DefaultVisit(node);

    public virtual void VisitConversionOperatorDeclaration(ConversionOperatorDeclarationSyntax node) => this.DefaultVisit(node);

    public virtual void VisitConstructorDeclaration(ConstructorDeclarationSyntax node) => this.DefaultVisit(node);

    public virtual void VisitConstructorInitializer(ConstructorInitializerSyntax node) => this.DefaultVisit(node);

    public virtual void VisitDestructorDeclaration(DestructorDeclarationSyntax node) => this.DefaultVisit(node);

    public virtual void VisitPropertyDeclaration(PropertyDeclarationSyntax node) => this.DefaultVisit(node);

    public virtual void VisitArrowExpressionClause(ArrowExpressionClauseSyntax node) => this.DefaultVisit(node);

    public virtual void VisitEventDeclaration(EventDeclarationSyntax node) => this.DefaultVisit(node);

    public virtual void VisitIndexerDeclaration(IndexerDeclarationSyntax node) => this.DefaultVisit(node);

    public virtual void VisitAccessorList(AccessorListSyntax node) => this.DefaultVisit(node);

    public virtual void VisitAccessorDeclaration(AccessorDeclarationSyntax node) => this.DefaultVisit(node);

    public virtual void VisitParameterList(ParameterListSyntax node) => this.DefaultVisit(node);

    public virtual void VisitBracketedParameterList(BracketedParameterListSyntax node) => this.DefaultVisit(node);

    public virtual void VisitParameter(ParameterSyntax node) => this.DefaultVisit(node);

    public virtual void VisitIncompleteMember(IncompleteMemberSyntax node) => this.DefaultVisit(node);

    public virtual void VisitSkippedTokensTrivia(SkippedTokensTriviaSyntax node) => this.DefaultVisit(node);

    public virtual void VisitDocumentationCommentTrivia(DocumentationCommentTriviaSyntax node) => this.DefaultVisit(node);

    public virtual void VisitTypeCref(TypeCrefSyntax node) => this.DefaultVisit(node);

    public virtual void VisitQualifiedCref(QualifiedCrefSyntax node) => this.DefaultVisit(node);

    public virtual void VisitNameMemberCref(NameMemberCrefSyntax node) => this.DefaultVisit(node);

    public virtual void VisitIndexerMemberCref(IndexerMemberCrefSyntax node) => this.DefaultVisit(node);

    public virtual void VisitOperatorMemberCref(OperatorMemberCrefSyntax node) => this.DefaultVisit(node);

    public virtual void VisitConversionOperatorMemberCref(ConversionOperatorMemberCrefSyntax node) => this.DefaultVisit(node);

    public virtual void VisitCrefParameterList(CrefParameterListSyntax node) => this.DefaultVisit(node);

    public virtual void VisitCrefBracketedParameterList(CrefBracketedParameterListSyntax node) => this.DefaultVisit(node);

    public virtual void VisitCrefParameter(CrefParameterSyntax node) => this.DefaultVisit(node);

    public virtual void VisitXmlElement(XmlElementSyntax node) => this.DefaultVisit(node);

    public virtual void VisitXmlElementStartTag(XmlElementStartTagSyntax node) => this.DefaultVisit(node);

    public virtual void VisitXmlElementEndTag(XmlElementEndTagSyntax node) => this.DefaultVisit(node);

    public virtual void VisitXmlEmptyElement(XmlEmptyElementSyntax node) => this.DefaultVisit(node);

    public virtual void VisitXmlName(XmlNameSyntax node) => this.DefaultVisit(node);

    public virtual void VisitXmlPrefix(XmlPrefixSyntax node) => this.DefaultVisit(node);

    public virtual void VisitXmlTextAttribute(XmlTextAttributeSyntax node) => this.DefaultVisit(node);

    public virtual void VisitXmlCrefAttribute(XmlCrefAttributeSyntax node) => this.DefaultVisit(node);

    public virtual void VisitXmlNameAttribute(XmlNameAttributeSyntax node) => this.DefaultVisit(node);

    public virtual void VisitXmlText(XmlTextSyntax node) => this.DefaultVisit(node);

    public virtual void VisitXmlCDataSection(XmlCDataSectionSyntax node) => this.DefaultVisit(node);

    public virtual void VisitXmlProcessingInstruction(XmlProcessingInstructionSyntax node) => this.DefaultVisit(node);

    public virtual void VisitXmlComment(XmlCommentSyntax node) => this.DefaultVisit(node);

    public virtual void VisitIfDirectiveTrivia(IfDirectiveTriviaSyntax node) => this.DefaultVisit(node);

    public virtual void VisitElifDirectiveTrivia(ElifDirectiveTriviaSyntax node) => this.DefaultVisit(node);

    public virtual void VisitElseDirectiveTrivia(ElseDirectiveTriviaSyntax node) => this.DefaultVisit(node);

    public virtual void VisitEndIfDirectiveTrivia(EndIfDirectiveTriviaSyntax node) => this.DefaultVisit(node);

    public virtual void VisitRegionDirectiveTrivia(RegionDirectiveTriviaSyntax node) => this.DefaultVisit(node);

    public virtual void VisitEndRegionDirectiveTrivia(EndRegionDirectiveTriviaSyntax node) => this.DefaultVisit(node);

    public virtual void VisitErrorDirectiveTrivia(ErrorDirectiveTriviaSyntax node) => this.DefaultVisit(node);

    public virtual void VisitWarningDirectiveTrivia(WarningDirectiveTriviaSyntax node) => this.DefaultVisit(node);

    public virtual void VisitBadDirectiveTrivia(BadDirectiveTriviaSyntax node) => this.DefaultVisit(node);

    public virtual void VisitDefineDirectiveTrivia(DefineDirectiveTriviaSyntax node) => this.DefaultVisit(node);

    public virtual void VisitUndefDirectiveTrivia(UndefDirectiveTriviaSyntax node) => this.DefaultVisit(node);

    public virtual void VisitLineDirectiveTrivia(LineDirectiveTriviaSyntax node) => this.DefaultVisit(node);

    public virtual void VisitPragmaWarningDirectiveTrivia(PragmaWarningDirectiveTriviaSyntax node) => this.DefaultVisit(node);

    public virtual void VisitPragmaChecksumDirectiveTrivia(PragmaChecksumDirectiveTriviaSyntax node) => this.DefaultVisit(node);

    public virtual void VisitReferenceDirectiveTrivia(ReferenceDirectiveTriviaSyntax node) => this.DefaultVisit(node);

    public virtual void VisitLoadDirectiveTrivia(LoadDirectiveTriviaSyntax node) => this.DefaultVisit(node);

    public virtual void VisitShebangDirectiveTrivia(ShebangDirectiveTriviaSyntax node) => this.DefaultVisit(node);

    public virtual void VisitNullableDirectiveTrivia(NullableDirectiveTriviaSyntax node) => this.DefaultVisit(node);
  }

  internal partial class CSharpSyntaxRewriter : CSharpSyntaxVisitor<CSharpSyntaxNode>
  {
    public override CSharpSyntaxNode VisitIdentifierName(IdentifierNameSyntax node)
    {
      var identifier = (SyntaxToken)this.Visit(node.Identifier);
      return node.Update(identifier);
    }

    public override CSharpSyntaxNode VisitQualifiedName(QualifiedNameSyntax node)
    {
      var left = (NameSyntax)this.Visit(node.Left);
      var dotToken = (SyntaxToken)this.Visit(node.DotToken);
      var right = (SimpleNameSyntax)this.Visit(node.Right);
      return node.Update(left, dotToken, right);
    }

    public override CSharpSyntaxNode VisitGenericName(GenericNameSyntax node)
    {
      var identifier = (SyntaxToken)this.Visit(node.Identifier);
      var typeArgumentList = (TypeArgumentListSyntax)this.Visit(node.TypeArgumentList);
      return node.Update(identifier, typeArgumentList);
    }

    public override CSharpSyntaxNode VisitTypeArgumentList(TypeArgumentListSyntax node)
    {
      var lessThanToken = (SyntaxToken)this.Visit(node.LessThanToken);
      var arguments = this.VisitList(node.Arguments);
      var greaterThanToken = (SyntaxToken)this.Visit(node.GreaterThanToken);
      return node.Update(lessThanToken, arguments, greaterThanToken);
    }

    public override CSharpSyntaxNode VisitAliasQualifiedName(AliasQualifiedNameSyntax node)
    {
      var alias = (IdentifierNameSyntax)this.Visit(node.Alias);
      var colonColonToken = (SyntaxToken)this.Visit(node.ColonColonToken);
      var name = (SimpleNameSyntax)this.Visit(node.Name);
      return node.Update(alias, colonColonToken, name);
    }

    public override CSharpSyntaxNode VisitPredefinedType(PredefinedTypeSyntax node)
    {
      var keyword = (SyntaxToken)this.Visit(node.Keyword);
      return node.Update(keyword);
    }

    public override CSharpSyntaxNode VisitArrayType(ArrayTypeSyntax node)
    {
      var elementType = (TypeSyntax)this.Visit(node.ElementType);
      var rankSpecifiers = this.VisitList(node.RankSpecifiers);
      return node.Update(elementType, rankSpecifiers);
    }

    public override CSharpSyntaxNode VisitArrayRankSpecifier(ArrayRankSpecifierSyntax node)
    {
      var openBracketToken = (SyntaxToken)this.Visit(node.OpenBracketToken);
      var sizes = this.VisitList(node.Sizes);
      var closeBracketToken = (SyntaxToken)this.Visit(node.CloseBracketToken);
      return node.Update(openBracketToken, sizes, closeBracketToken);
    }

    public override CSharpSyntaxNode VisitPointerType(PointerTypeSyntax node)
    {
      var elementType = (TypeSyntax)this.Visit(node.ElementType);
      var asteriskToken = (SyntaxToken)this.Visit(node.AsteriskToken);
      return node.Update(elementType, asteriskToken);
    }

    public override CSharpSyntaxNode VisitNullableType(NullableTypeSyntax node)
    {
      var elementType = (TypeSyntax)this.Visit(node.ElementType);
      var questionToken = (SyntaxToken)this.Visit(node.QuestionToken);
      return node.Update(elementType, questionToken);
    }

    public override CSharpSyntaxNode VisitTupleType(TupleTypeSyntax node)
    {
      var openParenToken = (SyntaxToken)this.Visit(node.OpenParenToken);
      var elements = this.VisitList(node.Elements);
      var closeParenToken = (SyntaxToken)this.Visit(node.CloseParenToken);
      return node.Update(openParenToken, elements, closeParenToken);
    }

    public override CSharpSyntaxNode VisitTupleElement(TupleElementSyntax node)
    {
      var type = (TypeSyntax)this.Visit(node.Type);
      var identifier = (SyntaxToken)this.Visit(node.Identifier);
      return node.Update(type, identifier);
    }

    public override CSharpSyntaxNode VisitOmittedTypeArgument(OmittedTypeArgumentSyntax node)
    {
      var omittedTypeArgumentToken = (SyntaxToken)this.Visit(node.OmittedTypeArgumentToken);
      return node.Update(omittedTypeArgumentToken);
    }

    public override CSharpSyntaxNode VisitRefType(RefTypeSyntax node)
    {
      var refKeyword = (SyntaxToken)this.Visit(node.RefKeyword);
      var readOnlyKeyword = (SyntaxToken)this.Visit(node.ReadOnlyKeyword);
      var type = (TypeSyntax)this.Visit(node.Type);
      return node.Update(refKeyword, readOnlyKeyword, type);
    }

    public override CSharpSyntaxNode VisitParenthesizedExpression(ParenthesizedExpressionSyntax node)
    {
      var openParenToken = (SyntaxToken)this.Visit(node.OpenParenToken);
      var expression = (ExpressionSyntax)this.Visit(node.Expression);
      var closeParenToken = (SyntaxToken)this.Visit(node.CloseParenToken);
      return node.Update(openParenToken, expression, closeParenToken);
    }

    public override CSharpSyntaxNode VisitTupleExpression(TupleExpressionSyntax node)
    {
      var openParenToken = (SyntaxToken)this.Visit(node.OpenParenToken);
      var arguments = this.VisitList(node.Arguments);
      var closeParenToken = (SyntaxToken)this.Visit(node.CloseParenToken);
      return node.Update(openParenToken, arguments, closeParenToken);
    }

    public override CSharpSyntaxNode VisitPrefixUnaryExpression(PrefixUnaryExpressionSyntax node)
    {
      var operatorToken = (SyntaxToken)this.Visit(node.OperatorToken);
      var operand = (ExpressionSyntax)this.Visit(node.Operand);
      return node.Update(operatorToken, operand);
    }

    public override CSharpSyntaxNode VisitAwaitExpression(AwaitExpressionSyntax node)
    {
      var awaitKeyword = (SyntaxToken)this.Visit(node.AwaitKeyword);
      var expression = (ExpressionSyntax)this.Visit(node.Expression);
      return node.Update(awaitKeyword, expression);
    }

    public override CSharpSyntaxNode VisitPostfixUnaryExpression(PostfixUnaryExpressionSyntax node)
    {
      var operand = (ExpressionSyntax)this.Visit(node.Operand);
      var operatorToken = (SyntaxToken)this.Visit(node.OperatorToken);
      return node.Update(operand, operatorToken);
    }

    public override CSharpSyntaxNode VisitMemberAccessExpression(MemberAccessExpressionSyntax node)
    {
      var expression = (ExpressionSyntax)this.Visit(node.Expression);
      var operatorToken = (SyntaxToken)this.Visit(node.OperatorToken);
      var name = (SimpleNameSyntax)this.Visit(node.Name);
      return node.Update(expression, operatorToken, name);
    }

    public override CSharpSyntaxNode VisitConditionalAccessExpression(ConditionalAccessExpressionSyntax node)
    {
      var expression = (ExpressionSyntax)this.Visit(node.Expression);
      var operatorToken = (SyntaxToken)this.Visit(node.OperatorToken);
      var whenNotNull = (ExpressionSyntax)this.Visit(node.WhenNotNull);
      return node.Update(expression, operatorToken, whenNotNull);
    }

    public override CSharpSyntaxNode VisitMemberBindingExpression(MemberBindingExpressionSyntax node)
    {
      var operatorToken = (SyntaxToken)this.Visit(node.OperatorToken);
      var name = (SimpleNameSyntax)this.Visit(node.Name);
      return node.Update(operatorToken, name);
    }

    public override CSharpSyntaxNode VisitElementBindingExpression(ElementBindingExpressionSyntax node)
    {
      var argumentList = (BracketedArgumentListSyntax)this.Visit(node.ArgumentList);
      return node.Update(argumentList);
    }

    public override CSharpSyntaxNode VisitRangeExpression(RangeExpressionSyntax node)
    {
      var leftOperand = (ExpressionSyntax)this.Visit(node.LeftOperand);
      var operatorToken = (SyntaxToken)this.Visit(node.OperatorToken);
      var rightOperand = (ExpressionSyntax)this.Visit(node.RightOperand);
      return node.Update(leftOperand, operatorToken, rightOperand);
    }

    public override CSharpSyntaxNode VisitImplicitElementAccess(ImplicitElementAccessSyntax node)
    {
      var argumentList = (BracketedArgumentListSyntax)this.Visit(node.ArgumentList);
      return node.Update(argumentList);
    }

    public override CSharpSyntaxNode VisitBinaryExpression(BinaryExpressionSyntax node)
    {
      var left = (ExpressionSyntax)this.Visit(node.Left);
      var operatorToken = (SyntaxToken)this.Visit(node.OperatorToken);
      var right = (ExpressionSyntax)this.Visit(node.Right);
      return node.Update(left, operatorToken, right);
    }

    public override CSharpSyntaxNode VisitAssignmentExpression(AssignmentExpressionSyntax node)
    {
      var left = (ExpressionSyntax)this.Visit(node.Left);
      var operatorToken = (SyntaxToken)this.Visit(node.OperatorToken);
      var right = (ExpressionSyntax)this.Visit(node.Right);
      return node.Update(left, operatorToken, right);
    }

    public override CSharpSyntaxNode VisitConditionalExpression(ConditionalExpressionSyntax node)
    {
      var condition = (ExpressionSyntax)this.Visit(node.Condition);
      var questionToken = (SyntaxToken)this.Visit(node.QuestionToken);
      var whenTrue = (ExpressionSyntax)this.Visit(node.WhenTrue);
      var colonToken = (SyntaxToken)this.Visit(node.ColonToken);
      var whenFalse = (ExpressionSyntax)this.Visit(node.WhenFalse);
      return node.Update(condition, questionToken, whenTrue, colonToken, whenFalse);
    }

    public override CSharpSyntaxNode VisitThisExpression(ThisExpressionSyntax node)
    {
      var token = (SyntaxToken)this.Visit(node.Token);
      return node.Update(token);
    }

    public override CSharpSyntaxNode VisitBaseExpression(BaseExpressionSyntax node)
    {
      var token = (SyntaxToken)this.Visit(node.Token);
      return node.Update(token);
    }

    public override CSharpSyntaxNode VisitLiteralExpression(LiteralExpressionSyntax node)
    {
      var token = (SyntaxToken)this.Visit(node.Token);
      return node.Update(token);
    }

    public override CSharpSyntaxNode VisitMakeRefExpression(MakeRefExpressionSyntax node)
    {
      var keyword = (SyntaxToken)this.Visit(node.Keyword);
      var openParenToken = (SyntaxToken)this.Visit(node.OpenParenToken);
      var expression = (ExpressionSyntax)this.Visit(node.Expression);
      var closeParenToken = (SyntaxToken)this.Visit(node.CloseParenToken);
      return node.Update(keyword, openParenToken, expression, closeParenToken);
    }

    public override CSharpSyntaxNode VisitRefTypeExpression(RefTypeExpressionSyntax node)
    {
      var keyword = (SyntaxToken)this.Visit(node.Keyword);
      var openParenToken = (SyntaxToken)this.Visit(node.OpenParenToken);
      var expression = (ExpressionSyntax)this.Visit(node.Expression);
      var closeParenToken = (SyntaxToken)this.Visit(node.CloseParenToken);
      return node.Update(keyword, openParenToken, expression, closeParenToken);
    }

    public override CSharpSyntaxNode VisitRefValueExpression(RefValueExpressionSyntax node)
    {
      var keyword = (SyntaxToken)this.Visit(node.Keyword);
      var openParenToken = (SyntaxToken)this.Visit(node.OpenParenToken);
      var expression = (ExpressionSyntax)this.Visit(node.Expression);
      var comma = (SyntaxToken)this.Visit(node.Comma);
      var type = (TypeSyntax)this.Visit(node.Type);
      var closeParenToken = (SyntaxToken)this.Visit(node.CloseParenToken);
      return node.Update(keyword, openParenToken, expression, comma, type, closeParenToken);
    }

    public override CSharpSyntaxNode VisitCheckedExpression(CheckedExpressionSyntax node)
    {
      var keyword = (SyntaxToken)this.Visit(node.Keyword);
      var openParenToken = (SyntaxToken)this.Visit(node.OpenParenToken);
      var expression = (ExpressionSyntax)this.Visit(node.Expression);
      var closeParenToken = (SyntaxToken)this.Visit(node.CloseParenToken);
      return node.Update(keyword, openParenToken, expression, closeParenToken);
    }

    public override CSharpSyntaxNode VisitDefaultExpression(DefaultExpressionSyntax node)
    {
      var keyword = (SyntaxToken)this.Visit(node.Keyword);
      var openParenToken = (SyntaxToken)this.Visit(node.OpenParenToken);
      var type = (TypeSyntax)this.Visit(node.Type);
      var closeParenToken = (SyntaxToken)this.Visit(node.CloseParenToken);
      return node.Update(keyword, openParenToken, type, closeParenToken);
    }

    public override CSharpSyntaxNode VisitTypeOfExpression(TypeOfExpressionSyntax node)
    {
      var keyword = (SyntaxToken)this.Visit(node.Keyword);
      var openParenToken = (SyntaxToken)this.Visit(node.OpenParenToken);
      var type = (TypeSyntax)this.Visit(node.Type);
      var closeParenToken = (SyntaxToken)this.Visit(node.CloseParenToken);
      return node.Update(keyword, openParenToken, type, closeParenToken);
    }

    public override CSharpSyntaxNode VisitSizeOfExpression(SizeOfExpressionSyntax node)
    {
      var keyword = (SyntaxToken)this.Visit(node.Keyword);
      var openParenToken = (SyntaxToken)this.Visit(node.OpenParenToken);
      var type = (TypeSyntax)this.Visit(node.Type);
      var closeParenToken = (SyntaxToken)this.Visit(node.CloseParenToken);
      return node.Update(keyword, openParenToken, type, closeParenToken);
    }

    public override CSharpSyntaxNode VisitInvocationExpression(InvocationExpressionSyntax node)
    {
      var expression = (ExpressionSyntax)this.Visit(node.Expression);
      var argumentList = (ArgumentListSyntax)this.Visit(node.ArgumentList);
      return node.Update(expression, argumentList);
    }

    public override CSharpSyntaxNode VisitElementAccessExpression(ElementAccessExpressionSyntax node)
    {
      var expression = (ExpressionSyntax)this.Visit(node.Expression);
      var argumentList = (BracketedArgumentListSyntax)this.Visit(node.ArgumentList);
      return node.Update(expression, argumentList);
    }

    public override CSharpSyntaxNode VisitArgumentList(ArgumentListSyntax node)
    {
      var openParenToken = (SyntaxToken)this.Visit(node.OpenParenToken);
      var arguments = this.VisitList(node.Arguments);
      var closeParenToken = (SyntaxToken)this.Visit(node.CloseParenToken);
      return node.Update(openParenToken, arguments, closeParenToken);
    }

    public override CSharpSyntaxNode VisitBracketedArgumentList(BracketedArgumentListSyntax node)
    {
      var openBracketToken = (SyntaxToken)this.Visit(node.OpenBracketToken);
      var arguments = this.VisitList(node.Arguments);
      var closeBracketToken = (SyntaxToken)this.Visit(node.CloseBracketToken);
      return node.Update(openBracketToken, arguments, closeBracketToken);
    }

    public override CSharpSyntaxNode VisitArgument(ArgumentSyntax node)
    {
      var nameColon = (NameColonSyntax)this.Visit(node.NameColon);
      var refKindKeyword = (SyntaxToken)this.Visit(node.RefKindKeyword);
      var expression = (ExpressionSyntax)this.Visit(node.Expression);
      return node.Update(nameColon, refKindKeyword, expression);
    }

    public override CSharpSyntaxNode VisitNameColon(NameColonSyntax node)
    {
      var name = (IdentifierNameSyntax)this.Visit(node.Name);
      var colonToken = (SyntaxToken)this.Visit(node.ColonToken);
      return node.Update(name, colonToken);
    }

    public override CSharpSyntaxNode VisitDeclarationExpression(DeclarationExpressionSyntax node)
    {
      var type = (TypeSyntax)this.Visit(node.Type);
      var designation = (VariableDesignationSyntax)this.Visit(node.Designation);
      return node.Update(type, designation);
    }

    public override CSharpSyntaxNode VisitCastExpression(CastExpressionSyntax node)
    {
      var openParenToken = (SyntaxToken)this.Visit(node.OpenParenToken);
      var type = (TypeSyntax)this.Visit(node.Type);
      var closeParenToken = (SyntaxToken)this.Visit(node.CloseParenToken);
      var expression = (ExpressionSyntax)this.Visit(node.Expression);
      return node.Update(openParenToken, type, closeParenToken, expression);
    }

    public override CSharpSyntaxNode VisitAnonymousMethodExpression(AnonymousMethodExpressionSyntax node)
    {
      var asyncKeyword = (SyntaxToken)this.Visit(node.AsyncKeyword);
      var delegateKeyword = (SyntaxToken)this.Visit(node.DelegateKeyword);
      var parameterList = (ParameterListSyntax)this.Visit(node.ParameterList);
      var body = (CSharpSyntaxNode)this.Visit(node.Body);
      return node.Update(asyncKeyword, delegateKeyword, parameterList, body);
    }

    public override CSharpSyntaxNode VisitSimpleLambdaExpression(SimpleLambdaExpressionSyntax node)
    {
      var asyncKeyword = (SyntaxToken)this.Visit(node.AsyncKeyword);
      var parameter = (ParameterSyntax)this.Visit(node.Parameter);
      var arrowToken = (SyntaxToken)this.Visit(node.ArrowToken);
      var body = (CSharpSyntaxNode)this.Visit(node.Body);
      return node.Update(asyncKeyword, parameter, arrowToken, body);
    }

    public override CSharpSyntaxNode VisitRefExpression(RefExpressionSyntax node)
    {
      var refKeyword = (SyntaxToken)this.Visit(node.RefKeyword);
      var expression = (ExpressionSyntax)this.Visit(node.Expression);
      return node.Update(refKeyword, expression);
    }

    public override CSharpSyntaxNode VisitParenthesizedLambdaExpression(ParenthesizedLambdaExpressionSyntax node)
    {
      var asyncKeyword = (SyntaxToken)this.Visit(node.AsyncKeyword);
      var parameterList = (ParameterListSyntax)this.Visit(node.ParameterList);
      var arrowToken = (SyntaxToken)this.Visit(node.ArrowToken);
      var body = (CSharpSyntaxNode)this.Visit(node.Body);
      return node.Update(asyncKeyword, parameterList, arrowToken, body);
    }

    public override CSharpSyntaxNode VisitInitializerExpression(InitializerExpressionSyntax node)
    {
      var openBraceToken = (SyntaxToken)this.Visit(node.OpenBraceToken);
      var expressions = this.VisitList(node.Expressions);
      var closeBraceToken = (SyntaxToken)this.Visit(node.CloseBraceToken);
      return node.Update(openBraceToken, expressions, closeBraceToken);
    }

    public override CSharpSyntaxNode VisitObjectCreationExpression(ObjectCreationExpressionSyntax node)
    {
      var newKeyword = (SyntaxToken)this.Visit(node.NewKeyword);
      var type = (TypeSyntax)this.Visit(node.Type);
      var argumentList = (ArgumentListSyntax)this.Visit(node.ArgumentList);
      var initializer = (InitializerExpressionSyntax)this.Visit(node.Initializer);
      return node.Update(newKeyword, type, argumentList, initializer);
    }

    public override CSharpSyntaxNode VisitAnonymousObjectMemberDeclarator(AnonymousObjectMemberDeclaratorSyntax node)
    {
      var nameEquals = (NameEqualsSyntax)this.Visit(node.NameEquals);
      var expression = (ExpressionSyntax)this.Visit(node.Expression);
      return node.Update(nameEquals, expression);
    }

    public override CSharpSyntaxNode VisitAnonymousObjectCreationExpression(AnonymousObjectCreationExpressionSyntax node)
    {
      var newKeyword = (SyntaxToken)this.Visit(node.NewKeyword);
      var openBraceToken = (SyntaxToken)this.Visit(node.OpenBraceToken);
      var initializers = this.VisitList(node.Initializers);
      var closeBraceToken = (SyntaxToken)this.Visit(node.CloseBraceToken);
      return node.Update(newKeyword, openBraceToken, initializers, closeBraceToken);
    }

    public override CSharpSyntaxNode VisitArrayCreationExpression(ArrayCreationExpressionSyntax node)
    {
      var newKeyword = (SyntaxToken)this.Visit(node.NewKeyword);
      var type = (ArrayTypeSyntax)this.Visit(node.Type);
      var initializer = (InitializerExpressionSyntax)this.Visit(node.Initializer);
      return node.Update(newKeyword, type, initializer);
    }

    public override CSharpSyntaxNode VisitImplicitArrayCreationExpression(ImplicitArrayCreationExpressionSyntax node)
    {
      var newKeyword = (SyntaxToken)this.Visit(node.NewKeyword);
      var openBracketToken = (SyntaxToken)this.Visit(node.OpenBracketToken);
      var commas = this.VisitList(node.Commas);
      var closeBracketToken = (SyntaxToken)this.Visit(node.CloseBracketToken);
      var initializer = (InitializerExpressionSyntax)this.Visit(node.Initializer);
      return node.Update(newKeyword, openBracketToken, commas, closeBracketToken, initializer);
    }

    public override CSharpSyntaxNode VisitStackAllocArrayCreationExpression(StackAllocArrayCreationExpressionSyntax node)
    {
      var stackAllocKeyword = (SyntaxToken)this.Visit(node.StackAllocKeyword);
      var type = (TypeSyntax)this.Visit(node.Type);
      var initializer = (InitializerExpressionSyntax)this.Visit(node.Initializer);
      return node.Update(stackAllocKeyword, type, initializer);
    }

    public override CSharpSyntaxNode VisitImplicitStackAllocArrayCreationExpression(ImplicitStackAllocArrayCreationExpressionSyntax node)
    {
      var stackAllocKeyword = (SyntaxToken)this.Visit(node.StackAllocKeyword);
      var openBracketToken = (SyntaxToken)this.Visit(node.OpenBracketToken);
      var closeBracketToken = (SyntaxToken)this.Visit(node.CloseBracketToken);
      var initializer = (InitializerExpressionSyntax)this.Visit(node.Initializer);
      return node.Update(stackAllocKeyword, openBracketToken, closeBracketToken, initializer);
    }

    public override CSharpSyntaxNode VisitQueryExpression(QueryExpressionSyntax node)
    {
      var fromClause = (FromClauseSyntax)this.Visit(node.FromClause);
      var body = (QueryBodySyntax)this.Visit(node.Body);
      return node.Update(fromClause, body);
    }

    public override CSharpSyntaxNode VisitQueryBody(QueryBodySyntax node)
    {
      var clauses = this.VisitList(node.Clauses);
      var selectOrGroup = (SelectOrGroupClauseSyntax)this.Visit(node.SelectOrGroup);
      var continuation = (QueryContinuationSyntax)this.Visit(node.Continuation);
      return node.Update(clauses, selectOrGroup, continuation);
    }

    public override CSharpSyntaxNode VisitFromClause(FromClauseSyntax node)
    {
      var fromKeyword = (SyntaxToken)this.Visit(node.FromKeyword);
      var type = (TypeSyntax)this.Visit(node.Type);
      var identifier = (SyntaxToken)this.Visit(node.Identifier);
      var inKeyword = (SyntaxToken)this.Visit(node.InKeyword);
      var expression = (ExpressionSyntax)this.Visit(node.Expression);
      return node.Update(fromKeyword, type, identifier, inKeyword, expression);
    }

    public override CSharpSyntaxNode VisitLetClause(LetClauseSyntax node)
    {
      var letKeyword = (SyntaxToken)this.Visit(node.LetKeyword);
      var identifier = (SyntaxToken)this.Visit(node.Identifier);
      var equalsToken = (SyntaxToken)this.Visit(node.EqualsToken);
      var expression = (ExpressionSyntax)this.Visit(node.Expression);
      return node.Update(letKeyword, identifier, equalsToken, expression);
    }

    public override CSharpSyntaxNode VisitJoinClause(JoinClauseSyntax node)
    {
      var joinKeyword = (SyntaxToken)this.Visit(node.JoinKeyword);
      var type = (TypeSyntax)this.Visit(node.Type);
      var identifier = (SyntaxToken)this.Visit(node.Identifier);
      var inKeyword = (SyntaxToken)this.Visit(node.InKeyword);
      var inExpression = (ExpressionSyntax)this.Visit(node.InExpression);
      var onKeyword = (SyntaxToken)this.Visit(node.OnKeyword);
      var leftExpression = (ExpressionSyntax)this.Visit(node.LeftExpression);
      var equalsKeyword = (SyntaxToken)this.Visit(node.EqualsKeyword);
      var rightExpression = (ExpressionSyntax)this.Visit(node.RightExpression);
      var into = (JoinIntoClauseSyntax)this.Visit(node.Into);
      return node.Update(joinKeyword, type, identifier, inKeyword, inExpression, onKeyword, leftExpression, equalsKeyword, rightExpression, into);
    }

    public override CSharpSyntaxNode VisitJoinIntoClause(JoinIntoClauseSyntax node)
    {
      var intoKeyword = (SyntaxToken)this.Visit(node.IntoKeyword);
      var identifier = (SyntaxToken)this.Visit(node.Identifier);
      return node.Update(intoKeyword, identifier);
    }

    public override CSharpSyntaxNode VisitWhereClause(WhereClauseSyntax node)
    {
      var whereKeyword = (SyntaxToken)this.Visit(node.WhereKeyword);
      var condition = (ExpressionSyntax)this.Visit(node.Condition);
      return node.Update(whereKeyword, condition);
    }

    public override CSharpSyntaxNode VisitOrderByClause(OrderByClauseSyntax node)
    {
      var orderByKeyword = (SyntaxToken)this.Visit(node.OrderByKeyword);
      var orderings = this.VisitList(node.Orderings);
      return node.Update(orderByKeyword, orderings);
    }

    public override CSharpSyntaxNode VisitOrdering(OrderingSyntax node)
    {
      var expression = (ExpressionSyntax)this.Visit(node.Expression);
      var ascendingOrDescendingKeyword = (SyntaxToken)this.Visit(node.AscendingOrDescendingKeyword);
      return node.Update(expression, ascendingOrDescendingKeyword);
    }

    public override CSharpSyntaxNode VisitSelectClause(SelectClauseSyntax node)
    {
      var selectKeyword = (SyntaxToken)this.Visit(node.SelectKeyword);
      var expression = (ExpressionSyntax)this.Visit(node.Expression);
      return node.Update(selectKeyword, expression);
    }

    public override CSharpSyntaxNode VisitGroupClause(GroupClauseSyntax node)
    {
      var groupKeyword = (SyntaxToken)this.Visit(node.GroupKeyword);
      var groupExpression = (ExpressionSyntax)this.Visit(node.GroupExpression);
      var byKeyword = (SyntaxToken)this.Visit(node.ByKeyword);
      var byExpression = (ExpressionSyntax)this.Visit(node.ByExpression);
      return node.Update(groupKeyword, groupExpression, byKeyword, byExpression);
    }

    public override CSharpSyntaxNode VisitQueryContinuation(QueryContinuationSyntax node)
    {
      var intoKeyword = (SyntaxToken)this.Visit(node.IntoKeyword);
      var identifier = (SyntaxToken)this.Visit(node.Identifier);
      var body = (QueryBodySyntax)this.Visit(node.Body);
      return node.Update(intoKeyword, identifier, body);
    }

    public override CSharpSyntaxNode VisitOmittedArraySizeExpression(OmittedArraySizeExpressionSyntax node)
    {
      var omittedArraySizeExpressionToken = (SyntaxToken)this.Visit(node.OmittedArraySizeExpressionToken);
      return node.Update(omittedArraySizeExpressionToken);
    }

    public override CSharpSyntaxNode VisitInterpolatedStringExpression(InterpolatedStringExpressionSyntax node)
    {
      var stringStartToken = (SyntaxToken)this.Visit(node.StringStartToken);
      var contents = this.VisitList(node.Contents);
      var stringEndToken = (SyntaxToken)this.Visit(node.StringEndToken);
      return node.Update(stringStartToken, contents, stringEndToken);
    }

    public override CSharpSyntaxNode VisitIsPatternExpression(IsPatternExpressionSyntax node)
    {
      var expression = (ExpressionSyntax)this.Visit(node.Expression);
      var isKeyword = (SyntaxToken)this.Visit(node.IsKeyword);
      var pattern = (PatternSyntax)this.Visit(node.Pattern);
      return node.Update(expression, isKeyword, pattern);
    }

    public override CSharpSyntaxNode VisitThrowExpression(ThrowExpressionSyntax node)
    {
      var throwKeyword = (SyntaxToken)this.Visit(node.ThrowKeyword);
      var expression = (ExpressionSyntax)this.Visit(node.Expression);
      return node.Update(throwKeyword, expression);
    }

    public override CSharpSyntaxNode VisitWhenClause(WhenClauseSyntax node)
    {
      var whenKeyword = (SyntaxToken)this.Visit(node.WhenKeyword);
      var condition = (ExpressionSyntax)this.Visit(node.Condition);
      return node.Update(whenKeyword, condition);
    }

    public override CSharpSyntaxNode VisitDiscardPattern(DiscardPatternSyntax node)
    {
      var underscoreToken = (SyntaxToken)this.Visit(node.UnderscoreToken);
      return node.Update(underscoreToken);
    }

    public override CSharpSyntaxNode VisitDeclarationPattern(DeclarationPatternSyntax node)
    {
      var type = (TypeSyntax)this.Visit(node.Type);
      var designation = (VariableDesignationSyntax)this.Visit(node.Designation);
      return node.Update(type, designation);
    }

    public override CSharpSyntaxNode VisitVarPattern(VarPatternSyntax node)
    {
      var varKeyword = (SyntaxToken)this.Visit(node.VarKeyword);
      var designation = (VariableDesignationSyntax)this.Visit(node.Designation);
      return node.Update(varKeyword, designation);
    }

    public override CSharpSyntaxNode VisitRecursivePattern(RecursivePatternSyntax node)
    {
      var type = (TypeSyntax)this.Visit(node.Type);
      var positionalPatternClause = (PositionalPatternClauseSyntax)this.Visit(node.PositionalPatternClause);
      var propertyPatternClause = (PropertyPatternClauseSyntax)this.Visit(node.PropertyPatternClause);
      var designation = (VariableDesignationSyntax)this.Visit(node.Designation);
      return node.Update(type, positionalPatternClause, propertyPatternClause, designation);
    }

    public override CSharpSyntaxNode VisitPositionalPatternClause(PositionalPatternClauseSyntax node)
    {
      var openParenToken = (SyntaxToken)this.Visit(node.OpenParenToken);
      var subpatterns = this.VisitList(node.Subpatterns);
      var closeParenToken = (SyntaxToken)this.Visit(node.CloseParenToken);
      return node.Update(openParenToken, subpatterns, closeParenToken);
    }

    public override CSharpSyntaxNode VisitPropertyPatternClause(PropertyPatternClauseSyntax node)
    {
      var openBraceToken = (SyntaxToken)this.Visit(node.OpenBraceToken);
      var subpatterns = this.VisitList(node.Subpatterns);
      var closeBraceToken = (SyntaxToken)this.Visit(node.CloseBraceToken);
      return node.Update(openBraceToken, subpatterns, closeBraceToken);
    }

    public override CSharpSyntaxNode VisitSubpattern(SubpatternSyntax node)
    {
      var nameColon = (NameColonSyntax)this.Visit(node.NameColon);
      var pattern = (PatternSyntax)this.Visit(node.Pattern);
      return node.Update(nameColon, pattern);
    }

    public override CSharpSyntaxNode VisitConstantPattern(ConstantPatternSyntax node)
    {
      var expression = (ExpressionSyntax)this.Visit(node.Expression);
      return node.Update(expression);
    }

    public override CSharpSyntaxNode VisitInterpolatedStringText(InterpolatedStringTextSyntax node)
    {
      var textToken = (SyntaxToken)this.Visit(node.TextToken);
      return node.Update(textToken);
    }

    public override CSharpSyntaxNode VisitInterpolation(InterpolationSyntax node)
    {
      var openBraceToken = (SyntaxToken)this.Visit(node.OpenBraceToken);
      var expression = (ExpressionSyntax)this.Visit(node.Expression);
      var alignmentClause = (InterpolationAlignmentClauseSyntax)this.Visit(node.AlignmentClause);
      var formatClause = (InterpolationFormatClauseSyntax)this.Visit(node.FormatClause);
      var closeBraceToken = (SyntaxToken)this.Visit(node.CloseBraceToken);
      return node.Update(openBraceToken, expression, alignmentClause, formatClause, closeBraceToken);
    }

    public override CSharpSyntaxNode VisitInterpolationAlignmentClause(InterpolationAlignmentClauseSyntax node)
    {
      var commaToken = (SyntaxToken)this.Visit(node.CommaToken);
      var value = (ExpressionSyntax)this.Visit(node.Value);
      return node.Update(commaToken, value);
    }

    public override CSharpSyntaxNode VisitInterpolationFormatClause(InterpolationFormatClauseSyntax node)
    {
      var colonToken = (SyntaxToken)this.Visit(node.ColonToken);
      var formatStringToken = (SyntaxToken)this.Visit(node.FormatStringToken);
      return node.Update(colonToken, formatStringToken);
    }

    public override CSharpSyntaxNode VisitGlobalStatement(GlobalStatementSyntax node)
    {
      var attributeLists = this.VisitList(node.AttributeLists);
      var modifiers = this.VisitList(node.Modifiers);
      var statement = (StatementSyntax)this.Visit(node.Statement);
      return node.Update(attributeLists, modifiers, statement);
    }

    public override CSharpSyntaxNode VisitBlock(BlockSyntax node)
    {
      var openBraceToken = (SyntaxToken)this.Visit(node.OpenBraceToken);
      var statements = this.VisitList(node.Statements);
      var closeBraceToken = (SyntaxToken)this.Visit(node.CloseBraceToken);
      return node.Update(openBraceToken, statements, closeBraceToken);
    }

    public override CSharpSyntaxNode VisitLocalFunctionStatement(LocalFunctionStatementSyntax node)
    {
      var modifiers = this.VisitList(node.Modifiers);
      var returnType = (TypeSyntax)this.Visit(node.ReturnType);
      var identifier = (SyntaxToken)this.Visit(node.Identifier);
      var typeParameterList = (TypeParameterListSyntax)this.Visit(node.TypeParameterList);
      var parameterList = (ParameterListSyntax)this.Visit(node.ParameterList);
      var constraintClauses = this.VisitList(node.ConstraintClauses);
      var body = (BlockSyntax)this.Visit(node.Body);
      var expressionBody = (ArrowExpressionClauseSyntax)this.Visit(node.ExpressionBody);
      var semicolonToken = (SyntaxToken)this.Visit(node.SemicolonToken);
      return node.Update(modifiers, returnType, identifier, typeParameterList, parameterList, constraintClauses, body, expressionBody, semicolonToken);
    }

    public override CSharpSyntaxNode VisitLocalDeclarationStatement(LocalDeclarationStatementSyntax node)
    {
      var awaitKeyword = (SyntaxToken)this.Visit(node.AwaitKeyword);
      var usingKeyword = (SyntaxToken)this.Visit(node.UsingKeyword);
      var modifiers = this.VisitList(node.Modifiers);
      var declaration = (VariableDeclarationSyntax)this.Visit(node.Declaration);
      var semicolonToken = (SyntaxToken)this.Visit(node.SemicolonToken);
      return node.Update(awaitKeyword, usingKeyword, modifiers, declaration, semicolonToken);
    }

    public override CSharpSyntaxNode VisitVariableDeclaration(VariableDeclarationSyntax node)
    {
      var type = (TypeSyntax)this.Visit(node.Type);
      var variables = this.VisitList(node.Variables);
      return node.Update(type, variables);
    }

    public override CSharpSyntaxNode VisitVariableDeclarator(VariableDeclaratorSyntax node)
    {
      var identifier = (SyntaxToken)this.Visit(node.Identifier);
      var argumentList = (BracketedArgumentListSyntax)this.Visit(node.ArgumentList);
      var initializer = (EqualsValueClauseSyntax)this.Visit(node.Initializer);
      return node.Update(identifier, argumentList, initializer);
    }

    public override CSharpSyntaxNode VisitEqualsValueClause(EqualsValueClauseSyntax node)
    {
      var equalsToken = (SyntaxToken)this.Visit(node.EqualsToken);
      var value = (ExpressionSyntax)this.Visit(node.Value);
      return node.Update(equalsToken, value);
    }

    public override CSharpSyntaxNode VisitSingleVariableDesignation(SingleVariableDesignationSyntax node)
    {
      var identifier = (SyntaxToken)this.Visit(node.Identifier);
      return node.Update(identifier);
    }

    public override CSharpSyntaxNode VisitDiscardDesignation(DiscardDesignationSyntax node)
    {
      var underscoreToken = (SyntaxToken)this.Visit(node.UnderscoreToken);
      return node.Update(underscoreToken);
    }

    public override CSharpSyntaxNode VisitParenthesizedVariableDesignation(ParenthesizedVariableDesignationSyntax node)
    {
      var openParenToken = (SyntaxToken)this.Visit(node.OpenParenToken);
      var variables = this.VisitList(node.Variables);
      var closeParenToken = (SyntaxToken)this.Visit(node.CloseParenToken);
      return node.Update(openParenToken, variables, closeParenToken);
    }

    public override CSharpSyntaxNode VisitExpressionStatement(ExpressionStatementSyntax node)
    {
      var expression = (ExpressionSyntax)this.Visit(node.Expression);
      var semicolonToken = (SyntaxToken)this.Visit(node.SemicolonToken);
      return node.Update(expression, semicolonToken);
    }

    public override CSharpSyntaxNode VisitEmptyStatement(EmptyStatementSyntax node)
    {
      var semicolonToken = (SyntaxToken)this.Visit(node.SemicolonToken);
      return node.Update(semicolonToken);
    }

    public override CSharpSyntaxNode VisitLabeledStatement(LabeledStatementSyntax node)
    {
      var identifier = (SyntaxToken)this.Visit(node.Identifier);
      var colonToken = (SyntaxToken)this.Visit(node.ColonToken);
      var statement = (StatementSyntax)this.Visit(node.Statement);
      return node.Update(identifier, colonToken, statement);
    }

    public override CSharpSyntaxNode VisitGotoStatement(GotoStatementSyntax node)
    {
      var gotoKeyword = (SyntaxToken)this.Visit(node.GotoKeyword);
      var caseOrDefaultKeyword = (SyntaxToken)this.Visit(node.CaseOrDefaultKeyword);
      var expression = (ExpressionSyntax)this.Visit(node.Expression);
      var semicolonToken = (SyntaxToken)this.Visit(node.SemicolonToken);
      return node.Update(gotoKeyword, caseOrDefaultKeyword, expression, semicolonToken);
    }

    public override CSharpSyntaxNode VisitBreakStatement(BreakStatementSyntax node)
    {
      var breakKeyword = (SyntaxToken)this.Visit(node.BreakKeyword);
      var semicolonToken = (SyntaxToken)this.Visit(node.SemicolonToken);
      return node.Update(breakKeyword, semicolonToken);
    }

    public override CSharpSyntaxNode VisitContinueStatement(ContinueStatementSyntax node)
    {
      var continueKeyword = (SyntaxToken)this.Visit(node.ContinueKeyword);
      var semicolonToken = (SyntaxToken)this.Visit(node.SemicolonToken);
      return node.Update(continueKeyword, semicolonToken);
    }

    public override CSharpSyntaxNode VisitReturnStatement(ReturnStatementSyntax node)
    {
      var returnKeyword = (SyntaxToken)this.Visit(node.ReturnKeyword);
      var expression = (ExpressionSyntax)this.Visit(node.Expression);
      var semicolonToken = (SyntaxToken)this.Visit(node.SemicolonToken);
      return node.Update(returnKeyword, expression, semicolonToken);
    }

    public override CSharpSyntaxNode VisitThrowStatement(ThrowStatementSyntax node)
    {
      var throwKeyword = (SyntaxToken)this.Visit(node.ThrowKeyword);
      var expression = (ExpressionSyntax)this.Visit(node.Expression);
      var semicolonToken = (SyntaxToken)this.Visit(node.SemicolonToken);
      return node.Update(throwKeyword, expression, semicolonToken);
    }

    public override CSharpSyntaxNode VisitYieldStatement(YieldStatementSyntax node)
    {
      var yieldKeyword = (SyntaxToken)this.Visit(node.YieldKeyword);
      var returnOrBreakKeyword = (SyntaxToken)this.Visit(node.ReturnOrBreakKeyword);
      var expression = (ExpressionSyntax)this.Visit(node.Expression);
      var semicolonToken = (SyntaxToken)this.Visit(node.SemicolonToken);
      return node.Update(yieldKeyword, returnOrBreakKeyword, expression, semicolonToken);
    }

    public override CSharpSyntaxNode VisitWhileStatement(WhileStatementSyntax node)
    {
      var whileKeyword = (SyntaxToken)this.Visit(node.WhileKeyword);
      var openParenToken = (SyntaxToken)this.Visit(node.OpenParenToken);
      var condition = (ExpressionSyntax)this.Visit(node.Condition);
      var closeParenToken = (SyntaxToken)this.Visit(node.CloseParenToken);
      var statement = (StatementSyntax)this.Visit(node.Statement);
      return node.Update(whileKeyword, openParenToken, condition, closeParenToken, statement);
    }

    public override CSharpSyntaxNode VisitDoStatement(DoStatementSyntax node)
    {
      var doKeyword = (SyntaxToken)this.Visit(node.DoKeyword);
      var statement = (StatementSyntax)this.Visit(node.Statement);
      var whileKeyword = (SyntaxToken)this.Visit(node.WhileKeyword);
      var openParenToken = (SyntaxToken)this.Visit(node.OpenParenToken);
      var condition = (ExpressionSyntax)this.Visit(node.Condition);
      var closeParenToken = (SyntaxToken)this.Visit(node.CloseParenToken);
      var semicolonToken = (SyntaxToken)this.Visit(node.SemicolonToken);
      return node.Update(doKeyword, statement, whileKeyword, openParenToken, condition, closeParenToken, semicolonToken);
    }

    public override CSharpSyntaxNode VisitForStatement(ForStatementSyntax node)
    {
      var forKeyword = (SyntaxToken)this.Visit(node.ForKeyword);
      var openParenToken = (SyntaxToken)this.Visit(node.OpenParenToken);
      var declaration = (VariableDeclarationSyntax)this.Visit(node.Declaration);
      var initializers = this.VisitList(node.Initializers);
      var firstSemicolonToken = (SyntaxToken)this.Visit(node.FirstSemicolonToken);
      var condition = (ExpressionSyntax)this.Visit(node.Condition);
      var secondSemicolonToken = (SyntaxToken)this.Visit(node.SecondSemicolonToken);
      var incrementors = this.VisitList(node.Incrementors);
      var closeParenToken = (SyntaxToken)this.Visit(node.CloseParenToken);
      var statement = (StatementSyntax)this.Visit(node.Statement);
      return node.Update(forKeyword, openParenToken, declaration, initializers, firstSemicolonToken, condition, secondSemicolonToken, incrementors, closeParenToken, statement);
    }

    public override CSharpSyntaxNode VisitForEachStatement(ForEachStatementSyntax node)
    {
      var awaitKeyword = (SyntaxToken)this.Visit(node.AwaitKeyword);
      var forEachKeyword = (SyntaxToken)this.Visit(node.ForEachKeyword);
      var openParenToken = (SyntaxToken)this.Visit(node.OpenParenToken);
      var type = (TypeSyntax)this.Visit(node.Type);
      var identifier = (SyntaxToken)this.Visit(node.Identifier);
      var inKeyword = (SyntaxToken)this.Visit(node.InKeyword);
      var expression = (ExpressionSyntax)this.Visit(node.Expression);
      var closeParenToken = (SyntaxToken)this.Visit(node.CloseParenToken);
      var statement = (StatementSyntax)this.Visit(node.Statement);
      return node.Update(awaitKeyword, forEachKeyword, openParenToken, type, identifier, inKeyword, expression, closeParenToken, statement);
    }

    public override CSharpSyntaxNode VisitForEachVariableStatement(ForEachVariableStatementSyntax node)
    {
      var awaitKeyword = (SyntaxToken)this.Visit(node.AwaitKeyword);
      var forEachKeyword = (SyntaxToken)this.Visit(node.ForEachKeyword);
      var openParenToken = (SyntaxToken)this.Visit(node.OpenParenToken);
      var variable = (ExpressionSyntax)this.Visit(node.Variable);
      var inKeyword = (SyntaxToken)this.Visit(node.InKeyword);
      var expression = (ExpressionSyntax)this.Visit(node.Expression);
      var closeParenToken = (SyntaxToken)this.Visit(node.CloseParenToken);
      var statement = (StatementSyntax)this.Visit(node.Statement);
      return node.Update(awaitKeyword, forEachKeyword, openParenToken, variable, inKeyword, expression, closeParenToken, statement);
    }

    public override CSharpSyntaxNode VisitUsingStatement(UsingStatementSyntax node)
    {
      var awaitKeyword = (SyntaxToken)this.Visit(node.AwaitKeyword);
      var usingKeyword = (SyntaxToken)this.Visit(node.UsingKeyword);
      var openParenToken = (SyntaxToken)this.Visit(node.OpenParenToken);
      var declaration = (VariableDeclarationSyntax)this.Visit(node.Declaration);
      var expression = (ExpressionSyntax)this.Visit(node.Expression);
      var closeParenToken = (SyntaxToken)this.Visit(node.CloseParenToken);
      var statement = (StatementSyntax)this.Visit(node.Statement);
      return node.Update(awaitKeyword, usingKeyword, openParenToken, declaration, expression, closeParenToken, statement);
    }

    public override CSharpSyntaxNode VisitFixedStatement(FixedStatementSyntax node)
    {
      var fixedKeyword = (SyntaxToken)this.Visit(node.FixedKeyword);
      var openParenToken = (SyntaxToken)this.Visit(node.OpenParenToken);
      var declaration = (VariableDeclarationSyntax)this.Visit(node.Declaration);
      var closeParenToken = (SyntaxToken)this.Visit(node.CloseParenToken);
      var statement = (StatementSyntax)this.Visit(node.Statement);
      return node.Update(fixedKeyword, openParenToken, declaration, closeParenToken, statement);
    }

    public override CSharpSyntaxNode VisitCheckedStatement(CheckedStatementSyntax node)
    {
      var keyword = (SyntaxToken)this.Visit(node.Keyword);
      var block = (BlockSyntax)this.Visit(node.Block);
      return node.Update(keyword, block);
    }

    public override CSharpSyntaxNode VisitUnsafeStatement(UnsafeStatementSyntax node)
    {
      var unsafeKeyword = (SyntaxToken)this.Visit(node.UnsafeKeyword);
      var block = (BlockSyntax)this.Visit(node.Block);
      return node.Update(unsafeKeyword, block);
    }

    public override CSharpSyntaxNode VisitLockStatement(LockStatementSyntax node)
    {
      var lockKeyword = (SyntaxToken)this.Visit(node.LockKeyword);
      var openParenToken = (SyntaxToken)this.Visit(node.OpenParenToken);
      var expression = (ExpressionSyntax)this.Visit(node.Expression);
      var closeParenToken = (SyntaxToken)this.Visit(node.CloseParenToken);
      var statement = (StatementSyntax)this.Visit(node.Statement);
      return node.Update(lockKeyword, openParenToken, expression, closeParenToken, statement);
    }

    public override CSharpSyntaxNode VisitIfStatement(IfStatementSyntax node)
    {
      var ifKeyword = (SyntaxToken)this.Visit(node.IfKeyword);
      var openParenToken = (SyntaxToken)this.Visit(node.OpenParenToken);
      var condition = (ExpressionSyntax)this.Visit(node.Condition);
      var closeParenToken = (SyntaxToken)this.Visit(node.CloseParenToken);
      var statement = (StatementSyntax)this.Visit(node.Statement);
      var @else = (ElseClauseSyntax)this.Visit(node.Else);
      return node.Update(ifKeyword, openParenToken, condition, closeParenToken, statement, @else);
    }

    public override CSharpSyntaxNode VisitElseClause(ElseClauseSyntax node)
    {
      var elseKeyword = (SyntaxToken)this.Visit(node.ElseKeyword);
      var statement = (StatementSyntax)this.Visit(node.Statement);
      return node.Update(elseKeyword, statement);
    }

    public override CSharpSyntaxNode VisitSwitchStatement(SwitchStatementSyntax node)
    {
      var switchKeyword = (SyntaxToken)this.Visit(node.SwitchKeyword);
      var openParenToken = (SyntaxToken)this.Visit(node.OpenParenToken);
      var expression = (ExpressionSyntax)this.Visit(node.Expression);
      var closeParenToken = (SyntaxToken)this.Visit(node.CloseParenToken);
      var openBraceToken = (SyntaxToken)this.Visit(node.OpenBraceToken);
      var sections = this.VisitList(node.Sections);
      var closeBraceToken = (SyntaxToken)this.Visit(node.CloseBraceToken);
      return node.Update(switchKeyword, openParenToken, expression, closeParenToken, openBraceToken, sections, closeBraceToken);
    }

    public override CSharpSyntaxNode VisitSwitchSection(SwitchSectionSyntax node)
    {
      var labels = this.VisitList(node.Labels);
      var statements = this.VisitList(node.Statements);
      return node.Update(labels, statements);
    }

    public override CSharpSyntaxNode VisitCasePatternSwitchLabel(CasePatternSwitchLabelSyntax node)
    {
      var keyword = (SyntaxToken)this.Visit(node.Keyword);
      var pattern = (PatternSyntax)this.Visit(node.Pattern);
      var whenClause = (WhenClauseSyntax)this.Visit(node.WhenClause);
      var colonToken = (SyntaxToken)this.Visit(node.ColonToken);
      return node.Update(keyword, pattern, whenClause, colonToken);
    }

    public override CSharpSyntaxNode VisitCaseSwitchLabel(CaseSwitchLabelSyntax node)
    {
      var keyword = (SyntaxToken)this.Visit(node.Keyword);
      var value = (ExpressionSyntax)this.Visit(node.Value);
      var colonToken = (SyntaxToken)this.Visit(node.ColonToken);
      return node.Update(keyword, value, colonToken);
    }

    public override CSharpSyntaxNode VisitDefaultSwitchLabel(DefaultSwitchLabelSyntax node)
    {
      var keyword = (SyntaxToken)this.Visit(node.Keyword);
      var colonToken = (SyntaxToken)this.Visit(node.ColonToken);
      return node.Update(keyword, colonToken);
    }

    public override CSharpSyntaxNode VisitSwitchExpression(SwitchExpressionSyntax node)
    {
      var governingExpression = (ExpressionSyntax)this.Visit(node.GoverningExpression);
      var switchKeyword = (SyntaxToken)this.Visit(node.SwitchKeyword);
      var openBraceToken = (SyntaxToken)this.Visit(node.OpenBraceToken);
      var arms = this.VisitList(node.Arms);
      var closeBraceToken = (SyntaxToken)this.Visit(node.CloseBraceToken);
      return node.Update(governingExpression, switchKeyword, openBraceToken, arms, closeBraceToken);
    }

    public override CSharpSyntaxNode VisitSwitchExpressionArm(SwitchExpressionArmSyntax node)
    {
      var pattern = (PatternSyntax)this.Visit(node.Pattern);
      var whenClause = (WhenClauseSyntax)this.Visit(node.WhenClause);
      var equalsGreaterThanToken = (SyntaxToken)this.Visit(node.EqualsGreaterThanToken);
      var expression = (ExpressionSyntax)this.Visit(node.Expression);
      return node.Update(pattern, whenClause, equalsGreaterThanToken, expression);
    }

    public override CSharpSyntaxNode VisitTryStatement(TryStatementSyntax node)
    {
      var tryKeyword = (SyntaxToken)this.Visit(node.TryKeyword);
      var block = (BlockSyntax)this.Visit(node.Block);
      var catches = this.VisitList(node.Catches);
      var @finally = (FinallyClauseSyntax)this.Visit(node.Finally);
      return node.Update(tryKeyword, block, catches, @finally);
    }

    public override CSharpSyntaxNode VisitCatchClause(CatchClauseSyntax node)
    {
      var catchKeyword = (SyntaxToken)this.Visit(node.CatchKeyword);
      var declaration = (CatchDeclarationSyntax)this.Visit(node.Declaration);
      var filter = (CatchFilterClauseSyntax)this.Visit(node.Filter);
      var block = (BlockSyntax)this.Visit(node.Block);
      return node.Update(catchKeyword, declaration, filter, block);
    }

    public override CSharpSyntaxNode VisitCatchDeclaration(CatchDeclarationSyntax node)
    {
      var openParenToken = (SyntaxToken)this.Visit(node.OpenParenToken);
      var type = (TypeSyntax)this.Visit(node.Type);
      var identifier = (SyntaxToken)this.Visit(node.Identifier);
      var closeParenToken = (SyntaxToken)this.Visit(node.CloseParenToken);
      return node.Update(openParenToken, type, identifier, closeParenToken);
    }

    public override CSharpSyntaxNode VisitCatchFilterClause(CatchFilterClauseSyntax node)
    {
      var whenKeyword = (SyntaxToken)this.Visit(node.WhenKeyword);
      var openParenToken = (SyntaxToken)this.Visit(node.OpenParenToken);
      var filterExpression = (ExpressionSyntax)this.Visit(node.FilterExpression);
      var closeParenToken = (SyntaxToken)this.Visit(node.CloseParenToken);
      return node.Update(whenKeyword, openParenToken, filterExpression, closeParenToken);
    }

    public override CSharpSyntaxNode VisitFinallyClause(FinallyClauseSyntax node)
    {
      var finallyKeyword = (SyntaxToken)this.Visit(node.FinallyKeyword);
      var block = (BlockSyntax)this.Visit(node.Block);
      return node.Update(finallyKeyword, block);
    }

    public override CSharpSyntaxNode VisitCompilationUnit(CompilationUnitSyntax node)
    {
      var externs = this.VisitList(node.Externs);
      var usings = this.VisitList(node.Usings);
      var attributeLists = this.VisitList(node.AttributeLists);
      var members = this.VisitList(node.Members);
      var endOfFileToken = (SyntaxToken)this.Visit(node.EndOfFileToken);
      return node.Update(externs, usings, attributeLists, members, endOfFileToken);
    }

    public override CSharpSyntaxNode VisitExternAliasDirective(ExternAliasDirectiveSyntax node)
    {
      var externKeyword = (SyntaxToken)this.Visit(node.ExternKeyword);
      var aliasKeyword = (SyntaxToken)this.Visit(node.AliasKeyword);
      var identifier = (SyntaxToken)this.Visit(node.Identifier);
      var semicolonToken = (SyntaxToken)this.Visit(node.SemicolonToken);
      return node.Update(externKeyword, aliasKeyword, identifier, semicolonToken);
    }

    public override CSharpSyntaxNode VisitUsingDirective(UsingDirectiveSyntax node)
    {
      var usingKeyword = (SyntaxToken)this.Visit(node.UsingKeyword);
      var staticKeyword = (SyntaxToken)this.Visit(node.StaticKeyword);
      var alias = (NameEqualsSyntax)this.Visit(node.Alias);
      var name = (NameSyntax)this.Visit(node.Name);
      var semicolonToken = (SyntaxToken)this.Visit(node.SemicolonToken);
      return node.Update(usingKeyword, staticKeyword, alias, name, semicolonToken);
    }

    public override CSharpSyntaxNode VisitNamespaceDeclaration(NamespaceDeclarationSyntax node)
    {
      var attributeLists = this.VisitList(node.AttributeLists);
      var modifiers = this.VisitList(node.Modifiers);
      var namespaceKeyword = (SyntaxToken)this.Visit(node.NamespaceKeyword);
      var name = (NameSyntax)this.Visit(node.Name);
      var openBraceToken = (SyntaxToken)this.Visit(node.OpenBraceToken);
      var externs = this.VisitList(node.Externs);
      var usings = this.VisitList(node.Usings);
      var members = this.VisitList(node.Members);
      var closeBraceToken = (SyntaxToken)this.Visit(node.CloseBraceToken);
      var semicolonToken = (SyntaxToken)this.Visit(node.SemicolonToken);
      return node.Update(attributeLists, modifiers, namespaceKeyword, name, openBraceToken, externs, usings, members, closeBraceToken, semicolonToken);
    }

    public override CSharpSyntaxNode VisitAttributeList(AttributeListSyntax node)
    {
      var openBracketToken = (SyntaxToken)this.Visit(node.OpenBracketToken);
      var target = (AttributeTargetSpecifierSyntax)this.Visit(node.Target);
      var attributes = this.VisitList(node.Attributes);
      var closeBracketToken = (SyntaxToken)this.Visit(node.CloseBracketToken);
      return node.Update(openBracketToken, target, attributes, closeBracketToken);
    }

    public override CSharpSyntaxNode VisitAttributeTargetSpecifier(AttributeTargetSpecifierSyntax node)
    {
      var identifier = (SyntaxToken)this.Visit(node.Identifier);
      var colonToken = (SyntaxToken)this.Visit(node.ColonToken);
      return node.Update(identifier, colonToken);
    }

    public override CSharpSyntaxNode VisitAttribute(AttributeSyntax node)
    {
      var name = (NameSyntax)this.Visit(node.Name);
      var argumentList = (AttributeArgumentListSyntax)this.Visit(node.ArgumentList);
      return node.Update(name, argumentList);
    }

    public override CSharpSyntaxNode VisitAttributeArgumentList(AttributeArgumentListSyntax node)
    {
      var openParenToken = (SyntaxToken)this.Visit(node.OpenParenToken);
      var arguments = this.VisitList(node.Arguments);
      var closeParenToken = (SyntaxToken)this.Visit(node.CloseParenToken);
      return node.Update(openParenToken, arguments, closeParenToken);
    }

    public override CSharpSyntaxNode VisitAttributeArgument(AttributeArgumentSyntax node)
    {
      var nameEquals = (NameEqualsSyntax)this.Visit(node.NameEquals);
      var nameColon = (NameColonSyntax)this.Visit(node.NameColon);
      var expression = (ExpressionSyntax)this.Visit(node.Expression);
      return node.Update(nameEquals, nameColon, expression);
    }

    public override CSharpSyntaxNode VisitNameEquals(NameEqualsSyntax node)
    {
      var name = (IdentifierNameSyntax)this.Visit(node.Name);
      var equalsToken = (SyntaxToken)this.Visit(node.EqualsToken);
      return node.Update(name, equalsToken);
    }

    public override CSharpSyntaxNode VisitTypeParameterList(TypeParameterListSyntax node)
    {
      var lessThanToken = (SyntaxToken)this.Visit(node.LessThanToken);
      var parameters = this.VisitList(node.Parameters);
      var greaterThanToken = (SyntaxToken)this.Visit(node.GreaterThanToken);
      return node.Update(lessThanToken, parameters, greaterThanToken);
    }

    public override CSharpSyntaxNode VisitTypeParameter(TypeParameterSyntax node)
    {
      var attributeLists = this.VisitList(node.AttributeLists);
      var varianceKeyword = (SyntaxToken)this.Visit(node.VarianceKeyword);
      var identifier = (SyntaxToken)this.Visit(node.Identifier);
      return node.Update(attributeLists, varianceKeyword, identifier);
    }

    public override CSharpSyntaxNode VisitClassDeclaration(ClassDeclarationSyntax node)
    {
      var attributeLists = this.VisitList(node.AttributeLists);
      var modifiers = this.VisitList(node.Modifiers);
      var keyword = (SyntaxToken)this.Visit(node.Keyword);
      var identifier = (SyntaxToken)this.Visit(node.Identifier);
      var typeParameterList = (TypeParameterListSyntax)this.Visit(node.TypeParameterList);
      var baseList = (BaseListSyntax)this.Visit(node.BaseList);
      var constraintClauses = this.VisitList(node.ConstraintClauses);
      var openBraceToken = (SyntaxToken)this.Visit(node.OpenBraceToken);
      var members = this.VisitList(node.Members);
      var closeBraceToken = (SyntaxToken)this.Visit(node.CloseBraceToken);
      var semicolonToken = (SyntaxToken)this.Visit(node.SemicolonToken);
      return node.Update(attributeLists, modifiers, keyword, identifier, typeParameterList, baseList, constraintClauses, openBraceToken, members, closeBraceToken, semicolonToken);
    }

    public override CSharpSyntaxNode VisitStructDeclaration(StructDeclarationSyntax node)
    {
      var attributeLists = this.VisitList(node.AttributeLists);
      var modifiers = this.VisitList(node.Modifiers);
      var keyword = (SyntaxToken)this.Visit(node.Keyword);
      var identifier = (SyntaxToken)this.Visit(node.Identifier);
      var typeParameterList = (TypeParameterListSyntax)this.Visit(node.TypeParameterList);
      var baseList = (BaseListSyntax)this.Visit(node.BaseList);
      var constraintClauses = this.VisitList(node.ConstraintClauses);
      var openBraceToken = (SyntaxToken)this.Visit(node.OpenBraceToken);
      var members = this.VisitList(node.Members);
      var closeBraceToken = (SyntaxToken)this.Visit(node.CloseBraceToken);
      var semicolonToken = (SyntaxToken)this.Visit(node.SemicolonToken);
      return node.Update(attributeLists, modifiers, keyword, identifier, typeParameterList, baseList, constraintClauses, openBraceToken, members, closeBraceToken, semicolonToken);
    }

    public override CSharpSyntaxNode VisitInterfaceDeclaration(InterfaceDeclarationSyntax node)
    {
      var attributeLists = this.VisitList(node.AttributeLists);
      var modifiers = this.VisitList(node.Modifiers);
      var keyword = (SyntaxToken)this.Visit(node.Keyword);
      var identifier = (SyntaxToken)this.Visit(node.Identifier);
      var typeParameterList = (TypeParameterListSyntax)this.Visit(node.TypeParameterList);
      var baseList = (BaseListSyntax)this.Visit(node.BaseList);
      var constraintClauses = this.VisitList(node.ConstraintClauses);
      var openBraceToken = (SyntaxToken)this.Visit(node.OpenBraceToken);
      var members = this.VisitList(node.Members);
      var closeBraceToken = (SyntaxToken)this.Visit(node.CloseBraceToken);
      var semicolonToken = (SyntaxToken)this.Visit(node.SemicolonToken);
      return node.Update(attributeLists, modifiers, keyword, identifier, typeParameterList, baseList, constraintClauses, openBraceToken, members, closeBraceToken, semicolonToken);
    }

    public override CSharpSyntaxNode VisitEnumDeclaration(EnumDeclarationSyntax node)
    {
      var attributeLists = this.VisitList(node.AttributeLists);
      var modifiers = this.VisitList(node.Modifiers);
      var enumKeyword = (SyntaxToken)this.Visit(node.EnumKeyword);
      var identifier = (SyntaxToken)this.Visit(node.Identifier);
      var baseList = (BaseListSyntax)this.Visit(node.BaseList);
      var openBraceToken = (SyntaxToken)this.Visit(node.OpenBraceToken);
      var members = this.VisitList(node.Members);
      var closeBraceToken = (SyntaxToken)this.Visit(node.CloseBraceToken);
      var semicolonToken = (SyntaxToken)this.Visit(node.SemicolonToken);
      return node.Update(attributeLists, modifiers, enumKeyword, identifier, baseList, openBraceToken, members, closeBraceToken, semicolonToken);
    }

    public override CSharpSyntaxNode VisitDelegateDeclaration(DelegateDeclarationSyntax node)
    {
      var attributeLists = this.VisitList(node.AttributeLists);
      var modifiers = this.VisitList(node.Modifiers);
      var delegateKeyword = (SyntaxToken)this.Visit(node.DelegateKeyword);
      var returnType = (TypeSyntax)this.Visit(node.ReturnType);
      var identifier = (SyntaxToken)this.Visit(node.Identifier);
      var typeParameterList = (TypeParameterListSyntax)this.Visit(node.TypeParameterList);
      var parameterList = (ParameterListSyntax)this.Visit(node.ParameterList);
      var constraintClauses = this.VisitList(node.ConstraintClauses);
      var semicolonToken = (SyntaxToken)this.Visit(node.SemicolonToken);
      return node.Update(attributeLists, modifiers, delegateKeyword, returnType, identifier, typeParameterList, parameterList, constraintClauses, semicolonToken);
    }

    public override CSharpSyntaxNode VisitEnumMemberDeclaration(EnumMemberDeclarationSyntax node)
    {
      var attributeLists = this.VisitList(node.AttributeLists);
      var modifiers = this.VisitList(node.Modifiers);
      var identifier = (SyntaxToken)this.Visit(node.Identifier);
      var equalsValue = (EqualsValueClauseSyntax)this.Visit(node.EqualsValue);
      return node.Update(attributeLists, modifiers, identifier, equalsValue);
    }

    public override CSharpSyntaxNode VisitBaseList(BaseListSyntax node)
    {
      var colonToken = (SyntaxToken)this.Visit(node.ColonToken);
      var types = this.VisitList(node.Types);
      return node.Update(colonToken, types);
    }

    public override CSharpSyntaxNode VisitSimpleBaseType(SimpleBaseTypeSyntax node)
    {
      var type = (TypeSyntax)this.Visit(node.Type);
      return node.Update(type);
    }

    public override CSharpSyntaxNode VisitTypeParameterConstraintClause(TypeParameterConstraintClauseSyntax node)
    {
      var whereKeyword = (SyntaxToken)this.Visit(node.WhereKeyword);
      var name = (IdentifierNameSyntax)this.Visit(node.Name);
      var colonToken = (SyntaxToken)this.Visit(node.ColonToken);
      var constraints = this.VisitList(node.Constraints);
      return node.Update(whereKeyword, name, colonToken, constraints);
    }

    public override CSharpSyntaxNode VisitConstructorConstraint(ConstructorConstraintSyntax node)
    {
      var newKeyword = (SyntaxToken)this.Visit(node.NewKeyword);
      var openParenToken = (SyntaxToken)this.Visit(node.OpenParenToken);
      var closeParenToken = (SyntaxToken)this.Visit(node.CloseParenToken);
      return node.Update(newKeyword, openParenToken, closeParenToken);
    }

    public override CSharpSyntaxNode VisitClassOrStructConstraint(ClassOrStructConstraintSyntax node)
    {
      var classOrStructKeyword = (SyntaxToken)this.Visit(node.ClassOrStructKeyword);
      var questionToken = (SyntaxToken)this.Visit(node.QuestionToken);
      return node.Update(classOrStructKeyword, questionToken);
    }

    public override CSharpSyntaxNode VisitTypeConstraint(TypeConstraintSyntax node)
    {
      var type = (TypeSyntax)this.Visit(node.Type);
      return node.Update(type);
    }

    public override CSharpSyntaxNode VisitFieldDeclaration(FieldDeclarationSyntax node)
    {
      var attributeLists = this.VisitList(node.AttributeLists);
      var modifiers = this.VisitList(node.Modifiers);
      var declaration = (VariableDeclarationSyntax)this.Visit(node.Declaration);
      var semicolonToken = (SyntaxToken)this.Visit(node.SemicolonToken);
      return node.Update(attributeLists, modifiers, declaration, semicolonToken);
    }

    public override CSharpSyntaxNode VisitEventFieldDeclaration(EventFieldDeclarationSyntax node)
    {
      var attributeLists = this.VisitList(node.AttributeLists);
      var modifiers = this.VisitList(node.Modifiers);
      var eventKeyword = (SyntaxToken)this.Visit(node.EventKeyword);
      var declaration = (VariableDeclarationSyntax)this.Visit(node.Declaration);
      var semicolonToken = (SyntaxToken)this.Visit(node.SemicolonToken);
      return node.Update(attributeLists, modifiers, eventKeyword, declaration, semicolonToken);
    }

    public override CSharpSyntaxNode VisitExplicitInterfaceSpecifier(ExplicitInterfaceSpecifierSyntax node)
    {
      var name = (NameSyntax)this.Visit(node.Name);
      var dotToken = (SyntaxToken)this.Visit(node.DotToken);
      return node.Update(name, dotToken);
    }

    public override CSharpSyntaxNode VisitMethodDeclaration(MethodDeclarationSyntax node)
    {
      var attributeLists = this.VisitList(node.AttributeLists);
      var modifiers = this.VisitList(node.Modifiers);
      var returnType = (TypeSyntax)this.Visit(node.ReturnType);
      var explicitInterfaceSpecifier = (ExplicitInterfaceSpecifierSyntax)this.Visit(node.ExplicitInterfaceSpecifier);
      var identifier = (SyntaxToken)this.Visit(node.Identifier);
      var typeParameterList = (TypeParameterListSyntax)this.Visit(node.TypeParameterList);
      var parameterList = (ParameterListSyntax)this.Visit(node.ParameterList);
      var constraintClauses = this.VisitList(node.ConstraintClauses);
      var body = (BlockSyntax)this.Visit(node.Body);
      var expressionBody = (ArrowExpressionClauseSyntax)this.Visit(node.ExpressionBody);
      var semicolonToken = (SyntaxToken)this.Visit(node.SemicolonToken);
      return node.Update(attributeLists, modifiers, returnType, explicitInterfaceSpecifier, identifier, typeParameterList, parameterList, constraintClauses, body, expressionBody, semicolonToken);
    }

    public override CSharpSyntaxNode VisitOperatorDeclaration(OperatorDeclarationSyntax node)
    {
      var attributeLists = this.VisitList(node.AttributeLists);
      var modifiers = this.VisitList(node.Modifiers);
      var returnType = (TypeSyntax)this.Visit(node.ReturnType);
      var operatorKeyword = (SyntaxToken)this.Visit(node.OperatorKeyword);
      var operatorToken = (SyntaxToken)this.Visit(node.OperatorToken);
      var parameterList = (ParameterListSyntax)this.Visit(node.ParameterList);
      var body = (BlockSyntax)this.Visit(node.Body);
      var expressionBody = (ArrowExpressionClauseSyntax)this.Visit(node.ExpressionBody);
      var semicolonToken = (SyntaxToken)this.Visit(node.SemicolonToken);
      return node.Update(attributeLists, modifiers, returnType, operatorKeyword, operatorToken, parameterList, body, expressionBody, semicolonToken);
    }

    public override CSharpSyntaxNode VisitConversionOperatorDeclaration(ConversionOperatorDeclarationSyntax node)
    {
      var attributeLists = this.VisitList(node.AttributeLists);
      var modifiers = this.VisitList(node.Modifiers);
      var implicitOrExplicitKeyword = (SyntaxToken)this.Visit(node.ImplicitOrExplicitKeyword);
      var operatorKeyword = (SyntaxToken)this.Visit(node.OperatorKeyword);
      var type = (TypeSyntax)this.Visit(node.Type);
      var parameterList = (ParameterListSyntax)this.Visit(node.ParameterList);
      var body = (BlockSyntax)this.Visit(node.Body);
      var expressionBody = (ArrowExpressionClauseSyntax)this.Visit(node.ExpressionBody);
      var semicolonToken = (SyntaxToken)this.Visit(node.SemicolonToken);
      return node.Update(attributeLists, modifiers, implicitOrExplicitKeyword, operatorKeyword, type, parameterList, body, expressionBody, semicolonToken);
    }

    public override CSharpSyntaxNode VisitConstructorDeclaration(ConstructorDeclarationSyntax node)
    {
      var attributeLists = this.VisitList(node.AttributeLists);
      var modifiers = this.VisitList(node.Modifiers);
      var identifier = (SyntaxToken)this.Visit(node.Identifier);
      var parameterList = (ParameterListSyntax)this.Visit(node.ParameterList);
      var initializer = (ConstructorInitializerSyntax)this.Visit(node.Initializer);
      var body = (BlockSyntax)this.Visit(node.Body);
      var expressionBody = (ArrowExpressionClauseSyntax)this.Visit(node.ExpressionBody);
      var semicolonToken = (SyntaxToken)this.Visit(node.SemicolonToken);
      return node.Update(attributeLists, modifiers, identifier, parameterList, initializer, body, expressionBody, semicolonToken);
    }

    public override CSharpSyntaxNode VisitConstructorInitializer(ConstructorInitializerSyntax node)
    {
      var colonToken = (SyntaxToken)this.Visit(node.ColonToken);
      var thisOrBaseKeyword = (SyntaxToken)this.Visit(node.ThisOrBaseKeyword);
      var argumentList = (ArgumentListSyntax)this.Visit(node.ArgumentList);
      return node.Update(colonToken, thisOrBaseKeyword, argumentList);
    }

    public override CSharpSyntaxNode VisitDestructorDeclaration(DestructorDeclarationSyntax node)
    {
      var attributeLists = this.VisitList(node.AttributeLists);
      var modifiers = this.VisitList(node.Modifiers);
      var tildeToken = (SyntaxToken)this.Visit(node.TildeToken);
      var identifier = (SyntaxToken)this.Visit(node.Identifier);
      var parameterList = (ParameterListSyntax)this.Visit(node.ParameterList);
      var body = (BlockSyntax)this.Visit(node.Body);
      var expressionBody = (ArrowExpressionClauseSyntax)this.Visit(node.ExpressionBody);
      var semicolonToken = (SyntaxToken)this.Visit(node.SemicolonToken);
      return node.Update(attributeLists, modifiers, tildeToken, identifier, parameterList, body, expressionBody, semicolonToken);
    }

    public override CSharpSyntaxNode VisitPropertyDeclaration(PropertyDeclarationSyntax node)
    {
      var attributeLists = this.VisitList(node.AttributeLists);
      var modifiers = this.VisitList(node.Modifiers);
      var type = (TypeSyntax)this.Visit(node.Type);
      var explicitInterfaceSpecifier = (ExplicitInterfaceSpecifierSyntax)this.Visit(node.ExplicitInterfaceSpecifier);
      var identifier = (SyntaxToken)this.Visit(node.Identifier);
      var accessorList = (AccessorListSyntax)this.Visit(node.AccessorList);
      var expressionBody = (ArrowExpressionClauseSyntax)this.Visit(node.ExpressionBody);
      var initializer = (EqualsValueClauseSyntax)this.Visit(node.Initializer);
      var semicolonToken = (SyntaxToken)this.Visit(node.SemicolonToken);
      return node.Update(attributeLists, modifiers, type, explicitInterfaceSpecifier, identifier, accessorList, expressionBody, initializer, semicolonToken);
    }

    public override CSharpSyntaxNode VisitArrowExpressionClause(ArrowExpressionClauseSyntax node)
    {
      var arrowToken = (SyntaxToken)this.Visit(node.ArrowToken);
      var expression = (ExpressionSyntax)this.Visit(node.Expression);
      return node.Update(arrowToken, expression);
    }

    public override CSharpSyntaxNode VisitEventDeclaration(EventDeclarationSyntax node)
    {
      var attributeLists = this.VisitList(node.AttributeLists);
      var modifiers = this.VisitList(node.Modifiers);
      var eventKeyword = (SyntaxToken)this.Visit(node.EventKeyword);
      var type = (TypeSyntax)this.Visit(node.Type);
      var explicitInterfaceSpecifier = (ExplicitInterfaceSpecifierSyntax)this.Visit(node.ExplicitInterfaceSpecifier);
      var identifier = (SyntaxToken)this.Visit(node.Identifier);
      var accessorList = (AccessorListSyntax)this.Visit(node.AccessorList);
      var semicolonToken = (SyntaxToken)this.Visit(node.SemicolonToken);
      return node.Update(attributeLists, modifiers, eventKeyword, type, explicitInterfaceSpecifier, identifier, accessorList, semicolonToken);
    }

    public override CSharpSyntaxNode VisitIndexerDeclaration(IndexerDeclarationSyntax node)
    {
      var attributeLists = this.VisitList(node.AttributeLists);
      var modifiers = this.VisitList(node.Modifiers);
      var type = (TypeSyntax)this.Visit(node.Type);
      var explicitInterfaceSpecifier = (ExplicitInterfaceSpecifierSyntax)this.Visit(node.ExplicitInterfaceSpecifier);
      var thisKeyword = (SyntaxToken)this.Visit(node.ThisKeyword);
      var parameterList = (BracketedParameterListSyntax)this.Visit(node.ParameterList);
      var accessorList = (AccessorListSyntax)this.Visit(node.AccessorList);
      var expressionBody = (ArrowExpressionClauseSyntax)this.Visit(node.ExpressionBody);
      var semicolonToken = (SyntaxToken)this.Visit(node.SemicolonToken);
      return node.Update(attributeLists, modifiers, type, explicitInterfaceSpecifier, thisKeyword, parameterList, accessorList, expressionBody, semicolonToken);
    }

    public override CSharpSyntaxNode VisitAccessorList(AccessorListSyntax node)
    {
      var openBraceToken = (SyntaxToken)this.Visit(node.OpenBraceToken);
      var accessors = this.VisitList(node.Accessors);
      var closeBraceToken = (SyntaxToken)this.Visit(node.CloseBraceToken);
      return node.Update(openBraceToken, accessors, closeBraceToken);
    }

    public override CSharpSyntaxNode VisitAccessorDeclaration(AccessorDeclarationSyntax node)
    {
      var attributeLists = this.VisitList(node.AttributeLists);
      var modifiers = this.VisitList(node.Modifiers);
      var keyword = (SyntaxToken)this.Visit(node.Keyword);
      var body = (BlockSyntax)this.Visit(node.Body);
      var expressionBody = (ArrowExpressionClauseSyntax)this.Visit(node.ExpressionBody);
      var semicolonToken = (SyntaxToken)this.Visit(node.SemicolonToken);
      return node.Update(attributeLists, modifiers, keyword, body, expressionBody, semicolonToken);
    }

    public override CSharpSyntaxNode VisitParameterList(ParameterListSyntax node)
    {
      var openParenToken = (SyntaxToken)this.Visit(node.OpenParenToken);
      var parameters = this.VisitList(node.Parameters);
      var closeParenToken = (SyntaxToken)this.Visit(node.CloseParenToken);
      return node.Update(openParenToken, parameters, closeParenToken);
    }

    public override CSharpSyntaxNode VisitBracketedParameterList(BracketedParameterListSyntax node)
    {
      var openBracketToken = (SyntaxToken)this.Visit(node.OpenBracketToken);
      var parameters = this.VisitList(node.Parameters);
      var closeBracketToken = (SyntaxToken)this.Visit(node.CloseBracketToken);
      return node.Update(openBracketToken, parameters, closeBracketToken);
    }

    public override CSharpSyntaxNode VisitParameter(ParameterSyntax node)
    {
      var attributeLists = this.VisitList(node.AttributeLists);
      var modifiers = this.VisitList(node.Modifiers);
      var type = (TypeSyntax)this.Visit(node.Type);
      var identifier = (SyntaxToken)this.Visit(node.Identifier);
      var @default = (EqualsValueClauseSyntax)this.Visit(node.Default);
      return node.Update(attributeLists, modifiers, type, identifier, @default);
    }

    public override CSharpSyntaxNode VisitIncompleteMember(IncompleteMemberSyntax node)
    {
      var attributeLists = this.VisitList(node.AttributeLists);
      var modifiers = this.VisitList(node.Modifiers);
      var type = (TypeSyntax)this.Visit(node.Type);
      return node.Update(attributeLists, modifiers, type);
    }

    public override CSharpSyntaxNode VisitSkippedTokensTrivia(SkippedTokensTriviaSyntax node)
    {
      var tokens = this.VisitList(node.Tokens);
      return node.Update(tokens);
    }

    public override CSharpSyntaxNode VisitDocumentationCommentTrivia(DocumentationCommentTriviaSyntax node)
    {
      var content = this.VisitList(node.Content);
      var endOfComment = (SyntaxToken)this.Visit(node.EndOfComment);
      return node.Update(content, endOfComment);
    }

    public override CSharpSyntaxNode VisitTypeCref(TypeCrefSyntax node)
    {
      var type = (TypeSyntax)this.Visit(node.Type);
      return node.Update(type);
    }

    public override CSharpSyntaxNode VisitQualifiedCref(QualifiedCrefSyntax node)
    {
      var container = (TypeSyntax)this.Visit(node.Container);
      var dotToken = (SyntaxToken)this.Visit(node.DotToken);
      var member = (MemberCrefSyntax)this.Visit(node.Member);
      return node.Update(container, dotToken, member);
    }

    public override CSharpSyntaxNode VisitNameMemberCref(NameMemberCrefSyntax node)
    {
      var name = (TypeSyntax)this.Visit(node.Name);
      var parameters = (CrefParameterListSyntax)this.Visit(node.Parameters);
      return node.Update(name, parameters);
    }

    public override CSharpSyntaxNode VisitIndexerMemberCref(IndexerMemberCrefSyntax node)
    {
      var thisKeyword = (SyntaxToken)this.Visit(node.ThisKeyword);
      var parameters = (CrefBracketedParameterListSyntax)this.Visit(node.Parameters);
      return node.Update(thisKeyword, parameters);
    }

    public override CSharpSyntaxNode VisitOperatorMemberCref(OperatorMemberCrefSyntax node)
    {
      var operatorKeyword = (SyntaxToken)this.Visit(node.OperatorKeyword);
      var operatorToken = (SyntaxToken)this.Visit(node.OperatorToken);
      var parameters = (CrefParameterListSyntax)this.Visit(node.Parameters);
      return node.Update(operatorKeyword, operatorToken, parameters);
    }

    public override CSharpSyntaxNode VisitConversionOperatorMemberCref(ConversionOperatorMemberCrefSyntax node)
    {
      var implicitOrExplicitKeyword = (SyntaxToken)this.Visit(node.ImplicitOrExplicitKeyword);
      var operatorKeyword = (SyntaxToken)this.Visit(node.OperatorKeyword);
      var type = (TypeSyntax)this.Visit(node.Type);
      var parameters = (CrefParameterListSyntax)this.Visit(node.Parameters);
      return node.Update(implicitOrExplicitKeyword, operatorKeyword, type, parameters);
    }

    public override CSharpSyntaxNode VisitCrefParameterList(CrefParameterListSyntax node)
    {
      var openParenToken = (SyntaxToken)this.Visit(node.OpenParenToken);
      var parameters = this.VisitList(node.Parameters);
      var closeParenToken = (SyntaxToken)this.Visit(node.CloseParenToken);
      return node.Update(openParenToken, parameters, closeParenToken);
    }

    public override CSharpSyntaxNode VisitCrefBracketedParameterList(CrefBracketedParameterListSyntax node)
    {
      var openBracketToken = (SyntaxToken)this.Visit(node.OpenBracketToken);
      var parameters = this.VisitList(node.Parameters);
      var closeBracketToken = (SyntaxToken)this.Visit(node.CloseBracketToken);
      return node.Update(openBracketToken, parameters, closeBracketToken);
    }

    public override CSharpSyntaxNode VisitCrefParameter(CrefParameterSyntax node)
    {
      var refKindKeyword = (SyntaxToken)this.Visit(node.RefKindKeyword);
      var type = (TypeSyntax)this.Visit(node.Type);
      return node.Update(refKindKeyword, type);
    }

    public override CSharpSyntaxNode VisitXmlElement(XmlElementSyntax node)
    {
      var startTag = (XmlElementStartTagSyntax)this.Visit(node.StartTag);
      var content = this.VisitList(node.Content);
      var endTag = (XmlElementEndTagSyntax)this.Visit(node.EndTag);
      return node.Update(startTag, content, endTag);
    }

    public override CSharpSyntaxNode VisitXmlElementStartTag(XmlElementStartTagSyntax node)
    {
      var lessThanToken = (SyntaxToken)this.Visit(node.LessThanToken);
      var name = (XmlNameSyntax)this.Visit(node.Name);
      var attributes = this.VisitList(node.Attributes);
      var greaterThanToken = (SyntaxToken)this.Visit(node.GreaterThanToken);
      return node.Update(lessThanToken, name, attributes, greaterThanToken);
    }

    public override CSharpSyntaxNode VisitXmlElementEndTag(XmlElementEndTagSyntax node)
    {
      var lessThanSlashToken = (SyntaxToken)this.Visit(node.LessThanSlashToken);
      var name = (XmlNameSyntax)this.Visit(node.Name);
      var greaterThanToken = (SyntaxToken)this.Visit(node.GreaterThanToken);
      return node.Update(lessThanSlashToken, name, greaterThanToken);
    }

    public override CSharpSyntaxNode VisitXmlEmptyElement(XmlEmptyElementSyntax node)
    {
      var lessThanToken = (SyntaxToken)this.Visit(node.LessThanToken);
      var name = (XmlNameSyntax)this.Visit(node.Name);
      var attributes = this.VisitList(node.Attributes);
      var slashGreaterThanToken = (SyntaxToken)this.Visit(node.SlashGreaterThanToken);
      return node.Update(lessThanToken, name, attributes, slashGreaterThanToken);
    }

    public override CSharpSyntaxNode VisitXmlName(XmlNameSyntax node)
    {
      var prefix = (XmlPrefixSyntax)this.Visit(node.Prefix);
      var localName = (SyntaxToken)this.Visit(node.LocalName);
      return node.Update(prefix, localName);
    }

    public override CSharpSyntaxNode VisitXmlPrefix(XmlPrefixSyntax node)
    {
      var prefix = (SyntaxToken)this.Visit(node.Prefix);
      var colonToken = (SyntaxToken)this.Visit(node.ColonToken);
      return node.Update(prefix, colonToken);
    }

    public override CSharpSyntaxNode VisitXmlTextAttribute(XmlTextAttributeSyntax node)
    {
      var name = (XmlNameSyntax)this.Visit(node.Name);
      var equalsToken = (SyntaxToken)this.Visit(node.EqualsToken);
      var startQuoteToken = (SyntaxToken)this.Visit(node.StartQuoteToken);
      var textTokens = this.VisitList(node.TextTokens);
      var endQuoteToken = (SyntaxToken)this.Visit(node.EndQuoteToken);
      return node.Update(name, equalsToken, startQuoteToken, textTokens, endQuoteToken);
    }

    public override CSharpSyntaxNode VisitXmlCrefAttribute(XmlCrefAttributeSyntax node)
    {
      var name = (XmlNameSyntax)this.Visit(node.Name);
      var equalsToken = (SyntaxToken)this.Visit(node.EqualsToken);
      var startQuoteToken = (SyntaxToken)this.Visit(node.StartQuoteToken);
      var cref = (CrefSyntax)this.Visit(node.Cref);
      var endQuoteToken = (SyntaxToken)this.Visit(node.EndQuoteToken);
      return node.Update(name, equalsToken, startQuoteToken, cref, endQuoteToken);
    }

    public override CSharpSyntaxNode VisitXmlNameAttribute(XmlNameAttributeSyntax node)
    {
      var name = (XmlNameSyntax)this.Visit(node.Name);
      var equalsToken = (SyntaxToken)this.Visit(node.EqualsToken);
      var startQuoteToken = (SyntaxToken)this.Visit(node.StartQuoteToken);
      var identifier = (IdentifierNameSyntax)this.Visit(node.Identifier);
      var endQuoteToken = (SyntaxToken)this.Visit(node.EndQuoteToken);
      return node.Update(name, equalsToken, startQuoteToken, identifier, endQuoteToken);
    }

    public override CSharpSyntaxNode VisitXmlText(XmlTextSyntax node)
    {
      var textTokens = this.VisitList(node.TextTokens);
      return node.Update(textTokens);
    }

    public override CSharpSyntaxNode VisitXmlCDataSection(XmlCDataSectionSyntax node)
    {
      var startCDataToken = (SyntaxToken)this.Visit(node.StartCDataToken);
      var textTokens = this.VisitList(node.TextTokens);
      var endCDataToken = (SyntaxToken)this.Visit(node.EndCDataToken);
      return node.Update(startCDataToken, textTokens, endCDataToken);
    }

    public override CSharpSyntaxNode VisitXmlProcessingInstruction(XmlProcessingInstructionSyntax node)
    {
      var startProcessingInstructionToken = (SyntaxToken)this.Visit(node.StartProcessingInstructionToken);
      var name = (XmlNameSyntax)this.Visit(node.Name);
      var textTokens = this.VisitList(node.TextTokens);
      var endProcessingInstructionToken = (SyntaxToken)this.Visit(node.EndProcessingInstructionToken);
      return node.Update(startProcessingInstructionToken, name, textTokens, endProcessingInstructionToken);
    }

    public override CSharpSyntaxNode VisitXmlComment(XmlCommentSyntax node)
    {
      var lessThanExclamationMinusMinusToken = (SyntaxToken)this.Visit(node.LessThanExclamationMinusMinusToken);
      var textTokens = this.VisitList(node.TextTokens);
      var minusMinusGreaterThanToken = (SyntaxToken)this.Visit(node.MinusMinusGreaterThanToken);
      return node.Update(lessThanExclamationMinusMinusToken, textTokens, minusMinusGreaterThanToken);
    }

    public override CSharpSyntaxNode VisitIfDirectiveTrivia(IfDirectiveTriviaSyntax node)
    {
      var hashToken = (SyntaxToken)this.Visit(node.HashToken);
      var ifKeyword = (SyntaxToken)this.Visit(node.IfKeyword);
      var condition = (ExpressionSyntax)this.Visit(node.Condition);
      var endOfDirectiveToken = (SyntaxToken)this.Visit(node.EndOfDirectiveToken);
      return node.Update(hashToken, ifKeyword, condition, endOfDirectiveToken, node.IsActive, node.BranchTaken, node.ConditionValue);
    }

    public override CSharpSyntaxNode VisitElifDirectiveTrivia(ElifDirectiveTriviaSyntax node)
    {
      var hashToken = (SyntaxToken)this.Visit(node.HashToken);
      var elifKeyword = (SyntaxToken)this.Visit(node.ElifKeyword);
      var condition = (ExpressionSyntax)this.Visit(node.Condition);
      var endOfDirectiveToken = (SyntaxToken)this.Visit(node.EndOfDirectiveToken);
      return node.Update(hashToken, elifKeyword, condition, endOfDirectiveToken, node.IsActive, node.BranchTaken, node.ConditionValue);
    }

    public override CSharpSyntaxNode VisitElseDirectiveTrivia(ElseDirectiveTriviaSyntax node)
    {
      var hashToken = (SyntaxToken)this.Visit(node.HashToken);
      var elseKeyword = (SyntaxToken)this.Visit(node.ElseKeyword);
      var endOfDirectiveToken = (SyntaxToken)this.Visit(node.EndOfDirectiveToken);
      return node.Update(hashToken, elseKeyword, endOfDirectiveToken, node.IsActive, node.BranchTaken);
    }

    public override CSharpSyntaxNode VisitEndIfDirectiveTrivia(EndIfDirectiveTriviaSyntax node)
    {
      var hashToken = (SyntaxToken)this.Visit(node.HashToken);
      var endIfKeyword = (SyntaxToken)this.Visit(node.EndIfKeyword);
      var endOfDirectiveToken = (SyntaxToken)this.Visit(node.EndOfDirectiveToken);
      return node.Update(hashToken, endIfKeyword, endOfDirectiveToken, node.IsActive);
    }

    public override CSharpSyntaxNode VisitRegionDirectiveTrivia(RegionDirectiveTriviaSyntax node)
    {
      var hashToken = (SyntaxToken)this.Visit(node.HashToken);
      var regionKeyword = (SyntaxToken)this.Visit(node.RegionKeyword);
      var endOfDirectiveToken = (SyntaxToken)this.Visit(node.EndOfDirectiveToken);
      return node.Update(hashToken, regionKeyword, endOfDirectiveToken, node.IsActive);
    }

    public override CSharpSyntaxNode VisitEndRegionDirectiveTrivia(EndRegionDirectiveTriviaSyntax node)
    {
      var hashToken = (SyntaxToken)this.Visit(node.HashToken);
      var endRegionKeyword = (SyntaxToken)this.Visit(node.EndRegionKeyword);
      var endOfDirectiveToken = (SyntaxToken)this.Visit(node.EndOfDirectiveToken);
      return node.Update(hashToken, endRegionKeyword, endOfDirectiveToken, node.IsActive);
    }

    public override CSharpSyntaxNode VisitErrorDirectiveTrivia(ErrorDirectiveTriviaSyntax node)
    {
      var hashToken = (SyntaxToken)this.Visit(node.HashToken);
      var errorKeyword = (SyntaxToken)this.Visit(node.ErrorKeyword);
      var endOfDirectiveToken = (SyntaxToken)this.Visit(node.EndOfDirectiveToken);
      return node.Update(hashToken, errorKeyword, endOfDirectiveToken, node.IsActive);
    }

    public override CSharpSyntaxNode VisitWarningDirectiveTrivia(WarningDirectiveTriviaSyntax node)
    {
      var hashToken = (SyntaxToken)this.Visit(node.HashToken);
      var warningKeyword = (SyntaxToken)this.Visit(node.WarningKeyword);
      var endOfDirectiveToken = (SyntaxToken)this.Visit(node.EndOfDirectiveToken);
      return node.Update(hashToken, warningKeyword, endOfDirectiveToken, node.IsActive);
    }

    public override CSharpSyntaxNode VisitBadDirectiveTrivia(BadDirectiveTriviaSyntax node)
    {
      var hashToken = (SyntaxToken)this.Visit(node.HashToken);
      var identifier = (SyntaxToken)this.Visit(node.Identifier);
      var endOfDirectiveToken = (SyntaxToken)this.Visit(node.EndOfDirectiveToken);
      return node.Update(hashToken, identifier, endOfDirectiveToken, node.IsActive);
    }

    public override CSharpSyntaxNode VisitDefineDirectiveTrivia(DefineDirectiveTriviaSyntax node)
    {
      var hashToken = (SyntaxToken)this.Visit(node.HashToken);
      var defineKeyword = (SyntaxToken)this.Visit(node.DefineKeyword);
      var name = (SyntaxToken)this.Visit(node.Name);
      var endOfDirectiveToken = (SyntaxToken)this.Visit(node.EndOfDirectiveToken);
      return node.Update(hashToken, defineKeyword, name, endOfDirectiveToken, node.IsActive);
    }

    public override CSharpSyntaxNode VisitUndefDirectiveTrivia(UndefDirectiveTriviaSyntax node)
    {
      var hashToken = (SyntaxToken)this.Visit(node.HashToken);
      var undefKeyword = (SyntaxToken)this.Visit(node.UndefKeyword);
      var name = (SyntaxToken)this.Visit(node.Name);
      var endOfDirectiveToken = (SyntaxToken)this.Visit(node.EndOfDirectiveToken);
      return node.Update(hashToken, undefKeyword, name, endOfDirectiveToken, node.IsActive);
    }

    public override CSharpSyntaxNode VisitLineDirectiveTrivia(LineDirectiveTriviaSyntax node)
    {
      var hashToken = (SyntaxToken)this.Visit(node.HashToken);
      var lineKeyword = (SyntaxToken)this.Visit(node.LineKeyword);
      var line = (SyntaxToken)this.Visit(node.Line);
      var file = (SyntaxToken)this.Visit(node.File);
      var endOfDirectiveToken = (SyntaxToken)this.Visit(node.EndOfDirectiveToken);
      return node.Update(hashToken, lineKeyword, line, file, endOfDirectiveToken, node.IsActive);
    }

    public override CSharpSyntaxNode VisitPragmaWarningDirectiveTrivia(PragmaWarningDirectiveTriviaSyntax node)
    {
      var hashToken = (SyntaxToken)this.Visit(node.HashToken);
      var pragmaKeyword = (SyntaxToken)this.Visit(node.PragmaKeyword);
      var warningKeyword = (SyntaxToken)this.Visit(node.WarningKeyword);
      var disableOrRestoreKeyword = (SyntaxToken)this.Visit(node.DisableOrRestoreKeyword);
      var errorCodes = this.VisitList(node.ErrorCodes);
      var endOfDirectiveToken = (SyntaxToken)this.Visit(node.EndOfDirectiveToken);
      return node.Update(hashToken, pragmaKeyword, warningKeyword, disableOrRestoreKeyword, errorCodes, endOfDirectiveToken, node.IsActive);
    }

    public override CSharpSyntaxNode VisitPragmaChecksumDirectiveTrivia(PragmaChecksumDirectiveTriviaSyntax node)
    {
      var hashToken = (SyntaxToken)this.Visit(node.HashToken);
      var pragmaKeyword = (SyntaxToken)this.Visit(node.PragmaKeyword);
      var checksumKeyword = (SyntaxToken)this.Visit(node.ChecksumKeyword);
      var file = (SyntaxToken)this.Visit(node.File);
      var guid = (SyntaxToken)this.Visit(node.Guid);
      var bytes = (SyntaxToken)this.Visit(node.Bytes);
      var endOfDirectiveToken = (SyntaxToken)this.Visit(node.EndOfDirectiveToken);
      return node.Update(hashToken, pragmaKeyword, checksumKeyword, file, guid, bytes, endOfDirectiveToken, node.IsActive);
    }

    public override CSharpSyntaxNode VisitReferenceDirectiveTrivia(ReferenceDirectiveTriviaSyntax node)
    {
      var hashToken = (SyntaxToken)this.Visit(node.HashToken);
      var referenceKeyword = (SyntaxToken)this.Visit(node.ReferenceKeyword);
      var file = (SyntaxToken)this.Visit(node.File);
      var endOfDirectiveToken = (SyntaxToken)this.Visit(node.EndOfDirectiveToken);
      return node.Update(hashToken, referenceKeyword, file, endOfDirectiveToken, node.IsActive);
    }

    public override CSharpSyntaxNode VisitLoadDirectiveTrivia(LoadDirectiveTriviaSyntax node)
    {
      var hashToken = (SyntaxToken)this.Visit(node.HashToken);
      var loadKeyword = (SyntaxToken)this.Visit(node.LoadKeyword);
      var file = (SyntaxToken)this.Visit(node.File);
      var endOfDirectiveToken = (SyntaxToken)this.Visit(node.EndOfDirectiveToken);
      return node.Update(hashToken, loadKeyword, file, endOfDirectiveToken, node.IsActive);
    }

    public override CSharpSyntaxNode VisitShebangDirectiveTrivia(ShebangDirectiveTriviaSyntax node)
    {
      var hashToken = (SyntaxToken)this.Visit(node.HashToken);
      var exclamationToken = (SyntaxToken)this.Visit(node.ExclamationToken);
      var endOfDirectiveToken = (SyntaxToken)this.Visit(node.EndOfDirectiveToken);
      return node.Update(hashToken, exclamationToken, endOfDirectiveToken, node.IsActive);
    }

    public override CSharpSyntaxNode VisitNullableDirectiveTrivia(NullableDirectiveTriviaSyntax node)
    {
      var hashToken = (SyntaxToken)this.Visit(node.HashToken);
      var nullableKeyword = (SyntaxToken)this.Visit(node.NullableKeyword);
      var settingToken = (SyntaxToken)this.Visit(node.SettingToken);
      var targetToken = (SyntaxToken)this.Visit(node.TargetToken);
      var endOfDirectiveToken = (SyntaxToken)this.Visit(node.EndOfDirectiveToken);
      return node.Update(hashToken, nullableKeyword, settingToken, targetToken, endOfDirectiveToken, node.IsActive);
    }
  }

  internal partial class ContextAwareSyntax
  {
    private SyntaxFactoryContext context;


    public ContextAwareSyntax(SyntaxFactoryContext context)
    {
        this.context = context;
    }
    public IdentifierNameSyntax IdentifierName(SyntaxToken identifier)
    {
#if DEBUG
      if (identifier == null)
        throw new ArgumentNullException(nameof(identifier));
      switch (identifier.Kind)
      {
        case SyntaxKind.IdentifierToken:
        case SyntaxKind.GlobalKeyword:
          break;
        default:
          throw new ArgumentException(nameof(identifier));
      }
#endif

      int hash;
      var cached = CSharpSyntaxNodeCache.TryGetNode((int)SyntaxKind.IdentifierName, identifier, this.context, out hash);
      if (cached != null) return (IdentifierNameSyntax)cached;

      var result = new IdentifierNameSyntax(SyntaxKind.IdentifierName, identifier, this.context);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public QualifiedNameSyntax QualifiedName(NameSyntax left, SyntaxToken dotToken, SimpleNameSyntax right)
    {
#if DEBUG
      if (left == null)
        throw new ArgumentNullException(nameof(left));
      if (dotToken == null)
        throw new ArgumentNullException(nameof(dotToken));
      switch (dotToken.Kind)
      {
        case SyntaxKind.DotToken:
          break;
        default:
          throw new ArgumentException(nameof(dotToken));
      }
      if (right == null)
        throw new ArgumentNullException(nameof(right));
#endif

      int hash;
      var cached = CSharpSyntaxNodeCache.TryGetNode((int)SyntaxKind.QualifiedName, left, dotToken, right, this.context, out hash);
      if (cached != null) return (QualifiedNameSyntax)cached;

      var result = new QualifiedNameSyntax(SyntaxKind.QualifiedName, left, dotToken, right, this.context);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public GenericNameSyntax GenericName(SyntaxToken identifier, TypeArgumentListSyntax typeArgumentList)
    {
#if DEBUG
      if (identifier == null)
        throw new ArgumentNullException(nameof(identifier));
      switch (identifier.Kind)
      {
        case SyntaxKind.IdentifierToken:
          break;
        default:
          throw new ArgumentException(nameof(identifier));
      }
      if (typeArgumentList == null)
        throw new ArgumentNullException(nameof(typeArgumentList));
#endif

      int hash;
      var cached = CSharpSyntaxNodeCache.TryGetNode((int)SyntaxKind.GenericName, identifier, typeArgumentList, this.context, out hash);
      if (cached != null) return (GenericNameSyntax)cached;

      var result = new GenericNameSyntax(SyntaxKind.GenericName, identifier, typeArgumentList, this.context);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public TypeArgumentListSyntax TypeArgumentList(SyntaxToken lessThanToken, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<TypeSyntax> arguments, SyntaxToken greaterThanToken)
    {
#if DEBUG
      if (lessThanToken == null)
        throw new ArgumentNullException(nameof(lessThanToken));
      switch (lessThanToken.Kind)
      {
        case SyntaxKind.LessThanToken:
          break;
        default:
          throw new ArgumentException(nameof(lessThanToken));
      }
      if (greaterThanToken == null)
        throw new ArgumentNullException(nameof(greaterThanToken));
      switch (greaterThanToken.Kind)
      {
        case SyntaxKind.GreaterThanToken:
          break;
        default:
          throw new ArgumentException(nameof(greaterThanToken));
      }
#endif

      int hash;
      var cached = CSharpSyntaxNodeCache.TryGetNode((int)SyntaxKind.TypeArgumentList, lessThanToken, arguments.Node, greaterThanToken, this.context, out hash);
      if (cached != null) return (TypeArgumentListSyntax)cached;

      var result = new TypeArgumentListSyntax(SyntaxKind.TypeArgumentList, lessThanToken, arguments.Node, greaterThanToken, this.context);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public AliasQualifiedNameSyntax AliasQualifiedName(IdentifierNameSyntax alias, SyntaxToken colonColonToken, SimpleNameSyntax name)
    {
#if DEBUG
      if (alias == null)
        throw new ArgumentNullException(nameof(alias));
      if (colonColonToken == null)
        throw new ArgumentNullException(nameof(colonColonToken));
      switch (colonColonToken.Kind)
      {
        case SyntaxKind.ColonColonToken:
          break;
        default:
          throw new ArgumentException(nameof(colonColonToken));
      }
      if (name == null)
        throw new ArgumentNullException(nameof(name));
#endif

      int hash;
      var cached = CSharpSyntaxNodeCache.TryGetNode((int)SyntaxKind.AliasQualifiedName, alias, colonColonToken, name, this.context, out hash);
      if (cached != null) return (AliasQualifiedNameSyntax)cached;

      var result = new AliasQualifiedNameSyntax(SyntaxKind.AliasQualifiedName, alias, colonColonToken, name, this.context);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public PredefinedTypeSyntax PredefinedType(SyntaxToken keyword)
    {
#if DEBUG
      if (keyword == null)
        throw new ArgumentNullException(nameof(keyword));
      switch (keyword.Kind)
      {
        case SyntaxKind.BoolKeyword:
        case SyntaxKind.ByteKeyword:
        case SyntaxKind.SByteKeyword:
        case SyntaxKind.IntKeyword:
        case SyntaxKind.UIntKeyword:
        case SyntaxKind.ShortKeyword:
        case SyntaxKind.UShortKeyword:
        case SyntaxKind.LongKeyword:
        case SyntaxKind.ULongKeyword:
        case SyntaxKind.FloatKeyword:
        case SyntaxKind.DoubleKeyword:
        case SyntaxKind.DecimalKeyword:
        case SyntaxKind.StringKeyword:
        case SyntaxKind.CharKeyword:
        case SyntaxKind.ObjectKeyword:
        case SyntaxKind.VoidKeyword:
          break;
        default:
          throw new ArgumentException(nameof(keyword));
      }
#endif

      int hash;
      var cached = CSharpSyntaxNodeCache.TryGetNode((int)SyntaxKind.PredefinedType, keyword, this.context, out hash);
      if (cached != null) return (PredefinedTypeSyntax)cached;

      var result = new PredefinedTypeSyntax(SyntaxKind.PredefinedType, keyword, this.context);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public ArrayTypeSyntax ArrayType(TypeSyntax elementType, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<ArrayRankSpecifierSyntax> rankSpecifiers)
    {
#if DEBUG
      if (elementType == null)
        throw new ArgumentNullException(nameof(elementType));
#endif

      int hash;
      var cached = CSharpSyntaxNodeCache.TryGetNode((int)SyntaxKind.ArrayType, elementType, rankSpecifiers.Node, this.context, out hash);
      if (cached != null) return (ArrayTypeSyntax)cached;

      var result = new ArrayTypeSyntax(SyntaxKind.ArrayType, elementType, rankSpecifiers.Node, this.context);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public ArrayRankSpecifierSyntax ArrayRankSpecifier(SyntaxToken openBracketToken, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<ExpressionSyntax> sizes, SyntaxToken closeBracketToken)
    {
#if DEBUG
      if (openBracketToken == null)
        throw new ArgumentNullException(nameof(openBracketToken));
      switch (openBracketToken.Kind)
      {
        case SyntaxKind.OpenBracketToken:
          break;
        default:
          throw new ArgumentException(nameof(openBracketToken));
      }
      if (closeBracketToken == null)
        throw new ArgumentNullException(nameof(closeBracketToken));
      switch (closeBracketToken.Kind)
      {
        case SyntaxKind.CloseBracketToken:
          break;
        default:
          throw new ArgumentException(nameof(closeBracketToken));
      }
#endif

      int hash;
      var cached = CSharpSyntaxNodeCache.TryGetNode((int)SyntaxKind.ArrayRankSpecifier, openBracketToken, sizes.Node, closeBracketToken, this.context, out hash);
      if (cached != null) return (ArrayRankSpecifierSyntax)cached;

      var result = new ArrayRankSpecifierSyntax(SyntaxKind.ArrayRankSpecifier, openBracketToken, sizes.Node, closeBracketToken, this.context);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public PointerTypeSyntax PointerType(TypeSyntax elementType, SyntaxToken asteriskToken)
    {
#if DEBUG
      if (elementType == null)
        throw new ArgumentNullException(nameof(elementType));
      if (asteriskToken == null)
        throw new ArgumentNullException(nameof(asteriskToken));
      switch (asteriskToken.Kind)
      {
        case SyntaxKind.AsteriskToken:
          break;
        default:
          throw new ArgumentException(nameof(asteriskToken));
      }
#endif

      int hash;
      var cached = CSharpSyntaxNodeCache.TryGetNode((int)SyntaxKind.PointerType, elementType, asteriskToken, this.context, out hash);
      if (cached != null) return (PointerTypeSyntax)cached;

      var result = new PointerTypeSyntax(SyntaxKind.PointerType, elementType, asteriskToken, this.context);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public NullableTypeSyntax NullableType(TypeSyntax elementType, SyntaxToken questionToken)
    {
#if DEBUG
      if (elementType == null)
        throw new ArgumentNullException(nameof(elementType));
      if (questionToken == null)
        throw new ArgumentNullException(nameof(questionToken));
      switch (questionToken.Kind)
      {
        case SyntaxKind.QuestionToken:
          break;
        default:
          throw new ArgumentException(nameof(questionToken));
      }
#endif

      int hash;
      var cached = CSharpSyntaxNodeCache.TryGetNode((int)SyntaxKind.NullableType, elementType, questionToken, this.context, out hash);
      if (cached != null) return (NullableTypeSyntax)cached;

      var result = new NullableTypeSyntax(SyntaxKind.NullableType, elementType, questionToken, this.context);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public TupleTypeSyntax TupleType(SyntaxToken openParenToken, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<TupleElementSyntax> elements, SyntaxToken closeParenToken)
    {
#if DEBUG
      if (openParenToken == null)
        throw new ArgumentNullException(nameof(openParenToken));
      switch (openParenToken.Kind)
      {
        case SyntaxKind.OpenParenToken:
          break;
        default:
          throw new ArgumentException(nameof(openParenToken));
      }
      if (closeParenToken == null)
        throw new ArgumentNullException(nameof(closeParenToken));
      switch (closeParenToken.Kind)
      {
        case SyntaxKind.CloseParenToken:
          break;
        default:
          throw new ArgumentException(nameof(closeParenToken));
      }
#endif

      int hash;
      var cached = CSharpSyntaxNodeCache.TryGetNode((int)SyntaxKind.TupleType, openParenToken, elements.Node, closeParenToken, this.context, out hash);
      if (cached != null) return (TupleTypeSyntax)cached;

      var result = new TupleTypeSyntax(SyntaxKind.TupleType, openParenToken, elements.Node, closeParenToken, this.context);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public TupleElementSyntax TupleElement(TypeSyntax type, SyntaxToken identifier)
    {
#if DEBUG
      if (type == null)
        throw new ArgumentNullException(nameof(type));
      if (identifier != null)
      {
      switch (identifier.Kind)
      {
        case SyntaxKind.IdentifierToken:
        case SyntaxKind.None:
          break;
        default:
          throw new ArgumentException(nameof(identifier));
      }
      }
#endif

      int hash;
      var cached = CSharpSyntaxNodeCache.TryGetNode((int)SyntaxKind.TupleElement, type, identifier, this.context, out hash);
      if (cached != null) return (TupleElementSyntax)cached;

      var result = new TupleElementSyntax(SyntaxKind.TupleElement, type, identifier, this.context);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public OmittedTypeArgumentSyntax OmittedTypeArgument(SyntaxToken omittedTypeArgumentToken)
    {
#if DEBUG
      if (omittedTypeArgumentToken == null)
        throw new ArgumentNullException(nameof(omittedTypeArgumentToken));
      switch (omittedTypeArgumentToken.Kind)
      {
        case SyntaxKind.OmittedTypeArgumentToken:
          break;
        default:
          throw new ArgumentException(nameof(omittedTypeArgumentToken));
      }
#endif

      int hash;
      var cached = CSharpSyntaxNodeCache.TryGetNode((int)SyntaxKind.OmittedTypeArgument, omittedTypeArgumentToken, this.context, out hash);
      if (cached != null) return (OmittedTypeArgumentSyntax)cached;

      var result = new OmittedTypeArgumentSyntax(SyntaxKind.OmittedTypeArgument, omittedTypeArgumentToken, this.context);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public RefTypeSyntax RefType(SyntaxToken refKeyword, SyntaxToken readOnlyKeyword, TypeSyntax type)
    {
#if DEBUG
      if (refKeyword == null)
        throw new ArgumentNullException(nameof(refKeyword));
      switch (refKeyword.Kind)
      {
        case SyntaxKind.RefKeyword:
          break;
        default:
          throw new ArgumentException(nameof(refKeyword));
      }
      if (readOnlyKeyword != null)
      {
      switch (readOnlyKeyword.Kind)
      {
        case SyntaxKind.ReadOnlyKeyword:
        case SyntaxKind.None:
          break;
        default:
          throw new ArgumentException(nameof(readOnlyKeyword));
      }
      }
      if (type == null)
        throw new ArgumentNullException(nameof(type));
#endif

      int hash;
      var cached = CSharpSyntaxNodeCache.TryGetNode((int)SyntaxKind.RefType, refKeyword, readOnlyKeyword, type, this.context, out hash);
      if (cached != null) return (RefTypeSyntax)cached;

      var result = new RefTypeSyntax(SyntaxKind.RefType, refKeyword, readOnlyKeyword, type, this.context);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public ParenthesizedExpressionSyntax ParenthesizedExpression(SyntaxToken openParenToken, ExpressionSyntax expression, SyntaxToken closeParenToken)
    {
#if DEBUG
      if (openParenToken == null)
        throw new ArgumentNullException(nameof(openParenToken));
      switch (openParenToken.Kind)
      {
        case SyntaxKind.OpenParenToken:
          break;
        default:
          throw new ArgumentException(nameof(openParenToken));
      }
      if (expression == null)
        throw new ArgumentNullException(nameof(expression));
      if (closeParenToken == null)
        throw new ArgumentNullException(nameof(closeParenToken));
      switch (closeParenToken.Kind)
      {
        case SyntaxKind.CloseParenToken:
          break;
        default:
          throw new ArgumentException(nameof(closeParenToken));
      }
#endif

      int hash;
      var cached = CSharpSyntaxNodeCache.TryGetNode((int)SyntaxKind.ParenthesizedExpression, openParenToken, expression, closeParenToken, this.context, out hash);
      if (cached != null) return (ParenthesizedExpressionSyntax)cached;

      var result = new ParenthesizedExpressionSyntax(SyntaxKind.ParenthesizedExpression, openParenToken, expression, closeParenToken, this.context);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public TupleExpressionSyntax TupleExpression(SyntaxToken openParenToken, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<ArgumentSyntax> arguments, SyntaxToken closeParenToken)
    {
#if DEBUG
      if (openParenToken == null)
        throw new ArgumentNullException(nameof(openParenToken));
      switch (openParenToken.Kind)
      {
        case SyntaxKind.OpenParenToken:
          break;
        default:
          throw new ArgumentException(nameof(openParenToken));
      }
      if (closeParenToken == null)
        throw new ArgumentNullException(nameof(closeParenToken));
      switch (closeParenToken.Kind)
      {
        case SyntaxKind.CloseParenToken:
          break;
        default:
          throw new ArgumentException(nameof(closeParenToken));
      }
#endif

      int hash;
      var cached = CSharpSyntaxNodeCache.TryGetNode((int)SyntaxKind.TupleExpression, openParenToken, arguments.Node, closeParenToken, this.context, out hash);
      if (cached != null) return (TupleExpressionSyntax)cached;

      var result = new TupleExpressionSyntax(SyntaxKind.TupleExpression, openParenToken, arguments.Node, closeParenToken, this.context);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public PrefixUnaryExpressionSyntax PrefixUnaryExpression(SyntaxKind kind, SyntaxToken operatorToken, ExpressionSyntax operand)
    {
      switch (kind)
      {
        case SyntaxKind.UnaryPlusExpression:
        case SyntaxKind.UnaryMinusExpression:
        case SyntaxKind.BitwiseNotExpression:
        case SyntaxKind.LogicalNotExpression:
        case SyntaxKind.PreIncrementExpression:
        case SyntaxKind.PreDecrementExpression:
        case SyntaxKind.AddressOfExpression:
        case SyntaxKind.PointerIndirectionExpression:
        case SyntaxKind.IndexExpression:
          break;
        default:
          throw new ArgumentException(nameof(kind));
      }
#if DEBUG
      if (operatorToken == null)
        throw new ArgumentNullException(nameof(operatorToken));
      switch (operatorToken.Kind)
      {
        case SyntaxKind.PlusToken:
        case SyntaxKind.MinusToken:
        case SyntaxKind.TildeToken:
        case SyntaxKind.ExclamationToken:
        case SyntaxKind.PlusPlusToken:
        case SyntaxKind.MinusMinusToken:
        case SyntaxKind.AmpersandToken:
        case SyntaxKind.AsteriskToken:
        case SyntaxKind.CaretToken:
          break;
        default:
          throw new ArgumentException(nameof(operatorToken));
      }
      if (operand == null)
        throw new ArgumentNullException(nameof(operand));
#endif

      int hash;
      var cached = CSharpSyntaxNodeCache.TryGetNode((int)kind, operatorToken, operand, this.context, out hash);
      if (cached != null) return (PrefixUnaryExpressionSyntax)cached;

      var result = new PrefixUnaryExpressionSyntax(kind, operatorToken, operand, this.context);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public AwaitExpressionSyntax AwaitExpression(SyntaxToken awaitKeyword, ExpressionSyntax expression)
    {
#if DEBUG
      if (awaitKeyword == null)
        throw new ArgumentNullException(nameof(awaitKeyword));
      switch (awaitKeyword.Kind)
      {
        case SyntaxKind.AwaitKeyword:
          break;
        default:
          throw new ArgumentException(nameof(awaitKeyword));
      }
      if (expression == null)
        throw new ArgumentNullException(nameof(expression));
#endif

      int hash;
      var cached = CSharpSyntaxNodeCache.TryGetNode((int)SyntaxKind.AwaitExpression, awaitKeyword, expression, this.context, out hash);
      if (cached != null) return (AwaitExpressionSyntax)cached;

      var result = new AwaitExpressionSyntax(SyntaxKind.AwaitExpression, awaitKeyword, expression, this.context);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public PostfixUnaryExpressionSyntax PostfixUnaryExpression(SyntaxKind kind, ExpressionSyntax operand, SyntaxToken operatorToken)
    {
      switch (kind)
      {
        case SyntaxKind.PostIncrementExpression:
        case SyntaxKind.PostDecrementExpression:
        case SyntaxKind.SuppressNullableWarningExpression:
          break;
        default:
          throw new ArgumentException(nameof(kind));
      }
#if DEBUG
      if (operand == null)
        throw new ArgumentNullException(nameof(operand));
      if (operatorToken == null)
        throw new ArgumentNullException(nameof(operatorToken));
      switch (operatorToken.Kind)
      {
        case SyntaxKind.PlusPlusToken:
        case SyntaxKind.MinusMinusToken:
        case SyntaxKind.ExclamationToken:
          break;
        default:
          throw new ArgumentException(nameof(operatorToken));
      }
#endif

      int hash;
      var cached = CSharpSyntaxNodeCache.TryGetNode((int)kind, operand, operatorToken, this.context, out hash);
      if (cached != null) return (PostfixUnaryExpressionSyntax)cached;

      var result = new PostfixUnaryExpressionSyntax(kind, operand, operatorToken, this.context);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public MemberAccessExpressionSyntax MemberAccessExpression(SyntaxKind kind, ExpressionSyntax expression, SyntaxToken operatorToken, SimpleNameSyntax name)
    {
      switch (kind)
      {
        case SyntaxKind.SimpleMemberAccessExpression:
        case SyntaxKind.PointerMemberAccessExpression:
          break;
        default:
          throw new ArgumentException(nameof(kind));
      }
#if DEBUG
      if (expression == null)
        throw new ArgumentNullException(nameof(expression));
      if (operatorToken == null)
        throw new ArgumentNullException(nameof(operatorToken));
      switch (operatorToken.Kind)
      {
        case SyntaxKind.DotToken:
        case SyntaxKind.MinusGreaterThanToken:
          break;
        default:
          throw new ArgumentException(nameof(operatorToken));
      }
      if (name == null)
        throw new ArgumentNullException(nameof(name));
#endif

      int hash;
      var cached = CSharpSyntaxNodeCache.TryGetNode((int)kind, expression, operatorToken, name, this.context, out hash);
      if (cached != null) return (MemberAccessExpressionSyntax)cached;

      var result = new MemberAccessExpressionSyntax(kind, expression, operatorToken, name, this.context);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public ConditionalAccessExpressionSyntax ConditionalAccessExpression(ExpressionSyntax expression, SyntaxToken operatorToken, ExpressionSyntax whenNotNull)
    {
#if DEBUG
      if (expression == null)
        throw new ArgumentNullException(nameof(expression));
      if (operatorToken == null)
        throw new ArgumentNullException(nameof(operatorToken));
      switch (operatorToken.Kind)
      {
        case SyntaxKind.QuestionToken:
          break;
        default:
          throw new ArgumentException(nameof(operatorToken));
      }
      if (whenNotNull == null)
        throw new ArgumentNullException(nameof(whenNotNull));
#endif

      int hash;
      var cached = CSharpSyntaxNodeCache.TryGetNode((int)SyntaxKind.ConditionalAccessExpression, expression, operatorToken, whenNotNull, this.context, out hash);
      if (cached != null) return (ConditionalAccessExpressionSyntax)cached;

      var result = new ConditionalAccessExpressionSyntax(SyntaxKind.ConditionalAccessExpression, expression, operatorToken, whenNotNull, this.context);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public MemberBindingExpressionSyntax MemberBindingExpression(SyntaxToken operatorToken, SimpleNameSyntax name)
    {
#if DEBUG
      if (operatorToken == null)
        throw new ArgumentNullException(nameof(operatorToken));
      switch (operatorToken.Kind)
      {
        case SyntaxKind.DotToken:
          break;
        default:
          throw new ArgumentException(nameof(operatorToken));
      }
      if (name == null)
        throw new ArgumentNullException(nameof(name));
#endif

      int hash;
      var cached = CSharpSyntaxNodeCache.TryGetNode((int)SyntaxKind.MemberBindingExpression, operatorToken, name, this.context, out hash);
      if (cached != null) return (MemberBindingExpressionSyntax)cached;

      var result = new MemberBindingExpressionSyntax(SyntaxKind.MemberBindingExpression, operatorToken, name, this.context);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public ElementBindingExpressionSyntax ElementBindingExpression(BracketedArgumentListSyntax argumentList)
    {
#if DEBUG
      if (argumentList == null)
        throw new ArgumentNullException(nameof(argumentList));
#endif

      int hash;
      var cached = CSharpSyntaxNodeCache.TryGetNode((int)SyntaxKind.ElementBindingExpression, argumentList, this.context, out hash);
      if (cached != null) return (ElementBindingExpressionSyntax)cached;

      var result = new ElementBindingExpressionSyntax(SyntaxKind.ElementBindingExpression, argumentList, this.context);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public RangeExpressionSyntax RangeExpression(ExpressionSyntax leftOperand, SyntaxToken operatorToken, ExpressionSyntax rightOperand)
    {
#if DEBUG
      if (operatorToken == null)
        throw new ArgumentNullException(nameof(operatorToken));
      switch (operatorToken.Kind)
      {
        case SyntaxKind.DotDotToken:
          break;
        default:
          throw new ArgumentException(nameof(operatorToken));
      }
#endif

      int hash;
      var cached = CSharpSyntaxNodeCache.TryGetNode((int)SyntaxKind.RangeExpression, leftOperand, operatorToken, rightOperand, this.context, out hash);
      if (cached != null) return (RangeExpressionSyntax)cached;

      var result = new RangeExpressionSyntax(SyntaxKind.RangeExpression, leftOperand, operatorToken, rightOperand, this.context);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public ImplicitElementAccessSyntax ImplicitElementAccess(BracketedArgumentListSyntax argumentList)
    {
#if DEBUG
      if (argumentList == null)
        throw new ArgumentNullException(nameof(argumentList));
#endif

      int hash;
      var cached = CSharpSyntaxNodeCache.TryGetNode((int)SyntaxKind.ImplicitElementAccess, argumentList, this.context, out hash);
      if (cached != null) return (ImplicitElementAccessSyntax)cached;

      var result = new ImplicitElementAccessSyntax(SyntaxKind.ImplicitElementAccess, argumentList, this.context);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public BinaryExpressionSyntax BinaryExpression(SyntaxKind kind, ExpressionSyntax left, SyntaxToken operatorToken, ExpressionSyntax right)
    {
      switch (kind)
      {
        case SyntaxKind.AddExpression:
        case SyntaxKind.SubtractExpression:
        case SyntaxKind.MultiplyExpression:
        case SyntaxKind.DivideExpression:
        case SyntaxKind.ModuloExpression:
        case SyntaxKind.LeftShiftExpression:
        case SyntaxKind.RightShiftExpression:
        case SyntaxKind.LogicalOrExpression:
        case SyntaxKind.LogicalAndExpression:
        case SyntaxKind.BitwiseOrExpression:
        case SyntaxKind.BitwiseAndExpression:
        case SyntaxKind.ExclusiveOrExpression:
        case SyntaxKind.EqualsExpression:
        case SyntaxKind.NotEqualsExpression:
        case SyntaxKind.LessThanExpression:
        case SyntaxKind.LessThanOrEqualExpression:
        case SyntaxKind.GreaterThanExpression:
        case SyntaxKind.GreaterThanOrEqualExpression:
        case SyntaxKind.IsExpression:
        case SyntaxKind.AsExpression:
        case SyntaxKind.CoalesceExpression:
          break;
        default:
          throw new ArgumentException(nameof(kind));
      }
#if DEBUG
      if (left == null)
        throw new ArgumentNullException(nameof(left));
      if (operatorToken == null)
        throw new ArgumentNullException(nameof(operatorToken));
      switch (operatorToken.Kind)
      {
        case SyntaxKind.PlusToken:
        case SyntaxKind.MinusToken:
        case SyntaxKind.AsteriskToken:
        case SyntaxKind.SlashToken:
        case SyntaxKind.PercentToken:
        case SyntaxKind.LessThanLessThanToken:
        case SyntaxKind.GreaterThanGreaterThanToken:
        case SyntaxKind.BarBarToken:
        case SyntaxKind.AmpersandAmpersandToken:
        case SyntaxKind.BarToken:
        case SyntaxKind.AmpersandToken:
        case SyntaxKind.CaretToken:
        case SyntaxKind.EqualsEqualsToken:
        case SyntaxKind.ExclamationEqualsToken:
        case SyntaxKind.LessThanToken:
        case SyntaxKind.LessThanEqualsToken:
        case SyntaxKind.GreaterThanToken:
        case SyntaxKind.GreaterThanEqualsToken:
        case SyntaxKind.IsKeyword:
        case SyntaxKind.AsKeyword:
        case SyntaxKind.QuestionQuestionToken:
          break;
        default:
          throw new ArgumentException(nameof(operatorToken));
      }
      if (right == null)
        throw new ArgumentNullException(nameof(right));
#endif

      int hash;
      var cached = CSharpSyntaxNodeCache.TryGetNode((int)kind, left, operatorToken, right, this.context, out hash);
      if (cached != null) return (BinaryExpressionSyntax)cached;

      var result = new BinaryExpressionSyntax(kind, left, operatorToken, right, this.context);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public AssignmentExpressionSyntax AssignmentExpression(SyntaxKind kind, ExpressionSyntax left, SyntaxToken operatorToken, ExpressionSyntax right)
    {
      switch (kind)
      {
        case SyntaxKind.SimpleAssignmentExpression:
        case SyntaxKind.AddAssignmentExpression:
        case SyntaxKind.SubtractAssignmentExpression:
        case SyntaxKind.MultiplyAssignmentExpression:
        case SyntaxKind.DivideAssignmentExpression:
        case SyntaxKind.ModuloAssignmentExpression:
        case SyntaxKind.AndAssignmentExpression:
        case SyntaxKind.ExclusiveOrAssignmentExpression:
        case SyntaxKind.OrAssignmentExpression:
        case SyntaxKind.LeftShiftAssignmentExpression:
        case SyntaxKind.RightShiftAssignmentExpression:
        case SyntaxKind.CoalesceAssignmentExpression:
          break;
        default:
          throw new ArgumentException(nameof(kind));
      }
#if DEBUG
      if (left == null)
        throw new ArgumentNullException(nameof(left));
      if (operatorToken == null)
        throw new ArgumentNullException(nameof(operatorToken));
      switch (operatorToken.Kind)
      {
        case SyntaxKind.EqualsToken:
        case SyntaxKind.PlusEqualsToken:
        case SyntaxKind.MinusEqualsToken:
        case SyntaxKind.AsteriskEqualsToken:
        case SyntaxKind.SlashEqualsToken:
        case SyntaxKind.PercentEqualsToken:
        case SyntaxKind.AmpersandEqualsToken:
        case SyntaxKind.CaretEqualsToken:
        case SyntaxKind.BarEqualsToken:
        case SyntaxKind.LessThanLessThanEqualsToken:
        case SyntaxKind.GreaterThanGreaterThanEqualsToken:
        case SyntaxKind.QuestionQuestionEqualsToken:
          break;
        default:
          throw new ArgumentException(nameof(operatorToken));
      }
      if (right == null)
        throw new ArgumentNullException(nameof(right));
#endif

      int hash;
      var cached = CSharpSyntaxNodeCache.TryGetNode((int)kind, left, operatorToken, right, this.context, out hash);
      if (cached != null) return (AssignmentExpressionSyntax)cached;

      var result = new AssignmentExpressionSyntax(kind, left, operatorToken, right, this.context);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public ConditionalExpressionSyntax ConditionalExpression(ExpressionSyntax condition, SyntaxToken questionToken, ExpressionSyntax whenTrue, SyntaxToken colonToken, ExpressionSyntax whenFalse)
    {
#if DEBUG
      if (condition == null)
        throw new ArgumentNullException(nameof(condition));
      if (questionToken == null)
        throw new ArgumentNullException(nameof(questionToken));
      switch (questionToken.Kind)
      {
        case SyntaxKind.QuestionToken:
          break;
        default:
          throw new ArgumentException(nameof(questionToken));
      }
      if (whenTrue == null)
        throw new ArgumentNullException(nameof(whenTrue));
      if (colonToken == null)
        throw new ArgumentNullException(nameof(colonToken));
      switch (colonToken.Kind)
      {
        case SyntaxKind.ColonToken:
          break;
        default:
          throw new ArgumentException(nameof(colonToken));
      }
      if (whenFalse == null)
        throw new ArgumentNullException(nameof(whenFalse));
#endif

      return new ConditionalExpressionSyntax(SyntaxKind.ConditionalExpression, condition, questionToken, whenTrue, colonToken, whenFalse, this.context);
    }

    public ThisExpressionSyntax ThisExpression(SyntaxToken token)
    {
#if DEBUG
      if (token == null)
        throw new ArgumentNullException(nameof(token));
      switch (token.Kind)
      {
        case SyntaxKind.ThisKeyword:
          break;
        default:
          throw new ArgumentException(nameof(token));
      }
#endif

      int hash;
      var cached = CSharpSyntaxNodeCache.TryGetNode((int)SyntaxKind.ThisExpression, token, this.context, out hash);
      if (cached != null) return (ThisExpressionSyntax)cached;

      var result = new ThisExpressionSyntax(SyntaxKind.ThisExpression, token, this.context);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public BaseExpressionSyntax BaseExpression(SyntaxToken token)
    {
#if DEBUG
      if (token == null)
        throw new ArgumentNullException(nameof(token));
      switch (token.Kind)
      {
        case SyntaxKind.BaseKeyword:
          break;
        default:
          throw new ArgumentException(nameof(token));
      }
#endif

      int hash;
      var cached = CSharpSyntaxNodeCache.TryGetNode((int)SyntaxKind.BaseExpression, token, this.context, out hash);
      if (cached != null) return (BaseExpressionSyntax)cached;

      var result = new BaseExpressionSyntax(SyntaxKind.BaseExpression, token, this.context);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public LiteralExpressionSyntax LiteralExpression(SyntaxKind kind, SyntaxToken token)
    {
      switch (kind)
      {
        case SyntaxKind.ArgListExpression:
        case SyntaxKind.NumericLiteralExpression:
        case SyntaxKind.StringLiteralExpression:
        case SyntaxKind.CharacterLiteralExpression:
        case SyntaxKind.TrueLiteralExpression:
        case SyntaxKind.FalseLiteralExpression:
        case SyntaxKind.NullLiteralExpression:
        case SyntaxKind.DefaultLiteralExpression:
          break;
        default:
          throw new ArgumentException(nameof(kind));
      }
#if DEBUG
      if (token == null)
        throw new ArgumentNullException(nameof(token));
      switch (token.Kind)
      {
        case SyntaxKind.ArgListKeyword:
        case SyntaxKind.NumericLiteralToken:
        case SyntaxKind.StringLiteralToken:
        case SyntaxKind.CharacterLiteralToken:
        case SyntaxKind.TrueKeyword:
        case SyntaxKind.FalseKeyword:
        case SyntaxKind.NullKeyword:
        case SyntaxKind.DefaultKeyword:
          break;
        default:
          throw new ArgumentException(nameof(token));
      }
#endif

      int hash;
      var cached = CSharpSyntaxNodeCache.TryGetNode((int)kind, token, this.context, out hash);
      if (cached != null) return (LiteralExpressionSyntax)cached;

      var result = new LiteralExpressionSyntax(kind, token, this.context);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public MakeRefExpressionSyntax MakeRefExpression(SyntaxToken keyword, SyntaxToken openParenToken, ExpressionSyntax expression, SyntaxToken closeParenToken)
    {
#if DEBUG
      if (keyword == null)
        throw new ArgumentNullException(nameof(keyword));
      switch (keyword.Kind)
      {
        case SyntaxKind.MakeRefKeyword:
          break;
        default:
          throw new ArgumentException(nameof(keyword));
      }
      if (openParenToken == null)
        throw new ArgumentNullException(nameof(openParenToken));
      switch (openParenToken.Kind)
      {
        case SyntaxKind.OpenParenToken:
          break;
        default:
          throw new ArgumentException(nameof(openParenToken));
      }
      if (expression == null)
        throw new ArgumentNullException(nameof(expression));
      if (closeParenToken == null)
        throw new ArgumentNullException(nameof(closeParenToken));
      switch (closeParenToken.Kind)
      {
        case SyntaxKind.CloseParenToken:
          break;
        default:
          throw new ArgumentException(nameof(closeParenToken));
      }
#endif

      return new MakeRefExpressionSyntax(SyntaxKind.MakeRefExpression, keyword, openParenToken, expression, closeParenToken, this.context);
    }

    public RefTypeExpressionSyntax RefTypeExpression(SyntaxToken keyword, SyntaxToken openParenToken, ExpressionSyntax expression, SyntaxToken closeParenToken)
    {
#if DEBUG
      if (keyword == null)
        throw new ArgumentNullException(nameof(keyword));
      switch (keyword.Kind)
      {
        case SyntaxKind.RefTypeKeyword:
          break;
        default:
          throw new ArgumentException(nameof(keyword));
      }
      if (openParenToken == null)
        throw new ArgumentNullException(nameof(openParenToken));
      switch (openParenToken.Kind)
      {
        case SyntaxKind.OpenParenToken:
          break;
        default:
          throw new ArgumentException(nameof(openParenToken));
      }
      if (expression == null)
        throw new ArgumentNullException(nameof(expression));
      if (closeParenToken == null)
        throw new ArgumentNullException(nameof(closeParenToken));
      switch (closeParenToken.Kind)
      {
        case SyntaxKind.CloseParenToken:
          break;
        default:
          throw new ArgumentException(nameof(closeParenToken));
      }
#endif

      return new RefTypeExpressionSyntax(SyntaxKind.RefTypeExpression, keyword, openParenToken, expression, closeParenToken, this.context);
    }

    public RefValueExpressionSyntax RefValueExpression(SyntaxToken keyword, SyntaxToken openParenToken, ExpressionSyntax expression, SyntaxToken comma, TypeSyntax type, SyntaxToken closeParenToken)
    {
#if DEBUG
      if (keyword == null)
        throw new ArgumentNullException(nameof(keyword));
      switch (keyword.Kind)
      {
        case SyntaxKind.RefValueKeyword:
          break;
        default:
          throw new ArgumentException(nameof(keyword));
      }
      if (openParenToken == null)
        throw new ArgumentNullException(nameof(openParenToken));
      switch (openParenToken.Kind)
      {
        case SyntaxKind.OpenParenToken:
          break;
        default:
          throw new ArgumentException(nameof(openParenToken));
      }
      if (expression == null)
        throw new ArgumentNullException(nameof(expression));
      if (comma == null)
        throw new ArgumentNullException(nameof(comma));
      switch (comma.Kind)
      {
        case SyntaxKind.CommaToken:
          break;
        default:
          throw new ArgumentException(nameof(comma));
      }
      if (type == null)
        throw new ArgumentNullException(nameof(type));
      if (closeParenToken == null)
        throw new ArgumentNullException(nameof(closeParenToken));
      switch (closeParenToken.Kind)
      {
        case SyntaxKind.CloseParenToken:
          break;
        default:
          throw new ArgumentException(nameof(closeParenToken));
      }
#endif

      return new RefValueExpressionSyntax(SyntaxKind.RefValueExpression, keyword, openParenToken, expression, comma, type, closeParenToken, this.context);
    }

    public CheckedExpressionSyntax CheckedExpression(SyntaxKind kind, SyntaxToken keyword, SyntaxToken openParenToken, ExpressionSyntax expression, SyntaxToken closeParenToken)
    {
      switch (kind)
      {
        case SyntaxKind.CheckedExpression:
        case SyntaxKind.UncheckedExpression:
          break;
        default:
          throw new ArgumentException(nameof(kind));
      }
#if DEBUG
      if (keyword == null)
        throw new ArgumentNullException(nameof(keyword));
      switch (keyword.Kind)
      {
        case SyntaxKind.CheckedKeyword:
        case SyntaxKind.UncheckedKeyword:
          break;
        default:
          throw new ArgumentException(nameof(keyword));
      }
      if (openParenToken == null)
        throw new ArgumentNullException(nameof(openParenToken));
      switch (openParenToken.Kind)
      {
        case SyntaxKind.OpenParenToken:
          break;
        default:
          throw new ArgumentException(nameof(openParenToken));
      }
      if (expression == null)
        throw new ArgumentNullException(nameof(expression));
      if (closeParenToken == null)
        throw new ArgumentNullException(nameof(closeParenToken));
      switch (closeParenToken.Kind)
      {
        case SyntaxKind.CloseParenToken:
          break;
        default:
          throw new ArgumentException(nameof(closeParenToken));
      }
#endif

      return new CheckedExpressionSyntax(kind, keyword, openParenToken, expression, closeParenToken, this.context);
    }

    public DefaultExpressionSyntax DefaultExpression(SyntaxToken keyword, SyntaxToken openParenToken, TypeSyntax type, SyntaxToken closeParenToken)
    {
#if DEBUG
      if (keyword == null)
        throw new ArgumentNullException(nameof(keyword));
      switch (keyword.Kind)
      {
        case SyntaxKind.DefaultKeyword:
          break;
        default:
          throw new ArgumentException(nameof(keyword));
      }
      if (openParenToken == null)
        throw new ArgumentNullException(nameof(openParenToken));
      switch (openParenToken.Kind)
      {
        case SyntaxKind.OpenParenToken:
          break;
        default:
          throw new ArgumentException(nameof(openParenToken));
      }
      if (type == null)
        throw new ArgumentNullException(nameof(type));
      if (closeParenToken == null)
        throw new ArgumentNullException(nameof(closeParenToken));
      switch (closeParenToken.Kind)
      {
        case SyntaxKind.CloseParenToken:
          break;
        default:
          throw new ArgumentException(nameof(closeParenToken));
      }
#endif

      return new DefaultExpressionSyntax(SyntaxKind.DefaultExpression, keyword, openParenToken, type, closeParenToken, this.context);
    }

    public TypeOfExpressionSyntax TypeOfExpression(SyntaxToken keyword, SyntaxToken openParenToken, TypeSyntax type, SyntaxToken closeParenToken)
    {
#if DEBUG
      if (keyword == null)
        throw new ArgumentNullException(nameof(keyword));
      switch (keyword.Kind)
      {
        case SyntaxKind.TypeOfKeyword:
          break;
        default:
          throw new ArgumentException(nameof(keyword));
      }
      if (openParenToken == null)
        throw new ArgumentNullException(nameof(openParenToken));
      switch (openParenToken.Kind)
      {
        case SyntaxKind.OpenParenToken:
          break;
        default:
          throw new ArgumentException(nameof(openParenToken));
      }
      if (type == null)
        throw new ArgumentNullException(nameof(type));
      if (closeParenToken == null)
        throw new ArgumentNullException(nameof(closeParenToken));
      switch (closeParenToken.Kind)
      {
        case SyntaxKind.CloseParenToken:
          break;
        default:
          throw new ArgumentException(nameof(closeParenToken));
      }
#endif

      return new TypeOfExpressionSyntax(SyntaxKind.TypeOfExpression, keyword, openParenToken, type, closeParenToken, this.context);
    }

    public SizeOfExpressionSyntax SizeOfExpression(SyntaxToken keyword, SyntaxToken openParenToken, TypeSyntax type, SyntaxToken closeParenToken)
    {
#if DEBUG
      if (keyword == null)
        throw new ArgumentNullException(nameof(keyword));
      switch (keyword.Kind)
      {
        case SyntaxKind.SizeOfKeyword:
          break;
        default:
          throw new ArgumentException(nameof(keyword));
      }
      if (openParenToken == null)
        throw new ArgumentNullException(nameof(openParenToken));
      switch (openParenToken.Kind)
      {
        case SyntaxKind.OpenParenToken:
          break;
        default:
          throw new ArgumentException(nameof(openParenToken));
      }
      if (type == null)
        throw new ArgumentNullException(nameof(type));
      if (closeParenToken == null)
        throw new ArgumentNullException(nameof(closeParenToken));
      switch (closeParenToken.Kind)
      {
        case SyntaxKind.CloseParenToken:
          break;
        default:
          throw new ArgumentException(nameof(closeParenToken));
      }
#endif

      return new SizeOfExpressionSyntax(SyntaxKind.SizeOfExpression, keyword, openParenToken, type, closeParenToken, this.context);
    }

    public InvocationExpressionSyntax InvocationExpression(ExpressionSyntax expression, ArgumentListSyntax argumentList)
    {
#if DEBUG
      if (expression == null)
        throw new ArgumentNullException(nameof(expression));
      if (argumentList == null)
        throw new ArgumentNullException(nameof(argumentList));
#endif

      int hash;
      var cached = CSharpSyntaxNodeCache.TryGetNode((int)SyntaxKind.InvocationExpression, expression, argumentList, this.context, out hash);
      if (cached != null) return (InvocationExpressionSyntax)cached;

      var result = new InvocationExpressionSyntax(SyntaxKind.InvocationExpression, expression, argumentList, this.context);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public ElementAccessExpressionSyntax ElementAccessExpression(ExpressionSyntax expression, BracketedArgumentListSyntax argumentList)
    {
#if DEBUG
      if (expression == null)
        throw new ArgumentNullException(nameof(expression));
      if (argumentList == null)
        throw new ArgumentNullException(nameof(argumentList));
#endif

      int hash;
      var cached = CSharpSyntaxNodeCache.TryGetNode((int)SyntaxKind.ElementAccessExpression, expression, argumentList, this.context, out hash);
      if (cached != null) return (ElementAccessExpressionSyntax)cached;

      var result = new ElementAccessExpressionSyntax(SyntaxKind.ElementAccessExpression, expression, argumentList, this.context);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public ArgumentListSyntax ArgumentList(SyntaxToken openParenToken, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<ArgumentSyntax> arguments, SyntaxToken closeParenToken)
    {
#if DEBUG
      if (openParenToken == null)
        throw new ArgumentNullException(nameof(openParenToken));
      switch (openParenToken.Kind)
      {
        case SyntaxKind.OpenParenToken:
          break;
        default:
          throw new ArgumentException(nameof(openParenToken));
      }
      if (closeParenToken == null)
        throw new ArgumentNullException(nameof(closeParenToken));
      switch (closeParenToken.Kind)
      {
        case SyntaxKind.CloseParenToken:
          break;
        default:
          throw new ArgumentException(nameof(closeParenToken));
      }
#endif

      int hash;
      var cached = CSharpSyntaxNodeCache.TryGetNode((int)SyntaxKind.ArgumentList, openParenToken, arguments.Node, closeParenToken, this.context, out hash);
      if (cached != null) return (ArgumentListSyntax)cached;

      var result = new ArgumentListSyntax(SyntaxKind.ArgumentList, openParenToken, arguments.Node, closeParenToken, this.context);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public BracketedArgumentListSyntax BracketedArgumentList(SyntaxToken openBracketToken, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<ArgumentSyntax> arguments, SyntaxToken closeBracketToken)
    {
#if DEBUG
      if (openBracketToken == null)
        throw new ArgumentNullException(nameof(openBracketToken));
      switch (openBracketToken.Kind)
      {
        case SyntaxKind.OpenBracketToken:
          break;
        default:
          throw new ArgumentException(nameof(openBracketToken));
      }
      if (closeBracketToken == null)
        throw new ArgumentNullException(nameof(closeBracketToken));
      switch (closeBracketToken.Kind)
      {
        case SyntaxKind.CloseBracketToken:
          break;
        default:
          throw new ArgumentException(nameof(closeBracketToken));
      }
#endif

      int hash;
      var cached = CSharpSyntaxNodeCache.TryGetNode((int)SyntaxKind.BracketedArgumentList, openBracketToken, arguments.Node, closeBracketToken, this.context, out hash);
      if (cached != null) return (BracketedArgumentListSyntax)cached;

      var result = new BracketedArgumentListSyntax(SyntaxKind.BracketedArgumentList, openBracketToken, arguments.Node, closeBracketToken, this.context);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public ArgumentSyntax Argument(NameColonSyntax nameColon, SyntaxToken refKindKeyword, ExpressionSyntax expression)
    {
#if DEBUG
      if (refKindKeyword != null)
      {
      switch (refKindKeyword.Kind)
      {
        case SyntaxKind.RefKeyword:
        case SyntaxKind.OutKeyword:
        case SyntaxKind.InKeyword:
        case SyntaxKind.None:
          break;
        default:
          throw new ArgumentException(nameof(refKindKeyword));
      }
      }
      if (expression == null)
        throw new ArgumentNullException(nameof(expression));
#endif

      int hash;
      var cached = CSharpSyntaxNodeCache.TryGetNode((int)SyntaxKind.Argument, nameColon, refKindKeyword, expression, this.context, out hash);
      if (cached != null) return (ArgumentSyntax)cached;

      var result = new ArgumentSyntax(SyntaxKind.Argument, nameColon, refKindKeyword, expression, this.context);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public NameColonSyntax NameColon(IdentifierNameSyntax name, SyntaxToken colonToken)
    {
#if DEBUG
      if (name == null)
        throw new ArgumentNullException(nameof(name));
      if (colonToken == null)
        throw new ArgumentNullException(nameof(colonToken));
      switch (colonToken.Kind)
      {
        case SyntaxKind.ColonToken:
          break;
        default:
          throw new ArgumentException(nameof(colonToken));
      }
#endif

      int hash;
      var cached = CSharpSyntaxNodeCache.TryGetNode((int)SyntaxKind.NameColon, name, colonToken, this.context, out hash);
      if (cached != null) return (NameColonSyntax)cached;

      var result = new NameColonSyntax(SyntaxKind.NameColon, name, colonToken, this.context);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public DeclarationExpressionSyntax DeclarationExpression(TypeSyntax type, VariableDesignationSyntax designation)
    {
#if DEBUG
      if (type == null)
        throw new ArgumentNullException(nameof(type));
      if (designation == null)
        throw new ArgumentNullException(nameof(designation));
#endif

      int hash;
      var cached = CSharpSyntaxNodeCache.TryGetNode((int)SyntaxKind.DeclarationExpression, type, designation, this.context, out hash);
      if (cached != null) return (DeclarationExpressionSyntax)cached;

      var result = new DeclarationExpressionSyntax(SyntaxKind.DeclarationExpression, type, designation, this.context);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public CastExpressionSyntax CastExpression(SyntaxToken openParenToken, TypeSyntax type, SyntaxToken closeParenToken, ExpressionSyntax expression)
    {
#if DEBUG
      if (openParenToken == null)
        throw new ArgumentNullException(nameof(openParenToken));
      switch (openParenToken.Kind)
      {
        case SyntaxKind.OpenParenToken:
          break;
        default:
          throw new ArgumentException(nameof(openParenToken));
      }
      if (type == null)
        throw new ArgumentNullException(nameof(type));
      if (closeParenToken == null)
        throw new ArgumentNullException(nameof(closeParenToken));
      switch (closeParenToken.Kind)
      {
        case SyntaxKind.CloseParenToken:
          break;
        default:
          throw new ArgumentException(nameof(closeParenToken));
      }
      if (expression == null)
        throw new ArgumentNullException(nameof(expression));
#endif

      return new CastExpressionSyntax(SyntaxKind.CastExpression, openParenToken, type, closeParenToken, expression, this.context);
    }

    public AnonymousMethodExpressionSyntax AnonymousMethodExpression(SyntaxToken asyncKeyword, SyntaxToken delegateKeyword, ParameterListSyntax parameterList, CSharpSyntaxNode body)
    {
#if DEBUG
      if (asyncKeyword != null)
      {
      switch (asyncKeyword.Kind)
      {
        case SyntaxKind.AsyncKeyword:
        case SyntaxKind.None:
          break;
        default:
          throw new ArgumentException(nameof(asyncKeyword));
      }
      }
      if (delegateKeyword == null)
        throw new ArgumentNullException(nameof(delegateKeyword));
      switch (delegateKeyword.Kind)
      {
        case SyntaxKind.DelegateKeyword:
          break;
        default:
          throw new ArgumentException(nameof(delegateKeyword));
      }
      if (body == null)
        throw new ArgumentNullException(nameof(body));
#endif

      return new AnonymousMethodExpressionSyntax(SyntaxKind.AnonymousMethodExpression, asyncKeyword, delegateKeyword, parameterList, body, this.context);
    }

    public SimpleLambdaExpressionSyntax SimpleLambdaExpression(SyntaxToken asyncKeyword, ParameterSyntax parameter, SyntaxToken arrowToken, CSharpSyntaxNode body)
    {
#if DEBUG
      if (asyncKeyword != null)
      {
      switch (asyncKeyword.Kind)
      {
        case SyntaxKind.AsyncKeyword:
        case SyntaxKind.None:
          break;
        default:
          throw new ArgumentException(nameof(asyncKeyword));
      }
      }
      if (parameter == null)
        throw new ArgumentNullException(nameof(parameter));
      if (arrowToken == null)
        throw new ArgumentNullException(nameof(arrowToken));
      switch (arrowToken.Kind)
      {
        case SyntaxKind.EqualsGreaterThanToken:
          break;
        default:
          throw new ArgumentException(nameof(arrowToken));
      }
      if (body == null)
        throw new ArgumentNullException(nameof(body));
#endif

      return new SimpleLambdaExpressionSyntax(SyntaxKind.SimpleLambdaExpression, asyncKeyword, parameter, arrowToken, body, this.context);
    }

    public RefExpressionSyntax RefExpression(SyntaxToken refKeyword, ExpressionSyntax expression)
    {
#if DEBUG
      if (refKeyword == null)
        throw new ArgumentNullException(nameof(refKeyword));
      switch (refKeyword.Kind)
      {
        case SyntaxKind.RefKeyword:
          break;
        default:
          throw new ArgumentException(nameof(refKeyword));
      }
      if (expression == null)
        throw new ArgumentNullException(nameof(expression));
#endif

      int hash;
      var cached = CSharpSyntaxNodeCache.TryGetNode((int)SyntaxKind.RefExpression, refKeyword, expression, this.context, out hash);
      if (cached != null) return (RefExpressionSyntax)cached;

      var result = new RefExpressionSyntax(SyntaxKind.RefExpression, refKeyword, expression, this.context);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public ParenthesizedLambdaExpressionSyntax ParenthesizedLambdaExpression(SyntaxToken asyncKeyword, ParameterListSyntax parameterList, SyntaxToken arrowToken, CSharpSyntaxNode body)
    {
#if DEBUG
      if (asyncKeyword != null)
      {
      switch (asyncKeyword.Kind)
      {
        case SyntaxKind.AsyncKeyword:
        case SyntaxKind.None:
          break;
        default:
          throw new ArgumentException(nameof(asyncKeyword));
      }
      }
      if (parameterList == null)
        throw new ArgumentNullException(nameof(parameterList));
      if (arrowToken == null)
        throw new ArgumentNullException(nameof(arrowToken));
      switch (arrowToken.Kind)
      {
        case SyntaxKind.EqualsGreaterThanToken:
          break;
        default:
          throw new ArgumentException(nameof(arrowToken));
      }
      if (body == null)
        throw new ArgumentNullException(nameof(body));
#endif

      return new ParenthesizedLambdaExpressionSyntax(SyntaxKind.ParenthesizedLambdaExpression, asyncKeyword, parameterList, arrowToken, body, this.context);
    }

    public InitializerExpressionSyntax InitializerExpression(SyntaxKind kind, SyntaxToken openBraceToken, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<ExpressionSyntax> expressions, SyntaxToken closeBraceToken)
    {
      switch (kind)
      {
        case SyntaxKind.ObjectInitializerExpression:
        case SyntaxKind.CollectionInitializerExpression:
        case SyntaxKind.ArrayInitializerExpression:
        case SyntaxKind.ComplexElementInitializerExpression:
          break;
        default:
          throw new ArgumentException(nameof(kind));
      }
#if DEBUG
      if (openBraceToken == null)
        throw new ArgumentNullException(nameof(openBraceToken));
      switch (openBraceToken.Kind)
      {
        case SyntaxKind.OpenBraceToken:
          break;
        default:
          throw new ArgumentException(nameof(openBraceToken));
      }
      if (closeBraceToken == null)
        throw new ArgumentNullException(nameof(closeBraceToken));
      switch (closeBraceToken.Kind)
      {
        case SyntaxKind.CloseBraceToken:
          break;
        default:
          throw new ArgumentException(nameof(closeBraceToken));
      }
#endif

      int hash;
      var cached = CSharpSyntaxNodeCache.TryGetNode((int)kind, openBraceToken, expressions.Node, closeBraceToken, this.context, out hash);
      if (cached != null) return (InitializerExpressionSyntax)cached;

      var result = new InitializerExpressionSyntax(kind, openBraceToken, expressions.Node, closeBraceToken, this.context);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public ObjectCreationExpressionSyntax ObjectCreationExpression(SyntaxToken newKeyword, TypeSyntax type, ArgumentListSyntax argumentList, InitializerExpressionSyntax initializer)
    {
#if DEBUG
      if (newKeyword == null)
        throw new ArgumentNullException(nameof(newKeyword));
      switch (newKeyword.Kind)
      {
        case SyntaxKind.NewKeyword:
          break;
        default:
          throw new ArgumentException(nameof(newKeyword));
      }
      if (type == null)
        throw new ArgumentNullException(nameof(type));
#endif

      return new ObjectCreationExpressionSyntax(SyntaxKind.ObjectCreationExpression, newKeyword, type, argumentList, initializer, this.context);
    }

    public AnonymousObjectMemberDeclaratorSyntax AnonymousObjectMemberDeclarator(NameEqualsSyntax nameEquals, ExpressionSyntax expression)
    {
#if DEBUG
      if (expression == null)
        throw new ArgumentNullException(nameof(expression));
#endif

      int hash;
      var cached = CSharpSyntaxNodeCache.TryGetNode((int)SyntaxKind.AnonymousObjectMemberDeclarator, nameEquals, expression, this.context, out hash);
      if (cached != null) return (AnonymousObjectMemberDeclaratorSyntax)cached;

      var result = new AnonymousObjectMemberDeclaratorSyntax(SyntaxKind.AnonymousObjectMemberDeclarator, nameEquals, expression, this.context);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public AnonymousObjectCreationExpressionSyntax AnonymousObjectCreationExpression(SyntaxToken newKeyword, SyntaxToken openBraceToken, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<AnonymousObjectMemberDeclaratorSyntax> initializers, SyntaxToken closeBraceToken)
    {
#if DEBUG
      if (newKeyword == null)
        throw new ArgumentNullException(nameof(newKeyword));
      switch (newKeyword.Kind)
      {
        case SyntaxKind.NewKeyword:
          break;
        default:
          throw new ArgumentException(nameof(newKeyword));
      }
      if (openBraceToken == null)
        throw new ArgumentNullException(nameof(openBraceToken));
      switch (openBraceToken.Kind)
      {
        case SyntaxKind.OpenBraceToken:
          break;
        default:
          throw new ArgumentException(nameof(openBraceToken));
      }
      if (closeBraceToken == null)
        throw new ArgumentNullException(nameof(closeBraceToken));
      switch (closeBraceToken.Kind)
      {
        case SyntaxKind.CloseBraceToken:
          break;
        default:
          throw new ArgumentException(nameof(closeBraceToken));
      }
#endif

      return new AnonymousObjectCreationExpressionSyntax(SyntaxKind.AnonymousObjectCreationExpression, newKeyword, openBraceToken, initializers.Node, closeBraceToken, this.context);
    }

    public ArrayCreationExpressionSyntax ArrayCreationExpression(SyntaxToken newKeyword, ArrayTypeSyntax type, InitializerExpressionSyntax initializer)
    {
#if DEBUG
      if (newKeyword == null)
        throw new ArgumentNullException(nameof(newKeyword));
      switch (newKeyword.Kind)
      {
        case SyntaxKind.NewKeyword:
          break;
        default:
          throw new ArgumentException(nameof(newKeyword));
      }
      if (type == null)
        throw new ArgumentNullException(nameof(type));
#endif

      int hash;
      var cached = CSharpSyntaxNodeCache.TryGetNode((int)SyntaxKind.ArrayCreationExpression, newKeyword, type, initializer, this.context, out hash);
      if (cached != null) return (ArrayCreationExpressionSyntax)cached;

      var result = new ArrayCreationExpressionSyntax(SyntaxKind.ArrayCreationExpression, newKeyword, type, initializer, this.context);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public ImplicitArrayCreationExpressionSyntax ImplicitArrayCreationExpression(SyntaxToken newKeyword, SyntaxToken openBracketToken, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SyntaxToken> commas, SyntaxToken closeBracketToken, InitializerExpressionSyntax initializer)
    {
#if DEBUG
      if (newKeyword == null)
        throw new ArgumentNullException(nameof(newKeyword));
      switch (newKeyword.Kind)
      {
        case SyntaxKind.NewKeyword:
          break;
        default:
          throw new ArgumentException(nameof(newKeyword));
      }
      if (openBracketToken == null)
        throw new ArgumentNullException(nameof(openBracketToken));
      switch (openBracketToken.Kind)
      {
        case SyntaxKind.OpenBracketToken:
          break;
        default:
          throw new ArgumentException(nameof(openBracketToken));
      }
      if (closeBracketToken == null)
        throw new ArgumentNullException(nameof(closeBracketToken));
      switch (closeBracketToken.Kind)
      {
        case SyntaxKind.CloseBracketToken:
          break;
        default:
          throw new ArgumentException(nameof(closeBracketToken));
      }
      if (initializer == null)
        throw new ArgumentNullException(nameof(initializer));
#endif

      return new ImplicitArrayCreationExpressionSyntax(SyntaxKind.ImplicitArrayCreationExpression, newKeyword, openBracketToken, commas.Node, closeBracketToken, initializer, this.context);
    }

    public StackAllocArrayCreationExpressionSyntax StackAllocArrayCreationExpression(SyntaxToken stackAllocKeyword, TypeSyntax type, InitializerExpressionSyntax initializer)
    {
#if DEBUG
      if (stackAllocKeyword == null)
        throw new ArgumentNullException(nameof(stackAllocKeyword));
      switch (stackAllocKeyword.Kind)
      {
        case SyntaxKind.StackAllocKeyword:
          break;
        default:
          throw new ArgumentException(nameof(stackAllocKeyword));
      }
      if (type == null)
        throw new ArgumentNullException(nameof(type));
#endif

      int hash;
      var cached = CSharpSyntaxNodeCache.TryGetNode((int)SyntaxKind.StackAllocArrayCreationExpression, stackAllocKeyword, type, initializer, this.context, out hash);
      if (cached != null) return (StackAllocArrayCreationExpressionSyntax)cached;

      var result = new StackAllocArrayCreationExpressionSyntax(SyntaxKind.StackAllocArrayCreationExpression, stackAllocKeyword, type, initializer, this.context);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public ImplicitStackAllocArrayCreationExpressionSyntax ImplicitStackAllocArrayCreationExpression(SyntaxToken stackAllocKeyword, SyntaxToken openBracketToken, SyntaxToken closeBracketToken, InitializerExpressionSyntax initializer)
    {
#if DEBUG
      if (stackAllocKeyword == null)
        throw new ArgumentNullException(nameof(stackAllocKeyword));
      switch (stackAllocKeyword.Kind)
      {
        case SyntaxKind.StackAllocKeyword:
          break;
        default:
          throw new ArgumentException(nameof(stackAllocKeyword));
      }
      if (openBracketToken == null)
        throw new ArgumentNullException(nameof(openBracketToken));
      switch (openBracketToken.Kind)
      {
        case SyntaxKind.OpenBracketToken:
          break;
        default:
          throw new ArgumentException(nameof(openBracketToken));
      }
      if (closeBracketToken == null)
        throw new ArgumentNullException(nameof(closeBracketToken));
      switch (closeBracketToken.Kind)
      {
        case SyntaxKind.CloseBracketToken:
          break;
        default:
          throw new ArgumentException(nameof(closeBracketToken));
      }
      if (initializer == null)
        throw new ArgumentNullException(nameof(initializer));
#endif

      return new ImplicitStackAllocArrayCreationExpressionSyntax(SyntaxKind.ImplicitStackAllocArrayCreationExpression, stackAllocKeyword, openBracketToken, closeBracketToken, initializer, this.context);
    }

    public QueryExpressionSyntax QueryExpression(FromClauseSyntax fromClause, QueryBodySyntax body)
    {
#if DEBUG
      if (fromClause == null)
        throw new ArgumentNullException(nameof(fromClause));
      if (body == null)
        throw new ArgumentNullException(nameof(body));
#endif

      int hash;
      var cached = CSharpSyntaxNodeCache.TryGetNode((int)SyntaxKind.QueryExpression, fromClause, body, this.context, out hash);
      if (cached != null) return (QueryExpressionSyntax)cached;

      var result = new QueryExpressionSyntax(SyntaxKind.QueryExpression, fromClause, body, this.context);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public QueryBodySyntax QueryBody(Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<QueryClauseSyntax> clauses, SelectOrGroupClauseSyntax selectOrGroup, QueryContinuationSyntax continuation)
    {
#if DEBUG
      if (selectOrGroup == null)
        throw new ArgumentNullException(nameof(selectOrGroup));
#endif

      int hash;
      var cached = CSharpSyntaxNodeCache.TryGetNode((int)SyntaxKind.QueryBody, clauses.Node, selectOrGroup, continuation, this.context, out hash);
      if (cached != null) return (QueryBodySyntax)cached;

      var result = new QueryBodySyntax(SyntaxKind.QueryBody, clauses.Node, selectOrGroup, continuation, this.context);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public FromClauseSyntax FromClause(SyntaxToken fromKeyword, TypeSyntax type, SyntaxToken identifier, SyntaxToken inKeyword, ExpressionSyntax expression)
    {
#if DEBUG
      if (fromKeyword == null)
        throw new ArgumentNullException(nameof(fromKeyword));
      switch (fromKeyword.Kind)
      {
        case SyntaxKind.FromKeyword:
          break;
        default:
          throw new ArgumentException(nameof(fromKeyword));
      }
      if (identifier == null)
        throw new ArgumentNullException(nameof(identifier));
      switch (identifier.Kind)
      {
        case SyntaxKind.IdentifierToken:
          break;
        default:
          throw new ArgumentException(nameof(identifier));
      }
      if (inKeyword == null)
        throw new ArgumentNullException(nameof(inKeyword));
      switch (inKeyword.Kind)
      {
        case SyntaxKind.InKeyword:
          break;
        default:
          throw new ArgumentException(nameof(inKeyword));
      }
      if (expression == null)
        throw new ArgumentNullException(nameof(expression));
#endif

      return new FromClauseSyntax(SyntaxKind.FromClause, fromKeyword, type, identifier, inKeyword, expression, this.context);
    }

    public LetClauseSyntax LetClause(SyntaxToken letKeyword, SyntaxToken identifier, SyntaxToken equalsToken, ExpressionSyntax expression)
    {
#if DEBUG
      if (letKeyword == null)
        throw new ArgumentNullException(nameof(letKeyword));
      switch (letKeyword.Kind)
      {
        case SyntaxKind.LetKeyword:
          break;
        default:
          throw new ArgumentException(nameof(letKeyword));
      }
      if (identifier == null)
        throw new ArgumentNullException(nameof(identifier));
      switch (identifier.Kind)
      {
        case SyntaxKind.IdentifierToken:
          break;
        default:
          throw new ArgumentException(nameof(identifier));
      }
      if (equalsToken == null)
        throw new ArgumentNullException(nameof(equalsToken));
      switch (equalsToken.Kind)
      {
        case SyntaxKind.EqualsToken:
          break;
        default:
          throw new ArgumentException(nameof(equalsToken));
      }
      if (expression == null)
        throw new ArgumentNullException(nameof(expression));
#endif

      return new LetClauseSyntax(SyntaxKind.LetClause, letKeyword, identifier, equalsToken, expression, this.context);
    }

    public JoinClauseSyntax JoinClause(SyntaxToken joinKeyword, TypeSyntax type, SyntaxToken identifier, SyntaxToken inKeyword, ExpressionSyntax inExpression, SyntaxToken onKeyword, ExpressionSyntax leftExpression, SyntaxToken equalsKeyword, ExpressionSyntax rightExpression, JoinIntoClauseSyntax into)
    {
#if DEBUG
      if (joinKeyword == null)
        throw new ArgumentNullException(nameof(joinKeyword));
      switch (joinKeyword.Kind)
      {
        case SyntaxKind.JoinKeyword:
          break;
        default:
          throw new ArgumentException(nameof(joinKeyword));
      }
      if (identifier == null)
        throw new ArgumentNullException(nameof(identifier));
      switch (identifier.Kind)
      {
        case SyntaxKind.IdentifierToken:
          break;
        default:
          throw new ArgumentException(nameof(identifier));
      }
      if (inKeyword == null)
        throw new ArgumentNullException(nameof(inKeyword));
      switch (inKeyword.Kind)
      {
        case SyntaxKind.InKeyword:
          break;
        default:
          throw new ArgumentException(nameof(inKeyword));
      }
      if (inExpression == null)
        throw new ArgumentNullException(nameof(inExpression));
      if (onKeyword == null)
        throw new ArgumentNullException(nameof(onKeyword));
      switch (onKeyword.Kind)
      {
        case SyntaxKind.OnKeyword:
          break;
        default:
          throw new ArgumentException(nameof(onKeyword));
      }
      if (leftExpression == null)
        throw new ArgumentNullException(nameof(leftExpression));
      if (equalsKeyword == null)
        throw new ArgumentNullException(nameof(equalsKeyword));
      switch (equalsKeyword.Kind)
      {
        case SyntaxKind.EqualsKeyword:
          break;
        default:
          throw new ArgumentException(nameof(equalsKeyword));
      }
      if (rightExpression == null)
        throw new ArgumentNullException(nameof(rightExpression));
#endif

      return new JoinClauseSyntax(SyntaxKind.JoinClause, joinKeyword, type, identifier, inKeyword, inExpression, onKeyword, leftExpression, equalsKeyword, rightExpression, into, this.context);
    }

    public JoinIntoClauseSyntax JoinIntoClause(SyntaxToken intoKeyword, SyntaxToken identifier)
    {
#if DEBUG
      if (intoKeyword == null)
        throw new ArgumentNullException(nameof(intoKeyword));
      switch (intoKeyword.Kind)
      {
        case SyntaxKind.IntoKeyword:
          break;
        default:
          throw new ArgumentException(nameof(intoKeyword));
      }
      if (identifier == null)
        throw new ArgumentNullException(nameof(identifier));
      switch (identifier.Kind)
      {
        case SyntaxKind.IdentifierToken:
          break;
        default:
          throw new ArgumentException(nameof(identifier));
      }
#endif

      int hash;
      var cached = CSharpSyntaxNodeCache.TryGetNode((int)SyntaxKind.JoinIntoClause, intoKeyword, identifier, this.context, out hash);
      if (cached != null) return (JoinIntoClauseSyntax)cached;

      var result = new JoinIntoClauseSyntax(SyntaxKind.JoinIntoClause, intoKeyword, identifier, this.context);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public WhereClauseSyntax WhereClause(SyntaxToken whereKeyword, ExpressionSyntax condition)
    {
#if DEBUG
      if (whereKeyword == null)
        throw new ArgumentNullException(nameof(whereKeyword));
      switch (whereKeyword.Kind)
      {
        case SyntaxKind.WhereKeyword:
          break;
        default:
          throw new ArgumentException(nameof(whereKeyword));
      }
      if (condition == null)
        throw new ArgumentNullException(nameof(condition));
#endif

      int hash;
      var cached = CSharpSyntaxNodeCache.TryGetNode((int)SyntaxKind.WhereClause, whereKeyword, condition, this.context, out hash);
      if (cached != null) return (WhereClauseSyntax)cached;

      var result = new WhereClauseSyntax(SyntaxKind.WhereClause, whereKeyword, condition, this.context);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public OrderByClauseSyntax OrderByClause(SyntaxToken orderByKeyword, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<OrderingSyntax> orderings)
    {
#if DEBUG
      if (orderByKeyword == null)
        throw new ArgumentNullException(nameof(orderByKeyword));
      switch (orderByKeyword.Kind)
      {
        case SyntaxKind.OrderByKeyword:
          break;
        default:
          throw new ArgumentException(nameof(orderByKeyword));
      }
#endif

      int hash;
      var cached = CSharpSyntaxNodeCache.TryGetNode((int)SyntaxKind.OrderByClause, orderByKeyword, orderings.Node, this.context, out hash);
      if (cached != null) return (OrderByClauseSyntax)cached;

      var result = new OrderByClauseSyntax(SyntaxKind.OrderByClause, orderByKeyword, orderings.Node, this.context);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public OrderingSyntax Ordering(SyntaxKind kind, ExpressionSyntax expression, SyntaxToken ascendingOrDescendingKeyword)
    {
      switch (kind)
      {
        case SyntaxKind.AscendingOrdering:
        case SyntaxKind.DescendingOrdering:
          break;
        default:
          throw new ArgumentException(nameof(kind));
      }
#if DEBUG
      if (expression == null)
        throw new ArgumentNullException(nameof(expression));
      if (ascendingOrDescendingKeyword != null)
      {
      switch (ascendingOrDescendingKeyword.Kind)
      {
        case SyntaxKind.AscendingKeyword:
        case SyntaxKind.DescendingKeyword:
        case SyntaxKind.None:
          break;
        default:
          throw new ArgumentException(nameof(ascendingOrDescendingKeyword));
      }
      }
#endif

      int hash;
      var cached = CSharpSyntaxNodeCache.TryGetNode((int)kind, expression, ascendingOrDescendingKeyword, this.context, out hash);
      if (cached != null) return (OrderingSyntax)cached;

      var result = new OrderingSyntax(kind, expression, ascendingOrDescendingKeyword, this.context);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public SelectClauseSyntax SelectClause(SyntaxToken selectKeyword, ExpressionSyntax expression)
    {
#if DEBUG
      if (selectKeyword == null)
        throw new ArgumentNullException(nameof(selectKeyword));
      switch (selectKeyword.Kind)
      {
        case SyntaxKind.SelectKeyword:
          break;
        default:
          throw new ArgumentException(nameof(selectKeyword));
      }
      if (expression == null)
        throw new ArgumentNullException(nameof(expression));
#endif

      int hash;
      var cached = CSharpSyntaxNodeCache.TryGetNode((int)SyntaxKind.SelectClause, selectKeyword, expression, this.context, out hash);
      if (cached != null) return (SelectClauseSyntax)cached;

      var result = new SelectClauseSyntax(SyntaxKind.SelectClause, selectKeyword, expression, this.context);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public GroupClauseSyntax GroupClause(SyntaxToken groupKeyword, ExpressionSyntax groupExpression, SyntaxToken byKeyword, ExpressionSyntax byExpression)
    {
#if DEBUG
      if (groupKeyword == null)
        throw new ArgumentNullException(nameof(groupKeyword));
      switch (groupKeyword.Kind)
      {
        case SyntaxKind.GroupKeyword:
          break;
        default:
          throw new ArgumentException(nameof(groupKeyword));
      }
      if (groupExpression == null)
        throw new ArgumentNullException(nameof(groupExpression));
      if (byKeyword == null)
        throw new ArgumentNullException(nameof(byKeyword));
      switch (byKeyword.Kind)
      {
        case SyntaxKind.ByKeyword:
          break;
        default:
          throw new ArgumentException(nameof(byKeyword));
      }
      if (byExpression == null)
        throw new ArgumentNullException(nameof(byExpression));
#endif

      return new GroupClauseSyntax(SyntaxKind.GroupClause, groupKeyword, groupExpression, byKeyword, byExpression, this.context);
    }

    public QueryContinuationSyntax QueryContinuation(SyntaxToken intoKeyword, SyntaxToken identifier, QueryBodySyntax body)
    {
#if DEBUG
      if (intoKeyword == null)
        throw new ArgumentNullException(nameof(intoKeyword));
      switch (intoKeyword.Kind)
      {
        case SyntaxKind.IntoKeyword:
          break;
        default:
          throw new ArgumentException(nameof(intoKeyword));
      }
      if (identifier == null)
        throw new ArgumentNullException(nameof(identifier));
      switch (identifier.Kind)
      {
        case SyntaxKind.IdentifierToken:
          break;
        default:
          throw new ArgumentException(nameof(identifier));
      }
      if (body == null)
        throw new ArgumentNullException(nameof(body));
#endif

      int hash;
      var cached = CSharpSyntaxNodeCache.TryGetNode((int)SyntaxKind.QueryContinuation, intoKeyword, identifier, body, this.context, out hash);
      if (cached != null) return (QueryContinuationSyntax)cached;

      var result = new QueryContinuationSyntax(SyntaxKind.QueryContinuation, intoKeyword, identifier, body, this.context);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public OmittedArraySizeExpressionSyntax OmittedArraySizeExpression(SyntaxToken omittedArraySizeExpressionToken)
    {
#if DEBUG
      if (omittedArraySizeExpressionToken == null)
        throw new ArgumentNullException(nameof(omittedArraySizeExpressionToken));
      switch (omittedArraySizeExpressionToken.Kind)
      {
        case SyntaxKind.OmittedArraySizeExpressionToken:
          break;
        default:
          throw new ArgumentException(nameof(omittedArraySizeExpressionToken));
      }
#endif

      int hash;
      var cached = CSharpSyntaxNodeCache.TryGetNode((int)SyntaxKind.OmittedArraySizeExpression, omittedArraySizeExpressionToken, this.context, out hash);
      if (cached != null) return (OmittedArraySizeExpressionSyntax)cached;

      var result = new OmittedArraySizeExpressionSyntax(SyntaxKind.OmittedArraySizeExpression, omittedArraySizeExpressionToken, this.context);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public InterpolatedStringExpressionSyntax InterpolatedStringExpression(SyntaxToken stringStartToken, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<InterpolatedStringContentSyntax> contents, SyntaxToken stringEndToken)
    {
#if DEBUG
      if (stringStartToken == null)
        throw new ArgumentNullException(nameof(stringStartToken));
      switch (stringStartToken.Kind)
      {
        case SyntaxKind.InterpolatedStringStartToken:
        case SyntaxKind.InterpolatedVerbatimStringStartToken:
          break;
        default:
          throw new ArgumentException(nameof(stringStartToken));
      }
      if (stringEndToken == null)
        throw new ArgumentNullException(nameof(stringEndToken));
      switch (stringEndToken.Kind)
      {
        case SyntaxKind.InterpolatedStringEndToken:
          break;
        default:
          throw new ArgumentException(nameof(stringEndToken));
      }
#endif

      int hash;
      var cached = CSharpSyntaxNodeCache.TryGetNode((int)SyntaxKind.InterpolatedStringExpression, stringStartToken, contents.Node, stringEndToken, this.context, out hash);
      if (cached != null) return (InterpolatedStringExpressionSyntax)cached;

      var result = new InterpolatedStringExpressionSyntax(SyntaxKind.InterpolatedStringExpression, stringStartToken, contents.Node, stringEndToken, this.context);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public IsPatternExpressionSyntax IsPatternExpression(ExpressionSyntax expression, SyntaxToken isKeyword, PatternSyntax pattern)
    {
#if DEBUG
      if (expression == null)
        throw new ArgumentNullException(nameof(expression));
      if (isKeyword == null)
        throw new ArgumentNullException(nameof(isKeyword));
      switch (isKeyword.Kind)
      {
        case SyntaxKind.IsKeyword:
          break;
        default:
          throw new ArgumentException(nameof(isKeyword));
      }
      if (pattern == null)
        throw new ArgumentNullException(nameof(pattern));
#endif

      int hash;
      var cached = CSharpSyntaxNodeCache.TryGetNode((int)SyntaxKind.IsPatternExpression, expression, isKeyword, pattern, this.context, out hash);
      if (cached != null) return (IsPatternExpressionSyntax)cached;

      var result = new IsPatternExpressionSyntax(SyntaxKind.IsPatternExpression, expression, isKeyword, pattern, this.context);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public ThrowExpressionSyntax ThrowExpression(SyntaxToken throwKeyword, ExpressionSyntax expression)
    {
#if DEBUG
      if (throwKeyword == null)
        throw new ArgumentNullException(nameof(throwKeyword));
      switch (throwKeyword.Kind)
      {
        case SyntaxKind.ThrowKeyword:
          break;
        default:
          throw new ArgumentException(nameof(throwKeyword));
      }
      if (expression == null)
        throw new ArgumentNullException(nameof(expression));
#endif

      int hash;
      var cached = CSharpSyntaxNodeCache.TryGetNode((int)SyntaxKind.ThrowExpression, throwKeyword, expression, this.context, out hash);
      if (cached != null) return (ThrowExpressionSyntax)cached;

      var result = new ThrowExpressionSyntax(SyntaxKind.ThrowExpression, throwKeyword, expression, this.context);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public WhenClauseSyntax WhenClause(SyntaxToken whenKeyword, ExpressionSyntax condition)
    {
#if DEBUG
      if (whenKeyword == null)
        throw new ArgumentNullException(nameof(whenKeyword));
      switch (whenKeyword.Kind)
      {
        case SyntaxKind.WhenKeyword:
          break;
        default:
          throw new ArgumentException(nameof(whenKeyword));
      }
      if (condition == null)
        throw new ArgumentNullException(nameof(condition));
#endif

      int hash;
      var cached = CSharpSyntaxNodeCache.TryGetNode((int)SyntaxKind.WhenClause, whenKeyword, condition, this.context, out hash);
      if (cached != null) return (WhenClauseSyntax)cached;

      var result = new WhenClauseSyntax(SyntaxKind.WhenClause, whenKeyword, condition, this.context);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public DiscardPatternSyntax DiscardPattern(SyntaxToken underscoreToken)
    {
#if DEBUG
      if (underscoreToken == null)
        throw new ArgumentNullException(nameof(underscoreToken));
      switch (underscoreToken.Kind)
      {
        case SyntaxKind.UnderscoreToken:
          break;
        default:
          throw new ArgumentException(nameof(underscoreToken));
      }
#endif

      int hash;
      var cached = CSharpSyntaxNodeCache.TryGetNode((int)SyntaxKind.DiscardPattern, underscoreToken, this.context, out hash);
      if (cached != null) return (DiscardPatternSyntax)cached;

      var result = new DiscardPatternSyntax(SyntaxKind.DiscardPattern, underscoreToken, this.context);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public DeclarationPatternSyntax DeclarationPattern(TypeSyntax type, VariableDesignationSyntax designation)
    {
#if DEBUG
      if (type == null)
        throw new ArgumentNullException(nameof(type));
      if (designation == null)
        throw new ArgumentNullException(nameof(designation));
#endif

      int hash;
      var cached = CSharpSyntaxNodeCache.TryGetNode((int)SyntaxKind.DeclarationPattern, type, designation, this.context, out hash);
      if (cached != null) return (DeclarationPatternSyntax)cached;

      var result = new DeclarationPatternSyntax(SyntaxKind.DeclarationPattern, type, designation, this.context);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public VarPatternSyntax VarPattern(SyntaxToken varKeyword, VariableDesignationSyntax designation)
    {
#if DEBUG
      if (varKeyword == null)
        throw new ArgumentNullException(nameof(varKeyword));
      switch (varKeyword.Kind)
      {
        case SyntaxKind.VarKeyword:
          break;
        default:
          throw new ArgumentException(nameof(varKeyword));
      }
      if (designation == null)
        throw new ArgumentNullException(nameof(designation));
#endif

      int hash;
      var cached = CSharpSyntaxNodeCache.TryGetNode((int)SyntaxKind.VarPattern, varKeyword, designation, this.context, out hash);
      if (cached != null) return (VarPatternSyntax)cached;

      var result = new VarPatternSyntax(SyntaxKind.VarPattern, varKeyword, designation, this.context);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public RecursivePatternSyntax RecursivePattern(TypeSyntax type, PositionalPatternClauseSyntax positionalPatternClause, PropertyPatternClauseSyntax propertyPatternClause, VariableDesignationSyntax designation)
    {
#if DEBUG
#endif

      return new RecursivePatternSyntax(SyntaxKind.RecursivePattern, type, positionalPatternClause, propertyPatternClause, designation, this.context);
    }

    public PositionalPatternClauseSyntax PositionalPatternClause(SyntaxToken openParenToken, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<SubpatternSyntax> subpatterns, SyntaxToken closeParenToken)
    {
#if DEBUG
      if (openParenToken == null)
        throw new ArgumentNullException(nameof(openParenToken));
      switch (openParenToken.Kind)
      {
        case SyntaxKind.OpenParenToken:
          break;
        default:
          throw new ArgumentException(nameof(openParenToken));
      }
      if (closeParenToken == null)
        throw new ArgumentNullException(nameof(closeParenToken));
      switch (closeParenToken.Kind)
      {
        case SyntaxKind.CloseParenToken:
          break;
        default:
          throw new ArgumentException(nameof(closeParenToken));
      }
#endif

      int hash;
      var cached = CSharpSyntaxNodeCache.TryGetNode((int)SyntaxKind.PositionalPatternClause, openParenToken, subpatterns.Node, closeParenToken, this.context, out hash);
      if (cached != null) return (PositionalPatternClauseSyntax)cached;

      var result = new PositionalPatternClauseSyntax(SyntaxKind.PositionalPatternClause, openParenToken, subpatterns.Node, closeParenToken, this.context);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public PropertyPatternClauseSyntax PropertyPatternClause(SyntaxToken openBraceToken, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<SubpatternSyntax> subpatterns, SyntaxToken closeBraceToken)
    {
#if DEBUG
      if (openBraceToken == null)
        throw new ArgumentNullException(nameof(openBraceToken));
      switch (openBraceToken.Kind)
      {
        case SyntaxKind.OpenBraceToken:
          break;
        default:
          throw new ArgumentException(nameof(openBraceToken));
      }
      if (closeBraceToken == null)
        throw new ArgumentNullException(nameof(closeBraceToken));
      switch (closeBraceToken.Kind)
      {
        case SyntaxKind.CloseBraceToken:
          break;
        default:
          throw new ArgumentException(nameof(closeBraceToken));
      }
#endif

      int hash;
      var cached = CSharpSyntaxNodeCache.TryGetNode((int)SyntaxKind.PropertyPatternClause, openBraceToken, subpatterns.Node, closeBraceToken, this.context, out hash);
      if (cached != null) return (PropertyPatternClauseSyntax)cached;

      var result = new PropertyPatternClauseSyntax(SyntaxKind.PropertyPatternClause, openBraceToken, subpatterns.Node, closeBraceToken, this.context);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public SubpatternSyntax Subpattern(NameColonSyntax nameColon, PatternSyntax pattern)
    {
#if DEBUG
      if (pattern == null)
        throw new ArgumentNullException(nameof(pattern));
#endif

      int hash;
      var cached = CSharpSyntaxNodeCache.TryGetNode((int)SyntaxKind.Subpattern, nameColon, pattern, this.context, out hash);
      if (cached != null) return (SubpatternSyntax)cached;

      var result = new SubpatternSyntax(SyntaxKind.Subpattern, nameColon, pattern, this.context);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public ConstantPatternSyntax ConstantPattern(ExpressionSyntax expression)
    {
#if DEBUG
      if (expression == null)
        throw new ArgumentNullException(nameof(expression));
#endif

      int hash;
      var cached = CSharpSyntaxNodeCache.TryGetNode((int)SyntaxKind.ConstantPattern, expression, this.context, out hash);
      if (cached != null) return (ConstantPatternSyntax)cached;

      var result = new ConstantPatternSyntax(SyntaxKind.ConstantPattern, expression, this.context);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public InterpolatedStringTextSyntax InterpolatedStringText(SyntaxToken textToken)
    {
#if DEBUG
      if (textToken == null)
        throw new ArgumentNullException(nameof(textToken));
      switch (textToken.Kind)
      {
        case SyntaxKind.InterpolatedStringTextToken:
          break;
        default:
          throw new ArgumentException(nameof(textToken));
      }
#endif

      int hash;
      var cached = CSharpSyntaxNodeCache.TryGetNode((int)SyntaxKind.InterpolatedStringText, textToken, this.context, out hash);
      if (cached != null) return (InterpolatedStringTextSyntax)cached;

      var result = new InterpolatedStringTextSyntax(SyntaxKind.InterpolatedStringText, textToken, this.context);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public InterpolationSyntax Interpolation(SyntaxToken openBraceToken, ExpressionSyntax expression, InterpolationAlignmentClauseSyntax alignmentClause, InterpolationFormatClauseSyntax formatClause, SyntaxToken closeBraceToken)
    {
#if DEBUG
      if (openBraceToken == null)
        throw new ArgumentNullException(nameof(openBraceToken));
      switch (openBraceToken.Kind)
      {
        case SyntaxKind.OpenBraceToken:
          break;
        default:
          throw new ArgumentException(nameof(openBraceToken));
      }
      if (expression == null)
        throw new ArgumentNullException(nameof(expression));
      if (closeBraceToken == null)
        throw new ArgumentNullException(nameof(closeBraceToken));
      switch (closeBraceToken.Kind)
      {
        case SyntaxKind.CloseBraceToken:
          break;
        default:
          throw new ArgumentException(nameof(closeBraceToken));
      }
#endif

      return new InterpolationSyntax(SyntaxKind.Interpolation, openBraceToken, expression, alignmentClause, formatClause, closeBraceToken, this.context);
    }

    public InterpolationAlignmentClauseSyntax InterpolationAlignmentClause(SyntaxToken commaToken, ExpressionSyntax value)
    {
#if DEBUG
      if (commaToken == null)
        throw new ArgumentNullException(nameof(commaToken));
      if (value == null)
        throw new ArgumentNullException(nameof(value));
#endif

      int hash;
      var cached = CSharpSyntaxNodeCache.TryGetNode((int)SyntaxKind.InterpolationAlignmentClause, commaToken, value, this.context, out hash);
      if (cached != null) return (InterpolationAlignmentClauseSyntax)cached;

      var result = new InterpolationAlignmentClauseSyntax(SyntaxKind.InterpolationAlignmentClause, commaToken, value, this.context);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public InterpolationFormatClauseSyntax InterpolationFormatClause(SyntaxToken colonToken, SyntaxToken formatStringToken)
    {
#if DEBUG
      if (colonToken == null)
        throw new ArgumentNullException(nameof(colonToken));
      if (formatStringToken == null)
        throw new ArgumentNullException(nameof(formatStringToken));
      switch (formatStringToken.Kind)
      {
        case SyntaxKind.InterpolatedStringTextToken:
          break;
        default:
          throw new ArgumentException(nameof(formatStringToken));
      }
#endif

      int hash;
      var cached = CSharpSyntaxNodeCache.TryGetNode((int)SyntaxKind.InterpolationFormatClause, colonToken, formatStringToken, this.context, out hash);
      if (cached != null) return (InterpolationFormatClauseSyntax)cached;

      var result = new InterpolationFormatClauseSyntax(SyntaxKind.InterpolationFormatClause, colonToken, formatStringToken, this.context);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public GlobalStatementSyntax GlobalStatement(Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<AttributeListSyntax> attributeLists, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SyntaxToken> modifiers, StatementSyntax statement)
    {
#if DEBUG
      if (statement == null)
        throw new ArgumentNullException(nameof(statement));
#endif

      int hash;
      var cached = CSharpSyntaxNodeCache.TryGetNode((int)SyntaxKind.GlobalStatement, attributeLists.Node, modifiers.Node, statement, this.context, out hash);
      if (cached != null) return (GlobalStatementSyntax)cached;

      var result = new GlobalStatementSyntax(SyntaxKind.GlobalStatement, attributeLists.Node, modifiers.Node, statement, this.context);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public BlockSyntax Block(SyntaxToken openBraceToken, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<StatementSyntax> statements, SyntaxToken closeBraceToken)
    {
#if DEBUG
      if (openBraceToken == null)
        throw new ArgumentNullException(nameof(openBraceToken));
      switch (openBraceToken.Kind)
      {
        case SyntaxKind.OpenBraceToken:
          break;
        default:
          throw new ArgumentException(nameof(openBraceToken));
      }
      if (closeBraceToken == null)
        throw new ArgumentNullException(nameof(closeBraceToken));
      switch (closeBraceToken.Kind)
      {
        case SyntaxKind.CloseBraceToken:
          break;
        default:
          throw new ArgumentException(nameof(closeBraceToken));
      }
#endif

      int hash;
      var cached = CSharpSyntaxNodeCache.TryGetNode((int)SyntaxKind.Block, openBraceToken, statements.Node, closeBraceToken, this.context, out hash);
      if (cached != null) return (BlockSyntax)cached;

      var result = new BlockSyntax(SyntaxKind.Block, openBraceToken, statements.Node, closeBraceToken, this.context);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public LocalFunctionStatementSyntax LocalFunctionStatement(Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SyntaxToken> modifiers, TypeSyntax returnType, SyntaxToken identifier, TypeParameterListSyntax typeParameterList, ParameterListSyntax parameterList, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<TypeParameterConstraintClauseSyntax> constraintClauses, BlockSyntax body, ArrowExpressionClauseSyntax expressionBody, SyntaxToken semicolonToken)
    {
#if DEBUG
      if (returnType == null)
        throw new ArgumentNullException(nameof(returnType));
      if (identifier == null)
        throw new ArgumentNullException(nameof(identifier));
      switch (identifier.Kind)
      {
        case SyntaxKind.IdentifierToken:
          break;
        default:
          throw new ArgumentException(nameof(identifier));
      }
      if (parameterList == null)
        throw new ArgumentNullException(nameof(parameterList));
      if (semicolonToken != null)
      {
      switch (semicolonToken.Kind)
      {
        case SyntaxKind.SemicolonToken:
        case SyntaxKind.None:
          break;
        default:
          throw new ArgumentException(nameof(semicolonToken));
      }
      }
#endif

      return new LocalFunctionStatementSyntax(SyntaxKind.LocalFunctionStatement, modifiers.Node, returnType, identifier, typeParameterList, parameterList, constraintClauses.Node, body, expressionBody, semicolonToken, this.context);
    }

    public LocalDeclarationStatementSyntax LocalDeclarationStatement(SyntaxToken awaitKeyword, SyntaxToken usingKeyword, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SyntaxToken> modifiers, VariableDeclarationSyntax declaration, SyntaxToken semicolonToken)
    {
#if DEBUG
      if (awaitKeyword != null)
      {
      switch (awaitKeyword.Kind)
      {
        case SyntaxKind.AwaitKeyword:
        case SyntaxKind.None:
          break;
        default:
          throw new ArgumentException(nameof(awaitKeyword));
      }
      }
      if (usingKeyword != null)
      {
      switch (usingKeyword.Kind)
      {
        case SyntaxKind.UsingKeyword:
        case SyntaxKind.None:
          break;
        default:
          throw new ArgumentException(nameof(usingKeyword));
      }
      }
      if (declaration == null)
        throw new ArgumentNullException(nameof(declaration));
      if (semicolonToken == null)
        throw new ArgumentNullException(nameof(semicolonToken));
      switch (semicolonToken.Kind)
      {
        case SyntaxKind.SemicolonToken:
          break;
        default:
          throw new ArgumentException(nameof(semicolonToken));
      }
#endif

      return new LocalDeclarationStatementSyntax(SyntaxKind.LocalDeclarationStatement, awaitKeyword, usingKeyword, modifiers.Node, declaration, semicolonToken, this.context);
    }

    public VariableDeclarationSyntax VariableDeclaration(TypeSyntax type, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<VariableDeclaratorSyntax> variables)
    {
#if DEBUG
      if (type == null)
        throw new ArgumentNullException(nameof(type));
#endif

      int hash;
      var cached = CSharpSyntaxNodeCache.TryGetNode((int)SyntaxKind.VariableDeclaration, type, variables.Node, this.context, out hash);
      if (cached != null) return (VariableDeclarationSyntax)cached;

      var result = new VariableDeclarationSyntax(SyntaxKind.VariableDeclaration, type, variables.Node, this.context);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public VariableDeclaratorSyntax VariableDeclarator(SyntaxToken identifier, BracketedArgumentListSyntax argumentList, EqualsValueClauseSyntax initializer)
    {
#if DEBUG
      if (identifier == null)
        throw new ArgumentNullException(nameof(identifier));
      switch (identifier.Kind)
      {
        case SyntaxKind.IdentifierToken:
          break;
        default:
          throw new ArgumentException(nameof(identifier));
      }
#endif

      int hash;
      var cached = CSharpSyntaxNodeCache.TryGetNode((int)SyntaxKind.VariableDeclarator, identifier, argumentList, initializer, this.context, out hash);
      if (cached != null) return (VariableDeclaratorSyntax)cached;

      var result = new VariableDeclaratorSyntax(SyntaxKind.VariableDeclarator, identifier, argumentList, initializer, this.context);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public EqualsValueClauseSyntax EqualsValueClause(SyntaxToken equalsToken, ExpressionSyntax value)
    {
#if DEBUG
      if (equalsToken == null)
        throw new ArgumentNullException(nameof(equalsToken));
      switch (equalsToken.Kind)
      {
        case SyntaxKind.EqualsToken:
          break;
        default:
          throw new ArgumentException(nameof(equalsToken));
      }
      if (value == null)
        throw new ArgumentNullException(nameof(value));
#endif

      int hash;
      var cached = CSharpSyntaxNodeCache.TryGetNode((int)SyntaxKind.EqualsValueClause, equalsToken, value, this.context, out hash);
      if (cached != null) return (EqualsValueClauseSyntax)cached;

      var result = new EqualsValueClauseSyntax(SyntaxKind.EqualsValueClause, equalsToken, value, this.context);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public SingleVariableDesignationSyntax SingleVariableDesignation(SyntaxToken identifier)
    {
#if DEBUG
      if (identifier == null)
        throw new ArgumentNullException(nameof(identifier));
      switch (identifier.Kind)
      {
        case SyntaxKind.IdentifierToken:
          break;
        default:
          throw new ArgumentException(nameof(identifier));
      }
#endif

      int hash;
      var cached = CSharpSyntaxNodeCache.TryGetNode((int)SyntaxKind.SingleVariableDesignation, identifier, this.context, out hash);
      if (cached != null) return (SingleVariableDesignationSyntax)cached;

      var result = new SingleVariableDesignationSyntax(SyntaxKind.SingleVariableDesignation, identifier, this.context);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public DiscardDesignationSyntax DiscardDesignation(SyntaxToken underscoreToken)
    {
#if DEBUG
      if (underscoreToken == null)
        throw new ArgumentNullException(nameof(underscoreToken));
      switch (underscoreToken.Kind)
      {
        case SyntaxKind.UnderscoreToken:
          break;
        default:
          throw new ArgumentException(nameof(underscoreToken));
      }
#endif

      int hash;
      var cached = CSharpSyntaxNodeCache.TryGetNode((int)SyntaxKind.DiscardDesignation, underscoreToken, this.context, out hash);
      if (cached != null) return (DiscardDesignationSyntax)cached;

      var result = new DiscardDesignationSyntax(SyntaxKind.DiscardDesignation, underscoreToken, this.context);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public ParenthesizedVariableDesignationSyntax ParenthesizedVariableDesignation(SyntaxToken openParenToken, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<VariableDesignationSyntax> variables, SyntaxToken closeParenToken)
    {
#if DEBUG
      if (openParenToken == null)
        throw new ArgumentNullException(nameof(openParenToken));
      switch (openParenToken.Kind)
      {
        case SyntaxKind.OpenParenToken:
          break;
        default:
          throw new ArgumentException(nameof(openParenToken));
      }
      if (closeParenToken == null)
        throw new ArgumentNullException(nameof(closeParenToken));
      switch (closeParenToken.Kind)
      {
        case SyntaxKind.CloseParenToken:
          break;
        default:
          throw new ArgumentException(nameof(closeParenToken));
      }
#endif

      int hash;
      var cached = CSharpSyntaxNodeCache.TryGetNode((int)SyntaxKind.ParenthesizedVariableDesignation, openParenToken, variables.Node, closeParenToken, this.context, out hash);
      if (cached != null) return (ParenthesizedVariableDesignationSyntax)cached;

      var result = new ParenthesizedVariableDesignationSyntax(SyntaxKind.ParenthesizedVariableDesignation, openParenToken, variables.Node, closeParenToken, this.context);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public ExpressionStatementSyntax ExpressionStatement(ExpressionSyntax expression, SyntaxToken semicolonToken)
    {
#if DEBUG
      if (expression == null)
        throw new ArgumentNullException(nameof(expression));
      if (semicolonToken == null)
        throw new ArgumentNullException(nameof(semicolonToken));
      switch (semicolonToken.Kind)
      {
        case SyntaxKind.SemicolonToken:
          break;
        default:
          throw new ArgumentException(nameof(semicolonToken));
      }
#endif

      int hash;
      var cached = CSharpSyntaxNodeCache.TryGetNode((int)SyntaxKind.ExpressionStatement, expression, semicolonToken, this.context, out hash);
      if (cached != null) return (ExpressionStatementSyntax)cached;

      var result = new ExpressionStatementSyntax(SyntaxKind.ExpressionStatement, expression, semicolonToken, this.context);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public EmptyStatementSyntax EmptyStatement(SyntaxToken semicolonToken)
    {
#if DEBUG
      if (semicolonToken == null)
        throw new ArgumentNullException(nameof(semicolonToken));
      switch (semicolonToken.Kind)
      {
        case SyntaxKind.SemicolonToken:
          break;
        default:
          throw new ArgumentException(nameof(semicolonToken));
      }
#endif

      int hash;
      var cached = CSharpSyntaxNodeCache.TryGetNode((int)SyntaxKind.EmptyStatement, semicolonToken, this.context, out hash);
      if (cached != null) return (EmptyStatementSyntax)cached;

      var result = new EmptyStatementSyntax(SyntaxKind.EmptyStatement, semicolonToken, this.context);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public LabeledStatementSyntax LabeledStatement(SyntaxToken identifier, SyntaxToken colonToken, StatementSyntax statement)
    {
#if DEBUG
      if (identifier == null)
        throw new ArgumentNullException(nameof(identifier));
      switch (identifier.Kind)
      {
        case SyntaxKind.IdentifierToken:
          break;
        default:
          throw new ArgumentException(nameof(identifier));
      }
      if (colonToken == null)
        throw new ArgumentNullException(nameof(colonToken));
      switch (colonToken.Kind)
      {
        case SyntaxKind.ColonToken:
          break;
        default:
          throw new ArgumentException(nameof(colonToken));
      }
      if (statement == null)
        throw new ArgumentNullException(nameof(statement));
#endif

      int hash;
      var cached = CSharpSyntaxNodeCache.TryGetNode((int)SyntaxKind.LabeledStatement, identifier, colonToken, statement, this.context, out hash);
      if (cached != null) return (LabeledStatementSyntax)cached;

      var result = new LabeledStatementSyntax(SyntaxKind.LabeledStatement, identifier, colonToken, statement, this.context);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public GotoStatementSyntax GotoStatement(SyntaxKind kind, SyntaxToken gotoKeyword, SyntaxToken caseOrDefaultKeyword, ExpressionSyntax expression, SyntaxToken semicolonToken)
    {
      switch (kind)
      {
        case SyntaxKind.GotoStatement:
        case SyntaxKind.GotoCaseStatement:
        case SyntaxKind.GotoDefaultStatement:
          break;
        default:
          throw new ArgumentException(nameof(kind));
      }
#if DEBUG
      if (gotoKeyword == null)
        throw new ArgumentNullException(nameof(gotoKeyword));
      switch (gotoKeyword.Kind)
      {
        case SyntaxKind.GotoKeyword:
          break;
        default:
          throw new ArgumentException(nameof(gotoKeyword));
      }
      if (caseOrDefaultKeyword != null)
      {
      switch (caseOrDefaultKeyword.Kind)
      {
        case SyntaxKind.CaseKeyword:
        case SyntaxKind.DefaultKeyword:
        case SyntaxKind.None:
          break;
        default:
          throw new ArgumentException(nameof(caseOrDefaultKeyword));
      }
      }
      if (semicolonToken == null)
        throw new ArgumentNullException(nameof(semicolonToken));
      switch (semicolonToken.Kind)
      {
        case SyntaxKind.SemicolonToken:
          break;
        default:
          throw new ArgumentException(nameof(semicolonToken));
      }
#endif

      return new GotoStatementSyntax(kind, gotoKeyword, caseOrDefaultKeyword, expression, semicolonToken, this.context);
    }

    public BreakStatementSyntax BreakStatement(SyntaxToken breakKeyword, SyntaxToken semicolonToken)
    {
#if DEBUG
      if (breakKeyword == null)
        throw new ArgumentNullException(nameof(breakKeyword));
      switch (breakKeyword.Kind)
      {
        case SyntaxKind.BreakKeyword:
          break;
        default:
          throw new ArgumentException(nameof(breakKeyword));
      }
      if (semicolonToken == null)
        throw new ArgumentNullException(nameof(semicolonToken));
      switch (semicolonToken.Kind)
      {
        case SyntaxKind.SemicolonToken:
          break;
        default:
          throw new ArgumentException(nameof(semicolonToken));
      }
#endif

      int hash;
      var cached = CSharpSyntaxNodeCache.TryGetNode((int)SyntaxKind.BreakStatement, breakKeyword, semicolonToken, this.context, out hash);
      if (cached != null) return (BreakStatementSyntax)cached;

      var result = new BreakStatementSyntax(SyntaxKind.BreakStatement, breakKeyword, semicolonToken, this.context);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public ContinueStatementSyntax ContinueStatement(SyntaxToken continueKeyword, SyntaxToken semicolonToken)
    {
#if DEBUG
      if (continueKeyword == null)
        throw new ArgumentNullException(nameof(continueKeyword));
      switch (continueKeyword.Kind)
      {
        case SyntaxKind.ContinueKeyword:
          break;
        default:
          throw new ArgumentException(nameof(continueKeyword));
      }
      if (semicolonToken == null)
        throw new ArgumentNullException(nameof(semicolonToken));
      switch (semicolonToken.Kind)
      {
        case SyntaxKind.SemicolonToken:
          break;
        default:
          throw new ArgumentException(nameof(semicolonToken));
      }
#endif

      int hash;
      var cached = CSharpSyntaxNodeCache.TryGetNode((int)SyntaxKind.ContinueStatement, continueKeyword, semicolonToken, this.context, out hash);
      if (cached != null) return (ContinueStatementSyntax)cached;

      var result = new ContinueStatementSyntax(SyntaxKind.ContinueStatement, continueKeyword, semicolonToken, this.context);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public ReturnStatementSyntax ReturnStatement(SyntaxToken returnKeyword, ExpressionSyntax expression, SyntaxToken semicolonToken)
    {
#if DEBUG
      if (returnKeyword == null)
        throw new ArgumentNullException(nameof(returnKeyword));
      switch (returnKeyword.Kind)
      {
        case SyntaxKind.ReturnKeyword:
          break;
        default:
          throw new ArgumentException(nameof(returnKeyword));
      }
      if (semicolonToken == null)
        throw new ArgumentNullException(nameof(semicolonToken));
      switch (semicolonToken.Kind)
      {
        case SyntaxKind.SemicolonToken:
          break;
        default:
          throw new ArgumentException(nameof(semicolonToken));
      }
#endif

      int hash;
      var cached = CSharpSyntaxNodeCache.TryGetNode((int)SyntaxKind.ReturnStatement, returnKeyword, expression, semicolonToken, this.context, out hash);
      if (cached != null) return (ReturnStatementSyntax)cached;

      var result = new ReturnStatementSyntax(SyntaxKind.ReturnStatement, returnKeyword, expression, semicolonToken, this.context);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public ThrowStatementSyntax ThrowStatement(SyntaxToken throwKeyword, ExpressionSyntax expression, SyntaxToken semicolonToken)
    {
#if DEBUG
      if (throwKeyword == null)
        throw new ArgumentNullException(nameof(throwKeyword));
      switch (throwKeyword.Kind)
      {
        case SyntaxKind.ThrowKeyword:
          break;
        default:
          throw new ArgumentException(nameof(throwKeyword));
      }
      if (semicolonToken == null)
        throw new ArgumentNullException(nameof(semicolonToken));
      switch (semicolonToken.Kind)
      {
        case SyntaxKind.SemicolonToken:
          break;
        default:
          throw new ArgumentException(nameof(semicolonToken));
      }
#endif

      int hash;
      var cached = CSharpSyntaxNodeCache.TryGetNode((int)SyntaxKind.ThrowStatement, throwKeyword, expression, semicolonToken, this.context, out hash);
      if (cached != null) return (ThrowStatementSyntax)cached;

      var result = new ThrowStatementSyntax(SyntaxKind.ThrowStatement, throwKeyword, expression, semicolonToken, this.context);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public YieldStatementSyntax YieldStatement(SyntaxKind kind, SyntaxToken yieldKeyword, SyntaxToken returnOrBreakKeyword, ExpressionSyntax expression, SyntaxToken semicolonToken)
    {
      switch (kind)
      {
        case SyntaxKind.YieldReturnStatement:
        case SyntaxKind.YieldBreakStatement:
          break;
        default:
          throw new ArgumentException(nameof(kind));
      }
#if DEBUG
      if (yieldKeyword == null)
        throw new ArgumentNullException(nameof(yieldKeyword));
      switch (yieldKeyword.Kind)
      {
        case SyntaxKind.YieldKeyword:
          break;
        default:
          throw new ArgumentException(nameof(yieldKeyword));
      }
      if (returnOrBreakKeyword == null)
        throw new ArgumentNullException(nameof(returnOrBreakKeyword));
      switch (returnOrBreakKeyword.Kind)
      {
        case SyntaxKind.ReturnKeyword:
        case SyntaxKind.BreakKeyword:
          break;
        default:
          throw new ArgumentException(nameof(returnOrBreakKeyword));
      }
      if (semicolonToken == null)
        throw new ArgumentNullException(nameof(semicolonToken));
      switch (semicolonToken.Kind)
      {
        case SyntaxKind.SemicolonToken:
          break;
        default:
          throw new ArgumentException(nameof(semicolonToken));
      }
#endif

      return new YieldStatementSyntax(kind, yieldKeyword, returnOrBreakKeyword, expression, semicolonToken, this.context);
    }

    public WhileStatementSyntax WhileStatement(SyntaxToken whileKeyword, SyntaxToken openParenToken, ExpressionSyntax condition, SyntaxToken closeParenToken, StatementSyntax statement)
    {
#if DEBUG
      if (whileKeyword == null)
        throw new ArgumentNullException(nameof(whileKeyword));
      switch (whileKeyword.Kind)
      {
        case SyntaxKind.WhileKeyword:
          break;
        default:
          throw new ArgumentException(nameof(whileKeyword));
      }
      if (openParenToken == null)
        throw new ArgumentNullException(nameof(openParenToken));
      switch (openParenToken.Kind)
      {
        case SyntaxKind.OpenParenToken:
          break;
        default:
          throw new ArgumentException(nameof(openParenToken));
      }
      if (condition == null)
        throw new ArgumentNullException(nameof(condition));
      if (closeParenToken == null)
        throw new ArgumentNullException(nameof(closeParenToken));
      switch (closeParenToken.Kind)
      {
        case SyntaxKind.CloseParenToken:
          break;
        default:
          throw new ArgumentException(nameof(closeParenToken));
      }
      if (statement == null)
        throw new ArgumentNullException(nameof(statement));
#endif

      return new WhileStatementSyntax(SyntaxKind.WhileStatement, whileKeyword, openParenToken, condition, closeParenToken, statement, this.context);
    }

    public DoStatementSyntax DoStatement(SyntaxToken doKeyword, StatementSyntax statement, SyntaxToken whileKeyword, SyntaxToken openParenToken, ExpressionSyntax condition, SyntaxToken closeParenToken, SyntaxToken semicolonToken)
    {
#if DEBUG
      if (doKeyword == null)
        throw new ArgumentNullException(nameof(doKeyword));
      switch (doKeyword.Kind)
      {
        case SyntaxKind.DoKeyword:
          break;
        default:
          throw new ArgumentException(nameof(doKeyword));
      }
      if (statement == null)
        throw new ArgumentNullException(nameof(statement));
      if (whileKeyword == null)
        throw new ArgumentNullException(nameof(whileKeyword));
      switch (whileKeyword.Kind)
      {
        case SyntaxKind.WhileKeyword:
          break;
        default:
          throw new ArgumentException(nameof(whileKeyword));
      }
      if (openParenToken == null)
        throw new ArgumentNullException(nameof(openParenToken));
      switch (openParenToken.Kind)
      {
        case SyntaxKind.OpenParenToken:
          break;
        default:
          throw new ArgumentException(nameof(openParenToken));
      }
      if (condition == null)
        throw new ArgumentNullException(nameof(condition));
      if (closeParenToken == null)
        throw new ArgumentNullException(nameof(closeParenToken));
      switch (closeParenToken.Kind)
      {
        case SyntaxKind.CloseParenToken:
          break;
        default:
          throw new ArgumentException(nameof(closeParenToken));
      }
      if (semicolonToken == null)
        throw new ArgumentNullException(nameof(semicolonToken));
      switch (semicolonToken.Kind)
      {
        case SyntaxKind.SemicolonToken:
          break;
        default:
          throw new ArgumentException(nameof(semicolonToken));
      }
#endif

      return new DoStatementSyntax(SyntaxKind.DoStatement, doKeyword, statement, whileKeyword, openParenToken, condition, closeParenToken, semicolonToken, this.context);
    }

    public ForStatementSyntax ForStatement(SyntaxToken forKeyword, SyntaxToken openParenToken, VariableDeclarationSyntax declaration, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<ExpressionSyntax> initializers, SyntaxToken firstSemicolonToken, ExpressionSyntax condition, SyntaxToken secondSemicolonToken, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<ExpressionSyntax> incrementors, SyntaxToken closeParenToken, StatementSyntax statement)
    {
#if DEBUG
      if (forKeyword == null)
        throw new ArgumentNullException(nameof(forKeyword));
      switch (forKeyword.Kind)
      {
        case SyntaxKind.ForKeyword:
          break;
        default:
          throw new ArgumentException(nameof(forKeyword));
      }
      if (openParenToken == null)
        throw new ArgumentNullException(nameof(openParenToken));
      switch (openParenToken.Kind)
      {
        case SyntaxKind.OpenParenToken:
          break;
        default:
          throw new ArgumentException(nameof(openParenToken));
      }
      if (firstSemicolonToken == null)
        throw new ArgumentNullException(nameof(firstSemicolonToken));
      switch (firstSemicolonToken.Kind)
      {
        case SyntaxKind.SemicolonToken:
          break;
        default:
          throw new ArgumentException(nameof(firstSemicolonToken));
      }
      if (secondSemicolonToken == null)
        throw new ArgumentNullException(nameof(secondSemicolonToken));
      switch (secondSemicolonToken.Kind)
      {
        case SyntaxKind.SemicolonToken:
          break;
        default:
          throw new ArgumentException(nameof(secondSemicolonToken));
      }
      if (closeParenToken == null)
        throw new ArgumentNullException(nameof(closeParenToken));
      switch (closeParenToken.Kind)
      {
        case SyntaxKind.CloseParenToken:
          break;
        default:
          throw new ArgumentException(nameof(closeParenToken));
      }
      if (statement == null)
        throw new ArgumentNullException(nameof(statement));
#endif

      return new ForStatementSyntax(SyntaxKind.ForStatement, forKeyword, openParenToken, declaration, initializers.Node, firstSemicolonToken, condition, secondSemicolonToken, incrementors.Node, closeParenToken, statement, this.context);
    }

    public ForEachStatementSyntax ForEachStatement(SyntaxToken awaitKeyword, SyntaxToken forEachKeyword, SyntaxToken openParenToken, TypeSyntax type, SyntaxToken identifier, SyntaxToken inKeyword, ExpressionSyntax expression, SyntaxToken closeParenToken, StatementSyntax statement)
    {
#if DEBUG
      if (awaitKeyword != null)
      {
      switch (awaitKeyword.Kind)
      {
        case SyntaxKind.AwaitKeyword:
        case SyntaxKind.None:
          break;
        default:
          throw new ArgumentException(nameof(awaitKeyword));
      }
      }
      if (forEachKeyword == null)
        throw new ArgumentNullException(nameof(forEachKeyword));
      switch (forEachKeyword.Kind)
      {
        case SyntaxKind.ForEachKeyword:
          break;
        default:
          throw new ArgumentException(nameof(forEachKeyword));
      }
      if (openParenToken == null)
        throw new ArgumentNullException(nameof(openParenToken));
      switch (openParenToken.Kind)
      {
        case SyntaxKind.OpenParenToken:
          break;
        default:
          throw new ArgumentException(nameof(openParenToken));
      }
      if (type == null)
        throw new ArgumentNullException(nameof(type));
      if (identifier == null)
        throw new ArgumentNullException(nameof(identifier));
      switch (identifier.Kind)
      {
        case SyntaxKind.IdentifierToken:
          break;
        default:
          throw new ArgumentException(nameof(identifier));
      }
      if (inKeyword == null)
        throw new ArgumentNullException(nameof(inKeyword));
      switch (inKeyword.Kind)
      {
        case SyntaxKind.InKeyword:
          break;
        default:
          throw new ArgumentException(nameof(inKeyword));
      }
      if (expression == null)
        throw new ArgumentNullException(nameof(expression));
      if (closeParenToken == null)
        throw new ArgumentNullException(nameof(closeParenToken));
      switch (closeParenToken.Kind)
      {
        case SyntaxKind.CloseParenToken:
          break;
        default:
          throw new ArgumentException(nameof(closeParenToken));
      }
      if (statement == null)
        throw new ArgumentNullException(nameof(statement));
#endif

      return new ForEachStatementSyntax(SyntaxKind.ForEachStatement, awaitKeyword, forEachKeyword, openParenToken, type, identifier, inKeyword, expression, closeParenToken, statement, this.context);
    }

    public ForEachVariableStatementSyntax ForEachVariableStatement(SyntaxToken awaitKeyword, SyntaxToken forEachKeyword, SyntaxToken openParenToken, ExpressionSyntax variable, SyntaxToken inKeyword, ExpressionSyntax expression, SyntaxToken closeParenToken, StatementSyntax statement)
    {
#if DEBUG
      if (awaitKeyword != null)
      {
      switch (awaitKeyword.Kind)
      {
        case SyntaxKind.AwaitKeyword:
        case SyntaxKind.None:
          break;
        default:
          throw new ArgumentException(nameof(awaitKeyword));
      }
      }
      if (forEachKeyword == null)
        throw new ArgumentNullException(nameof(forEachKeyword));
      switch (forEachKeyword.Kind)
      {
        case SyntaxKind.ForEachKeyword:
          break;
        default:
          throw new ArgumentException(nameof(forEachKeyword));
      }
      if (openParenToken == null)
        throw new ArgumentNullException(nameof(openParenToken));
      switch (openParenToken.Kind)
      {
        case SyntaxKind.OpenParenToken:
          break;
        default:
          throw new ArgumentException(nameof(openParenToken));
      }
      if (variable == null)
        throw new ArgumentNullException(nameof(variable));
      if (inKeyword == null)
        throw new ArgumentNullException(nameof(inKeyword));
      switch (inKeyword.Kind)
      {
        case SyntaxKind.InKeyword:
          break;
        default:
          throw new ArgumentException(nameof(inKeyword));
      }
      if (expression == null)
        throw new ArgumentNullException(nameof(expression));
      if (closeParenToken == null)
        throw new ArgumentNullException(nameof(closeParenToken));
      switch (closeParenToken.Kind)
      {
        case SyntaxKind.CloseParenToken:
          break;
        default:
          throw new ArgumentException(nameof(closeParenToken));
      }
      if (statement == null)
        throw new ArgumentNullException(nameof(statement));
#endif

      return new ForEachVariableStatementSyntax(SyntaxKind.ForEachVariableStatement, awaitKeyword, forEachKeyword, openParenToken, variable, inKeyword, expression, closeParenToken, statement, this.context);
    }

    public UsingStatementSyntax UsingStatement(SyntaxToken awaitKeyword, SyntaxToken usingKeyword, SyntaxToken openParenToken, VariableDeclarationSyntax declaration, ExpressionSyntax expression, SyntaxToken closeParenToken, StatementSyntax statement)
    {
#if DEBUG
      if (awaitKeyword != null)
      {
      switch (awaitKeyword.Kind)
      {
        case SyntaxKind.AwaitKeyword:
        case SyntaxKind.None:
          break;
        default:
          throw new ArgumentException(nameof(awaitKeyword));
      }
      }
      if (usingKeyword == null)
        throw new ArgumentNullException(nameof(usingKeyword));
      switch (usingKeyword.Kind)
      {
        case SyntaxKind.UsingKeyword:
          break;
        default:
          throw new ArgumentException(nameof(usingKeyword));
      }
      if (openParenToken == null)
        throw new ArgumentNullException(nameof(openParenToken));
      switch (openParenToken.Kind)
      {
        case SyntaxKind.OpenParenToken:
          break;
        default:
          throw new ArgumentException(nameof(openParenToken));
      }
      if (closeParenToken == null)
        throw new ArgumentNullException(nameof(closeParenToken));
      switch (closeParenToken.Kind)
      {
        case SyntaxKind.CloseParenToken:
          break;
        default:
          throw new ArgumentException(nameof(closeParenToken));
      }
      if (statement == null)
        throw new ArgumentNullException(nameof(statement));
#endif

      return new UsingStatementSyntax(SyntaxKind.UsingStatement, awaitKeyword, usingKeyword, openParenToken, declaration, expression, closeParenToken, statement, this.context);
    }

    public FixedStatementSyntax FixedStatement(SyntaxToken fixedKeyword, SyntaxToken openParenToken, VariableDeclarationSyntax declaration, SyntaxToken closeParenToken, StatementSyntax statement)
    {
#if DEBUG
      if (fixedKeyword == null)
        throw new ArgumentNullException(nameof(fixedKeyword));
      switch (fixedKeyword.Kind)
      {
        case SyntaxKind.FixedKeyword:
          break;
        default:
          throw new ArgumentException(nameof(fixedKeyword));
      }
      if (openParenToken == null)
        throw new ArgumentNullException(nameof(openParenToken));
      switch (openParenToken.Kind)
      {
        case SyntaxKind.OpenParenToken:
          break;
        default:
          throw new ArgumentException(nameof(openParenToken));
      }
      if (declaration == null)
        throw new ArgumentNullException(nameof(declaration));
      if (closeParenToken == null)
        throw new ArgumentNullException(nameof(closeParenToken));
      switch (closeParenToken.Kind)
      {
        case SyntaxKind.CloseParenToken:
          break;
        default:
          throw new ArgumentException(nameof(closeParenToken));
      }
      if (statement == null)
        throw new ArgumentNullException(nameof(statement));
#endif

      return new FixedStatementSyntax(SyntaxKind.FixedStatement, fixedKeyword, openParenToken, declaration, closeParenToken, statement, this.context);
    }

    public CheckedStatementSyntax CheckedStatement(SyntaxKind kind, SyntaxToken keyword, BlockSyntax block)
    {
      switch (kind)
      {
        case SyntaxKind.CheckedStatement:
        case SyntaxKind.UncheckedStatement:
          break;
        default:
          throw new ArgumentException(nameof(kind));
      }
#if DEBUG
      if (keyword == null)
        throw new ArgumentNullException(nameof(keyword));
      switch (keyword.Kind)
      {
        case SyntaxKind.CheckedKeyword:
        case SyntaxKind.UncheckedKeyword:
          break;
        default:
          throw new ArgumentException(nameof(keyword));
      }
      if (block == null)
        throw new ArgumentNullException(nameof(block));
#endif

      int hash;
      var cached = CSharpSyntaxNodeCache.TryGetNode((int)kind, keyword, block, this.context, out hash);
      if (cached != null) return (CheckedStatementSyntax)cached;

      var result = new CheckedStatementSyntax(kind, keyword, block, this.context);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public UnsafeStatementSyntax UnsafeStatement(SyntaxToken unsafeKeyword, BlockSyntax block)
    {
#if DEBUG
      if (unsafeKeyword == null)
        throw new ArgumentNullException(nameof(unsafeKeyword));
      switch (unsafeKeyword.Kind)
      {
        case SyntaxKind.UnsafeKeyword:
          break;
        default:
          throw new ArgumentException(nameof(unsafeKeyword));
      }
      if (block == null)
        throw new ArgumentNullException(nameof(block));
#endif

      int hash;
      var cached = CSharpSyntaxNodeCache.TryGetNode((int)SyntaxKind.UnsafeStatement, unsafeKeyword, block, this.context, out hash);
      if (cached != null) return (UnsafeStatementSyntax)cached;

      var result = new UnsafeStatementSyntax(SyntaxKind.UnsafeStatement, unsafeKeyword, block, this.context);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public LockStatementSyntax LockStatement(SyntaxToken lockKeyword, SyntaxToken openParenToken, ExpressionSyntax expression, SyntaxToken closeParenToken, StatementSyntax statement)
    {
#if DEBUG
      if (lockKeyword == null)
        throw new ArgumentNullException(nameof(lockKeyword));
      switch (lockKeyword.Kind)
      {
        case SyntaxKind.LockKeyword:
          break;
        default:
          throw new ArgumentException(nameof(lockKeyword));
      }
      if (openParenToken == null)
        throw new ArgumentNullException(nameof(openParenToken));
      switch (openParenToken.Kind)
      {
        case SyntaxKind.OpenParenToken:
          break;
        default:
          throw new ArgumentException(nameof(openParenToken));
      }
      if (expression == null)
        throw new ArgumentNullException(nameof(expression));
      if (closeParenToken == null)
        throw new ArgumentNullException(nameof(closeParenToken));
      switch (closeParenToken.Kind)
      {
        case SyntaxKind.CloseParenToken:
          break;
        default:
          throw new ArgumentException(nameof(closeParenToken));
      }
      if (statement == null)
        throw new ArgumentNullException(nameof(statement));
#endif

      return new LockStatementSyntax(SyntaxKind.LockStatement, lockKeyword, openParenToken, expression, closeParenToken, statement, this.context);
    }

    public IfStatementSyntax IfStatement(SyntaxToken ifKeyword, SyntaxToken openParenToken, ExpressionSyntax condition, SyntaxToken closeParenToken, StatementSyntax statement, ElseClauseSyntax @else)
    {
#if DEBUG
      if (ifKeyword == null)
        throw new ArgumentNullException(nameof(ifKeyword));
      switch (ifKeyword.Kind)
      {
        case SyntaxKind.IfKeyword:
          break;
        default:
          throw new ArgumentException(nameof(ifKeyword));
      }
      if (openParenToken == null)
        throw new ArgumentNullException(nameof(openParenToken));
      switch (openParenToken.Kind)
      {
        case SyntaxKind.OpenParenToken:
          break;
        default:
          throw new ArgumentException(nameof(openParenToken));
      }
      if (condition == null)
        throw new ArgumentNullException(nameof(condition));
      if (closeParenToken == null)
        throw new ArgumentNullException(nameof(closeParenToken));
      switch (closeParenToken.Kind)
      {
        case SyntaxKind.CloseParenToken:
          break;
        default:
          throw new ArgumentException(nameof(closeParenToken));
      }
      if (statement == null)
        throw new ArgumentNullException(nameof(statement));
#endif

      return new IfStatementSyntax(SyntaxKind.IfStatement, ifKeyword, openParenToken, condition, closeParenToken, statement, @else, this.context);
    }

    public ElseClauseSyntax ElseClause(SyntaxToken elseKeyword, StatementSyntax statement)
    {
#if DEBUG
      if (elseKeyword == null)
        throw new ArgumentNullException(nameof(elseKeyword));
      switch (elseKeyword.Kind)
      {
        case SyntaxKind.ElseKeyword:
          break;
        default:
          throw new ArgumentException(nameof(elseKeyword));
      }
      if (statement == null)
        throw new ArgumentNullException(nameof(statement));
#endif

      int hash;
      var cached = CSharpSyntaxNodeCache.TryGetNode((int)SyntaxKind.ElseClause, elseKeyword, statement, this.context, out hash);
      if (cached != null) return (ElseClauseSyntax)cached;

      var result = new ElseClauseSyntax(SyntaxKind.ElseClause, elseKeyword, statement, this.context);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public SwitchStatementSyntax SwitchStatement(SyntaxToken switchKeyword, SyntaxToken openParenToken, ExpressionSyntax expression, SyntaxToken closeParenToken, SyntaxToken openBraceToken, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SwitchSectionSyntax> sections, SyntaxToken closeBraceToken)
    {
#if DEBUG
      if (switchKeyword == null)
        throw new ArgumentNullException(nameof(switchKeyword));
      switch (switchKeyword.Kind)
      {
        case SyntaxKind.SwitchKeyword:
          break;
        default:
          throw new ArgumentException(nameof(switchKeyword));
      }
      if (openParenToken != null)
      {
      switch (openParenToken.Kind)
      {
        case SyntaxKind.OpenParenToken:
        case SyntaxKind.None:
          break;
        default:
          throw new ArgumentException(nameof(openParenToken));
      }
      }
      if (expression == null)
        throw new ArgumentNullException(nameof(expression));
      if (closeParenToken != null)
      {
      switch (closeParenToken.Kind)
      {
        case SyntaxKind.CloseParenToken:
        case SyntaxKind.None:
          break;
        default:
          throw new ArgumentException(nameof(closeParenToken));
      }
      }
      if (openBraceToken == null)
        throw new ArgumentNullException(nameof(openBraceToken));
      switch (openBraceToken.Kind)
      {
        case SyntaxKind.OpenBraceToken:
          break;
        default:
          throw new ArgumentException(nameof(openBraceToken));
      }
      if (closeBraceToken == null)
        throw new ArgumentNullException(nameof(closeBraceToken));
      switch (closeBraceToken.Kind)
      {
        case SyntaxKind.CloseBraceToken:
          break;
        default:
          throw new ArgumentException(nameof(closeBraceToken));
      }
#endif

      return new SwitchStatementSyntax(SyntaxKind.SwitchStatement, switchKeyword, openParenToken, expression, closeParenToken, openBraceToken, sections.Node, closeBraceToken, this.context);
    }

    public SwitchSectionSyntax SwitchSection(Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SwitchLabelSyntax> labels, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<StatementSyntax> statements)
    {
#if DEBUG
#endif

      int hash;
      var cached = CSharpSyntaxNodeCache.TryGetNode((int)SyntaxKind.SwitchSection, labels.Node, statements.Node, this.context, out hash);
      if (cached != null) return (SwitchSectionSyntax)cached;

      var result = new SwitchSectionSyntax(SyntaxKind.SwitchSection, labels.Node, statements.Node, this.context);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public CasePatternSwitchLabelSyntax CasePatternSwitchLabel(SyntaxToken keyword, PatternSyntax pattern, WhenClauseSyntax whenClause, SyntaxToken colonToken)
    {
#if DEBUG
      if (keyword == null)
        throw new ArgumentNullException(nameof(keyword));
      switch (keyword.Kind)
      {
        case SyntaxKind.CaseKeyword:
          break;
        default:
          throw new ArgumentException(nameof(keyword));
      }
      if (pattern == null)
        throw new ArgumentNullException(nameof(pattern));
      if (colonToken == null)
        throw new ArgumentNullException(nameof(colonToken));
#endif

      return new CasePatternSwitchLabelSyntax(SyntaxKind.CasePatternSwitchLabel, keyword, pattern, whenClause, colonToken, this.context);
    }

    public CaseSwitchLabelSyntax CaseSwitchLabel(SyntaxToken keyword, ExpressionSyntax value, SyntaxToken colonToken)
    {
#if DEBUG
      if (keyword == null)
        throw new ArgumentNullException(nameof(keyword));
      switch (keyword.Kind)
      {
        case SyntaxKind.CaseKeyword:
          break;
        default:
          throw new ArgumentException(nameof(keyword));
      }
      if (value == null)
        throw new ArgumentNullException(nameof(value));
      if (colonToken == null)
        throw new ArgumentNullException(nameof(colonToken));
#endif

      int hash;
      var cached = CSharpSyntaxNodeCache.TryGetNode((int)SyntaxKind.CaseSwitchLabel, keyword, value, colonToken, this.context, out hash);
      if (cached != null) return (CaseSwitchLabelSyntax)cached;

      var result = new CaseSwitchLabelSyntax(SyntaxKind.CaseSwitchLabel, keyword, value, colonToken, this.context);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public DefaultSwitchLabelSyntax DefaultSwitchLabel(SyntaxToken keyword, SyntaxToken colonToken)
    {
#if DEBUG
      if (keyword == null)
        throw new ArgumentNullException(nameof(keyword));
      switch (keyword.Kind)
      {
        case SyntaxKind.DefaultKeyword:
          break;
        default:
          throw new ArgumentException(nameof(keyword));
      }
      if (colonToken == null)
        throw new ArgumentNullException(nameof(colonToken));
#endif

      int hash;
      var cached = CSharpSyntaxNodeCache.TryGetNode((int)SyntaxKind.DefaultSwitchLabel, keyword, colonToken, this.context, out hash);
      if (cached != null) return (DefaultSwitchLabelSyntax)cached;

      var result = new DefaultSwitchLabelSyntax(SyntaxKind.DefaultSwitchLabel, keyword, colonToken, this.context);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public SwitchExpressionSyntax SwitchExpression(ExpressionSyntax governingExpression, SyntaxToken switchKeyword, SyntaxToken openBraceToken, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<SwitchExpressionArmSyntax> arms, SyntaxToken closeBraceToken)
    {
#if DEBUG
      if (governingExpression == null)
        throw new ArgumentNullException(nameof(governingExpression));
      if (switchKeyword == null)
        throw new ArgumentNullException(nameof(switchKeyword));
      switch (switchKeyword.Kind)
      {
        case SyntaxKind.SwitchKeyword:
          break;
        default:
          throw new ArgumentException(nameof(switchKeyword));
      }
      if (openBraceToken == null)
        throw new ArgumentNullException(nameof(openBraceToken));
      switch (openBraceToken.Kind)
      {
        case SyntaxKind.OpenBraceToken:
          break;
        default:
          throw new ArgumentException(nameof(openBraceToken));
      }
      if (closeBraceToken == null)
        throw new ArgumentNullException(nameof(closeBraceToken));
      switch (closeBraceToken.Kind)
      {
        case SyntaxKind.CloseBraceToken:
          break;
        default:
          throw new ArgumentException(nameof(closeBraceToken));
      }
#endif

      return new SwitchExpressionSyntax(SyntaxKind.SwitchExpression, governingExpression, switchKeyword, openBraceToken, arms.Node, closeBraceToken, this.context);
    }

    public SwitchExpressionArmSyntax SwitchExpressionArm(PatternSyntax pattern, WhenClauseSyntax whenClause, SyntaxToken equalsGreaterThanToken, ExpressionSyntax expression)
    {
#if DEBUG
      if (pattern == null)
        throw new ArgumentNullException(nameof(pattern));
      if (equalsGreaterThanToken == null)
        throw new ArgumentNullException(nameof(equalsGreaterThanToken));
      switch (equalsGreaterThanToken.Kind)
      {
        case SyntaxKind.EqualsGreaterThanToken:
          break;
        default:
          throw new ArgumentException(nameof(equalsGreaterThanToken));
      }
      if (expression == null)
        throw new ArgumentNullException(nameof(expression));
#endif

      return new SwitchExpressionArmSyntax(SyntaxKind.SwitchExpressionArm, pattern, whenClause, equalsGreaterThanToken, expression, this.context);
    }

    public TryStatementSyntax TryStatement(SyntaxToken tryKeyword, BlockSyntax block, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<CatchClauseSyntax> catches, FinallyClauseSyntax @finally)
    {
#if DEBUG
      if (tryKeyword == null)
        throw new ArgumentNullException(nameof(tryKeyword));
      switch (tryKeyword.Kind)
      {
        case SyntaxKind.TryKeyword:
          break;
        default:
          throw new ArgumentException(nameof(tryKeyword));
      }
      if (block == null)
        throw new ArgumentNullException(nameof(block));
#endif

      return new TryStatementSyntax(SyntaxKind.TryStatement, tryKeyword, block, catches.Node, @finally, this.context);
    }

    public CatchClauseSyntax CatchClause(SyntaxToken catchKeyword, CatchDeclarationSyntax declaration, CatchFilterClauseSyntax filter, BlockSyntax block)
    {
#if DEBUG
      if (catchKeyword == null)
        throw new ArgumentNullException(nameof(catchKeyword));
      switch (catchKeyword.Kind)
      {
        case SyntaxKind.CatchKeyword:
          break;
        default:
          throw new ArgumentException(nameof(catchKeyword));
      }
      if (block == null)
        throw new ArgumentNullException(nameof(block));
#endif

      return new CatchClauseSyntax(SyntaxKind.CatchClause, catchKeyword, declaration, filter, block, this.context);
    }

    public CatchDeclarationSyntax CatchDeclaration(SyntaxToken openParenToken, TypeSyntax type, SyntaxToken identifier, SyntaxToken closeParenToken)
    {
#if DEBUG
      if (openParenToken == null)
        throw new ArgumentNullException(nameof(openParenToken));
      switch (openParenToken.Kind)
      {
        case SyntaxKind.OpenParenToken:
          break;
        default:
          throw new ArgumentException(nameof(openParenToken));
      }
      if (type == null)
        throw new ArgumentNullException(nameof(type));
      if (identifier != null)
      {
      switch (identifier.Kind)
      {
        case SyntaxKind.IdentifierToken:
        case SyntaxKind.None:
          break;
        default:
          throw new ArgumentException(nameof(identifier));
      }
      }
      if (closeParenToken == null)
        throw new ArgumentNullException(nameof(closeParenToken));
      switch (closeParenToken.Kind)
      {
        case SyntaxKind.CloseParenToken:
          break;
        default:
          throw new ArgumentException(nameof(closeParenToken));
      }
#endif

      return new CatchDeclarationSyntax(SyntaxKind.CatchDeclaration, openParenToken, type, identifier, closeParenToken, this.context);
    }

    public CatchFilterClauseSyntax CatchFilterClause(SyntaxToken whenKeyword, SyntaxToken openParenToken, ExpressionSyntax filterExpression, SyntaxToken closeParenToken)
    {
#if DEBUG
      if (whenKeyword == null)
        throw new ArgumentNullException(nameof(whenKeyword));
      switch (whenKeyword.Kind)
      {
        case SyntaxKind.WhenKeyword:
          break;
        default:
          throw new ArgumentException(nameof(whenKeyword));
      }
      if (openParenToken == null)
        throw new ArgumentNullException(nameof(openParenToken));
      switch (openParenToken.Kind)
      {
        case SyntaxKind.OpenParenToken:
          break;
        default:
          throw new ArgumentException(nameof(openParenToken));
      }
      if (filterExpression == null)
        throw new ArgumentNullException(nameof(filterExpression));
      if (closeParenToken == null)
        throw new ArgumentNullException(nameof(closeParenToken));
      switch (closeParenToken.Kind)
      {
        case SyntaxKind.CloseParenToken:
          break;
        default:
          throw new ArgumentException(nameof(closeParenToken));
      }
#endif

      return new CatchFilterClauseSyntax(SyntaxKind.CatchFilterClause, whenKeyword, openParenToken, filterExpression, closeParenToken, this.context);
    }

    public FinallyClauseSyntax FinallyClause(SyntaxToken finallyKeyword, BlockSyntax block)
    {
#if DEBUG
      if (finallyKeyword == null)
        throw new ArgumentNullException(nameof(finallyKeyword));
      switch (finallyKeyword.Kind)
      {
        case SyntaxKind.FinallyKeyword:
          break;
        default:
          throw new ArgumentException(nameof(finallyKeyword));
      }
      if (block == null)
        throw new ArgumentNullException(nameof(block));
#endif

      int hash;
      var cached = CSharpSyntaxNodeCache.TryGetNode((int)SyntaxKind.FinallyClause, finallyKeyword, block, this.context, out hash);
      if (cached != null) return (FinallyClauseSyntax)cached;

      var result = new FinallyClauseSyntax(SyntaxKind.FinallyClause, finallyKeyword, block, this.context);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public CompilationUnitSyntax CompilationUnit(Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<ExternAliasDirectiveSyntax> externs, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<UsingDirectiveSyntax> usings, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<AttributeListSyntax> attributeLists, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<MemberDeclarationSyntax> members, SyntaxToken endOfFileToken)
    {
#if DEBUG
      if (endOfFileToken == null)
        throw new ArgumentNullException(nameof(endOfFileToken));
      switch (endOfFileToken.Kind)
      {
        case SyntaxKind.EndOfFileToken:
          break;
        default:
          throw new ArgumentException(nameof(endOfFileToken));
      }
#endif

      return new CompilationUnitSyntax(SyntaxKind.CompilationUnit, externs.Node, usings.Node, attributeLists.Node, members.Node, endOfFileToken, this.context);
    }

    public ExternAliasDirectiveSyntax ExternAliasDirective(SyntaxToken externKeyword, SyntaxToken aliasKeyword, SyntaxToken identifier, SyntaxToken semicolonToken)
    {
#if DEBUG
      if (externKeyword == null)
        throw new ArgumentNullException(nameof(externKeyword));
      switch (externKeyword.Kind)
      {
        case SyntaxKind.ExternKeyword:
          break;
        default:
          throw new ArgumentException(nameof(externKeyword));
      }
      if (aliasKeyword == null)
        throw new ArgumentNullException(nameof(aliasKeyword));
      switch (aliasKeyword.Kind)
      {
        case SyntaxKind.AliasKeyword:
          break;
        default:
          throw new ArgumentException(nameof(aliasKeyword));
      }
      if (identifier == null)
        throw new ArgumentNullException(nameof(identifier));
      switch (identifier.Kind)
      {
        case SyntaxKind.IdentifierToken:
          break;
        default:
          throw new ArgumentException(nameof(identifier));
      }
      if (semicolonToken == null)
        throw new ArgumentNullException(nameof(semicolonToken));
      switch (semicolonToken.Kind)
      {
        case SyntaxKind.SemicolonToken:
          break;
        default:
          throw new ArgumentException(nameof(semicolonToken));
      }
#endif

      return new ExternAliasDirectiveSyntax(SyntaxKind.ExternAliasDirective, externKeyword, aliasKeyword, identifier, semicolonToken, this.context);
    }

    public UsingDirectiveSyntax UsingDirective(SyntaxToken usingKeyword, SyntaxToken staticKeyword, NameEqualsSyntax alias, NameSyntax name, SyntaxToken semicolonToken)
    {
#if DEBUG
      if (usingKeyword == null)
        throw new ArgumentNullException(nameof(usingKeyword));
      switch (usingKeyword.Kind)
      {
        case SyntaxKind.UsingKeyword:
          break;
        default:
          throw new ArgumentException(nameof(usingKeyword));
      }
      if (name == null)
        throw new ArgumentNullException(nameof(name));
      if (semicolonToken == null)
        throw new ArgumentNullException(nameof(semicolonToken));
      switch (semicolonToken.Kind)
      {
        case SyntaxKind.SemicolonToken:
          break;
        default:
          throw new ArgumentException(nameof(semicolonToken));
      }
#endif

      return new UsingDirectiveSyntax(SyntaxKind.UsingDirective, usingKeyword, staticKeyword, alias, name, semicolonToken, this.context);
    }

    public NamespaceDeclarationSyntax NamespaceDeclaration(Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<AttributeListSyntax> attributeLists, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SyntaxToken> modifiers, SyntaxToken namespaceKeyword, NameSyntax name, SyntaxToken openBraceToken, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<ExternAliasDirectiveSyntax> externs, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<UsingDirectiveSyntax> usings, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<MemberDeclarationSyntax> members, SyntaxToken closeBraceToken, SyntaxToken semicolonToken)
    {
#if DEBUG
      if (namespaceKeyword == null)
        throw new ArgumentNullException(nameof(namespaceKeyword));
      switch (namespaceKeyword.Kind)
      {
        case SyntaxKind.NamespaceKeyword:
          break;
        default:
          throw new ArgumentException(nameof(namespaceKeyword));
      }
      if (name == null)
        throw new ArgumentNullException(nameof(name));
      if (openBraceToken == null)
        throw new ArgumentNullException(nameof(openBraceToken));
      switch (openBraceToken.Kind)
      {
        case SyntaxKind.OpenBraceToken:
          break;
        default:
          throw new ArgumentException(nameof(openBraceToken));
      }
      if (closeBraceToken == null)
        throw new ArgumentNullException(nameof(closeBraceToken));
      switch (closeBraceToken.Kind)
      {
        case SyntaxKind.CloseBraceToken:
          break;
        default:
          throw new ArgumentException(nameof(closeBraceToken));
      }
      if (semicolonToken != null)
      {
      switch (semicolonToken.Kind)
      {
        case SyntaxKind.SemicolonToken:
        case SyntaxKind.None:
          break;
        default:
          throw new ArgumentException(nameof(semicolonToken));
      }
      }
#endif

      return new NamespaceDeclarationSyntax(SyntaxKind.NamespaceDeclaration, attributeLists.Node, modifiers.Node, namespaceKeyword, name, openBraceToken, externs.Node, usings.Node, members.Node, closeBraceToken, semicolonToken, this.context);
    }

    public AttributeListSyntax AttributeList(SyntaxToken openBracketToken, AttributeTargetSpecifierSyntax target, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<AttributeSyntax> attributes, SyntaxToken closeBracketToken)
    {
#if DEBUG
      if (openBracketToken == null)
        throw new ArgumentNullException(nameof(openBracketToken));
      switch (openBracketToken.Kind)
      {
        case SyntaxKind.OpenBracketToken:
          break;
        default:
          throw new ArgumentException(nameof(openBracketToken));
      }
      if (closeBracketToken == null)
        throw new ArgumentNullException(nameof(closeBracketToken));
      switch (closeBracketToken.Kind)
      {
        case SyntaxKind.CloseBracketToken:
          break;
        default:
          throw new ArgumentException(nameof(closeBracketToken));
      }
#endif

      return new AttributeListSyntax(SyntaxKind.AttributeList, openBracketToken, target, attributes.Node, closeBracketToken, this.context);
    }

    public AttributeTargetSpecifierSyntax AttributeTargetSpecifier(SyntaxToken identifier, SyntaxToken colonToken)
    {
#if DEBUG
      if (identifier == null)
        throw new ArgumentNullException(nameof(identifier));
      if (colonToken == null)
        throw new ArgumentNullException(nameof(colonToken));
      switch (colonToken.Kind)
      {
        case SyntaxKind.ColonToken:
          break;
        default:
          throw new ArgumentException(nameof(colonToken));
      }
#endif

      int hash;
      var cached = CSharpSyntaxNodeCache.TryGetNode((int)SyntaxKind.AttributeTargetSpecifier, identifier, colonToken, this.context, out hash);
      if (cached != null) return (AttributeTargetSpecifierSyntax)cached;

      var result = new AttributeTargetSpecifierSyntax(SyntaxKind.AttributeTargetSpecifier, identifier, colonToken, this.context);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public AttributeSyntax Attribute(NameSyntax name, AttributeArgumentListSyntax argumentList)
    {
#if DEBUG
      if (name == null)
        throw new ArgumentNullException(nameof(name));
#endif

      int hash;
      var cached = CSharpSyntaxNodeCache.TryGetNode((int)SyntaxKind.Attribute, name, argumentList, this.context, out hash);
      if (cached != null) return (AttributeSyntax)cached;

      var result = new AttributeSyntax(SyntaxKind.Attribute, name, argumentList, this.context);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public AttributeArgumentListSyntax AttributeArgumentList(SyntaxToken openParenToken, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<AttributeArgumentSyntax> arguments, SyntaxToken closeParenToken)
    {
#if DEBUG
      if (openParenToken == null)
        throw new ArgumentNullException(nameof(openParenToken));
      switch (openParenToken.Kind)
      {
        case SyntaxKind.OpenParenToken:
          break;
        default:
          throw new ArgumentException(nameof(openParenToken));
      }
      if (closeParenToken == null)
        throw new ArgumentNullException(nameof(closeParenToken));
      switch (closeParenToken.Kind)
      {
        case SyntaxKind.CloseParenToken:
          break;
        default:
          throw new ArgumentException(nameof(closeParenToken));
      }
#endif

      int hash;
      var cached = CSharpSyntaxNodeCache.TryGetNode((int)SyntaxKind.AttributeArgumentList, openParenToken, arguments.Node, closeParenToken, this.context, out hash);
      if (cached != null) return (AttributeArgumentListSyntax)cached;

      var result = new AttributeArgumentListSyntax(SyntaxKind.AttributeArgumentList, openParenToken, arguments.Node, closeParenToken, this.context);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public AttributeArgumentSyntax AttributeArgument(NameEqualsSyntax nameEquals, NameColonSyntax nameColon, ExpressionSyntax expression)
    {
#if DEBUG
      if (expression == null)
        throw new ArgumentNullException(nameof(expression));
#endif

      int hash;
      var cached = CSharpSyntaxNodeCache.TryGetNode((int)SyntaxKind.AttributeArgument, nameEquals, nameColon, expression, this.context, out hash);
      if (cached != null) return (AttributeArgumentSyntax)cached;

      var result = new AttributeArgumentSyntax(SyntaxKind.AttributeArgument, nameEquals, nameColon, expression, this.context);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public NameEqualsSyntax NameEquals(IdentifierNameSyntax name, SyntaxToken equalsToken)
    {
#if DEBUG
      if (name == null)
        throw new ArgumentNullException(nameof(name));
      if (equalsToken == null)
        throw new ArgumentNullException(nameof(equalsToken));
      switch (equalsToken.Kind)
      {
        case SyntaxKind.EqualsToken:
          break;
        default:
          throw new ArgumentException(nameof(equalsToken));
      }
#endif

      int hash;
      var cached = CSharpSyntaxNodeCache.TryGetNode((int)SyntaxKind.NameEquals, name, equalsToken, this.context, out hash);
      if (cached != null) return (NameEqualsSyntax)cached;

      var result = new NameEqualsSyntax(SyntaxKind.NameEquals, name, equalsToken, this.context);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public TypeParameterListSyntax TypeParameterList(SyntaxToken lessThanToken, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<TypeParameterSyntax> parameters, SyntaxToken greaterThanToken)
    {
#if DEBUG
      if (lessThanToken == null)
        throw new ArgumentNullException(nameof(lessThanToken));
      switch (lessThanToken.Kind)
      {
        case SyntaxKind.LessThanToken:
          break;
        default:
          throw new ArgumentException(nameof(lessThanToken));
      }
      if (greaterThanToken == null)
        throw new ArgumentNullException(nameof(greaterThanToken));
      switch (greaterThanToken.Kind)
      {
        case SyntaxKind.GreaterThanToken:
          break;
        default:
          throw new ArgumentException(nameof(greaterThanToken));
      }
#endif

      int hash;
      var cached = CSharpSyntaxNodeCache.TryGetNode((int)SyntaxKind.TypeParameterList, lessThanToken, parameters.Node, greaterThanToken, this.context, out hash);
      if (cached != null) return (TypeParameterListSyntax)cached;

      var result = new TypeParameterListSyntax(SyntaxKind.TypeParameterList, lessThanToken, parameters.Node, greaterThanToken, this.context);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public TypeParameterSyntax TypeParameter(Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<AttributeListSyntax> attributeLists, SyntaxToken varianceKeyword, SyntaxToken identifier)
    {
#if DEBUG
      if (varianceKeyword != null)
      {
      switch (varianceKeyword.Kind)
      {
        case SyntaxKind.InKeyword:
        case SyntaxKind.OutKeyword:
        case SyntaxKind.None:
          break;
        default:
          throw new ArgumentException(nameof(varianceKeyword));
      }
      }
      if (identifier == null)
        throw new ArgumentNullException(nameof(identifier));
      switch (identifier.Kind)
      {
        case SyntaxKind.IdentifierToken:
          break;
        default:
          throw new ArgumentException(nameof(identifier));
      }
#endif

      int hash;
      var cached = CSharpSyntaxNodeCache.TryGetNode((int)SyntaxKind.TypeParameter, attributeLists.Node, varianceKeyword, identifier, this.context, out hash);
      if (cached != null) return (TypeParameterSyntax)cached;

      var result = new TypeParameterSyntax(SyntaxKind.TypeParameter, attributeLists.Node, varianceKeyword, identifier, this.context);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public ClassDeclarationSyntax ClassDeclaration(Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<AttributeListSyntax> attributeLists, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SyntaxToken> modifiers, SyntaxToken keyword, SyntaxToken identifier, TypeParameterListSyntax typeParameterList, BaseListSyntax baseList, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<TypeParameterConstraintClauseSyntax> constraintClauses, SyntaxToken openBraceToken, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<MemberDeclarationSyntax> members, SyntaxToken closeBraceToken, SyntaxToken semicolonToken)
    {
#if DEBUG
      if (keyword == null)
        throw new ArgumentNullException(nameof(keyword));
      switch (keyword.Kind)
      {
        case SyntaxKind.ClassKeyword:
          break;
        default:
          throw new ArgumentException(nameof(keyword));
      }
      if (identifier == null)
        throw new ArgumentNullException(nameof(identifier));
      switch (identifier.Kind)
      {
        case SyntaxKind.IdentifierToken:
          break;
        default:
          throw new ArgumentException(nameof(identifier));
      }
      if (openBraceToken == null)
        throw new ArgumentNullException(nameof(openBraceToken));
      switch (openBraceToken.Kind)
      {
        case SyntaxKind.OpenBraceToken:
          break;
        default:
          throw new ArgumentException(nameof(openBraceToken));
      }
      if (closeBraceToken == null)
        throw new ArgumentNullException(nameof(closeBraceToken));
      switch (closeBraceToken.Kind)
      {
        case SyntaxKind.CloseBraceToken:
          break;
        default:
          throw new ArgumentException(nameof(closeBraceToken));
      }
      if (semicolonToken != null)
      {
      switch (semicolonToken.Kind)
      {
        case SyntaxKind.SemicolonToken:
        case SyntaxKind.None:
          break;
        default:
          throw new ArgumentException(nameof(semicolonToken));
      }
      }
#endif

      return new ClassDeclarationSyntax(SyntaxKind.ClassDeclaration, attributeLists.Node, modifiers.Node, keyword, identifier, typeParameterList, baseList, constraintClauses.Node, openBraceToken, members.Node, closeBraceToken, semicolonToken, this.context);
    }

    public StructDeclarationSyntax StructDeclaration(Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<AttributeListSyntax> attributeLists, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SyntaxToken> modifiers, SyntaxToken keyword, SyntaxToken identifier, TypeParameterListSyntax typeParameterList, BaseListSyntax baseList, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<TypeParameterConstraintClauseSyntax> constraintClauses, SyntaxToken openBraceToken, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<MemberDeclarationSyntax> members, SyntaxToken closeBraceToken, SyntaxToken semicolonToken)
    {
#if DEBUG
      if (keyword == null)
        throw new ArgumentNullException(nameof(keyword));
      switch (keyword.Kind)
      {
        case SyntaxKind.StructKeyword:
          break;
        default:
          throw new ArgumentException(nameof(keyword));
      }
      if (identifier == null)
        throw new ArgumentNullException(nameof(identifier));
      switch (identifier.Kind)
      {
        case SyntaxKind.IdentifierToken:
          break;
        default:
          throw new ArgumentException(nameof(identifier));
      }
      if (openBraceToken == null)
        throw new ArgumentNullException(nameof(openBraceToken));
      switch (openBraceToken.Kind)
      {
        case SyntaxKind.OpenBraceToken:
          break;
        default:
          throw new ArgumentException(nameof(openBraceToken));
      }
      if (closeBraceToken == null)
        throw new ArgumentNullException(nameof(closeBraceToken));
      switch (closeBraceToken.Kind)
      {
        case SyntaxKind.CloseBraceToken:
          break;
        default:
          throw new ArgumentException(nameof(closeBraceToken));
      }
      if (semicolonToken != null)
      {
      switch (semicolonToken.Kind)
      {
        case SyntaxKind.SemicolonToken:
        case SyntaxKind.None:
          break;
        default:
          throw new ArgumentException(nameof(semicolonToken));
      }
      }
#endif

      return new StructDeclarationSyntax(SyntaxKind.StructDeclaration, attributeLists.Node, modifiers.Node, keyword, identifier, typeParameterList, baseList, constraintClauses.Node, openBraceToken, members.Node, closeBraceToken, semicolonToken, this.context);
    }

    public InterfaceDeclarationSyntax InterfaceDeclaration(Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<AttributeListSyntax> attributeLists, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SyntaxToken> modifiers, SyntaxToken keyword, SyntaxToken identifier, TypeParameterListSyntax typeParameterList, BaseListSyntax baseList, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<TypeParameterConstraintClauseSyntax> constraintClauses, SyntaxToken openBraceToken, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<MemberDeclarationSyntax> members, SyntaxToken closeBraceToken, SyntaxToken semicolonToken)
    {
#if DEBUG
      if (keyword == null)
        throw new ArgumentNullException(nameof(keyword));
      switch (keyword.Kind)
      {
        case SyntaxKind.InterfaceKeyword:
          break;
        default:
          throw new ArgumentException(nameof(keyword));
      }
      if (identifier == null)
        throw new ArgumentNullException(nameof(identifier));
      switch (identifier.Kind)
      {
        case SyntaxKind.IdentifierToken:
          break;
        default:
          throw new ArgumentException(nameof(identifier));
      }
      if (openBraceToken == null)
        throw new ArgumentNullException(nameof(openBraceToken));
      switch (openBraceToken.Kind)
      {
        case SyntaxKind.OpenBraceToken:
          break;
        default:
          throw new ArgumentException(nameof(openBraceToken));
      }
      if (closeBraceToken == null)
        throw new ArgumentNullException(nameof(closeBraceToken));
      switch (closeBraceToken.Kind)
      {
        case SyntaxKind.CloseBraceToken:
          break;
        default:
          throw new ArgumentException(nameof(closeBraceToken));
      }
      if (semicolonToken != null)
      {
      switch (semicolonToken.Kind)
      {
        case SyntaxKind.SemicolonToken:
        case SyntaxKind.None:
          break;
        default:
          throw new ArgumentException(nameof(semicolonToken));
      }
      }
#endif

      return new InterfaceDeclarationSyntax(SyntaxKind.InterfaceDeclaration, attributeLists.Node, modifiers.Node, keyword, identifier, typeParameterList, baseList, constraintClauses.Node, openBraceToken, members.Node, closeBraceToken, semicolonToken, this.context);
    }

    public EnumDeclarationSyntax EnumDeclaration(Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<AttributeListSyntax> attributeLists, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SyntaxToken> modifiers, SyntaxToken enumKeyword, SyntaxToken identifier, BaseListSyntax baseList, SyntaxToken openBraceToken, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<EnumMemberDeclarationSyntax> members, SyntaxToken closeBraceToken, SyntaxToken semicolonToken)
    {
#if DEBUG
      if (enumKeyword == null)
        throw new ArgumentNullException(nameof(enumKeyword));
      switch (enumKeyword.Kind)
      {
        case SyntaxKind.EnumKeyword:
          break;
        default:
          throw new ArgumentException(nameof(enumKeyword));
      }
      if (identifier == null)
        throw new ArgumentNullException(nameof(identifier));
      switch (identifier.Kind)
      {
        case SyntaxKind.IdentifierToken:
          break;
        default:
          throw new ArgumentException(nameof(identifier));
      }
      if (openBraceToken == null)
        throw new ArgumentNullException(nameof(openBraceToken));
      switch (openBraceToken.Kind)
      {
        case SyntaxKind.OpenBraceToken:
          break;
        default:
          throw new ArgumentException(nameof(openBraceToken));
      }
      if (closeBraceToken == null)
        throw new ArgumentNullException(nameof(closeBraceToken));
      switch (closeBraceToken.Kind)
      {
        case SyntaxKind.CloseBraceToken:
          break;
        default:
          throw new ArgumentException(nameof(closeBraceToken));
      }
      if (semicolonToken != null)
      {
      switch (semicolonToken.Kind)
      {
        case SyntaxKind.SemicolonToken:
        case SyntaxKind.None:
          break;
        default:
          throw new ArgumentException(nameof(semicolonToken));
      }
      }
#endif

      return new EnumDeclarationSyntax(SyntaxKind.EnumDeclaration, attributeLists.Node, modifiers.Node, enumKeyword, identifier, baseList, openBraceToken, members.Node, closeBraceToken, semicolonToken, this.context);
    }

    public DelegateDeclarationSyntax DelegateDeclaration(Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<AttributeListSyntax> attributeLists, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SyntaxToken> modifiers, SyntaxToken delegateKeyword, TypeSyntax returnType, SyntaxToken identifier, TypeParameterListSyntax typeParameterList, ParameterListSyntax parameterList, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<TypeParameterConstraintClauseSyntax> constraintClauses, SyntaxToken semicolonToken)
    {
#if DEBUG
      if (delegateKeyword == null)
        throw new ArgumentNullException(nameof(delegateKeyword));
      switch (delegateKeyword.Kind)
      {
        case SyntaxKind.DelegateKeyword:
          break;
        default:
          throw new ArgumentException(nameof(delegateKeyword));
      }
      if (returnType == null)
        throw new ArgumentNullException(nameof(returnType));
      if (identifier == null)
        throw new ArgumentNullException(nameof(identifier));
      switch (identifier.Kind)
      {
        case SyntaxKind.IdentifierToken:
          break;
        default:
          throw new ArgumentException(nameof(identifier));
      }
      if (parameterList == null)
        throw new ArgumentNullException(nameof(parameterList));
      if (semicolonToken == null)
        throw new ArgumentNullException(nameof(semicolonToken));
      switch (semicolonToken.Kind)
      {
        case SyntaxKind.SemicolonToken:
          break;
        default:
          throw new ArgumentException(nameof(semicolonToken));
      }
#endif

      return new DelegateDeclarationSyntax(SyntaxKind.DelegateDeclaration, attributeLists.Node, modifiers.Node, delegateKeyword, returnType, identifier, typeParameterList, parameterList, constraintClauses.Node, semicolonToken, this.context);
    }

    public EnumMemberDeclarationSyntax EnumMemberDeclaration(Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<AttributeListSyntax> attributeLists, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SyntaxToken> modifiers, SyntaxToken identifier, EqualsValueClauseSyntax equalsValue)
    {
#if DEBUG
      if (identifier == null)
        throw new ArgumentNullException(nameof(identifier));
      switch (identifier.Kind)
      {
        case SyntaxKind.IdentifierToken:
          break;
        default:
          throw new ArgumentException(nameof(identifier));
      }
#endif

      return new EnumMemberDeclarationSyntax(SyntaxKind.EnumMemberDeclaration, attributeLists.Node, modifiers.Node, identifier, equalsValue, this.context);
    }

    public BaseListSyntax BaseList(SyntaxToken colonToken, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<BaseTypeSyntax> types)
    {
#if DEBUG
      if (colonToken == null)
        throw new ArgumentNullException(nameof(colonToken));
      switch (colonToken.Kind)
      {
        case SyntaxKind.ColonToken:
          break;
        default:
          throw new ArgumentException(nameof(colonToken));
      }
#endif

      int hash;
      var cached = CSharpSyntaxNodeCache.TryGetNode((int)SyntaxKind.BaseList, colonToken, types.Node, this.context, out hash);
      if (cached != null) return (BaseListSyntax)cached;

      var result = new BaseListSyntax(SyntaxKind.BaseList, colonToken, types.Node, this.context);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public SimpleBaseTypeSyntax SimpleBaseType(TypeSyntax type)
    {
#if DEBUG
      if (type == null)
        throw new ArgumentNullException(nameof(type));
#endif

      int hash;
      var cached = CSharpSyntaxNodeCache.TryGetNode((int)SyntaxKind.SimpleBaseType, type, this.context, out hash);
      if (cached != null) return (SimpleBaseTypeSyntax)cached;

      var result = new SimpleBaseTypeSyntax(SyntaxKind.SimpleBaseType, type, this.context);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public TypeParameterConstraintClauseSyntax TypeParameterConstraintClause(SyntaxToken whereKeyword, IdentifierNameSyntax name, SyntaxToken colonToken, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<TypeParameterConstraintSyntax> constraints)
    {
#if DEBUG
      if (whereKeyword == null)
        throw new ArgumentNullException(nameof(whereKeyword));
      switch (whereKeyword.Kind)
      {
        case SyntaxKind.WhereKeyword:
          break;
        default:
          throw new ArgumentException(nameof(whereKeyword));
      }
      if (name == null)
        throw new ArgumentNullException(nameof(name));
      if (colonToken == null)
        throw new ArgumentNullException(nameof(colonToken));
      switch (colonToken.Kind)
      {
        case SyntaxKind.ColonToken:
          break;
        default:
          throw new ArgumentException(nameof(colonToken));
      }
#endif

      return new TypeParameterConstraintClauseSyntax(SyntaxKind.TypeParameterConstraintClause, whereKeyword, name, colonToken, constraints.Node, this.context);
    }

    public ConstructorConstraintSyntax ConstructorConstraint(SyntaxToken newKeyword, SyntaxToken openParenToken, SyntaxToken closeParenToken)
    {
#if DEBUG
      if (newKeyword == null)
        throw new ArgumentNullException(nameof(newKeyword));
      switch (newKeyword.Kind)
      {
        case SyntaxKind.NewKeyword:
          break;
        default:
          throw new ArgumentException(nameof(newKeyword));
      }
      if (openParenToken == null)
        throw new ArgumentNullException(nameof(openParenToken));
      switch (openParenToken.Kind)
      {
        case SyntaxKind.OpenParenToken:
          break;
        default:
          throw new ArgumentException(nameof(openParenToken));
      }
      if (closeParenToken == null)
        throw new ArgumentNullException(nameof(closeParenToken));
      switch (closeParenToken.Kind)
      {
        case SyntaxKind.CloseParenToken:
          break;
        default:
          throw new ArgumentException(nameof(closeParenToken));
      }
#endif

      int hash;
      var cached = CSharpSyntaxNodeCache.TryGetNode((int)SyntaxKind.ConstructorConstraint, newKeyword, openParenToken, closeParenToken, this.context, out hash);
      if (cached != null) return (ConstructorConstraintSyntax)cached;

      var result = new ConstructorConstraintSyntax(SyntaxKind.ConstructorConstraint, newKeyword, openParenToken, closeParenToken, this.context);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public ClassOrStructConstraintSyntax ClassOrStructConstraint(SyntaxKind kind, SyntaxToken classOrStructKeyword, SyntaxToken questionToken)
    {
      switch (kind)
      {
        case SyntaxKind.ClassConstraint:
        case SyntaxKind.StructConstraint:
          break;
        default:
          throw new ArgumentException(nameof(kind));
      }
#if DEBUG
      if (classOrStructKeyword == null)
        throw new ArgumentNullException(nameof(classOrStructKeyword));
      switch (classOrStructKeyword.Kind)
      {
        case SyntaxKind.ClassKeyword:
        case SyntaxKind.StructKeyword:
          break;
        default:
          throw new ArgumentException(nameof(classOrStructKeyword));
      }
      if (questionToken != null)
      {
      switch (questionToken.Kind)
      {
        case SyntaxKind.QuestionToken:
        case SyntaxKind.None:
          break;
        default:
          throw new ArgumentException(nameof(questionToken));
      }
      }
#endif

      int hash;
      var cached = CSharpSyntaxNodeCache.TryGetNode((int)kind, classOrStructKeyword, questionToken, this.context, out hash);
      if (cached != null) return (ClassOrStructConstraintSyntax)cached;

      var result = new ClassOrStructConstraintSyntax(kind, classOrStructKeyword, questionToken, this.context);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public TypeConstraintSyntax TypeConstraint(TypeSyntax type)
    {
#if DEBUG
      if (type == null)
        throw new ArgumentNullException(nameof(type));
#endif

      int hash;
      var cached = CSharpSyntaxNodeCache.TryGetNode((int)SyntaxKind.TypeConstraint, type, this.context, out hash);
      if (cached != null) return (TypeConstraintSyntax)cached;

      var result = new TypeConstraintSyntax(SyntaxKind.TypeConstraint, type, this.context);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public FieldDeclarationSyntax FieldDeclaration(Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<AttributeListSyntax> attributeLists, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SyntaxToken> modifiers, VariableDeclarationSyntax declaration, SyntaxToken semicolonToken)
    {
#if DEBUG
      if (declaration == null)
        throw new ArgumentNullException(nameof(declaration));
      if (semicolonToken == null)
        throw new ArgumentNullException(nameof(semicolonToken));
      switch (semicolonToken.Kind)
      {
        case SyntaxKind.SemicolonToken:
          break;
        default:
          throw new ArgumentException(nameof(semicolonToken));
      }
#endif

      return new FieldDeclarationSyntax(SyntaxKind.FieldDeclaration, attributeLists.Node, modifiers.Node, declaration, semicolonToken, this.context);
    }

    public EventFieldDeclarationSyntax EventFieldDeclaration(Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<AttributeListSyntax> attributeLists, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SyntaxToken> modifiers, SyntaxToken eventKeyword, VariableDeclarationSyntax declaration, SyntaxToken semicolonToken)
    {
#if DEBUG
      if (eventKeyword == null)
        throw new ArgumentNullException(nameof(eventKeyword));
      switch (eventKeyword.Kind)
      {
        case SyntaxKind.EventKeyword:
          break;
        default:
          throw new ArgumentException(nameof(eventKeyword));
      }
      if (declaration == null)
        throw new ArgumentNullException(nameof(declaration));
      if (semicolonToken == null)
        throw new ArgumentNullException(nameof(semicolonToken));
      switch (semicolonToken.Kind)
      {
        case SyntaxKind.SemicolonToken:
          break;
        default:
          throw new ArgumentException(nameof(semicolonToken));
      }
#endif

      return new EventFieldDeclarationSyntax(SyntaxKind.EventFieldDeclaration, attributeLists.Node, modifiers.Node, eventKeyword, declaration, semicolonToken, this.context);
    }

    public ExplicitInterfaceSpecifierSyntax ExplicitInterfaceSpecifier(NameSyntax name, SyntaxToken dotToken)
    {
#if DEBUG
      if (name == null)
        throw new ArgumentNullException(nameof(name));
      if (dotToken == null)
        throw new ArgumentNullException(nameof(dotToken));
      switch (dotToken.Kind)
      {
        case SyntaxKind.DotToken:
          break;
        default:
          throw new ArgumentException(nameof(dotToken));
      }
#endif

      int hash;
      var cached = CSharpSyntaxNodeCache.TryGetNode((int)SyntaxKind.ExplicitInterfaceSpecifier, name, dotToken, this.context, out hash);
      if (cached != null) return (ExplicitInterfaceSpecifierSyntax)cached;

      var result = new ExplicitInterfaceSpecifierSyntax(SyntaxKind.ExplicitInterfaceSpecifier, name, dotToken, this.context);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public MethodDeclarationSyntax MethodDeclaration(Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<AttributeListSyntax> attributeLists, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SyntaxToken> modifiers, TypeSyntax returnType, ExplicitInterfaceSpecifierSyntax explicitInterfaceSpecifier, SyntaxToken identifier, TypeParameterListSyntax typeParameterList, ParameterListSyntax parameterList, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<TypeParameterConstraintClauseSyntax> constraintClauses, BlockSyntax body, ArrowExpressionClauseSyntax expressionBody, SyntaxToken semicolonToken)
    {
#if DEBUG
      if (returnType == null)
        throw new ArgumentNullException(nameof(returnType));
      if (identifier == null)
        throw new ArgumentNullException(nameof(identifier));
      switch (identifier.Kind)
      {
        case SyntaxKind.IdentifierToken:
          break;
        default:
          throw new ArgumentException(nameof(identifier));
      }
      if (parameterList == null)
        throw new ArgumentNullException(nameof(parameterList));
      if (semicolonToken != null)
      {
      switch (semicolonToken.Kind)
      {
        case SyntaxKind.SemicolonToken:
        case SyntaxKind.None:
          break;
        default:
          throw new ArgumentException(nameof(semicolonToken));
      }
      }
#endif

      return new MethodDeclarationSyntax(SyntaxKind.MethodDeclaration, attributeLists.Node, modifiers.Node, returnType, explicitInterfaceSpecifier, identifier, typeParameterList, parameterList, constraintClauses.Node, body, expressionBody, semicolonToken, this.context);
    }

    public OperatorDeclarationSyntax OperatorDeclaration(Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<AttributeListSyntax> attributeLists, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SyntaxToken> modifiers, TypeSyntax returnType, SyntaxToken operatorKeyword, SyntaxToken operatorToken, ParameterListSyntax parameterList, BlockSyntax body, ArrowExpressionClauseSyntax expressionBody, SyntaxToken semicolonToken)
    {
#if DEBUG
      if (returnType == null)
        throw new ArgumentNullException(nameof(returnType));
      if (operatorKeyword == null)
        throw new ArgumentNullException(nameof(operatorKeyword));
      switch (operatorKeyword.Kind)
      {
        case SyntaxKind.OperatorKeyword:
          break;
        default:
          throw new ArgumentException(nameof(operatorKeyword));
      }
      if (operatorToken == null)
        throw new ArgumentNullException(nameof(operatorToken));
      switch (operatorToken.Kind)
      {
        case SyntaxKind.PlusToken:
        case SyntaxKind.MinusToken:
        case SyntaxKind.ExclamationToken:
        case SyntaxKind.TildeToken:
        case SyntaxKind.PlusPlusToken:
        case SyntaxKind.MinusMinusToken:
        case SyntaxKind.AsteriskToken:
        case SyntaxKind.SlashToken:
        case SyntaxKind.PercentToken:
        case SyntaxKind.LessThanLessThanToken:
        case SyntaxKind.GreaterThanGreaterThanToken:
        case SyntaxKind.BarToken:
        case SyntaxKind.AmpersandToken:
        case SyntaxKind.CaretToken:
        case SyntaxKind.EqualsEqualsToken:
        case SyntaxKind.ExclamationEqualsToken:
        case SyntaxKind.LessThanToken:
        case SyntaxKind.LessThanEqualsToken:
        case SyntaxKind.GreaterThanToken:
        case SyntaxKind.GreaterThanEqualsToken:
        case SyntaxKind.FalseKeyword:
        case SyntaxKind.TrueKeyword:
        case SyntaxKind.IsKeyword:
          break;
        default:
          throw new ArgumentException(nameof(operatorToken));
      }
      if (parameterList == null)
        throw new ArgumentNullException(nameof(parameterList));
      if (semicolonToken != null)
      {
      switch (semicolonToken.Kind)
      {
        case SyntaxKind.SemicolonToken:
        case SyntaxKind.None:
          break;
        default:
          throw new ArgumentException(nameof(semicolonToken));
      }
      }
#endif

      return new OperatorDeclarationSyntax(SyntaxKind.OperatorDeclaration, attributeLists.Node, modifiers.Node, returnType, operatorKeyword, operatorToken, parameterList, body, expressionBody, semicolonToken, this.context);
    }

    public ConversionOperatorDeclarationSyntax ConversionOperatorDeclaration(Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<AttributeListSyntax> attributeLists, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SyntaxToken> modifiers, SyntaxToken implicitOrExplicitKeyword, SyntaxToken operatorKeyword, TypeSyntax type, ParameterListSyntax parameterList, BlockSyntax body, ArrowExpressionClauseSyntax expressionBody, SyntaxToken semicolonToken)
    {
#if DEBUG
      if (implicitOrExplicitKeyword == null)
        throw new ArgumentNullException(nameof(implicitOrExplicitKeyword));
      switch (implicitOrExplicitKeyword.Kind)
      {
        case SyntaxKind.ImplicitKeyword:
        case SyntaxKind.ExplicitKeyword:
          break;
        default:
          throw new ArgumentException(nameof(implicitOrExplicitKeyword));
      }
      if (operatorKeyword == null)
        throw new ArgumentNullException(nameof(operatorKeyword));
      switch (operatorKeyword.Kind)
      {
        case SyntaxKind.OperatorKeyword:
          break;
        default:
          throw new ArgumentException(nameof(operatorKeyword));
      }
      if (type == null)
        throw new ArgumentNullException(nameof(type));
      if (parameterList == null)
        throw new ArgumentNullException(nameof(parameterList));
      if (semicolonToken != null)
      {
      switch (semicolonToken.Kind)
      {
        case SyntaxKind.SemicolonToken:
        case SyntaxKind.None:
          break;
        default:
          throw new ArgumentException(nameof(semicolonToken));
      }
      }
#endif

      return new ConversionOperatorDeclarationSyntax(SyntaxKind.ConversionOperatorDeclaration, attributeLists.Node, modifiers.Node, implicitOrExplicitKeyword, operatorKeyword, type, parameterList, body, expressionBody, semicolonToken, this.context);
    }

    public ConstructorDeclarationSyntax ConstructorDeclaration(Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<AttributeListSyntax> attributeLists, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SyntaxToken> modifiers, SyntaxToken identifier, ParameterListSyntax parameterList, ConstructorInitializerSyntax initializer, BlockSyntax body, ArrowExpressionClauseSyntax expressionBody, SyntaxToken semicolonToken)
    {
#if DEBUG
      if (identifier == null)
        throw new ArgumentNullException(nameof(identifier));
      switch (identifier.Kind)
      {
        case SyntaxKind.IdentifierToken:
          break;
        default:
          throw new ArgumentException(nameof(identifier));
      }
      if (parameterList == null)
        throw new ArgumentNullException(nameof(parameterList));
      if (semicolonToken != null)
      {
      switch (semicolonToken.Kind)
      {
        case SyntaxKind.SemicolonToken:
        case SyntaxKind.None:
          break;
        default:
          throw new ArgumentException(nameof(semicolonToken));
      }
      }
#endif

      return new ConstructorDeclarationSyntax(SyntaxKind.ConstructorDeclaration, attributeLists.Node, modifiers.Node, identifier, parameterList, initializer, body, expressionBody, semicolonToken, this.context);
    }

    public ConstructorInitializerSyntax ConstructorInitializer(SyntaxKind kind, SyntaxToken colonToken, SyntaxToken thisOrBaseKeyword, ArgumentListSyntax argumentList)
    {
      switch (kind)
      {
        case SyntaxKind.BaseConstructorInitializer:
        case SyntaxKind.ThisConstructorInitializer:
          break;
        default:
          throw new ArgumentException(nameof(kind));
      }
#if DEBUG
      if (colonToken == null)
        throw new ArgumentNullException(nameof(colonToken));
      switch (colonToken.Kind)
      {
        case SyntaxKind.ColonToken:
          break;
        default:
          throw new ArgumentException(nameof(colonToken));
      }
      if (thisOrBaseKeyword == null)
        throw new ArgumentNullException(nameof(thisOrBaseKeyword));
      switch (thisOrBaseKeyword.Kind)
      {
        case SyntaxKind.BaseKeyword:
        case SyntaxKind.ThisKeyword:
          break;
        default:
          throw new ArgumentException(nameof(thisOrBaseKeyword));
      }
      if (argumentList == null)
        throw new ArgumentNullException(nameof(argumentList));
#endif

      int hash;
      var cached = CSharpSyntaxNodeCache.TryGetNode((int)kind, colonToken, thisOrBaseKeyword, argumentList, this.context, out hash);
      if (cached != null) return (ConstructorInitializerSyntax)cached;

      var result = new ConstructorInitializerSyntax(kind, colonToken, thisOrBaseKeyword, argumentList, this.context);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public DestructorDeclarationSyntax DestructorDeclaration(Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<AttributeListSyntax> attributeLists, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SyntaxToken> modifiers, SyntaxToken tildeToken, SyntaxToken identifier, ParameterListSyntax parameterList, BlockSyntax body, ArrowExpressionClauseSyntax expressionBody, SyntaxToken semicolonToken)
    {
#if DEBUG
      if (tildeToken == null)
        throw new ArgumentNullException(nameof(tildeToken));
      switch (tildeToken.Kind)
      {
        case SyntaxKind.TildeToken:
          break;
        default:
          throw new ArgumentException(nameof(tildeToken));
      }
      if (identifier == null)
        throw new ArgumentNullException(nameof(identifier));
      switch (identifier.Kind)
      {
        case SyntaxKind.IdentifierToken:
          break;
        default:
          throw new ArgumentException(nameof(identifier));
      }
      if (parameterList == null)
        throw new ArgumentNullException(nameof(parameterList));
      if (semicolonToken != null)
      {
      switch (semicolonToken.Kind)
      {
        case SyntaxKind.SemicolonToken:
        case SyntaxKind.None:
          break;
        default:
          throw new ArgumentException(nameof(semicolonToken));
      }
      }
#endif

      return new DestructorDeclarationSyntax(SyntaxKind.DestructorDeclaration, attributeLists.Node, modifiers.Node, tildeToken, identifier, parameterList, body, expressionBody, semicolonToken, this.context);
    }

    public PropertyDeclarationSyntax PropertyDeclaration(Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<AttributeListSyntax> attributeLists, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SyntaxToken> modifiers, TypeSyntax type, ExplicitInterfaceSpecifierSyntax explicitInterfaceSpecifier, SyntaxToken identifier, AccessorListSyntax accessorList, ArrowExpressionClauseSyntax expressionBody, EqualsValueClauseSyntax initializer, SyntaxToken semicolonToken)
    {
#if DEBUG
      if (type == null)
        throw new ArgumentNullException(nameof(type));
      if (identifier == null)
        throw new ArgumentNullException(nameof(identifier));
      switch (identifier.Kind)
      {
        case SyntaxKind.IdentifierToken:
          break;
        default:
          throw new ArgumentException(nameof(identifier));
      }
      if (semicolonToken != null)
      {
      switch (semicolonToken.Kind)
      {
        case SyntaxKind.SemicolonToken:
        case SyntaxKind.None:
          break;
        default:
          throw new ArgumentException(nameof(semicolonToken));
      }
      }
#endif

      return new PropertyDeclarationSyntax(SyntaxKind.PropertyDeclaration, attributeLists.Node, modifiers.Node, type, explicitInterfaceSpecifier, identifier, accessorList, expressionBody, initializer, semicolonToken, this.context);
    }

    public ArrowExpressionClauseSyntax ArrowExpressionClause(SyntaxToken arrowToken, ExpressionSyntax expression)
    {
#if DEBUG
      if (arrowToken == null)
        throw new ArgumentNullException(nameof(arrowToken));
      switch (arrowToken.Kind)
      {
        case SyntaxKind.EqualsGreaterThanToken:
          break;
        default:
          throw new ArgumentException(nameof(arrowToken));
      }
      if (expression == null)
        throw new ArgumentNullException(nameof(expression));
#endif

      int hash;
      var cached = CSharpSyntaxNodeCache.TryGetNode((int)SyntaxKind.ArrowExpressionClause, arrowToken, expression, this.context, out hash);
      if (cached != null) return (ArrowExpressionClauseSyntax)cached;

      var result = new ArrowExpressionClauseSyntax(SyntaxKind.ArrowExpressionClause, arrowToken, expression, this.context);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public EventDeclarationSyntax EventDeclaration(Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<AttributeListSyntax> attributeLists, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SyntaxToken> modifiers, SyntaxToken eventKeyword, TypeSyntax type, ExplicitInterfaceSpecifierSyntax explicitInterfaceSpecifier, SyntaxToken identifier, AccessorListSyntax accessorList, SyntaxToken semicolonToken)
    {
#if DEBUG
      if (eventKeyword == null)
        throw new ArgumentNullException(nameof(eventKeyword));
      switch (eventKeyword.Kind)
      {
        case SyntaxKind.EventKeyword:
          break;
        default:
          throw new ArgumentException(nameof(eventKeyword));
      }
      if (type == null)
        throw new ArgumentNullException(nameof(type));
      if (identifier == null)
        throw new ArgumentNullException(nameof(identifier));
      switch (identifier.Kind)
      {
        case SyntaxKind.IdentifierToken:
          break;
        default:
          throw new ArgumentException(nameof(identifier));
      }
      if (semicolonToken != null)
      {
      switch (semicolonToken.Kind)
      {
        case SyntaxKind.SemicolonToken:
        case SyntaxKind.None:
          break;
        default:
          throw new ArgumentException(nameof(semicolonToken));
      }
      }
#endif

      return new EventDeclarationSyntax(SyntaxKind.EventDeclaration, attributeLists.Node, modifiers.Node, eventKeyword, type, explicitInterfaceSpecifier, identifier, accessorList, semicolonToken, this.context);
    }

    public IndexerDeclarationSyntax IndexerDeclaration(Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<AttributeListSyntax> attributeLists, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SyntaxToken> modifiers, TypeSyntax type, ExplicitInterfaceSpecifierSyntax explicitInterfaceSpecifier, SyntaxToken thisKeyword, BracketedParameterListSyntax parameterList, AccessorListSyntax accessorList, ArrowExpressionClauseSyntax expressionBody, SyntaxToken semicolonToken)
    {
#if DEBUG
      if (type == null)
        throw new ArgumentNullException(nameof(type));
      if (thisKeyword == null)
        throw new ArgumentNullException(nameof(thisKeyword));
      switch (thisKeyword.Kind)
      {
        case SyntaxKind.ThisKeyword:
          break;
        default:
          throw new ArgumentException(nameof(thisKeyword));
      }
      if (parameterList == null)
        throw new ArgumentNullException(nameof(parameterList));
      if (semicolonToken != null)
      {
      switch (semicolonToken.Kind)
      {
        case SyntaxKind.SemicolonToken:
        case SyntaxKind.None:
          break;
        default:
          throw new ArgumentException(nameof(semicolonToken));
      }
      }
#endif

      return new IndexerDeclarationSyntax(SyntaxKind.IndexerDeclaration, attributeLists.Node, modifiers.Node, type, explicitInterfaceSpecifier, thisKeyword, parameterList, accessorList, expressionBody, semicolonToken, this.context);
    }

    public AccessorListSyntax AccessorList(SyntaxToken openBraceToken, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<AccessorDeclarationSyntax> accessors, SyntaxToken closeBraceToken)
    {
#if DEBUG
      if (openBraceToken == null)
        throw new ArgumentNullException(nameof(openBraceToken));
      switch (openBraceToken.Kind)
      {
        case SyntaxKind.OpenBraceToken:
          break;
        default:
          throw new ArgumentException(nameof(openBraceToken));
      }
      if (closeBraceToken == null)
        throw new ArgumentNullException(nameof(closeBraceToken));
      switch (closeBraceToken.Kind)
      {
        case SyntaxKind.CloseBraceToken:
          break;
        default:
          throw new ArgumentException(nameof(closeBraceToken));
      }
#endif

      int hash;
      var cached = CSharpSyntaxNodeCache.TryGetNode((int)SyntaxKind.AccessorList, openBraceToken, accessors.Node, closeBraceToken, this.context, out hash);
      if (cached != null) return (AccessorListSyntax)cached;

      var result = new AccessorListSyntax(SyntaxKind.AccessorList, openBraceToken, accessors.Node, closeBraceToken, this.context);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public AccessorDeclarationSyntax AccessorDeclaration(SyntaxKind kind, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<AttributeListSyntax> attributeLists, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SyntaxToken> modifiers, SyntaxToken keyword, BlockSyntax body, ArrowExpressionClauseSyntax expressionBody, SyntaxToken semicolonToken)
    {
      switch (kind)
      {
        case SyntaxKind.GetAccessorDeclaration:
        case SyntaxKind.SetAccessorDeclaration:
        case SyntaxKind.AddAccessorDeclaration:
        case SyntaxKind.RemoveAccessorDeclaration:
        case SyntaxKind.UnknownAccessorDeclaration:
          break;
        default:
          throw new ArgumentException(nameof(kind));
      }
#if DEBUG
      if (keyword == null)
        throw new ArgumentNullException(nameof(keyword));
      switch (keyword.Kind)
      {
        case SyntaxKind.GetKeyword:
        case SyntaxKind.SetKeyword:
        case SyntaxKind.AddKeyword:
        case SyntaxKind.RemoveKeyword:
        case SyntaxKind.IdentifierToken:
          break;
        default:
          throw new ArgumentException(nameof(keyword));
      }
      if (semicolonToken != null)
      {
      switch (semicolonToken.Kind)
      {
        case SyntaxKind.SemicolonToken:
        case SyntaxKind.None:
          break;
        default:
          throw new ArgumentException(nameof(semicolonToken));
      }
      }
#endif

      return new AccessorDeclarationSyntax(kind, attributeLists.Node, modifiers.Node, keyword, body, expressionBody, semicolonToken, this.context);
    }

    public ParameterListSyntax ParameterList(SyntaxToken openParenToken, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<ParameterSyntax> parameters, SyntaxToken closeParenToken)
    {
#if DEBUG
      if (openParenToken == null)
        throw new ArgumentNullException(nameof(openParenToken));
      switch (openParenToken.Kind)
      {
        case SyntaxKind.OpenParenToken:
          break;
        default:
          throw new ArgumentException(nameof(openParenToken));
      }
      if (closeParenToken == null)
        throw new ArgumentNullException(nameof(closeParenToken));
      switch (closeParenToken.Kind)
      {
        case SyntaxKind.CloseParenToken:
          break;
        default:
          throw new ArgumentException(nameof(closeParenToken));
      }
#endif

      int hash;
      var cached = CSharpSyntaxNodeCache.TryGetNode((int)SyntaxKind.ParameterList, openParenToken, parameters.Node, closeParenToken, this.context, out hash);
      if (cached != null) return (ParameterListSyntax)cached;

      var result = new ParameterListSyntax(SyntaxKind.ParameterList, openParenToken, parameters.Node, closeParenToken, this.context);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public BracketedParameterListSyntax BracketedParameterList(SyntaxToken openBracketToken, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<ParameterSyntax> parameters, SyntaxToken closeBracketToken)
    {
#if DEBUG
      if (openBracketToken == null)
        throw new ArgumentNullException(nameof(openBracketToken));
      switch (openBracketToken.Kind)
      {
        case SyntaxKind.OpenBracketToken:
          break;
        default:
          throw new ArgumentException(nameof(openBracketToken));
      }
      if (closeBracketToken == null)
        throw new ArgumentNullException(nameof(closeBracketToken));
      switch (closeBracketToken.Kind)
      {
        case SyntaxKind.CloseBracketToken:
          break;
        default:
          throw new ArgumentException(nameof(closeBracketToken));
      }
#endif

      int hash;
      var cached = CSharpSyntaxNodeCache.TryGetNode((int)SyntaxKind.BracketedParameterList, openBracketToken, parameters.Node, closeBracketToken, this.context, out hash);
      if (cached != null) return (BracketedParameterListSyntax)cached;

      var result = new BracketedParameterListSyntax(SyntaxKind.BracketedParameterList, openBracketToken, parameters.Node, closeBracketToken, this.context);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public ParameterSyntax Parameter(Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<AttributeListSyntax> attributeLists, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SyntaxToken> modifiers, TypeSyntax type, SyntaxToken identifier, EqualsValueClauseSyntax @default)
    {
#if DEBUG
      if (identifier == null)
        throw new ArgumentNullException(nameof(identifier));
      switch (identifier.Kind)
      {
        case SyntaxKind.IdentifierToken:
        case SyntaxKind.ArgListKeyword:
          break;
        default:
          throw new ArgumentException(nameof(identifier));
      }
#endif

      return new ParameterSyntax(SyntaxKind.Parameter, attributeLists.Node, modifiers.Node, type, identifier, @default, this.context);
    }

    public IncompleteMemberSyntax IncompleteMember(Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<AttributeListSyntax> attributeLists, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SyntaxToken> modifiers, TypeSyntax type)
    {
#if DEBUG
#endif

      return new IncompleteMemberSyntax(SyntaxKind.IncompleteMember, attributeLists.Node, modifiers.Node, type, this.context);
    }

    public SkippedTokensTriviaSyntax SkippedTokensTrivia(Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SyntaxToken> tokens)
    {
#if DEBUG
#endif

      return new SkippedTokensTriviaSyntax(SyntaxKind.SkippedTokensTrivia, tokens.Node, this.context);
    }

    public DocumentationCommentTriviaSyntax DocumentationCommentTrivia(SyntaxKind kind, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<XmlNodeSyntax> content, SyntaxToken endOfComment)
    {
      switch (kind)
      {
        case SyntaxKind.SingleLineDocumentationCommentTrivia:
        case SyntaxKind.MultiLineDocumentationCommentTrivia:
          break;
        default:
          throw new ArgumentException(nameof(kind));
      }
#if DEBUG
      if (endOfComment == null)
        throw new ArgumentNullException(nameof(endOfComment));
      switch (endOfComment.Kind)
      {
        case SyntaxKind.EndOfDocumentationCommentToken:
          break;
        default:
          throw new ArgumentException(nameof(endOfComment));
      }
#endif

      return new DocumentationCommentTriviaSyntax(kind, content.Node, endOfComment, this.context);
    }

    public TypeCrefSyntax TypeCref(TypeSyntax type)
    {
#if DEBUG
      if (type == null)
        throw new ArgumentNullException(nameof(type));
#endif

      int hash;
      var cached = CSharpSyntaxNodeCache.TryGetNode((int)SyntaxKind.TypeCref, type, this.context, out hash);
      if (cached != null) return (TypeCrefSyntax)cached;

      var result = new TypeCrefSyntax(SyntaxKind.TypeCref, type, this.context);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public QualifiedCrefSyntax QualifiedCref(TypeSyntax container, SyntaxToken dotToken, MemberCrefSyntax member)
    {
#if DEBUG
      if (container == null)
        throw new ArgumentNullException(nameof(container));
      if (dotToken == null)
        throw new ArgumentNullException(nameof(dotToken));
      switch (dotToken.Kind)
      {
        case SyntaxKind.DotToken:
          break;
        default:
          throw new ArgumentException(nameof(dotToken));
      }
      if (member == null)
        throw new ArgumentNullException(nameof(member));
#endif

      int hash;
      var cached = CSharpSyntaxNodeCache.TryGetNode((int)SyntaxKind.QualifiedCref, container, dotToken, member, this.context, out hash);
      if (cached != null) return (QualifiedCrefSyntax)cached;

      var result = new QualifiedCrefSyntax(SyntaxKind.QualifiedCref, container, dotToken, member, this.context);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public NameMemberCrefSyntax NameMemberCref(TypeSyntax name, CrefParameterListSyntax parameters)
    {
#if DEBUG
      if (name == null)
        throw new ArgumentNullException(nameof(name));
#endif

      int hash;
      var cached = CSharpSyntaxNodeCache.TryGetNode((int)SyntaxKind.NameMemberCref, name, parameters, this.context, out hash);
      if (cached != null) return (NameMemberCrefSyntax)cached;

      var result = new NameMemberCrefSyntax(SyntaxKind.NameMemberCref, name, parameters, this.context);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public IndexerMemberCrefSyntax IndexerMemberCref(SyntaxToken thisKeyword, CrefBracketedParameterListSyntax parameters)
    {
#if DEBUG
      if (thisKeyword == null)
        throw new ArgumentNullException(nameof(thisKeyword));
      switch (thisKeyword.Kind)
      {
        case SyntaxKind.ThisKeyword:
          break;
        default:
          throw new ArgumentException(nameof(thisKeyword));
      }
#endif

      int hash;
      var cached = CSharpSyntaxNodeCache.TryGetNode((int)SyntaxKind.IndexerMemberCref, thisKeyword, parameters, this.context, out hash);
      if (cached != null) return (IndexerMemberCrefSyntax)cached;

      var result = new IndexerMemberCrefSyntax(SyntaxKind.IndexerMemberCref, thisKeyword, parameters, this.context);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public OperatorMemberCrefSyntax OperatorMemberCref(SyntaxToken operatorKeyword, SyntaxToken operatorToken, CrefParameterListSyntax parameters)
    {
#if DEBUG
      if (operatorKeyword == null)
        throw new ArgumentNullException(nameof(operatorKeyword));
      switch (operatorKeyword.Kind)
      {
        case SyntaxKind.OperatorKeyword:
          break;
        default:
          throw new ArgumentException(nameof(operatorKeyword));
      }
      if (operatorToken == null)
        throw new ArgumentNullException(nameof(operatorToken));
      switch (operatorToken.Kind)
      {
        case SyntaxKind.PlusToken:
        case SyntaxKind.MinusToken:
        case SyntaxKind.ExclamationToken:
        case SyntaxKind.TildeToken:
        case SyntaxKind.PlusPlusToken:
        case SyntaxKind.MinusMinusToken:
        case SyntaxKind.AsteriskToken:
        case SyntaxKind.SlashToken:
        case SyntaxKind.PercentToken:
        case SyntaxKind.LessThanLessThanToken:
        case SyntaxKind.GreaterThanGreaterThanToken:
        case SyntaxKind.BarToken:
        case SyntaxKind.AmpersandToken:
        case SyntaxKind.CaretToken:
        case SyntaxKind.EqualsEqualsToken:
        case SyntaxKind.ExclamationEqualsToken:
        case SyntaxKind.LessThanToken:
        case SyntaxKind.LessThanEqualsToken:
        case SyntaxKind.GreaterThanToken:
        case SyntaxKind.GreaterThanEqualsToken:
        case SyntaxKind.FalseKeyword:
        case SyntaxKind.TrueKeyword:
          break;
        default:
          throw new ArgumentException(nameof(operatorToken));
      }
#endif

      int hash;
      var cached = CSharpSyntaxNodeCache.TryGetNode((int)SyntaxKind.OperatorMemberCref, operatorKeyword, operatorToken, parameters, this.context, out hash);
      if (cached != null) return (OperatorMemberCrefSyntax)cached;

      var result = new OperatorMemberCrefSyntax(SyntaxKind.OperatorMemberCref, operatorKeyword, operatorToken, parameters, this.context);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public ConversionOperatorMemberCrefSyntax ConversionOperatorMemberCref(SyntaxToken implicitOrExplicitKeyword, SyntaxToken operatorKeyword, TypeSyntax type, CrefParameterListSyntax parameters)
    {
#if DEBUG
      if (implicitOrExplicitKeyword == null)
        throw new ArgumentNullException(nameof(implicitOrExplicitKeyword));
      switch (implicitOrExplicitKeyword.Kind)
      {
        case SyntaxKind.ImplicitKeyword:
        case SyntaxKind.ExplicitKeyword:
          break;
        default:
          throw new ArgumentException(nameof(implicitOrExplicitKeyword));
      }
      if (operatorKeyword == null)
        throw new ArgumentNullException(nameof(operatorKeyword));
      switch (operatorKeyword.Kind)
      {
        case SyntaxKind.OperatorKeyword:
          break;
        default:
          throw new ArgumentException(nameof(operatorKeyword));
      }
      if (type == null)
        throw new ArgumentNullException(nameof(type));
#endif

      return new ConversionOperatorMemberCrefSyntax(SyntaxKind.ConversionOperatorMemberCref, implicitOrExplicitKeyword, operatorKeyword, type, parameters, this.context);
    }

    public CrefParameterListSyntax CrefParameterList(SyntaxToken openParenToken, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<CrefParameterSyntax> parameters, SyntaxToken closeParenToken)
    {
#if DEBUG
      if (openParenToken == null)
        throw new ArgumentNullException(nameof(openParenToken));
      switch (openParenToken.Kind)
      {
        case SyntaxKind.OpenParenToken:
          break;
        default:
          throw new ArgumentException(nameof(openParenToken));
      }
      if (closeParenToken == null)
        throw new ArgumentNullException(nameof(closeParenToken));
      switch (closeParenToken.Kind)
      {
        case SyntaxKind.CloseParenToken:
          break;
        default:
          throw new ArgumentException(nameof(closeParenToken));
      }
#endif

      int hash;
      var cached = CSharpSyntaxNodeCache.TryGetNode((int)SyntaxKind.CrefParameterList, openParenToken, parameters.Node, closeParenToken, this.context, out hash);
      if (cached != null) return (CrefParameterListSyntax)cached;

      var result = new CrefParameterListSyntax(SyntaxKind.CrefParameterList, openParenToken, parameters.Node, closeParenToken, this.context);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public CrefBracketedParameterListSyntax CrefBracketedParameterList(SyntaxToken openBracketToken, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<CrefParameterSyntax> parameters, SyntaxToken closeBracketToken)
    {
#if DEBUG
      if (openBracketToken == null)
        throw new ArgumentNullException(nameof(openBracketToken));
      switch (openBracketToken.Kind)
      {
        case SyntaxKind.OpenBracketToken:
          break;
        default:
          throw new ArgumentException(nameof(openBracketToken));
      }
      if (closeBracketToken == null)
        throw new ArgumentNullException(nameof(closeBracketToken));
      switch (closeBracketToken.Kind)
      {
        case SyntaxKind.CloseBracketToken:
          break;
        default:
          throw new ArgumentException(nameof(closeBracketToken));
      }
#endif

      int hash;
      var cached = CSharpSyntaxNodeCache.TryGetNode((int)SyntaxKind.CrefBracketedParameterList, openBracketToken, parameters.Node, closeBracketToken, this.context, out hash);
      if (cached != null) return (CrefBracketedParameterListSyntax)cached;

      var result = new CrefBracketedParameterListSyntax(SyntaxKind.CrefBracketedParameterList, openBracketToken, parameters.Node, closeBracketToken, this.context);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public CrefParameterSyntax CrefParameter(SyntaxToken refKindKeyword, TypeSyntax type)
    {
#if DEBUG
      if (refKindKeyword != null)
      {
      switch (refKindKeyword.Kind)
      {
        case SyntaxKind.RefKeyword:
        case SyntaxKind.OutKeyword:
        case SyntaxKind.InKeyword:
        case SyntaxKind.None:
          break;
        default:
          throw new ArgumentException(nameof(refKindKeyword));
      }
      }
      if (type == null)
        throw new ArgumentNullException(nameof(type));
#endif

      int hash;
      var cached = CSharpSyntaxNodeCache.TryGetNode((int)SyntaxKind.CrefParameter, refKindKeyword, type, this.context, out hash);
      if (cached != null) return (CrefParameterSyntax)cached;

      var result = new CrefParameterSyntax(SyntaxKind.CrefParameter, refKindKeyword, type, this.context);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public XmlElementSyntax XmlElement(XmlElementStartTagSyntax startTag, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<XmlNodeSyntax> content, XmlElementEndTagSyntax endTag)
    {
#if DEBUG
      if (startTag == null)
        throw new ArgumentNullException(nameof(startTag));
      if (endTag == null)
        throw new ArgumentNullException(nameof(endTag));
#endif

      int hash;
      var cached = CSharpSyntaxNodeCache.TryGetNode((int)SyntaxKind.XmlElement, startTag, content.Node, endTag, this.context, out hash);
      if (cached != null) return (XmlElementSyntax)cached;

      var result = new XmlElementSyntax(SyntaxKind.XmlElement, startTag, content.Node, endTag, this.context);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public XmlElementStartTagSyntax XmlElementStartTag(SyntaxToken lessThanToken, XmlNameSyntax name, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<XmlAttributeSyntax> attributes, SyntaxToken greaterThanToken)
    {
#if DEBUG
      if (lessThanToken == null)
        throw new ArgumentNullException(nameof(lessThanToken));
      switch (lessThanToken.Kind)
      {
        case SyntaxKind.LessThanToken:
          break;
        default:
          throw new ArgumentException(nameof(lessThanToken));
      }
      if (name == null)
        throw new ArgumentNullException(nameof(name));
      if (greaterThanToken == null)
        throw new ArgumentNullException(nameof(greaterThanToken));
      switch (greaterThanToken.Kind)
      {
        case SyntaxKind.GreaterThanToken:
          break;
        default:
          throw new ArgumentException(nameof(greaterThanToken));
      }
#endif

      return new XmlElementStartTagSyntax(SyntaxKind.XmlElementStartTag, lessThanToken, name, attributes.Node, greaterThanToken, this.context);
    }

    public XmlElementEndTagSyntax XmlElementEndTag(SyntaxToken lessThanSlashToken, XmlNameSyntax name, SyntaxToken greaterThanToken)
    {
#if DEBUG
      if (lessThanSlashToken == null)
        throw new ArgumentNullException(nameof(lessThanSlashToken));
      switch (lessThanSlashToken.Kind)
      {
        case SyntaxKind.LessThanSlashToken:
          break;
        default:
          throw new ArgumentException(nameof(lessThanSlashToken));
      }
      if (name == null)
        throw new ArgumentNullException(nameof(name));
      if (greaterThanToken == null)
        throw new ArgumentNullException(nameof(greaterThanToken));
      switch (greaterThanToken.Kind)
      {
        case SyntaxKind.GreaterThanToken:
          break;
        default:
          throw new ArgumentException(nameof(greaterThanToken));
      }
#endif

      int hash;
      var cached = CSharpSyntaxNodeCache.TryGetNode((int)SyntaxKind.XmlElementEndTag, lessThanSlashToken, name, greaterThanToken, this.context, out hash);
      if (cached != null) return (XmlElementEndTagSyntax)cached;

      var result = new XmlElementEndTagSyntax(SyntaxKind.XmlElementEndTag, lessThanSlashToken, name, greaterThanToken, this.context);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public XmlEmptyElementSyntax XmlEmptyElement(SyntaxToken lessThanToken, XmlNameSyntax name, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<XmlAttributeSyntax> attributes, SyntaxToken slashGreaterThanToken)
    {
#if DEBUG
      if (lessThanToken == null)
        throw new ArgumentNullException(nameof(lessThanToken));
      switch (lessThanToken.Kind)
      {
        case SyntaxKind.LessThanToken:
          break;
        default:
          throw new ArgumentException(nameof(lessThanToken));
      }
      if (name == null)
        throw new ArgumentNullException(nameof(name));
      if (slashGreaterThanToken == null)
        throw new ArgumentNullException(nameof(slashGreaterThanToken));
      switch (slashGreaterThanToken.Kind)
      {
        case SyntaxKind.SlashGreaterThanToken:
          break;
        default:
          throw new ArgumentException(nameof(slashGreaterThanToken));
      }
#endif

      return new XmlEmptyElementSyntax(SyntaxKind.XmlEmptyElement, lessThanToken, name, attributes.Node, slashGreaterThanToken, this.context);
    }

    public XmlNameSyntax XmlName(XmlPrefixSyntax prefix, SyntaxToken localName)
    {
#if DEBUG
      if (localName == null)
        throw new ArgumentNullException(nameof(localName));
      switch (localName.Kind)
      {
        case SyntaxKind.IdentifierToken:
          break;
        default:
          throw new ArgumentException(nameof(localName));
      }
#endif

      int hash;
      var cached = CSharpSyntaxNodeCache.TryGetNode((int)SyntaxKind.XmlName, prefix, localName, this.context, out hash);
      if (cached != null) return (XmlNameSyntax)cached;

      var result = new XmlNameSyntax(SyntaxKind.XmlName, prefix, localName, this.context);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public XmlPrefixSyntax XmlPrefix(SyntaxToken prefix, SyntaxToken colonToken)
    {
#if DEBUG
      if (prefix == null)
        throw new ArgumentNullException(nameof(prefix));
      switch (prefix.Kind)
      {
        case SyntaxKind.IdentifierToken:
          break;
        default:
          throw new ArgumentException(nameof(prefix));
      }
      if (colonToken == null)
        throw new ArgumentNullException(nameof(colonToken));
      switch (colonToken.Kind)
      {
        case SyntaxKind.ColonToken:
          break;
        default:
          throw new ArgumentException(nameof(colonToken));
      }
#endif

      int hash;
      var cached = CSharpSyntaxNodeCache.TryGetNode((int)SyntaxKind.XmlPrefix, prefix, colonToken, this.context, out hash);
      if (cached != null) return (XmlPrefixSyntax)cached;

      var result = new XmlPrefixSyntax(SyntaxKind.XmlPrefix, prefix, colonToken, this.context);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public XmlTextAttributeSyntax XmlTextAttribute(XmlNameSyntax name, SyntaxToken equalsToken, SyntaxToken startQuoteToken, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SyntaxToken> textTokens, SyntaxToken endQuoteToken)
    {
#if DEBUG
      if (name == null)
        throw new ArgumentNullException(nameof(name));
      if (equalsToken == null)
        throw new ArgumentNullException(nameof(equalsToken));
      switch (equalsToken.Kind)
      {
        case SyntaxKind.EqualsToken:
          break;
        default:
          throw new ArgumentException(nameof(equalsToken));
      }
      if (startQuoteToken == null)
        throw new ArgumentNullException(nameof(startQuoteToken));
      switch (startQuoteToken.Kind)
      {
        case SyntaxKind.SingleQuoteToken:
        case SyntaxKind.DoubleQuoteToken:
          break;
        default:
          throw new ArgumentException(nameof(startQuoteToken));
      }
      if (endQuoteToken == null)
        throw new ArgumentNullException(nameof(endQuoteToken));
      switch (endQuoteToken.Kind)
      {
        case SyntaxKind.SingleQuoteToken:
        case SyntaxKind.DoubleQuoteToken:
          break;
        default:
          throw new ArgumentException(nameof(endQuoteToken));
      }
#endif

      return new XmlTextAttributeSyntax(SyntaxKind.XmlTextAttribute, name, equalsToken, startQuoteToken, textTokens.Node, endQuoteToken, this.context);
    }

    public XmlCrefAttributeSyntax XmlCrefAttribute(XmlNameSyntax name, SyntaxToken equalsToken, SyntaxToken startQuoteToken, CrefSyntax cref, SyntaxToken endQuoteToken)
    {
#if DEBUG
      if (name == null)
        throw new ArgumentNullException(nameof(name));
      if (equalsToken == null)
        throw new ArgumentNullException(nameof(equalsToken));
      switch (equalsToken.Kind)
      {
        case SyntaxKind.EqualsToken:
          break;
        default:
          throw new ArgumentException(nameof(equalsToken));
      }
      if (startQuoteToken == null)
        throw new ArgumentNullException(nameof(startQuoteToken));
      switch (startQuoteToken.Kind)
      {
        case SyntaxKind.SingleQuoteToken:
        case SyntaxKind.DoubleQuoteToken:
          break;
        default:
          throw new ArgumentException(nameof(startQuoteToken));
      }
      if (cref == null)
        throw new ArgumentNullException(nameof(cref));
      if (endQuoteToken == null)
        throw new ArgumentNullException(nameof(endQuoteToken));
      switch (endQuoteToken.Kind)
      {
        case SyntaxKind.SingleQuoteToken:
        case SyntaxKind.DoubleQuoteToken:
          break;
        default:
          throw new ArgumentException(nameof(endQuoteToken));
      }
#endif

      return new XmlCrefAttributeSyntax(SyntaxKind.XmlCrefAttribute, name, equalsToken, startQuoteToken, cref, endQuoteToken, this.context);
    }

    public XmlNameAttributeSyntax XmlNameAttribute(XmlNameSyntax name, SyntaxToken equalsToken, SyntaxToken startQuoteToken, IdentifierNameSyntax identifier, SyntaxToken endQuoteToken)
    {
#if DEBUG
      if (name == null)
        throw new ArgumentNullException(nameof(name));
      if (equalsToken == null)
        throw new ArgumentNullException(nameof(equalsToken));
      switch (equalsToken.Kind)
      {
        case SyntaxKind.EqualsToken:
          break;
        default:
          throw new ArgumentException(nameof(equalsToken));
      }
      if (startQuoteToken == null)
        throw new ArgumentNullException(nameof(startQuoteToken));
      switch (startQuoteToken.Kind)
      {
        case SyntaxKind.SingleQuoteToken:
        case SyntaxKind.DoubleQuoteToken:
          break;
        default:
          throw new ArgumentException(nameof(startQuoteToken));
      }
      if (identifier == null)
        throw new ArgumentNullException(nameof(identifier));
      if (endQuoteToken == null)
        throw new ArgumentNullException(nameof(endQuoteToken));
      switch (endQuoteToken.Kind)
      {
        case SyntaxKind.SingleQuoteToken:
        case SyntaxKind.DoubleQuoteToken:
          break;
        default:
          throw new ArgumentException(nameof(endQuoteToken));
      }
#endif

      return new XmlNameAttributeSyntax(SyntaxKind.XmlNameAttribute, name, equalsToken, startQuoteToken, identifier, endQuoteToken, this.context);
    }

    public XmlTextSyntax XmlText(Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SyntaxToken> textTokens)
    {
#if DEBUG
#endif

      int hash;
      var cached = CSharpSyntaxNodeCache.TryGetNode((int)SyntaxKind.XmlText, textTokens.Node, this.context, out hash);
      if (cached != null) return (XmlTextSyntax)cached;

      var result = new XmlTextSyntax(SyntaxKind.XmlText, textTokens.Node, this.context);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public XmlCDataSectionSyntax XmlCDataSection(SyntaxToken startCDataToken, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SyntaxToken> textTokens, SyntaxToken endCDataToken)
    {
#if DEBUG
      if (startCDataToken == null)
        throw new ArgumentNullException(nameof(startCDataToken));
      switch (startCDataToken.Kind)
      {
        case SyntaxKind.XmlCDataStartToken:
          break;
        default:
          throw new ArgumentException(nameof(startCDataToken));
      }
      if (endCDataToken == null)
        throw new ArgumentNullException(nameof(endCDataToken));
      switch (endCDataToken.Kind)
      {
        case SyntaxKind.XmlCDataEndToken:
          break;
        default:
          throw new ArgumentException(nameof(endCDataToken));
      }
#endif

      int hash;
      var cached = CSharpSyntaxNodeCache.TryGetNode((int)SyntaxKind.XmlCDataSection, startCDataToken, textTokens.Node, endCDataToken, this.context, out hash);
      if (cached != null) return (XmlCDataSectionSyntax)cached;

      var result = new XmlCDataSectionSyntax(SyntaxKind.XmlCDataSection, startCDataToken, textTokens.Node, endCDataToken, this.context);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public XmlProcessingInstructionSyntax XmlProcessingInstruction(SyntaxToken startProcessingInstructionToken, XmlNameSyntax name, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SyntaxToken> textTokens, SyntaxToken endProcessingInstructionToken)
    {
#if DEBUG
      if (startProcessingInstructionToken == null)
        throw new ArgumentNullException(nameof(startProcessingInstructionToken));
      switch (startProcessingInstructionToken.Kind)
      {
        case SyntaxKind.XmlProcessingInstructionStartToken:
          break;
        default:
          throw new ArgumentException(nameof(startProcessingInstructionToken));
      }
      if (name == null)
        throw new ArgumentNullException(nameof(name));
      if (endProcessingInstructionToken == null)
        throw new ArgumentNullException(nameof(endProcessingInstructionToken));
      switch (endProcessingInstructionToken.Kind)
      {
        case SyntaxKind.XmlProcessingInstructionEndToken:
          break;
        default:
          throw new ArgumentException(nameof(endProcessingInstructionToken));
      }
#endif

      return new XmlProcessingInstructionSyntax(SyntaxKind.XmlProcessingInstruction, startProcessingInstructionToken, name, textTokens.Node, endProcessingInstructionToken, this.context);
    }

    public XmlCommentSyntax XmlComment(SyntaxToken lessThanExclamationMinusMinusToken, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SyntaxToken> textTokens, SyntaxToken minusMinusGreaterThanToken)
    {
#if DEBUG
      if (lessThanExclamationMinusMinusToken == null)
        throw new ArgumentNullException(nameof(lessThanExclamationMinusMinusToken));
      switch (lessThanExclamationMinusMinusToken.Kind)
      {
        case SyntaxKind.XmlCommentStartToken:
          break;
        default:
          throw new ArgumentException(nameof(lessThanExclamationMinusMinusToken));
      }
      if (minusMinusGreaterThanToken == null)
        throw new ArgumentNullException(nameof(minusMinusGreaterThanToken));
      switch (minusMinusGreaterThanToken.Kind)
      {
        case SyntaxKind.XmlCommentEndToken:
          break;
        default:
          throw new ArgumentException(nameof(minusMinusGreaterThanToken));
      }
#endif

      int hash;
      var cached = CSharpSyntaxNodeCache.TryGetNode((int)SyntaxKind.XmlComment, lessThanExclamationMinusMinusToken, textTokens.Node, minusMinusGreaterThanToken, this.context, out hash);
      if (cached != null) return (XmlCommentSyntax)cached;

      var result = new XmlCommentSyntax(SyntaxKind.XmlComment, lessThanExclamationMinusMinusToken, textTokens.Node, minusMinusGreaterThanToken, this.context);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public IfDirectiveTriviaSyntax IfDirectiveTrivia(SyntaxToken hashToken, SyntaxToken ifKeyword, ExpressionSyntax condition, SyntaxToken endOfDirectiveToken, bool isActive, bool branchTaken, bool conditionValue)
    {
#if DEBUG
      if (hashToken == null)
        throw new ArgumentNullException(nameof(hashToken));
      switch (hashToken.Kind)
      {
        case SyntaxKind.HashToken:
          break;
        default:
          throw new ArgumentException(nameof(hashToken));
      }
      if (ifKeyword == null)
        throw new ArgumentNullException(nameof(ifKeyword));
      switch (ifKeyword.Kind)
      {
        case SyntaxKind.IfKeyword:
          break;
        default:
          throw new ArgumentException(nameof(ifKeyword));
      }
      if (condition == null)
        throw new ArgumentNullException(nameof(condition));
      if (endOfDirectiveToken == null)
        throw new ArgumentNullException(nameof(endOfDirectiveToken));
      switch (endOfDirectiveToken.Kind)
      {
        case SyntaxKind.EndOfDirectiveToken:
          break;
        default:
          throw new ArgumentException(nameof(endOfDirectiveToken));
      }
#endif

      return new IfDirectiveTriviaSyntax(SyntaxKind.IfDirectiveTrivia, hashToken, ifKeyword, condition, endOfDirectiveToken, isActive, branchTaken, conditionValue, this.context);
    }

    public ElifDirectiveTriviaSyntax ElifDirectiveTrivia(SyntaxToken hashToken, SyntaxToken elifKeyword, ExpressionSyntax condition, SyntaxToken endOfDirectiveToken, bool isActive, bool branchTaken, bool conditionValue)
    {
#if DEBUG
      if (hashToken == null)
        throw new ArgumentNullException(nameof(hashToken));
      switch (hashToken.Kind)
      {
        case SyntaxKind.HashToken:
          break;
        default:
          throw new ArgumentException(nameof(hashToken));
      }
      if (elifKeyword == null)
        throw new ArgumentNullException(nameof(elifKeyword));
      switch (elifKeyword.Kind)
      {
        case SyntaxKind.ElifKeyword:
          break;
        default:
          throw new ArgumentException(nameof(elifKeyword));
      }
      if (condition == null)
        throw new ArgumentNullException(nameof(condition));
      if (endOfDirectiveToken == null)
        throw new ArgumentNullException(nameof(endOfDirectiveToken));
      switch (endOfDirectiveToken.Kind)
      {
        case SyntaxKind.EndOfDirectiveToken:
          break;
        default:
          throw new ArgumentException(nameof(endOfDirectiveToken));
      }
#endif

      return new ElifDirectiveTriviaSyntax(SyntaxKind.ElifDirectiveTrivia, hashToken, elifKeyword, condition, endOfDirectiveToken, isActive, branchTaken, conditionValue, this.context);
    }

    public ElseDirectiveTriviaSyntax ElseDirectiveTrivia(SyntaxToken hashToken, SyntaxToken elseKeyword, SyntaxToken endOfDirectiveToken, bool isActive, bool branchTaken)
    {
#if DEBUG
      if (hashToken == null)
        throw new ArgumentNullException(nameof(hashToken));
      switch (hashToken.Kind)
      {
        case SyntaxKind.HashToken:
          break;
        default:
          throw new ArgumentException(nameof(hashToken));
      }
      if (elseKeyword == null)
        throw new ArgumentNullException(nameof(elseKeyword));
      switch (elseKeyword.Kind)
      {
        case SyntaxKind.ElseKeyword:
          break;
        default:
          throw new ArgumentException(nameof(elseKeyword));
      }
      if (endOfDirectiveToken == null)
        throw new ArgumentNullException(nameof(endOfDirectiveToken));
      switch (endOfDirectiveToken.Kind)
      {
        case SyntaxKind.EndOfDirectiveToken:
          break;
        default:
          throw new ArgumentException(nameof(endOfDirectiveToken));
      }
#endif

      return new ElseDirectiveTriviaSyntax(SyntaxKind.ElseDirectiveTrivia, hashToken, elseKeyword, endOfDirectiveToken, isActive, branchTaken, this.context);
    }

    public EndIfDirectiveTriviaSyntax EndIfDirectiveTrivia(SyntaxToken hashToken, SyntaxToken endIfKeyword, SyntaxToken endOfDirectiveToken, bool isActive)
    {
#if DEBUG
      if (hashToken == null)
        throw new ArgumentNullException(nameof(hashToken));
      switch (hashToken.Kind)
      {
        case SyntaxKind.HashToken:
          break;
        default:
          throw new ArgumentException(nameof(hashToken));
      }
      if (endIfKeyword == null)
        throw new ArgumentNullException(nameof(endIfKeyword));
      switch (endIfKeyword.Kind)
      {
        case SyntaxKind.EndIfKeyword:
          break;
        default:
          throw new ArgumentException(nameof(endIfKeyword));
      }
      if (endOfDirectiveToken == null)
        throw new ArgumentNullException(nameof(endOfDirectiveToken));
      switch (endOfDirectiveToken.Kind)
      {
        case SyntaxKind.EndOfDirectiveToken:
          break;
        default:
          throw new ArgumentException(nameof(endOfDirectiveToken));
      }
#endif

      return new EndIfDirectiveTriviaSyntax(SyntaxKind.EndIfDirectiveTrivia, hashToken, endIfKeyword, endOfDirectiveToken, isActive, this.context);
    }

    public RegionDirectiveTriviaSyntax RegionDirectiveTrivia(SyntaxToken hashToken, SyntaxToken regionKeyword, SyntaxToken endOfDirectiveToken, bool isActive)
    {
#if DEBUG
      if (hashToken == null)
        throw new ArgumentNullException(nameof(hashToken));
      switch (hashToken.Kind)
      {
        case SyntaxKind.HashToken:
          break;
        default:
          throw new ArgumentException(nameof(hashToken));
      }
      if (regionKeyword == null)
        throw new ArgumentNullException(nameof(regionKeyword));
      switch (regionKeyword.Kind)
      {
        case SyntaxKind.RegionKeyword:
          break;
        default:
          throw new ArgumentException(nameof(regionKeyword));
      }
      if (endOfDirectiveToken == null)
        throw new ArgumentNullException(nameof(endOfDirectiveToken));
      switch (endOfDirectiveToken.Kind)
      {
        case SyntaxKind.EndOfDirectiveToken:
          break;
        default:
          throw new ArgumentException(nameof(endOfDirectiveToken));
      }
#endif

      return new RegionDirectiveTriviaSyntax(SyntaxKind.RegionDirectiveTrivia, hashToken, regionKeyword, endOfDirectiveToken, isActive, this.context);
    }

    public EndRegionDirectiveTriviaSyntax EndRegionDirectiveTrivia(SyntaxToken hashToken, SyntaxToken endRegionKeyword, SyntaxToken endOfDirectiveToken, bool isActive)
    {
#if DEBUG
      if (hashToken == null)
        throw new ArgumentNullException(nameof(hashToken));
      switch (hashToken.Kind)
      {
        case SyntaxKind.HashToken:
          break;
        default:
          throw new ArgumentException(nameof(hashToken));
      }
      if (endRegionKeyword == null)
        throw new ArgumentNullException(nameof(endRegionKeyword));
      switch (endRegionKeyword.Kind)
      {
        case SyntaxKind.EndRegionKeyword:
          break;
        default:
          throw new ArgumentException(nameof(endRegionKeyword));
      }
      if (endOfDirectiveToken == null)
        throw new ArgumentNullException(nameof(endOfDirectiveToken));
      switch (endOfDirectiveToken.Kind)
      {
        case SyntaxKind.EndOfDirectiveToken:
          break;
        default:
          throw new ArgumentException(nameof(endOfDirectiveToken));
      }
#endif

      return new EndRegionDirectiveTriviaSyntax(SyntaxKind.EndRegionDirectiveTrivia, hashToken, endRegionKeyword, endOfDirectiveToken, isActive, this.context);
    }

    public ErrorDirectiveTriviaSyntax ErrorDirectiveTrivia(SyntaxToken hashToken, SyntaxToken errorKeyword, SyntaxToken endOfDirectiveToken, bool isActive)
    {
#if DEBUG
      if (hashToken == null)
        throw new ArgumentNullException(nameof(hashToken));
      switch (hashToken.Kind)
      {
        case SyntaxKind.HashToken:
          break;
        default:
          throw new ArgumentException(nameof(hashToken));
      }
      if (errorKeyword == null)
        throw new ArgumentNullException(nameof(errorKeyword));
      switch (errorKeyword.Kind)
      {
        case SyntaxKind.ErrorKeyword:
          break;
        default:
          throw new ArgumentException(nameof(errorKeyword));
      }
      if (endOfDirectiveToken == null)
        throw new ArgumentNullException(nameof(endOfDirectiveToken));
      switch (endOfDirectiveToken.Kind)
      {
        case SyntaxKind.EndOfDirectiveToken:
          break;
        default:
          throw new ArgumentException(nameof(endOfDirectiveToken));
      }
#endif

      return new ErrorDirectiveTriviaSyntax(SyntaxKind.ErrorDirectiveTrivia, hashToken, errorKeyword, endOfDirectiveToken, isActive, this.context);
    }

    public WarningDirectiveTriviaSyntax WarningDirectiveTrivia(SyntaxToken hashToken, SyntaxToken warningKeyword, SyntaxToken endOfDirectiveToken, bool isActive)
    {
#if DEBUG
      if (hashToken == null)
        throw new ArgumentNullException(nameof(hashToken));
      switch (hashToken.Kind)
      {
        case SyntaxKind.HashToken:
          break;
        default:
          throw new ArgumentException(nameof(hashToken));
      }
      if (warningKeyword == null)
        throw new ArgumentNullException(nameof(warningKeyword));
      switch (warningKeyword.Kind)
      {
        case SyntaxKind.WarningKeyword:
          break;
        default:
          throw new ArgumentException(nameof(warningKeyword));
      }
      if (endOfDirectiveToken == null)
        throw new ArgumentNullException(nameof(endOfDirectiveToken));
      switch (endOfDirectiveToken.Kind)
      {
        case SyntaxKind.EndOfDirectiveToken:
          break;
        default:
          throw new ArgumentException(nameof(endOfDirectiveToken));
      }
#endif

      return new WarningDirectiveTriviaSyntax(SyntaxKind.WarningDirectiveTrivia, hashToken, warningKeyword, endOfDirectiveToken, isActive, this.context);
    }

    public BadDirectiveTriviaSyntax BadDirectiveTrivia(SyntaxToken hashToken, SyntaxToken identifier, SyntaxToken endOfDirectiveToken, bool isActive)
    {
#if DEBUG
      if (hashToken == null)
        throw new ArgumentNullException(nameof(hashToken));
      switch (hashToken.Kind)
      {
        case SyntaxKind.HashToken:
          break;
        default:
          throw new ArgumentException(nameof(hashToken));
      }
      if (identifier == null)
        throw new ArgumentNullException(nameof(identifier));
      if (endOfDirectiveToken == null)
        throw new ArgumentNullException(nameof(endOfDirectiveToken));
      switch (endOfDirectiveToken.Kind)
      {
        case SyntaxKind.EndOfDirectiveToken:
          break;
        default:
          throw new ArgumentException(nameof(endOfDirectiveToken));
      }
#endif

      return new BadDirectiveTriviaSyntax(SyntaxKind.BadDirectiveTrivia, hashToken, identifier, endOfDirectiveToken, isActive, this.context);
    }

    public DefineDirectiveTriviaSyntax DefineDirectiveTrivia(SyntaxToken hashToken, SyntaxToken defineKeyword, SyntaxToken name, SyntaxToken endOfDirectiveToken, bool isActive)
    {
#if DEBUG
      if (hashToken == null)
        throw new ArgumentNullException(nameof(hashToken));
      switch (hashToken.Kind)
      {
        case SyntaxKind.HashToken:
          break;
        default:
          throw new ArgumentException(nameof(hashToken));
      }
      if (defineKeyword == null)
        throw new ArgumentNullException(nameof(defineKeyword));
      switch (defineKeyword.Kind)
      {
        case SyntaxKind.DefineKeyword:
          break;
        default:
          throw new ArgumentException(nameof(defineKeyword));
      }
      if (name == null)
        throw new ArgumentNullException(nameof(name));
      switch (name.Kind)
      {
        case SyntaxKind.IdentifierToken:
          break;
        default:
          throw new ArgumentException(nameof(name));
      }
      if (endOfDirectiveToken == null)
        throw new ArgumentNullException(nameof(endOfDirectiveToken));
      switch (endOfDirectiveToken.Kind)
      {
        case SyntaxKind.EndOfDirectiveToken:
          break;
        default:
          throw new ArgumentException(nameof(endOfDirectiveToken));
      }
#endif

      return new DefineDirectiveTriviaSyntax(SyntaxKind.DefineDirectiveTrivia, hashToken, defineKeyword, name, endOfDirectiveToken, isActive, this.context);
    }

    public UndefDirectiveTriviaSyntax UndefDirectiveTrivia(SyntaxToken hashToken, SyntaxToken undefKeyword, SyntaxToken name, SyntaxToken endOfDirectiveToken, bool isActive)
    {
#if DEBUG
      if (hashToken == null)
        throw new ArgumentNullException(nameof(hashToken));
      switch (hashToken.Kind)
      {
        case SyntaxKind.HashToken:
          break;
        default:
          throw new ArgumentException(nameof(hashToken));
      }
      if (undefKeyword == null)
        throw new ArgumentNullException(nameof(undefKeyword));
      switch (undefKeyword.Kind)
      {
        case SyntaxKind.UndefKeyword:
          break;
        default:
          throw new ArgumentException(nameof(undefKeyword));
      }
      if (name == null)
        throw new ArgumentNullException(nameof(name));
      switch (name.Kind)
      {
        case SyntaxKind.IdentifierToken:
          break;
        default:
          throw new ArgumentException(nameof(name));
      }
      if (endOfDirectiveToken == null)
        throw new ArgumentNullException(nameof(endOfDirectiveToken));
      switch (endOfDirectiveToken.Kind)
      {
        case SyntaxKind.EndOfDirectiveToken:
          break;
        default:
          throw new ArgumentException(nameof(endOfDirectiveToken));
      }
#endif

      return new UndefDirectiveTriviaSyntax(SyntaxKind.UndefDirectiveTrivia, hashToken, undefKeyword, name, endOfDirectiveToken, isActive, this.context);
    }

    public LineDirectiveTriviaSyntax LineDirectiveTrivia(SyntaxToken hashToken, SyntaxToken lineKeyword, SyntaxToken line, SyntaxToken file, SyntaxToken endOfDirectiveToken, bool isActive)
    {
#if DEBUG
      if (hashToken == null)
        throw new ArgumentNullException(nameof(hashToken));
      switch (hashToken.Kind)
      {
        case SyntaxKind.HashToken:
          break;
        default:
          throw new ArgumentException(nameof(hashToken));
      }
      if (lineKeyword == null)
        throw new ArgumentNullException(nameof(lineKeyword));
      switch (lineKeyword.Kind)
      {
        case SyntaxKind.LineKeyword:
          break;
        default:
          throw new ArgumentException(nameof(lineKeyword));
      }
      if (line == null)
        throw new ArgumentNullException(nameof(line));
      switch (line.Kind)
      {
        case SyntaxKind.NumericLiteralToken:
        case SyntaxKind.DefaultKeyword:
        case SyntaxKind.HiddenKeyword:
          break;
        default:
          throw new ArgumentException(nameof(line));
      }
      if (file != null)
      {
      switch (file.Kind)
      {
        case SyntaxKind.StringLiteralToken:
        case SyntaxKind.None:
          break;
        default:
          throw new ArgumentException(nameof(file));
      }
      }
      if (endOfDirectiveToken == null)
        throw new ArgumentNullException(nameof(endOfDirectiveToken));
      switch (endOfDirectiveToken.Kind)
      {
        case SyntaxKind.EndOfDirectiveToken:
          break;
        default:
          throw new ArgumentException(nameof(endOfDirectiveToken));
      }
#endif

      return new LineDirectiveTriviaSyntax(SyntaxKind.LineDirectiveTrivia, hashToken, lineKeyword, line, file, endOfDirectiveToken, isActive, this.context);
    }

    public PragmaWarningDirectiveTriviaSyntax PragmaWarningDirectiveTrivia(SyntaxToken hashToken, SyntaxToken pragmaKeyword, SyntaxToken warningKeyword, SyntaxToken disableOrRestoreKeyword, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<ExpressionSyntax> errorCodes, SyntaxToken endOfDirectiveToken, bool isActive)
    {
#if DEBUG
      if (hashToken == null)
        throw new ArgumentNullException(nameof(hashToken));
      switch (hashToken.Kind)
      {
        case SyntaxKind.HashToken:
          break;
        default:
          throw new ArgumentException(nameof(hashToken));
      }
      if (pragmaKeyword == null)
        throw new ArgumentNullException(nameof(pragmaKeyword));
      switch (pragmaKeyword.Kind)
      {
        case SyntaxKind.PragmaKeyword:
          break;
        default:
          throw new ArgumentException(nameof(pragmaKeyword));
      }
      if (warningKeyword == null)
        throw new ArgumentNullException(nameof(warningKeyword));
      switch (warningKeyword.Kind)
      {
        case SyntaxKind.WarningKeyword:
          break;
        default:
          throw new ArgumentException(nameof(warningKeyword));
      }
      if (disableOrRestoreKeyword == null)
        throw new ArgumentNullException(nameof(disableOrRestoreKeyword));
      switch (disableOrRestoreKeyword.Kind)
      {
        case SyntaxKind.DisableKeyword:
        case SyntaxKind.RestoreKeyword:
          break;
        default:
          throw new ArgumentException(nameof(disableOrRestoreKeyword));
      }
      if (endOfDirectiveToken == null)
        throw new ArgumentNullException(nameof(endOfDirectiveToken));
      switch (endOfDirectiveToken.Kind)
      {
        case SyntaxKind.EndOfDirectiveToken:
          break;
        default:
          throw new ArgumentException(nameof(endOfDirectiveToken));
      }
#endif

      return new PragmaWarningDirectiveTriviaSyntax(SyntaxKind.PragmaWarningDirectiveTrivia, hashToken, pragmaKeyword, warningKeyword, disableOrRestoreKeyword, errorCodes.Node, endOfDirectiveToken, isActive, this.context);
    }

    public PragmaChecksumDirectiveTriviaSyntax PragmaChecksumDirectiveTrivia(SyntaxToken hashToken, SyntaxToken pragmaKeyword, SyntaxToken checksumKeyword, SyntaxToken file, SyntaxToken guid, SyntaxToken bytes, SyntaxToken endOfDirectiveToken, bool isActive)
    {
#if DEBUG
      if (hashToken == null)
        throw new ArgumentNullException(nameof(hashToken));
      switch (hashToken.Kind)
      {
        case SyntaxKind.HashToken:
          break;
        default:
          throw new ArgumentException(nameof(hashToken));
      }
      if (pragmaKeyword == null)
        throw new ArgumentNullException(nameof(pragmaKeyword));
      switch (pragmaKeyword.Kind)
      {
        case SyntaxKind.PragmaKeyword:
          break;
        default:
          throw new ArgumentException(nameof(pragmaKeyword));
      }
      if (checksumKeyword == null)
        throw new ArgumentNullException(nameof(checksumKeyword));
      switch (checksumKeyword.Kind)
      {
        case SyntaxKind.ChecksumKeyword:
          break;
        default:
          throw new ArgumentException(nameof(checksumKeyword));
      }
      if (file == null)
        throw new ArgumentNullException(nameof(file));
      switch (file.Kind)
      {
        case SyntaxKind.StringLiteralToken:
          break;
        default:
          throw new ArgumentException(nameof(file));
      }
      if (guid == null)
        throw new ArgumentNullException(nameof(guid));
      switch (guid.Kind)
      {
        case SyntaxKind.StringLiteralToken:
          break;
        default:
          throw new ArgumentException(nameof(guid));
      }
      if (bytes == null)
        throw new ArgumentNullException(nameof(bytes));
      switch (bytes.Kind)
      {
        case SyntaxKind.StringLiteralToken:
          break;
        default:
          throw new ArgumentException(nameof(bytes));
      }
      if (endOfDirectiveToken == null)
        throw new ArgumentNullException(nameof(endOfDirectiveToken));
      switch (endOfDirectiveToken.Kind)
      {
        case SyntaxKind.EndOfDirectiveToken:
          break;
        default:
          throw new ArgumentException(nameof(endOfDirectiveToken));
      }
#endif

      return new PragmaChecksumDirectiveTriviaSyntax(SyntaxKind.PragmaChecksumDirectiveTrivia, hashToken, pragmaKeyword, checksumKeyword, file, guid, bytes, endOfDirectiveToken, isActive, this.context);
    }

    public ReferenceDirectiveTriviaSyntax ReferenceDirectiveTrivia(SyntaxToken hashToken, SyntaxToken referenceKeyword, SyntaxToken file, SyntaxToken endOfDirectiveToken, bool isActive)
    {
#if DEBUG
      if (hashToken == null)
        throw new ArgumentNullException(nameof(hashToken));
      switch (hashToken.Kind)
      {
        case SyntaxKind.HashToken:
          break;
        default:
          throw new ArgumentException(nameof(hashToken));
      }
      if (referenceKeyword == null)
        throw new ArgumentNullException(nameof(referenceKeyword));
      switch (referenceKeyword.Kind)
      {
        case SyntaxKind.ReferenceKeyword:
          break;
        default:
          throw new ArgumentException(nameof(referenceKeyword));
      }
      if (file == null)
        throw new ArgumentNullException(nameof(file));
      switch (file.Kind)
      {
        case SyntaxKind.StringLiteralToken:
          break;
        default:
          throw new ArgumentException(nameof(file));
      }
      if (endOfDirectiveToken == null)
        throw new ArgumentNullException(nameof(endOfDirectiveToken));
      switch (endOfDirectiveToken.Kind)
      {
        case SyntaxKind.EndOfDirectiveToken:
          break;
        default:
          throw new ArgumentException(nameof(endOfDirectiveToken));
      }
#endif

      return new ReferenceDirectiveTriviaSyntax(SyntaxKind.ReferenceDirectiveTrivia, hashToken, referenceKeyword, file, endOfDirectiveToken, isActive, this.context);
    }

    public LoadDirectiveTriviaSyntax LoadDirectiveTrivia(SyntaxToken hashToken, SyntaxToken loadKeyword, SyntaxToken file, SyntaxToken endOfDirectiveToken, bool isActive)
    {
#if DEBUG
      if (hashToken == null)
        throw new ArgumentNullException(nameof(hashToken));
      switch (hashToken.Kind)
      {
        case SyntaxKind.HashToken:
          break;
        default:
          throw new ArgumentException(nameof(hashToken));
      }
      if (loadKeyword == null)
        throw new ArgumentNullException(nameof(loadKeyword));
      switch (loadKeyword.Kind)
      {
        case SyntaxKind.LoadKeyword:
          break;
        default:
          throw new ArgumentException(nameof(loadKeyword));
      }
      if (file == null)
        throw new ArgumentNullException(nameof(file));
      switch (file.Kind)
      {
        case SyntaxKind.StringLiteralToken:
          break;
        default:
          throw new ArgumentException(nameof(file));
      }
      if (endOfDirectiveToken == null)
        throw new ArgumentNullException(nameof(endOfDirectiveToken));
      switch (endOfDirectiveToken.Kind)
      {
        case SyntaxKind.EndOfDirectiveToken:
          break;
        default:
          throw new ArgumentException(nameof(endOfDirectiveToken));
      }
#endif

      return new LoadDirectiveTriviaSyntax(SyntaxKind.LoadDirectiveTrivia, hashToken, loadKeyword, file, endOfDirectiveToken, isActive, this.context);
    }

    public ShebangDirectiveTriviaSyntax ShebangDirectiveTrivia(SyntaxToken hashToken, SyntaxToken exclamationToken, SyntaxToken endOfDirectiveToken, bool isActive)
    {
#if DEBUG
      if (hashToken == null)
        throw new ArgumentNullException(nameof(hashToken));
      switch (hashToken.Kind)
      {
        case SyntaxKind.HashToken:
          break;
        default:
          throw new ArgumentException(nameof(hashToken));
      }
      if (exclamationToken == null)
        throw new ArgumentNullException(nameof(exclamationToken));
      switch (exclamationToken.Kind)
      {
        case SyntaxKind.ExclamationToken:
          break;
        default:
          throw new ArgumentException(nameof(exclamationToken));
      }
      if (endOfDirectiveToken == null)
        throw new ArgumentNullException(nameof(endOfDirectiveToken));
      switch (endOfDirectiveToken.Kind)
      {
        case SyntaxKind.EndOfDirectiveToken:
          break;
        default:
          throw new ArgumentException(nameof(endOfDirectiveToken));
      }
#endif

      return new ShebangDirectiveTriviaSyntax(SyntaxKind.ShebangDirectiveTrivia, hashToken, exclamationToken, endOfDirectiveToken, isActive, this.context);
    }

    public NullableDirectiveTriviaSyntax NullableDirectiveTrivia(SyntaxToken hashToken, SyntaxToken nullableKeyword, SyntaxToken settingToken, SyntaxToken targetToken, SyntaxToken endOfDirectiveToken, bool isActive)
    {
#if DEBUG
      if (hashToken == null)
        throw new ArgumentNullException(nameof(hashToken));
      switch (hashToken.Kind)
      {
        case SyntaxKind.HashToken:
          break;
        default:
          throw new ArgumentException(nameof(hashToken));
      }
      if (nullableKeyword == null)
        throw new ArgumentNullException(nameof(nullableKeyword));
      switch (nullableKeyword.Kind)
      {
        case SyntaxKind.NullableKeyword:
          break;
        default:
          throw new ArgumentException(nameof(nullableKeyword));
      }
      if (settingToken == null)
        throw new ArgumentNullException(nameof(settingToken));
      switch (settingToken.Kind)
      {
        case SyntaxKind.EnableKeyword:
        case SyntaxKind.DisableKeyword:
        case SyntaxKind.RestoreKeyword:
          break;
        default:
          throw new ArgumentException(nameof(settingToken));
      }
      if (targetToken != null)
      {
      switch (targetToken.Kind)
      {
        case SyntaxKind.WarningsKeyword:
        case SyntaxKind.AnnotationsKeyword:
        case SyntaxKind.None:
          break;
        default:
          throw new ArgumentException(nameof(targetToken));
      }
      }
      if (endOfDirectiveToken == null)
        throw new ArgumentNullException(nameof(endOfDirectiveToken));
      switch (endOfDirectiveToken.Kind)
      {
        case SyntaxKind.EndOfDirectiveToken:
          break;
        default:
          throw new ArgumentException(nameof(endOfDirectiveToken));
      }
#endif

      return new NullableDirectiveTriviaSyntax(SyntaxKind.NullableDirectiveTrivia, hashToken, nullableKeyword, settingToken, targetToken, endOfDirectiveToken, isActive, this.context);
    }
  }

  internal static partial class SyntaxFactory
  {
    public static IdentifierNameSyntax IdentifierName(SyntaxToken identifier)
    {
#if DEBUG
      if (identifier == null)
        throw new ArgumentNullException(nameof(identifier));
      switch (identifier.Kind)
      {
        case SyntaxKind.IdentifierToken:
        case SyntaxKind.GlobalKeyword:
          break;
        default:
          throw new ArgumentException(nameof(identifier));
      }
#endif

      int hash;
      var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.IdentifierName, identifier, out hash);
      if (cached != null) return (IdentifierNameSyntax)cached;

      var result = new IdentifierNameSyntax(SyntaxKind.IdentifierName, identifier);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public static QualifiedNameSyntax QualifiedName(NameSyntax left, SyntaxToken dotToken, SimpleNameSyntax right)
    {
#if DEBUG
      if (left == null)
        throw new ArgumentNullException(nameof(left));
      if (dotToken == null)
        throw new ArgumentNullException(nameof(dotToken));
      switch (dotToken.Kind)
      {
        case SyntaxKind.DotToken:
          break;
        default:
          throw new ArgumentException(nameof(dotToken));
      }
      if (right == null)
        throw new ArgumentNullException(nameof(right));
#endif

      int hash;
      var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.QualifiedName, left, dotToken, right, out hash);
      if (cached != null) return (QualifiedNameSyntax)cached;

      var result = new QualifiedNameSyntax(SyntaxKind.QualifiedName, left, dotToken, right);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public static GenericNameSyntax GenericName(SyntaxToken identifier, TypeArgumentListSyntax typeArgumentList)
    {
#if DEBUG
      if (identifier == null)
        throw new ArgumentNullException(nameof(identifier));
      switch (identifier.Kind)
      {
        case SyntaxKind.IdentifierToken:
          break;
        default:
          throw new ArgumentException(nameof(identifier));
      }
      if (typeArgumentList == null)
        throw new ArgumentNullException(nameof(typeArgumentList));
#endif

      int hash;
      var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.GenericName, identifier, typeArgumentList, out hash);
      if (cached != null) return (GenericNameSyntax)cached;

      var result = new GenericNameSyntax(SyntaxKind.GenericName, identifier, typeArgumentList);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public static TypeArgumentListSyntax TypeArgumentList(SyntaxToken lessThanToken, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<TypeSyntax> arguments, SyntaxToken greaterThanToken)
    {
#if DEBUG
      if (lessThanToken == null)
        throw new ArgumentNullException(nameof(lessThanToken));
      switch (lessThanToken.Kind)
      {
        case SyntaxKind.LessThanToken:
          break;
        default:
          throw new ArgumentException(nameof(lessThanToken));
      }
      if (greaterThanToken == null)
        throw new ArgumentNullException(nameof(greaterThanToken));
      switch (greaterThanToken.Kind)
      {
        case SyntaxKind.GreaterThanToken:
          break;
        default:
          throw new ArgumentException(nameof(greaterThanToken));
      }
#endif

      int hash;
      var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.TypeArgumentList, lessThanToken, arguments.Node, greaterThanToken, out hash);
      if (cached != null) return (TypeArgumentListSyntax)cached;

      var result = new TypeArgumentListSyntax(SyntaxKind.TypeArgumentList, lessThanToken, arguments.Node, greaterThanToken);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public static AliasQualifiedNameSyntax AliasQualifiedName(IdentifierNameSyntax alias, SyntaxToken colonColonToken, SimpleNameSyntax name)
    {
#if DEBUG
      if (alias == null)
        throw new ArgumentNullException(nameof(alias));
      if (colonColonToken == null)
        throw new ArgumentNullException(nameof(colonColonToken));
      switch (colonColonToken.Kind)
      {
        case SyntaxKind.ColonColonToken:
          break;
        default:
          throw new ArgumentException(nameof(colonColonToken));
      }
      if (name == null)
        throw new ArgumentNullException(nameof(name));
#endif

      int hash;
      var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.AliasQualifiedName, alias, colonColonToken, name, out hash);
      if (cached != null) return (AliasQualifiedNameSyntax)cached;

      var result = new AliasQualifiedNameSyntax(SyntaxKind.AliasQualifiedName, alias, colonColonToken, name);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public static PredefinedTypeSyntax PredefinedType(SyntaxToken keyword)
    {
#if DEBUG
      if (keyword == null)
        throw new ArgumentNullException(nameof(keyword));
      switch (keyword.Kind)
      {
        case SyntaxKind.BoolKeyword:
        case SyntaxKind.ByteKeyword:
        case SyntaxKind.SByteKeyword:
        case SyntaxKind.IntKeyword:
        case SyntaxKind.UIntKeyword:
        case SyntaxKind.ShortKeyword:
        case SyntaxKind.UShortKeyword:
        case SyntaxKind.LongKeyword:
        case SyntaxKind.ULongKeyword:
        case SyntaxKind.FloatKeyword:
        case SyntaxKind.DoubleKeyword:
        case SyntaxKind.DecimalKeyword:
        case SyntaxKind.StringKeyword:
        case SyntaxKind.CharKeyword:
        case SyntaxKind.ObjectKeyword:
        case SyntaxKind.VoidKeyword:
          break;
        default:
          throw new ArgumentException(nameof(keyword));
      }
#endif

      int hash;
      var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.PredefinedType, keyword, out hash);
      if (cached != null) return (PredefinedTypeSyntax)cached;

      var result = new PredefinedTypeSyntax(SyntaxKind.PredefinedType, keyword);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public static ArrayTypeSyntax ArrayType(TypeSyntax elementType, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<ArrayRankSpecifierSyntax> rankSpecifiers)
    {
#if DEBUG
      if (elementType == null)
        throw new ArgumentNullException(nameof(elementType));
#endif

      int hash;
      var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.ArrayType, elementType, rankSpecifiers.Node, out hash);
      if (cached != null) return (ArrayTypeSyntax)cached;

      var result = new ArrayTypeSyntax(SyntaxKind.ArrayType, elementType, rankSpecifiers.Node);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public static ArrayRankSpecifierSyntax ArrayRankSpecifier(SyntaxToken openBracketToken, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<ExpressionSyntax> sizes, SyntaxToken closeBracketToken)
    {
#if DEBUG
      if (openBracketToken == null)
        throw new ArgumentNullException(nameof(openBracketToken));
      switch (openBracketToken.Kind)
      {
        case SyntaxKind.OpenBracketToken:
          break;
        default:
          throw new ArgumentException(nameof(openBracketToken));
      }
      if (closeBracketToken == null)
        throw new ArgumentNullException(nameof(closeBracketToken));
      switch (closeBracketToken.Kind)
      {
        case SyntaxKind.CloseBracketToken:
          break;
        default:
          throw new ArgumentException(nameof(closeBracketToken));
      }
#endif

      int hash;
      var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.ArrayRankSpecifier, openBracketToken, sizes.Node, closeBracketToken, out hash);
      if (cached != null) return (ArrayRankSpecifierSyntax)cached;

      var result = new ArrayRankSpecifierSyntax(SyntaxKind.ArrayRankSpecifier, openBracketToken, sizes.Node, closeBracketToken);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public static PointerTypeSyntax PointerType(TypeSyntax elementType, SyntaxToken asteriskToken)
    {
#if DEBUG
      if (elementType == null)
        throw new ArgumentNullException(nameof(elementType));
      if (asteriskToken == null)
        throw new ArgumentNullException(nameof(asteriskToken));
      switch (asteriskToken.Kind)
      {
        case SyntaxKind.AsteriskToken:
          break;
        default:
          throw new ArgumentException(nameof(asteriskToken));
      }
#endif

      int hash;
      var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.PointerType, elementType, asteriskToken, out hash);
      if (cached != null) return (PointerTypeSyntax)cached;

      var result = new PointerTypeSyntax(SyntaxKind.PointerType, elementType, asteriskToken);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public static NullableTypeSyntax NullableType(TypeSyntax elementType, SyntaxToken questionToken)
    {
#if DEBUG
      if (elementType == null)
        throw new ArgumentNullException(nameof(elementType));
      if (questionToken == null)
        throw new ArgumentNullException(nameof(questionToken));
      switch (questionToken.Kind)
      {
        case SyntaxKind.QuestionToken:
          break;
        default:
          throw new ArgumentException(nameof(questionToken));
      }
#endif

      int hash;
      var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.NullableType, elementType, questionToken, out hash);
      if (cached != null) return (NullableTypeSyntax)cached;

      var result = new NullableTypeSyntax(SyntaxKind.NullableType, elementType, questionToken);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public static TupleTypeSyntax TupleType(SyntaxToken openParenToken, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<TupleElementSyntax> elements, SyntaxToken closeParenToken)
    {
#if DEBUG
      if (openParenToken == null)
        throw new ArgumentNullException(nameof(openParenToken));
      switch (openParenToken.Kind)
      {
        case SyntaxKind.OpenParenToken:
          break;
        default:
          throw new ArgumentException(nameof(openParenToken));
      }
      if (closeParenToken == null)
        throw new ArgumentNullException(nameof(closeParenToken));
      switch (closeParenToken.Kind)
      {
        case SyntaxKind.CloseParenToken:
          break;
        default:
          throw new ArgumentException(nameof(closeParenToken));
      }
#endif

      int hash;
      var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.TupleType, openParenToken, elements.Node, closeParenToken, out hash);
      if (cached != null) return (TupleTypeSyntax)cached;

      var result = new TupleTypeSyntax(SyntaxKind.TupleType, openParenToken, elements.Node, closeParenToken);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public static TupleElementSyntax TupleElement(TypeSyntax type, SyntaxToken identifier)
    {
#if DEBUG
      if (type == null)
        throw new ArgumentNullException(nameof(type));
      if (identifier != null)
      {
      switch (identifier.Kind)
      {
        case SyntaxKind.IdentifierToken:
        case SyntaxKind.None:
          break;
        default:
          throw new ArgumentException(nameof(identifier));
      }
      }
#endif

      int hash;
      var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.TupleElement, type, identifier, out hash);
      if (cached != null) return (TupleElementSyntax)cached;

      var result = new TupleElementSyntax(SyntaxKind.TupleElement, type, identifier);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public static OmittedTypeArgumentSyntax OmittedTypeArgument(SyntaxToken omittedTypeArgumentToken)
    {
#if DEBUG
      if (omittedTypeArgumentToken == null)
        throw new ArgumentNullException(nameof(omittedTypeArgumentToken));
      switch (omittedTypeArgumentToken.Kind)
      {
        case SyntaxKind.OmittedTypeArgumentToken:
          break;
        default:
          throw new ArgumentException(nameof(omittedTypeArgumentToken));
      }
#endif

      int hash;
      var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.OmittedTypeArgument, omittedTypeArgumentToken, out hash);
      if (cached != null) return (OmittedTypeArgumentSyntax)cached;

      var result = new OmittedTypeArgumentSyntax(SyntaxKind.OmittedTypeArgument, omittedTypeArgumentToken);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public static RefTypeSyntax RefType(SyntaxToken refKeyword, SyntaxToken readOnlyKeyword, TypeSyntax type)
    {
#if DEBUG
      if (refKeyword == null)
        throw new ArgumentNullException(nameof(refKeyword));
      switch (refKeyword.Kind)
      {
        case SyntaxKind.RefKeyword:
          break;
        default:
          throw new ArgumentException(nameof(refKeyword));
      }
      if (readOnlyKeyword != null)
      {
      switch (readOnlyKeyword.Kind)
      {
        case SyntaxKind.ReadOnlyKeyword:
        case SyntaxKind.None:
          break;
        default:
          throw new ArgumentException(nameof(readOnlyKeyword));
      }
      }
      if (type == null)
        throw new ArgumentNullException(nameof(type));
#endif

      int hash;
      var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.RefType, refKeyword, readOnlyKeyword, type, out hash);
      if (cached != null) return (RefTypeSyntax)cached;

      var result = new RefTypeSyntax(SyntaxKind.RefType, refKeyword, readOnlyKeyword, type);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public static ParenthesizedExpressionSyntax ParenthesizedExpression(SyntaxToken openParenToken, ExpressionSyntax expression, SyntaxToken closeParenToken)
    {
#if DEBUG
      if (openParenToken == null)
        throw new ArgumentNullException(nameof(openParenToken));
      switch (openParenToken.Kind)
      {
        case SyntaxKind.OpenParenToken:
          break;
        default:
          throw new ArgumentException(nameof(openParenToken));
      }
      if (expression == null)
        throw new ArgumentNullException(nameof(expression));
      if (closeParenToken == null)
        throw new ArgumentNullException(nameof(closeParenToken));
      switch (closeParenToken.Kind)
      {
        case SyntaxKind.CloseParenToken:
          break;
        default:
          throw new ArgumentException(nameof(closeParenToken));
      }
#endif

      int hash;
      var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.ParenthesizedExpression, openParenToken, expression, closeParenToken, out hash);
      if (cached != null) return (ParenthesizedExpressionSyntax)cached;

      var result = new ParenthesizedExpressionSyntax(SyntaxKind.ParenthesizedExpression, openParenToken, expression, closeParenToken);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public static TupleExpressionSyntax TupleExpression(SyntaxToken openParenToken, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<ArgumentSyntax> arguments, SyntaxToken closeParenToken)
    {
#if DEBUG
      if (openParenToken == null)
        throw new ArgumentNullException(nameof(openParenToken));
      switch (openParenToken.Kind)
      {
        case SyntaxKind.OpenParenToken:
          break;
        default:
          throw new ArgumentException(nameof(openParenToken));
      }
      if (closeParenToken == null)
        throw new ArgumentNullException(nameof(closeParenToken));
      switch (closeParenToken.Kind)
      {
        case SyntaxKind.CloseParenToken:
          break;
        default:
          throw new ArgumentException(nameof(closeParenToken));
      }
#endif

      int hash;
      var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.TupleExpression, openParenToken, arguments.Node, closeParenToken, out hash);
      if (cached != null) return (TupleExpressionSyntax)cached;

      var result = new TupleExpressionSyntax(SyntaxKind.TupleExpression, openParenToken, arguments.Node, closeParenToken);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public static PrefixUnaryExpressionSyntax PrefixUnaryExpression(SyntaxKind kind, SyntaxToken operatorToken, ExpressionSyntax operand)
    {
      switch (kind)
      {
        case SyntaxKind.UnaryPlusExpression:
        case SyntaxKind.UnaryMinusExpression:
        case SyntaxKind.BitwiseNotExpression:
        case SyntaxKind.LogicalNotExpression:
        case SyntaxKind.PreIncrementExpression:
        case SyntaxKind.PreDecrementExpression:
        case SyntaxKind.AddressOfExpression:
        case SyntaxKind.PointerIndirectionExpression:
        case SyntaxKind.IndexExpression:
          break;
        default:
          throw new ArgumentException(nameof(kind));
      }
#if DEBUG
      if (operatorToken == null)
        throw new ArgumentNullException(nameof(operatorToken));
      switch (operatorToken.Kind)
      {
        case SyntaxKind.PlusToken:
        case SyntaxKind.MinusToken:
        case SyntaxKind.TildeToken:
        case SyntaxKind.ExclamationToken:
        case SyntaxKind.PlusPlusToken:
        case SyntaxKind.MinusMinusToken:
        case SyntaxKind.AmpersandToken:
        case SyntaxKind.AsteriskToken:
        case SyntaxKind.CaretToken:
          break;
        default:
          throw new ArgumentException(nameof(operatorToken));
      }
      if (operand == null)
        throw new ArgumentNullException(nameof(operand));
#endif

      int hash;
      var cached = SyntaxNodeCache.TryGetNode((int)kind, operatorToken, operand, out hash);
      if (cached != null) return (PrefixUnaryExpressionSyntax)cached;

      var result = new PrefixUnaryExpressionSyntax(kind, operatorToken, operand);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public static AwaitExpressionSyntax AwaitExpression(SyntaxToken awaitKeyword, ExpressionSyntax expression)
    {
#if DEBUG
      if (awaitKeyword == null)
        throw new ArgumentNullException(nameof(awaitKeyword));
      switch (awaitKeyword.Kind)
      {
        case SyntaxKind.AwaitKeyword:
          break;
        default:
          throw new ArgumentException(nameof(awaitKeyword));
      }
      if (expression == null)
        throw new ArgumentNullException(nameof(expression));
#endif

      int hash;
      var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.AwaitExpression, awaitKeyword, expression, out hash);
      if (cached != null) return (AwaitExpressionSyntax)cached;

      var result = new AwaitExpressionSyntax(SyntaxKind.AwaitExpression, awaitKeyword, expression);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public static PostfixUnaryExpressionSyntax PostfixUnaryExpression(SyntaxKind kind, ExpressionSyntax operand, SyntaxToken operatorToken)
    {
      switch (kind)
      {
        case SyntaxKind.PostIncrementExpression:
        case SyntaxKind.PostDecrementExpression:
        case SyntaxKind.SuppressNullableWarningExpression:
          break;
        default:
          throw new ArgumentException(nameof(kind));
      }
#if DEBUG
      if (operand == null)
        throw new ArgumentNullException(nameof(operand));
      if (operatorToken == null)
        throw new ArgumentNullException(nameof(operatorToken));
      switch (operatorToken.Kind)
      {
        case SyntaxKind.PlusPlusToken:
        case SyntaxKind.MinusMinusToken:
        case SyntaxKind.ExclamationToken:
          break;
        default:
          throw new ArgumentException(nameof(operatorToken));
      }
#endif

      int hash;
      var cached = SyntaxNodeCache.TryGetNode((int)kind, operand, operatorToken, out hash);
      if (cached != null) return (PostfixUnaryExpressionSyntax)cached;

      var result = new PostfixUnaryExpressionSyntax(kind, operand, operatorToken);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public static MemberAccessExpressionSyntax MemberAccessExpression(SyntaxKind kind, ExpressionSyntax expression, SyntaxToken operatorToken, SimpleNameSyntax name)
    {
      switch (kind)
      {
        case SyntaxKind.SimpleMemberAccessExpression:
        case SyntaxKind.PointerMemberAccessExpression:
          break;
        default:
          throw new ArgumentException(nameof(kind));
      }
#if DEBUG
      if (expression == null)
        throw new ArgumentNullException(nameof(expression));
      if (operatorToken == null)
        throw new ArgumentNullException(nameof(operatorToken));
      switch (operatorToken.Kind)
      {
        case SyntaxKind.DotToken:
        case SyntaxKind.MinusGreaterThanToken:
          break;
        default:
          throw new ArgumentException(nameof(operatorToken));
      }
      if (name == null)
        throw new ArgumentNullException(nameof(name));
#endif

      int hash;
      var cached = SyntaxNodeCache.TryGetNode((int)kind, expression, operatorToken, name, out hash);
      if (cached != null) return (MemberAccessExpressionSyntax)cached;

      var result = new MemberAccessExpressionSyntax(kind, expression, operatorToken, name);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public static ConditionalAccessExpressionSyntax ConditionalAccessExpression(ExpressionSyntax expression, SyntaxToken operatorToken, ExpressionSyntax whenNotNull)
    {
#if DEBUG
      if (expression == null)
        throw new ArgumentNullException(nameof(expression));
      if (operatorToken == null)
        throw new ArgumentNullException(nameof(operatorToken));
      switch (operatorToken.Kind)
      {
        case SyntaxKind.QuestionToken:
          break;
        default:
          throw new ArgumentException(nameof(operatorToken));
      }
      if (whenNotNull == null)
        throw new ArgumentNullException(nameof(whenNotNull));
#endif

      int hash;
      var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.ConditionalAccessExpression, expression, operatorToken, whenNotNull, out hash);
      if (cached != null) return (ConditionalAccessExpressionSyntax)cached;

      var result = new ConditionalAccessExpressionSyntax(SyntaxKind.ConditionalAccessExpression, expression, operatorToken, whenNotNull);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public static MemberBindingExpressionSyntax MemberBindingExpression(SyntaxToken operatorToken, SimpleNameSyntax name)
    {
#if DEBUG
      if (operatorToken == null)
        throw new ArgumentNullException(nameof(operatorToken));
      switch (operatorToken.Kind)
      {
        case SyntaxKind.DotToken:
          break;
        default:
          throw new ArgumentException(nameof(operatorToken));
      }
      if (name == null)
        throw new ArgumentNullException(nameof(name));
#endif

      int hash;
      var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.MemberBindingExpression, operatorToken, name, out hash);
      if (cached != null) return (MemberBindingExpressionSyntax)cached;

      var result = new MemberBindingExpressionSyntax(SyntaxKind.MemberBindingExpression, operatorToken, name);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public static ElementBindingExpressionSyntax ElementBindingExpression(BracketedArgumentListSyntax argumentList)
    {
#if DEBUG
      if (argumentList == null)
        throw new ArgumentNullException(nameof(argumentList));
#endif

      int hash;
      var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.ElementBindingExpression, argumentList, out hash);
      if (cached != null) return (ElementBindingExpressionSyntax)cached;

      var result = new ElementBindingExpressionSyntax(SyntaxKind.ElementBindingExpression, argumentList);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public static RangeExpressionSyntax RangeExpression(ExpressionSyntax leftOperand, SyntaxToken operatorToken, ExpressionSyntax rightOperand)
    {
#if DEBUG
      if (operatorToken == null)
        throw new ArgumentNullException(nameof(operatorToken));
      switch (operatorToken.Kind)
      {
        case SyntaxKind.DotDotToken:
          break;
        default:
          throw new ArgumentException(nameof(operatorToken));
      }
#endif

      int hash;
      var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.RangeExpression, leftOperand, operatorToken, rightOperand, out hash);
      if (cached != null) return (RangeExpressionSyntax)cached;

      var result = new RangeExpressionSyntax(SyntaxKind.RangeExpression, leftOperand, operatorToken, rightOperand);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public static ImplicitElementAccessSyntax ImplicitElementAccess(BracketedArgumentListSyntax argumentList)
    {
#if DEBUG
      if (argumentList == null)
        throw new ArgumentNullException(nameof(argumentList));
#endif

      int hash;
      var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.ImplicitElementAccess, argumentList, out hash);
      if (cached != null) return (ImplicitElementAccessSyntax)cached;

      var result = new ImplicitElementAccessSyntax(SyntaxKind.ImplicitElementAccess, argumentList);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public static BinaryExpressionSyntax BinaryExpression(SyntaxKind kind, ExpressionSyntax left, SyntaxToken operatorToken, ExpressionSyntax right)
    {
      switch (kind)
      {
        case SyntaxKind.AddExpression:
        case SyntaxKind.SubtractExpression:
        case SyntaxKind.MultiplyExpression:
        case SyntaxKind.DivideExpression:
        case SyntaxKind.ModuloExpression:
        case SyntaxKind.LeftShiftExpression:
        case SyntaxKind.RightShiftExpression:
        case SyntaxKind.LogicalOrExpression:
        case SyntaxKind.LogicalAndExpression:
        case SyntaxKind.BitwiseOrExpression:
        case SyntaxKind.BitwiseAndExpression:
        case SyntaxKind.ExclusiveOrExpression:
        case SyntaxKind.EqualsExpression:
        case SyntaxKind.NotEqualsExpression:
        case SyntaxKind.LessThanExpression:
        case SyntaxKind.LessThanOrEqualExpression:
        case SyntaxKind.GreaterThanExpression:
        case SyntaxKind.GreaterThanOrEqualExpression:
        case SyntaxKind.IsExpression:
        case SyntaxKind.AsExpression:
        case SyntaxKind.CoalesceExpression:
          break;
        default:
          throw new ArgumentException(nameof(kind));
      }
#if DEBUG
      if (left == null)
        throw new ArgumentNullException(nameof(left));
      if (operatorToken == null)
        throw new ArgumentNullException(nameof(operatorToken));
      switch (operatorToken.Kind)
      {
        case SyntaxKind.PlusToken:
        case SyntaxKind.MinusToken:
        case SyntaxKind.AsteriskToken:
        case SyntaxKind.SlashToken:
        case SyntaxKind.PercentToken:
        case SyntaxKind.LessThanLessThanToken:
        case SyntaxKind.GreaterThanGreaterThanToken:
        case SyntaxKind.BarBarToken:
        case SyntaxKind.AmpersandAmpersandToken:
        case SyntaxKind.BarToken:
        case SyntaxKind.AmpersandToken:
        case SyntaxKind.CaretToken:
        case SyntaxKind.EqualsEqualsToken:
        case SyntaxKind.ExclamationEqualsToken:
        case SyntaxKind.LessThanToken:
        case SyntaxKind.LessThanEqualsToken:
        case SyntaxKind.GreaterThanToken:
        case SyntaxKind.GreaterThanEqualsToken:
        case SyntaxKind.IsKeyword:
        case SyntaxKind.AsKeyword:
        case SyntaxKind.QuestionQuestionToken:
          break;
        default:
          throw new ArgumentException(nameof(operatorToken));
      }
      if (right == null)
        throw new ArgumentNullException(nameof(right));
#endif

      int hash;
      var cached = SyntaxNodeCache.TryGetNode((int)kind, left, operatorToken, right, out hash);
      if (cached != null) return (BinaryExpressionSyntax)cached;

      var result = new BinaryExpressionSyntax(kind, left, operatorToken, right);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public static AssignmentExpressionSyntax AssignmentExpression(SyntaxKind kind, ExpressionSyntax left, SyntaxToken operatorToken, ExpressionSyntax right)
    {
      switch (kind)
      {
        case SyntaxKind.SimpleAssignmentExpression:
        case SyntaxKind.AddAssignmentExpression:
        case SyntaxKind.SubtractAssignmentExpression:
        case SyntaxKind.MultiplyAssignmentExpression:
        case SyntaxKind.DivideAssignmentExpression:
        case SyntaxKind.ModuloAssignmentExpression:
        case SyntaxKind.AndAssignmentExpression:
        case SyntaxKind.ExclusiveOrAssignmentExpression:
        case SyntaxKind.OrAssignmentExpression:
        case SyntaxKind.LeftShiftAssignmentExpression:
        case SyntaxKind.RightShiftAssignmentExpression:
        case SyntaxKind.CoalesceAssignmentExpression:
          break;
        default:
          throw new ArgumentException(nameof(kind));
      }
#if DEBUG
      if (left == null)
        throw new ArgumentNullException(nameof(left));
      if (operatorToken == null)
        throw new ArgumentNullException(nameof(operatorToken));
      switch (operatorToken.Kind)
      {
        case SyntaxKind.EqualsToken:
        case SyntaxKind.PlusEqualsToken:
        case SyntaxKind.MinusEqualsToken:
        case SyntaxKind.AsteriskEqualsToken:
        case SyntaxKind.SlashEqualsToken:
        case SyntaxKind.PercentEqualsToken:
        case SyntaxKind.AmpersandEqualsToken:
        case SyntaxKind.CaretEqualsToken:
        case SyntaxKind.BarEqualsToken:
        case SyntaxKind.LessThanLessThanEqualsToken:
        case SyntaxKind.GreaterThanGreaterThanEqualsToken:
        case SyntaxKind.QuestionQuestionEqualsToken:
          break;
        default:
          throw new ArgumentException(nameof(operatorToken));
      }
      if (right == null)
        throw new ArgumentNullException(nameof(right));
#endif

      int hash;
      var cached = SyntaxNodeCache.TryGetNode((int)kind, left, operatorToken, right, out hash);
      if (cached != null) return (AssignmentExpressionSyntax)cached;

      var result = new AssignmentExpressionSyntax(kind, left, operatorToken, right);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public static ConditionalExpressionSyntax ConditionalExpression(ExpressionSyntax condition, SyntaxToken questionToken, ExpressionSyntax whenTrue, SyntaxToken colonToken, ExpressionSyntax whenFalse)
    {
#if DEBUG
      if (condition == null)
        throw new ArgumentNullException(nameof(condition));
      if (questionToken == null)
        throw new ArgumentNullException(nameof(questionToken));
      switch (questionToken.Kind)
      {
        case SyntaxKind.QuestionToken:
          break;
        default:
          throw new ArgumentException(nameof(questionToken));
      }
      if (whenTrue == null)
        throw new ArgumentNullException(nameof(whenTrue));
      if (colonToken == null)
        throw new ArgumentNullException(nameof(colonToken));
      switch (colonToken.Kind)
      {
        case SyntaxKind.ColonToken:
          break;
        default:
          throw new ArgumentException(nameof(colonToken));
      }
      if (whenFalse == null)
        throw new ArgumentNullException(nameof(whenFalse));
#endif

      return new ConditionalExpressionSyntax(SyntaxKind.ConditionalExpression, condition, questionToken, whenTrue, colonToken, whenFalse);
    }

    public static ThisExpressionSyntax ThisExpression(SyntaxToken token)
    {
#if DEBUG
      if (token == null)
        throw new ArgumentNullException(nameof(token));
      switch (token.Kind)
      {
        case SyntaxKind.ThisKeyword:
          break;
        default:
          throw new ArgumentException(nameof(token));
      }
#endif

      int hash;
      var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.ThisExpression, token, out hash);
      if (cached != null) return (ThisExpressionSyntax)cached;

      var result = new ThisExpressionSyntax(SyntaxKind.ThisExpression, token);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public static BaseExpressionSyntax BaseExpression(SyntaxToken token)
    {
#if DEBUG
      if (token == null)
        throw new ArgumentNullException(nameof(token));
      switch (token.Kind)
      {
        case SyntaxKind.BaseKeyword:
          break;
        default:
          throw new ArgumentException(nameof(token));
      }
#endif

      int hash;
      var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.BaseExpression, token, out hash);
      if (cached != null) return (BaseExpressionSyntax)cached;

      var result = new BaseExpressionSyntax(SyntaxKind.BaseExpression, token);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public static LiteralExpressionSyntax LiteralExpression(SyntaxKind kind, SyntaxToken token)
    {
      switch (kind)
      {
        case SyntaxKind.ArgListExpression:
        case SyntaxKind.NumericLiteralExpression:
        case SyntaxKind.StringLiteralExpression:
        case SyntaxKind.CharacterLiteralExpression:
        case SyntaxKind.TrueLiteralExpression:
        case SyntaxKind.FalseLiteralExpression:
        case SyntaxKind.NullLiteralExpression:
        case SyntaxKind.DefaultLiteralExpression:
          break;
        default:
          throw new ArgumentException(nameof(kind));
      }
#if DEBUG
      if (token == null)
        throw new ArgumentNullException(nameof(token));
      switch (token.Kind)
      {
        case SyntaxKind.ArgListKeyword:
        case SyntaxKind.NumericLiteralToken:
        case SyntaxKind.StringLiteralToken:
        case SyntaxKind.CharacterLiteralToken:
        case SyntaxKind.TrueKeyword:
        case SyntaxKind.FalseKeyword:
        case SyntaxKind.NullKeyword:
        case SyntaxKind.DefaultKeyword:
          break;
        default:
          throw new ArgumentException(nameof(token));
      }
#endif

      int hash;
      var cached = SyntaxNodeCache.TryGetNode((int)kind, token, out hash);
      if (cached != null) return (LiteralExpressionSyntax)cached;

      var result = new LiteralExpressionSyntax(kind, token);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public static MakeRefExpressionSyntax MakeRefExpression(SyntaxToken keyword, SyntaxToken openParenToken, ExpressionSyntax expression, SyntaxToken closeParenToken)
    {
#if DEBUG
      if (keyword == null)
        throw new ArgumentNullException(nameof(keyword));
      switch (keyword.Kind)
      {
        case SyntaxKind.MakeRefKeyword:
          break;
        default:
          throw new ArgumentException(nameof(keyword));
      }
      if (openParenToken == null)
        throw new ArgumentNullException(nameof(openParenToken));
      switch (openParenToken.Kind)
      {
        case SyntaxKind.OpenParenToken:
          break;
        default:
          throw new ArgumentException(nameof(openParenToken));
      }
      if (expression == null)
        throw new ArgumentNullException(nameof(expression));
      if (closeParenToken == null)
        throw new ArgumentNullException(nameof(closeParenToken));
      switch (closeParenToken.Kind)
      {
        case SyntaxKind.CloseParenToken:
          break;
        default:
          throw new ArgumentException(nameof(closeParenToken));
      }
#endif

      return new MakeRefExpressionSyntax(SyntaxKind.MakeRefExpression, keyword, openParenToken, expression, closeParenToken);
    }

    public static RefTypeExpressionSyntax RefTypeExpression(SyntaxToken keyword, SyntaxToken openParenToken, ExpressionSyntax expression, SyntaxToken closeParenToken)
    {
#if DEBUG
      if (keyword == null)
        throw new ArgumentNullException(nameof(keyword));
      switch (keyword.Kind)
      {
        case SyntaxKind.RefTypeKeyword:
          break;
        default:
          throw new ArgumentException(nameof(keyword));
      }
      if (openParenToken == null)
        throw new ArgumentNullException(nameof(openParenToken));
      switch (openParenToken.Kind)
      {
        case SyntaxKind.OpenParenToken:
          break;
        default:
          throw new ArgumentException(nameof(openParenToken));
      }
      if (expression == null)
        throw new ArgumentNullException(nameof(expression));
      if (closeParenToken == null)
        throw new ArgumentNullException(nameof(closeParenToken));
      switch (closeParenToken.Kind)
      {
        case SyntaxKind.CloseParenToken:
          break;
        default:
          throw new ArgumentException(nameof(closeParenToken));
      }
#endif

      return new RefTypeExpressionSyntax(SyntaxKind.RefTypeExpression, keyword, openParenToken, expression, closeParenToken);
    }

    public static RefValueExpressionSyntax RefValueExpression(SyntaxToken keyword, SyntaxToken openParenToken, ExpressionSyntax expression, SyntaxToken comma, TypeSyntax type, SyntaxToken closeParenToken)
    {
#if DEBUG
      if (keyword == null)
        throw new ArgumentNullException(nameof(keyword));
      switch (keyword.Kind)
      {
        case SyntaxKind.RefValueKeyword:
          break;
        default:
          throw new ArgumentException(nameof(keyword));
      }
      if (openParenToken == null)
        throw new ArgumentNullException(nameof(openParenToken));
      switch (openParenToken.Kind)
      {
        case SyntaxKind.OpenParenToken:
          break;
        default:
          throw new ArgumentException(nameof(openParenToken));
      }
      if (expression == null)
        throw new ArgumentNullException(nameof(expression));
      if (comma == null)
        throw new ArgumentNullException(nameof(comma));
      switch (comma.Kind)
      {
        case SyntaxKind.CommaToken:
          break;
        default:
          throw new ArgumentException(nameof(comma));
      }
      if (type == null)
        throw new ArgumentNullException(nameof(type));
      if (closeParenToken == null)
        throw new ArgumentNullException(nameof(closeParenToken));
      switch (closeParenToken.Kind)
      {
        case SyntaxKind.CloseParenToken:
          break;
        default:
          throw new ArgumentException(nameof(closeParenToken));
      }
#endif

      return new RefValueExpressionSyntax(SyntaxKind.RefValueExpression, keyword, openParenToken, expression, comma, type, closeParenToken);
    }

    public static CheckedExpressionSyntax CheckedExpression(SyntaxKind kind, SyntaxToken keyword, SyntaxToken openParenToken, ExpressionSyntax expression, SyntaxToken closeParenToken)
    {
      switch (kind)
      {
        case SyntaxKind.CheckedExpression:
        case SyntaxKind.UncheckedExpression:
          break;
        default:
          throw new ArgumentException(nameof(kind));
      }
#if DEBUG
      if (keyword == null)
        throw new ArgumentNullException(nameof(keyword));
      switch (keyword.Kind)
      {
        case SyntaxKind.CheckedKeyword:
        case SyntaxKind.UncheckedKeyword:
          break;
        default:
          throw new ArgumentException(nameof(keyword));
      }
      if (openParenToken == null)
        throw new ArgumentNullException(nameof(openParenToken));
      switch (openParenToken.Kind)
      {
        case SyntaxKind.OpenParenToken:
          break;
        default:
          throw new ArgumentException(nameof(openParenToken));
      }
      if (expression == null)
        throw new ArgumentNullException(nameof(expression));
      if (closeParenToken == null)
        throw new ArgumentNullException(nameof(closeParenToken));
      switch (closeParenToken.Kind)
      {
        case SyntaxKind.CloseParenToken:
          break;
        default:
          throw new ArgumentException(nameof(closeParenToken));
      }
#endif

      return new CheckedExpressionSyntax(kind, keyword, openParenToken, expression, closeParenToken);
    }

    public static DefaultExpressionSyntax DefaultExpression(SyntaxToken keyword, SyntaxToken openParenToken, TypeSyntax type, SyntaxToken closeParenToken)
    {
#if DEBUG
      if (keyword == null)
        throw new ArgumentNullException(nameof(keyword));
      switch (keyword.Kind)
      {
        case SyntaxKind.DefaultKeyword:
          break;
        default:
          throw new ArgumentException(nameof(keyword));
      }
      if (openParenToken == null)
        throw new ArgumentNullException(nameof(openParenToken));
      switch (openParenToken.Kind)
      {
        case SyntaxKind.OpenParenToken:
          break;
        default:
          throw new ArgumentException(nameof(openParenToken));
      }
      if (type == null)
        throw new ArgumentNullException(nameof(type));
      if (closeParenToken == null)
        throw new ArgumentNullException(nameof(closeParenToken));
      switch (closeParenToken.Kind)
      {
        case SyntaxKind.CloseParenToken:
          break;
        default:
          throw new ArgumentException(nameof(closeParenToken));
      }
#endif

      return new DefaultExpressionSyntax(SyntaxKind.DefaultExpression, keyword, openParenToken, type, closeParenToken);
    }

    public static TypeOfExpressionSyntax TypeOfExpression(SyntaxToken keyword, SyntaxToken openParenToken, TypeSyntax type, SyntaxToken closeParenToken)
    {
#if DEBUG
      if (keyword == null)
        throw new ArgumentNullException(nameof(keyword));
      switch (keyword.Kind)
      {
        case SyntaxKind.TypeOfKeyword:
          break;
        default:
          throw new ArgumentException(nameof(keyword));
      }
      if (openParenToken == null)
        throw new ArgumentNullException(nameof(openParenToken));
      switch (openParenToken.Kind)
      {
        case SyntaxKind.OpenParenToken:
          break;
        default:
          throw new ArgumentException(nameof(openParenToken));
      }
      if (type == null)
        throw new ArgumentNullException(nameof(type));
      if (closeParenToken == null)
        throw new ArgumentNullException(nameof(closeParenToken));
      switch (closeParenToken.Kind)
      {
        case SyntaxKind.CloseParenToken:
          break;
        default:
          throw new ArgumentException(nameof(closeParenToken));
      }
#endif

      return new TypeOfExpressionSyntax(SyntaxKind.TypeOfExpression, keyword, openParenToken, type, closeParenToken);
    }

    public static SizeOfExpressionSyntax SizeOfExpression(SyntaxToken keyword, SyntaxToken openParenToken, TypeSyntax type, SyntaxToken closeParenToken)
    {
#if DEBUG
      if (keyword == null)
        throw new ArgumentNullException(nameof(keyword));
      switch (keyword.Kind)
      {
        case SyntaxKind.SizeOfKeyword:
          break;
        default:
          throw new ArgumentException(nameof(keyword));
      }
      if (openParenToken == null)
        throw new ArgumentNullException(nameof(openParenToken));
      switch (openParenToken.Kind)
      {
        case SyntaxKind.OpenParenToken:
          break;
        default:
          throw new ArgumentException(nameof(openParenToken));
      }
      if (type == null)
        throw new ArgumentNullException(nameof(type));
      if (closeParenToken == null)
        throw new ArgumentNullException(nameof(closeParenToken));
      switch (closeParenToken.Kind)
      {
        case SyntaxKind.CloseParenToken:
          break;
        default:
          throw new ArgumentException(nameof(closeParenToken));
      }
#endif

      return new SizeOfExpressionSyntax(SyntaxKind.SizeOfExpression, keyword, openParenToken, type, closeParenToken);
    }

    public static InvocationExpressionSyntax InvocationExpression(ExpressionSyntax expression, ArgumentListSyntax argumentList)
    {
#if DEBUG
      if (expression == null)
        throw new ArgumentNullException(nameof(expression));
      if (argumentList == null)
        throw new ArgumentNullException(nameof(argumentList));
#endif

      int hash;
      var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.InvocationExpression, expression, argumentList, out hash);
      if (cached != null) return (InvocationExpressionSyntax)cached;

      var result = new InvocationExpressionSyntax(SyntaxKind.InvocationExpression, expression, argumentList);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public static ElementAccessExpressionSyntax ElementAccessExpression(ExpressionSyntax expression, BracketedArgumentListSyntax argumentList)
    {
#if DEBUG
      if (expression == null)
        throw new ArgumentNullException(nameof(expression));
      if (argumentList == null)
        throw new ArgumentNullException(nameof(argumentList));
#endif

      int hash;
      var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.ElementAccessExpression, expression, argumentList, out hash);
      if (cached != null) return (ElementAccessExpressionSyntax)cached;

      var result = new ElementAccessExpressionSyntax(SyntaxKind.ElementAccessExpression, expression, argumentList);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public static ArgumentListSyntax ArgumentList(SyntaxToken openParenToken, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<ArgumentSyntax> arguments, SyntaxToken closeParenToken)
    {
#if DEBUG
      if (openParenToken == null)
        throw new ArgumentNullException(nameof(openParenToken));
      switch (openParenToken.Kind)
      {
        case SyntaxKind.OpenParenToken:
          break;
        default:
          throw new ArgumentException(nameof(openParenToken));
      }
      if (closeParenToken == null)
        throw new ArgumentNullException(nameof(closeParenToken));
      switch (closeParenToken.Kind)
      {
        case SyntaxKind.CloseParenToken:
          break;
        default:
          throw new ArgumentException(nameof(closeParenToken));
      }
#endif

      int hash;
      var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.ArgumentList, openParenToken, arguments.Node, closeParenToken, out hash);
      if (cached != null) return (ArgumentListSyntax)cached;

      var result = new ArgumentListSyntax(SyntaxKind.ArgumentList, openParenToken, arguments.Node, closeParenToken);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public static BracketedArgumentListSyntax BracketedArgumentList(SyntaxToken openBracketToken, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<ArgumentSyntax> arguments, SyntaxToken closeBracketToken)
    {
#if DEBUG
      if (openBracketToken == null)
        throw new ArgumentNullException(nameof(openBracketToken));
      switch (openBracketToken.Kind)
      {
        case SyntaxKind.OpenBracketToken:
          break;
        default:
          throw new ArgumentException(nameof(openBracketToken));
      }
      if (closeBracketToken == null)
        throw new ArgumentNullException(nameof(closeBracketToken));
      switch (closeBracketToken.Kind)
      {
        case SyntaxKind.CloseBracketToken:
          break;
        default:
          throw new ArgumentException(nameof(closeBracketToken));
      }
#endif

      int hash;
      var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.BracketedArgumentList, openBracketToken, arguments.Node, closeBracketToken, out hash);
      if (cached != null) return (BracketedArgumentListSyntax)cached;

      var result = new BracketedArgumentListSyntax(SyntaxKind.BracketedArgumentList, openBracketToken, arguments.Node, closeBracketToken);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public static ArgumentSyntax Argument(NameColonSyntax nameColon, SyntaxToken refKindKeyword, ExpressionSyntax expression)
    {
#if DEBUG
      if (refKindKeyword != null)
      {
      switch (refKindKeyword.Kind)
      {
        case SyntaxKind.RefKeyword:
        case SyntaxKind.OutKeyword:
        case SyntaxKind.InKeyword:
        case SyntaxKind.None:
          break;
        default:
          throw new ArgumentException(nameof(refKindKeyword));
      }
      }
      if (expression == null)
        throw new ArgumentNullException(nameof(expression));
#endif

      int hash;
      var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.Argument, nameColon, refKindKeyword, expression, out hash);
      if (cached != null) return (ArgumentSyntax)cached;

      var result = new ArgumentSyntax(SyntaxKind.Argument, nameColon, refKindKeyword, expression);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public static NameColonSyntax NameColon(IdentifierNameSyntax name, SyntaxToken colonToken)
    {
#if DEBUG
      if (name == null)
        throw new ArgumentNullException(nameof(name));
      if (colonToken == null)
        throw new ArgumentNullException(nameof(colonToken));
      switch (colonToken.Kind)
      {
        case SyntaxKind.ColonToken:
          break;
        default:
          throw new ArgumentException(nameof(colonToken));
      }
#endif

      int hash;
      var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.NameColon, name, colonToken, out hash);
      if (cached != null) return (NameColonSyntax)cached;

      var result = new NameColonSyntax(SyntaxKind.NameColon, name, colonToken);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public static DeclarationExpressionSyntax DeclarationExpression(TypeSyntax type, VariableDesignationSyntax designation)
    {
#if DEBUG
      if (type == null)
        throw new ArgumentNullException(nameof(type));
      if (designation == null)
        throw new ArgumentNullException(nameof(designation));
#endif

      int hash;
      var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.DeclarationExpression, type, designation, out hash);
      if (cached != null) return (DeclarationExpressionSyntax)cached;

      var result = new DeclarationExpressionSyntax(SyntaxKind.DeclarationExpression, type, designation);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public static CastExpressionSyntax CastExpression(SyntaxToken openParenToken, TypeSyntax type, SyntaxToken closeParenToken, ExpressionSyntax expression)
    {
#if DEBUG
      if (openParenToken == null)
        throw new ArgumentNullException(nameof(openParenToken));
      switch (openParenToken.Kind)
      {
        case SyntaxKind.OpenParenToken:
          break;
        default:
          throw new ArgumentException(nameof(openParenToken));
      }
      if (type == null)
        throw new ArgumentNullException(nameof(type));
      if (closeParenToken == null)
        throw new ArgumentNullException(nameof(closeParenToken));
      switch (closeParenToken.Kind)
      {
        case SyntaxKind.CloseParenToken:
          break;
        default:
          throw new ArgumentException(nameof(closeParenToken));
      }
      if (expression == null)
        throw new ArgumentNullException(nameof(expression));
#endif

      return new CastExpressionSyntax(SyntaxKind.CastExpression, openParenToken, type, closeParenToken, expression);
    }

    public static AnonymousMethodExpressionSyntax AnonymousMethodExpression(SyntaxToken asyncKeyword, SyntaxToken delegateKeyword, ParameterListSyntax parameterList, CSharpSyntaxNode body)
    {
#if DEBUG
      if (asyncKeyword != null)
      {
      switch (asyncKeyword.Kind)
      {
        case SyntaxKind.AsyncKeyword:
        case SyntaxKind.None:
          break;
        default:
          throw new ArgumentException(nameof(asyncKeyword));
      }
      }
      if (delegateKeyword == null)
        throw new ArgumentNullException(nameof(delegateKeyword));
      switch (delegateKeyword.Kind)
      {
        case SyntaxKind.DelegateKeyword:
          break;
        default:
          throw new ArgumentException(nameof(delegateKeyword));
      }
      if (body == null)
        throw new ArgumentNullException(nameof(body));
#endif

      return new AnonymousMethodExpressionSyntax(SyntaxKind.AnonymousMethodExpression, asyncKeyword, delegateKeyword, parameterList, body);
    }

    public static SimpleLambdaExpressionSyntax SimpleLambdaExpression(SyntaxToken asyncKeyword, ParameterSyntax parameter, SyntaxToken arrowToken, CSharpSyntaxNode body)
    {
#if DEBUG
      if (asyncKeyword != null)
      {
      switch (asyncKeyword.Kind)
      {
        case SyntaxKind.AsyncKeyword:
        case SyntaxKind.None:
          break;
        default:
          throw new ArgumentException(nameof(asyncKeyword));
      }
      }
      if (parameter == null)
        throw new ArgumentNullException(nameof(parameter));
      if (arrowToken == null)
        throw new ArgumentNullException(nameof(arrowToken));
      switch (arrowToken.Kind)
      {
        case SyntaxKind.EqualsGreaterThanToken:
          break;
        default:
          throw new ArgumentException(nameof(arrowToken));
      }
      if (body == null)
        throw new ArgumentNullException(nameof(body));
#endif

      return new SimpleLambdaExpressionSyntax(SyntaxKind.SimpleLambdaExpression, asyncKeyword, parameter, arrowToken, body);
    }

    public static RefExpressionSyntax RefExpression(SyntaxToken refKeyword, ExpressionSyntax expression)
    {
#if DEBUG
      if (refKeyword == null)
        throw new ArgumentNullException(nameof(refKeyword));
      switch (refKeyword.Kind)
      {
        case SyntaxKind.RefKeyword:
          break;
        default:
          throw new ArgumentException(nameof(refKeyword));
      }
      if (expression == null)
        throw new ArgumentNullException(nameof(expression));
#endif

      int hash;
      var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.RefExpression, refKeyword, expression, out hash);
      if (cached != null) return (RefExpressionSyntax)cached;

      var result = new RefExpressionSyntax(SyntaxKind.RefExpression, refKeyword, expression);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public static ParenthesizedLambdaExpressionSyntax ParenthesizedLambdaExpression(SyntaxToken asyncKeyword, ParameterListSyntax parameterList, SyntaxToken arrowToken, CSharpSyntaxNode body)
    {
#if DEBUG
      if (asyncKeyword != null)
      {
      switch (asyncKeyword.Kind)
      {
        case SyntaxKind.AsyncKeyword:
        case SyntaxKind.None:
          break;
        default:
          throw new ArgumentException(nameof(asyncKeyword));
      }
      }
      if (parameterList == null)
        throw new ArgumentNullException(nameof(parameterList));
      if (arrowToken == null)
        throw new ArgumentNullException(nameof(arrowToken));
      switch (arrowToken.Kind)
      {
        case SyntaxKind.EqualsGreaterThanToken:
          break;
        default:
          throw new ArgumentException(nameof(arrowToken));
      }
      if (body == null)
        throw new ArgumentNullException(nameof(body));
#endif

      return new ParenthesizedLambdaExpressionSyntax(SyntaxKind.ParenthesizedLambdaExpression, asyncKeyword, parameterList, arrowToken, body);
    }

    public static InitializerExpressionSyntax InitializerExpression(SyntaxKind kind, SyntaxToken openBraceToken, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<ExpressionSyntax> expressions, SyntaxToken closeBraceToken)
    {
      switch (kind)
      {
        case SyntaxKind.ObjectInitializerExpression:
        case SyntaxKind.CollectionInitializerExpression:
        case SyntaxKind.ArrayInitializerExpression:
        case SyntaxKind.ComplexElementInitializerExpression:
          break;
        default:
          throw new ArgumentException(nameof(kind));
      }
#if DEBUG
      if (openBraceToken == null)
        throw new ArgumentNullException(nameof(openBraceToken));
      switch (openBraceToken.Kind)
      {
        case SyntaxKind.OpenBraceToken:
          break;
        default:
          throw new ArgumentException(nameof(openBraceToken));
      }
      if (closeBraceToken == null)
        throw new ArgumentNullException(nameof(closeBraceToken));
      switch (closeBraceToken.Kind)
      {
        case SyntaxKind.CloseBraceToken:
          break;
        default:
          throw new ArgumentException(nameof(closeBraceToken));
      }
#endif

      int hash;
      var cached = SyntaxNodeCache.TryGetNode((int)kind, openBraceToken, expressions.Node, closeBraceToken, out hash);
      if (cached != null) return (InitializerExpressionSyntax)cached;

      var result = new InitializerExpressionSyntax(kind, openBraceToken, expressions.Node, closeBraceToken);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public static ObjectCreationExpressionSyntax ObjectCreationExpression(SyntaxToken newKeyword, TypeSyntax type, ArgumentListSyntax argumentList, InitializerExpressionSyntax initializer)
    {
#if DEBUG
      if (newKeyword == null)
        throw new ArgumentNullException(nameof(newKeyword));
      switch (newKeyword.Kind)
      {
        case SyntaxKind.NewKeyword:
          break;
        default:
          throw new ArgumentException(nameof(newKeyword));
      }
      if (type == null)
        throw new ArgumentNullException(nameof(type));
#endif

      return new ObjectCreationExpressionSyntax(SyntaxKind.ObjectCreationExpression, newKeyword, type, argumentList, initializer);
    }

    public static AnonymousObjectMemberDeclaratorSyntax AnonymousObjectMemberDeclarator(NameEqualsSyntax nameEquals, ExpressionSyntax expression)
    {
#if DEBUG
      if (expression == null)
        throw new ArgumentNullException(nameof(expression));
#endif

      int hash;
      var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.AnonymousObjectMemberDeclarator, nameEquals, expression, out hash);
      if (cached != null) return (AnonymousObjectMemberDeclaratorSyntax)cached;

      var result = new AnonymousObjectMemberDeclaratorSyntax(SyntaxKind.AnonymousObjectMemberDeclarator, nameEquals, expression);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public static AnonymousObjectCreationExpressionSyntax AnonymousObjectCreationExpression(SyntaxToken newKeyword, SyntaxToken openBraceToken, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<AnonymousObjectMemberDeclaratorSyntax> initializers, SyntaxToken closeBraceToken)
    {
#if DEBUG
      if (newKeyword == null)
        throw new ArgumentNullException(nameof(newKeyword));
      switch (newKeyword.Kind)
      {
        case SyntaxKind.NewKeyword:
          break;
        default:
          throw new ArgumentException(nameof(newKeyword));
      }
      if (openBraceToken == null)
        throw new ArgumentNullException(nameof(openBraceToken));
      switch (openBraceToken.Kind)
      {
        case SyntaxKind.OpenBraceToken:
          break;
        default:
          throw new ArgumentException(nameof(openBraceToken));
      }
      if (closeBraceToken == null)
        throw new ArgumentNullException(nameof(closeBraceToken));
      switch (closeBraceToken.Kind)
      {
        case SyntaxKind.CloseBraceToken:
          break;
        default:
          throw new ArgumentException(nameof(closeBraceToken));
      }
#endif

      return new AnonymousObjectCreationExpressionSyntax(SyntaxKind.AnonymousObjectCreationExpression, newKeyword, openBraceToken, initializers.Node, closeBraceToken);
    }

    public static ArrayCreationExpressionSyntax ArrayCreationExpression(SyntaxToken newKeyword, ArrayTypeSyntax type, InitializerExpressionSyntax initializer)
    {
#if DEBUG
      if (newKeyword == null)
        throw new ArgumentNullException(nameof(newKeyword));
      switch (newKeyword.Kind)
      {
        case SyntaxKind.NewKeyword:
          break;
        default:
          throw new ArgumentException(nameof(newKeyword));
      }
      if (type == null)
        throw new ArgumentNullException(nameof(type));
#endif

      int hash;
      var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.ArrayCreationExpression, newKeyword, type, initializer, out hash);
      if (cached != null) return (ArrayCreationExpressionSyntax)cached;

      var result = new ArrayCreationExpressionSyntax(SyntaxKind.ArrayCreationExpression, newKeyword, type, initializer);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public static ImplicitArrayCreationExpressionSyntax ImplicitArrayCreationExpression(SyntaxToken newKeyword, SyntaxToken openBracketToken, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SyntaxToken> commas, SyntaxToken closeBracketToken, InitializerExpressionSyntax initializer)
    {
#if DEBUG
      if (newKeyword == null)
        throw new ArgumentNullException(nameof(newKeyword));
      switch (newKeyword.Kind)
      {
        case SyntaxKind.NewKeyword:
          break;
        default:
          throw new ArgumentException(nameof(newKeyword));
      }
      if (openBracketToken == null)
        throw new ArgumentNullException(nameof(openBracketToken));
      switch (openBracketToken.Kind)
      {
        case SyntaxKind.OpenBracketToken:
          break;
        default:
          throw new ArgumentException(nameof(openBracketToken));
      }
      if (closeBracketToken == null)
        throw new ArgumentNullException(nameof(closeBracketToken));
      switch (closeBracketToken.Kind)
      {
        case SyntaxKind.CloseBracketToken:
          break;
        default:
          throw new ArgumentException(nameof(closeBracketToken));
      }
      if (initializer == null)
        throw new ArgumentNullException(nameof(initializer));
#endif

      return new ImplicitArrayCreationExpressionSyntax(SyntaxKind.ImplicitArrayCreationExpression, newKeyword, openBracketToken, commas.Node, closeBracketToken, initializer);
    }

    public static StackAllocArrayCreationExpressionSyntax StackAllocArrayCreationExpression(SyntaxToken stackAllocKeyword, TypeSyntax type, InitializerExpressionSyntax initializer)
    {
#if DEBUG
      if (stackAllocKeyword == null)
        throw new ArgumentNullException(nameof(stackAllocKeyword));
      switch (stackAllocKeyword.Kind)
      {
        case SyntaxKind.StackAllocKeyword:
          break;
        default:
          throw new ArgumentException(nameof(stackAllocKeyword));
      }
      if (type == null)
        throw new ArgumentNullException(nameof(type));
#endif

      int hash;
      var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.StackAllocArrayCreationExpression, stackAllocKeyword, type, initializer, out hash);
      if (cached != null) return (StackAllocArrayCreationExpressionSyntax)cached;

      var result = new StackAllocArrayCreationExpressionSyntax(SyntaxKind.StackAllocArrayCreationExpression, stackAllocKeyword, type, initializer);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public static ImplicitStackAllocArrayCreationExpressionSyntax ImplicitStackAllocArrayCreationExpression(SyntaxToken stackAllocKeyword, SyntaxToken openBracketToken, SyntaxToken closeBracketToken, InitializerExpressionSyntax initializer)
    {
#if DEBUG
      if (stackAllocKeyword == null)
        throw new ArgumentNullException(nameof(stackAllocKeyword));
      switch (stackAllocKeyword.Kind)
      {
        case SyntaxKind.StackAllocKeyword:
          break;
        default:
          throw new ArgumentException(nameof(stackAllocKeyword));
      }
      if (openBracketToken == null)
        throw new ArgumentNullException(nameof(openBracketToken));
      switch (openBracketToken.Kind)
      {
        case SyntaxKind.OpenBracketToken:
          break;
        default:
          throw new ArgumentException(nameof(openBracketToken));
      }
      if (closeBracketToken == null)
        throw new ArgumentNullException(nameof(closeBracketToken));
      switch (closeBracketToken.Kind)
      {
        case SyntaxKind.CloseBracketToken:
          break;
        default:
          throw new ArgumentException(nameof(closeBracketToken));
      }
      if (initializer == null)
        throw new ArgumentNullException(nameof(initializer));
#endif

      return new ImplicitStackAllocArrayCreationExpressionSyntax(SyntaxKind.ImplicitStackAllocArrayCreationExpression, stackAllocKeyword, openBracketToken, closeBracketToken, initializer);
    }

    public static QueryExpressionSyntax QueryExpression(FromClauseSyntax fromClause, QueryBodySyntax body)
    {
#if DEBUG
      if (fromClause == null)
        throw new ArgumentNullException(nameof(fromClause));
      if (body == null)
        throw new ArgumentNullException(nameof(body));
#endif

      int hash;
      var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.QueryExpression, fromClause, body, out hash);
      if (cached != null) return (QueryExpressionSyntax)cached;

      var result = new QueryExpressionSyntax(SyntaxKind.QueryExpression, fromClause, body);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public static QueryBodySyntax QueryBody(Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<QueryClauseSyntax> clauses, SelectOrGroupClauseSyntax selectOrGroup, QueryContinuationSyntax continuation)
    {
#if DEBUG
      if (selectOrGroup == null)
        throw new ArgumentNullException(nameof(selectOrGroup));
#endif

      int hash;
      var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.QueryBody, clauses.Node, selectOrGroup, continuation, out hash);
      if (cached != null) return (QueryBodySyntax)cached;

      var result = new QueryBodySyntax(SyntaxKind.QueryBody, clauses.Node, selectOrGroup, continuation);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public static FromClauseSyntax FromClause(SyntaxToken fromKeyword, TypeSyntax type, SyntaxToken identifier, SyntaxToken inKeyword, ExpressionSyntax expression)
    {
#if DEBUG
      if (fromKeyword == null)
        throw new ArgumentNullException(nameof(fromKeyword));
      switch (fromKeyword.Kind)
      {
        case SyntaxKind.FromKeyword:
          break;
        default:
          throw new ArgumentException(nameof(fromKeyword));
      }
      if (identifier == null)
        throw new ArgumentNullException(nameof(identifier));
      switch (identifier.Kind)
      {
        case SyntaxKind.IdentifierToken:
          break;
        default:
          throw new ArgumentException(nameof(identifier));
      }
      if (inKeyword == null)
        throw new ArgumentNullException(nameof(inKeyword));
      switch (inKeyword.Kind)
      {
        case SyntaxKind.InKeyword:
          break;
        default:
          throw new ArgumentException(nameof(inKeyword));
      }
      if (expression == null)
        throw new ArgumentNullException(nameof(expression));
#endif

      return new FromClauseSyntax(SyntaxKind.FromClause, fromKeyword, type, identifier, inKeyword, expression);
    }

    public static LetClauseSyntax LetClause(SyntaxToken letKeyword, SyntaxToken identifier, SyntaxToken equalsToken, ExpressionSyntax expression)
    {
#if DEBUG
      if (letKeyword == null)
        throw new ArgumentNullException(nameof(letKeyword));
      switch (letKeyword.Kind)
      {
        case SyntaxKind.LetKeyword:
          break;
        default:
          throw new ArgumentException(nameof(letKeyword));
      }
      if (identifier == null)
        throw new ArgumentNullException(nameof(identifier));
      switch (identifier.Kind)
      {
        case SyntaxKind.IdentifierToken:
          break;
        default:
          throw new ArgumentException(nameof(identifier));
      }
      if (equalsToken == null)
        throw new ArgumentNullException(nameof(equalsToken));
      switch (equalsToken.Kind)
      {
        case SyntaxKind.EqualsToken:
          break;
        default:
          throw new ArgumentException(nameof(equalsToken));
      }
      if (expression == null)
        throw new ArgumentNullException(nameof(expression));
#endif

      return new LetClauseSyntax(SyntaxKind.LetClause, letKeyword, identifier, equalsToken, expression);
    }

    public static JoinClauseSyntax JoinClause(SyntaxToken joinKeyword, TypeSyntax type, SyntaxToken identifier, SyntaxToken inKeyword, ExpressionSyntax inExpression, SyntaxToken onKeyword, ExpressionSyntax leftExpression, SyntaxToken equalsKeyword, ExpressionSyntax rightExpression, JoinIntoClauseSyntax into)
    {
#if DEBUG
      if (joinKeyword == null)
        throw new ArgumentNullException(nameof(joinKeyword));
      switch (joinKeyword.Kind)
      {
        case SyntaxKind.JoinKeyword:
          break;
        default:
          throw new ArgumentException(nameof(joinKeyword));
      }
      if (identifier == null)
        throw new ArgumentNullException(nameof(identifier));
      switch (identifier.Kind)
      {
        case SyntaxKind.IdentifierToken:
          break;
        default:
          throw new ArgumentException(nameof(identifier));
      }
      if (inKeyword == null)
        throw new ArgumentNullException(nameof(inKeyword));
      switch (inKeyword.Kind)
      {
        case SyntaxKind.InKeyword:
          break;
        default:
          throw new ArgumentException(nameof(inKeyword));
      }
      if (inExpression == null)
        throw new ArgumentNullException(nameof(inExpression));
      if (onKeyword == null)
        throw new ArgumentNullException(nameof(onKeyword));
      switch (onKeyword.Kind)
      {
        case SyntaxKind.OnKeyword:
          break;
        default:
          throw new ArgumentException(nameof(onKeyword));
      }
      if (leftExpression == null)
        throw new ArgumentNullException(nameof(leftExpression));
      if (equalsKeyword == null)
        throw new ArgumentNullException(nameof(equalsKeyword));
      switch (equalsKeyword.Kind)
      {
        case SyntaxKind.EqualsKeyword:
          break;
        default:
          throw new ArgumentException(nameof(equalsKeyword));
      }
      if (rightExpression == null)
        throw new ArgumentNullException(nameof(rightExpression));
#endif

      return new JoinClauseSyntax(SyntaxKind.JoinClause, joinKeyword, type, identifier, inKeyword, inExpression, onKeyword, leftExpression, equalsKeyword, rightExpression, into);
    }

    public static JoinIntoClauseSyntax JoinIntoClause(SyntaxToken intoKeyword, SyntaxToken identifier)
    {
#if DEBUG
      if (intoKeyword == null)
        throw new ArgumentNullException(nameof(intoKeyword));
      switch (intoKeyword.Kind)
      {
        case SyntaxKind.IntoKeyword:
          break;
        default:
          throw new ArgumentException(nameof(intoKeyword));
      }
      if (identifier == null)
        throw new ArgumentNullException(nameof(identifier));
      switch (identifier.Kind)
      {
        case SyntaxKind.IdentifierToken:
          break;
        default:
          throw new ArgumentException(nameof(identifier));
      }
#endif

      int hash;
      var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.JoinIntoClause, intoKeyword, identifier, out hash);
      if (cached != null) return (JoinIntoClauseSyntax)cached;

      var result = new JoinIntoClauseSyntax(SyntaxKind.JoinIntoClause, intoKeyword, identifier);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public static WhereClauseSyntax WhereClause(SyntaxToken whereKeyword, ExpressionSyntax condition)
    {
#if DEBUG
      if (whereKeyword == null)
        throw new ArgumentNullException(nameof(whereKeyword));
      switch (whereKeyword.Kind)
      {
        case SyntaxKind.WhereKeyword:
          break;
        default:
          throw new ArgumentException(nameof(whereKeyword));
      }
      if (condition == null)
        throw new ArgumentNullException(nameof(condition));
#endif

      int hash;
      var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.WhereClause, whereKeyword, condition, out hash);
      if (cached != null) return (WhereClauseSyntax)cached;

      var result = new WhereClauseSyntax(SyntaxKind.WhereClause, whereKeyword, condition);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public static OrderByClauseSyntax OrderByClause(SyntaxToken orderByKeyword, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<OrderingSyntax> orderings)
    {
#if DEBUG
      if (orderByKeyword == null)
        throw new ArgumentNullException(nameof(orderByKeyword));
      switch (orderByKeyword.Kind)
      {
        case SyntaxKind.OrderByKeyword:
          break;
        default:
          throw new ArgumentException(nameof(orderByKeyword));
      }
#endif

      int hash;
      var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.OrderByClause, orderByKeyword, orderings.Node, out hash);
      if (cached != null) return (OrderByClauseSyntax)cached;

      var result = new OrderByClauseSyntax(SyntaxKind.OrderByClause, orderByKeyword, orderings.Node);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public static OrderingSyntax Ordering(SyntaxKind kind, ExpressionSyntax expression, SyntaxToken ascendingOrDescendingKeyword)
    {
      switch (kind)
      {
        case SyntaxKind.AscendingOrdering:
        case SyntaxKind.DescendingOrdering:
          break;
        default:
          throw new ArgumentException(nameof(kind));
      }
#if DEBUG
      if (expression == null)
        throw new ArgumentNullException(nameof(expression));
      if (ascendingOrDescendingKeyword != null)
      {
      switch (ascendingOrDescendingKeyword.Kind)
      {
        case SyntaxKind.AscendingKeyword:
        case SyntaxKind.DescendingKeyword:
        case SyntaxKind.None:
          break;
        default:
          throw new ArgumentException(nameof(ascendingOrDescendingKeyword));
      }
      }
#endif

      int hash;
      var cached = SyntaxNodeCache.TryGetNode((int)kind, expression, ascendingOrDescendingKeyword, out hash);
      if (cached != null) return (OrderingSyntax)cached;

      var result = new OrderingSyntax(kind, expression, ascendingOrDescendingKeyword);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public static SelectClauseSyntax SelectClause(SyntaxToken selectKeyword, ExpressionSyntax expression)
    {
#if DEBUG
      if (selectKeyword == null)
        throw new ArgumentNullException(nameof(selectKeyword));
      switch (selectKeyword.Kind)
      {
        case SyntaxKind.SelectKeyword:
          break;
        default:
          throw new ArgumentException(nameof(selectKeyword));
      }
      if (expression == null)
        throw new ArgumentNullException(nameof(expression));
#endif

      int hash;
      var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.SelectClause, selectKeyword, expression, out hash);
      if (cached != null) return (SelectClauseSyntax)cached;

      var result = new SelectClauseSyntax(SyntaxKind.SelectClause, selectKeyword, expression);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public static GroupClauseSyntax GroupClause(SyntaxToken groupKeyword, ExpressionSyntax groupExpression, SyntaxToken byKeyword, ExpressionSyntax byExpression)
    {
#if DEBUG
      if (groupKeyword == null)
        throw new ArgumentNullException(nameof(groupKeyword));
      switch (groupKeyword.Kind)
      {
        case SyntaxKind.GroupKeyword:
          break;
        default:
          throw new ArgumentException(nameof(groupKeyword));
      }
      if (groupExpression == null)
        throw new ArgumentNullException(nameof(groupExpression));
      if (byKeyword == null)
        throw new ArgumentNullException(nameof(byKeyword));
      switch (byKeyword.Kind)
      {
        case SyntaxKind.ByKeyword:
          break;
        default:
          throw new ArgumentException(nameof(byKeyword));
      }
      if (byExpression == null)
        throw new ArgumentNullException(nameof(byExpression));
#endif

      return new GroupClauseSyntax(SyntaxKind.GroupClause, groupKeyword, groupExpression, byKeyword, byExpression);
    }

    public static QueryContinuationSyntax QueryContinuation(SyntaxToken intoKeyword, SyntaxToken identifier, QueryBodySyntax body)
    {
#if DEBUG
      if (intoKeyword == null)
        throw new ArgumentNullException(nameof(intoKeyword));
      switch (intoKeyword.Kind)
      {
        case SyntaxKind.IntoKeyword:
          break;
        default:
          throw new ArgumentException(nameof(intoKeyword));
      }
      if (identifier == null)
        throw new ArgumentNullException(nameof(identifier));
      switch (identifier.Kind)
      {
        case SyntaxKind.IdentifierToken:
          break;
        default:
          throw new ArgumentException(nameof(identifier));
      }
      if (body == null)
        throw new ArgumentNullException(nameof(body));
#endif

      int hash;
      var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.QueryContinuation, intoKeyword, identifier, body, out hash);
      if (cached != null) return (QueryContinuationSyntax)cached;

      var result = new QueryContinuationSyntax(SyntaxKind.QueryContinuation, intoKeyword, identifier, body);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public static OmittedArraySizeExpressionSyntax OmittedArraySizeExpression(SyntaxToken omittedArraySizeExpressionToken)
    {
#if DEBUG
      if (omittedArraySizeExpressionToken == null)
        throw new ArgumentNullException(nameof(omittedArraySizeExpressionToken));
      switch (omittedArraySizeExpressionToken.Kind)
      {
        case SyntaxKind.OmittedArraySizeExpressionToken:
          break;
        default:
          throw new ArgumentException(nameof(omittedArraySizeExpressionToken));
      }
#endif

      int hash;
      var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.OmittedArraySizeExpression, omittedArraySizeExpressionToken, out hash);
      if (cached != null) return (OmittedArraySizeExpressionSyntax)cached;

      var result = new OmittedArraySizeExpressionSyntax(SyntaxKind.OmittedArraySizeExpression, omittedArraySizeExpressionToken);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public static InterpolatedStringExpressionSyntax InterpolatedStringExpression(SyntaxToken stringStartToken, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<InterpolatedStringContentSyntax> contents, SyntaxToken stringEndToken)
    {
#if DEBUG
      if (stringStartToken == null)
        throw new ArgumentNullException(nameof(stringStartToken));
      switch (stringStartToken.Kind)
      {
        case SyntaxKind.InterpolatedStringStartToken:
        case SyntaxKind.InterpolatedVerbatimStringStartToken:
          break;
        default:
          throw new ArgumentException(nameof(stringStartToken));
      }
      if (stringEndToken == null)
        throw new ArgumentNullException(nameof(stringEndToken));
      switch (stringEndToken.Kind)
      {
        case SyntaxKind.InterpolatedStringEndToken:
          break;
        default:
          throw new ArgumentException(nameof(stringEndToken));
      }
#endif

      int hash;
      var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.InterpolatedStringExpression, stringStartToken, contents.Node, stringEndToken, out hash);
      if (cached != null) return (InterpolatedStringExpressionSyntax)cached;

      var result = new InterpolatedStringExpressionSyntax(SyntaxKind.InterpolatedStringExpression, stringStartToken, contents.Node, stringEndToken);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public static IsPatternExpressionSyntax IsPatternExpression(ExpressionSyntax expression, SyntaxToken isKeyword, PatternSyntax pattern)
    {
#if DEBUG
      if (expression == null)
        throw new ArgumentNullException(nameof(expression));
      if (isKeyword == null)
        throw new ArgumentNullException(nameof(isKeyword));
      switch (isKeyword.Kind)
      {
        case SyntaxKind.IsKeyword:
          break;
        default:
          throw new ArgumentException(nameof(isKeyword));
      }
      if (pattern == null)
        throw new ArgumentNullException(nameof(pattern));
#endif

      int hash;
      var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.IsPatternExpression, expression, isKeyword, pattern, out hash);
      if (cached != null) return (IsPatternExpressionSyntax)cached;

      var result = new IsPatternExpressionSyntax(SyntaxKind.IsPatternExpression, expression, isKeyword, pattern);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public static ThrowExpressionSyntax ThrowExpression(SyntaxToken throwKeyword, ExpressionSyntax expression)
    {
#if DEBUG
      if (throwKeyword == null)
        throw new ArgumentNullException(nameof(throwKeyword));
      switch (throwKeyword.Kind)
      {
        case SyntaxKind.ThrowKeyword:
          break;
        default:
          throw new ArgumentException(nameof(throwKeyword));
      }
      if (expression == null)
        throw new ArgumentNullException(nameof(expression));
#endif

      int hash;
      var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.ThrowExpression, throwKeyword, expression, out hash);
      if (cached != null) return (ThrowExpressionSyntax)cached;

      var result = new ThrowExpressionSyntax(SyntaxKind.ThrowExpression, throwKeyword, expression);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public static WhenClauseSyntax WhenClause(SyntaxToken whenKeyword, ExpressionSyntax condition)
    {
#if DEBUG
      if (whenKeyword == null)
        throw new ArgumentNullException(nameof(whenKeyword));
      switch (whenKeyword.Kind)
      {
        case SyntaxKind.WhenKeyword:
          break;
        default:
          throw new ArgumentException(nameof(whenKeyword));
      }
      if (condition == null)
        throw new ArgumentNullException(nameof(condition));
#endif

      int hash;
      var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.WhenClause, whenKeyword, condition, out hash);
      if (cached != null) return (WhenClauseSyntax)cached;

      var result = new WhenClauseSyntax(SyntaxKind.WhenClause, whenKeyword, condition);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public static DiscardPatternSyntax DiscardPattern(SyntaxToken underscoreToken)
    {
#if DEBUG
      if (underscoreToken == null)
        throw new ArgumentNullException(nameof(underscoreToken));
      switch (underscoreToken.Kind)
      {
        case SyntaxKind.UnderscoreToken:
          break;
        default:
          throw new ArgumentException(nameof(underscoreToken));
      }
#endif

      int hash;
      var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.DiscardPattern, underscoreToken, out hash);
      if (cached != null) return (DiscardPatternSyntax)cached;

      var result = new DiscardPatternSyntax(SyntaxKind.DiscardPattern, underscoreToken);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public static DeclarationPatternSyntax DeclarationPattern(TypeSyntax type, VariableDesignationSyntax designation)
    {
#if DEBUG
      if (type == null)
        throw new ArgumentNullException(nameof(type));
      if (designation == null)
        throw new ArgumentNullException(nameof(designation));
#endif

      int hash;
      var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.DeclarationPattern, type, designation, out hash);
      if (cached != null) return (DeclarationPatternSyntax)cached;

      var result = new DeclarationPatternSyntax(SyntaxKind.DeclarationPattern, type, designation);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public static VarPatternSyntax VarPattern(SyntaxToken varKeyword, VariableDesignationSyntax designation)
    {
#if DEBUG
      if (varKeyword == null)
        throw new ArgumentNullException(nameof(varKeyword));
      switch (varKeyword.Kind)
      {
        case SyntaxKind.VarKeyword:
          break;
        default:
          throw new ArgumentException(nameof(varKeyword));
      }
      if (designation == null)
        throw new ArgumentNullException(nameof(designation));
#endif

      int hash;
      var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.VarPattern, varKeyword, designation, out hash);
      if (cached != null) return (VarPatternSyntax)cached;

      var result = new VarPatternSyntax(SyntaxKind.VarPattern, varKeyword, designation);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public static RecursivePatternSyntax RecursivePattern(TypeSyntax type, PositionalPatternClauseSyntax positionalPatternClause, PropertyPatternClauseSyntax propertyPatternClause, VariableDesignationSyntax designation)
    {
#if DEBUG
#endif

      return new RecursivePatternSyntax(SyntaxKind.RecursivePattern, type, positionalPatternClause, propertyPatternClause, designation);
    }

    public static PositionalPatternClauseSyntax PositionalPatternClause(SyntaxToken openParenToken, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<SubpatternSyntax> subpatterns, SyntaxToken closeParenToken)
    {
#if DEBUG
      if (openParenToken == null)
        throw new ArgumentNullException(nameof(openParenToken));
      switch (openParenToken.Kind)
      {
        case SyntaxKind.OpenParenToken:
          break;
        default:
          throw new ArgumentException(nameof(openParenToken));
      }
      if (closeParenToken == null)
        throw new ArgumentNullException(nameof(closeParenToken));
      switch (closeParenToken.Kind)
      {
        case SyntaxKind.CloseParenToken:
          break;
        default:
          throw new ArgumentException(nameof(closeParenToken));
      }
#endif

      int hash;
      var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.PositionalPatternClause, openParenToken, subpatterns.Node, closeParenToken, out hash);
      if (cached != null) return (PositionalPatternClauseSyntax)cached;

      var result = new PositionalPatternClauseSyntax(SyntaxKind.PositionalPatternClause, openParenToken, subpatterns.Node, closeParenToken);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public static PropertyPatternClauseSyntax PropertyPatternClause(SyntaxToken openBraceToken, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<SubpatternSyntax> subpatterns, SyntaxToken closeBraceToken)
    {
#if DEBUG
      if (openBraceToken == null)
        throw new ArgumentNullException(nameof(openBraceToken));
      switch (openBraceToken.Kind)
      {
        case SyntaxKind.OpenBraceToken:
          break;
        default:
          throw new ArgumentException(nameof(openBraceToken));
      }
      if (closeBraceToken == null)
        throw new ArgumentNullException(nameof(closeBraceToken));
      switch (closeBraceToken.Kind)
      {
        case SyntaxKind.CloseBraceToken:
          break;
        default:
          throw new ArgumentException(nameof(closeBraceToken));
      }
#endif

      int hash;
      var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.PropertyPatternClause, openBraceToken, subpatterns.Node, closeBraceToken, out hash);
      if (cached != null) return (PropertyPatternClauseSyntax)cached;

      var result = new PropertyPatternClauseSyntax(SyntaxKind.PropertyPatternClause, openBraceToken, subpatterns.Node, closeBraceToken);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public static SubpatternSyntax Subpattern(NameColonSyntax nameColon, PatternSyntax pattern)
    {
#if DEBUG
      if (pattern == null)
        throw new ArgumentNullException(nameof(pattern));
#endif

      int hash;
      var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.Subpattern, nameColon, pattern, out hash);
      if (cached != null) return (SubpatternSyntax)cached;

      var result = new SubpatternSyntax(SyntaxKind.Subpattern, nameColon, pattern);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public static ConstantPatternSyntax ConstantPattern(ExpressionSyntax expression)
    {
#if DEBUG
      if (expression == null)
        throw new ArgumentNullException(nameof(expression));
#endif

      int hash;
      var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.ConstantPattern, expression, out hash);
      if (cached != null) return (ConstantPatternSyntax)cached;

      var result = new ConstantPatternSyntax(SyntaxKind.ConstantPattern, expression);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public static InterpolatedStringTextSyntax InterpolatedStringText(SyntaxToken textToken)
    {
#if DEBUG
      if (textToken == null)
        throw new ArgumentNullException(nameof(textToken));
      switch (textToken.Kind)
      {
        case SyntaxKind.InterpolatedStringTextToken:
          break;
        default:
          throw new ArgumentException(nameof(textToken));
      }
#endif

      int hash;
      var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.InterpolatedStringText, textToken, out hash);
      if (cached != null) return (InterpolatedStringTextSyntax)cached;

      var result = new InterpolatedStringTextSyntax(SyntaxKind.InterpolatedStringText, textToken);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public static InterpolationSyntax Interpolation(SyntaxToken openBraceToken, ExpressionSyntax expression, InterpolationAlignmentClauseSyntax alignmentClause, InterpolationFormatClauseSyntax formatClause, SyntaxToken closeBraceToken)
    {
#if DEBUG
      if (openBraceToken == null)
        throw new ArgumentNullException(nameof(openBraceToken));
      switch (openBraceToken.Kind)
      {
        case SyntaxKind.OpenBraceToken:
          break;
        default:
          throw new ArgumentException(nameof(openBraceToken));
      }
      if (expression == null)
        throw new ArgumentNullException(nameof(expression));
      if (closeBraceToken == null)
        throw new ArgumentNullException(nameof(closeBraceToken));
      switch (closeBraceToken.Kind)
      {
        case SyntaxKind.CloseBraceToken:
          break;
        default:
          throw new ArgumentException(nameof(closeBraceToken));
      }
#endif

      return new InterpolationSyntax(SyntaxKind.Interpolation, openBraceToken, expression, alignmentClause, formatClause, closeBraceToken);
    }

    public static InterpolationAlignmentClauseSyntax InterpolationAlignmentClause(SyntaxToken commaToken, ExpressionSyntax value)
    {
#if DEBUG
      if (commaToken == null)
        throw new ArgumentNullException(nameof(commaToken));
      if (value == null)
        throw new ArgumentNullException(nameof(value));
#endif

      int hash;
      var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.InterpolationAlignmentClause, commaToken, value, out hash);
      if (cached != null) return (InterpolationAlignmentClauseSyntax)cached;

      var result = new InterpolationAlignmentClauseSyntax(SyntaxKind.InterpolationAlignmentClause, commaToken, value);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public static InterpolationFormatClauseSyntax InterpolationFormatClause(SyntaxToken colonToken, SyntaxToken formatStringToken)
    {
#if DEBUG
      if (colonToken == null)
        throw new ArgumentNullException(nameof(colonToken));
      if (formatStringToken == null)
        throw new ArgumentNullException(nameof(formatStringToken));
      switch (formatStringToken.Kind)
      {
        case SyntaxKind.InterpolatedStringTextToken:
          break;
        default:
          throw new ArgumentException(nameof(formatStringToken));
      }
#endif

      int hash;
      var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.InterpolationFormatClause, colonToken, formatStringToken, out hash);
      if (cached != null) return (InterpolationFormatClauseSyntax)cached;

      var result = new InterpolationFormatClauseSyntax(SyntaxKind.InterpolationFormatClause, colonToken, formatStringToken);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public static GlobalStatementSyntax GlobalStatement(Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<AttributeListSyntax> attributeLists, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SyntaxToken> modifiers, StatementSyntax statement)
    {
#if DEBUG
      if (statement == null)
        throw new ArgumentNullException(nameof(statement));
#endif

      int hash;
      var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.GlobalStatement, attributeLists.Node, modifiers.Node, statement, out hash);
      if (cached != null) return (GlobalStatementSyntax)cached;

      var result = new GlobalStatementSyntax(SyntaxKind.GlobalStatement, attributeLists.Node, modifiers.Node, statement);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public static BlockSyntax Block(SyntaxToken openBraceToken, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<StatementSyntax> statements, SyntaxToken closeBraceToken)
    {
#if DEBUG
      if (openBraceToken == null)
        throw new ArgumentNullException(nameof(openBraceToken));
      switch (openBraceToken.Kind)
      {
        case SyntaxKind.OpenBraceToken:
          break;
        default:
          throw new ArgumentException(nameof(openBraceToken));
      }
      if (closeBraceToken == null)
        throw new ArgumentNullException(nameof(closeBraceToken));
      switch (closeBraceToken.Kind)
      {
        case SyntaxKind.CloseBraceToken:
          break;
        default:
          throw new ArgumentException(nameof(closeBraceToken));
      }
#endif

      int hash;
      var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.Block, openBraceToken, statements.Node, closeBraceToken, out hash);
      if (cached != null) return (BlockSyntax)cached;

      var result = new BlockSyntax(SyntaxKind.Block, openBraceToken, statements.Node, closeBraceToken);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public static LocalFunctionStatementSyntax LocalFunctionStatement(Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SyntaxToken> modifiers, TypeSyntax returnType, SyntaxToken identifier, TypeParameterListSyntax typeParameterList, ParameterListSyntax parameterList, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<TypeParameterConstraintClauseSyntax> constraintClauses, BlockSyntax body, ArrowExpressionClauseSyntax expressionBody, SyntaxToken semicolonToken)
    {
#if DEBUG
      if (returnType == null)
        throw new ArgumentNullException(nameof(returnType));
      if (identifier == null)
        throw new ArgumentNullException(nameof(identifier));
      switch (identifier.Kind)
      {
        case SyntaxKind.IdentifierToken:
          break;
        default:
          throw new ArgumentException(nameof(identifier));
      }
      if (parameterList == null)
        throw new ArgumentNullException(nameof(parameterList));
      if (semicolonToken != null)
      {
      switch (semicolonToken.Kind)
      {
        case SyntaxKind.SemicolonToken:
        case SyntaxKind.None:
          break;
        default:
          throw new ArgumentException(nameof(semicolonToken));
      }
      }
#endif

      return new LocalFunctionStatementSyntax(SyntaxKind.LocalFunctionStatement, modifiers.Node, returnType, identifier, typeParameterList, parameterList, constraintClauses.Node, body, expressionBody, semicolonToken);
    }

    public static LocalDeclarationStatementSyntax LocalDeclarationStatement(SyntaxToken awaitKeyword, SyntaxToken usingKeyword, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SyntaxToken> modifiers, VariableDeclarationSyntax declaration, SyntaxToken semicolonToken)
    {
#if DEBUG
      if (awaitKeyword != null)
      {
      switch (awaitKeyword.Kind)
      {
        case SyntaxKind.AwaitKeyword:
        case SyntaxKind.None:
          break;
        default:
          throw new ArgumentException(nameof(awaitKeyword));
      }
      }
      if (usingKeyword != null)
      {
      switch (usingKeyword.Kind)
      {
        case SyntaxKind.UsingKeyword:
        case SyntaxKind.None:
          break;
        default:
          throw new ArgumentException(nameof(usingKeyword));
      }
      }
      if (declaration == null)
        throw new ArgumentNullException(nameof(declaration));
      if (semicolonToken == null)
        throw new ArgumentNullException(nameof(semicolonToken));
      switch (semicolonToken.Kind)
      {
        case SyntaxKind.SemicolonToken:
          break;
        default:
          throw new ArgumentException(nameof(semicolonToken));
      }
#endif

      return new LocalDeclarationStatementSyntax(SyntaxKind.LocalDeclarationStatement, awaitKeyword, usingKeyword, modifiers.Node, declaration, semicolonToken);
    }

    public static VariableDeclarationSyntax VariableDeclaration(TypeSyntax type, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<VariableDeclaratorSyntax> variables)
    {
#if DEBUG
      if (type == null)
        throw new ArgumentNullException(nameof(type));
#endif

      int hash;
      var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.VariableDeclaration, type, variables.Node, out hash);
      if (cached != null) return (VariableDeclarationSyntax)cached;

      var result = new VariableDeclarationSyntax(SyntaxKind.VariableDeclaration, type, variables.Node);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public static VariableDeclaratorSyntax VariableDeclarator(SyntaxToken identifier, BracketedArgumentListSyntax argumentList, EqualsValueClauseSyntax initializer)
    {
#if DEBUG
      if (identifier == null)
        throw new ArgumentNullException(nameof(identifier));
      switch (identifier.Kind)
      {
        case SyntaxKind.IdentifierToken:
          break;
        default:
          throw new ArgumentException(nameof(identifier));
      }
#endif

      int hash;
      var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.VariableDeclarator, identifier, argumentList, initializer, out hash);
      if (cached != null) return (VariableDeclaratorSyntax)cached;

      var result = new VariableDeclaratorSyntax(SyntaxKind.VariableDeclarator, identifier, argumentList, initializer);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public static EqualsValueClauseSyntax EqualsValueClause(SyntaxToken equalsToken, ExpressionSyntax value)
    {
#if DEBUG
      if (equalsToken == null)
        throw new ArgumentNullException(nameof(equalsToken));
      switch (equalsToken.Kind)
      {
        case SyntaxKind.EqualsToken:
          break;
        default:
          throw new ArgumentException(nameof(equalsToken));
      }
      if (value == null)
        throw new ArgumentNullException(nameof(value));
#endif

      int hash;
      var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.EqualsValueClause, equalsToken, value, out hash);
      if (cached != null) return (EqualsValueClauseSyntax)cached;

      var result = new EqualsValueClauseSyntax(SyntaxKind.EqualsValueClause, equalsToken, value);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public static SingleVariableDesignationSyntax SingleVariableDesignation(SyntaxToken identifier)
    {
#if DEBUG
      if (identifier == null)
        throw new ArgumentNullException(nameof(identifier));
      switch (identifier.Kind)
      {
        case SyntaxKind.IdentifierToken:
          break;
        default:
          throw new ArgumentException(nameof(identifier));
      }
#endif

      int hash;
      var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.SingleVariableDesignation, identifier, out hash);
      if (cached != null) return (SingleVariableDesignationSyntax)cached;

      var result = new SingleVariableDesignationSyntax(SyntaxKind.SingleVariableDesignation, identifier);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public static DiscardDesignationSyntax DiscardDesignation(SyntaxToken underscoreToken)
    {
#if DEBUG
      if (underscoreToken == null)
        throw new ArgumentNullException(nameof(underscoreToken));
      switch (underscoreToken.Kind)
      {
        case SyntaxKind.UnderscoreToken:
          break;
        default:
          throw new ArgumentException(nameof(underscoreToken));
      }
#endif

      int hash;
      var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.DiscardDesignation, underscoreToken, out hash);
      if (cached != null) return (DiscardDesignationSyntax)cached;

      var result = new DiscardDesignationSyntax(SyntaxKind.DiscardDesignation, underscoreToken);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public static ParenthesizedVariableDesignationSyntax ParenthesizedVariableDesignation(SyntaxToken openParenToken, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<VariableDesignationSyntax> variables, SyntaxToken closeParenToken)
    {
#if DEBUG
      if (openParenToken == null)
        throw new ArgumentNullException(nameof(openParenToken));
      switch (openParenToken.Kind)
      {
        case SyntaxKind.OpenParenToken:
          break;
        default:
          throw new ArgumentException(nameof(openParenToken));
      }
      if (closeParenToken == null)
        throw new ArgumentNullException(nameof(closeParenToken));
      switch (closeParenToken.Kind)
      {
        case SyntaxKind.CloseParenToken:
          break;
        default:
          throw new ArgumentException(nameof(closeParenToken));
      }
#endif

      int hash;
      var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.ParenthesizedVariableDesignation, openParenToken, variables.Node, closeParenToken, out hash);
      if (cached != null) return (ParenthesizedVariableDesignationSyntax)cached;

      var result = new ParenthesizedVariableDesignationSyntax(SyntaxKind.ParenthesizedVariableDesignation, openParenToken, variables.Node, closeParenToken);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public static ExpressionStatementSyntax ExpressionStatement(ExpressionSyntax expression, SyntaxToken semicolonToken)
    {
#if DEBUG
      if (expression == null)
        throw new ArgumentNullException(nameof(expression));
      if (semicolonToken == null)
        throw new ArgumentNullException(nameof(semicolonToken));
      switch (semicolonToken.Kind)
      {
        case SyntaxKind.SemicolonToken:
          break;
        default:
          throw new ArgumentException(nameof(semicolonToken));
      }
#endif

      int hash;
      var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.ExpressionStatement, expression, semicolonToken, out hash);
      if (cached != null) return (ExpressionStatementSyntax)cached;

      var result = new ExpressionStatementSyntax(SyntaxKind.ExpressionStatement, expression, semicolonToken);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public static EmptyStatementSyntax EmptyStatement(SyntaxToken semicolonToken)
    {
#if DEBUG
      if (semicolonToken == null)
        throw new ArgumentNullException(nameof(semicolonToken));
      switch (semicolonToken.Kind)
      {
        case SyntaxKind.SemicolonToken:
          break;
        default:
          throw new ArgumentException(nameof(semicolonToken));
      }
#endif

      int hash;
      var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.EmptyStatement, semicolonToken, out hash);
      if (cached != null) return (EmptyStatementSyntax)cached;

      var result = new EmptyStatementSyntax(SyntaxKind.EmptyStatement, semicolonToken);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public static LabeledStatementSyntax LabeledStatement(SyntaxToken identifier, SyntaxToken colonToken, StatementSyntax statement)
    {
#if DEBUG
      if (identifier == null)
        throw new ArgumentNullException(nameof(identifier));
      switch (identifier.Kind)
      {
        case SyntaxKind.IdentifierToken:
          break;
        default:
          throw new ArgumentException(nameof(identifier));
      }
      if (colonToken == null)
        throw new ArgumentNullException(nameof(colonToken));
      switch (colonToken.Kind)
      {
        case SyntaxKind.ColonToken:
          break;
        default:
          throw new ArgumentException(nameof(colonToken));
      }
      if (statement == null)
        throw new ArgumentNullException(nameof(statement));
#endif

      int hash;
      var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.LabeledStatement, identifier, colonToken, statement, out hash);
      if (cached != null) return (LabeledStatementSyntax)cached;

      var result = new LabeledStatementSyntax(SyntaxKind.LabeledStatement, identifier, colonToken, statement);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public static GotoStatementSyntax GotoStatement(SyntaxKind kind, SyntaxToken gotoKeyword, SyntaxToken caseOrDefaultKeyword, ExpressionSyntax expression, SyntaxToken semicolonToken)
    {
      switch (kind)
      {
        case SyntaxKind.GotoStatement:
        case SyntaxKind.GotoCaseStatement:
        case SyntaxKind.GotoDefaultStatement:
          break;
        default:
          throw new ArgumentException(nameof(kind));
      }
#if DEBUG
      if (gotoKeyword == null)
        throw new ArgumentNullException(nameof(gotoKeyword));
      switch (gotoKeyword.Kind)
      {
        case SyntaxKind.GotoKeyword:
          break;
        default:
          throw new ArgumentException(nameof(gotoKeyword));
      }
      if (caseOrDefaultKeyword != null)
      {
      switch (caseOrDefaultKeyword.Kind)
      {
        case SyntaxKind.CaseKeyword:
        case SyntaxKind.DefaultKeyword:
        case SyntaxKind.None:
          break;
        default:
          throw new ArgumentException(nameof(caseOrDefaultKeyword));
      }
      }
      if (semicolonToken == null)
        throw new ArgumentNullException(nameof(semicolonToken));
      switch (semicolonToken.Kind)
      {
        case SyntaxKind.SemicolonToken:
          break;
        default:
          throw new ArgumentException(nameof(semicolonToken));
      }
#endif

      return new GotoStatementSyntax(kind, gotoKeyword, caseOrDefaultKeyword, expression, semicolonToken);
    }

    public static BreakStatementSyntax BreakStatement(SyntaxToken breakKeyword, SyntaxToken semicolonToken)
    {
#if DEBUG
      if (breakKeyword == null)
        throw new ArgumentNullException(nameof(breakKeyword));
      switch (breakKeyword.Kind)
      {
        case SyntaxKind.BreakKeyword:
          break;
        default:
          throw new ArgumentException(nameof(breakKeyword));
      }
      if (semicolonToken == null)
        throw new ArgumentNullException(nameof(semicolonToken));
      switch (semicolonToken.Kind)
      {
        case SyntaxKind.SemicolonToken:
          break;
        default:
          throw new ArgumentException(nameof(semicolonToken));
      }
#endif

      int hash;
      var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.BreakStatement, breakKeyword, semicolonToken, out hash);
      if (cached != null) return (BreakStatementSyntax)cached;

      var result = new BreakStatementSyntax(SyntaxKind.BreakStatement, breakKeyword, semicolonToken);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public static ContinueStatementSyntax ContinueStatement(SyntaxToken continueKeyword, SyntaxToken semicolonToken)
    {
#if DEBUG
      if (continueKeyword == null)
        throw new ArgumentNullException(nameof(continueKeyword));
      switch (continueKeyword.Kind)
      {
        case SyntaxKind.ContinueKeyword:
          break;
        default:
          throw new ArgumentException(nameof(continueKeyword));
      }
      if (semicolonToken == null)
        throw new ArgumentNullException(nameof(semicolonToken));
      switch (semicolonToken.Kind)
      {
        case SyntaxKind.SemicolonToken:
          break;
        default:
          throw new ArgumentException(nameof(semicolonToken));
      }
#endif

      int hash;
      var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.ContinueStatement, continueKeyword, semicolonToken, out hash);
      if (cached != null) return (ContinueStatementSyntax)cached;

      var result = new ContinueStatementSyntax(SyntaxKind.ContinueStatement, continueKeyword, semicolonToken);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public static ReturnStatementSyntax ReturnStatement(SyntaxToken returnKeyword, ExpressionSyntax expression, SyntaxToken semicolonToken)
    {
#if DEBUG
      if (returnKeyword == null)
        throw new ArgumentNullException(nameof(returnKeyword));
      switch (returnKeyword.Kind)
      {
        case SyntaxKind.ReturnKeyword:
          break;
        default:
          throw new ArgumentException(nameof(returnKeyword));
      }
      if (semicolonToken == null)
        throw new ArgumentNullException(nameof(semicolonToken));
      switch (semicolonToken.Kind)
      {
        case SyntaxKind.SemicolonToken:
          break;
        default:
          throw new ArgumentException(nameof(semicolonToken));
      }
#endif

      int hash;
      var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.ReturnStatement, returnKeyword, expression, semicolonToken, out hash);
      if (cached != null) return (ReturnStatementSyntax)cached;

      var result = new ReturnStatementSyntax(SyntaxKind.ReturnStatement, returnKeyword, expression, semicolonToken);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public static ThrowStatementSyntax ThrowStatement(SyntaxToken throwKeyword, ExpressionSyntax expression, SyntaxToken semicolonToken)
    {
#if DEBUG
      if (throwKeyword == null)
        throw new ArgumentNullException(nameof(throwKeyword));
      switch (throwKeyword.Kind)
      {
        case SyntaxKind.ThrowKeyword:
          break;
        default:
          throw new ArgumentException(nameof(throwKeyword));
      }
      if (semicolonToken == null)
        throw new ArgumentNullException(nameof(semicolonToken));
      switch (semicolonToken.Kind)
      {
        case SyntaxKind.SemicolonToken:
          break;
        default:
          throw new ArgumentException(nameof(semicolonToken));
      }
#endif

      int hash;
      var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.ThrowStatement, throwKeyword, expression, semicolonToken, out hash);
      if (cached != null) return (ThrowStatementSyntax)cached;

      var result = new ThrowStatementSyntax(SyntaxKind.ThrowStatement, throwKeyword, expression, semicolonToken);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public static YieldStatementSyntax YieldStatement(SyntaxKind kind, SyntaxToken yieldKeyword, SyntaxToken returnOrBreakKeyword, ExpressionSyntax expression, SyntaxToken semicolonToken)
    {
      switch (kind)
      {
        case SyntaxKind.YieldReturnStatement:
        case SyntaxKind.YieldBreakStatement:
          break;
        default:
          throw new ArgumentException(nameof(kind));
      }
#if DEBUG
      if (yieldKeyword == null)
        throw new ArgumentNullException(nameof(yieldKeyword));
      switch (yieldKeyword.Kind)
      {
        case SyntaxKind.YieldKeyword:
          break;
        default:
          throw new ArgumentException(nameof(yieldKeyword));
      }
      if (returnOrBreakKeyword == null)
        throw new ArgumentNullException(nameof(returnOrBreakKeyword));
      switch (returnOrBreakKeyword.Kind)
      {
        case SyntaxKind.ReturnKeyword:
        case SyntaxKind.BreakKeyword:
          break;
        default:
          throw new ArgumentException(nameof(returnOrBreakKeyword));
      }
      if (semicolonToken == null)
        throw new ArgumentNullException(nameof(semicolonToken));
      switch (semicolonToken.Kind)
      {
        case SyntaxKind.SemicolonToken:
          break;
        default:
          throw new ArgumentException(nameof(semicolonToken));
      }
#endif

      return new YieldStatementSyntax(kind, yieldKeyword, returnOrBreakKeyword, expression, semicolonToken);
    }

    public static WhileStatementSyntax WhileStatement(SyntaxToken whileKeyword, SyntaxToken openParenToken, ExpressionSyntax condition, SyntaxToken closeParenToken, StatementSyntax statement)
    {
#if DEBUG
      if (whileKeyword == null)
        throw new ArgumentNullException(nameof(whileKeyword));
      switch (whileKeyword.Kind)
      {
        case SyntaxKind.WhileKeyword:
          break;
        default:
          throw new ArgumentException(nameof(whileKeyword));
      }
      if (openParenToken == null)
        throw new ArgumentNullException(nameof(openParenToken));
      switch (openParenToken.Kind)
      {
        case SyntaxKind.OpenParenToken:
          break;
        default:
          throw new ArgumentException(nameof(openParenToken));
      }
      if (condition == null)
        throw new ArgumentNullException(nameof(condition));
      if (closeParenToken == null)
        throw new ArgumentNullException(nameof(closeParenToken));
      switch (closeParenToken.Kind)
      {
        case SyntaxKind.CloseParenToken:
          break;
        default:
          throw new ArgumentException(nameof(closeParenToken));
      }
      if (statement == null)
        throw new ArgumentNullException(nameof(statement));
#endif

      return new WhileStatementSyntax(SyntaxKind.WhileStatement, whileKeyword, openParenToken, condition, closeParenToken, statement);
    }

    public static DoStatementSyntax DoStatement(SyntaxToken doKeyword, StatementSyntax statement, SyntaxToken whileKeyword, SyntaxToken openParenToken, ExpressionSyntax condition, SyntaxToken closeParenToken, SyntaxToken semicolonToken)
    {
#if DEBUG
      if (doKeyword == null)
        throw new ArgumentNullException(nameof(doKeyword));
      switch (doKeyword.Kind)
      {
        case SyntaxKind.DoKeyword:
          break;
        default:
          throw new ArgumentException(nameof(doKeyword));
      }
      if (statement == null)
        throw new ArgumentNullException(nameof(statement));
      if (whileKeyword == null)
        throw new ArgumentNullException(nameof(whileKeyword));
      switch (whileKeyword.Kind)
      {
        case SyntaxKind.WhileKeyword:
          break;
        default:
          throw new ArgumentException(nameof(whileKeyword));
      }
      if (openParenToken == null)
        throw new ArgumentNullException(nameof(openParenToken));
      switch (openParenToken.Kind)
      {
        case SyntaxKind.OpenParenToken:
          break;
        default:
          throw new ArgumentException(nameof(openParenToken));
      }
      if (condition == null)
        throw new ArgumentNullException(nameof(condition));
      if (closeParenToken == null)
        throw new ArgumentNullException(nameof(closeParenToken));
      switch (closeParenToken.Kind)
      {
        case SyntaxKind.CloseParenToken:
          break;
        default:
          throw new ArgumentException(nameof(closeParenToken));
      }
      if (semicolonToken == null)
        throw new ArgumentNullException(nameof(semicolonToken));
      switch (semicolonToken.Kind)
      {
        case SyntaxKind.SemicolonToken:
          break;
        default:
          throw new ArgumentException(nameof(semicolonToken));
      }
#endif

      return new DoStatementSyntax(SyntaxKind.DoStatement, doKeyword, statement, whileKeyword, openParenToken, condition, closeParenToken, semicolonToken);
    }

    public static ForStatementSyntax ForStatement(SyntaxToken forKeyword, SyntaxToken openParenToken, VariableDeclarationSyntax declaration, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<ExpressionSyntax> initializers, SyntaxToken firstSemicolonToken, ExpressionSyntax condition, SyntaxToken secondSemicolonToken, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<ExpressionSyntax> incrementors, SyntaxToken closeParenToken, StatementSyntax statement)
    {
#if DEBUG
      if (forKeyword == null)
        throw new ArgumentNullException(nameof(forKeyword));
      switch (forKeyword.Kind)
      {
        case SyntaxKind.ForKeyword:
          break;
        default:
          throw new ArgumentException(nameof(forKeyword));
      }
      if (openParenToken == null)
        throw new ArgumentNullException(nameof(openParenToken));
      switch (openParenToken.Kind)
      {
        case SyntaxKind.OpenParenToken:
          break;
        default:
          throw new ArgumentException(nameof(openParenToken));
      }
      if (firstSemicolonToken == null)
        throw new ArgumentNullException(nameof(firstSemicolonToken));
      switch (firstSemicolonToken.Kind)
      {
        case SyntaxKind.SemicolonToken:
          break;
        default:
          throw new ArgumentException(nameof(firstSemicolonToken));
      }
      if (secondSemicolonToken == null)
        throw new ArgumentNullException(nameof(secondSemicolonToken));
      switch (secondSemicolonToken.Kind)
      {
        case SyntaxKind.SemicolonToken:
          break;
        default:
          throw new ArgumentException(nameof(secondSemicolonToken));
      }
      if (closeParenToken == null)
        throw new ArgumentNullException(nameof(closeParenToken));
      switch (closeParenToken.Kind)
      {
        case SyntaxKind.CloseParenToken:
          break;
        default:
          throw new ArgumentException(nameof(closeParenToken));
      }
      if (statement == null)
        throw new ArgumentNullException(nameof(statement));
#endif

      return new ForStatementSyntax(SyntaxKind.ForStatement, forKeyword, openParenToken, declaration, initializers.Node, firstSemicolonToken, condition, secondSemicolonToken, incrementors.Node, closeParenToken, statement);
    }

    public static ForEachStatementSyntax ForEachStatement(SyntaxToken awaitKeyword, SyntaxToken forEachKeyword, SyntaxToken openParenToken, TypeSyntax type, SyntaxToken identifier, SyntaxToken inKeyword, ExpressionSyntax expression, SyntaxToken closeParenToken, StatementSyntax statement)
    {
#if DEBUG
      if (awaitKeyword != null)
      {
      switch (awaitKeyword.Kind)
      {
        case SyntaxKind.AwaitKeyword:
        case SyntaxKind.None:
          break;
        default:
          throw new ArgumentException(nameof(awaitKeyword));
      }
      }
      if (forEachKeyword == null)
        throw new ArgumentNullException(nameof(forEachKeyword));
      switch (forEachKeyword.Kind)
      {
        case SyntaxKind.ForEachKeyword:
          break;
        default:
          throw new ArgumentException(nameof(forEachKeyword));
      }
      if (openParenToken == null)
        throw new ArgumentNullException(nameof(openParenToken));
      switch (openParenToken.Kind)
      {
        case SyntaxKind.OpenParenToken:
          break;
        default:
          throw new ArgumentException(nameof(openParenToken));
      }
      if (type == null)
        throw new ArgumentNullException(nameof(type));
      if (identifier == null)
        throw new ArgumentNullException(nameof(identifier));
      switch (identifier.Kind)
      {
        case SyntaxKind.IdentifierToken:
          break;
        default:
          throw new ArgumentException(nameof(identifier));
      }
      if (inKeyword == null)
        throw new ArgumentNullException(nameof(inKeyword));
      switch (inKeyword.Kind)
      {
        case SyntaxKind.InKeyword:
          break;
        default:
          throw new ArgumentException(nameof(inKeyword));
      }
      if (expression == null)
        throw new ArgumentNullException(nameof(expression));
      if (closeParenToken == null)
        throw new ArgumentNullException(nameof(closeParenToken));
      switch (closeParenToken.Kind)
      {
        case SyntaxKind.CloseParenToken:
          break;
        default:
          throw new ArgumentException(nameof(closeParenToken));
      }
      if (statement == null)
        throw new ArgumentNullException(nameof(statement));
#endif

      return new ForEachStatementSyntax(SyntaxKind.ForEachStatement, awaitKeyword, forEachKeyword, openParenToken, type, identifier, inKeyword, expression, closeParenToken, statement);
    }

    public static ForEachVariableStatementSyntax ForEachVariableStatement(SyntaxToken awaitKeyword, SyntaxToken forEachKeyword, SyntaxToken openParenToken, ExpressionSyntax variable, SyntaxToken inKeyword, ExpressionSyntax expression, SyntaxToken closeParenToken, StatementSyntax statement)
    {
#if DEBUG
      if (awaitKeyword != null)
      {
      switch (awaitKeyword.Kind)
      {
        case SyntaxKind.AwaitKeyword:
        case SyntaxKind.None:
          break;
        default:
          throw new ArgumentException(nameof(awaitKeyword));
      }
      }
      if (forEachKeyword == null)
        throw new ArgumentNullException(nameof(forEachKeyword));
      switch (forEachKeyword.Kind)
      {
        case SyntaxKind.ForEachKeyword:
          break;
        default:
          throw new ArgumentException(nameof(forEachKeyword));
      }
      if (openParenToken == null)
        throw new ArgumentNullException(nameof(openParenToken));
      switch (openParenToken.Kind)
      {
        case SyntaxKind.OpenParenToken:
          break;
        default:
          throw new ArgumentException(nameof(openParenToken));
      }
      if (variable == null)
        throw new ArgumentNullException(nameof(variable));
      if (inKeyword == null)
        throw new ArgumentNullException(nameof(inKeyword));
      switch (inKeyword.Kind)
      {
        case SyntaxKind.InKeyword:
          break;
        default:
          throw new ArgumentException(nameof(inKeyword));
      }
      if (expression == null)
        throw new ArgumentNullException(nameof(expression));
      if (closeParenToken == null)
        throw new ArgumentNullException(nameof(closeParenToken));
      switch (closeParenToken.Kind)
      {
        case SyntaxKind.CloseParenToken:
          break;
        default:
          throw new ArgumentException(nameof(closeParenToken));
      }
      if (statement == null)
        throw new ArgumentNullException(nameof(statement));
#endif

      return new ForEachVariableStatementSyntax(SyntaxKind.ForEachVariableStatement, awaitKeyword, forEachKeyword, openParenToken, variable, inKeyword, expression, closeParenToken, statement);
    }

    public static UsingStatementSyntax UsingStatement(SyntaxToken awaitKeyword, SyntaxToken usingKeyword, SyntaxToken openParenToken, VariableDeclarationSyntax declaration, ExpressionSyntax expression, SyntaxToken closeParenToken, StatementSyntax statement)
    {
#if DEBUG
      if (awaitKeyword != null)
      {
      switch (awaitKeyword.Kind)
      {
        case SyntaxKind.AwaitKeyword:
        case SyntaxKind.None:
          break;
        default:
          throw new ArgumentException(nameof(awaitKeyword));
      }
      }
      if (usingKeyword == null)
        throw new ArgumentNullException(nameof(usingKeyword));
      switch (usingKeyword.Kind)
      {
        case SyntaxKind.UsingKeyword:
          break;
        default:
          throw new ArgumentException(nameof(usingKeyword));
      }
      if (openParenToken == null)
        throw new ArgumentNullException(nameof(openParenToken));
      switch (openParenToken.Kind)
      {
        case SyntaxKind.OpenParenToken:
          break;
        default:
          throw new ArgumentException(nameof(openParenToken));
      }
      if (closeParenToken == null)
        throw new ArgumentNullException(nameof(closeParenToken));
      switch (closeParenToken.Kind)
      {
        case SyntaxKind.CloseParenToken:
          break;
        default:
          throw new ArgumentException(nameof(closeParenToken));
      }
      if (statement == null)
        throw new ArgumentNullException(nameof(statement));
#endif

      return new UsingStatementSyntax(SyntaxKind.UsingStatement, awaitKeyword, usingKeyword, openParenToken, declaration, expression, closeParenToken, statement);
    }

    public static FixedStatementSyntax FixedStatement(SyntaxToken fixedKeyword, SyntaxToken openParenToken, VariableDeclarationSyntax declaration, SyntaxToken closeParenToken, StatementSyntax statement)
    {
#if DEBUG
      if (fixedKeyword == null)
        throw new ArgumentNullException(nameof(fixedKeyword));
      switch (fixedKeyword.Kind)
      {
        case SyntaxKind.FixedKeyword:
          break;
        default:
          throw new ArgumentException(nameof(fixedKeyword));
      }
      if (openParenToken == null)
        throw new ArgumentNullException(nameof(openParenToken));
      switch (openParenToken.Kind)
      {
        case SyntaxKind.OpenParenToken:
          break;
        default:
          throw new ArgumentException(nameof(openParenToken));
      }
      if (declaration == null)
        throw new ArgumentNullException(nameof(declaration));
      if (closeParenToken == null)
        throw new ArgumentNullException(nameof(closeParenToken));
      switch (closeParenToken.Kind)
      {
        case SyntaxKind.CloseParenToken:
          break;
        default:
          throw new ArgumentException(nameof(closeParenToken));
      }
      if (statement == null)
        throw new ArgumentNullException(nameof(statement));
#endif

      return new FixedStatementSyntax(SyntaxKind.FixedStatement, fixedKeyword, openParenToken, declaration, closeParenToken, statement);
    }

    public static CheckedStatementSyntax CheckedStatement(SyntaxKind kind, SyntaxToken keyword, BlockSyntax block)
    {
      switch (kind)
      {
        case SyntaxKind.CheckedStatement:
        case SyntaxKind.UncheckedStatement:
          break;
        default:
          throw new ArgumentException(nameof(kind));
      }
#if DEBUG
      if (keyword == null)
        throw new ArgumentNullException(nameof(keyword));
      switch (keyword.Kind)
      {
        case SyntaxKind.CheckedKeyword:
        case SyntaxKind.UncheckedKeyword:
          break;
        default:
          throw new ArgumentException(nameof(keyword));
      }
      if (block == null)
        throw new ArgumentNullException(nameof(block));
#endif

      int hash;
      var cached = SyntaxNodeCache.TryGetNode((int)kind, keyword, block, out hash);
      if (cached != null) return (CheckedStatementSyntax)cached;

      var result = new CheckedStatementSyntax(kind, keyword, block);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public static UnsafeStatementSyntax UnsafeStatement(SyntaxToken unsafeKeyword, BlockSyntax block)
    {
#if DEBUG
      if (unsafeKeyword == null)
        throw new ArgumentNullException(nameof(unsafeKeyword));
      switch (unsafeKeyword.Kind)
      {
        case SyntaxKind.UnsafeKeyword:
          break;
        default:
          throw new ArgumentException(nameof(unsafeKeyword));
      }
      if (block == null)
        throw new ArgumentNullException(nameof(block));
#endif

      int hash;
      var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.UnsafeStatement, unsafeKeyword, block, out hash);
      if (cached != null) return (UnsafeStatementSyntax)cached;

      var result = new UnsafeStatementSyntax(SyntaxKind.UnsafeStatement, unsafeKeyword, block);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public static LockStatementSyntax LockStatement(SyntaxToken lockKeyword, SyntaxToken openParenToken, ExpressionSyntax expression, SyntaxToken closeParenToken, StatementSyntax statement)
    {
#if DEBUG
      if (lockKeyword == null)
        throw new ArgumentNullException(nameof(lockKeyword));
      switch (lockKeyword.Kind)
      {
        case SyntaxKind.LockKeyword:
          break;
        default:
          throw new ArgumentException(nameof(lockKeyword));
      }
      if (openParenToken == null)
        throw new ArgumentNullException(nameof(openParenToken));
      switch (openParenToken.Kind)
      {
        case SyntaxKind.OpenParenToken:
          break;
        default:
          throw new ArgumentException(nameof(openParenToken));
      }
      if (expression == null)
        throw new ArgumentNullException(nameof(expression));
      if (closeParenToken == null)
        throw new ArgumentNullException(nameof(closeParenToken));
      switch (closeParenToken.Kind)
      {
        case SyntaxKind.CloseParenToken:
          break;
        default:
          throw new ArgumentException(nameof(closeParenToken));
      }
      if (statement == null)
        throw new ArgumentNullException(nameof(statement));
#endif

      return new LockStatementSyntax(SyntaxKind.LockStatement, lockKeyword, openParenToken, expression, closeParenToken, statement);
    }

    public static IfStatementSyntax IfStatement(SyntaxToken ifKeyword, SyntaxToken openParenToken, ExpressionSyntax condition, SyntaxToken closeParenToken, StatementSyntax statement, ElseClauseSyntax @else)
    {
#if DEBUG
      if (ifKeyword == null)
        throw new ArgumentNullException(nameof(ifKeyword));
      switch (ifKeyword.Kind)
      {
        case SyntaxKind.IfKeyword:
          break;
        default:
          throw new ArgumentException(nameof(ifKeyword));
      }
      if (openParenToken == null)
        throw new ArgumentNullException(nameof(openParenToken));
      switch (openParenToken.Kind)
      {
        case SyntaxKind.OpenParenToken:
          break;
        default:
          throw new ArgumentException(nameof(openParenToken));
      }
      if (condition == null)
        throw new ArgumentNullException(nameof(condition));
      if (closeParenToken == null)
        throw new ArgumentNullException(nameof(closeParenToken));
      switch (closeParenToken.Kind)
      {
        case SyntaxKind.CloseParenToken:
          break;
        default:
          throw new ArgumentException(nameof(closeParenToken));
      }
      if (statement == null)
        throw new ArgumentNullException(nameof(statement));
#endif

      return new IfStatementSyntax(SyntaxKind.IfStatement, ifKeyword, openParenToken, condition, closeParenToken, statement, @else);
    }

    public static ElseClauseSyntax ElseClause(SyntaxToken elseKeyword, StatementSyntax statement)
    {
#if DEBUG
      if (elseKeyword == null)
        throw new ArgumentNullException(nameof(elseKeyword));
      switch (elseKeyword.Kind)
      {
        case SyntaxKind.ElseKeyword:
          break;
        default:
          throw new ArgumentException(nameof(elseKeyword));
      }
      if (statement == null)
        throw new ArgumentNullException(nameof(statement));
#endif

      int hash;
      var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.ElseClause, elseKeyword, statement, out hash);
      if (cached != null) return (ElseClauseSyntax)cached;

      var result = new ElseClauseSyntax(SyntaxKind.ElseClause, elseKeyword, statement);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public static SwitchStatementSyntax SwitchStatement(SyntaxToken switchKeyword, SyntaxToken openParenToken, ExpressionSyntax expression, SyntaxToken closeParenToken, SyntaxToken openBraceToken, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SwitchSectionSyntax> sections, SyntaxToken closeBraceToken)
    {
#if DEBUG
      if (switchKeyword == null)
        throw new ArgumentNullException(nameof(switchKeyword));
      switch (switchKeyword.Kind)
      {
        case SyntaxKind.SwitchKeyword:
          break;
        default:
          throw new ArgumentException(nameof(switchKeyword));
      }
      if (openParenToken != null)
      {
      switch (openParenToken.Kind)
      {
        case SyntaxKind.OpenParenToken:
        case SyntaxKind.None:
          break;
        default:
          throw new ArgumentException(nameof(openParenToken));
      }
      }
      if (expression == null)
        throw new ArgumentNullException(nameof(expression));
      if (closeParenToken != null)
      {
      switch (closeParenToken.Kind)
      {
        case SyntaxKind.CloseParenToken:
        case SyntaxKind.None:
          break;
        default:
          throw new ArgumentException(nameof(closeParenToken));
      }
      }
      if (openBraceToken == null)
        throw new ArgumentNullException(nameof(openBraceToken));
      switch (openBraceToken.Kind)
      {
        case SyntaxKind.OpenBraceToken:
          break;
        default:
          throw new ArgumentException(nameof(openBraceToken));
      }
      if (closeBraceToken == null)
        throw new ArgumentNullException(nameof(closeBraceToken));
      switch (closeBraceToken.Kind)
      {
        case SyntaxKind.CloseBraceToken:
          break;
        default:
          throw new ArgumentException(nameof(closeBraceToken));
      }
#endif

      return new SwitchStatementSyntax(SyntaxKind.SwitchStatement, switchKeyword, openParenToken, expression, closeParenToken, openBraceToken, sections.Node, closeBraceToken);
    }

    public static SwitchSectionSyntax SwitchSection(Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SwitchLabelSyntax> labels, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<StatementSyntax> statements)
    {
#if DEBUG
#endif

      int hash;
      var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.SwitchSection, labels.Node, statements.Node, out hash);
      if (cached != null) return (SwitchSectionSyntax)cached;

      var result = new SwitchSectionSyntax(SyntaxKind.SwitchSection, labels.Node, statements.Node);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public static CasePatternSwitchLabelSyntax CasePatternSwitchLabel(SyntaxToken keyword, PatternSyntax pattern, WhenClauseSyntax whenClause, SyntaxToken colonToken)
    {
#if DEBUG
      if (keyword == null)
        throw new ArgumentNullException(nameof(keyword));
      switch (keyword.Kind)
      {
        case SyntaxKind.CaseKeyword:
          break;
        default:
          throw new ArgumentException(nameof(keyword));
      }
      if (pattern == null)
        throw new ArgumentNullException(nameof(pattern));
      if (colonToken == null)
        throw new ArgumentNullException(nameof(colonToken));
#endif

      return new CasePatternSwitchLabelSyntax(SyntaxKind.CasePatternSwitchLabel, keyword, pattern, whenClause, colonToken);
    }

    public static CaseSwitchLabelSyntax CaseSwitchLabel(SyntaxToken keyword, ExpressionSyntax value, SyntaxToken colonToken)
    {
#if DEBUG
      if (keyword == null)
        throw new ArgumentNullException(nameof(keyword));
      switch (keyword.Kind)
      {
        case SyntaxKind.CaseKeyword:
          break;
        default:
          throw new ArgumentException(nameof(keyword));
      }
      if (value == null)
        throw new ArgumentNullException(nameof(value));
      if (colonToken == null)
        throw new ArgumentNullException(nameof(colonToken));
#endif

      int hash;
      var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.CaseSwitchLabel, keyword, value, colonToken, out hash);
      if (cached != null) return (CaseSwitchLabelSyntax)cached;

      var result = new CaseSwitchLabelSyntax(SyntaxKind.CaseSwitchLabel, keyword, value, colonToken);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public static DefaultSwitchLabelSyntax DefaultSwitchLabel(SyntaxToken keyword, SyntaxToken colonToken)
    {
#if DEBUG
      if (keyword == null)
        throw new ArgumentNullException(nameof(keyword));
      switch (keyword.Kind)
      {
        case SyntaxKind.DefaultKeyword:
          break;
        default:
          throw new ArgumentException(nameof(keyword));
      }
      if (colonToken == null)
        throw new ArgumentNullException(nameof(colonToken));
#endif

      int hash;
      var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.DefaultSwitchLabel, keyword, colonToken, out hash);
      if (cached != null) return (DefaultSwitchLabelSyntax)cached;

      var result = new DefaultSwitchLabelSyntax(SyntaxKind.DefaultSwitchLabel, keyword, colonToken);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public static SwitchExpressionSyntax SwitchExpression(ExpressionSyntax governingExpression, SyntaxToken switchKeyword, SyntaxToken openBraceToken, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<SwitchExpressionArmSyntax> arms, SyntaxToken closeBraceToken)
    {
#if DEBUG
      if (governingExpression == null)
        throw new ArgumentNullException(nameof(governingExpression));
      if (switchKeyword == null)
        throw new ArgumentNullException(nameof(switchKeyword));
      switch (switchKeyword.Kind)
      {
        case SyntaxKind.SwitchKeyword:
          break;
        default:
          throw new ArgumentException(nameof(switchKeyword));
      }
      if (openBraceToken == null)
        throw new ArgumentNullException(nameof(openBraceToken));
      switch (openBraceToken.Kind)
      {
        case SyntaxKind.OpenBraceToken:
          break;
        default:
          throw new ArgumentException(nameof(openBraceToken));
      }
      if (closeBraceToken == null)
        throw new ArgumentNullException(nameof(closeBraceToken));
      switch (closeBraceToken.Kind)
      {
        case SyntaxKind.CloseBraceToken:
          break;
        default:
          throw new ArgumentException(nameof(closeBraceToken));
      }
#endif

      return new SwitchExpressionSyntax(SyntaxKind.SwitchExpression, governingExpression, switchKeyword, openBraceToken, arms.Node, closeBraceToken);
    }

    public static SwitchExpressionArmSyntax SwitchExpressionArm(PatternSyntax pattern, WhenClauseSyntax whenClause, SyntaxToken equalsGreaterThanToken, ExpressionSyntax expression)
    {
#if DEBUG
      if (pattern == null)
        throw new ArgumentNullException(nameof(pattern));
      if (equalsGreaterThanToken == null)
        throw new ArgumentNullException(nameof(equalsGreaterThanToken));
      switch (equalsGreaterThanToken.Kind)
      {
        case SyntaxKind.EqualsGreaterThanToken:
          break;
        default:
          throw new ArgumentException(nameof(equalsGreaterThanToken));
      }
      if (expression == null)
        throw new ArgumentNullException(nameof(expression));
#endif

      return new SwitchExpressionArmSyntax(SyntaxKind.SwitchExpressionArm, pattern, whenClause, equalsGreaterThanToken, expression);
    }

    public static TryStatementSyntax TryStatement(SyntaxToken tryKeyword, BlockSyntax block, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<CatchClauseSyntax> catches, FinallyClauseSyntax @finally)
    {
#if DEBUG
      if (tryKeyword == null)
        throw new ArgumentNullException(nameof(tryKeyword));
      switch (tryKeyword.Kind)
      {
        case SyntaxKind.TryKeyword:
          break;
        default:
          throw new ArgumentException(nameof(tryKeyword));
      }
      if (block == null)
        throw new ArgumentNullException(nameof(block));
#endif

      return new TryStatementSyntax(SyntaxKind.TryStatement, tryKeyword, block, catches.Node, @finally);
    }

    public static CatchClauseSyntax CatchClause(SyntaxToken catchKeyword, CatchDeclarationSyntax declaration, CatchFilterClauseSyntax filter, BlockSyntax block)
    {
#if DEBUG
      if (catchKeyword == null)
        throw new ArgumentNullException(nameof(catchKeyword));
      switch (catchKeyword.Kind)
      {
        case SyntaxKind.CatchKeyword:
          break;
        default:
          throw new ArgumentException(nameof(catchKeyword));
      }
      if (block == null)
        throw new ArgumentNullException(nameof(block));
#endif

      return new CatchClauseSyntax(SyntaxKind.CatchClause, catchKeyword, declaration, filter, block);
    }

    public static CatchDeclarationSyntax CatchDeclaration(SyntaxToken openParenToken, TypeSyntax type, SyntaxToken identifier, SyntaxToken closeParenToken)
    {
#if DEBUG
      if (openParenToken == null)
        throw new ArgumentNullException(nameof(openParenToken));
      switch (openParenToken.Kind)
      {
        case SyntaxKind.OpenParenToken:
          break;
        default:
          throw new ArgumentException(nameof(openParenToken));
      }
      if (type == null)
        throw new ArgumentNullException(nameof(type));
      if (identifier != null)
      {
      switch (identifier.Kind)
      {
        case SyntaxKind.IdentifierToken:
        case SyntaxKind.None:
          break;
        default:
          throw new ArgumentException(nameof(identifier));
      }
      }
      if (closeParenToken == null)
        throw new ArgumentNullException(nameof(closeParenToken));
      switch (closeParenToken.Kind)
      {
        case SyntaxKind.CloseParenToken:
          break;
        default:
          throw new ArgumentException(nameof(closeParenToken));
      }
#endif

      return new CatchDeclarationSyntax(SyntaxKind.CatchDeclaration, openParenToken, type, identifier, closeParenToken);
    }

    public static CatchFilterClauseSyntax CatchFilterClause(SyntaxToken whenKeyword, SyntaxToken openParenToken, ExpressionSyntax filterExpression, SyntaxToken closeParenToken)
    {
#if DEBUG
      if (whenKeyword == null)
        throw new ArgumentNullException(nameof(whenKeyword));
      switch (whenKeyword.Kind)
      {
        case SyntaxKind.WhenKeyword:
          break;
        default:
          throw new ArgumentException(nameof(whenKeyword));
      }
      if (openParenToken == null)
        throw new ArgumentNullException(nameof(openParenToken));
      switch (openParenToken.Kind)
      {
        case SyntaxKind.OpenParenToken:
          break;
        default:
          throw new ArgumentException(nameof(openParenToken));
      }
      if (filterExpression == null)
        throw new ArgumentNullException(nameof(filterExpression));
      if (closeParenToken == null)
        throw new ArgumentNullException(nameof(closeParenToken));
      switch (closeParenToken.Kind)
      {
        case SyntaxKind.CloseParenToken:
          break;
        default:
          throw new ArgumentException(nameof(closeParenToken));
      }
#endif

      return new CatchFilterClauseSyntax(SyntaxKind.CatchFilterClause, whenKeyword, openParenToken, filterExpression, closeParenToken);
    }

    public static FinallyClauseSyntax FinallyClause(SyntaxToken finallyKeyword, BlockSyntax block)
    {
#if DEBUG
      if (finallyKeyword == null)
        throw new ArgumentNullException(nameof(finallyKeyword));
      switch (finallyKeyword.Kind)
      {
        case SyntaxKind.FinallyKeyword:
          break;
        default:
          throw new ArgumentException(nameof(finallyKeyword));
      }
      if (block == null)
        throw new ArgumentNullException(nameof(block));
#endif

      int hash;
      var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.FinallyClause, finallyKeyword, block, out hash);
      if (cached != null) return (FinallyClauseSyntax)cached;

      var result = new FinallyClauseSyntax(SyntaxKind.FinallyClause, finallyKeyword, block);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public static CompilationUnitSyntax CompilationUnit(Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<ExternAliasDirectiveSyntax> externs, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<UsingDirectiveSyntax> usings, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<AttributeListSyntax> attributeLists, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<MemberDeclarationSyntax> members, SyntaxToken endOfFileToken)
    {
#if DEBUG
      if (endOfFileToken == null)
        throw new ArgumentNullException(nameof(endOfFileToken));
      switch (endOfFileToken.Kind)
      {
        case SyntaxKind.EndOfFileToken:
          break;
        default:
          throw new ArgumentException(nameof(endOfFileToken));
      }
#endif

      return new CompilationUnitSyntax(SyntaxKind.CompilationUnit, externs.Node, usings.Node, attributeLists.Node, members.Node, endOfFileToken);
    }

    public static ExternAliasDirectiveSyntax ExternAliasDirective(SyntaxToken externKeyword, SyntaxToken aliasKeyword, SyntaxToken identifier, SyntaxToken semicolonToken)
    {
#if DEBUG
      if (externKeyword == null)
        throw new ArgumentNullException(nameof(externKeyword));
      switch (externKeyword.Kind)
      {
        case SyntaxKind.ExternKeyword:
          break;
        default:
          throw new ArgumentException(nameof(externKeyword));
      }
      if (aliasKeyword == null)
        throw new ArgumentNullException(nameof(aliasKeyword));
      switch (aliasKeyword.Kind)
      {
        case SyntaxKind.AliasKeyword:
          break;
        default:
          throw new ArgumentException(nameof(aliasKeyword));
      }
      if (identifier == null)
        throw new ArgumentNullException(nameof(identifier));
      switch (identifier.Kind)
      {
        case SyntaxKind.IdentifierToken:
          break;
        default:
          throw new ArgumentException(nameof(identifier));
      }
      if (semicolonToken == null)
        throw new ArgumentNullException(nameof(semicolonToken));
      switch (semicolonToken.Kind)
      {
        case SyntaxKind.SemicolonToken:
          break;
        default:
          throw new ArgumentException(nameof(semicolonToken));
      }
#endif

      return new ExternAliasDirectiveSyntax(SyntaxKind.ExternAliasDirective, externKeyword, aliasKeyword, identifier, semicolonToken);
    }

    public static UsingDirectiveSyntax UsingDirective(SyntaxToken usingKeyword, SyntaxToken staticKeyword, NameEqualsSyntax alias, NameSyntax name, SyntaxToken semicolonToken)
    {
#if DEBUG
      if (usingKeyword == null)
        throw new ArgumentNullException(nameof(usingKeyword));
      switch (usingKeyword.Kind)
      {
        case SyntaxKind.UsingKeyword:
          break;
        default:
          throw new ArgumentException(nameof(usingKeyword));
      }
      if (name == null)
        throw new ArgumentNullException(nameof(name));
      if (semicolonToken == null)
        throw new ArgumentNullException(nameof(semicolonToken));
      switch (semicolonToken.Kind)
      {
        case SyntaxKind.SemicolonToken:
          break;
        default:
          throw new ArgumentException(nameof(semicolonToken));
      }
#endif

      return new UsingDirectiveSyntax(SyntaxKind.UsingDirective, usingKeyword, staticKeyword, alias, name, semicolonToken);
    }

    public static NamespaceDeclarationSyntax NamespaceDeclaration(Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<AttributeListSyntax> attributeLists, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SyntaxToken> modifiers, SyntaxToken namespaceKeyword, NameSyntax name, SyntaxToken openBraceToken, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<ExternAliasDirectiveSyntax> externs, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<UsingDirectiveSyntax> usings, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<MemberDeclarationSyntax> members, SyntaxToken closeBraceToken, SyntaxToken semicolonToken)
    {
#if DEBUG
      if (namespaceKeyword == null)
        throw new ArgumentNullException(nameof(namespaceKeyword));
      switch (namespaceKeyword.Kind)
      {
        case SyntaxKind.NamespaceKeyword:
          break;
        default:
          throw new ArgumentException(nameof(namespaceKeyword));
      }
      if (name == null)
        throw new ArgumentNullException(nameof(name));
      if (openBraceToken == null)
        throw new ArgumentNullException(nameof(openBraceToken));
      switch (openBraceToken.Kind)
      {
        case SyntaxKind.OpenBraceToken:
          break;
        default:
          throw new ArgumentException(nameof(openBraceToken));
      }
      if (closeBraceToken == null)
        throw new ArgumentNullException(nameof(closeBraceToken));
      switch (closeBraceToken.Kind)
      {
        case SyntaxKind.CloseBraceToken:
          break;
        default:
          throw new ArgumentException(nameof(closeBraceToken));
      }
      if (semicolonToken != null)
      {
      switch (semicolonToken.Kind)
      {
        case SyntaxKind.SemicolonToken:
        case SyntaxKind.None:
          break;
        default:
          throw new ArgumentException(nameof(semicolonToken));
      }
      }
#endif

      return new NamespaceDeclarationSyntax(SyntaxKind.NamespaceDeclaration, attributeLists.Node, modifiers.Node, namespaceKeyword, name, openBraceToken, externs.Node, usings.Node, members.Node, closeBraceToken, semicolonToken);
    }

    public static AttributeListSyntax AttributeList(SyntaxToken openBracketToken, AttributeTargetSpecifierSyntax target, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<AttributeSyntax> attributes, SyntaxToken closeBracketToken)
    {
#if DEBUG
      if (openBracketToken == null)
        throw new ArgumentNullException(nameof(openBracketToken));
      switch (openBracketToken.Kind)
      {
        case SyntaxKind.OpenBracketToken:
          break;
        default:
          throw new ArgumentException(nameof(openBracketToken));
      }
      if (closeBracketToken == null)
        throw new ArgumentNullException(nameof(closeBracketToken));
      switch (closeBracketToken.Kind)
      {
        case SyntaxKind.CloseBracketToken:
          break;
        default:
          throw new ArgumentException(nameof(closeBracketToken));
      }
#endif

      return new AttributeListSyntax(SyntaxKind.AttributeList, openBracketToken, target, attributes.Node, closeBracketToken);
    }

    public static AttributeTargetSpecifierSyntax AttributeTargetSpecifier(SyntaxToken identifier, SyntaxToken colonToken)
    {
#if DEBUG
      if (identifier == null)
        throw new ArgumentNullException(nameof(identifier));
      if (colonToken == null)
        throw new ArgumentNullException(nameof(colonToken));
      switch (colonToken.Kind)
      {
        case SyntaxKind.ColonToken:
          break;
        default:
          throw new ArgumentException(nameof(colonToken));
      }
#endif

      int hash;
      var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.AttributeTargetSpecifier, identifier, colonToken, out hash);
      if (cached != null) return (AttributeTargetSpecifierSyntax)cached;

      var result = new AttributeTargetSpecifierSyntax(SyntaxKind.AttributeTargetSpecifier, identifier, colonToken);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public static AttributeSyntax Attribute(NameSyntax name, AttributeArgumentListSyntax argumentList)
    {
#if DEBUG
      if (name == null)
        throw new ArgumentNullException(nameof(name));
#endif

      int hash;
      var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.Attribute, name, argumentList, out hash);
      if (cached != null) return (AttributeSyntax)cached;

      var result = new AttributeSyntax(SyntaxKind.Attribute, name, argumentList);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public static AttributeArgumentListSyntax AttributeArgumentList(SyntaxToken openParenToken, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<AttributeArgumentSyntax> arguments, SyntaxToken closeParenToken)
    {
#if DEBUG
      if (openParenToken == null)
        throw new ArgumentNullException(nameof(openParenToken));
      switch (openParenToken.Kind)
      {
        case SyntaxKind.OpenParenToken:
          break;
        default:
          throw new ArgumentException(nameof(openParenToken));
      }
      if (closeParenToken == null)
        throw new ArgumentNullException(nameof(closeParenToken));
      switch (closeParenToken.Kind)
      {
        case SyntaxKind.CloseParenToken:
          break;
        default:
          throw new ArgumentException(nameof(closeParenToken));
      }
#endif

      int hash;
      var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.AttributeArgumentList, openParenToken, arguments.Node, closeParenToken, out hash);
      if (cached != null) return (AttributeArgumentListSyntax)cached;

      var result = new AttributeArgumentListSyntax(SyntaxKind.AttributeArgumentList, openParenToken, arguments.Node, closeParenToken);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public static AttributeArgumentSyntax AttributeArgument(NameEqualsSyntax nameEquals, NameColonSyntax nameColon, ExpressionSyntax expression)
    {
#if DEBUG
      if (expression == null)
        throw new ArgumentNullException(nameof(expression));
#endif

      int hash;
      var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.AttributeArgument, nameEquals, nameColon, expression, out hash);
      if (cached != null) return (AttributeArgumentSyntax)cached;

      var result = new AttributeArgumentSyntax(SyntaxKind.AttributeArgument, nameEquals, nameColon, expression);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public static NameEqualsSyntax NameEquals(IdentifierNameSyntax name, SyntaxToken equalsToken)
    {
#if DEBUG
      if (name == null)
        throw new ArgumentNullException(nameof(name));
      if (equalsToken == null)
        throw new ArgumentNullException(nameof(equalsToken));
      switch (equalsToken.Kind)
      {
        case SyntaxKind.EqualsToken:
          break;
        default:
          throw new ArgumentException(nameof(equalsToken));
      }
#endif

      int hash;
      var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.NameEquals, name, equalsToken, out hash);
      if (cached != null) return (NameEqualsSyntax)cached;

      var result = new NameEqualsSyntax(SyntaxKind.NameEquals, name, equalsToken);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public static TypeParameterListSyntax TypeParameterList(SyntaxToken lessThanToken, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<TypeParameterSyntax> parameters, SyntaxToken greaterThanToken)
    {
#if DEBUG
      if (lessThanToken == null)
        throw new ArgumentNullException(nameof(lessThanToken));
      switch (lessThanToken.Kind)
      {
        case SyntaxKind.LessThanToken:
          break;
        default:
          throw new ArgumentException(nameof(lessThanToken));
      }
      if (greaterThanToken == null)
        throw new ArgumentNullException(nameof(greaterThanToken));
      switch (greaterThanToken.Kind)
      {
        case SyntaxKind.GreaterThanToken:
          break;
        default:
          throw new ArgumentException(nameof(greaterThanToken));
      }
#endif

      int hash;
      var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.TypeParameterList, lessThanToken, parameters.Node, greaterThanToken, out hash);
      if (cached != null) return (TypeParameterListSyntax)cached;

      var result = new TypeParameterListSyntax(SyntaxKind.TypeParameterList, lessThanToken, parameters.Node, greaterThanToken);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public static TypeParameterSyntax TypeParameter(Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<AttributeListSyntax> attributeLists, SyntaxToken varianceKeyword, SyntaxToken identifier)
    {
#if DEBUG
      if (varianceKeyword != null)
      {
      switch (varianceKeyword.Kind)
      {
        case SyntaxKind.InKeyword:
        case SyntaxKind.OutKeyword:
        case SyntaxKind.None:
          break;
        default:
          throw new ArgumentException(nameof(varianceKeyword));
      }
      }
      if (identifier == null)
        throw new ArgumentNullException(nameof(identifier));
      switch (identifier.Kind)
      {
        case SyntaxKind.IdentifierToken:
          break;
        default:
          throw new ArgumentException(nameof(identifier));
      }
#endif

      int hash;
      var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.TypeParameter, attributeLists.Node, varianceKeyword, identifier, out hash);
      if (cached != null) return (TypeParameterSyntax)cached;

      var result = new TypeParameterSyntax(SyntaxKind.TypeParameter, attributeLists.Node, varianceKeyword, identifier);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public static ClassDeclarationSyntax ClassDeclaration(Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<AttributeListSyntax> attributeLists, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SyntaxToken> modifiers, SyntaxToken keyword, SyntaxToken identifier, TypeParameterListSyntax typeParameterList, BaseListSyntax baseList, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<TypeParameterConstraintClauseSyntax> constraintClauses, SyntaxToken openBraceToken, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<MemberDeclarationSyntax> members, SyntaxToken closeBraceToken, SyntaxToken semicolonToken)
    {
#if DEBUG
      if (keyword == null)
        throw new ArgumentNullException(nameof(keyword));
      switch (keyword.Kind)
      {
        case SyntaxKind.ClassKeyword:
          break;
        default:
          throw new ArgumentException(nameof(keyword));
      }
      if (identifier == null)
        throw new ArgumentNullException(nameof(identifier));
      switch (identifier.Kind)
      {
        case SyntaxKind.IdentifierToken:
          break;
        default:
          throw new ArgumentException(nameof(identifier));
      }
      if (openBraceToken == null)
        throw new ArgumentNullException(nameof(openBraceToken));
      switch (openBraceToken.Kind)
      {
        case SyntaxKind.OpenBraceToken:
          break;
        default:
          throw new ArgumentException(nameof(openBraceToken));
      }
      if (closeBraceToken == null)
        throw new ArgumentNullException(nameof(closeBraceToken));
      switch (closeBraceToken.Kind)
      {
        case SyntaxKind.CloseBraceToken:
          break;
        default:
          throw new ArgumentException(nameof(closeBraceToken));
      }
      if (semicolonToken != null)
      {
      switch (semicolonToken.Kind)
      {
        case SyntaxKind.SemicolonToken:
        case SyntaxKind.None:
          break;
        default:
          throw new ArgumentException(nameof(semicolonToken));
      }
      }
#endif

      return new ClassDeclarationSyntax(SyntaxKind.ClassDeclaration, attributeLists.Node, modifiers.Node, keyword, identifier, typeParameterList, baseList, constraintClauses.Node, openBraceToken, members.Node, closeBraceToken, semicolonToken);
    }

    public static StructDeclarationSyntax StructDeclaration(Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<AttributeListSyntax> attributeLists, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SyntaxToken> modifiers, SyntaxToken keyword, SyntaxToken identifier, TypeParameterListSyntax typeParameterList, BaseListSyntax baseList, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<TypeParameterConstraintClauseSyntax> constraintClauses, SyntaxToken openBraceToken, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<MemberDeclarationSyntax> members, SyntaxToken closeBraceToken, SyntaxToken semicolonToken)
    {
#if DEBUG
      if (keyword == null)
        throw new ArgumentNullException(nameof(keyword));
      switch (keyword.Kind)
      {
        case SyntaxKind.StructKeyword:
          break;
        default:
          throw new ArgumentException(nameof(keyword));
      }
      if (identifier == null)
        throw new ArgumentNullException(nameof(identifier));
      switch (identifier.Kind)
      {
        case SyntaxKind.IdentifierToken:
          break;
        default:
          throw new ArgumentException(nameof(identifier));
      }
      if (openBraceToken == null)
        throw new ArgumentNullException(nameof(openBraceToken));
      switch (openBraceToken.Kind)
      {
        case SyntaxKind.OpenBraceToken:
          break;
        default:
          throw new ArgumentException(nameof(openBraceToken));
      }
      if (closeBraceToken == null)
        throw new ArgumentNullException(nameof(closeBraceToken));
      switch (closeBraceToken.Kind)
      {
        case SyntaxKind.CloseBraceToken:
          break;
        default:
          throw new ArgumentException(nameof(closeBraceToken));
      }
      if (semicolonToken != null)
      {
      switch (semicolonToken.Kind)
      {
        case SyntaxKind.SemicolonToken:
        case SyntaxKind.None:
          break;
        default:
          throw new ArgumentException(nameof(semicolonToken));
      }
      }
#endif

      return new StructDeclarationSyntax(SyntaxKind.StructDeclaration, attributeLists.Node, modifiers.Node, keyword, identifier, typeParameterList, baseList, constraintClauses.Node, openBraceToken, members.Node, closeBraceToken, semicolonToken);
    }

    public static InterfaceDeclarationSyntax InterfaceDeclaration(Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<AttributeListSyntax> attributeLists, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SyntaxToken> modifiers, SyntaxToken keyword, SyntaxToken identifier, TypeParameterListSyntax typeParameterList, BaseListSyntax baseList, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<TypeParameterConstraintClauseSyntax> constraintClauses, SyntaxToken openBraceToken, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<MemberDeclarationSyntax> members, SyntaxToken closeBraceToken, SyntaxToken semicolonToken)
    {
#if DEBUG
      if (keyword == null)
        throw new ArgumentNullException(nameof(keyword));
      switch (keyword.Kind)
      {
        case SyntaxKind.InterfaceKeyword:
          break;
        default:
          throw new ArgumentException(nameof(keyword));
      }
      if (identifier == null)
        throw new ArgumentNullException(nameof(identifier));
      switch (identifier.Kind)
      {
        case SyntaxKind.IdentifierToken:
          break;
        default:
          throw new ArgumentException(nameof(identifier));
      }
      if (openBraceToken == null)
        throw new ArgumentNullException(nameof(openBraceToken));
      switch (openBraceToken.Kind)
      {
        case SyntaxKind.OpenBraceToken:
          break;
        default:
          throw new ArgumentException(nameof(openBraceToken));
      }
      if (closeBraceToken == null)
        throw new ArgumentNullException(nameof(closeBraceToken));
      switch (closeBraceToken.Kind)
      {
        case SyntaxKind.CloseBraceToken:
          break;
        default:
          throw new ArgumentException(nameof(closeBraceToken));
      }
      if (semicolonToken != null)
      {
      switch (semicolonToken.Kind)
      {
        case SyntaxKind.SemicolonToken:
        case SyntaxKind.None:
          break;
        default:
          throw new ArgumentException(nameof(semicolonToken));
      }
      }
#endif

      return new InterfaceDeclarationSyntax(SyntaxKind.InterfaceDeclaration, attributeLists.Node, modifiers.Node, keyword, identifier, typeParameterList, baseList, constraintClauses.Node, openBraceToken, members.Node, closeBraceToken, semicolonToken);
    }

    public static EnumDeclarationSyntax EnumDeclaration(Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<AttributeListSyntax> attributeLists, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SyntaxToken> modifiers, SyntaxToken enumKeyword, SyntaxToken identifier, BaseListSyntax baseList, SyntaxToken openBraceToken, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<EnumMemberDeclarationSyntax> members, SyntaxToken closeBraceToken, SyntaxToken semicolonToken)
    {
#if DEBUG
      if (enumKeyword == null)
        throw new ArgumentNullException(nameof(enumKeyword));
      switch (enumKeyword.Kind)
      {
        case SyntaxKind.EnumKeyword:
          break;
        default:
          throw new ArgumentException(nameof(enumKeyword));
      }
      if (identifier == null)
        throw new ArgumentNullException(nameof(identifier));
      switch (identifier.Kind)
      {
        case SyntaxKind.IdentifierToken:
          break;
        default:
          throw new ArgumentException(nameof(identifier));
      }
      if (openBraceToken == null)
        throw new ArgumentNullException(nameof(openBraceToken));
      switch (openBraceToken.Kind)
      {
        case SyntaxKind.OpenBraceToken:
          break;
        default:
          throw new ArgumentException(nameof(openBraceToken));
      }
      if (closeBraceToken == null)
        throw new ArgumentNullException(nameof(closeBraceToken));
      switch (closeBraceToken.Kind)
      {
        case SyntaxKind.CloseBraceToken:
          break;
        default:
          throw new ArgumentException(nameof(closeBraceToken));
      }
      if (semicolonToken != null)
      {
      switch (semicolonToken.Kind)
      {
        case SyntaxKind.SemicolonToken:
        case SyntaxKind.None:
          break;
        default:
          throw new ArgumentException(nameof(semicolonToken));
      }
      }
#endif

      return new EnumDeclarationSyntax(SyntaxKind.EnumDeclaration, attributeLists.Node, modifiers.Node, enumKeyword, identifier, baseList, openBraceToken, members.Node, closeBraceToken, semicolonToken);
    }

    public static DelegateDeclarationSyntax DelegateDeclaration(Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<AttributeListSyntax> attributeLists, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SyntaxToken> modifiers, SyntaxToken delegateKeyword, TypeSyntax returnType, SyntaxToken identifier, TypeParameterListSyntax typeParameterList, ParameterListSyntax parameterList, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<TypeParameterConstraintClauseSyntax> constraintClauses, SyntaxToken semicolonToken)
    {
#if DEBUG
      if (delegateKeyword == null)
        throw new ArgumentNullException(nameof(delegateKeyword));
      switch (delegateKeyword.Kind)
      {
        case SyntaxKind.DelegateKeyword:
          break;
        default:
          throw new ArgumentException(nameof(delegateKeyword));
      }
      if (returnType == null)
        throw new ArgumentNullException(nameof(returnType));
      if (identifier == null)
        throw new ArgumentNullException(nameof(identifier));
      switch (identifier.Kind)
      {
        case SyntaxKind.IdentifierToken:
          break;
        default:
          throw new ArgumentException(nameof(identifier));
      }
      if (parameterList == null)
        throw new ArgumentNullException(nameof(parameterList));
      if (semicolonToken == null)
        throw new ArgumentNullException(nameof(semicolonToken));
      switch (semicolonToken.Kind)
      {
        case SyntaxKind.SemicolonToken:
          break;
        default:
          throw new ArgumentException(nameof(semicolonToken));
      }
#endif

      return new DelegateDeclarationSyntax(SyntaxKind.DelegateDeclaration, attributeLists.Node, modifiers.Node, delegateKeyword, returnType, identifier, typeParameterList, parameterList, constraintClauses.Node, semicolonToken);
    }

    public static EnumMemberDeclarationSyntax EnumMemberDeclaration(Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<AttributeListSyntax> attributeLists, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SyntaxToken> modifiers, SyntaxToken identifier, EqualsValueClauseSyntax equalsValue)
    {
#if DEBUG
      if (identifier == null)
        throw new ArgumentNullException(nameof(identifier));
      switch (identifier.Kind)
      {
        case SyntaxKind.IdentifierToken:
          break;
        default:
          throw new ArgumentException(nameof(identifier));
      }
#endif

      return new EnumMemberDeclarationSyntax(SyntaxKind.EnumMemberDeclaration, attributeLists.Node, modifiers.Node, identifier, equalsValue);
    }

    public static BaseListSyntax BaseList(SyntaxToken colonToken, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<BaseTypeSyntax> types)
    {
#if DEBUG
      if (colonToken == null)
        throw new ArgumentNullException(nameof(colonToken));
      switch (colonToken.Kind)
      {
        case SyntaxKind.ColonToken:
          break;
        default:
          throw new ArgumentException(nameof(colonToken));
      }
#endif

      int hash;
      var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.BaseList, colonToken, types.Node, out hash);
      if (cached != null) return (BaseListSyntax)cached;

      var result = new BaseListSyntax(SyntaxKind.BaseList, colonToken, types.Node);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public static SimpleBaseTypeSyntax SimpleBaseType(TypeSyntax type)
    {
#if DEBUG
      if (type == null)
        throw new ArgumentNullException(nameof(type));
#endif

      int hash;
      var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.SimpleBaseType, type, out hash);
      if (cached != null) return (SimpleBaseTypeSyntax)cached;

      var result = new SimpleBaseTypeSyntax(SyntaxKind.SimpleBaseType, type);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public static TypeParameterConstraintClauseSyntax TypeParameterConstraintClause(SyntaxToken whereKeyword, IdentifierNameSyntax name, SyntaxToken colonToken, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<TypeParameterConstraintSyntax> constraints)
    {
#if DEBUG
      if (whereKeyword == null)
        throw new ArgumentNullException(nameof(whereKeyword));
      switch (whereKeyword.Kind)
      {
        case SyntaxKind.WhereKeyword:
          break;
        default:
          throw new ArgumentException(nameof(whereKeyword));
      }
      if (name == null)
        throw new ArgumentNullException(nameof(name));
      if (colonToken == null)
        throw new ArgumentNullException(nameof(colonToken));
      switch (colonToken.Kind)
      {
        case SyntaxKind.ColonToken:
          break;
        default:
          throw new ArgumentException(nameof(colonToken));
      }
#endif

      return new TypeParameterConstraintClauseSyntax(SyntaxKind.TypeParameterConstraintClause, whereKeyword, name, colonToken, constraints.Node);
    }

    public static ConstructorConstraintSyntax ConstructorConstraint(SyntaxToken newKeyword, SyntaxToken openParenToken, SyntaxToken closeParenToken)
    {
#if DEBUG
      if (newKeyword == null)
        throw new ArgumentNullException(nameof(newKeyword));
      switch (newKeyword.Kind)
      {
        case SyntaxKind.NewKeyword:
          break;
        default:
          throw new ArgumentException(nameof(newKeyword));
      }
      if (openParenToken == null)
        throw new ArgumentNullException(nameof(openParenToken));
      switch (openParenToken.Kind)
      {
        case SyntaxKind.OpenParenToken:
          break;
        default:
          throw new ArgumentException(nameof(openParenToken));
      }
      if (closeParenToken == null)
        throw new ArgumentNullException(nameof(closeParenToken));
      switch (closeParenToken.Kind)
      {
        case SyntaxKind.CloseParenToken:
          break;
        default:
          throw new ArgumentException(nameof(closeParenToken));
      }
#endif

      int hash;
      var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.ConstructorConstraint, newKeyword, openParenToken, closeParenToken, out hash);
      if (cached != null) return (ConstructorConstraintSyntax)cached;

      var result = new ConstructorConstraintSyntax(SyntaxKind.ConstructorConstraint, newKeyword, openParenToken, closeParenToken);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public static ClassOrStructConstraintSyntax ClassOrStructConstraint(SyntaxKind kind, SyntaxToken classOrStructKeyword, SyntaxToken questionToken)
    {
      switch (kind)
      {
        case SyntaxKind.ClassConstraint:
        case SyntaxKind.StructConstraint:
          break;
        default:
          throw new ArgumentException(nameof(kind));
      }
#if DEBUG
      if (classOrStructKeyword == null)
        throw new ArgumentNullException(nameof(classOrStructKeyword));
      switch (classOrStructKeyword.Kind)
      {
        case SyntaxKind.ClassKeyword:
        case SyntaxKind.StructKeyword:
          break;
        default:
          throw new ArgumentException(nameof(classOrStructKeyword));
      }
      if (questionToken != null)
      {
      switch (questionToken.Kind)
      {
        case SyntaxKind.QuestionToken:
        case SyntaxKind.None:
          break;
        default:
          throw new ArgumentException(nameof(questionToken));
      }
      }
#endif

      int hash;
      var cached = SyntaxNodeCache.TryGetNode((int)kind, classOrStructKeyword, questionToken, out hash);
      if (cached != null) return (ClassOrStructConstraintSyntax)cached;

      var result = new ClassOrStructConstraintSyntax(kind, classOrStructKeyword, questionToken);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public static TypeConstraintSyntax TypeConstraint(TypeSyntax type)
    {
#if DEBUG
      if (type == null)
        throw new ArgumentNullException(nameof(type));
#endif

      int hash;
      var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.TypeConstraint, type, out hash);
      if (cached != null) return (TypeConstraintSyntax)cached;

      var result = new TypeConstraintSyntax(SyntaxKind.TypeConstraint, type);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public static FieldDeclarationSyntax FieldDeclaration(Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<AttributeListSyntax> attributeLists, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SyntaxToken> modifiers, VariableDeclarationSyntax declaration, SyntaxToken semicolonToken)
    {
#if DEBUG
      if (declaration == null)
        throw new ArgumentNullException(nameof(declaration));
      if (semicolonToken == null)
        throw new ArgumentNullException(nameof(semicolonToken));
      switch (semicolonToken.Kind)
      {
        case SyntaxKind.SemicolonToken:
          break;
        default:
          throw new ArgumentException(nameof(semicolonToken));
      }
#endif

      return new FieldDeclarationSyntax(SyntaxKind.FieldDeclaration, attributeLists.Node, modifiers.Node, declaration, semicolonToken);
    }

    public static EventFieldDeclarationSyntax EventFieldDeclaration(Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<AttributeListSyntax> attributeLists, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SyntaxToken> modifiers, SyntaxToken eventKeyword, VariableDeclarationSyntax declaration, SyntaxToken semicolonToken)
    {
#if DEBUG
      if (eventKeyword == null)
        throw new ArgumentNullException(nameof(eventKeyword));
      switch (eventKeyword.Kind)
      {
        case SyntaxKind.EventKeyword:
          break;
        default:
          throw new ArgumentException(nameof(eventKeyword));
      }
      if (declaration == null)
        throw new ArgumentNullException(nameof(declaration));
      if (semicolonToken == null)
        throw new ArgumentNullException(nameof(semicolonToken));
      switch (semicolonToken.Kind)
      {
        case SyntaxKind.SemicolonToken:
          break;
        default:
          throw new ArgumentException(nameof(semicolonToken));
      }
#endif

      return new EventFieldDeclarationSyntax(SyntaxKind.EventFieldDeclaration, attributeLists.Node, modifiers.Node, eventKeyword, declaration, semicolonToken);
    }

    public static ExplicitInterfaceSpecifierSyntax ExplicitInterfaceSpecifier(NameSyntax name, SyntaxToken dotToken)
    {
#if DEBUG
      if (name == null)
        throw new ArgumentNullException(nameof(name));
      if (dotToken == null)
        throw new ArgumentNullException(nameof(dotToken));
      switch (dotToken.Kind)
      {
        case SyntaxKind.DotToken:
          break;
        default:
          throw new ArgumentException(nameof(dotToken));
      }
#endif

      int hash;
      var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.ExplicitInterfaceSpecifier, name, dotToken, out hash);
      if (cached != null) return (ExplicitInterfaceSpecifierSyntax)cached;

      var result = new ExplicitInterfaceSpecifierSyntax(SyntaxKind.ExplicitInterfaceSpecifier, name, dotToken);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public static MethodDeclarationSyntax MethodDeclaration(Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<AttributeListSyntax> attributeLists, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SyntaxToken> modifiers, TypeSyntax returnType, ExplicitInterfaceSpecifierSyntax explicitInterfaceSpecifier, SyntaxToken identifier, TypeParameterListSyntax typeParameterList, ParameterListSyntax parameterList, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<TypeParameterConstraintClauseSyntax> constraintClauses, BlockSyntax body, ArrowExpressionClauseSyntax expressionBody, SyntaxToken semicolonToken)
    {
#if DEBUG
      if (returnType == null)
        throw new ArgumentNullException(nameof(returnType));
      if (identifier == null)
        throw new ArgumentNullException(nameof(identifier));
      switch (identifier.Kind)
      {
        case SyntaxKind.IdentifierToken:
          break;
        default:
          throw new ArgumentException(nameof(identifier));
      }
      if (parameterList == null)
        throw new ArgumentNullException(nameof(parameterList));
      if (semicolonToken != null)
      {
      switch (semicolonToken.Kind)
      {
        case SyntaxKind.SemicolonToken:
        case SyntaxKind.None:
          break;
        default:
          throw new ArgumentException(nameof(semicolonToken));
      }
      }
#endif

      return new MethodDeclarationSyntax(SyntaxKind.MethodDeclaration, attributeLists.Node, modifiers.Node, returnType, explicitInterfaceSpecifier, identifier, typeParameterList, parameterList, constraintClauses.Node, body, expressionBody, semicolonToken);
    }

    public static OperatorDeclarationSyntax OperatorDeclaration(Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<AttributeListSyntax> attributeLists, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SyntaxToken> modifiers, TypeSyntax returnType, SyntaxToken operatorKeyword, SyntaxToken operatorToken, ParameterListSyntax parameterList, BlockSyntax body, ArrowExpressionClauseSyntax expressionBody, SyntaxToken semicolonToken)
    {
#if DEBUG
      if (returnType == null)
        throw new ArgumentNullException(nameof(returnType));
      if (operatorKeyword == null)
        throw new ArgumentNullException(nameof(operatorKeyword));
      switch (operatorKeyword.Kind)
      {
        case SyntaxKind.OperatorKeyword:
          break;
        default:
          throw new ArgumentException(nameof(operatorKeyword));
      }
      if (operatorToken == null)
        throw new ArgumentNullException(nameof(operatorToken));
      switch (operatorToken.Kind)
      {
        case SyntaxKind.PlusToken:
        case SyntaxKind.MinusToken:
        case SyntaxKind.ExclamationToken:
        case SyntaxKind.TildeToken:
        case SyntaxKind.PlusPlusToken:
        case SyntaxKind.MinusMinusToken:
        case SyntaxKind.AsteriskToken:
        case SyntaxKind.SlashToken:
        case SyntaxKind.PercentToken:
        case SyntaxKind.LessThanLessThanToken:
        case SyntaxKind.GreaterThanGreaterThanToken:
        case SyntaxKind.BarToken:
        case SyntaxKind.AmpersandToken:
        case SyntaxKind.CaretToken:
        case SyntaxKind.EqualsEqualsToken:
        case SyntaxKind.ExclamationEqualsToken:
        case SyntaxKind.LessThanToken:
        case SyntaxKind.LessThanEqualsToken:
        case SyntaxKind.GreaterThanToken:
        case SyntaxKind.GreaterThanEqualsToken:
        case SyntaxKind.FalseKeyword:
        case SyntaxKind.TrueKeyword:
        case SyntaxKind.IsKeyword:
          break;
        default:
          throw new ArgumentException(nameof(operatorToken));
      }
      if (parameterList == null)
        throw new ArgumentNullException(nameof(parameterList));
      if (semicolonToken != null)
      {
      switch (semicolonToken.Kind)
      {
        case SyntaxKind.SemicolonToken:
        case SyntaxKind.None:
          break;
        default:
          throw new ArgumentException(nameof(semicolonToken));
      }
      }
#endif

      return new OperatorDeclarationSyntax(SyntaxKind.OperatorDeclaration, attributeLists.Node, modifiers.Node, returnType, operatorKeyword, operatorToken, parameterList, body, expressionBody, semicolonToken);
    }

    public static ConversionOperatorDeclarationSyntax ConversionOperatorDeclaration(Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<AttributeListSyntax> attributeLists, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SyntaxToken> modifiers, SyntaxToken implicitOrExplicitKeyword, SyntaxToken operatorKeyword, TypeSyntax type, ParameterListSyntax parameterList, BlockSyntax body, ArrowExpressionClauseSyntax expressionBody, SyntaxToken semicolonToken)
    {
#if DEBUG
      if (implicitOrExplicitKeyword == null)
        throw new ArgumentNullException(nameof(implicitOrExplicitKeyword));
      switch (implicitOrExplicitKeyword.Kind)
      {
        case SyntaxKind.ImplicitKeyword:
        case SyntaxKind.ExplicitKeyword:
          break;
        default:
          throw new ArgumentException(nameof(implicitOrExplicitKeyword));
      }
      if (operatorKeyword == null)
        throw new ArgumentNullException(nameof(operatorKeyword));
      switch (operatorKeyword.Kind)
      {
        case SyntaxKind.OperatorKeyword:
          break;
        default:
          throw new ArgumentException(nameof(operatorKeyword));
      }
      if (type == null)
        throw new ArgumentNullException(nameof(type));
      if (parameterList == null)
        throw new ArgumentNullException(nameof(parameterList));
      if (semicolonToken != null)
      {
      switch (semicolonToken.Kind)
      {
        case SyntaxKind.SemicolonToken:
        case SyntaxKind.None:
          break;
        default:
          throw new ArgumentException(nameof(semicolonToken));
      }
      }
#endif

      return new ConversionOperatorDeclarationSyntax(SyntaxKind.ConversionOperatorDeclaration, attributeLists.Node, modifiers.Node, implicitOrExplicitKeyword, operatorKeyword, type, parameterList, body, expressionBody, semicolonToken);
    }

    public static ConstructorDeclarationSyntax ConstructorDeclaration(Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<AttributeListSyntax> attributeLists, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SyntaxToken> modifiers, SyntaxToken identifier, ParameterListSyntax parameterList, ConstructorInitializerSyntax initializer, BlockSyntax body, ArrowExpressionClauseSyntax expressionBody, SyntaxToken semicolonToken)
    {
#if DEBUG
      if (identifier == null)
        throw new ArgumentNullException(nameof(identifier));
      switch (identifier.Kind)
      {
        case SyntaxKind.IdentifierToken:
          break;
        default:
          throw new ArgumentException(nameof(identifier));
      }
      if (parameterList == null)
        throw new ArgumentNullException(nameof(parameterList));
      if (semicolonToken != null)
      {
      switch (semicolonToken.Kind)
      {
        case SyntaxKind.SemicolonToken:
        case SyntaxKind.None:
          break;
        default:
          throw new ArgumentException(nameof(semicolonToken));
      }
      }
#endif

      return new ConstructorDeclarationSyntax(SyntaxKind.ConstructorDeclaration, attributeLists.Node, modifiers.Node, identifier, parameterList, initializer, body, expressionBody, semicolonToken);
    }

    public static ConstructorInitializerSyntax ConstructorInitializer(SyntaxKind kind, SyntaxToken colonToken, SyntaxToken thisOrBaseKeyword, ArgumentListSyntax argumentList)
    {
      switch (kind)
      {
        case SyntaxKind.BaseConstructorInitializer:
        case SyntaxKind.ThisConstructorInitializer:
          break;
        default:
          throw new ArgumentException(nameof(kind));
      }
#if DEBUG
      if (colonToken == null)
        throw new ArgumentNullException(nameof(colonToken));
      switch (colonToken.Kind)
      {
        case SyntaxKind.ColonToken:
          break;
        default:
          throw new ArgumentException(nameof(colonToken));
      }
      if (thisOrBaseKeyword == null)
        throw new ArgumentNullException(nameof(thisOrBaseKeyword));
      switch (thisOrBaseKeyword.Kind)
      {
        case SyntaxKind.BaseKeyword:
        case SyntaxKind.ThisKeyword:
          break;
        default:
          throw new ArgumentException(nameof(thisOrBaseKeyword));
      }
      if (argumentList == null)
        throw new ArgumentNullException(nameof(argumentList));
#endif

      int hash;
      var cached = SyntaxNodeCache.TryGetNode((int)kind, colonToken, thisOrBaseKeyword, argumentList, out hash);
      if (cached != null) return (ConstructorInitializerSyntax)cached;

      var result = new ConstructorInitializerSyntax(kind, colonToken, thisOrBaseKeyword, argumentList);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public static DestructorDeclarationSyntax DestructorDeclaration(Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<AttributeListSyntax> attributeLists, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SyntaxToken> modifiers, SyntaxToken tildeToken, SyntaxToken identifier, ParameterListSyntax parameterList, BlockSyntax body, ArrowExpressionClauseSyntax expressionBody, SyntaxToken semicolonToken)
    {
#if DEBUG
      if (tildeToken == null)
        throw new ArgumentNullException(nameof(tildeToken));
      switch (tildeToken.Kind)
      {
        case SyntaxKind.TildeToken:
          break;
        default:
          throw new ArgumentException(nameof(tildeToken));
      }
      if (identifier == null)
        throw new ArgumentNullException(nameof(identifier));
      switch (identifier.Kind)
      {
        case SyntaxKind.IdentifierToken:
          break;
        default:
          throw new ArgumentException(nameof(identifier));
      }
      if (parameterList == null)
        throw new ArgumentNullException(nameof(parameterList));
      if (semicolonToken != null)
      {
      switch (semicolonToken.Kind)
      {
        case SyntaxKind.SemicolonToken:
        case SyntaxKind.None:
          break;
        default:
          throw new ArgumentException(nameof(semicolonToken));
      }
      }
#endif

      return new DestructorDeclarationSyntax(SyntaxKind.DestructorDeclaration, attributeLists.Node, modifiers.Node, tildeToken, identifier, parameterList, body, expressionBody, semicolonToken);
    }

    public static PropertyDeclarationSyntax PropertyDeclaration(Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<AttributeListSyntax> attributeLists, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SyntaxToken> modifiers, TypeSyntax type, ExplicitInterfaceSpecifierSyntax explicitInterfaceSpecifier, SyntaxToken identifier, AccessorListSyntax accessorList, ArrowExpressionClauseSyntax expressionBody, EqualsValueClauseSyntax initializer, SyntaxToken semicolonToken)
    {
#if DEBUG
      if (type == null)
        throw new ArgumentNullException(nameof(type));
      if (identifier == null)
        throw new ArgumentNullException(nameof(identifier));
      switch (identifier.Kind)
      {
        case SyntaxKind.IdentifierToken:
          break;
        default:
          throw new ArgumentException(nameof(identifier));
      }
      if (semicolonToken != null)
      {
      switch (semicolonToken.Kind)
      {
        case SyntaxKind.SemicolonToken:
        case SyntaxKind.None:
          break;
        default:
          throw new ArgumentException(nameof(semicolonToken));
      }
      }
#endif

      return new PropertyDeclarationSyntax(SyntaxKind.PropertyDeclaration, attributeLists.Node, modifiers.Node, type, explicitInterfaceSpecifier, identifier, accessorList, expressionBody, initializer, semicolonToken);
    }

    public static ArrowExpressionClauseSyntax ArrowExpressionClause(SyntaxToken arrowToken, ExpressionSyntax expression)
    {
#if DEBUG
      if (arrowToken == null)
        throw new ArgumentNullException(nameof(arrowToken));
      switch (arrowToken.Kind)
      {
        case SyntaxKind.EqualsGreaterThanToken:
          break;
        default:
          throw new ArgumentException(nameof(arrowToken));
      }
      if (expression == null)
        throw new ArgumentNullException(nameof(expression));
#endif

      int hash;
      var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.ArrowExpressionClause, arrowToken, expression, out hash);
      if (cached != null) return (ArrowExpressionClauseSyntax)cached;

      var result = new ArrowExpressionClauseSyntax(SyntaxKind.ArrowExpressionClause, arrowToken, expression);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public static EventDeclarationSyntax EventDeclaration(Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<AttributeListSyntax> attributeLists, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SyntaxToken> modifiers, SyntaxToken eventKeyword, TypeSyntax type, ExplicitInterfaceSpecifierSyntax explicitInterfaceSpecifier, SyntaxToken identifier, AccessorListSyntax accessorList, SyntaxToken semicolonToken)
    {
#if DEBUG
      if (eventKeyword == null)
        throw new ArgumentNullException(nameof(eventKeyword));
      switch (eventKeyword.Kind)
      {
        case SyntaxKind.EventKeyword:
          break;
        default:
          throw new ArgumentException(nameof(eventKeyword));
      }
      if (type == null)
        throw new ArgumentNullException(nameof(type));
      if (identifier == null)
        throw new ArgumentNullException(nameof(identifier));
      switch (identifier.Kind)
      {
        case SyntaxKind.IdentifierToken:
          break;
        default:
          throw new ArgumentException(nameof(identifier));
      }
      if (semicolonToken != null)
      {
      switch (semicolonToken.Kind)
      {
        case SyntaxKind.SemicolonToken:
        case SyntaxKind.None:
          break;
        default:
          throw new ArgumentException(nameof(semicolonToken));
      }
      }
#endif

      return new EventDeclarationSyntax(SyntaxKind.EventDeclaration, attributeLists.Node, modifiers.Node, eventKeyword, type, explicitInterfaceSpecifier, identifier, accessorList, semicolonToken);
    }

    public static IndexerDeclarationSyntax IndexerDeclaration(Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<AttributeListSyntax> attributeLists, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SyntaxToken> modifiers, TypeSyntax type, ExplicitInterfaceSpecifierSyntax explicitInterfaceSpecifier, SyntaxToken thisKeyword, BracketedParameterListSyntax parameterList, AccessorListSyntax accessorList, ArrowExpressionClauseSyntax expressionBody, SyntaxToken semicolonToken)
    {
#if DEBUG
      if (type == null)
        throw new ArgumentNullException(nameof(type));
      if (thisKeyword == null)
        throw new ArgumentNullException(nameof(thisKeyword));
      switch (thisKeyword.Kind)
      {
        case SyntaxKind.ThisKeyword:
          break;
        default:
          throw new ArgumentException(nameof(thisKeyword));
      }
      if (parameterList == null)
        throw new ArgumentNullException(nameof(parameterList));
      if (semicolonToken != null)
      {
      switch (semicolonToken.Kind)
      {
        case SyntaxKind.SemicolonToken:
        case SyntaxKind.None:
          break;
        default:
          throw new ArgumentException(nameof(semicolonToken));
      }
      }
#endif

      return new IndexerDeclarationSyntax(SyntaxKind.IndexerDeclaration, attributeLists.Node, modifiers.Node, type, explicitInterfaceSpecifier, thisKeyword, parameterList, accessorList, expressionBody, semicolonToken);
    }

    public static AccessorListSyntax AccessorList(SyntaxToken openBraceToken, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<AccessorDeclarationSyntax> accessors, SyntaxToken closeBraceToken)
    {
#if DEBUG
      if (openBraceToken == null)
        throw new ArgumentNullException(nameof(openBraceToken));
      switch (openBraceToken.Kind)
      {
        case SyntaxKind.OpenBraceToken:
          break;
        default:
          throw new ArgumentException(nameof(openBraceToken));
      }
      if (closeBraceToken == null)
        throw new ArgumentNullException(nameof(closeBraceToken));
      switch (closeBraceToken.Kind)
      {
        case SyntaxKind.CloseBraceToken:
          break;
        default:
          throw new ArgumentException(nameof(closeBraceToken));
      }
#endif

      int hash;
      var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.AccessorList, openBraceToken, accessors.Node, closeBraceToken, out hash);
      if (cached != null) return (AccessorListSyntax)cached;

      var result = new AccessorListSyntax(SyntaxKind.AccessorList, openBraceToken, accessors.Node, closeBraceToken);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public static AccessorDeclarationSyntax AccessorDeclaration(SyntaxKind kind, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<AttributeListSyntax> attributeLists, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SyntaxToken> modifiers, SyntaxToken keyword, BlockSyntax body, ArrowExpressionClauseSyntax expressionBody, SyntaxToken semicolonToken)
    {
      switch (kind)
      {
        case SyntaxKind.GetAccessorDeclaration:
        case SyntaxKind.SetAccessorDeclaration:
        case SyntaxKind.AddAccessorDeclaration:
        case SyntaxKind.RemoveAccessorDeclaration:
        case SyntaxKind.UnknownAccessorDeclaration:
          break;
        default:
          throw new ArgumentException(nameof(kind));
      }
#if DEBUG
      if (keyword == null)
        throw new ArgumentNullException(nameof(keyword));
      switch (keyword.Kind)
      {
        case SyntaxKind.GetKeyword:
        case SyntaxKind.SetKeyword:
        case SyntaxKind.AddKeyword:
        case SyntaxKind.RemoveKeyword:
        case SyntaxKind.IdentifierToken:
          break;
        default:
          throw new ArgumentException(nameof(keyword));
      }
      if (semicolonToken != null)
      {
      switch (semicolonToken.Kind)
      {
        case SyntaxKind.SemicolonToken:
        case SyntaxKind.None:
          break;
        default:
          throw new ArgumentException(nameof(semicolonToken));
      }
      }
#endif

      return new AccessorDeclarationSyntax(kind, attributeLists.Node, modifiers.Node, keyword, body, expressionBody, semicolonToken);
    }

    public static ParameterListSyntax ParameterList(SyntaxToken openParenToken, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<ParameterSyntax> parameters, SyntaxToken closeParenToken)
    {
#if DEBUG
      if (openParenToken == null)
        throw new ArgumentNullException(nameof(openParenToken));
      switch (openParenToken.Kind)
      {
        case SyntaxKind.OpenParenToken:
          break;
        default:
          throw new ArgumentException(nameof(openParenToken));
      }
      if (closeParenToken == null)
        throw new ArgumentNullException(nameof(closeParenToken));
      switch (closeParenToken.Kind)
      {
        case SyntaxKind.CloseParenToken:
          break;
        default:
          throw new ArgumentException(nameof(closeParenToken));
      }
#endif

      int hash;
      var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.ParameterList, openParenToken, parameters.Node, closeParenToken, out hash);
      if (cached != null) return (ParameterListSyntax)cached;

      var result = new ParameterListSyntax(SyntaxKind.ParameterList, openParenToken, parameters.Node, closeParenToken);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public static BracketedParameterListSyntax BracketedParameterList(SyntaxToken openBracketToken, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<ParameterSyntax> parameters, SyntaxToken closeBracketToken)
    {
#if DEBUG
      if (openBracketToken == null)
        throw new ArgumentNullException(nameof(openBracketToken));
      switch (openBracketToken.Kind)
      {
        case SyntaxKind.OpenBracketToken:
          break;
        default:
          throw new ArgumentException(nameof(openBracketToken));
      }
      if (closeBracketToken == null)
        throw new ArgumentNullException(nameof(closeBracketToken));
      switch (closeBracketToken.Kind)
      {
        case SyntaxKind.CloseBracketToken:
          break;
        default:
          throw new ArgumentException(nameof(closeBracketToken));
      }
#endif

      int hash;
      var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.BracketedParameterList, openBracketToken, parameters.Node, closeBracketToken, out hash);
      if (cached != null) return (BracketedParameterListSyntax)cached;

      var result = new BracketedParameterListSyntax(SyntaxKind.BracketedParameterList, openBracketToken, parameters.Node, closeBracketToken);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public static ParameterSyntax Parameter(Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<AttributeListSyntax> attributeLists, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SyntaxToken> modifiers, TypeSyntax type, SyntaxToken identifier, EqualsValueClauseSyntax @default)
    {
#if DEBUG
      if (identifier == null)
        throw new ArgumentNullException(nameof(identifier));
      switch (identifier.Kind)
      {
        case SyntaxKind.IdentifierToken:
        case SyntaxKind.ArgListKeyword:
          break;
        default:
          throw new ArgumentException(nameof(identifier));
      }
#endif

      return new ParameterSyntax(SyntaxKind.Parameter, attributeLists.Node, modifiers.Node, type, identifier, @default);
    }

    public static IncompleteMemberSyntax IncompleteMember(Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<AttributeListSyntax> attributeLists, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SyntaxToken> modifiers, TypeSyntax type)
    {
#if DEBUG
#endif

      return new IncompleteMemberSyntax(SyntaxKind.IncompleteMember, attributeLists.Node, modifiers.Node, type);
    }

    public static SkippedTokensTriviaSyntax SkippedTokensTrivia(Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SyntaxToken> tokens)
    {
#if DEBUG
#endif

      return new SkippedTokensTriviaSyntax(SyntaxKind.SkippedTokensTrivia, tokens.Node);
    }

    public static DocumentationCommentTriviaSyntax DocumentationCommentTrivia(SyntaxKind kind, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<XmlNodeSyntax> content, SyntaxToken endOfComment)
    {
      switch (kind)
      {
        case SyntaxKind.SingleLineDocumentationCommentTrivia:
        case SyntaxKind.MultiLineDocumentationCommentTrivia:
          break;
        default:
          throw new ArgumentException(nameof(kind));
      }
#if DEBUG
      if (endOfComment == null)
        throw new ArgumentNullException(nameof(endOfComment));
      switch (endOfComment.Kind)
      {
        case SyntaxKind.EndOfDocumentationCommentToken:
          break;
        default:
          throw new ArgumentException(nameof(endOfComment));
      }
#endif

      return new DocumentationCommentTriviaSyntax(kind, content.Node, endOfComment);
    }

    public static TypeCrefSyntax TypeCref(TypeSyntax type)
    {
#if DEBUG
      if (type == null)
        throw new ArgumentNullException(nameof(type));
#endif

      int hash;
      var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.TypeCref, type, out hash);
      if (cached != null) return (TypeCrefSyntax)cached;

      var result = new TypeCrefSyntax(SyntaxKind.TypeCref, type);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public static QualifiedCrefSyntax QualifiedCref(TypeSyntax container, SyntaxToken dotToken, MemberCrefSyntax member)
    {
#if DEBUG
      if (container == null)
        throw new ArgumentNullException(nameof(container));
      if (dotToken == null)
        throw new ArgumentNullException(nameof(dotToken));
      switch (dotToken.Kind)
      {
        case SyntaxKind.DotToken:
          break;
        default:
          throw new ArgumentException(nameof(dotToken));
      }
      if (member == null)
        throw new ArgumentNullException(nameof(member));
#endif

      int hash;
      var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.QualifiedCref, container, dotToken, member, out hash);
      if (cached != null) return (QualifiedCrefSyntax)cached;

      var result = new QualifiedCrefSyntax(SyntaxKind.QualifiedCref, container, dotToken, member);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public static NameMemberCrefSyntax NameMemberCref(TypeSyntax name, CrefParameterListSyntax parameters)
    {
#if DEBUG
      if (name == null)
        throw new ArgumentNullException(nameof(name));
#endif

      int hash;
      var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.NameMemberCref, name, parameters, out hash);
      if (cached != null) return (NameMemberCrefSyntax)cached;

      var result = new NameMemberCrefSyntax(SyntaxKind.NameMemberCref, name, parameters);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public static IndexerMemberCrefSyntax IndexerMemberCref(SyntaxToken thisKeyword, CrefBracketedParameterListSyntax parameters)
    {
#if DEBUG
      if (thisKeyword == null)
        throw new ArgumentNullException(nameof(thisKeyword));
      switch (thisKeyword.Kind)
      {
        case SyntaxKind.ThisKeyword:
          break;
        default:
          throw new ArgumentException(nameof(thisKeyword));
      }
#endif

      int hash;
      var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.IndexerMemberCref, thisKeyword, parameters, out hash);
      if (cached != null) return (IndexerMemberCrefSyntax)cached;

      var result = new IndexerMemberCrefSyntax(SyntaxKind.IndexerMemberCref, thisKeyword, parameters);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public static OperatorMemberCrefSyntax OperatorMemberCref(SyntaxToken operatorKeyword, SyntaxToken operatorToken, CrefParameterListSyntax parameters)
    {
#if DEBUG
      if (operatorKeyword == null)
        throw new ArgumentNullException(nameof(operatorKeyword));
      switch (operatorKeyword.Kind)
      {
        case SyntaxKind.OperatorKeyword:
          break;
        default:
          throw new ArgumentException(nameof(operatorKeyword));
      }
      if (operatorToken == null)
        throw new ArgumentNullException(nameof(operatorToken));
      switch (operatorToken.Kind)
      {
        case SyntaxKind.PlusToken:
        case SyntaxKind.MinusToken:
        case SyntaxKind.ExclamationToken:
        case SyntaxKind.TildeToken:
        case SyntaxKind.PlusPlusToken:
        case SyntaxKind.MinusMinusToken:
        case SyntaxKind.AsteriskToken:
        case SyntaxKind.SlashToken:
        case SyntaxKind.PercentToken:
        case SyntaxKind.LessThanLessThanToken:
        case SyntaxKind.GreaterThanGreaterThanToken:
        case SyntaxKind.BarToken:
        case SyntaxKind.AmpersandToken:
        case SyntaxKind.CaretToken:
        case SyntaxKind.EqualsEqualsToken:
        case SyntaxKind.ExclamationEqualsToken:
        case SyntaxKind.LessThanToken:
        case SyntaxKind.LessThanEqualsToken:
        case SyntaxKind.GreaterThanToken:
        case SyntaxKind.GreaterThanEqualsToken:
        case SyntaxKind.FalseKeyword:
        case SyntaxKind.TrueKeyword:
          break;
        default:
          throw new ArgumentException(nameof(operatorToken));
      }
#endif

      int hash;
      var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.OperatorMemberCref, operatorKeyword, operatorToken, parameters, out hash);
      if (cached != null) return (OperatorMemberCrefSyntax)cached;

      var result = new OperatorMemberCrefSyntax(SyntaxKind.OperatorMemberCref, operatorKeyword, operatorToken, parameters);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public static ConversionOperatorMemberCrefSyntax ConversionOperatorMemberCref(SyntaxToken implicitOrExplicitKeyword, SyntaxToken operatorKeyword, TypeSyntax type, CrefParameterListSyntax parameters)
    {
#if DEBUG
      if (implicitOrExplicitKeyword == null)
        throw new ArgumentNullException(nameof(implicitOrExplicitKeyword));
      switch (implicitOrExplicitKeyword.Kind)
      {
        case SyntaxKind.ImplicitKeyword:
        case SyntaxKind.ExplicitKeyword:
          break;
        default:
          throw new ArgumentException(nameof(implicitOrExplicitKeyword));
      }
      if (operatorKeyword == null)
        throw new ArgumentNullException(nameof(operatorKeyword));
      switch (operatorKeyword.Kind)
      {
        case SyntaxKind.OperatorKeyword:
          break;
        default:
          throw new ArgumentException(nameof(operatorKeyword));
      }
      if (type == null)
        throw new ArgumentNullException(nameof(type));
#endif

      return new ConversionOperatorMemberCrefSyntax(SyntaxKind.ConversionOperatorMemberCref, implicitOrExplicitKeyword, operatorKeyword, type, parameters);
    }

    public static CrefParameterListSyntax CrefParameterList(SyntaxToken openParenToken, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<CrefParameterSyntax> parameters, SyntaxToken closeParenToken)
    {
#if DEBUG
      if (openParenToken == null)
        throw new ArgumentNullException(nameof(openParenToken));
      switch (openParenToken.Kind)
      {
        case SyntaxKind.OpenParenToken:
          break;
        default:
          throw new ArgumentException(nameof(openParenToken));
      }
      if (closeParenToken == null)
        throw new ArgumentNullException(nameof(closeParenToken));
      switch (closeParenToken.Kind)
      {
        case SyntaxKind.CloseParenToken:
          break;
        default:
          throw new ArgumentException(nameof(closeParenToken));
      }
#endif

      int hash;
      var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.CrefParameterList, openParenToken, parameters.Node, closeParenToken, out hash);
      if (cached != null) return (CrefParameterListSyntax)cached;

      var result = new CrefParameterListSyntax(SyntaxKind.CrefParameterList, openParenToken, parameters.Node, closeParenToken);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public static CrefBracketedParameterListSyntax CrefBracketedParameterList(SyntaxToken openBracketToken, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<CrefParameterSyntax> parameters, SyntaxToken closeBracketToken)
    {
#if DEBUG
      if (openBracketToken == null)
        throw new ArgumentNullException(nameof(openBracketToken));
      switch (openBracketToken.Kind)
      {
        case SyntaxKind.OpenBracketToken:
          break;
        default:
          throw new ArgumentException(nameof(openBracketToken));
      }
      if (closeBracketToken == null)
        throw new ArgumentNullException(nameof(closeBracketToken));
      switch (closeBracketToken.Kind)
      {
        case SyntaxKind.CloseBracketToken:
          break;
        default:
          throw new ArgumentException(nameof(closeBracketToken));
      }
#endif

      int hash;
      var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.CrefBracketedParameterList, openBracketToken, parameters.Node, closeBracketToken, out hash);
      if (cached != null) return (CrefBracketedParameterListSyntax)cached;

      var result = new CrefBracketedParameterListSyntax(SyntaxKind.CrefBracketedParameterList, openBracketToken, parameters.Node, closeBracketToken);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public static CrefParameterSyntax CrefParameter(SyntaxToken refKindKeyword, TypeSyntax type)
    {
#if DEBUG
      if (refKindKeyword != null)
      {
      switch (refKindKeyword.Kind)
      {
        case SyntaxKind.RefKeyword:
        case SyntaxKind.OutKeyword:
        case SyntaxKind.InKeyword:
        case SyntaxKind.None:
          break;
        default:
          throw new ArgumentException(nameof(refKindKeyword));
      }
      }
      if (type == null)
        throw new ArgumentNullException(nameof(type));
#endif

      int hash;
      var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.CrefParameter, refKindKeyword, type, out hash);
      if (cached != null) return (CrefParameterSyntax)cached;

      var result = new CrefParameterSyntax(SyntaxKind.CrefParameter, refKindKeyword, type);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public static XmlElementSyntax XmlElement(XmlElementStartTagSyntax startTag, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<XmlNodeSyntax> content, XmlElementEndTagSyntax endTag)
    {
#if DEBUG
      if (startTag == null)
        throw new ArgumentNullException(nameof(startTag));
      if (endTag == null)
        throw new ArgumentNullException(nameof(endTag));
#endif

      int hash;
      var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.XmlElement, startTag, content.Node, endTag, out hash);
      if (cached != null) return (XmlElementSyntax)cached;

      var result = new XmlElementSyntax(SyntaxKind.XmlElement, startTag, content.Node, endTag);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public static XmlElementStartTagSyntax XmlElementStartTag(SyntaxToken lessThanToken, XmlNameSyntax name, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<XmlAttributeSyntax> attributes, SyntaxToken greaterThanToken)
    {
#if DEBUG
      if (lessThanToken == null)
        throw new ArgumentNullException(nameof(lessThanToken));
      switch (lessThanToken.Kind)
      {
        case SyntaxKind.LessThanToken:
          break;
        default:
          throw new ArgumentException(nameof(lessThanToken));
      }
      if (name == null)
        throw new ArgumentNullException(nameof(name));
      if (greaterThanToken == null)
        throw new ArgumentNullException(nameof(greaterThanToken));
      switch (greaterThanToken.Kind)
      {
        case SyntaxKind.GreaterThanToken:
          break;
        default:
          throw new ArgumentException(nameof(greaterThanToken));
      }
#endif

      return new XmlElementStartTagSyntax(SyntaxKind.XmlElementStartTag, lessThanToken, name, attributes.Node, greaterThanToken);
    }

    public static XmlElementEndTagSyntax XmlElementEndTag(SyntaxToken lessThanSlashToken, XmlNameSyntax name, SyntaxToken greaterThanToken)
    {
#if DEBUG
      if (lessThanSlashToken == null)
        throw new ArgumentNullException(nameof(lessThanSlashToken));
      switch (lessThanSlashToken.Kind)
      {
        case SyntaxKind.LessThanSlashToken:
          break;
        default:
          throw new ArgumentException(nameof(lessThanSlashToken));
      }
      if (name == null)
        throw new ArgumentNullException(nameof(name));
      if (greaterThanToken == null)
        throw new ArgumentNullException(nameof(greaterThanToken));
      switch (greaterThanToken.Kind)
      {
        case SyntaxKind.GreaterThanToken:
          break;
        default:
          throw new ArgumentException(nameof(greaterThanToken));
      }
#endif

      int hash;
      var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.XmlElementEndTag, lessThanSlashToken, name, greaterThanToken, out hash);
      if (cached != null) return (XmlElementEndTagSyntax)cached;

      var result = new XmlElementEndTagSyntax(SyntaxKind.XmlElementEndTag, lessThanSlashToken, name, greaterThanToken);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public static XmlEmptyElementSyntax XmlEmptyElement(SyntaxToken lessThanToken, XmlNameSyntax name, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<XmlAttributeSyntax> attributes, SyntaxToken slashGreaterThanToken)
    {
#if DEBUG
      if (lessThanToken == null)
        throw new ArgumentNullException(nameof(lessThanToken));
      switch (lessThanToken.Kind)
      {
        case SyntaxKind.LessThanToken:
          break;
        default:
          throw new ArgumentException(nameof(lessThanToken));
      }
      if (name == null)
        throw new ArgumentNullException(nameof(name));
      if (slashGreaterThanToken == null)
        throw new ArgumentNullException(nameof(slashGreaterThanToken));
      switch (slashGreaterThanToken.Kind)
      {
        case SyntaxKind.SlashGreaterThanToken:
          break;
        default:
          throw new ArgumentException(nameof(slashGreaterThanToken));
      }
#endif

      return new XmlEmptyElementSyntax(SyntaxKind.XmlEmptyElement, lessThanToken, name, attributes.Node, slashGreaterThanToken);
    }

    public static XmlNameSyntax XmlName(XmlPrefixSyntax prefix, SyntaxToken localName)
    {
#if DEBUG
      if (localName == null)
        throw new ArgumentNullException(nameof(localName));
      switch (localName.Kind)
      {
        case SyntaxKind.IdentifierToken:
          break;
        default:
          throw new ArgumentException(nameof(localName));
      }
#endif

      int hash;
      var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.XmlName, prefix, localName, out hash);
      if (cached != null) return (XmlNameSyntax)cached;

      var result = new XmlNameSyntax(SyntaxKind.XmlName, prefix, localName);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public static XmlPrefixSyntax XmlPrefix(SyntaxToken prefix, SyntaxToken colonToken)
    {
#if DEBUG
      if (prefix == null)
        throw new ArgumentNullException(nameof(prefix));
      switch (prefix.Kind)
      {
        case SyntaxKind.IdentifierToken:
          break;
        default:
          throw new ArgumentException(nameof(prefix));
      }
      if (colonToken == null)
        throw new ArgumentNullException(nameof(colonToken));
      switch (colonToken.Kind)
      {
        case SyntaxKind.ColonToken:
          break;
        default:
          throw new ArgumentException(nameof(colonToken));
      }
#endif

      int hash;
      var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.XmlPrefix, prefix, colonToken, out hash);
      if (cached != null) return (XmlPrefixSyntax)cached;

      var result = new XmlPrefixSyntax(SyntaxKind.XmlPrefix, prefix, colonToken);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public static XmlTextAttributeSyntax XmlTextAttribute(XmlNameSyntax name, SyntaxToken equalsToken, SyntaxToken startQuoteToken, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SyntaxToken> textTokens, SyntaxToken endQuoteToken)
    {
#if DEBUG
      if (name == null)
        throw new ArgumentNullException(nameof(name));
      if (equalsToken == null)
        throw new ArgumentNullException(nameof(equalsToken));
      switch (equalsToken.Kind)
      {
        case SyntaxKind.EqualsToken:
          break;
        default:
          throw new ArgumentException(nameof(equalsToken));
      }
      if (startQuoteToken == null)
        throw new ArgumentNullException(nameof(startQuoteToken));
      switch (startQuoteToken.Kind)
      {
        case SyntaxKind.SingleQuoteToken:
        case SyntaxKind.DoubleQuoteToken:
          break;
        default:
          throw new ArgumentException(nameof(startQuoteToken));
      }
      if (endQuoteToken == null)
        throw new ArgumentNullException(nameof(endQuoteToken));
      switch (endQuoteToken.Kind)
      {
        case SyntaxKind.SingleQuoteToken:
        case SyntaxKind.DoubleQuoteToken:
          break;
        default:
          throw new ArgumentException(nameof(endQuoteToken));
      }
#endif

      return new XmlTextAttributeSyntax(SyntaxKind.XmlTextAttribute, name, equalsToken, startQuoteToken, textTokens.Node, endQuoteToken);
    }

    public static XmlCrefAttributeSyntax XmlCrefAttribute(XmlNameSyntax name, SyntaxToken equalsToken, SyntaxToken startQuoteToken, CrefSyntax cref, SyntaxToken endQuoteToken)
    {
#if DEBUG
      if (name == null)
        throw new ArgumentNullException(nameof(name));
      if (equalsToken == null)
        throw new ArgumentNullException(nameof(equalsToken));
      switch (equalsToken.Kind)
      {
        case SyntaxKind.EqualsToken:
          break;
        default:
          throw new ArgumentException(nameof(equalsToken));
      }
      if (startQuoteToken == null)
        throw new ArgumentNullException(nameof(startQuoteToken));
      switch (startQuoteToken.Kind)
      {
        case SyntaxKind.SingleQuoteToken:
        case SyntaxKind.DoubleQuoteToken:
          break;
        default:
          throw new ArgumentException(nameof(startQuoteToken));
      }
      if (cref == null)
        throw new ArgumentNullException(nameof(cref));
      if (endQuoteToken == null)
        throw new ArgumentNullException(nameof(endQuoteToken));
      switch (endQuoteToken.Kind)
      {
        case SyntaxKind.SingleQuoteToken:
        case SyntaxKind.DoubleQuoteToken:
          break;
        default:
          throw new ArgumentException(nameof(endQuoteToken));
      }
#endif

      return new XmlCrefAttributeSyntax(SyntaxKind.XmlCrefAttribute, name, equalsToken, startQuoteToken, cref, endQuoteToken);
    }

    public static XmlNameAttributeSyntax XmlNameAttribute(XmlNameSyntax name, SyntaxToken equalsToken, SyntaxToken startQuoteToken, IdentifierNameSyntax identifier, SyntaxToken endQuoteToken)
    {
#if DEBUG
      if (name == null)
        throw new ArgumentNullException(nameof(name));
      if (equalsToken == null)
        throw new ArgumentNullException(nameof(equalsToken));
      switch (equalsToken.Kind)
      {
        case SyntaxKind.EqualsToken:
          break;
        default:
          throw new ArgumentException(nameof(equalsToken));
      }
      if (startQuoteToken == null)
        throw new ArgumentNullException(nameof(startQuoteToken));
      switch (startQuoteToken.Kind)
      {
        case SyntaxKind.SingleQuoteToken:
        case SyntaxKind.DoubleQuoteToken:
          break;
        default:
          throw new ArgumentException(nameof(startQuoteToken));
      }
      if (identifier == null)
        throw new ArgumentNullException(nameof(identifier));
      if (endQuoteToken == null)
        throw new ArgumentNullException(nameof(endQuoteToken));
      switch (endQuoteToken.Kind)
      {
        case SyntaxKind.SingleQuoteToken:
        case SyntaxKind.DoubleQuoteToken:
          break;
        default:
          throw new ArgumentException(nameof(endQuoteToken));
      }
#endif

      return new XmlNameAttributeSyntax(SyntaxKind.XmlNameAttribute, name, equalsToken, startQuoteToken, identifier, endQuoteToken);
    }

    public static XmlTextSyntax XmlText(Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SyntaxToken> textTokens)
    {
#if DEBUG
#endif

      int hash;
      var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.XmlText, textTokens.Node, out hash);
      if (cached != null) return (XmlTextSyntax)cached;

      var result = new XmlTextSyntax(SyntaxKind.XmlText, textTokens.Node);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public static XmlCDataSectionSyntax XmlCDataSection(SyntaxToken startCDataToken, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SyntaxToken> textTokens, SyntaxToken endCDataToken)
    {
#if DEBUG
      if (startCDataToken == null)
        throw new ArgumentNullException(nameof(startCDataToken));
      switch (startCDataToken.Kind)
      {
        case SyntaxKind.XmlCDataStartToken:
          break;
        default:
          throw new ArgumentException(nameof(startCDataToken));
      }
      if (endCDataToken == null)
        throw new ArgumentNullException(nameof(endCDataToken));
      switch (endCDataToken.Kind)
      {
        case SyntaxKind.XmlCDataEndToken:
          break;
        default:
          throw new ArgumentException(nameof(endCDataToken));
      }
#endif

      int hash;
      var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.XmlCDataSection, startCDataToken, textTokens.Node, endCDataToken, out hash);
      if (cached != null) return (XmlCDataSectionSyntax)cached;

      var result = new XmlCDataSectionSyntax(SyntaxKind.XmlCDataSection, startCDataToken, textTokens.Node, endCDataToken);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public static XmlProcessingInstructionSyntax XmlProcessingInstruction(SyntaxToken startProcessingInstructionToken, XmlNameSyntax name, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SyntaxToken> textTokens, SyntaxToken endProcessingInstructionToken)
    {
#if DEBUG
      if (startProcessingInstructionToken == null)
        throw new ArgumentNullException(nameof(startProcessingInstructionToken));
      switch (startProcessingInstructionToken.Kind)
      {
        case SyntaxKind.XmlProcessingInstructionStartToken:
          break;
        default:
          throw new ArgumentException(nameof(startProcessingInstructionToken));
      }
      if (name == null)
        throw new ArgumentNullException(nameof(name));
      if (endProcessingInstructionToken == null)
        throw new ArgumentNullException(nameof(endProcessingInstructionToken));
      switch (endProcessingInstructionToken.Kind)
      {
        case SyntaxKind.XmlProcessingInstructionEndToken:
          break;
        default:
          throw new ArgumentException(nameof(endProcessingInstructionToken));
      }
#endif

      return new XmlProcessingInstructionSyntax(SyntaxKind.XmlProcessingInstruction, startProcessingInstructionToken, name, textTokens.Node, endProcessingInstructionToken);
    }

    public static XmlCommentSyntax XmlComment(SyntaxToken lessThanExclamationMinusMinusToken, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SyntaxToken> textTokens, SyntaxToken minusMinusGreaterThanToken)
    {
#if DEBUG
      if (lessThanExclamationMinusMinusToken == null)
        throw new ArgumentNullException(nameof(lessThanExclamationMinusMinusToken));
      switch (lessThanExclamationMinusMinusToken.Kind)
      {
        case SyntaxKind.XmlCommentStartToken:
          break;
        default:
          throw new ArgumentException(nameof(lessThanExclamationMinusMinusToken));
      }
      if (minusMinusGreaterThanToken == null)
        throw new ArgumentNullException(nameof(minusMinusGreaterThanToken));
      switch (minusMinusGreaterThanToken.Kind)
      {
        case SyntaxKind.XmlCommentEndToken:
          break;
        default:
          throw new ArgumentException(nameof(minusMinusGreaterThanToken));
      }
#endif

      int hash;
      var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.XmlComment, lessThanExclamationMinusMinusToken, textTokens.Node, minusMinusGreaterThanToken, out hash);
      if (cached != null) return (XmlCommentSyntax)cached;

      var result = new XmlCommentSyntax(SyntaxKind.XmlComment, lessThanExclamationMinusMinusToken, textTokens.Node, minusMinusGreaterThanToken);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public static IfDirectiveTriviaSyntax IfDirectiveTrivia(SyntaxToken hashToken, SyntaxToken ifKeyword, ExpressionSyntax condition, SyntaxToken endOfDirectiveToken, bool isActive, bool branchTaken, bool conditionValue)
    {
#if DEBUG
      if (hashToken == null)
        throw new ArgumentNullException(nameof(hashToken));
      switch (hashToken.Kind)
      {
        case SyntaxKind.HashToken:
          break;
        default:
          throw new ArgumentException(nameof(hashToken));
      }
      if (ifKeyword == null)
        throw new ArgumentNullException(nameof(ifKeyword));
      switch (ifKeyword.Kind)
      {
        case SyntaxKind.IfKeyword:
          break;
        default:
          throw new ArgumentException(nameof(ifKeyword));
      }
      if (condition == null)
        throw new ArgumentNullException(nameof(condition));
      if (endOfDirectiveToken == null)
        throw new ArgumentNullException(nameof(endOfDirectiveToken));
      switch (endOfDirectiveToken.Kind)
      {
        case SyntaxKind.EndOfDirectiveToken:
          break;
        default:
          throw new ArgumentException(nameof(endOfDirectiveToken));
      }
#endif

      return new IfDirectiveTriviaSyntax(SyntaxKind.IfDirectiveTrivia, hashToken, ifKeyword, condition, endOfDirectiveToken, isActive, branchTaken, conditionValue);
    }

    public static ElifDirectiveTriviaSyntax ElifDirectiveTrivia(SyntaxToken hashToken, SyntaxToken elifKeyword, ExpressionSyntax condition, SyntaxToken endOfDirectiveToken, bool isActive, bool branchTaken, bool conditionValue)
    {
#if DEBUG
      if (hashToken == null)
        throw new ArgumentNullException(nameof(hashToken));
      switch (hashToken.Kind)
      {
        case SyntaxKind.HashToken:
          break;
        default:
          throw new ArgumentException(nameof(hashToken));
      }
      if (elifKeyword == null)
        throw new ArgumentNullException(nameof(elifKeyword));
      switch (elifKeyword.Kind)
      {
        case SyntaxKind.ElifKeyword:
          break;
        default:
          throw new ArgumentException(nameof(elifKeyword));
      }
      if (condition == null)
        throw new ArgumentNullException(nameof(condition));
      if (endOfDirectiveToken == null)
        throw new ArgumentNullException(nameof(endOfDirectiveToken));
      switch (endOfDirectiveToken.Kind)
      {
        case SyntaxKind.EndOfDirectiveToken:
          break;
        default:
          throw new ArgumentException(nameof(endOfDirectiveToken));
      }
#endif

      return new ElifDirectiveTriviaSyntax(SyntaxKind.ElifDirectiveTrivia, hashToken, elifKeyword, condition, endOfDirectiveToken, isActive, branchTaken, conditionValue);
    }

    public static ElseDirectiveTriviaSyntax ElseDirectiveTrivia(SyntaxToken hashToken, SyntaxToken elseKeyword, SyntaxToken endOfDirectiveToken, bool isActive, bool branchTaken)
    {
#if DEBUG
      if (hashToken == null)
        throw new ArgumentNullException(nameof(hashToken));
      switch (hashToken.Kind)
      {
        case SyntaxKind.HashToken:
          break;
        default:
          throw new ArgumentException(nameof(hashToken));
      }
      if (elseKeyword == null)
        throw new ArgumentNullException(nameof(elseKeyword));
      switch (elseKeyword.Kind)
      {
        case SyntaxKind.ElseKeyword:
          break;
        default:
          throw new ArgumentException(nameof(elseKeyword));
      }
      if (endOfDirectiveToken == null)
        throw new ArgumentNullException(nameof(endOfDirectiveToken));
      switch (endOfDirectiveToken.Kind)
      {
        case SyntaxKind.EndOfDirectiveToken:
          break;
        default:
          throw new ArgumentException(nameof(endOfDirectiveToken));
      }
#endif

      return new ElseDirectiveTriviaSyntax(SyntaxKind.ElseDirectiveTrivia, hashToken, elseKeyword, endOfDirectiveToken, isActive, branchTaken);
    }

    public static EndIfDirectiveTriviaSyntax EndIfDirectiveTrivia(SyntaxToken hashToken, SyntaxToken endIfKeyword, SyntaxToken endOfDirectiveToken, bool isActive)
    {
#if DEBUG
      if (hashToken == null)
        throw new ArgumentNullException(nameof(hashToken));
      switch (hashToken.Kind)
      {
        case SyntaxKind.HashToken:
          break;
        default:
          throw new ArgumentException(nameof(hashToken));
      }
      if (endIfKeyword == null)
        throw new ArgumentNullException(nameof(endIfKeyword));
      switch (endIfKeyword.Kind)
      {
        case SyntaxKind.EndIfKeyword:
          break;
        default:
          throw new ArgumentException(nameof(endIfKeyword));
      }
      if (endOfDirectiveToken == null)
        throw new ArgumentNullException(nameof(endOfDirectiveToken));
      switch (endOfDirectiveToken.Kind)
      {
        case SyntaxKind.EndOfDirectiveToken:
          break;
        default:
          throw new ArgumentException(nameof(endOfDirectiveToken));
      }
#endif

      return new EndIfDirectiveTriviaSyntax(SyntaxKind.EndIfDirectiveTrivia, hashToken, endIfKeyword, endOfDirectiveToken, isActive);
    }

    public static RegionDirectiveTriviaSyntax RegionDirectiveTrivia(SyntaxToken hashToken, SyntaxToken regionKeyword, SyntaxToken endOfDirectiveToken, bool isActive)
    {
#if DEBUG
      if (hashToken == null)
        throw new ArgumentNullException(nameof(hashToken));
      switch (hashToken.Kind)
      {
        case SyntaxKind.HashToken:
          break;
        default:
          throw new ArgumentException(nameof(hashToken));
      }
      if (regionKeyword == null)
        throw new ArgumentNullException(nameof(regionKeyword));
      switch (regionKeyword.Kind)
      {
        case SyntaxKind.RegionKeyword:
          break;
        default:
          throw new ArgumentException(nameof(regionKeyword));
      }
      if (endOfDirectiveToken == null)
        throw new ArgumentNullException(nameof(endOfDirectiveToken));
      switch (endOfDirectiveToken.Kind)
      {
        case SyntaxKind.EndOfDirectiveToken:
          break;
        default:
          throw new ArgumentException(nameof(endOfDirectiveToken));
      }
#endif

      return new RegionDirectiveTriviaSyntax(SyntaxKind.RegionDirectiveTrivia, hashToken, regionKeyword, endOfDirectiveToken, isActive);
    }

    public static EndRegionDirectiveTriviaSyntax EndRegionDirectiveTrivia(SyntaxToken hashToken, SyntaxToken endRegionKeyword, SyntaxToken endOfDirectiveToken, bool isActive)
    {
#if DEBUG
      if (hashToken == null)
        throw new ArgumentNullException(nameof(hashToken));
      switch (hashToken.Kind)
      {
        case SyntaxKind.HashToken:
          break;
        default:
          throw new ArgumentException(nameof(hashToken));
      }
      if (endRegionKeyword == null)
        throw new ArgumentNullException(nameof(endRegionKeyword));
      switch (endRegionKeyword.Kind)
      {
        case SyntaxKind.EndRegionKeyword:
          break;
        default:
          throw new ArgumentException(nameof(endRegionKeyword));
      }
      if (endOfDirectiveToken == null)
        throw new ArgumentNullException(nameof(endOfDirectiveToken));
      switch (endOfDirectiveToken.Kind)
      {
        case SyntaxKind.EndOfDirectiveToken:
          break;
        default:
          throw new ArgumentException(nameof(endOfDirectiveToken));
      }
#endif

      return new EndRegionDirectiveTriviaSyntax(SyntaxKind.EndRegionDirectiveTrivia, hashToken, endRegionKeyword, endOfDirectiveToken, isActive);
    }

    public static ErrorDirectiveTriviaSyntax ErrorDirectiveTrivia(SyntaxToken hashToken, SyntaxToken errorKeyword, SyntaxToken endOfDirectiveToken, bool isActive)
    {
#if DEBUG
      if (hashToken == null)
        throw new ArgumentNullException(nameof(hashToken));
      switch (hashToken.Kind)
      {
        case SyntaxKind.HashToken:
          break;
        default:
          throw new ArgumentException(nameof(hashToken));
      }
      if (errorKeyword == null)
        throw new ArgumentNullException(nameof(errorKeyword));
      switch (errorKeyword.Kind)
      {
        case SyntaxKind.ErrorKeyword:
          break;
        default:
          throw new ArgumentException(nameof(errorKeyword));
      }
      if (endOfDirectiveToken == null)
        throw new ArgumentNullException(nameof(endOfDirectiveToken));
      switch (endOfDirectiveToken.Kind)
      {
        case SyntaxKind.EndOfDirectiveToken:
          break;
        default:
          throw new ArgumentException(nameof(endOfDirectiveToken));
      }
#endif

      return new ErrorDirectiveTriviaSyntax(SyntaxKind.ErrorDirectiveTrivia, hashToken, errorKeyword, endOfDirectiveToken, isActive);
    }

    public static WarningDirectiveTriviaSyntax WarningDirectiveTrivia(SyntaxToken hashToken, SyntaxToken warningKeyword, SyntaxToken endOfDirectiveToken, bool isActive)
    {
#if DEBUG
      if (hashToken == null)
        throw new ArgumentNullException(nameof(hashToken));
      switch (hashToken.Kind)
      {
        case SyntaxKind.HashToken:
          break;
        default:
          throw new ArgumentException(nameof(hashToken));
      }
      if (warningKeyword == null)
        throw new ArgumentNullException(nameof(warningKeyword));
      switch (warningKeyword.Kind)
      {
        case SyntaxKind.WarningKeyword:
          break;
        default:
          throw new ArgumentException(nameof(warningKeyword));
      }
      if (endOfDirectiveToken == null)
        throw new ArgumentNullException(nameof(endOfDirectiveToken));
      switch (endOfDirectiveToken.Kind)
      {
        case SyntaxKind.EndOfDirectiveToken:
          break;
        default:
          throw new ArgumentException(nameof(endOfDirectiveToken));
      }
#endif

      return new WarningDirectiveTriviaSyntax(SyntaxKind.WarningDirectiveTrivia, hashToken, warningKeyword, endOfDirectiveToken, isActive);
    }

    public static BadDirectiveTriviaSyntax BadDirectiveTrivia(SyntaxToken hashToken, SyntaxToken identifier, SyntaxToken endOfDirectiveToken, bool isActive)
    {
#if DEBUG
      if (hashToken == null)
        throw new ArgumentNullException(nameof(hashToken));
      switch (hashToken.Kind)
      {
        case SyntaxKind.HashToken:
          break;
        default:
          throw new ArgumentException(nameof(hashToken));
      }
      if (identifier == null)
        throw new ArgumentNullException(nameof(identifier));
      if (endOfDirectiveToken == null)
        throw new ArgumentNullException(nameof(endOfDirectiveToken));
      switch (endOfDirectiveToken.Kind)
      {
        case SyntaxKind.EndOfDirectiveToken:
          break;
        default:
          throw new ArgumentException(nameof(endOfDirectiveToken));
      }
#endif

      return new BadDirectiveTriviaSyntax(SyntaxKind.BadDirectiveTrivia, hashToken, identifier, endOfDirectiveToken, isActive);
    }

    public static DefineDirectiveTriviaSyntax DefineDirectiveTrivia(SyntaxToken hashToken, SyntaxToken defineKeyword, SyntaxToken name, SyntaxToken endOfDirectiveToken, bool isActive)
    {
#if DEBUG
      if (hashToken == null)
        throw new ArgumentNullException(nameof(hashToken));
      switch (hashToken.Kind)
      {
        case SyntaxKind.HashToken:
          break;
        default:
          throw new ArgumentException(nameof(hashToken));
      }
      if (defineKeyword == null)
        throw new ArgumentNullException(nameof(defineKeyword));
      switch (defineKeyword.Kind)
      {
        case SyntaxKind.DefineKeyword:
          break;
        default:
          throw new ArgumentException(nameof(defineKeyword));
      }
      if (name == null)
        throw new ArgumentNullException(nameof(name));
      switch (name.Kind)
      {
        case SyntaxKind.IdentifierToken:
          break;
        default:
          throw new ArgumentException(nameof(name));
      }
      if (endOfDirectiveToken == null)
        throw new ArgumentNullException(nameof(endOfDirectiveToken));
      switch (endOfDirectiveToken.Kind)
      {
        case SyntaxKind.EndOfDirectiveToken:
          break;
        default:
          throw new ArgumentException(nameof(endOfDirectiveToken));
      }
#endif

      return new DefineDirectiveTriviaSyntax(SyntaxKind.DefineDirectiveTrivia, hashToken, defineKeyword, name, endOfDirectiveToken, isActive);
    }

    public static UndefDirectiveTriviaSyntax UndefDirectiveTrivia(SyntaxToken hashToken, SyntaxToken undefKeyword, SyntaxToken name, SyntaxToken endOfDirectiveToken, bool isActive)
    {
#if DEBUG
      if (hashToken == null)
        throw new ArgumentNullException(nameof(hashToken));
      switch (hashToken.Kind)
      {
        case SyntaxKind.HashToken:
          break;
        default:
          throw new ArgumentException(nameof(hashToken));
      }
      if (undefKeyword == null)
        throw new ArgumentNullException(nameof(undefKeyword));
      switch (undefKeyword.Kind)
      {
        case SyntaxKind.UndefKeyword:
          break;
        default:
          throw new ArgumentException(nameof(undefKeyword));
      }
      if (name == null)
        throw new ArgumentNullException(nameof(name));
      switch (name.Kind)
      {
        case SyntaxKind.IdentifierToken:
          break;
        default:
          throw new ArgumentException(nameof(name));
      }
      if (endOfDirectiveToken == null)
        throw new ArgumentNullException(nameof(endOfDirectiveToken));
      switch (endOfDirectiveToken.Kind)
      {
        case SyntaxKind.EndOfDirectiveToken:
          break;
        default:
          throw new ArgumentException(nameof(endOfDirectiveToken));
      }
#endif

      return new UndefDirectiveTriviaSyntax(SyntaxKind.UndefDirectiveTrivia, hashToken, undefKeyword, name, endOfDirectiveToken, isActive);
    }

    public static LineDirectiveTriviaSyntax LineDirectiveTrivia(SyntaxToken hashToken, SyntaxToken lineKeyword, SyntaxToken line, SyntaxToken file, SyntaxToken endOfDirectiveToken, bool isActive)
    {
#if DEBUG
      if (hashToken == null)
        throw new ArgumentNullException(nameof(hashToken));
      switch (hashToken.Kind)
      {
        case SyntaxKind.HashToken:
          break;
        default:
          throw new ArgumentException(nameof(hashToken));
      }
      if (lineKeyword == null)
        throw new ArgumentNullException(nameof(lineKeyword));
      switch (lineKeyword.Kind)
      {
        case SyntaxKind.LineKeyword:
          break;
        default:
          throw new ArgumentException(nameof(lineKeyword));
      }
      if (line == null)
        throw new ArgumentNullException(nameof(line));
      switch (line.Kind)
      {
        case SyntaxKind.NumericLiteralToken:
        case SyntaxKind.DefaultKeyword:
        case SyntaxKind.HiddenKeyword:
          break;
        default:
          throw new ArgumentException(nameof(line));
      }
      if (file != null)
      {
      switch (file.Kind)
      {
        case SyntaxKind.StringLiteralToken:
        case SyntaxKind.None:
          break;
        default:
          throw new ArgumentException(nameof(file));
      }
      }
      if (endOfDirectiveToken == null)
        throw new ArgumentNullException(nameof(endOfDirectiveToken));
      switch (endOfDirectiveToken.Kind)
      {
        case SyntaxKind.EndOfDirectiveToken:
          break;
        default:
          throw new ArgumentException(nameof(endOfDirectiveToken));
      }
#endif

      return new LineDirectiveTriviaSyntax(SyntaxKind.LineDirectiveTrivia, hashToken, lineKeyword, line, file, endOfDirectiveToken, isActive);
    }

    public static PragmaWarningDirectiveTriviaSyntax PragmaWarningDirectiveTrivia(SyntaxToken hashToken, SyntaxToken pragmaKeyword, SyntaxToken warningKeyword, SyntaxToken disableOrRestoreKeyword, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<ExpressionSyntax> errorCodes, SyntaxToken endOfDirectiveToken, bool isActive)
    {
#if DEBUG
      if (hashToken == null)
        throw new ArgumentNullException(nameof(hashToken));
      switch (hashToken.Kind)
      {
        case SyntaxKind.HashToken:
          break;
        default:
          throw new ArgumentException(nameof(hashToken));
      }
      if (pragmaKeyword == null)
        throw new ArgumentNullException(nameof(pragmaKeyword));
      switch (pragmaKeyword.Kind)
      {
        case SyntaxKind.PragmaKeyword:
          break;
        default:
          throw new ArgumentException(nameof(pragmaKeyword));
      }
      if (warningKeyword == null)
        throw new ArgumentNullException(nameof(warningKeyword));
      switch (warningKeyword.Kind)
      {
        case SyntaxKind.WarningKeyword:
          break;
        default:
          throw new ArgumentException(nameof(warningKeyword));
      }
      if (disableOrRestoreKeyword == null)
        throw new ArgumentNullException(nameof(disableOrRestoreKeyword));
      switch (disableOrRestoreKeyword.Kind)
      {
        case SyntaxKind.DisableKeyword:
        case SyntaxKind.RestoreKeyword:
          break;
        default:
          throw new ArgumentException(nameof(disableOrRestoreKeyword));
      }
      if (endOfDirectiveToken == null)
        throw new ArgumentNullException(nameof(endOfDirectiveToken));
      switch (endOfDirectiveToken.Kind)
      {
        case SyntaxKind.EndOfDirectiveToken:
          break;
        default:
          throw new ArgumentException(nameof(endOfDirectiveToken));
      }
#endif

      return new PragmaWarningDirectiveTriviaSyntax(SyntaxKind.PragmaWarningDirectiveTrivia, hashToken, pragmaKeyword, warningKeyword, disableOrRestoreKeyword, errorCodes.Node, endOfDirectiveToken, isActive);
    }

    public static PragmaChecksumDirectiveTriviaSyntax PragmaChecksumDirectiveTrivia(SyntaxToken hashToken, SyntaxToken pragmaKeyword, SyntaxToken checksumKeyword, SyntaxToken file, SyntaxToken guid, SyntaxToken bytes, SyntaxToken endOfDirectiveToken, bool isActive)
    {
#if DEBUG
      if (hashToken == null)
        throw new ArgumentNullException(nameof(hashToken));
      switch (hashToken.Kind)
      {
        case SyntaxKind.HashToken:
          break;
        default:
          throw new ArgumentException(nameof(hashToken));
      }
      if (pragmaKeyword == null)
        throw new ArgumentNullException(nameof(pragmaKeyword));
      switch (pragmaKeyword.Kind)
      {
        case SyntaxKind.PragmaKeyword:
          break;
        default:
          throw new ArgumentException(nameof(pragmaKeyword));
      }
      if (checksumKeyword == null)
        throw new ArgumentNullException(nameof(checksumKeyword));
      switch (checksumKeyword.Kind)
      {
        case SyntaxKind.ChecksumKeyword:
          break;
        default:
          throw new ArgumentException(nameof(checksumKeyword));
      }
      if (file == null)
        throw new ArgumentNullException(nameof(file));
      switch (file.Kind)
      {
        case SyntaxKind.StringLiteralToken:
          break;
        default:
          throw new ArgumentException(nameof(file));
      }
      if (guid == null)
        throw new ArgumentNullException(nameof(guid));
      switch (guid.Kind)
      {
        case SyntaxKind.StringLiteralToken:
          break;
        default:
          throw new ArgumentException(nameof(guid));
      }
      if (bytes == null)
        throw new ArgumentNullException(nameof(bytes));
      switch (bytes.Kind)
      {
        case SyntaxKind.StringLiteralToken:
          break;
        default:
          throw new ArgumentException(nameof(bytes));
      }
      if (endOfDirectiveToken == null)
        throw new ArgumentNullException(nameof(endOfDirectiveToken));
      switch (endOfDirectiveToken.Kind)
      {
        case SyntaxKind.EndOfDirectiveToken:
          break;
        default:
          throw new ArgumentException(nameof(endOfDirectiveToken));
      }
#endif

      return new PragmaChecksumDirectiveTriviaSyntax(SyntaxKind.PragmaChecksumDirectiveTrivia, hashToken, pragmaKeyword, checksumKeyword, file, guid, bytes, endOfDirectiveToken, isActive);
    }

    public static ReferenceDirectiveTriviaSyntax ReferenceDirectiveTrivia(SyntaxToken hashToken, SyntaxToken referenceKeyword, SyntaxToken file, SyntaxToken endOfDirectiveToken, bool isActive)
    {
#if DEBUG
      if (hashToken == null)
        throw new ArgumentNullException(nameof(hashToken));
      switch (hashToken.Kind)
      {
        case SyntaxKind.HashToken:
          break;
        default:
          throw new ArgumentException(nameof(hashToken));
      }
      if (referenceKeyword == null)
        throw new ArgumentNullException(nameof(referenceKeyword));
      switch (referenceKeyword.Kind)
      {
        case SyntaxKind.ReferenceKeyword:
          break;
        default:
          throw new ArgumentException(nameof(referenceKeyword));
      }
      if (file == null)
        throw new ArgumentNullException(nameof(file));
      switch (file.Kind)
      {
        case SyntaxKind.StringLiteralToken:
          break;
        default:
          throw new ArgumentException(nameof(file));
      }
      if (endOfDirectiveToken == null)
        throw new ArgumentNullException(nameof(endOfDirectiveToken));
      switch (endOfDirectiveToken.Kind)
      {
        case SyntaxKind.EndOfDirectiveToken:
          break;
        default:
          throw new ArgumentException(nameof(endOfDirectiveToken));
      }
#endif

      return new ReferenceDirectiveTriviaSyntax(SyntaxKind.ReferenceDirectiveTrivia, hashToken, referenceKeyword, file, endOfDirectiveToken, isActive);
    }

    public static LoadDirectiveTriviaSyntax LoadDirectiveTrivia(SyntaxToken hashToken, SyntaxToken loadKeyword, SyntaxToken file, SyntaxToken endOfDirectiveToken, bool isActive)
    {
#if DEBUG
      if (hashToken == null)
        throw new ArgumentNullException(nameof(hashToken));
      switch (hashToken.Kind)
      {
        case SyntaxKind.HashToken:
          break;
        default:
          throw new ArgumentException(nameof(hashToken));
      }
      if (loadKeyword == null)
        throw new ArgumentNullException(nameof(loadKeyword));
      switch (loadKeyword.Kind)
      {
        case SyntaxKind.LoadKeyword:
          break;
        default:
          throw new ArgumentException(nameof(loadKeyword));
      }
      if (file == null)
        throw new ArgumentNullException(nameof(file));
      switch (file.Kind)
      {
        case SyntaxKind.StringLiteralToken:
          break;
        default:
          throw new ArgumentException(nameof(file));
      }
      if (endOfDirectiveToken == null)
        throw new ArgumentNullException(nameof(endOfDirectiveToken));
      switch (endOfDirectiveToken.Kind)
      {
        case SyntaxKind.EndOfDirectiveToken:
          break;
        default:
          throw new ArgumentException(nameof(endOfDirectiveToken));
      }
#endif

      return new LoadDirectiveTriviaSyntax(SyntaxKind.LoadDirectiveTrivia, hashToken, loadKeyword, file, endOfDirectiveToken, isActive);
    }

    public static ShebangDirectiveTriviaSyntax ShebangDirectiveTrivia(SyntaxToken hashToken, SyntaxToken exclamationToken, SyntaxToken endOfDirectiveToken, bool isActive)
    {
#if DEBUG
      if (hashToken == null)
        throw new ArgumentNullException(nameof(hashToken));
      switch (hashToken.Kind)
      {
        case SyntaxKind.HashToken:
          break;
        default:
          throw new ArgumentException(nameof(hashToken));
      }
      if (exclamationToken == null)
        throw new ArgumentNullException(nameof(exclamationToken));
      switch (exclamationToken.Kind)
      {
        case SyntaxKind.ExclamationToken:
          break;
        default:
          throw new ArgumentException(nameof(exclamationToken));
      }
      if (endOfDirectiveToken == null)
        throw new ArgumentNullException(nameof(endOfDirectiveToken));
      switch (endOfDirectiveToken.Kind)
      {
        case SyntaxKind.EndOfDirectiveToken:
          break;
        default:
          throw new ArgumentException(nameof(endOfDirectiveToken));
      }
#endif

      return new ShebangDirectiveTriviaSyntax(SyntaxKind.ShebangDirectiveTrivia, hashToken, exclamationToken, endOfDirectiveToken, isActive);
    }

    public static NullableDirectiveTriviaSyntax NullableDirectiveTrivia(SyntaxToken hashToken, SyntaxToken nullableKeyword, SyntaxToken settingToken, SyntaxToken targetToken, SyntaxToken endOfDirectiveToken, bool isActive)
    {
#if DEBUG
      if (hashToken == null)
        throw new ArgumentNullException(nameof(hashToken));
      switch (hashToken.Kind)
      {
        case SyntaxKind.HashToken:
          break;
        default:
          throw new ArgumentException(nameof(hashToken));
      }
      if (nullableKeyword == null)
        throw new ArgumentNullException(nameof(nullableKeyword));
      switch (nullableKeyword.Kind)
      {
        case SyntaxKind.NullableKeyword:
          break;
        default:
          throw new ArgumentException(nameof(nullableKeyword));
      }
      if (settingToken == null)
        throw new ArgumentNullException(nameof(settingToken));
      switch (settingToken.Kind)
      {
        case SyntaxKind.EnableKeyword:
        case SyntaxKind.DisableKeyword:
        case SyntaxKind.RestoreKeyword:
          break;
        default:
          throw new ArgumentException(nameof(settingToken));
      }
      if (targetToken != null)
      {
      switch (targetToken.Kind)
      {
        case SyntaxKind.WarningsKeyword:
        case SyntaxKind.AnnotationsKeyword:
        case SyntaxKind.None:
          break;
        default:
          throw new ArgumentException(nameof(targetToken));
      }
      }
      if (endOfDirectiveToken == null)
        throw new ArgumentNullException(nameof(endOfDirectiveToken));
      switch (endOfDirectiveToken.Kind)
      {
        case SyntaxKind.EndOfDirectiveToken:
          break;
        default:
          throw new ArgumentException(nameof(endOfDirectiveToken));
      }
#endif

      return new NullableDirectiveTriviaSyntax(SyntaxKind.NullableDirectiveTrivia, hashToken, nullableKeyword, settingToken, targetToken, endOfDirectiveToken, isActive);
    }

    internal static IEnumerable<Type> GetNodeTypes()
    {
        return new Type[] {
           typeof(IdentifierNameSyntax),
           typeof(QualifiedNameSyntax),
           typeof(GenericNameSyntax),
           typeof(TypeArgumentListSyntax),
           typeof(AliasQualifiedNameSyntax),
           typeof(PredefinedTypeSyntax),
           typeof(ArrayTypeSyntax),
           typeof(ArrayRankSpecifierSyntax),
           typeof(PointerTypeSyntax),
           typeof(NullableTypeSyntax),
           typeof(TupleTypeSyntax),
           typeof(TupleElementSyntax),
           typeof(OmittedTypeArgumentSyntax),
           typeof(RefTypeSyntax),
           typeof(ParenthesizedExpressionSyntax),
           typeof(TupleExpressionSyntax),
           typeof(PrefixUnaryExpressionSyntax),
           typeof(AwaitExpressionSyntax),
           typeof(PostfixUnaryExpressionSyntax),
           typeof(MemberAccessExpressionSyntax),
           typeof(ConditionalAccessExpressionSyntax),
           typeof(MemberBindingExpressionSyntax),
           typeof(ElementBindingExpressionSyntax),
           typeof(RangeExpressionSyntax),
           typeof(ImplicitElementAccessSyntax),
           typeof(BinaryExpressionSyntax),
           typeof(AssignmentExpressionSyntax),
           typeof(ConditionalExpressionSyntax),
           typeof(ThisExpressionSyntax),
           typeof(BaseExpressionSyntax),
           typeof(LiteralExpressionSyntax),
           typeof(MakeRefExpressionSyntax),
           typeof(RefTypeExpressionSyntax),
           typeof(RefValueExpressionSyntax),
           typeof(CheckedExpressionSyntax),
           typeof(DefaultExpressionSyntax),
           typeof(TypeOfExpressionSyntax),
           typeof(SizeOfExpressionSyntax),
           typeof(InvocationExpressionSyntax),
           typeof(ElementAccessExpressionSyntax),
           typeof(ArgumentListSyntax),
           typeof(BracketedArgumentListSyntax),
           typeof(ArgumentSyntax),
           typeof(NameColonSyntax),
           typeof(DeclarationExpressionSyntax),
           typeof(CastExpressionSyntax),
           typeof(AnonymousMethodExpressionSyntax),
           typeof(SimpleLambdaExpressionSyntax),
           typeof(RefExpressionSyntax),
           typeof(ParenthesizedLambdaExpressionSyntax),
           typeof(InitializerExpressionSyntax),
           typeof(ObjectCreationExpressionSyntax),
           typeof(AnonymousObjectMemberDeclaratorSyntax),
           typeof(AnonymousObjectCreationExpressionSyntax),
           typeof(ArrayCreationExpressionSyntax),
           typeof(ImplicitArrayCreationExpressionSyntax),
           typeof(StackAllocArrayCreationExpressionSyntax),
           typeof(ImplicitStackAllocArrayCreationExpressionSyntax),
           typeof(QueryExpressionSyntax),
           typeof(QueryBodySyntax),
           typeof(FromClauseSyntax),
           typeof(LetClauseSyntax),
           typeof(JoinClauseSyntax),
           typeof(JoinIntoClauseSyntax),
           typeof(WhereClauseSyntax),
           typeof(OrderByClauseSyntax),
           typeof(OrderingSyntax),
           typeof(SelectClauseSyntax),
           typeof(GroupClauseSyntax),
           typeof(QueryContinuationSyntax),
           typeof(OmittedArraySizeExpressionSyntax),
           typeof(InterpolatedStringExpressionSyntax),
           typeof(IsPatternExpressionSyntax),
           typeof(ThrowExpressionSyntax),
           typeof(WhenClauseSyntax),
           typeof(DiscardPatternSyntax),
           typeof(DeclarationPatternSyntax),
           typeof(VarPatternSyntax),
           typeof(RecursivePatternSyntax),
           typeof(PositionalPatternClauseSyntax),
           typeof(PropertyPatternClauseSyntax),
           typeof(SubpatternSyntax),
           typeof(ConstantPatternSyntax),
           typeof(InterpolatedStringTextSyntax),
           typeof(InterpolationSyntax),
           typeof(InterpolationAlignmentClauseSyntax),
           typeof(InterpolationFormatClauseSyntax),
           typeof(GlobalStatementSyntax),
           typeof(BlockSyntax),
           typeof(LocalFunctionStatementSyntax),
           typeof(LocalDeclarationStatementSyntax),
           typeof(VariableDeclarationSyntax),
           typeof(VariableDeclaratorSyntax),
           typeof(EqualsValueClauseSyntax),
           typeof(SingleVariableDesignationSyntax),
           typeof(DiscardDesignationSyntax),
           typeof(ParenthesizedVariableDesignationSyntax),
           typeof(ExpressionStatementSyntax),
           typeof(EmptyStatementSyntax),
           typeof(LabeledStatementSyntax),
           typeof(GotoStatementSyntax),
           typeof(BreakStatementSyntax),
           typeof(ContinueStatementSyntax),
           typeof(ReturnStatementSyntax),
           typeof(ThrowStatementSyntax),
           typeof(YieldStatementSyntax),
           typeof(WhileStatementSyntax),
           typeof(DoStatementSyntax),
           typeof(ForStatementSyntax),
           typeof(ForEachStatementSyntax),
           typeof(ForEachVariableStatementSyntax),
           typeof(UsingStatementSyntax),
           typeof(FixedStatementSyntax),
           typeof(CheckedStatementSyntax),
           typeof(UnsafeStatementSyntax),
           typeof(LockStatementSyntax),
           typeof(IfStatementSyntax),
           typeof(ElseClauseSyntax),
           typeof(SwitchStatementSyntax),
           typeof(SwitchSectionSyntax),
           typeof(CasePatternSwitchLabelSyntax),
           typeof(CaseSwitchLabelSyntax),
           typeof(DefaultSwitchLabelSyntax),
           typeof(SwitchExpressionSyntax),
           typeof(SwitchExpressionArmSyntax),
           typeof(TryStatementSyntax),
           typeof(CatchClauseSyntax),
           typeof(CatchDeclarationSyntax),
           typeof(CatchFilterClauseSyntax),
           typeof(FinallyClauseSyntax),
           typeof(CompilationUnitSyntax),
           typeof(ExternAliasDirectiveSyntax),
           typeof(UsingDirectiveSyntax),
           typeof(NamespaceDeclarationSyntax),
           typeof(AttributeListSyntax),
           typeof(AttributeTargetSpecifierSyntax),
           typeof(AttributeSyntax),
           typeof(AttributeArgumentListSyntax),
           typeof(AttributeArgumentSyntax),
           typeof(NameEqualsSyntax),
           typeof(TypeParameterListSyntax),
           typeof(TypeParameterSyntax),
           typeof(ClassDeclarationSyntax),
           typeof(StructDeclarationSyntax),
           typeof(InterfaceDeclarationSyntax),
           typeof(EnumDeclarationSyntax),
           typeof(DelegateDeclarationSyntax),
           typeof(EnumMemberDeclarationSyntax),
           typeof(BaseListSyntax),
           typeof(SimpleBaseTypeSyntax),
           typeof(TypeParameterConstraintClauseSyntax),
           typeof(ConstructorConstraintSyntax),
           typeof(ClassOrStructConstraintSyntax),
           typeof(TypeConstraintSyntax),
           typeof(FieldDeclarationSyntax),
           typeof(EventFieldDeclarationSyntax),
           typeof(ExplicitInterfaceSpecifierSyntax),
           typeof(MethodDeclarationSyntax),
           typeof(OperatorDeclarationSyntax),
           typeof(ConversionOperatorDeclarationSyntax),
           typeof(ConstructorDeclarationSyntax),
           typeof(ConstructorInitializerSyntax),
           typeof(DestructorDeclarationSyntax),
           typeof(PropertyDeclarationSyntax),
           typeof(ArrowExpressionClauseSyntax),
           typeof(EventDeclarationSyntax),
           typeof(IndexerDeclarationSyntax),
           typeof(AccessorListSyntax),
           typeof(AccessorDeclarationSyntax),
           typeof(ParameterListSyntax),
           typeof(BracketedParameterListSyntax),
           typeof(ParameterSyntax),
           typeof(IncompleteMemberSyntax),
           typeof(SkippedTokensTriviaSyntax),
           typeof(DocumentationCommentTriviaSyntax),
           typeof(TypeCrefSyntax),
           typeof(QualifiedCrefSyntax),
           typeof(NameMemberCrefSyntax),
           typeof(IndexerMemberCrefSyntax),
           typeof(OperatorMemberCrefSyntax),
           typeof(ConversionOperatorMemberCrefSyntax),
           typeof(CrefParameterListSyntax),
           typeof(CrefBracketedParameterListSyntax),
           typeof(CrefParameterSyntax),
           typeof(XmlElementSyntax),
           typeof(XmlElementStartTagSyntax),
           typeof(XmlElementEndTagSyntax),
           typeof(XmlEmptyElementSyntax),
           typeof(XmlNameSyntax),
           typeof(XmlPrefixSyntax),
           typeof(XmlTextAttributeSyntax),
           typeof(XmlCrefAttributeSyntax),
           typeof(XmlNameAttributeSyntax),
           typeof(XmlTextSyntax),
           typeof(XmlCDataSectionSyntax),
           typeof(XmlProcessingInstructionSyntax),
           typeof(XmlCommentSyntax),
           typeof(IfDirectiveTriviaSyntax),
           typeof(ElifDirectiveTriviaSyntax),
           typeof(ElseDirectiveTriviaSyntax),
           typeof(EndIfDirectiveTriviaSyntax),
           typeof(RegionDirectiveTriviaSyntax),
           typeof(EndRegionDirectiveTriviaSyntax),
           typeof(ErrorDirectiveTriviaSyntax),
           typeof(WarningDirectiveTriviaSyntax),
           typeof(BadDirectiveTriviaSyntax),
           typeof(DefineDirectiveTriviaSyntax),
           typeof(UndefDirectiveTriviaSyntax),
           typeof(LineDirectiveTriviaSyntax),
           typeof(PragmaWarningDirectiveTriviaSyntax),
           typeof(PragmaChecksumDirectiveTriviaSyntax),
           typeof(ReferenceDirectiveTriviaSyntax),
           typeof(LoadDirectiveTriviaSyntax),
           typeof(ShebangDirectiveTriviaSyntax),
           typeof(NullableDirectiveTriviaSyntax)
        };
    }
  }
}
