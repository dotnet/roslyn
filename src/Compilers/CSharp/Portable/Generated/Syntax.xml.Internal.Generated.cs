// <auto-generated />

using System;
using System.Collections;
using System.Collections.Generic;
using System.Linq;
using System.Threading;
using Microsoft.CodeAnalysis.Syntax.InternalSyntax;
using Roslyn.Utilities;

namespace Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax
{
  /// <summary>Provides the base class from which the classes that represent name syntax nodes are derived. This is an abstract class.</summary>
  internal abstract partial class NameSyntax : TypeSyntax
  {
    internal NameSyntax(SyntaxKind kind, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
      : base(kind, diagnostics, annotations)
    {
    }
    internal NameSyntax(SyntaxKind kind)
      : base(kind)
    {
    }

    protected NameSyntax(ObjectReader reader)
       : base(reader)
    {
    }
  }

  /// <summary>Provides the base class from which the classes that represent simple name syntax nodes are derived. This is an abstract class.</summary>
  internal abstract partial class SimpleNameSyntax : NameSyntax
  {
    internal SimpleNameSyntax(SyntaxKind kind, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
      : base(kind, diagnostics, annotations)
    {
    }
    internal SimpleNameSyntax(SyntaxKind kind)
      : base(kind)
    {
    }

    protected SimpleNameSyntax(ObjectReader reader)
       : base(reader)
    {
    }

    /// <summary>SyntaxToken representing the identifier of the simple name.</summary>
    public abstract SyntaxToken Identifier { get; }
  }

  /// <summary>Class which represents the syntax node for identifier name.</summary>
  internal sealed partial class IdentifierNameSyntax : SimpleNameSyntax
  {
    internal readonly SyntaxToken identifier;

    internal IdentifierNameSyntax(SyntaxKind kind, SyntaxToken identifier, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 1;
        this.AdjustFlagsAndWidth(identifier);
        this.identifier = identifier;
    }


    internal IdentifierNameSyntax(SyntaxKind kind, SyntaxToken identifier, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 1;
        this.AdjustFlagsAndWidth(identifier);
        this.identifier = identifier;
    }


    internal IdentifierNameSyntax(SyntaxKind kind, SyntaxToken identifier)
        : base(kind)
    {
        this.SlotCount = 1;
        this.AdjustFlagsAndWidth(identifier);
        this.identifier = identifier;
    }

    /// <summary>SyntaxToken representing the keyword for the kind of the identifier name.</summary>
    public override SyntaxToken Identifier { get { return this.identifier; } }

    internal override GreenNode GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.identifier;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode parent, int position)
    {
      return new CSharp.Syntax.IdentifierNameSyntax(this, parent, position);
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitIdentifierName(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitIdentifierName(this);
    }

    public IdentifierNameSyntax Update(SyntaxToken identifier)
    {
        if (identifier != this.Identifier)
        {
            var newNode = SyntaxFactory.IdentifierName(identifier);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
    {
         return new IdentifierNameSyntax(this.Kind, this.identifier, diagnostics, GetAnnotations());
    }

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
    {
         return new IdentifierNameSyntax(this.Kind, this.identifier, GetDiagnostics(), annotations);
    }

    internal IdentifierNameSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 1;
      var identifier = (SyntaxToken)reader.ReadValue();
      if (identifier != null)
      {
         AdjustFlagsAndWidth(identifier);
         this.identifier = identifier;
      }
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.identifier);
    }

    static IdentifierNameSyntax()
    {
       ObjectBinder.RegisterTypeReader(typeof(IdentifierNameSyntax), r => new IdentifierNameSyntax(r));
    }
  }

  /// <summary>Class which represents the syntax node for qualified name.</summary>
  internal sealed partial class QualifiedNameSyntax : NameSyntax
  {
    internal readonly NameSyntax left;
    internal readonly SyntaxToken dotToken;
    internal readonly SimpleNameSyntax right;

    internal QualifiedNameSyntax(SyntaxKind kind, NameSyntax left, SyntaxToken dotToken, SimpleNameSyntax right, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 3;
        this.AdjustFlagsAndWidth(left);
        this.left = left;
        this.AdjustFlagsAndWidth(dotToken);
        this.dotToken = dotToken;
        this.AdjustFlagsAndWidth(right);
        this.right = right;
    }


    internal QualifiedNameSyntax(SyntaxKind kind, NameSyntax left, SyntaxToken dotToken, SimpleNameSyntax right, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 3;
        this.AdjustFlagsAndWidth(left);
        this.left = left;
        this.AdjustFlagsAndWidth(dotToken);
        this.dotToken = dotToken;
        this.AdjustFlagsAndWidth(right);
        this.right = right;
    }


    internal QualifiedNameSyntax(SyntaxKind kind, NameSyntax left, SyntaxToken dotToken, SimpleNameSyntax right)
        : base(kind)
    {
        this.SlotCount = 3;
        this.AdjustFlagsAndWidth(left);
        this.left = left;
        this.AdjustFlagsAndWidth(dotToken);
        this.dotToken = dotToken;
        this.AdjustFlagsAndWidth(right);
        this.right = right;
    }

    /// <summary>NameSyntax node representing the name on the left side of the dot token of the qualified name.</summary>
    public NameSyntax Left { get { return this.left; } }
    /// <summary>SyntaxToken representing the dot.</summary>
    public SyntaxToken DotToken { get { return this.dotToken; } }
    /// <summary>SimpleNameSyntax node representing the name on the right side of the dot token of the qualified name.</summary>
    public SimpleNameSyntax Right { get { return this.right; } }

    internal override GreenNode GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.left;
            case 1: return this.dotToken;
            case 2: return this.right;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode parent, int position)
    {
      return new CSharp.Syntax.QualifiedNameSyntax(this, parent, position);
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitQualifiedName(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitQualifiedName(this);
    }

    public QualifiedNameSyntax Update(NameSyntax left, SyntaxToken dotToken, SimpleNameSyntax right)
    {
        if (left != this.Left || dotToken != this.DotToken || right != this.Right)
        {
            var newNode = SyntaxFactory.QualifiedName(left, dotToken, right);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
    {
         return new QualifiedNameSyntax(this.Kind, this.left, this.dotToken, this.right, diagnostics, GetAnnotations());
    }

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
    {
         return new QualifiedNameSyntax(this.Kind, this.left, this.dotToken, this.right, GetDiagnostics(), annotations);
    }

    internal QualifiedNameSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 3;
      var left = (NameSyntax)reader.ReadValue();
      if (left != null)
      {
         AdjustFlagsAndWidth(left);
         this.left = left;
      }
      var dotToken = (SyntaxToken)reader.ReadValue();
      if (dotToken != null)
      {
         AdjustFlagsAndWidth(dotToken);
         this.dotToken = dotToken;
      }
      var right = (SimpleNameSyntax)reader.ReadValue();
      if (right != null)
      {
         AdjustFlagsAndWidth(right);
         this.right = right;
      }
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.left);
      writer.WriteValue(this.dotToken);
      writer.WriteValue(this.right);
    }

    static QualifiedNameSyntax()
    {
       ObjectBinder.RegisterTypeReader(typeof(QualifiedNameSyntax), r => new QualifiedNameSyntax(r));
    }
  }

  /// <summary>Class which represents the syntax node for generic name.</summary>
  internal sealed partial class GenericNameSyntax : SimpleNameSyntax
  {
    internal readonly SyntaxToken identifier;
    internal readonly TypeArgumentListSyntax typeArgumentList;

    internal GenericNameSyntax(SyntaxKind kind, SyntaxToken identifier, TypeArgumentListSyntax typeArgumentList, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 2;
        this.AdjustFlagsAndWidth(identifier);
        this.identifier = identifier;
        this.AdjustFlagsAndWidth(typeArgumentList);
        this.typeArgumentList = typeArgumentList;
    }


    internal GenericNameSyntax(SyntaxKind kind, SyntaxToken identifier, TypeArgumentListSyntax typeArgumentList, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 2;
        this.AdjustFlagsAndWidth(identifier);
        this.identifier = identifier;
        this.AdjustFlagsAndWidth(typeArgumentList);
        this.typeArgumentList = typeArgumentList;
    }


    internal GenericNameSyntax(SyntaxKind kind, SyntaxToken identifier, TypeArgumentListSyntax typeArgumentList)
        : base(kind)
    {
        this.SlotCount = 2;
        this.AdjustFlagsAndWidth(identifier);
        this.identifier = identifier;
        this.AdjustFlagsAndWidth(typeArgumentList);
        this.typeArgumentList = typeArgumentList;
    }

    /// <summary>SyntaxToken representing the name of the identifier of the generic name.</summary>
    public override SyntaxToken Identifier { get { return this.identifier; } }
    /// <summary>TypeArgumentListSyntax node representing the list of type arguments of the generic name.</summary>
    public TypeArgumentListSyntax TypeArgumentList { get { return this.typeArgumentList; } }

    internal override GreenNode GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.identifier;
            case 1: return this.typeArgumentList;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode parent, int position)
    {
      return new CSharp.Syntax.GenericNameSyntax(this, parent, position);
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitGenericName(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitGenericName(this);
    }

    public GenericNameSyntax Update(SyntaxToken identifier, TypeArgumentListSyntax typeArgumentList)
    {
        if (identifier != this.Identifier || typeArgumentList != this.TypeArgumentList)
        {
            var newNode = SyntaxFactory.GenericName(identifier, typeArgumentList);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
    {
         return new GenericNameSyntax(this.Kind, this.identifier, this.typeArgumentList, diagnostics, GetAnnotations());
    }

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
    {
         return new GenericNameSyntax(this.Kind, this.identifier, this.typeArgumentList, GetDiagnostics(), annotations);
    }

    internal GenericNameSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 2;
      var identifier = (SyntaxToken)reader.ReadValue();
      if (identifier != null)
      {
         AdjustFlagsAndWidth(identifier);
         this.identifier = identifier;
      }
      var typeArgumentList = (TypeArgumentListSyntax)reader.ReadValue();
      if (typeArgumentList != null)
      {
         AdjustFlagsAndWidth(typeArgumentList);
         this.typeArgumentList = typeArgumentList;
      }
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.identifier);
      writer.WriteValue(this.typeArgumentList);
    }

    static GenericNameSyntax()
    {
       ObjectBinder.RegisterTypeReader(typeof(GenericNameSyntax), r => new GenericNameSyntax(r));
    }
  }

  /// <summary>Class which represents the syntax node for type argument list.</summary>
  internal sealed partial class TypeArgumentListSyntax : CSharpSyntaxNode
  {
    internal readonly SyntaxToken lessThanToken;
    internal readonly GreenNode arguments;
    internal readonly SyntaxToken greaterThanToken;

    internal TypeArgumentListSyntax(SyntaxKind kind, SyntaxToken lessThanToken, GreenNode arguments, SyntaxToken greaterThanToken, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 3;
        this.AdjustFlagsAndWidth(lessThanToken);
        this.lessThanToken = lessThanToken;
        if (arguments != null)
        {
            this.AdjustFlagsAndWidth(arguments);
            this.arguments = arguments;
        }
        this.AdjustFlagsAndWidth(greaterThanToken);
        this.greaterThanToken = greaterThanToken;
    }


    internal TypeArgumentListSyntax(SyntaxKind kind, SyntaxToken lessThanToken, GreenNode arguments, SyntaxToken greaterThanToken, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 3;
        this.AdjustFlagsAndWidth(lessThanToken);
        this.lessThanToken = lessThanToken;
        if (arguments != null)
        {
            this.AdjustFlagsAndWidth(arguments);
            this.arguments = arguments;
        }
        this.AdjustFlagsAndWidth(greaterThanToken);
        this.greaterThanToken = greaterThanToken;
    }


    internal TypeArgumentListSyntax(SyntaxKind kind, SyntaxToken lessThanToken, GreenNode arguments, SyntaxToken greaterThanToken)
        : base(kind)
    {
        this.SlotCount = 3;
        this.AdjustFlagsAndWidth(lessThanToken);
        this.lessThanToken = lessThanToken;
        if (arguments != null)
        {
            this.AdjustFlagsAndWidth(arguments);
            this.arguments = arguments;
        }
        this.AdjustFlagsAndWidth(greaterThanToken);
        this.greaterThanToken = greaterThanToken;
    }

    /// <summary>SyntaxToken representing less than.</summary>
    public SyntaxToken LessThanToken { get { return this.lessThanToken; } }
    /// <summary>SeparatedSyntaxList of TypeSyntax node representing the type arguments.</summary>
    public Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<TypeSyntax> Arguments { get { return new Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<TypeSyntax>(new Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<CSharpSyntaxNode>(this.arguments)); } }
    /// <summary>SyntaxToken representing greater than.</summary>
    public SyntaxToken GreaterThanToken { get { return this.greaterThanToken; } }

    internal override GreenNode GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.lessThanToken;
            case 1: return this.arguments;
            case 2: return this.greaterThanToken;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode parent, int position)
    {
      return new CSharp.Syntax.TypeArgumentListSyntax(this, parent, position);
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitTypeArgumentList(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitTypeArgumentList(this);
    }

    public TypeArgumentListSyntax Update(SyntaxToken lessThanToken, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<TypeSyntax> arguments, SyntaxToken greaterThanToken)
    {
        if (lessThanToken != this.LessThanToken || arguments != this.Arguments || greaterThanToken != this.GreaterThanToken)
        {
            var newNode = SyntaxFactory.TypeArgumentList(lessThanToken, arguments, greaterThanToken);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
    {
         return new TypeArgumentListSyntax(this.Kind, this.lessThanToken, this.arguments, this.greaterThanToken, diagnostics, GetAnnotations());
    }

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
    {
         return new TypeArgumentListSyntax(this.Kind, this.lessThanToken, this.arguments, this.greaterThanToken, GetDiagnostics(), annotations);
    }

    internal TypeArgumentListSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 3;
      var lessThanToken = (SyntaxToken)reader.ReadValue();
      if (lessThanToken != null)
      {
         AdjustFlagsAndWidth(lessThanToken);
         this.lessThanToken = lessThanToken;
      }
      var arguments = (GreenNode)reader.ReadValue();
      if (arguments != null)
      {
         AdjustFlagsAndWidth(arguments);
         this.arguments = arguments;
      }
      var greaterThanToken = (SyntaxToken)reader.ReadValue();
      if (greaterThanToken != null)
      {
         AdjustFlagsAndWidth(greaterThanToken);
         this.greaterThanToken = greaterThanToken;
      }
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.lessThanToken);
      writer.WriteValue(this.arguments);
      writer.WriteValue(this.greaterThanToken);
    }

    static TypeArgumentListSyntax()
    {
       ObjectBinder.RegisterTypeReader(typeof(TypeArgumentListSyntax), r => new TypeArgumentListSyntax(r));
    }
  }

  /// <summary>Class which represents the syntax node for alias qualified name.</summary>
  internal sealed partial class AliasQualifiedNameSyntax : NameSyntax
  {
    internal readonly IdentifierNameSyntax alias;
    internal readonly SyntaxToken colonColonToken;
    internal readonly SimpleNameSyntax name;

    internal AliasQualifiedNameSyntax(SyntaxKind kind, IdentifierNameSyntax alias, SyntaxToken colonColonToken, SimpleNameSyntax name, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 3;
        this.AdjustFlagsAndWidth(alias);
        this.alias = alias;
        this.AdjustFlagsAndWidth(colonColonToken);
        this.colonColonToken = colonColonToken;
        this.AdjustFlagsAndWidth(name);
        this.name = name;
    }


    internal AliasQualifiedNameSyntax(SyntaxKind kind, IdentifierNameSyntax alias, SyntaxToken colonColonToken, SimpleNameSyntax name, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 3;
        this.AdjustFlagsAndWidth(alias);
        this.alias = alias;
        this.AdjustFlagsAndWidth(colonColonToken);
        this.colonColonToken = colonColonToken;
        this.AdjustFlagsAndWidth(name);
        this.name = name;
    }


    internal AliasQualifiedNameSyntax(SyntaxKind kind, IdentifierNameSyntax alias, SyntaxToken colonColonToken, SimpleNameSyntax name)
        : base(kind)
    {
        this.SlotCount = 3;
        this.AdjustFlagsAndWidth(alias);
        this.alias = alias;
        this.AdjustFlagsAndWidth(colonColonToken);
        this.colonColonToken = colonColonToken;
        this.AdjustFlagsAndWidth(name);
        this.name = name;
    }

    /// <summary>IdentifierNameSyntax node representing the name of the alias</summary>
    public IdentifierNameSyntax Alias { get { return this.alias; } }
    /// <summary>SyntaxToken representing colon colon.</summary>
    public SyntaxToken ColonColonToken { get { return this.colonColonToken; } }
    /// <summary>SimpleNameSyntax node representing the name that is being alias qualified.</summary>
    public SimpleNameSyntax Name { get { return this.name; } }

    internal override GreenNode GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.alias;
            case 1: return this.colonColonToken;
            case 2: return this.name;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode parent, int position)
    {
      return new CSharp.Syntax.AliasQualifiedNameSyntax(this, parent, position);
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitAliasQualifiedName(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitAliasQualifiedName(this);
    }

    public AliasQualifiedNameSyntax Update(IdentifierNameSyntax alias, SyntaxToken colonColonToken, SimpleNameSyntax name)
    {
        if (alias != this.Alias || colonColonToken != this.ColonColonToken || name != this.Name)
        {
            var newNode = SyntaxFactory.AliasQualifiedName(alias, colonColonToken, name);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
    {
         return new AliasQualifiedNameSyntax(this.Kind, this.alias, this.colonColonToken, this.name, diagnostics, GetAnnotations());
    }

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
    {
         return new AliasQualifiedNameSyntax(this.Kind, this.alias, this.colonColonToken, this.name, GetDiagnostics(), annotations);
    }

    internal AliasQualifiedNameSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 3;
      var alias = (IdentifierNameSyntax)reader.ReadValue();
      if (alias != null)
      {
         AdjustFlagsAndWidth(alias);
         this.alias = alias;
      }
      var colonColonToken = (SyntaxToken)reader.ReadValue();
      if (colonColonToken != null)
      {
         AdjustFlagsAndWidth(colonColonToken);
         this.colonColonToken = colonColonToken;
      }
      var name = (SimpleNameSyntax)reader.ReadValue();
      if (name != null)
      {
         AdjustFlagsAndWidth(name);
         this.name = name;
      }
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.alias);
      writer.WriteValue(this.colonColonToken);
      writer.WriteValue(this.name);
    }

    static AliasQualifiedNameSyntax()
    {
       ObjectBinder.RegisterTypeReader(typeof(AliasQualifiedNameSyntax), r => new AliasQualifiedNameSyntax(r));
    }
  }

  /// <summary>Provides the base class from which the classes that represent type syntax nodes are derived. This is an abstract class.</summary>
  internal abstract partial class TypeSyntax : ExpressionSyntax
  {
    internal TypeSyntax(SyntaxKind kind, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
      : base(kind, diagnostics, annotations)
    {
    }
    internal TypeSyntax(SyntaxKind kind)
      : base(kind)
    {
    }

    protected TypeSyntax(ObjectReader reader)
       : base(reader)
    {
    }
  }

  /// <summary>Class which represents the syntax node for predefined types.</summary>
  internal sealed partial class PredefinedTypeSyntax : TypeSyntax
  {
    internal readonly SyntaxToken keyword;

    internal PredefinedTypeSyntax(SyntaxKind kind, SyntaxToken keyword, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 1;
        this.AdjustFlagsAndWidth(keyword);
        this.keyword = keyword;
    }


    internal PredefinedTypeSyntax(SyntaxKind kind, SyntaxToken keyword, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 1;
        this.AdjustFlagsAndWidth(keyword);
        this.keyword = keyword;
    }


    internal PredefinedTypeSyntax(SyntaxKind kind, SyntaxToken keyword)
        : base(kind)
    {
        this.SlotCount = 1;
        this.AdjustFlagsAndWidth(keyword);
        this.keyword = keyword;
    }

    /// <summary>SyntaxToken which represents the keyword corresponding to the predefined type.</summary>
    public SyntaxToken Keyword { get { return this.keyword; } }

    internal override GreenNode GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.keyword;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode parent, int position)
    {
      return new CSharp.Syntax.PredefinedTypeSyntax(this, parent, position);
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitPredefinedType(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitPredefinedType(this);
    }

    public PredefinedTypeSyntax Update(SyntaxToken keyword)
    {
        if (keyword != this.Keyword)
        {
            var newNode = SyntaxFactory.PredefinedType(keyword);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
    {
         return new PredefinedTypeSyntax(this.Kind, this.keyword, diagnostics, GetAnnotations());
    }

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
    {
         return new PredefinedTypeSyntax(this.Kind, this.keyword, GetDiagnostics(), annotations);
    }

    internal PredefinedTypeSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 1;
      var keyword = (SyntaxToken)reader.ReadValue();
      if (keyword != null)
      {
         AdjustFlagsAndWidth(keyword);
         this.keyword = keyword;
      }
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.keyword);
    }

    static PredefinedTypeSyntax()
    {
       ObjectBinder.RegisterTypeReader(typeof(PredefinedTypeSyntax), r => new PredefinedTypeSyntax(r));
    }
  }

  /// <summary>Class which represents the syntax node for the array type.</summary>
  internal sealed partial class ArrayTypeSyntax : TypeSyntax
  {
    internal readonly TypeSyntax elementType;
    internal readonly GreenNode rankSpecifiers;

    internal ArrayTypeSyntax(SyntaxKind kind, TypeSyntax elementType, GreenNode rankSpecifiers, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 2;
        this.AdjustFlagsAndWidth(elementType);
        this.elementType = elementType;
        if (rankSpecifiers != null)
        {
            this.AdjustFlagsAndWidth(rankSpecifiers);
            this.rankSpecifiers = rankSpecifiers;
        }
    }


    internal ArrayTypeSyntax(SyntaxKind kind, TypeSyntax elementType, GreenNode rankSpecifiers, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 2;
        this.AdjustFlagsAndWidth(elementType);
        this.elementType = elementType;
        if (rankSpecifiers != null)
        {
            this.AdjustFlagsAndWidth(rankSpecifiers);
            this.rankSpecifiers = rankSpecifiers;
        }
    }


    internal ArrayTypeSyntax(SyntaxKind kind, TypeSyntax elementType, GreenNode rankSpecifiers)
        : base(kind)
    {
        this.SlotCount = 2;
        this.AdjustFlagsAndWidth(elementType);
        this.elementType = elementType;
        if (rankSpecifiers != null)
        {
            this.AdjustFlagsAndWidth(rankSpecifiers);
            this.rankSpecifiers = rankSpecifiers;
        }
    }

    /// <summary>TypeSyntax node representing the type of the element of the array.</summary>
    public TypeSyntax ElementType { get { return this.elementType; } }
    /// <summary>SyntaxList of ArrayRankSpecifierSyntax nodes representing the list of rank specifiers for the array.</summary>
    public Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<ArrayRankSpecifierSyntax> RankSpecifiers { get { return new Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<ArrayRankSpecifierSyntax>(this.rankSpecifiers); } }

    internal override GreenNode GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.elementType;
            case 1: return this.rankSpecifiers;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode parent, int position)
    {
      return new CSharp.Syntax.ArrayTypeSyntax(this, parent, position);
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitArrayType(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitArrayType(this);
    }

    public ArrayTypeSyntax Update(TypeSyntax elementType, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<ArrayRankSpecifierSyntax> rankSpecifiers)
    {
        if (elementType != this.ElementType || rankSpecifiers != this.RankSpecifiers)
        {
            var newNode = SyntaxFactory.ArrayType(elementType, rankSpecifiers);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
    {
         return new ArrayTypeSyntax(this.Kind, this.elementType, this.rankSpecifiers, diagnostics, GetAnnotations());
    }

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
    {
         return new ArrayTypeSyntax(this.Kind, this.elementType, this.rankSpecifiers, GetDiagnostics(), annotations);
    }

    internal ArrayTypeSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 2;
      var elementType = (TypeSyntax)reader.ReadValue();
      if (elementType != null)
      {
         AdjustFlagsAndWidth(elementType);
         this.elementType = elementType;
      }
      var rankSpecifiers = (GreenNode)reader.ReadValue();
      if (rankSpecifiers != null)
      {
         AdjustFlagsAndWidth(rankSpecifiers);
         this.rankSpecifiers = rankSpecifiers;
      }
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.elementType);
      writer.WriteValue(this.rankSpecifiers);
    }

    static ArrayTypeSyntax()
    {
       ObjectBinder.RegisterTypeReader(typeof(ArrayTypeSyntax), r => new ArrayTypeSyntax(r));
    }
  }

  internal sealed partial class ArrayRankSpecifierSyntax : CSharpSyntaxNode
  {
    internal readonly SyntaxToken openBracketToken;
    internal readonly GreenNode sizes;
    internal readonly SyntaxToken closeBracketToken;

    internal ArrayRankSpecifierSyntax(SyntaxKind kind, SyntaxToken openBracketToken, GreenNode sizes, SyntaxToken closeBracketToken, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 3;
        this.AdjustFlagsAndWidth(openBracketToken);
        this.openBracketToken = openBracketToken;
        if (sizes != null)
        {
            this.AdjustFlagsAndWidth(sizes);
            this.sizes = sizes;
        }
        this.AdjustFlagsAndWidth(closeBracketToken);
        this.closeBracketToken = closeBracketToken;
    }


    internal ArrayRankSpecifierSyntax(SyntaxKind kind, SyntaxToken openBracketToken, GreenNode sizes, SyntaxToken closeBracketToken, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 3;
        this.AdjustFlagsAndWidth(openBracketToken);
        this.openBracketToken = openBracketToken;
        if (sizes != null)
        {
            this.AdjustFlagsAndWidth(sizes);
            this.sizes = sizes;
        }
        this.AdjustFlagsAndWidth(closeBracketToken);
        this.closeBracketToken = closeBracketToken;
    }


    internal ArrayRankSpecifierSyntax(SyntaxKind kind, SyntaxToken openBracketToken, GreenNode sizes, SyntaxToken closeBracketToken)
        : base(kind)
    {
        this.SlotCount = 3;
        this.AdjustFlagsAndWidth(openBracketToken);
        this.openBracketToken = openBracketToken;
        if (sizes != null)
        {
            this.AdjustFlagsAndWidth(sizes);
            this.sizes = sizes;
        }
        this.AdjustFlagsAndWidth(closeBracketToken);
        this.closeBracketToken = closeBracketToken;
    }

    public SyntaxToken OpenBracketToken { get { return this.openBracketToken; } }
    public Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<ExpressionSyntax> Sizes { get { return new Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<ExpressionSyntax>(new Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<CSharpSyntaxNode>(this.sizes)); } }
    public SyntaxToken CloseBracketToken { get { return this.closeBracketToken; } }

    internal override GreenNode GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.openBracketToken;
            case 1: return this.sizes;
            case 2: return this.closeBracketToken;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode parent, int position)
    {
      return new CSharp.Syntax.ArrayRankSpecifierSyntax(this, parent, position);
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitArrayRankSpecifier(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitArrayRankSpecifier(this);
    }

    public ArrayRankSpecifierSyntax Update(SyntaxToken openBracketToken, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<ExpressionSyntax> sizes, SyntaxToken closeBracketToken)
    {
        if (openBracketToken != this.OpenBracketToken || sizes != this.Sizes || closeBracketToken != this.CloseBracketToken)
        {
            var newNode = SyntaxFactory.ArrayRankSpecifier(openBracketToken, sizes, closeBracketToken);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
    {
         return new ArrayRankSpecifierSyntax(this.Kind, this.openBracketToken, this.sizes, this.closeBracketToken, diagnostics, GetAnnotations());
    }

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
    {
         return new ArrayRankSpecifierSyntax(this.Kind, this.openBracketToken, this.sizes, this.closeBracketToken, GetDiagnostics(), annotations);
    }

    internal ArrayRankSpecifierSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 3;
      var openBracketToken = (SyntaxToken)reader.ReadValue();
      if (openBracketToken != null)
      {
         AdjustFlagsAndWidth(openBracketToken);
         this.openBracketToken = openBracketToken;
      }
      var sizes = (GreenNode)reader.ReadValue();
      if (sizes != null)
      {
         AdjustFlagsAndWidth(sizes);
         this.sizes = sizes;
      }
      var closeBracketToken = (SyntaxToken)reader.ReadValue();
      if (closeBracketToken != null)
      {
         AdjustFlagsAndWidth(closeBracketToken);
         this.closeBracketToken = closeBracketToken;
      }
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.openBracketToken);
      writer.WriteValue(this.sizes);
      writer.WriteValue(this.closeBracketToken);
    }

    static ArrayRankSpecifierSyntax()
    {
       ObjectBinder.RegisterTypeReader(typeof(ArrayRankSpecifierSyntax), r => new ArrayRankSpecifierSyntax(r));
    }
  }

  /// <summary>Class which represents the syntax node for pointer type.</summary>
  internal sealed partial class PointerTypeSyntax : TypeSyntax
  {
    internal readonly TypeSyntax elementType;
    internal readonly SyntaxToken asteriskToken;

    internal PointerTypeSyntax(SyntaxKind kind, TypeSyntax elementType, SyntaxToken asteriskToken, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 2;
        this.AdjustFlagsAndWidth(elementType);
        this.elementType = elementType;
        this.AdjustFlagsAndWidth(asteriskToken);
        this.asteriskToken = asteriskToken;
    }


    internal PointerTypeSyntax(SyntaxKind kind, TypeSyntax elementType, SyntaxToken asteriskToken, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 2;
        this.AdjustFlagsAndWidth(elementType);
        this.elementType = elementType;
        this.AdjustFlagsAndWidth(asteriskToken);
        this.asteriskToken = asteriskToken;
    }


    internal PointerTypeSyntax(SyntaxKind kind, TypeSyntax elementType, SyntaxToken asteriskToken)
        : base(kind)
    {
        this.SlotCount = 2;
        this.AdjustFlagsAndWidth(elementType);
        this.elementType = elementType;
        this.AdjustFlagsAndWidth(asteriskToken);
        this.asteriskToken = asteriskToken;
    }

    /// <summary>TypeSyntax node that represents the element type of the pointer.</summary>
    public TypeSyntax ElementType { get { return this.elementType; } }
    /// <summary>SyntaxToken representing the asterisk.</summary>
    public SyntaxToken AsteriskToken { get { return this.asteriskToken; } }

    internal override GreenNode GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.elementType;
            case 1: return this.asteriskToken;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode parent, int position)
    {
      return new CSharp.Syntax.PointerTypeSyntax(this, parent, position);
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitPointerType(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitPointerType(this);
    }

    public PointerTypeSyntax Update(TypeSyntax elementType, SyntaxToken asteriskToken)
    {
        if (elementType != this.ElementType || asteriskToken != this.AsteriskToken)
        {
            var newNode = SyntaxFactory.PointerType(elementType, asteriskToken);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
    {
         return new PointerTypeSyntax(this.Kind, this.elementType, this.asteriskToken, diagnostics, GetAnnotations());
    }

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
    {
         return new PointerTypeSyntax(this.Kind, this.elementType, this.asteriskToken, GetDiagnostics(), annotations);
    }

    internal PointerTypeSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 2;
      var elementType = (TypeSyntax)reader.ReadValue();
      if (elementType != null)
      {
         AdjustFlagsAndWidth(elementType);
         this.elementType = elementType;
      }
      var asteriskToken = (SyntaxToken)reader.ReadValue();
      if (asteriskToken != null)
      {
         AdjustFlagsAndWidth(asteriskToken);
         this.asteriskToken = asteriskToken;
      }
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.elementType);
      writer.WriteValue(this.asteriskToken);
    }

    static PointerTypeSyntax()
    {
       ObjectBinder.RegisterTypeReader(typeof(PointerTypeSyntax), r => new PointerTypeSyntax(r));
    }
  }

  /// <summary>Class which represents the syntax node for a nullable type.</summary>
  internal sealed partial class NullableTypeSyntax : TypeSyntax
  {
    internal readonly TypeSyntax elementType;
    internal readonly SyntaxToken questionToken;

    internal NullableTypeSyntax(SyntaxKind kind, TypeSyntax elementType, SyntaxToken questionToken, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 2;
        this.AdjustFlagsAndWidth(elementType);
        this.elementType = elementType;
        this.AdjustFlagsAndWidth(questionToken);
        this.questionToken = questionToken;
    }


    internal NullableTypeSyntax(SyntaxKind kind, TypeSyntax elementType, SyntaxToken questionToken, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 2;
        this.AdjustFlagsAndWidth(elementType);
        this.elementType = elementType;
        this.AdjustFlagsAndWidth(questionToken);
        this.questionToken = questionToken;
    }


    internal NullableTypeSyntax(SyntaxKind kind, TypeSyntax elementType, SyntaxToken questionToken)
        : base(kind)
    {
        this.SlotCount = 2;
        this.AdjustFlagsAndWidth(elementType);
        this.elementType = elementType;
        this.AdjustFlagsAndWidth(questionToken);
        this.questionToken = questionToken;
    }

    /// <summary>TypeSyntax node representing the type of the element.</summary>
    public TypeSyntax ElementType { get { return this.elementType; } }
    /// <summary>SyntaxToken representing the question mark.</summary>
    public SyntaxToken QuestionToken { get { return this.questionToken; } }

    internal override GreenNode GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.elementType;
            case 1: return this.questionToken;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode parent, int position)
    {
      return new CSharp.Syntax.NullableTypeSyntax(this, parent, position);
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitNullableType(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitNullableType(this);
    }

    public NullableTypeSyntax Update(TypeSyntax elementType, SyntaxToken questionToken)
    {
        if (elementType != this.ElementType || questionToken != this.QuestionToken)
        {
            var newNode = SyntaxFactory.NullableType(elementType, questionToken);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
    {
         return new NullableTypeSyntax(this.Kind, this.elementType, this.questionToken, diagnostics, GetAnnotations());
    }

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
    {
         return new NullableTypeSyntax(this.Kind, this.elementType, this.questionToken, GetDiagnostics(), annotations);
    }

    internal NullableTypeSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 2;
      var elementType = (TypeSyntax)reader.ReadValue();
      if (elementType != null)
      {
         AdjustFlagsAndWidth(elementType);
         this.elementType = elementType;
      }
      var questionToken = (SyntaxToken)reader.ReadValue();
      if (questionToken != null)
      {
         AdjustFlagsAndWidth(questionToken);
         this.questionToken = questionToken;
      }
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.elementType);
      writer.WriteValue(this.questionToken);
    }

    static NullableTypeSyntax()
    {
       ObjectBinder.RegisterTypeReader(typeof(NullableTypeSyntax), r => new NullableTypeSyntax(r));
    }
  }

  /// <summary>Class which represents the syntax node for tuple type.</summary>
  internal sealed partial class TupleTypeSyntax : TypeSyntax
  {
    internal readonly SyntaxToken openParenToken;
    internal readonly GreenNode elements;
    internal readonly SyntaxToken closeParenToken;

    internal TupleTypeSyntax(SyntaxKind kind, SyntaxToken openParenToken, GreenNode elements, SyntaxToken closeParenToken, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 3;
        this.AdjustFlagsAndWidth(openParenToken);
        this.openParenToken = openParenToken;
        if (elements != null)
        {
            this.AdjustFlagsAndWidth(elements);
            this.elements = elements;
        }
        this.AdjustFlagsAndWidth(closeParenToken);
        this.closeParenToken = closeParenToken;
    }


    internal TupleTypeSyntax(SyntaxKind kind, SyntaxToken openParenToken, GreenNode elements, SyntaxToken closeParenToken, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 3;
        this.AdjustFlagsAndWidth(openParenToken);
        this.openParenToken = openParenToken;
        if (elements != null)
        {
            this.AdjustFlagsAndWidth(elements);
            this.elements = elements;
        }
        this.AdjustFlagsAndWidth(closeParenToken);
        this.closeParenToken = closeParenToken;
    }


    internal TupleTypeSyntax(SyntaxKind kind, SyntaxToken openParenToken, GreenNode elements, SyntaxToken closeParenToken)
        : base(kind)
    {
        this.SlotCount = 3;
        this.AdjustFlagsAndWidth(openParenToken);
        this.openParenToken = openParenToken;
        if (elements != null)
        {
            this.AdjustFlagsAndWidth(elements);
            this.elements = elements;
        }
        this.AdjustFlagsAndWidth(closeParenToken);
        this.closeParenToken = closeParenToken;
    }

    /// <summary>SyntaxToken representing the open parenthesis.</summary>
    public SyntaxToken OpenParenToken { get { return this.openParenToken; } }
    public Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<TupleElementSyntax> Elements { get { return new Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<TupleElementSyntax>(new Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<CSharpSyntaxNode>(this.elements)); } }
    /// <summary>SyntaxToken representing the close parenthesis.</summary>
    public SyntaxToken CloseParenToken { get { return this.closeParenToken; } }

    internal override GreenNode GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.openParenToken;
            case 1: return this.elements;
            case 2: return this.closeParenToken;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode parent, int position)
    {
      return new CSharp.Syntax.TupleTypeSyntax(this, parent, position);
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitTupleType(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitTupleType(this);
    }

    public TupleTypeSyntax Update(SyntaxToken openParenToken, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<TupleElementSyntax> elements, SyntaxToken closeParenToken)
    {
        if (openParenToken != this.OpenParenToken || elements != this.Elements || closeParenToken != this.CloseParenToken)
        {
            var newNode = SyntaxFactory.TupleType(openParenToken, elements, closeParenToken);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
    {
         return new TupleTypeSyntax(this.Kind, this.openParenToken, this.elements, this.closeParenToken, diagnostics, GetAnnotations());
    }

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
    {
         return new TupleTypeSyntax(this.Kind, this.openParenToken, this.elements, this.closeParenToken, GetDiagnostics(), annotations);
    }

    internal TupleTypeSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 3;
      var openParenToken = (SyntaxToken)reader.ReadValue();
      if (openParenToken != null)
      {
         AdjustFlagsAndWidth(openParenToken);
         this.openParenToken = openParenToken;
      }
      var elements = (GreenNode)reader.ReadValue();
      if (elements != null)
      {
         AdjustFlagsAndWidth(elements);
         this.elements = elements;
      }
      var closeParenToken = (SyntaxToken)reader.ReadValue();
      if (closeParenToken != null)
      {
         AdjustFlagsAndWidth(closeParenToken);
         this.closeParenToken = closeParenToken;
      }
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.openParenToken);
      writer.WriteValue(this.elements);
      writer.WriteValue(this.closeParenToken);
    }

    static TupleTypeSyntax()
    {
       ObjectBinder.RegisterTypeReader(typeof(TupleTypeSyntax), r => new TupleTypeSyntax(r));
    }
  }

  /// <summary>Tuple type element.</summary>
  internal sealed partial class TupleElementSyntax : CSharpSyntaxNode
  {
    internal readonly TypeSyntax type;
    internal readonly SyntaxToken identifier;

    internal TupleElementSyntax(SyntaxKind kind, TypeSyntax type, SyntaxToken identifier, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 2;
        this.AdjustFlagsAndWidth(type);
        this.type = type;
        if (identifier != null)
        {
            this.AdjustFlagsAndWidth(identifier);
            this.identifier = identifier;
        }
    }


    internal TupleElementSyntax(SyntaxKind kind, TypeSyntax type, SyntaxToken identifier, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 2;
        this.AdjustFlagsAndWidth(type);
        this.type = type;
        if (identifier != null)
        {
            this.AdjustFlagsAndWidth(identifier);
            this.identifier = identifier;
        }
    }


    internal TupleElementSyntax(SyntaxKind kind, TypeSyntax type, SyntaxToken identifier)
        : base(kind)
    {
        this.SlotCount = 2;
        this.AdjustFlagsAndWidth(type);
        this.type = type;
        if (identifier != null)
        {
            this.AdjustFlagsAndWidth(identifier);
            this.identifier = identifier;
        }
    }

    /// <summary>Gets the type of the tuple element.</summary>
    public TypeSyntax Type { get { return this.type; } }
    /// <summary>Gets the name of the tuple element.</summary>
    public SyntaxToken Identifier { get { return this.identifier; } }

    internal override GreenNode GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.type;
            case 1: return this.identifier;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode parent, int position)
    {
      return new CSharp.Syntax.TupleElementSyntax(this, parent, position);
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitTupleElement(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitTupleElement(this);
    }

    public TupleElementSyntax Update(TypeSyntax type, SyntaxToken identifier)
    {
        if (type != this.Type || identifier != this.Identifier)
        {
            var newNode = SyntaxFactory.TupleElement(type, identifier);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
    {
         return new TupleElementSyntax(this.Kind, this.type, this.identifier, diagnostics, GetAnnotations());
    }

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
    {
         return new TupleElementSyntax(this.Kind, this.type, this.identifier, GetDiagnostics(), annotations);
    }

    internal TupleElementSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 2;
      var type = (TypeSyntax)reader.ReadValue();
      if (type != null)
      {
         AdjustFlagsAndWidth(type);
         this.type = type;
      }
      var identifier = (SyntaxToken)reader.ReadValue();
      if (identifier != null)
      {
         AdjustFlagsAndWidth(identifier);
         this.identifier = identifier;
      }
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.type);
      writer.WriteValue(this.identifier);
    }

    static TupleElementSyntax()
    {
       ObjectBinder.RegisterTypeReader(typeof(TupleElementSyntax), r => new TupleElementSyntax(r));
    }
  }

  /// <summary>Class which represents a placeholder in the type argument list of an unbound generic type.</summary>
  internal sealed partial class OmittedTypeArgumentSyntax : TypeSyntax
  {
    internal readonly SyntaxToken omittedTypeArgumentToken;

    internal OmittedTypeArgumentSyntax(SyntaxKind kind, SyntaxToken omittedTypeArgumentToken, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 1;
        this.AdjustFlagsAndWidth(omittedTypeArgumentToken);
        this.omittedTypeArgumentToken = omittedTypeArgumentToken;
    }


    internal OmittedTypeArgumentSyntax(SyntaxKind kind, SyntaxToken omittedTypeArgumentToken, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 1;
        this.AdjustFlagsAndWidth(omittedTypeArgumentToken);
        this.omittedTypeArgumentToken = omittedTypeArgumentToken;
    }


    internal OmittedTypeArgumentSyntax(SyntaxKind kind, SyntaxToken omittedTypeArgumentToken)
        : base(kind)
    {
        this.SlotCount = 1;
        this.AdjustFlagsAndWidth(omittedTypeArgumentToken);
        this.omittedTypeArgumentToken = omittedTypeArgumentToken;
    }

    /// <summary>SyntaxToken representing the omitted type argument.</summary>
    public SyntaxToken OmittedTypeArgumentToken { get { return this.omittedTypeArgumentToken; } }

    internal override GreenNode GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.omittedTypeArgumentToken;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode parent, int position)
    {
      return new CSharp.Syntax.OmittedTypeArgumentSyntax(this, parent, position);
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitOmittedTypeArgument(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitOmittedTypeArgument(this);
    }

    public OmittedTypeArgumentSyntax Update(SyntaxToken omittedTypeArgumentToken)
    {
        if (omittedTypeArgumentToken != this.OmittedTypeArgumentToken)
        {
            var newNode = SyntaxFactory.OmittedTypeArgument(omittedTypeArgumentToken);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
    {
         return new OmittedTypeArgumentSyntax(this.Kind, this.omittedTypeArgumentToken, diagnostics, GetAnnotations());
    }

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
    {
         return new OmittedTypeArgumentSyntax(this.Kind, this.omittedTypeArgumentToken, GetDiagnostics(), annotations);
    }

    internal OmittedTypeArgumentSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 1;
      var omittedTypeArgumentToken = (SyntaxToken)reader.ReadValue();
      if (omittedTypeArgumentToken != null)
      {
         AdjustFlagsAndWidth(omittedTypeArgumentToken);
         this.omittedTypeArgumentToken = omittedTypeArgumentToken;
      }
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.omittedTypeArgumentToken);
    }

    static OmittedTypeArgumentSyntax()
    {
       ObjectBinder.RegisterTypeReader(typeof(OmittedTypeArgumentSyntax), r => new OmittedTypeArgumentSyntax(r));
    }
  }

  /// <summary>The ref modifier of a method's return value or a local.</summary>
  internal sealed partial class RefTypeSyntax : TypeSyntax
  {
    internal readonly SyntaxToken refKeyword;
    internal readonly TypeSyntax type;

    internal RefTypeSyntax(SyntaxKind kind, SyntaxToken refKeyword, TypeSyntax type, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 2;
        this.AdjustFlagsAndWidth(refKeyword);
        this.refKeyword = refKeyword;
        this.AdjustFlagsAndWidth(type);
        this.type = type;
    }


    internal RefTypeSyntax(SyntaxKind kind, SyntaxToken refKeyword, TypeSyntax type, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 2;
        this.AdjustFlagsAndWidth(refKeyword);
        this.refKeyword = refKeyword;
        this.AdjustFlagsAndWidth(type);
        this.type = type;
    }


    internal RefTypeSyntax(SyntaxKind kind, SyntaxToken refKeyword, TypeSyntax type)
        : base(kind)
    {
        this.SlotCount = 2;
        this.AdjustFlagsAndWidth(refKeyword);
        this.refKeyword = refKeyword;
        this.AdjustFlagsAndWidth(type);
        this.type = type;
    }

    public SyntaxToken RefKeyword { get { return this.refKeyword; } }
    public TypeSyntax Type { get { return this.type; } }

    internal override GreenNode GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.refKeyword;
            case 1: return this.type;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode parent, int position)
    {
      return new CSharp.Syntax.RefTypeSyntax(this, parent, position);
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitRefType(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitRefType(this);
    }

    public RefTypeSyntax Update(SyntaxToken refKeyword, TypeSyntax type)
    {
        if (refKeyword != this.RefKeyword || type != this.Type)
        {
            var newNode = SyntaxFactory.RefType(refKeyword, type);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
    {
         return new RefTypeSyntax(this.Kind, this.refKeyword, this.type, diagnostics, GetAnnotations());
    }

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
    {
         return new RefTypeSyntax(this.Kind, this.refKeyword, this.type, GetDiagnostics(), annotations);
    }

    internal RefTypeSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 2;
      var refKeyword = (SyntaxToken)reader.ReadValue();
      if (refKeyword != null)
      {
         AdjustFlagsAndWidth(refKeyword);
         this.refKeyword = refKeyword;
      }
      var type = (TypeSyntax)reader.ReadValue();
      if (type != null)
      {
         AdjustFlagsAndWidth(type);
         this.type = type;
      }
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.refKeyword);
      writer.WriteValue(this.type);
    }

    static RefTypeSyntax()
    {
       ObjectBinder.RegisterTypeReader(typeof(RefTypeSyntax), r => new RefTypeSyntax(r));
    }
  }

  /// <summary>Provides the base class from which the classes that represent expression syntax nodes are derived. This is an abstract class.</summary>
  internal abstract partial class ExpressionSyntax : CSharpSyntaxNode
  {
    internal ExpressionSyntax(SyntaxKind kind, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
      : base(kind, diagnostics, annotations)
    {
    }
    internal ExpressionSyntax(SyntaxKind kind)
      : base(kind)
    {
    }

    protected ExpressionSyntax(ObjectReader reader)
       : base(reader)
    {
    }
  }

  /// <summary>Class which represents the syntax node for parenthesized expression.</summary>
  internal sealed partial class ParenthesizedExpressionSyntax : ExpressionSyntax
  {
    internal readonly SyntaxToken openParenToken;
    internal readonly ExpressionSyntax expression;
    internal readonly SyntaxToken closeParenToken;

    internal ParenthesizedExpressionSyntax(SyntaxKind kind, SyntaxToken openParenToken, ExpressionSyntax expression, SyntaxToken closeParenToken, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 3;
        this.AdjustFlagsAndWidth(openParenToken);
        this.openParenToken = openParenToken;
        this.AdjustFlagsAndWidth(expression);
        this.expression = expression;
        this.AdjustFlagsAndWidth(closeParenToken);
        this.closeParenToken = closeParenToken;
    }


    internal ParenthesizedExpressionSyntax(SyntaxKind kind, SyntaxToken openParenToken, ExpressionSyntax expression, SyntaxToken closeParenToken, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 3;
        this.AdjustFlagsAndWidth(openParenToken);
        this.openParenToken = openParenToken;
        this.AdjustFlagsAndWidth(expression);
        this.expression = expression;
        this.AdjustFlagsAndWidth(closeParenToken);
        this.closeParenToken = closeParenToken;
    }


    internal ParenthesizedExpressionSyntax(SyntaxKind kind, SyntaxToken openParenToken, ExpressionSyntax expression, SyntaxToken closeParenToken)
        : base(kind)
    {
        this.SlotCount = 3;
        this.AdjustFlagsAndWidth(openParenToken);
        this.openParenToken = openParenToken;
        this.AdjustFlagsAndWidth(expression);
        this.expression = expression;
        this.AdjustFlagsAndWidth(closeParenToken);
        this.closeParenToken = closeParenToken;
    }

    /// <summary>SyntaxToken representing the open parenthesis.</summary>
    public SyntaxToken OpenParenToken { get { return this.openParenToken; } }
    /// <summary>ExpressionSyntax node representing the expression enclosed within the parenthesis.</summary>
    public ExpressionSyntax Expression { get { return this.expression; } }
    /// <summary>SyntaxToken representing the close parenthesis.</summary>
    public SyntaxToken CloseParenToken { get { return this.closeParenToken; } }

    internal override GreenNode GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.openParenToken;
            case 1: return this.expression;
            case 2: return this.closeParenToken;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode parent, int position)
    {
      return new CSharp.Syntax.ParenthesizedExpressionSyntax(this, parent, position);
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitParenthesizedExpression(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitParenthesizedExpression(this);
    }

    public ParenthesizedExpressionSyntax Update(SyntaxToken openParenToken, ExpressionSyntax expression, SyntaxToken closeParenToken)
    {
        if (openParenToken != this.OpenParenToken || expression != this.Expression || closeParenToken != this.CloseParenToken)
        {
            var newNode = SyntaxFactory.ParenthesizedExpression(openParenToken, expression, closeParenToken);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
    {
         return new ParenthesizedExpressionSyntax(this.Kind, this.openParenToken, this.expression, this.closeParenToken, diagnostics, GetAnnotations());
    }

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
    {
         return new ParenthesizedExpressionSyntax(this.Kind, this.openParenToken, this.expression, this.closeParenToken, GetDiagnostics(), annotations);
    }

    internal ParenthesizedExpressionSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 3;
      var openParenToken = (SyntaxToken)reader.ReadValue();
      if (openParenToken != null)
      {
         AdjustFlagsAndWidth(openParenToken);
         this.openParenToken = openParenToken;
      }
      var expression = (ExpressionSyntax)reader.ReadValue();
      if (expression != null)
      {
         AdjustFlagsAndWidth(expression);
         this.expression = expression;
      }
      var closeParenToken = (SyntaxToken)reader.ReadValue();
      if (closeParenToken != null)
      {
         AdjustFlagsAndWidth(closeParenToken);
         this.closeParenToken = closeParenToken;
      }
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.openParenToken);
      writer.WriteValue(this.expression);
      writer.WriteValue(this.closeParenToken);
    }

    static ParenthesizedExpressionSyntax()
    {
       ObjectBinder.RegisterTypeReader(typeof(ParenthesizedExpressionSyntax), r => new ParenthesizedExpressionSyntax(r));
    }
  }

  /// <summary>Class which represents the syntax node for tuple expression.</summary>
  internal sealed partial class TupleExpressionSyntax : ExpressionSyntax
  {
    internal readonly SyntaxToken openParenToken;
    internal readonly GreenNode arguments;
    internal readonly SyntaxToken closeParenToken;

    internal TupleExpressionSyntax(SyntaxKind kind, SyntaxToken openParenToken, GreenNode arguments, SyntaxToken closeParenToken, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 3;
        this.AdjustFlagsAndWidth(openParenToken);
        this.openParenToken = openParenToken;
        if (arguments != null)
        {
            this.AdjustFlagsAndWidth(arguments);
            this.arguments = arguments;
        }
        this.AdjustFlagsAndWidth(closeParenToken);
        this.closeParenToken = closeParenToken;
    }


    internal TupleExpressionSyntax(SyntaxKind kind, SyntaxToken openParenToken, GreenNode arguments, SyntaxToken closeParenToken, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 3;
        this.AdjustFlagsAndWidth(openParenToken);
        this.openParenToken = openParenToken;
        if (arguments != null)
        {
            this.AdjustFlagsAndWidth(arguments);
            this.arguments = arguments;
        }
        this.AdjustFlagsAndWidth(closeParenToken);
        this.closeParenToken = closeParenToken;
    }


    internal TupleExpressionSyntax(SyntaxKind kind, SyntaxToken openParenToken, GreenNode arguments, SyntaxToken closeParenToken)
        : base(kind)
    {
        this.SlotCount = 3;
        this.AdjustFlagsAndWidth(openParenToken);
        this.openParenToken = openParenToken;
        if (arguments != null)
        {
            this.AdjustFlagsAndWidth(arguments);
            this.arguments = arguments;
        }
        this.AdjustFlagsAndWidth(closeParenToken);
        this.closeParenToken = closeParenToken;
    }

    /// <summary>SyntaxToken representing the open parenthesis.</summary>
    public SyntaxToken OpenParenToken { get { return this.openParenToken; } }
    /// <summary>SeparatedSyntaxList of ArgumentSyntax representing the list of arguments.</summary>
    public Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<ArgumentSyntax> Arguments { get { return new Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<ArgumentSyntax>(new Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<CSharpSyntaxNode>(this.arguments)); } }
    /// <summary>SyntaxToken representing the close parenthesis.</summary>
    public SyntaxToken CloseParenToken { get { return this.closeParenToken; } }

    internal override GreenNode GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.openParenToken;
            case 1: return this.arguments;
            case 2: return this.closeParenToken;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode parent, int position)
    {
      return new CSharp.Syntax.TupleExpressionSyntax(this, parent, position);
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitTupleExpression(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitTupleExpression(this);
    }

    public TupleExpressionSyntax Update(SyntaxToken openParenToken, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<ArgumentSyntax> arguments, SyntaxToken closeParenToken)
    {
        if (openParenToken != this.OpenParenToken || arguments != this.Arguments || closeParenToken != this.CloseParenToken)
        {
            var newNode = SyntaxFactory.TupleExpression(openParenToken, arguments, closeParenToken);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
    {
         return new TupleExpressionSyntax(this.Kind, this.openParenToken, this.arguments, this.closeParenToken, diagnostics, GetAnnotations());
    }

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
    {
         return new TupleExpressionSyntax(this.Kind, this.openParenToken, this.arguments, this.closeParenToken, GetDiagnostics(), annotations);
    }

    internal TupleExpressionSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 3;
      var openParenToken = (SyntaxToken)reader.ReadValue();
      if (openParenToken != null)
      {
         AdjustFlagsAndWidth(openParenToken);
         this.openParenToken = openParenToken;
      }
      var arguments = (GreenNode)reader.ReadValue();
      if (arguments != null)
      {
         AdjustFlagsAndWidth(arguments);
         this.arguments = arguments;
      }
      var closeParenToken = (SyntaxToken)reader.ReadValue();
      if (closeParenToken != null)
      {
         AdjustFlagsAndWidth(closeParenToken);
         this.closeParenToken = closeParenToken;
      }
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.openParenToken);
      writer.WriteValue(this.arguments);
      writer.WriteValue(this.closeParenToken);
    }

    static TupleExpressionSyntax()
    {
       ObjectBinder.RegisterTypeReader(typeof(TupleExpressionSyntax), r => new TupleExpressionSyntax(r));
    }
  }

  /// <summary>Class which represents the syntax node for prefix unary expression.</summary>
  internal sealed partial class PrefixUnaryExpressionSyntax : ExpressionSyntax
  {
    internal readonly SyntaxToken operatorToken;
    internal readonly ExpressionSyntax operand;

    internal PrefixUnaryExpressionSyntax(SyntaxKind kind, SyntaxToken operatorToken, ExpressionSyntax operand, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 2;
        this.AdjustFlagsAndWidth(operatorToken);
        this.operatorToken = operatorToken;
        this.AdjustFlagsAndWidth(operand);
        this.operand = operand;
    }


    internal PrefixUnaryExpressionSyntax(SyntaxKind kind, SyntaxToken operatorToken, ExpressionSyntax operand, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 2;
        this.AdjustFlagsAndWidth(operatorToken);
        this.operatorToken = operatorToken;
        this.AdjustFlagsAndWidth(operand);
        this.operand = operand;
    }


    internal PrefixUnaryExpressionSyntax(SyntaxKind kind, SyntaxToken operatorToken, ExpressionSyntax operand)
        : base(kind)
    {
        this.SlotCount = 2;
        this.AdjustFlagsAndWidth(operatorToken);
        this.operatorToken = operatorToken;
        this.AdjustFlagsAndWidth(operand);
        this.operand = operand;
    }

    /// <summary>SyntaxToken representing the kind of the operator of the prefix unary expression.</summary>
    public SyntaxToken OperatorToken { get { return this.operatorToken; } }
    /// <summary>ExpressionSyntax representing the operand of the prefix unary expression.</summary>
    public ExpressionSyntax Operand { get { return this.operand; } }

    internal override GreenNode GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.operatorToken;
            case 1: return this.operand;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode parent, int position)
    {
      return new CSharp.Syntax.PrefixUnaryExpressionSyntax(this, parent, position);
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitPrefixUnaryExpression(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitPrefixUnaryExpression(this);
    }

    public PrefixUnaryExpressionSyntax Update(SyntaxToken operatorToken, ExpressionSyntax operand)
    {
        if (operatorToken != this.OperatorToken || operand != this.Operand)
        {
            var newNode = SyntaxFactory.PrefixUnaryExpression(this.Kind, operatorToken, operand);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
    {
         return new PrefixUnaryExpressionSyntax(this.Kind, this.operatorToken, this.operand, diagnostics, GetAnnotations());
    }

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
    {
         return new PrefixUnaryExpressionSyntax(this.Kind, this.operatorToken, this.operand, GetDiagnostics(), annotations);
    }

    internal PrefixUnaryExpressionSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 2;
      var operatorToken = (SyntaxToken)reader.ReadValue();
      if (operatorToken != null)
      {
         AdjustFlagsAndWidth(operatorToken);
         this.operatorToken = operatorToken;
      }
      var operand = (ExpressionSyntax)reader.ReadValue();
      if (operand != null)
      {
         AdjustFlagsAndWidth(operand);
         this.operand = operand;
      }
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.operatorToken);
      writer.WriteValue(this.operand);
    }

    static PrefixUnaryExpressionSyntax()
    {
       ObjectBinder.RegisterTypeReader(typeof(PrefixUnaryExpressionSyntax), r => new PrefixUnaryExpressionSyntax(r));
    }
  }

  /// <summary>Class which represents the syntax node for an "await" expression.</summary>
  internal sealed partial class AwaitExpressionSyntax : ExpressionSyntax
  {
    internal readonly SyntaxToken awaitKeyword;
    internal readonly ExpressionSyntax expression;

    internal AwaitExpressionSyntax(SyntaxKind kind, SyntaxToken awaitKeyword, ExpressionSyntax expression, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 2;
        this.AdjustFlagsAndWidth(awaitKeyword);
        this.awaitKeyword = awaitKeyword;
        this.AdjustFlagsAndWidth(expression);
        this.expression = expression;
    }


    internal AwaitExpressionSyntax(SyntaxKind kind, SyntaxToken awaitKeyword, ExpressionSyntax expression, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 2;
        this.AdjustFlagsAndWidth(awaitKeyword);
        this.awaitKeyword = awaitKeyword;
        this.AdjustFlagsAndWidth(expression);
        this.expression = expression;
    }


    internal AwaitExpressionSyntax(SyntaxKind kind, SyntaxToken awaitKeyword, ExpressionSyntax expression)
        : base(kind)
    {
        this.SlotCount = 2;
        this.AdjustFlagsAndWidth(awaitKeyword);
        this.awaitKeyword = awaitKeyword;
        this.AdjustFlagsAndWidth(expression);
        this.expression = expression;
    }

    /// <summary>SyntaxToken representing the kind "await" keyword.</summary>
    public SyntaxToken AwaitKeyword { get { return this.awaitKeyword; } }
    /// <summary>ExpressionSyntax representing the operand of the "await" operator.</summary>
    public ExpressionSyntax Expression { get { return this.expression; } }

    internal override GreenNode GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.awaitKeyword;
            case 1: return this.expression;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode parent, int position)
    {
      return new CSharp.Syntax.AwaitExpressionSyntax(this, parent, position);
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitAwaitExpression(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitAwaitExpression(this);
    }

    public AwaitExpressionSyntax Update(SyntaxToken awaitKeyword, ExpressionSyntax expression)
    {
        if (awaitKeyword != this.AwaitKeyword || expression != this.Expression)
        {
            var newNode = SyntaxFactory.AwaitExpression(awaitKeyword, expression);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
    {
         return new AwaitExpressionSyntax(this.Kind, this.awaitKeyword, this.expression, diagnostics, GetAnnotations());
    }

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
    {
         return new AwaitExpressionSyntax(this.Kind, this.awaitKeyword, this.expression, GetDiagnostics(), annotations);
    }

    internal AwaitExpressionSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 2;
      var awaitKeyword = (SyntaxToken)reader.ReadValue();
      if (awaitKeyword != null)
      {
         AdjustFlagsAndWidth(awaitKeyword);
         this.awaitKeyword = awaitKeyword;
      }
      var expression = (ExpressionSyntax)reader.ReadValue();
      if (expression != null)
      {
         AdjustFlagsAndWidth(expression);
         this.expression = expression;
      }
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.awaitKeyword);
      writer.WriteValue(this.expression);
    }

    static AwaitExpressionSyntax()
    {
       ObjectBinder.RegisterTypeReader(typeof(AwaitExpressionSyntax), r => new AwaitExpressionSyntax(r));
    }
  }

  /// <summary>Class which represents the syntax node for postfix unary expression.</summary>
  internal sealed partial class PostfixUnaryExpressionSyntax : ExpressionSyntax
  {
    internal readonly ExpressionSyntax operand;
    internal readonly SyntaxToken operatorToken;

    internal PostfixUnaryExpressionSyntax(SyntaxKind kind, ExpressionSyntax operand, SyntaxToken operatorToken, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 2;
        this.AdjustFlagsAndWidth(operand);
        this.operand = operand;
        this.AdjustFlagsAndWidth(operatorToken);
        this.operatorToken = operatorToken;
    }


    internal PostfixUnaryExpressionSyntax(SyntaxKind kind, ExpressionSyntax operand, SyntaxToken operatorToken, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 2;
        this.AdjustFlagsAndWidth(operand);
        this.operand = operand;
        this.AdjustFlagsAndWidth(operatorToken);
        this.operatorToken = operatorToken;
    }


    internal PostfixUnaryExpressionSyntax(SyntaxKind kind, ExpressionSyntax operand, SyntaxToken operatorToken)
        : base(kind)
    {
        this.SlotCount = 2;
        this.AdjustFlagsAndWidth(operand);
        this.operand = operand;
        this.AdjustFlagsAndWidth(operatorToken);
        this.operatorToken = operatorToken;
    }

    /// <summary>ExpressionSyntax representing the operand of the postfix unary expression.</summary>
    public ExpressionSyntax Operand { get { return this.operand; } }
    /// <summary>SyntaxToken representing the kind of the operator of the postfix unary expression.</summary>
    public SyntaxToken OperatorToken { get { return this.operatorToken; } }

    internal override GreenNode GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.operand;
            case 1: return this.operatorToken;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode parent, int position)
    {
      return new CSharp.Syntax.PostfixUnaryExpressionSyntax(this, parent, position);
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitPostfixUnaryExpression(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitPostfixUnaryExpression(this);
    }

    public PostfixUnaryExpressionSyntax Update(ExpressionSyntax operand, SyntaxToken operatorToken)
    {
        if (operand != this.Operand || operatorToken != this.OperatorToken)
        {
            var newNode = SyntaxFactory.PostfixUnaryExpression(this.Kind, operand, operatorToken);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
    {
         return new PostfixUnaryExpressionSyntax(this.Kind, this.operand, this.operatorToken, diagnostics, GetAnnotations());
    }

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
    {
         return new PostfixUnaryExpressionSyntax(this.Kind, this.operand, this.operatorToken, GetDiagnostics(), annotations);
    }

    internal PostfixUnaryExpressionSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 2;
      var operand = (ExpressionSyntax)reader.ReadValue();
      if (operand != null)
      {
         AdjustFlagsAndWidth(operand);
         this.operand = operand;
      }
      var operatorToken = (SyntaxToken)reader.ReadValue();
      if (operatorToken != null)
      {
         AdjustFlagsAndWidth(operatorToken);
         this.operatorToken = operatorToken;
      }
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.operand);
      writer.WriteValue(this.operatorToken);
    }

    static PostfixUnaryExpressionSyntax()
    {
       ObjectBinder.RegisterTypeReader(typeof(PostfixUnaryExpressionSyntax), r => new PostfixUnaryExpressionSyntax(r));
    }
  }

  /// <summary>Class which represents the syntax node for member access expression.</summary>
  internal sealed partial class MemberAccessExpressionSyntax : ExpressionSyntax
  {
    internal readonly ExpressionSyntax expression;
    internal readonly SyntaxToken operatorToken;
    internal readonly SimpleNameSyntax name;

    internal MemberAccessExpressionSyntax(SyntaxKind kind, ExpressionSyntax expression, SyntaxToken operatorToken, SimpleNameSyntax name, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 3;
        this.AdjustFlagsAndWidth(expression);
        this.expression = expression;
        this.AdjustFlagsAndWidth(operatorToken);
        this.operatorToken = operatorToken;
        this.AdjustFlagsAndWidth(name);
        this.name = name;
    }


    internal MemberAccessExpressionSyntax(SyntaxKind kind, ExpressionSyntax expression, SyntaxToken operatorToken, SimpleNameSyntax name, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 3;
        this.AdjustFlagsAndWidth(expression);
        this.expression = expression;
        this.AdjustFlagsAndWidth(operatorToken);
        this.operatorToken = operatorToken;
        this.AdjustFlagsAndWidth(name);
        this.name = name;
    }


    internal MemberAccessExpressionSyntax(SyntaxKind kind, ExpressionSyntax expression, SyntaxToken operatorToken, SimpleNameSyntax name)
        : base(kind)
    {
        this.SlotCount = 3;
        this.AdjustFlagsAndWidth(expression);
        this.expression = expression;
        this.AdjustFlagsAndWidth(operatorToken);
        this.operatorToken = operatorToken;
        this.AdjustFlagsAndWidth(name);
        this.name = name;
    }

    /// <summary>ExpressionSyntax node representing the object that the member belongs to.</summary>
    public ExpressionSyntax Expression { get { return this.expression; } }
    /// <summary>SyntaxToken representing the kind of the operator in the member access expression.</summary>
    public SyntaxToken OperatorToken { get { return this.operatorToken; } }
    /// <summary>SimpleNameSyntax node representing the member being accessed.</summary>
    public SimpleNameSyntax Name { get { return this.name; } }

    internal override GreenNode GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.expression;
            case 1: return this.operatorToken;
            case 2: return this.name;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode parent, int position)
    {
      return new CSharp.Syntax.MemberAccessExpressionSyntax(this, parent, position);
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitMemberAccessExpression(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitMemberAccessExpression(this);
    }

    public MemberAccessExpressionSyntax Update(ExpressionSyntax expression, SyntaxToken operatorToken, SimpleNameSyntax name)
    {
        if (expression != this.Expression || operatorToken != this.OperatorToken || name != this.Name)
        {
            var newNode = SyntaxFactory.MemberAccessExpression(this.Kind, expression, operatorToken, name);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
    {
         return new MemberAccessExpressionSyntax(this.Kind, this.expression, this.operatorToken, this.name, diagnostics, GetAnnotations());
    }

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
    {
         return new MemberAccessExpressionSyntax(this.Kind, this.expression, this.operatorToken, this.name, GetDiagnostics(), annotations);
    }

    internal MemberAccessExpressionSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 3;
      var expression = (ExpressionSyntax)reader.ReadValue();
      if (expression != null)
      {
         AdjustFlagsAndWidth(expression);
         this.expression = expression;
      }
      var operatorToken = (SyntaxToken)reader.ReadValue();
      if (operatorToken != null)
      {
         AdjustFlagsAndWidth(operatorToken);
         this.operatorToken = operatorToken;
      }
      var name = (SimpleNameSyntax)reader.ReadValue();
      if (name != null)
      {
         AdjustFlagsAndWidth(name);
         this.name = name;
      }
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.expression);
      writer.WriteValue(this.operatorToken);
      writer.WriteValue(this.name);
    }

    static MemberAccessExpressionSyntax()
    {
       ObjectBinder.RegisterTypeReader(typeof(MemberAccessExpressionSyntax), r => new MemberAccessExpressionSyntax(r));
    }
  }

  /// <summary>Class which represents the syntax node for conditional access expression.</summary>
  internal sealed partial class ConditionalAccessExpressionSyntax : ExpressionSyntax
  {
    internal readonly ExpressionSyntax expression;
    internal readonly SyntaxToken operatorToken;
    internal readonly ExpressionSyntax whenNotNull;

    internal ConditionalAccessExpressionSyntax(SyntaxKind kind, ExpressionSyntax expression, SyntaxToken operatorToken, ExpressionSyntax whenNotNull, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 3;
        this.AdjustFlagsAndWidth(expression);
        this.expression = expression;
        this.AdjustFlagsAndWidth(operatorToken);
        this.operatorToken = operatorToken;
        this.AdjustFlagsAndWidth(whenNotNull);
        this.whenNotNull = whenNotNull;
    }


    internal ConditionalAccessExpressionSyntax(SyntaxKind kind, ExpressionSyntax expression, SyntaxToken operatorToken, ExpressionSyntax whenNotNull, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 3;
        this.AdjustFlagsAndWidth(expression);
        this.expression = expression;
        this.AdjustFlagsAndWidth(operatorToken);
        this.operatorToken = operatorToken;
        this.AdjustFlagsAndWidth(whenNotNull);
        this.whenNotNull = whenNotNull;
    }


    internal ConditionalAccessExpressionSyntax(SyntaxKind kind, ExpressionSyntax expression, SyntaxToken operatorToken, ExpressionSyntax whenNotNull)
        : base(kind)
    {
        this.SlotCount = 3;
        this.AdjustFlagsAndWidth(expression);
        this.expression = expression;
        this.AdjustFlagsAndWidth(operatorToken);
        this.operatorToken = operatorToken;
        this.AdjustFlagsAndWidth(whenNotNull);
        this.whenNotNull = whenNotNull;
    }

    /// <summary>ExpressionSyntax node representing the object conditionally accessed.</summary>
    public ExpressionSyntax Expression { get { return this.expression; } }
    /// <summary>SyntaxToken representing the question mark.</summary>
    public SyntaxToken OperatorToken { get { return this.operatorToken; } }
    /// <summary>ExpressionSyntax node representing the access expression to be executed when the object is not null.</summary>
    public ExpressionSyntax WhenNotNull { get { return this.whenNotNull; } }

    internal override GreenNode GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.expression;
            case 1: return this.operatorToken;
            case 2: return this.whenNotNull;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode parent, int position)
    {
      return new CSharp.Syntax.ConditionalAccessExpressionSyntax(this, parent, position);
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitConditionalAccessExpression(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitConditionalAccessExpression(this);
    }

    public ConditionalAccessExpressionSyntax Update(ExpressionSyntax expression, SyntaxToken operatorToken, ExpressionSyntax whenNotNull)
    {
        if (expression != this.Expression || operatorToken != this.OperatorToken || whenNotNull != this.WhenNotNull)
        {
            var newNode = SyntaxFactory.ConditionalAccessExpression(expression, operatorToken, whenNotNull);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
    {
         return new ConditionalAccessExpressionSyntax(this.Kind, this.expression, this.operatorToken, this.whenNotNull, diagnostics, GetAnnotations());
    }

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
    {
         return new ConditionalAccessExpressionSyntax(this.Kind, this.expression, this.operatorToken, this.whenNotNull, GetDiagnostics(), annotations);
    }

    internal ConditionalAccessExpressionSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 3;
      var expression = (ExpressionSyntax)reader.ReadValue();
      if (expression != null)
      {
         AdjustFlagsAndWidth(expression);
         this.expression = expression;
      }
      var operatorToken = (SyntaxToken)reader.ReadValue();
      if (operatorToken != null)
      {
         AdjustFlagsAndWidth(operatorToken);
         this.operatorToken = operatorToken;
      }
      var whenNotNull = (ExpressionSyntax)reader.ReadValue();
      if (whenNotNull != null)
      {
         AdjustFlagsAndWidth(whenNotNull);
         this.whenNotNull = whenNotNull;
      }
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.expression);
      writer.WriteValue(this.operatorToken);
      writer.WriteValue(this.whenNotNull);
    }

    static ConditionalAccessExpressionSyntax()
    {
       ObjectBinder.RegisterTypeReader(typeof(ConditionalAccessExpressionSyntax), r => new ConditionalAccessExpressionSyntax(r));
    }
  }

  /// <summary>Class which represents the syntax node for member binding expression.</summary>
  internal sealed partial class MemberBindingExpressionSyntax : ExpressionSyntax
  {
    internal readonly SyntaxToken operatorToken;
    internal readonly SimpleNameSyntax name;

    internal MemberBindingExpressionSyntax(SyntaxKind kind, SyntaxToken operatorToken, SimpleNameSyntax name, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 2;
        this.AdjustFlagsAndWidth(operatorToken);
        this.operatorToken = operatorToken;
        this.AdjustFlagsAndWidth(name);
        this.name = name;
    }


    internal MemberBindingExpressionSyntax(SyntaxKind kind, SyntaxToken operatorToken, SimpleNameSyntax name, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 2;
        this.AdjustFlagsAndWidth(operatorToken);
        this.operatorToken = operatorToken;
        this.AdjustFlagsAndWidth(name);
        this.name = name;
    }


    internal MemberBindingExpressionSyntax(SyntaxKind kind, SyntaxToken operatorToken, SimpleNameSyntax name)
        : base(kind)
    {
        this.SlotCount = 2;
        this.AdjustFlagsAndWidth(operatorToken);
        this.operatorToken = operatorToken;
        this.AdjustFlagsAndWidth(name);
        this.name = name;
    }

    /// <summary>SyntaxToken representing dot.</summary>
    public SyntaxToken OperatorToken { get { return this.operatorToken; } }
    /// <summary>SimpleNameSyntax node representing the member being bound to.</summary>
    public SimpleNameSyntax Name { get { return this.name; } }

    internal override GreenNode GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.operatorToken;
            case 1: return this.name;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode parent, int position)
    {
      return new CSharp.Syntax.MemberBindingExpressionSyntax(this, parent, position);
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitMemberBindingExpression(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitMemberBindingExpression(this);
    }

    public MemberBindingExpressionSyntax Update(SyntaxToken operatorToken, SimpleNameSyntax name)
    {
        if (operatorToken != this.OperatorToken || name != this.Name)
        {
            var newNode = SyntaxFactory.MemberBindingExpression(operatorToken, name);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
    {
         return new MemberBindingExpressionSyntax(this.Kind, this.operatorToken, this.name, diagnostics, GetAnnotations());
    }

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
    {
         return new MemberBindingExpressionSyntax(this.Kind, this.operatorToken, this.name, GetDiagnostics(), annotations);
    }

    internal MemberBindingExpressionSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 2;
      var operatorToken = (SyntaxToken)reader.ReadValue();
      if (operatorToken != null)
      {
         AdjustFlagsAndWidth(operatorToken);
         this.operatorToken = operatorToken;
      }
      var name = (SimpleNameSyntax)reader.ReadValue();
      if (name != null)
      {
         AdjustFlagsAndWidth(name);
         this.name = name;
      }
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.operatorToken);
      writer.WriteValue(this.name);
    }

    static MemberBindingExpressionSyntax()
    {
       ObjectBinder.RegisterTypeReader(typeof(MemberBindingExpressionSyntax), r => new MemberBindingExpressionSyntax(r));
    }
  }

  /// <summary>Class which represents the syntax node for element binding expression.</summary>
  internal sealed partial class ElementBindingExpressionSyntax : ExpressionSyntax
  {
    internal readonly BracketedArgumentListSyntax argumentList;

    internal ElementBindingExpressionSyntax(SyntaxKind kind, BracketedArgumentListSyntax argumentList, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 1;
        this.AdjustFlagsAndWidth(argumentList);
        this.argumentList = argumentList;
    }


    internal ElementBindingExpressionSyntax(SyntaxKind kind, BracketedArgumentListSyntax argumentList, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 1;
        this.AdjustFlagsAndWidth(argumentList);
        this.argumentList = argumentList;
    }


    internal ElementBindingExpressionSyntax(SyntaxKind kind, BracketedArgumentListSyntax argumentList)
        : base(kind)
    {
        this.SlotCount = 1;
        this.AdjustFlagsAndWidth(argumentList);
        this.argumentList = argumentList;
    }

    /// <summary>BracketedArgumentListSyntax node representing the list of arguments of the element binding expression.</summary>
    public BracketedArgumentListSyntax ArgumentList { get { return this.argumentList; } }

    internal override GreenNode GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.argumentList;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode parent, int position)
    {
      return new CSharp.Syntax.ElementBindingExpressionSyntax(this, parent, position);
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitElementBindingExpression(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitElementBindingExpression(this);
    }

    public ElementBindingExpressionSyntax Update(BracketedArgumentListSyntax argumentList)
    {
        if (argumentList != this.ArgumentList)
        {
            var newNode = SyntaxFactory.ElementBindingExpression(argumentList);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
    {
         return new ElementBindingExpressionSyntax(this.Kind, this.argumentList, diagnostics, GetAnnotations());
    }

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
    {
         return new ElementBindingExpressionSyntax(this.Kind, this.argumentList, GetDiagnostics(), annotations);
    }

    internal ElementBindingExpressionSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 1;
      var argumentList = (BracketedArgumentListSyntax)reader.ReadValue();
      if (argumentList != null)
      {
         AdjustFlagsAndWidth(argumentList);
         this.argumentList = argumentList;
      }
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.argumentList);
    }

    static ElementBindingExpressionSyntax()
    {
       ObjectBinder.RegisterTypeReader(typeof(ElementBindingExpressionSyntax), r => new ElementBindingExpressionSyntax(r));
    }
  }

  /// <summary>Class which represents the syntax node for implicit element access expression.</summary>
  internal sealed partial class ImplicitElementAccessSyntax : ExpressionSyntax
  {
    internal readonly BracketedArgumentListSyntax argumentList;

    internal ImplicitElementAccessSyntax(SyntaxKind kind, BracketedArgumentListSyntax argumentList, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 1;
        this.AdjustFlagsAndWidth(argumentList);
        this.argumentList = argumentList;
    }


    internal ImplicitElementAccessSyntax(SyntaxKind kind, BracketedArgumentListSyntax argumentList, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 1;
        this.AdjustFlagsAndWidth(argumentList);
        this.argumentList = argumentList;
    }


    internal ImplicitElementAccessSyntax(SyntaxKind kind, BracketedArgumentListSyntax argumentList)
        : base(kind)
    {
        this.SlotCount = 1;
        this.AdjustFlagsAndWidth(argumentList);
        this.argumentList = argumentList;
    }

    /// <summary>BracketedArgumentListSyntax node representing the list of arguments of the implicit element access expression.</summary>
    public BracketedArgumentListSyntax ArgumentList { get { return this.argumentList; } }

    internal override GreenNode GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.argumentList;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode parent, int position)
    {
      return new CSharp.Syntax.ImplicitElementAccessSyntax(this, parent, position);
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitImplicitElementAccess(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitImplicitElementAccess(this);
    }

    public ImplicitElementAccessSyntax Update(BracketedArgumentListSyntax argumentList)
    {
        if (argumentList != this.ArgumentList)
        {
            var newNode = SyntaxFactory.ImplicitElementAccess(argumentList);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
    {
         return new ImplicitElementAccessSyntax(this.Kind, this.argumentList, diagnostics, GetAnnotations());
    }

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
    {
         return new ImplicitElementAccessSyntax(this.Kind, this.argumentList, GetDiagnostics(), annotations);
    }

    internal ImplicitElementAccessSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 1;
      var argumentList = (BracketedArgumentListSyntax)reader.ReadValue();
      if (argumentList != null)
      {
         AdjustFlagsAndWidth(argumentList);
         this.argumentList = argumentList;
      }
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.argumentList);
    }

    static ImplicitElementAccessSyntax()
    {
       ObjectBinder.RegisterTypeReader(typeof(ImplicitElementAccessSyntax), r => new ImplicitElementAccessSyntax(r));
    }
  }

  /// <summary>Class which represents an expression that has a binary operator.</summary>
  internal sealed partial class BinaryExpressionSyntax : ExpressionSyntax
  {
    internal readonly ExpressionSyntax left;
    internal readonly SyntaxToken operatorToken;
    internal readonly ExpressionSyntax right;

    internal BinaryExpressionSyntax(SyntaxKind kind, ExpressionSyntax left, SyntaxToken operatorToken, ExpressionSyntax right, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 3;
        this.AdjustFlagsAndWidth(left);
        this.left = left;
        this.AdjustFlagsAndWidth(operatorToken);
        this.operatorToken = operatorToken;
        this.AdjustFlagsAndWidth(right);
        this.right = right;
    }


    internal BinaryExpressionSyntax(SyntaxKind kind, ExpressionSyntax left, SyntaxToken operatorToken, ExpressionSyntax right, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 3;
        this.AdjustFlagsAndWidth(left);
        this.left = left;
        this.AdjustFlagsAndWidth(operatorToken);
        this.operatorToken = operatorToken;
        this.AdjustFlagsAndWidth(right);
        this.right = right;
    }


    internal BinaryExpressionSyntax(SyntaxKind kind, ExpressionSyntax left, SyntaxToken operatorToken, ExpressionSyntax right)
        : base(kind)
    {
        this.SlotCount = 3;
        this.AdjustFlagsAndWidth(left);
        this.left = left;
        this.AdjustFlagsAndWidth(operatorToken);
        this.operatorToken = operatorToken;
        this.AdjustFlagsAndWidth(right);
        this.right = right;
    }

    /// <summary>ExpressionSyntax node representing the expression on the left of the binary operator.</summary>
    public ExpressionSyntax Left { get { return this.left; } }
    /// <summary>SyntaxToken representing the operator of the binary expression.</summary>
    public SyntaxToken OperatorToken { get { return this.operatorToken; } }
    /// <summary>ExpressionSyntax node representing the expression on the right of the binary operator.</summary>
    public ExpressionSyntax Right { get { return this.right; } }

    internal override GreenNode GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.left;
            case 1: return this.operatorToken;
            case 2: return this.right;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode parent, int position)
    {
      return new CSharp.Syntax.BinaryExpressionSyntax(this, parent, position);
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitBinaryExpression(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitBinaryExpression(this);
    }

    public BinaryExpressionSyntax Update(ExpressionSyntax left, SyntaxToken operatorToken, ExpressionSyntax right)
    {
        if (left != this.Left || operatorToken != this.OperatorToken || right != this.Right)
        {
            var newNode = SyntaxFactory.BinaryExpression(this.Kind, left, operatorToken, right);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
    {
         return new BinaryExpressionSyntax(this.Kind, this.left, this.operatorToken, this.right, diagnostics, GetAnnotations());
    }

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
    {
         return new BinaryExpressionSyntax(this.Kind, this.left, this.operatorToken, this.right, GetDiagnostics(), annotations);
    }

    internal BinaryExpressionSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 3;
      var left = (ExpressionSyntax)reader.ReadValue();
      if (left != null)
      {
         AdjustFlagsAndWidth(left);
         this.left = left;
      }
      var operatorToken = (SyntaxToken)reader.ReadValue();
      if (operatorToken != null)
      {
         AdjustFlagsAndWidth(operatorToken);
         this.operatorToken = operatorToken;
      }
      var right = (ExpressionSyntax)reader.ReadValue();
      if (right != null)
      {
         AdjustFlagsAndWidth(right);
         this.right = right;
      }
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.left);
      writer.WriteValue(this.operatorToken);
      writer.WriteValue(this.right);
    }

    static BinaryExpressionSyntax()
    {
       ObjectBinder.RegisterTypeReader(typeof(BinaryExpressionSyntax), r => new BinaryExpressionSyntax(r));
    }
  }

  /// <summary>Class which represents an expression that has an assignment operator.</summary>
  internal sealed partial class AssignmentExpressionSyntax : ExpressionSyntax
  {
    internal readonly ExpressionSyntax left;
    internal readonly SyntaxToken operatorToken;
    internal readonly ExpressionSyntax right;

    internal AssignmentExpressionSyntax(SyntaxKind kind, ExpressionSyntax left, SyntaxToken operatorToken, ExpressionSyntax right, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 3;
        this.AdjustFlagsAndWidth(left);
        this.left = left;
        this.AdjustFlagsAndWidth(operatorToken);
        this.operatorToken = operatorToken;
        this.AdjustFlagsAndWidth(right);
        this.right = right;
    }


    internal AssignmentExpressionSyntax(SyntaxKind kind, ExpressionSyntax left, SyntaxToken operatorToken, ExpressionSyntax right, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 3;
        this.AdjustFlagsAndWidth(left);
        this.left = left;
        this.AdjustFlagsAndWidth(operatorToken);
        this.operatorToken = operatorToken;
        this.AdjustFlagsAndWidth(right);
        this.right = right;
    }


    internal AssignmentExpressionSyntax(SyntaxKind kind, ExpressionSyntax left, SyntaxToken operatorToken, ExpressionSyntax right)
        : base(kind)
    {
        this.SlotCount = 3;
        this.AdjustFlagsAndWidth(left);
        this.left = left;
        this.AdjustFlagsAndWidth(operatorToken);
        this.operatorToken = operatorToken;
        this.AdjustFlagsAndWidth(right);
        this.right = right;
    }

    /// <summary>ExpressionSyntax node representing the expression on the left of the assignment operator.</summary>
    public ExpressionSyntax Left { get { return this.left; } }
    /// <summary>SyntaxToken representing the operator of the assignment expression.</summary>
    public SyntaxToken OperatorToken { get { return this.operatorToken; } }
    /// <summary>ExpressionSyntax node representing the expression on the right of the assignment operator.</summary>
    public ExpressionSyntax Right { get { return this.right; } }

    internal override GreenNode GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.left;
            case 1: return this.operatorToken;
            case 2: return this.right;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode parent, int position)
    {
      return new CSharp.Syntax.AssignmentExpressionSyntax(this, parent, position);
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitAssignmentExpression(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitAssignmentExpression(this);
    }

    public AssignmentExpressionSyntax Update(ExpressionSyntax left, SyntaxToken operatorToken, ExpressionSyntax right)
    {
        if (left != this.Left || operatorToken != this.OperatorToken || right != this.Right)
        {
            var newNode = SyntaxFactory.AssignmentExpression(this.Kind, left, operatorToken, right);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
    {
         return new AssignmentExpressionSyntax(this.Kind, this.left, this.operatorToken, this.right, diagnostics, GetAnnotations());
    }

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
    {
         return new AssignmentExpressionSyntax(this.Kind, this.left, this.operatorToken, this.right, GetDiagnostics(), annotations);
    }

    internal AssignmentExpressionSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 3;
      var left = (ExpressionSyntax)reader.ReadValue();
      if (left != null)
      {
         AdjustFlagsAndWidth(left);
         this.left = left;
      }
      var operatorToken = (SyntaxToken)reader.ReadValue();
      if (operatorToken != null)
      {
         AdjustFlagsAndWidth(operatorToken);
         this.operatorToken = operatorToken;
      }
      var right = (ExpressionSyntax)reader.ReadValue();
      if (right != null)
      {
         AdjustFlagsAndWidth(right);
         this.right = right;
      }
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.left);
      writer.WriteValue(this.operatorToken);
      writer.WriteValue(this.right);
    }

    static AssignmentExpressionSyntax()
    {
       ObjectBinder.RegisterTypeReader(typeof(AssignmentExpressionSyntax), r => new AssignmentExpressionSyntax(r));
    }
  }

  /// <summary>Class which represents the syntax node for conditional expression.</summary>
  internal sealed partial class ConditionalExpressionSyntax : ExpressionSyntax
  {
    internal readonly ExpressionSyntax condition;
    internal readonly SyntaxToken questionToken;
    internal readonly ExpressionSyntax whenTrue;
    internal readonly SyntaxToken colonToken;
    internal readonly ExpressionSyntax whenFalse;

    internal ConditionalExpressionSyntax(SyntaxKind kind, ExpressionSyntax condition, SyntaxToken questionToken, ExpressionSyntax whenTrue, SyntaxToken colonToken, ExpressionSyntax whenFalse, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 5;
        this.AdjustFlagsAndWidth(condition);
        this.condition = condition;
        this.AdjustFlagsAndWidth(questionToken);
        this.questionToken = questionToken;
        this.AdjustFlagsAndWidth(whenTrue);
        this.whenTrue = whenTrue;
        this.AdjustFlagsAndWidth(colonToken);
        this.colonToken = colonToken;
        this.AdjustFlagsAndWidth(whenFalse);
        this.whenFalse = whenFalse;
    }


    internal ConditionalExpressionSyntax(SyntaxKind kind, ExpressionSyntax condition, SyntaxToken questionToken, ExpressionSyntax whenTrue, SyntaxToken colonToken, ExpressionSyntax whenFalse, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 5;
        this.AdjustFlagsAndWidth(condition);
        this.condition = condition;
        this.AdjustFlagsAndWidth(questionToken);
        this.questionToken = questionToken;
        this.AdjustFlagsAndWidth(whenTrue);
        this.whenTrue = whenTrue;
        this.AdjustFlagsAndWidth(colonToken);
        this.colonToken = colonToken;
        this.AdjustFlagsAndWidth(whenFalse);
        this.whenFalse = whenFalse;
    }


    internal ConditionalExpressionSyntax(SyntaxKind kind, ExpressionSyntax condition, SyntaxToken questionToken, ExpressionSyntax whenTrue, SyntaxToken colonToken, ExpressionSyntax whenFalse)
        : base(kind)
    {
        this.SlotCount = 5;
        this.AdjustFlagsAndWidth(condition);
        this.condition = condition;
        this.AdjustFlagsAndWidth(questionToken);
        this.questionToken = questionToken;
        this.AdjustFlagsAndWidth(whenTrue);
        this.whenTrue = whenTrue;
        this.AdjustFlagsAndWidth(colonToken);
        this.colonToken = colonToken;
        this.AdjustFlagsAndWidth(whenFalse);
        this.whenFalse = whenFalse;
    }

    /// <summary>ExpressionSyntax node representing the condition of the conditional expression.</summary>
    public ExpressionSyntax Condition { get { return this.condition; } }
    /// <summary>SyntaxToken representing the question mark.</summary>
    public SyntaxToken QuestionToken { get { return this.questionToken; } }
    /// <summary>ExpressionSyntax node representing the expression to be executed when the condition is true.</summary>
    public ExpressionSyntax WhenTrue { get { return this.whenTrue; } }
    /// <summary>SyntaxToken representing the colon.</summary>
    public SyntaxToken ColonToken { get { return this.colonToken; } }
    /// <summary>ExpressionSyntax node representing the expression to be executed when the condition is false.</summary>
    public ExpressionSyntax WhenFalse { get { return this.whenFalse; } }

    internal override GreenNode GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.condition;
            case 1: return this.questionToken;
            case 2: return this.whenTrue;
            case 3: return this.colonToken;
            case 4: return this.whenFalse;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode parent, int position)
    {
      return new CSharp.Syntax.ConditionalExpressionSyntax(this, parent, position);
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitConditionalExpression(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitConditionalExpression(this);
    }

    public ConditionalExpressionSyntax Update(ExpressionSyntax condition, SyntaxToken questionToken, ExpressionSyntax whenTrue, SyntaxToken colonToken, ExpressionSyntax whenFalse)
    {
        if (condition != this.Condition || questionToken != this.QuestionToken || whenTrue != this.WhenTrue || colonToken != this.ColonToken || whenFalse != this.WhenFalse)
        {
            var newNode = SyntaxFactory.ConditionalExpression(condition, questionToken, whenTrue, colonToken, whenFalse);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
    {
         return new ConditionalExpressionSyntax(this.Kind, this.condition, this.questionToken, this.whenTrue, this.colonToken, this.whenFalse, diagnostics, GetAnnotations());
    }

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
    {
         return new ConditionalExpressionSyntax(this.Kind, this.condition, this.questionToken, this.whenTrue, this.colonToken, this.whenFalse, GetDiagnostics(), annotations);
    }

    internal ConditionalExpressionSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 5;
      var condition = (ExpressionSyntax)reader.ReadValue();
      if (condition != null)
      {
         AdjustFlagsAndWidth(condition);
         this.condition = condition;
      }
      var questionToken = (SyntaxToken)reader.ReadValue();
      if (questionToken != null)
      {
         AdjustFlagsAndWidth(questionToken);
         this.questionToken = questionToken;
      }
      var whenTrue = (ExpressionSyntax)reader.ReadValue();
      if (whenTrue != null)
      {
         AdjustFlagsAndWidth(whenTrue);
         this.whenTrue = whenTrue;
      }
      var colonToken = (SyntaxToken)reader.ReadValue();
      if (colonToken != null)
      {
         AdjustFlagsAndWidth(colonToken);
         this.colonToken = colonToken;
      }
      var whenFalse = (ExpressionSyntax)reader.ReadValue();
      if (whenFalse != null)
      {
         AdjustFlagsAndWidth(whenFalse);
         this.whenFalse = whenFalse;
      }
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.condition);
      writer.WriteValue(this.questionToken);
      writer.WriteValue(this.whenTrue);
      writer.WriteValue(this.colonToken);
      writer.WriteValue(this.whenFalse);
    }

    static ConditionalExpressionSyntax()
    {
       ObjectBinder.RegisterTypeReader(typeof(ConditionalExpressionSyntax), r => new ConditionalExpressionSyntax(r));
    }
  }

  /// <summary>Provides the base class from which the classes that represent instance expression syntax nodes are derived. This is an abstract class.</summary>
  internal abstract partial class InstanceExpressionSyntax : ExpressionSyntax
  {
    internal InstanceExpressionSyntax(SyntaxKind kind, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
      : base(kind, diagnostics, annotations)
    {
    }
    internal InstanceExpressionSyntax(SyntaxKind kind)
      : base(kind)
    {
    }

    protected InstanceExpressionSyntax(ObjectReader reader)
       : base(reader)
    {
    }
  }

  /// <summary>Class which represents the syntax node for a this expression.</summary>
  internal sealed partial class ThisExpressionSyntax : InstanceExpressionSyntax
  {
    internal readonly SyntaxToken token;

    internal ThisExpressionSyntax(SyntaxKind kind, SyntaxToken token, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 1;
        this.AdjustFlagsAndWidth(token);
        this.token = token;
    }


    internal ThisExpressionSyntax(SyntaxKind kind, SyntaxToken token, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 1;
        this.AdjustFlagsAndWidth(token);
        this.token = token;
    }


    internal ThisExpressionSyntax(SyntaxKind kind, SyntaxToken token)
        : base(kind)
    {
        this.SlotCount = 1;
        this.AdjustFlagsAndWidth(token);
        this.token = token;
    }

    /// <summary>SyntaxToken representing the this keyword.</summary>
    public SyntaxToken Token { get { return this.token; } }

    internal override GreenNode GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.token;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode parent, int position)
    {
      return new CSharp.Syntax.ThisExpressionSyntax(this, parent, position);
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitThisExpression(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitThisExpression(this);
    }

    public ThisExpressionSyntax Update(SyntaxToken token)
    {
        if (token != this.Token)
        {
            var newNode = SyntaxFactory.ThisExpression(token);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
    {
         return new ThisExpressionSyntax(this.Kind, this.token, diagnostics, GetAnnotations());
    }

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
    {
         return new ThisExpressionSyntax(this.Kind, this.token, GetDiagnostics(), annotations);
    }

    internal ThisExpressionSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 1;
      var token = (SyntaxToken)reader.ReadValue();
      if (token != null)
      {
         AdjustFlagsAndWidth(token);
         this.token = token;
      }
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.token);
    }

    static ThisExpressionSyntax()
    {
       ObjectBinder.RegisterTypeReader(typeof(ThisExpressionSyntax), r => new ThisExpressionSyntax(r));
    }
  }

  /// <summary>Class which represents the syntax node for a base expression.</summary>
  internal sealed partial class BaseExpressionSyntax : InstanceExpressionSyntax
  {
    internal readonly SyntaxToken token;

    internal BaseExpressionSyntax(SyntaxKind kind, SyntaxToken token, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 1;
        this.AdjustFlagsAndWidth(token);
        this.token = token;
    }


    internal BaseExpressionSyntax(SyntaxKind kind, SyntaxToken token, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 1;
        this.AdjustFlagsAndWidth(token);
        this.token = token;
    }


    internal BaseExpressionSyntax(SyntaxKind kind, SyntaxToken token)
        : base(kind)
    {
        this.SlotCount = 1;
        this.AdjustFlagsAndWidth(token);
        this.token = token;
    }

    /// <summary>SyntaxToken representing the base keyword.</summary>
    public SyntaxToken Token { get { return this.token; } }

    internal override GreenNode GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.token;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode parent, int position)
    {
      return new CSharp.Syntax.BaseExpressionSyntax(this, parent, position);
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitBaseExpression(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitBaseExpression(this);
    }

    public BaseExpressionSyntax Update(SyntaxToken token)
    {
        if (token != this.Token)
        {
            var newNode = SyntaxFactory.BaseExpression(token);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
    {
         return new BaseExpressionSyntax(this.Kind, this.token, diagnostics, GetAnnotations());
    }

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
    {
         return new BaseExpressionSyntax(this.Kind, this.token, GetDiagnostics(), annotations);
    }

    internal BaseExpressionSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 1;
      var token = (SyntaxToken)reader.ReadValue();
      if (token != null)
      {
         AdjustFlagsAndWidth(token);
         this.token = token;
      }
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.token);
    }

    static BaseExpressionSyntax()
    {
       ObjectBinder.RegisterTypeReader(typeof(BaseExpressionSyntax), r => new BaseExpressionSyntax(r));
    }
  }

  /// <summary>Class which represents the syntax node for a literal expression.</summary>
  internal sealed partial class LiteralExpressionSyntax : ExpressionSyntax
  {
    internal readonly SyntaxToken token;

    internal LiteralExpressionSyntax(SyntaxKind kind, SyntaxToken token, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 1;
        this.AdjustFlagsAndWidth(token);
        this.token = token;
    }


    internal LiteralExpressionSyntax(SyntaxKind kind, SyntaxToken token, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 1;
        this.AdjustFlagsAndWidth(token);
        this.token = token;
    }


    internal LiteralExpressionSyntax(SyntaxKind kind, SyntaxToken token)
        : base(kind)
    {
        this.SlotCount = 1;
        this.AdjustFlagsAndWidth(token);
        this.token = token;
    }

    /// <summary>SyntaxToken representing the keyword corresponding to the kind of the literal expression.</summary>
    public SyntaxToken Token { get { return this.token; } }

    internal override GreenNode GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.token;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode parent, int position)
    {
      return new CSharp.Syntax.LiteralExpressionSyntax(this, parent, position);
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitLiteralExpression(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitLiteralExpression(this);
    }

    public LiteralExpressionSyntax Update(SyntaxToken token)
    {
        if (token != this.Token)
        {
            var newNode = SyntaxFactory.LiteralExpression(this.Kind, token);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
    {
         return new LiteralExpressionSyntax(this.Kind, this.token, diagnostics, GetAnnotations());
    }

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
    {
         return new LiteralExpressionSyntax(this.Kind, this.token, GetDiagnostics(), annotations);
    }

    internal LiteralExpressionSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 1;
      var token = (SyntaxToken)reader.ReadValue();
      if (token != null)
      {
         AdjustFlagsAndWidth(token);
         this.token = token;
      }
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.token);
    }

    static LiteralExpressionSyntax()
    {
       ObjectBinder.RegisterTypeReader(typeof(LiteralExpressionSyntax), r => new LiteralExpressionSyntax(r));
    }
  }

  /// <summary>Class which represents the syntax node for MakeRef expression.</summary>
  internal sealed partial class MakeRefExpressionSyntax : ExpressionSyntax
  {
    internal readonly SyntaxToken keyword;
    internal readonly SyntaxToken openParenToken;
    internal readonly ExpressionSyntax expression;
    internal readonly SyntaxToken closeParenToken;

    internal MakeRefExpressionSyntax(SyntaxKind kind, SyntaxToken keyword, SyntaxToken openParenToken, ExpressionSyntax expression, SyntaxToken closeParenToken, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 4;
        this.AdjustFlagsAndWidth(keyword);
        this.keyword = keyword;
        this.AdjustFlagsAndWidth(openParenToken);
        this.openParenToken = openParenToken;
        this.AdjustFlagsAndWidth(expression);
        this.expression = expression;
        this.AdjustFlagsAndWidth(closeParenToken);
        this.closeParenToken = closeParenToken;
    }


    internal MakeRefExpressionSyntax(SyntaxKind kind, SyntaxToken keyword, SyntaxToken openParenToken, ExpressionSyntax expression, SyntaxToken closeParenToken, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 4;
        this.AdjustFlagsAndWidth(keyword);
        this.keyword = keyword;
        this.AdjustFlagsAndWidth(openParenToken);
        this.openParenToken = openParenToken;
        this.AdjustFlagsAndWidth(expression);
        this.expression = expression;
        this.AdjustFlagsAndWidth(closeParenToken);
        this.closeParenToken = closeParenToken;
    }


    internal MakeRefExpressionSyntax(SyntaxKind kind, SyntaxToken keyword, SyntaxToken openParenToken, ExpressionSyntax expression, SyntaxToken closeParenToken)
        : base(kind)
    {
        this.SlotCount = 4;
        this.AdjustFlagsAndWidth(keyword);
        this.keyword = keyword;
        this.AdjustFlagsAndWidth(openParenToken);
        this.openParenToken = openParenToken;
        this.AdjustFlagsAndWidth(expression);
        this.expression = expression;
        this.AdjustFlagsAndWidth(closeParenToken);
        this.closeParenToken = closeParenToken;
    }

    /// <summary>SyntaxToken representing the MakeRefKeyword.</summary>
    public SyntaxToken Keyword { get { return this.keyword; } }
    /// <summary>SyntaxToken representing open parenthesis.</summary>
    public SyntaxToken OpenParenToken { get { return this.openParenToken; } }
    /// <summary>Argument of the primary function.</summary>
    public ExpressionSyntax Expression { get { return this.expression; } }
    /// <summary>SyntaxToken representing close parenthesis.</summary>
    public SyntaxToken CloseParenToken { get { return this.closeParenToken; } }

    internal override GreenNode GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.keyword;
            case 1: return this.openParenToken;
            case 2: return this.expression;
            case 3: return this.closeParenToken;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode parent, int position)
    {
      return new CSharp.Syntax.MakeRefExpressionSyntax(this, parent, position);
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitMakeRefExpression(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitMakeRefExpression(this);
    }

    public MakeRefExpressionSyntax Update(SyntaxToken keyword, SyntaxToken openParenToken, ExpressionSyntax expression, SyntaxToken closeParenToken)
    {
        if (keyword != this.Keyword || openParenToken != this.OpenParenToken || expression != this.Expression || closeParenToken != this.CloseParenToken)
        {
            var newNode = SyntaxFactory.MakeRefExpression(keyword, openParenToken, expression, closeParenToken);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
    {
         return new MakeRefExpressionSyntax(this.Kind, this.keyword, this.openParenToken, this.expression, this.closeParenToken, diagnostics, GetAnnotations());
    }

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
    {
         return new MakeRefExpressionSyntax(this.Kind, this.keyword, this.openParenToken, this.expression, this.closeParenToken, GetDiagnostics(), annotations);
    }

    internal MakeRefExpressionSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 4;
      var keyword = (SyntaxToken)reader.ReadValue();
      if (keyword != null)
      {
         AdjustFlagsAndWidth(keyword);
         this.keyword = keyword;
      }
      var openParenToken = (SyntaxToken)reader.ReadValue();
      if (openParenToken != null)
      {
         AdjustFlagsAndWidth(openParenToken);
         this.openParenToken = openParenToken;
      }
      var expression = (ExpressionSyntax)reader.ReadValue();
      if (expression != null)
      {
         AdjustFlagsAndWidth(expression);
         this.expression = expression;
      }
      var closeParenToken = (SyntaxToken)reader.ReadValue();
      if (closeParenToken != null)
      {
         AdjustFlagsAndWidth(closeParenToken);
         this.closeParenToken = closeParenToken;
      }
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.keyword);
      writer.WriteValue(this.openParenToken);
      writer.WriteValue(this.expression);
      writer.WriteValue(this.closeParenToken);
    }

    static MakeRefExpressionSyntax()
    {
       ObjectBinder.RegisterTypeReader(typeof(MakeRefExpressionSyntax), r => new MakeRefExpressionSyntax(r));
    }
  }

  /// <summary>Class which represents the syntax node for RefType expression.</summary>
  internal sealed partial class RefTypeExpressionSyntax : ExpressionSyntax
  {
    internal readonly SyntaxToken keyword;
    internal readonly SyntaxToken openParenToken;
    internal readonly ExpressionSyntax expression;
    internal readonly SyntaxToken closeParenToken;

    internal RefTypeExpressionSyntax(SyntaxKind kind, SyntaxToken keyword, SyntaxToken openParenToken, ExpressionSyntax expression, SyntaxToken closeParenToken, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 4;
        this.AdjustFlagsAndWidth(keyword);
        this.keyword = keyword;
        this.AdjustFlagsAndWidth(openParenToken);
        this.openParenToken = openParenToken;
        this.AdjustFlagsAndWidth(expression);
        this.expression = expression;
        this.AdjustFlagsAndWidth(closeParenToken);
        this.closeParenToken = closeParenToken;
    }


    internal RefTypeExpressionSyntax(SyntaxKind kind, SyntaxToken keyword, SyntaxToken openParenToken, ExpressionSyntax expression, SyntaxToken closeParenToken, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 4;
        this.AdjustFlagsAndWidth(keyword);
        this.keyword = keyword;
        this.AdjustFlagsAndWidth(openParenToken);
        this.openParenToken = openParenToken;
        this.AdjustFlagsAndWidth(expression);
        this.expression = expression;
        this.AdjustFlagsAndWidth(closeParenToken);
        this.closeParenToken = closeParenToken;
    }


    internal RefTypeExpressionSyntax(SyntaxKind kind, SyntaxToken keyword, SyntaxToken openParenToken, ExpressionSyntax expression, SyntaxToken closeParenToken)
        : base(kind)
    {
        this.SlotCount = 4;
        this.AdjustFlagsAndWidth(keyword);
        this.keyword = keyword;
        this.AdjustFlagsAndWidth(openParenToken);
        this.openParenToken = openParenToken;
        this.AdjustFlagsAndWidth(expression);
        this.expression = expression;
        this.AdjustFlagsAndWidth(closeParenToken);
        this.closeParenToken = closeParenToken;
    }

    /// <summary>SyntaxToken representing the RefTypeKeyword.</summary>
    public SyntaxToken Keyword { get { return this.keyword; } }
    /// <summary>SyntaxToken representing open parenthesis.</summary>
    public SyntaxToken OpenParenToken { get { return this.openParenToken; } }
    /// <summary>Argument of the primary function.</summary>
    public ExpressionSyntax Expression { get { return this.expression; } }
    /// <summary>SyntaxToken representing close parenthesis.</summary>
    public SyntaxToken CloseParenToken { get { return this.closeParenToken; } }

    internal override GreenNode GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.keyword;
            case 1: return this.openParenToken;
            case 2: return this.expression;
            case 3: return this.closeParenToken;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode parent, int position)
    {
      return new CSharp.Syntax.RefTypeExpressionSyntax(this, parent, position);
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitRefTypeExpression(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitRefTypeExpression(this);
    }

    public RefTypeExpressionSyntax Update(SyntaxToken keyword, SyntaxToken openParenToken, ExpressionSyntax expression, SyntaxToken closeParenToken)
    {
        if (keyword != this.Keyword || openParenToken != this.OpenParenToken || expression != this.Expression || closeParenToken != this.CloseParenToken)
        {
            var newNode = SyntaxFactory.RefTypeExpression(keyword, openParenToken, expression, closeParenToken);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
    {
         return new RefTypeExpressionSyntax(this.Kind, this.keyword, this.openParenToken, this.expression, this.closeParenToken, diagnostics, GetAnnotations());
    }

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
    {
         return new RefTypeExpressionSyntax(this.Kind, this.keyword, this.openParenToken, this.expression, this.closeParenToken, GetDiagnostics(), annotations);
    }

    internal RefTypeExpressionSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 4;
      var keyword = (SyntaxToken)reader.ReadValue();
      if (keyword != null)
      {
         AdjustFlagsAndWidth(keyword);
         this.keyword = keyword;
      }
      var openParenToken = (SyntaxToken)reader.ReadValue();
      if (openParenToken != null)
      {
         AdjustFlagsAndWidth(openParenToken);
         this.openParenToken = openParenToken;
      }
      var expression = (ExpressionSyntax)reader.ReadValue();
      if (expression != null)
      {
         AdjustFlagsAndWidth(expression);
         this.expression = expression;
      }
      var closeParenToken = (SyntaxToken)reader.ReadValue();
      if (closeParenToken != null)
      {
         AdjustFlagsAndWidth(closeParenToken);
         this.closeParenToken = closeParenToken;
      }
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.keyword);
      writer.WriteValue(this.openParenToken);
      writer.WriteValue(this.expression);
      writer.WriteValue(this.closeParenToken);
    }

    static RefTypeExpressionSyntax()
    {
       ObjectBinder.RegisterTypeReader(typeof(RefTypeExpressionSyntax), r => new RefTypeExpressionSyntax(r));
    }
  }

  /// <summary>Class which represents the syntax node for RefValue expression.</summary>
  internal sealed partial class RefValueExpressionSyntax : ExpressionSyntax
  {
    internal readonly SyntaxToken keyword;
    internal readonly SyntaxToken openParenToken;
    internal readonly ExpressionSyntax expression;
    internal readonly SyntaxToken comma;
    internal readonly TypeSyntax type;
    internal readonly SyntaxToken closeParenToken;

    internal RefValueExpressionSyntax(SyntaxKind kind, SyntaxToken keyword, SyntaxToken openParenToken, ExpressionSyntax expression, SyntaxToken comma, TypeSyntax type, SyntaxToken closeParenToken, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 6;
        this.AdjustFlagsAndWidth(keyword);
        this.keyword = keyword;
        this.AdjustFlagsAndWidth(openParenToken);
        this.openParenToken = openParenToken;
        this.AdjustFlagsAndWidth(expression);
        this.expression = expression;
        this.AdjustFlagsAndWidth(comma);
        this.comma = comma;
        this.AdjustFlagsAndWidth(type);
        this.type = type;
        this.AdjustFlagsAndWidth(closeParenToken);
        this.closeParenToken = closeParenToken;
    }


    internal RefValueExpressionSyntax(SyntaxKind kind, SyntaxToken keyword, SyntaxToken openParenToken, ExpressionSyntax expression, SyntaxToken comma, TypeSyntax type, SyntaxToken closeParenToken, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 6;
        this.AdjustFlagsAndWidth(keyword);
        this.keyword = keyword;
        this.AdjustFlagsAndWidth(openParenToken);
        this.openParenToken = openParenToken;
        this.AdjustFlagsAndWidth(expression);
        this.expression = expression;
        this.AdjustFlagsAndWidth(comma);
        this.comma = comma;
        this.AdjustFlagsAndWidth(type);
        this.type = type;
        this.AdjustFlagsAndWidth(closeParenToken);
        this.closeParenToken = closeParenToken;
    }


    internal RefValueExpressionSyntax(SyntaxKind kind, SyntaxToken keyword, SyntaxToken openParenToken, ExpressionSyntax expression, SyntaxToken comma, TypeSyntax type, SyntaxToken closeParenToken)
        : base(kind)
    {
        this.SlotCount = 6;
        this.AdjustFlagsAndWidth(keyword);
        this.keyword = keyword;
        this.AdjustFlagsAndWidth(openParenToken);
        this.openParenToken = openParenToken;
        this.AdjustFlagsAndWidth(expression);
        this.expression = expression;
        this.AdjustFlagsAndWidth(comma);
        this.comma = comma;
        this.AdjustFlagsAndWidth(type);
        this.type = type;
        this.AdjustFlagsAndWidth(closeParenToken);
        this.closeParenToken = closeParenToken;
    }

    /// <summary>SyntaxToken representing the RefValueKeyword.</summary>
    public SyntaxToken Keyword { get { return this.keyword; } }
    /// <summary>SyntaxToken representing open parenthesis.</summary>
    public SyntaxToken OpenParenToken { get { return this.openParenToken; } }
    /// <summary>Typed reference expression.</summary>
    public ExpressionSyntax Expression { get { return this.expression; } }
    /// <summary>Comma separating the arguments.</summary>
    public SyntaxToken Comma { get { return this.comma; } }
    /// <summary>The type of the value.</summary>
    public TypeSyntax Type { get { return this.type; } }
    /// <summary>SyntaxToken representing close parenthesis.</summary>
    public SyntaxToken CloseParenToken { get { return this.closeParenToken; } }

    internal override GreenNode GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.keyword;
            case 1: return this.openParenToken;
            case 2: return this.expression;
            case 3: return this.comma;
            case 4: return this.type;
            case 5: return this.closeParenToken;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode parent, int position)
    {
      return new CSharp.Syntax.RefValueExpressionSyntax(this, parent, position);
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitRefValueExpression(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitRefValueExpression(this);
    }

    public RefValueExpressionSyntax Update(SyntaxToken keyword, SyntaxToken openParenToken, ExpressionSyntax expression, SyntaxToken comma, TypeSyntax type, SyntaxToken closeParenToken)
    {
        if (keyword != this.Keyword || openParenToken != this.OpenParenToken || expression != this.Expression || comma != this.Comma || type != this.Type || closeParenToken != this.CloseParenToken)
        {
            var newNode = SyntaxFactory.RefValueExpression(keyword, openParenToken, expression, comma, type, closeParenToken);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
    {
         return new RefValueExpressionSyntax(this.Kind, this.keyword, this.openParenToken, this.expression, this.comma, this.type, this.closeParenToken, diagnostics, GetAnnotations());
    }

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
    {
         return new RefValueExpressionSyntax(this.Kind, this.keyword, this.openParenToken, this.expression, this.comma, this.type, this.closeParenToken, GetDiagnostics(), annotations);
    }

    internal RefValueExpressionSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 6;
      var keyword = (SyntaxToken)reader.ReadValue();
      if (keyword != null)
      {
         AdjustFlagsAndWidth(keyword);
         this.keyword = keyword;
      }
      var openParenToken = (SyntaxToken)reader.ReadValue();
      if (openParenToken != null)
      {
         AdjustFlagsAndWidth(openParenToken);
         this.openParenToken = openParenToken;
      }
      var expression = (ExpressionSyntax)reader.ReadValue();
      if (expression != null)
      {
         AdjustFlagsAndWidth(expression);
         this.expression = expression;
      }
      var comma = (SyntaxToken)reader.ReadValue();
      if (comma != null)
      {
         AdjustFlagsAndWidth(comma);
         this.comma = comma;
      }
      var type = (TypeSyntax)reader.ReadValue();
      if (type != null)
      {
         AdjustFlagsAndWidth(type);
         this.type = type;
      }
      var closeParenToken = (SyntaxToken)reader.ReadValue();
      if (closeParenToken != null)
      {
         AdjustFlagsAndWidth(closeParenToken);
         this.closeParenToken = closeParenToken;
      }
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.keyword);
      writer.WriteValue(this.openParenToken);
      writer.WriteValue(this.expression);
      writer.WriteValue(this.comma);
      writer.WriteValue(this.type);
      writer.WriteValue(this.closeParenToken);
    }

    static RefValueExpressionSyntax()
    {
       ObjectBinder.RegisterTypeReader(typeof(RefValueExpressionSyntax), r => new RefValueExpressionSyntax(r));
    }
  }

  /// <summary>Class which represents the syntax node for Checked or Unchecked expression.</summary>
  internal sealed partial class CheckedExpressionSyntax : ExpressionSyntax
  {
    internal readonly SyntaxToken keyword;
    internal readonly SyntaxToken openParenToken;
    internal readonly ExpressionSyntax expression;
    internal readonly SyntaxToken closeParenToken;

    internal CheckedExpressionSyntax(SyntaxKind kind, SyntaxToken keyword, SyntaxToken openParenToken, ExpressionSyntax expression, SyntaxToken closeParenToken, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 4;
        this.AdjustFlagsAndWidth(keyword);
        this.keyword = keyword;
        this.AdjustFlagsAndWidth(openParenToken);
        this.openParenToken = openParenToken;
        this.AdjustFlagsAndWidth(expression);
        this.expression = expression;
        this.AdjustFlagsAndWidth(closeParenToken);
        this.closeParenToken = closeParenToken;
    }


    internal CheckedExpressionSyntax(SyntaxKind kind, SyntaxToken keyword, SyntaxToken openParenToken, ExpressionSyntax expression, SyntaxToken closeParenToken, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 4;
        this.AdjustFlagsAndWidth(keyword);
        this.keyword = keyword;
        this.AdjustFlagsAndWidth(openParenToken);
        this.openParenToken = openParenToken;
        this.AdjustFlagsAndWidth(expression);
        this.expression = expression;
        this.AdjustFlagsAndWidth(closeParenToken);
        this.closeParenToken = closeParenToken;
    }


    internal CheckedExpressionSyntax(SyntaxKind kind, SyntaxToken keyword, SyntaxToken openParenToken, ExpressionSyntax expression, SyntaxToken closeParenToken)
        : base(kind)
    {
        this.SlotCount = 4;
        this.AdjustFlagsAndWidth(keyword);
        this.keyword = keyword;
        this.AdjustFlagsAndWidth(openParenToken);
        this.openParenToken = openParenToken;
        this.AdjustFlagsAndWidth(expression);
        this.expression = expression;
        this.AdjustFlagsAndWidth(closeParenToken);
        this.closeParenToken = closeParenToken;
    }

    /// <summary>SyntaxToken representing the checked or unchecked keyword.</summary>
    public SyntaxToken Keyword { get { return this.keyword; } }
    /// <summary>SyntaxToken representing open parenthesis.</summary>
    public SyntaxToken OpenParenToken { get { return this.openParenToken; } }
    /// <summary>Argument of the primary function.</summary>
    public ExpressionSyntax Expression { get { return this.expression; } }
    /// <summary>SyntaxToken representing close parenthesis.</summary>
    public SyntaxToken CloseParenToken { get { return this.closeParenToken; } }

    internal override GreenNode GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.keyword;
            case 1: return this.openParenToken;
            case 2: return this.expression;
            case 3: return this.closeParenToken;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode parent, int position)
    {
      return new CSharp.Syntax.CheckedExpressionSyntax(this, parent, position);
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitCheckedExpression(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitCheckedExpression(this);
    }

    public CheckedExpressionSyntax Update(SyntaxToken keyword, SyntaxToken openParenToken, ExpressionSyntax expression, SyntaxToken closeParenToken)
    {
        if (keyword != this.Keyword || openParenToken != this.OpenParenToken || expression != this.Expression || closeParenToken != this.CloseParenToken)
        {
            var newNode = SyntaxFactory.CheckedExpression(this.Kind, keyword, openParenToken, expression, closeParenToken);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
    {
         return new CheckedExpressionSyntax(this.Kind, this.keyword, this.openParenToken, this.expression, this.closeParenToken, diagnostics, GetAnnotations());
    }

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
    {
         return new CheckedExpressionSyntax(this.Kind, this.keyword, this.openParenToken, this.expression, this.closeParenToken, GetDiagnostics(), annotations);
    }

    internal CheckedExpressionSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 4;
      var keyword = (SyntaxToken)reader.ReadValue();
      if (keyword != null)
      {
         AdjustFlagsAndWidth(keyword);
         this.keyword = keyword;
      }
      var openParenToken = (SyntaxToken)reader.ReadValue();
      if (openParenToken != null)
      {
         AdjustFlagsAndWidth(openParenToken);
         this.openParenToken = openParenToken;
      }
      var expression = (ExpressionSyntax)reader.ReadValue();
      if (expression != null)
      {
         AdjustFlagsAndWidth(expression);
         this.expression = expression;
      }
      var closeParenToken = (SyntaxToken)reader.ReadValue();
      if (closeParenToken != null)
      {
         AdjustFlagsAndWidth(closeParenToken);
         this.closeParenToken = closeParenToken;
      }
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.keyword);
      writer.WriteValue(this.openParenToken);
      writer.WriteValue(this.expression);
      writer.WriteValue(this.closeParenToken);
    }

    static CheckedExpressionSyntax()
    {
       ObjectBinder.RegisterTypeReader(typeof(CheckedExpressionSyntax), r => new CheckedExpressionSyntax(r));
    }
  }

  /// <summary>Class which represents the syntax node for Default expression.</summary>
  internal sealed partial class DefaultExpressionSyntax : ExpressionSyntax
  {
    internal readonly SyntaxToken keyword;
    internal readonly SyntaxToken openParenToken;
    internal readonly TypeSyntax type;
    internal readonly SyntaxToken closeParenToken;

    internal DefaultExpressionSyntax(SyntaxKind kind, SyntaxToken keyword, SyntaxToken openParenToken, TypeSyntax type, SyntaxToken closeParenToken, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 4;
        this.AdjustFlagsAndWidth(keyword);
        this.keyword = keyword;
        this.AdjustFlagsAndWidth(openParenToken);
        this.openParenToken = openParenToken;
        this.AdjustFlagsAndWidth(type);
        this.type = type;
        this.AdjustFlagsAndWidth(closeParenToken);
        this.closeParenToken = closeParenToken;
    }


    internal DefaultExpressionSyntax(SyntaxKind kind, SyntaxToken keyword, SyntaxToken openParenToken, TypeSyntax type, SyntaxToken closeParenToken, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 4;
        this.AdjustFlagsAndWidth(keyword);
        this.keyword = keyword;
        this.AdjustFlagsAndWidth(openParenToken);
        this.openParenToken = openParenToken;
        this.AdjustFlagsAndWidth(type);
        this.type = type;
        this.AdjustFlagsAndWidth(closeParenToken);
        this.closeParenToken = closeParenToken;
    }


    internal DefaultExpressionSyntax(SyntaxKind kind, SyntaxToken keyword, SyntaxToken openParenToken, TypeSyntax type, SyntaxToken closeParenToken)
        : base(kind)
    {
        this.SlotCount = 4;
        this.AdjustFlagsAndWidth(keyword);
        this.keyword = keyword;
        this.AdjustFlagsAndWidth(openParenToken);
        this.openParenToken = openParenToken;
        this.AdjustFlagsAndWidth(type);
        this.type = type;
        this.AdjustFlagsAndWidth(closeParenToken);
        this.closeParenToken = closeParenToken;
    }

    /// <summary>SyntaxToken representing the DefaultKeyword.</summary>
    public SyntaxToken Keyword { get { return this.keyword; } }
    /// <summary>SyntaxToken representing open parenthesis.</summary>
    public SyntaxToken OpenParenToken { get { return this.openParenToken; } }
    /// <summary>Argument of the primary function.</summary>
    public TypeSyntax Type { get { return this.type; } }
    /// <summary>SyntaxToken representing close parenthesis.</summary>
    public SyntaxToken CloseParenToken { get { return this.closeParenToken; } }

    internal override GreenNode GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.keyword;
            case 1: return this.openParenToken;
            case 2: return this.type;
            case 3: return this.closeParenToken;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode parent, int position)
    {
      return new CSharp.Syntax.DefaultExpressionSyntax(this, parent, position);
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitDefaultExpression(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitDefaultExpression(this);
    }

    public DefaultExpressionSyntax Update(SyntaxToken keyword, SyntaxToken openParenToken, TypeSyntax type, SyntaxToken closeParenToken)
    {
        if (keyword != this.Keyword || openParenToken != this.OpenParenToken || type != this.Type || closeParenToken != this.CloseParenToken)
        {
            var newNode = SyntaxFactory.DefaultExpression(keyword, openParenToken, type, closeParenToken);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
    {
         return new DefaultExpressionSyntax(this.Kind, this.keyword, this.openParenToken, this.type, this.closeParenToken, diagnostics, GetAnnotations());
    }

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
    {
         return new DefaultExpressionSyntax(this.Kind, this.keyword, this.openParenToken, this.type, this.closeParenToken, GetDiagnostics(), annotations);
    }

    internal DefaultExpressionSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 4;
      var keyword = (SyntaxToken)reader.ReadValue();
      if (keyword != null)
      {
         AdjustFlagsAndWidth(keyword);
         this.keyword = keyword;
      }
      var openParenToken = (SyntaxToken)reader.ReadValue();
      if (openParenToken != null)
      {
         AdjustFlagsAndWidth(openParenToken);
         this.openParenToken = openParenToken;
      }
      var type = (TypeSyntax)reader.ReadValue();
      if (type != null)
      {
         AdjustFlagsAndWidth(type);
         this.type = type;
      }
      var closeParenToken = (SyntaxToken)reader.ReadValue();
      if (closeParenToken != null)
      {
         AdjustFlagsAndWidth(closeParenToken);
         this.closeParenToken = closeParenToken;
      }
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.keyword);
      writer.WriteValue(this.openParenToken);
      writer.WriteValue(this.type);
      writer.WriteValue(this.closeParenToken);
    }

    static DefaultExpressionSyntax()
    {
       ObjectBinder.RegisterTypeReader(typeof(DefaultExpressionSyntax), r => new DefaultExpressionSyntax(r));
    }
  }

  /// <summary>Class which represents the syntax node for TypeOf expression.</summary>
  internal sealed partial class TypeOfExpressionSyntax : ExpressionSyntax
  {
    internal readonly SyntaxToken keyword;
    internal readonly SyntaxToken openParenToken;
    internal readonly TypeSyntax type;
    internal readonly SyntaxToken closeParenToken;

    internal TypeOfExpressionSyntax(SyntaxKind kind, SyntaxToken keyword, SyntaxToken openParenToken, TypeSyntax type, SyntaxToken closeParenToken, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 4;
        this.AdjustFlagsAndWidth(keyword);
        this.keyword = keyword;
        this.AdjustFlagsAndWidth(openParenToken);
        this.openParenToken = openParenToken;
        this.AdjustFlagsAndWidth(type);
        this.type = type;
        this.AdjustFlagsAndWidth(closeParenToken);
        this.closeParenToken = closeParenToken;
    }


    internal TypeOfExpressionSyntax(SyntaxKind kind, SyntaxToken keyword, SyntaxToken openParenToken, TypeSyntax type, SyntaxToken closeParenToken, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 4;
        this.AdjustFlagsAndWidth(keyword);
        this.keyword = keyword;
        this.AdjustFlagsAndWidth(openParenToken);
        this.openParenToken = openParenToken;
        this.AdjustFlagsAndWidth(type);
        this.type = type;
        this.AdjustFlagsAndWidth(closeParenToken);
        this.closeParenToken = closeParenToken;
    }


    internal TypeOfExpressionSyntax(SyntaxKind kind, SyntaxToken keyword, SyntaxToken openParenToken, TypeSyntax type, SyntaxToken closeParenToken)
        : base(kind)
    {
        this.SlotCount = 4;
        this.AdjustFlagsAndWidth(keyword);
        this.keyword = keyword;
        this.AdjustFlagsAndWidth(openParenToken);
        this.openParenToken = openParenToken;
        this.AdjustFlagsAndWidth(type);
        this.type = type;
        this.AdjustFlagsAndWidth(closeParenToken);
        this.closeParenToken = closeParenToken;
    }

    /// <summary>SyntaxToken representing the TypeOfKeyword.</summary>
    public SyntaxToken Keyword { get { return this.keyword; } }
    /// <summary>SyntaxToken representing open parenthesis.</summary>
    public SyntaxToken OpenParenToken { get { return this.openParenToken; } }
    /// <summary>The expression to return type of.</summary>
    public TypeSyntax Type { get { return this.type; } }
    /// <summary>SyntaxToken representing close parenthesis.</summary>
    public SyntaxToken CloseParenToken { get { return this.closeParenToken; } }

    internal override GreenNode GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.keyword;
            case 1: return this.openParenToken;
            case 2: return this.type;
            case 3: return this.closeParenToken;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode parent, int position)
    {
      return new CSharp.Syntax.TypeOfExpressionSyntax(this, parent, position);
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitTypeOfExpression(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitTypeOfExpression(this);
    }

    public TypeOfExpressionSyntax Update(SyntaxToken keyword, SyntaxToken openParenToken, TypeSyntax type, SyntaxToken closeParenToken)
    {
        if (keyword != this.Keyword || openParenToken != this.OpenParenToken || type != this.Type || closeParenToken != this.CloseParenToken)
        {
            var newNode = SyntaxFactory.TypeOfExpression(keyword, openParenToken, type, closeParenToken);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
    {
         return new TypeOfExpressionSyntax(this.Kind, this.keyword, this.openParenToken, this.type, this.closeParenToken, diagnostics, GetAnnotations());
    }

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
    {
         return new TypeOfExpressionSyntax(this.Kind, this.keyword, this.openParenToken, this.type, this.closeParenToken, GetDiagnostics(), annotations);
    }

    internal TypeOfExpressionSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 4;
      var keyword = (SyntaxToken)reader.ReadValue();
      if (keyword != null)
      {
         AdjustFlagsAndWidth(keyword);
         this.keyword = keyword;
      }
      var openParenToken = (SyntaxToken)reader.ReadValue();
      if (openParenToken != null)
      {
         AdjustFlagsAndWidth(openParenToken);
         this.openParenToken = openParenToken;
      }
      var type = (TypeSyntax)reader.ReadValue();
      if (type != null)
      {
         AdjustFlagsAndWidth(type);
         this.type = type;
      }
      var closeParenToken = (SyntaxToken)reader.ReadValue();
      if (closeParenToken != null)
      {
         AdjustFlagsAndWidth(closeParenToken);
         this.closeParenToken = closeParenToken;
      }
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.keyword);
      writer.WriteValue(this.openParenToken);
      writer.WriteValue(this.type);
      writer.WriteValue(this.closeParenToken);
    }

    static TypeOfExpressionSyntax()
    {
       ObjectBinder.RegisterTypeReader(typeof(TypeOfExpressionSyntax), r => new TypeOfExpressionSyntax(r));
    }
  }

  /// <summary>Class which represents the syntax node for SizeOf expression.</summary>
  internal sealed partial class SizeOfExpressionSyntax : ExpressionSyntax
  {
    internal readonly SyntaxToken keyword;
    internal readonly SyntaxToken openParenToken;
    internal readonly TypeSyntax type;
    internal readonly SyntaxToken closeParenToken;

    internal SizeOfExpressionSyntax(SyntaxKind kind, SyntaxToken keyword, SyntaxToken openParenToken, TypeSyntax type, SyntaxToken closeParenToken, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 4;
        this.AdjustFlagsAndWidth(keyword);
        this.keyword = keyword;
        this.AdjustFlagsAndWidth(openParenToken);
        this.openParenToken = openParenToken;
        this.AdjustFlagsAndWidth(type);
        this.type = type;
        this.AdjustFlagsAndWidth(closeParenToken);
        this.closeParenToken = closeParenToken;
    }


    internal SizeOfExpressionSyntax(SyntaxKind kind, SyntaxToken keyword, SyntaxToken openParenToken, TypeSyntax type, SyntaxToken closeParenToken, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 4;
        this.AdjustFlagsAndWidth(keyword);
        this.keyword = keyword;
        this.AdjustFlagsAndWidth(openParenToken);
        this.openParenToken = openParenToken;
        this.AdjustFlagsAndWidth(type);
        this.type = type;
        this.AdjustFlagsAndWidth(closeParenToken);
        this.closeParenToken = closeParenToken;
    }


    internal SizeOfExpressionSyntax(SyntaxKind kind, SyntaxToken keyword, SyntaxToken openParenToken, TypeSyntax type, SyntaxToken closeParenToken)
        : base(kind)
    {
        this.SlotCount = 4;
        this.AdjustFlagsAndWidth(keyword);
        this.keyword = keyword;
        this.AdjustFlagsAndWidth(openParenToken);
        this.openParenToken = openParenToken;
        this.AdjustFlagsAndWidth(type);
        this.type = type;
        this.AdjustFlagsAndWidth(closeParenToken);
        this.closeParenToken = closeParenToken;
    }

    /// <summary>SyntaxToken representing the SizeOfKeyword.</summary>
    public SyntaxToken Keyword { get { return this.keyword; } }
    /// <summary>SyntaxToken representing open parenthesis.</summary>
    public SyntaxToken OpenParenToken { get { return this.openParenToken; } }
    /// <summary>Argument of the primary function.</summary>
    public TypeSyntax Type { get { return this.type; } }
    /// <summary>SyntaxToken representing close parenthesis.</summary>
    public SyntaxToken CloseParenToken { get { return this.closeParenToken; } }

    internal override GreenNode GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.keyword;
            case 1: return this.openParenToken;
            case 2: return this.type;
            case 3: return this.closeParenToken;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode parent, int position)
    {
      return new CSharp.Syntax.SizeOfExpressionSyntax(this, parent, position);
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitSizeOfExpression(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitSizeOfExpression(this);
    }

    public SizeOfExpressionSyntax Update(SyntaxToken keyword, SyntaxToken openParenToken, TypeSyntax type, SyntaxToken closeParenToken)
    {
        if (keyword != this.Keyword || openParenToken != this.OpenParenToken || type != this.Type || closeParenToken != this.CloseParenToken)
        {
            var newNode = SyntaxFactory.SizeOfExpression(keyword, openParenToken, type, closeParenToken);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
    {
         return new SizeOfExpressionSyntax(this.Kind, this.keyword, this.openParenToken, this.type, this.closeParenToken, diagnostics, GetAnnotations());
    }

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
    {
         return new SizeOfExpressionSyntax(this.Kind, this.keyword, this.openParenToken, this.type, this.closeParenToken, GetDiagnostics(), annotations);
    }

    internal SizeOfExpressionSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 4;
      var keyword = (SyntaxToken)reader.ReadValue();
      if (keyword != null)
      {
         AdjustFlagsAndWidth(keyword);
         this.keyword = keyword;
      }
      var openParenToken = (SyntaxToken)reader.ReadValue();
      if (openParenToken != null)
      {
         AdjustFlagsAndWidth(openParenToken);
         this.openParenToken = openParenToken;
      }
      var type = (TypeSyntax)reader.ReadValue();
      if (type != null)
      {
         AdjustFlagsAndWidth(type);
         this.type = type;
      }
      var closeParenToken = (SyntaxToken)reader.ReadValue();
      if (closeParenToken != null)
      {
         AdjustFlagsAndWidth(closeParenToken);
         this.closeParenToken = closeParenToken;
      }
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.keyword);
      writer.WriteValue(this.openParenToken);
      writer.WriteValue(this.type);
      writer.WriteValue(this.closeParenToken);
    }

    static SizeOfExpressionSyntax()
    {
       ObjectBinder.RegisterTypeReader(typeof(SizeOfExpressionSyntax), r => new SizeOfExpressionSyntax(r));
    }
  }

  /// <summary>Class which represents the syntax node for invocation expression.</summary>
  internal sealed partial class InvocationExpressionSyntax : ExpressionSyntax
  {
    internal readonly ExpressionSyntax expression;
    internal readonly ArgumentListSyntax argumentList;

    internal InvocationExpressionSyntax(SyntaxKind kind, ExpressionSyntax expression, ArgumentListSyntax argumentList, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 2;
        this.AdjustFlagsAndWidth(expression);
        this.expression = expression;
        this.AdjustFlagsAndWidth(argumentList);
        this.argumentList = argumentList;
    }


    internal InvocationExpressionSyntax(SyntaxKind kind, ExpressionSyntax expression, ArgumentListSyntax argumentList, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 2;
        this.AdjustFlagsAndWidth(expression);
        this.expression = expression;
        this.AdjustFlagsAndWidth(argumentList);
        this.argumentList = argumentList;
    }


    internal InvocationExpressionSyntax(SyntaxKind kind, ExpressionSyntax expression, ArgumentListSyntax argumentList)
        : base(kind)
    {
        this.SlotCount = 2;
        this.AdjustFlagsAndWidth(expression);
        this.expression = expression;
        this.AdjustFlagsAndWidth(argumentList);
        this.argumentList = argumentList;
    }

    /// <summary>ExpressionSyntax node representing the expression part of the invocation.</summary>
    public ExpressionSyntax Expression { get { return this.expression; } }
    /// <summary>ArgumentListSyntax node representing the list of arguments of the invocation expression.</summary>
    public ArgumentListSyntax ArgumentList { get { return this.argumentList; } }

    internal override GreenNode GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.expression;
            case 1: return this.argumentList;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode parent, int position)
    {
      return new CSharp.Syntax.InvocationExpressionSyntax(this, parent, position);
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitInvocationExpression(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitInvocationExpression(this);
    }

    public InvocationExpressionSyntax Update(ExpressionSyntax expression, ArgumentListSyntax argumentList)
    {
        if (expression != this.Expression || argumentList != this.ArgumentList)
        {
            var newNode = SyntaxFactory.InvocationExpression(expression, argumentList);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
    {
         return new InvocationExpressionSyntax(this.Kind, this.expression, this.argumentList, diagnostics, GetAnnotations());
    }

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
    {
         return new InvocationExpressionSyntax(this.Kind, this.expression, this.argumentList, GetDiagnostics(), annotations);
    }

    internal InvocationExpressionSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 2;
      var expression = (ExpressionSyntax)reader.ReadValue();
      if (expression != null)
      {
         AdjustFlagsAndWidth(expression);
         this.expression = expression;
      }
      var argumentList = (ArgumentListSyntax)reader.ReadValue();
      if (argumentList != null)
      {
         AdjustFlagsAndWidth(argumentList);
         this.argumentList = argumentList;
      }
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.expression);
      writer.WriteValue(this.argumentList);
    }

    static InvocationExpressionSyntax()
    {
       ObjectBinder.RegisterTypeReader(typeof(InvocationExpressionSyntax), r => new InvocationExpressionSyntax(r));
    }
  }

  /// <summary>Class which represents the syntax node for element access expression.</summary>
  internal sealed partial class ElementAccessExpressionSyntax : ExpressionSyntax
  {
    internal readonly ExpressionSyntax expression;
    internal readonly BracketedArgumentListSyntax argumentList;

    internal ElementAccessExpressionSyntax(SyntaxKind kind, ExpressionSyntax expression, BracketedArgumentListSyntax argumentList, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 2;
        this.AdjustFlagsAndWidth(expression);
        this.expression = expression;
        this.AdjustFlagsAndWidth(argumentList);
        this.argumentList = argumentList;
    }


    internal ElementAccessExpressionSyntax(SyntaxKind kind, ExpressionSyntax expression, BracketedArgumentListSyntax argumentList, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 2;
        this.AdjustFlagsAndWidth(expression);
        this.expression = expression;
        this.AdjustFlagsAndWidth(argumentList);
        this.argumentList = argumentList;
    }


    internal ElementAccessExpressionSyntax(SyntaxKind kind, ExpressionSyntax expression, BracketedArgumentListSyntax argumentList)
        : base(kind)
    {
        this.SlotCount = 2;
        this.AdjustFlagsAndWidth(expression);
        this.expression = expression;
        this.AdjustFlagsAndWidth(argumentList);
        this.argumentList = argumentList;
    }

    /// <summary>ExpressionSyntax node representing the expression which is accessing the element.</summary>
    public ExpressionSyntax Expression { get { return this.expression; } }
    /// <summary>BracketedArgumentListSyntax node representing the list of arguments of the element access expression.</summary>
    public BracketedArgumentListSyntax ArgumentList { get { return this.argumentList; } }

    internal override GreenNode GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.expression;
            case 1: return this.argumentList;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode parent, int position)
    {
      return new CSharp.Syntax.ElementAccessExpressionSyntax(this, parent, position);
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitElementAccessExpression(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitElementAccessExpression(this);
    }

    public ElementAccessExpressionSyntax Update(ExpressionSyntax expression, BracketedArgumentListSyntax argumentList)
    {
        if (expression != this.Expression || argumentList != this.ArgumentList)
        {
            var newNode = SyntaxFactory.ElementAccessExpression(expression, argumentList);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
    {
         return new ElementAccessExpressionSyntax(this.Kind, this.expression, this.argumentList, diagnostics, GetAnnotations());
    }

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
    {
         return new ElementAccessExpressionSyntax(this.Kind, this.expression, this.argumentList, GetDiagnostics(), annotations);
    }

    internal ElementAccessExpressionSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 2;
      var expression = (ExpressionSyntax)reader.ReadValue();
      if (expression != null)
      {
         AdjustFlagsAndWidth(expression);
         this.expression = expression;
      }
      var argumentList = (BracketedArgumentListSyntax)reader.ReadValue();
      if (argumentList != null)
      {
         AdjustFlagsAndWidth(argumentList);
         this.argumentList = argumentList;
      }
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.expression);
      writer.WriteValue(this.argumentList);
    }

    static ElementAccessExpressionSyntax()
    {
       ObjectBinder.RegisterTypeReader(typeof(ElementAccessExpressionSyntax), r => new ElementAccessExpressionSyntax(r));
    }
  }

  /// <summary>Provides the base class from which the classes that represent argument list syntax nodes are derived. This is an abstract class.</summary>
  internal abstract partial class BaseArgumentListSyntax : CSharpSyntaxNode
  {
    internal BaseArgumentListSyntax(SyntaxKind kind, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
      : base(kind, diagnostics, annotations)
    {
    }
    internal BaseArgumentListSyntax(SyntaxKind kind)
      : base(kind)
    {
    }

    protected BaseArgumentListSyntax(ObjectReader reader)
       : base(reader)
    {
    }

    /// <summary>SeparatedSyntaxList of ArgumentSyntax nodes representing the list of arguments.</summary>
    public abstract Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<ArgumentSyntax> Arguments { get; }
  }

  /// <summary>Class which represents the syntax node for the list of arguments.</summary>
  internal sealed partial class ArgumentListSyntax : BaseArgumentListSyntax
  {
    internal readonly SyntaxToken openParenToken;
    internal readonly GreenNode arguments;
    internal readonly SyntaxToken closeParenToken;

    internal ArgumentListSyntax(SyntaxKind kind, SyntaxToken openParenToken, GreenNode arguments, SyntaxToken closeParenToken, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 3;
        this.AdjustFlagsAndWidth(openParenToken);
        this.openParenToken = openParenToken;
        if (arguments != null)
        {
            this.AdjustFlagsAndWidth(arguments);
            this.arguments = arguments;
        }
        this.AdjustFlagsAndWidth(closeParenToken);
        this.closeParenToken = closeParenToken;
    }


    internal ArgumentListSyntax(SyntaxKind kind, SyntaxToken openParenToken, GreenNode arguments, SyntaxToken closeParenToken, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 3;
        this.AdjustFlagsAndWidth(openParenToken);
        this.openParenToken = openParenToken;
        if (arguments != null)
        {
            this.AdjustFlagsAndWidth(arguments);
            this.arguments = arguments;
        }
        this.AdjustFlagsAndWidth(closeParenToken);
        this.closeParenToken = closeParenToken;
    }


    internal ArgumentListSyntax(SyntaxKind kind, SyntaxToken openParenToken, GreenNode arguments, SyntaxToken closeParenToken)
        : base(kind)
    {
        this.SlotCount = 3;
        this.AdjustFlagsAndWidth(openParenToken);
        this.openParenToken = openParenToken;
        if (arguments != null)
        {
            this.AdjustFlagsAndWidth(arguments);
            this.arguments = arguments;
        }
        this.AdjustFlagsAndWidth(closeParenToken);
        this.closeParenToken = closeParenToken;
    }

    /// <summary>SyntaxToken representing open parenthesis.</summary>
    public SyntaxToken OpenParenToken { get { return this.openParenToken; } }
    /// <summary>SeparatedSyntaxList of ArgumentSyntax representing the list of arguments.</summary>
    public override Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<ArgumentSyntax> Arguments { get { return new Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<ArgumentSyntax>(new Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<CSharpSyntaxNode>(this.arguments)); } }
    /// <summary>SyntaxToken representing close parenthesis.</summary>
    public SyntaxToken CloseParenToken { get { return this.closeParenToken; } }

    internal override GreenNode GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.openParenToken;
            case 1: return this.arguments;
            case 2: return this.closeParenToken;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode parent, int position)
    {
      return new CSharp.Syntax.ArgumentListSyntax(this, parent, position);
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitArgumentList(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitArgumentList(this);
    }

    public ArgumentListSyntax Update(SyntaxToken openParenToken, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<ArgumentSyntax> arguments, SyntaxToken closeParenToken)
    {
        if (openParenToken != this.OpenParenToken || arguments != this.Arguments || closeParenToken != this.CloseParenToken)
        {
            var newNode = SyntaxFactory.ArgumentList(openParenToken, arguments, closeParenToken);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
    {
         return new ArgumentListSyntax(this.Kind, this.openParenToken, this.arguments, this.closeParenToken, diagnostics, GetAnnotations());
    }

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
    {
         return new ArgumentListSyntax(this.Kind, this.openParenToken, this.arguments, this.closeParenToken, GetDiagnostics(), annotations);
    }

    internal ArgumentListSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 3;
      var openParenToken = (SyntaxToken)reader.ReadValue();
      if (openParenToken != null)
      {
         AdjustFlagsAndWidth(openParenToken);
         this.openParenToken = openParenToken;
      }
      var arguments = (GreenNode)reader.ReadValue();
      if (arguments != null)
      {
         AdjustFlagsAndWidth(arguments);
         this.arguments = arguments;
      }
      var closeParenToken = (SyntaxToken)reader.ReadValue();
      if (closeParenToken != null)
      {
         AdjustFlagsAndWidth(closeParenToken);
         this.closeParenToken = closeParenToken;
      }
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.openParenToken);
      writer.WriteValue(this.arguments);
      writer.WriteValue(this.closeParenToken);
    }

    static ArgumentListSyntax()
    {
       ObjectBinder.RegisterTypeReader(typeof(ArgumentListSyntax), r => new ArgumentListSyntax(r));
    }
  }

  /// <summary>Class which represents the syntax node for bracketed argument list.</summary>
  internal sealed partial class BracketedArgumentListSyntax : BaseArgumentListSyntax
  {
    internal readonly SyntaxToken openBracketToken;
    internal readonly GreenNode arguments;
    internal readonly SyntaxToken closeBracketToken;

    internal BracketedArgumentListSyntax(SyntaxKind kind, SyntaxToken openBracketToken, GreenNode arguments, SyntaxToken closeBracketToken, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 3;
        this.AdjustFlagsAndWidth(openBracketToken);
        this.openBracketToken = openBracketToken;
        if (arguments != null)
        {
            this.AdjustFlagsAndWidth(arguments);
            this.arguments = arguments;
        }
        this.AdjustFlagsAndWidth(closeBracketToken);
        this.closeBracketToken = closeBracketToken;
    }


    internal BracketedArgumentListSyntax(SyntaxKind kind, SyntaxToken openBracketToken, GreenNode arguments, SyntaxToken closeBracketToken, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 3;
        this.AdjustFlagsAndWidth(openBracketToken);
        this.openBracketToken = openBracketToken;
        if (arguments != null)
        {
            this.AdjustFlagsAndWidth(arguments);
            this.arguments = arguments;
        }
        this.AdjustFlagsAndWidth(closeBracketToken);
        this.closeBracketToken = closeBracketToken;
    }


    internal BracketedArgumentListSyntax(SyntaxKind kind, SyntaxToken openBracketToken, GreenNode arguments, SyntaxToken closeBracketToken)
        : base(kind)
    {
        this.SlotCount = 3;
        this.AdjustFlagsAndWidth(openBracketToken);
        this.openBracketToken = openBracketToken;
        if (arguments != null)
        {
            this.AdjustFlagsAndWidth(arguments);
            this.arguments = arguments;
        }
        this.AdjustFlagsAndWidth(closeBracketToken);
        this.closeBracketToken = closeBracketToken;
    }

    /// <summary>SyntaxToken representing open bracket.</summary>
    public SyntaxToken OpenBracketToken { get { return this.openBracketToken; } }
    /// <summary>SeparatedSyntaxList of ArgumentSyntax representing the list of arguments.</summary>
    public override Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<ArgumentSyntax> Arguments { get { return new Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<ArgumentSyntax>(new Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<CSharpSyntaxNode>(this.arguments)); } }
    /// <summary>SyntaxToken representing close bracket.</summary>
    public SyntaxToken CloseBracketToken { get { return this.closeBracketToken; } }

    internal override GreenNode GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.openBracketToken;
            case 1: return this.arguments;
            case 2: return this.closeBracketToken;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode parent, int position)
    {
      return new CSharp.Syntax.BracketedArgumentListSyntax(this, parent, position);
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitBracketedArgumentList(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitBracketedArgumentList(this);
    }

    public BracketedArgumentListSyntax Update(SyntaxToken openBracketToken, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<ArgumentSyntax> arguments, SyntaxToken closeBracketToken)
    {
        if (openBracketToken != this.OpenBracketToken || arguments != this.Arguments || closeBracketToken != this.CloseBracketToken)
        {
            var newNode = SyntaxFactory.BracketedArgumentList(openBracketToken, arguments, closeBracketToken);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
    {
         return new BracketedArgumentListSyntax(this.Kind, this.openBracketToken, this.arguments, this.closeBracketToken, diagnostics, GetAnnotations());
    }

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
    {
         return new BracketedArgumentListSyntax(this.Kind, this.openBracketToken, this.arguments, this.closeBracketToken, GetDiagnostics(), annotations);
    }

    internal BracketedArgumentListSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 3;
      var openBracketToken = (SyntaxToken)reader.ReadValue();
      if (openBracketToken != null)
      {
         AdjustFlagsAndWidth(openBracketToken);
         this.openBracketToken = openBracketToken;
      }
      var arguments = (GreenNode)reader.ReadValue();
      if (arguments != null)
      {
         AdjustFlagsAndWidth(arguments);
         this.arguments = arguments;
      }
      var closeBracketToken = (SyntaxToken)reader.ReadValue();
      if (closeBracketToken != null)
      {
         AdjustFlagsAndWidth(closeBracketToken);
         this.closeBracketToken = closeBracketToken;
      }
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.openBracketToken);
      writer.WriteValue(this.arguments);
      writer.WriteValue(this.closeBracketToken);
    }

    static BracketedArgumentListSyntax()
    {
       ObjectBinder.RegisterTypeReader(typeof(BracketedArgumentListSyntax), r => new BracketedArgumentListSyntax(r));
    }
  }

  /// <summary>Class which represents the syntax node for argument.</summary>
  internal sealed partial class ArgumentSyntax : CSharpSyntaxNode
  {
    internal readonly NameColonSyntax nameColon;
    internal readonly SyntaxToken refOrOutKeyword;
    internal readonly ExpressionSyntax expression;

    internal ArgumentSyntax(SyntaxKind kind, NameColonSyntax nameColon, SyntaxToken refOrOutKeyword, ExpressionSyntax expression, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 3;
        if (nameColon != null)
        {
            this.AdjustFlagsAndWidth(nameColon);
            this.nameColon = nameColon;
        }
        if (refOrOutKeyword != null)
        {
            this.AdjustFlagsAndWidth(refOrOutKeyword);
            this.refOrOutKeyword = refOrOutKeyword;
        }
        this.AdjustFlagsAndWidth(expression);
        this.expression = expression;
    }


    internal ArgumentSyntax(SyntaxKind kind, NameColonSyntax nameColon, SyntaxToken refOrOutKeyword, ExpressionSyntax expression, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 3;
        if (nameColon != null)
        {
            this.AdjustFlagsAndWidth(nameColon);
            this.nameColon = nameColon;
        }
        if (refOrOutKeyword != null)
        {
            this.AdjustFlagsAndWidth(refOrOutKeyword);
            this.refOrOutKeyword = refOrOutKeyword;
        }
        this.AdjustFlagsAndWidth(expression);
        this.expression = expression;
    }


    internal ArgumentSyntax(SyntaxKind kind, NameColonSyntax nameColon, SyntaxToken refOrOutKeyword, ExpressionSyntax expression)
        : base(kind)
    {
        this.SlotCount = 3;
        if (nameColon != null)
        {
            this.AdjustFlagsAndWidth(nameColon);
            this.nameColon = nameColon;
        }
        if (refOrOutKeyword != null)
        {
            this.AdjustFlagsAndWidth(refOrOutKeyword);
            this.refOrOutKeyword = refOrOutKeyword;
        }
        this.AdjustFlagsAndWidth(expression);
        this.expression = expression;
    }

    /// <summary>NameColonSyntax node representing the optional name arguments.</summary>
    public NameColonSyntax NameColon { get { return this.nameColon; } }
    /// <summary>SyntaxToken representing the optional ref or out keyword.</summary>
    public SyntaxToken RefOrOutKeyword { get { return this.refOrOutKeyword; } }
    /// <summary>ExpressionSyntax node representing the argument.</summary>
    public ExpressionSyntax Expression { get { return this.expression; } }

    internal override GreenNode GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.nameColon;
            case 1: return this.refOrOutKeyword;
            case 2: return this.expression;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode parent, int position)
    {
      return new CSharp.Syntax.ArgumentSyntax(this, parent, position);
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitArgument(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitArgument(this);
    }

    public ArgumentSyntax Update(NameColonSyntax nameColon, SyntaxToken refOrOutKeyword, ExpressionSyntax expression)
    {
        if (nameColon != this.NameColon || refOrOutKeyword != this.RefOrOutKeyword || expression != this.Expression)
        {
            var newNode = SyntaxFactory.Argument(nameColon, refOrOutKeyword, expression);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
    {
         return new ArgumentSyntax(this.Kind, this.nameColon, this.refOrOutKeyword, this.expression, diagnostics, GetAnnotations());
    }

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
    {
         return new ArgumentSyntax(this.Kind, this.nameColon, this.refOrOutKeyword, this.expression, GetDiagnostics(), annotations);
    }

    internal ArgumentSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 3;
      var nameColon = (NameColonSyntax)reader.ReadValue();
      if (nameColon != null)
      {
         AdjustFlagsAndWidth(nameColon);
         this.nameColon = nameColon;
      }
      var refOrOutKeyword = (SyntaxToken)reader.ReadValue();
      if (refOrOutKeyword != null)
      {
         AdjustFlagsAndWidth(refOrOutKeyword);
         this.refOrOutKeyword = refOrOutKeyword;
      }
      var expression = (ExpressionSyntax)reader.ReadValue();
      if (expression != null)
      {
         AdjustFlagsAndWidth(expression);
         this.expression = expression;
      }
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.nameColon);
      writer.WriteValue(this.refOrOutKeyword);
      writer.WriteValue(this.expression);
    }

    static ArgumentSyntax()
    {
       ObjectBinder.RegisterTypeReader(typeof(ArgumentSyntax), r => new ArgumentSyntax(r));
    }
  }

  /// <summary>Class which represents the syntax node for name colon syntax.</summary>
  internal sealed partial class NameColonSyntax : CSharpSyntaxNode
  {
    internal readonly IdentifierNameSyntax name;
    internal readonly SyntaxToken colonToken;

    internal NameColonSyntax(SyntaxKind kind, IdentifierNameSyntax name, SyntaxToken colonToken, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 2;
        this.AdjustFlagsAndWidth(name);
        this.name = name;
        this.AdjustFlagsAndWidth(colonToken);
        this.colonToken = colonToken;
    }


    internal NameColonSyntax(SyntaxKind kind, IdentifierNameSyntax name, SyntaxToken colonToken, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 2;
        this.AdjustFlagsAndWidth(name);
        this.name = name;
        this.AdjustFlagsAndWidth(colonToken);
        this.colonToken = colonToken;
    }


    internal NameColonSyntax(SyntaxKind kind, IdentifierNameSyntax name, SyntaxToken colonToken)
        : base(kind)
    {
        this.SlotCount = 2;
        this.AdjustFlagsAndWidth(name);
        this.name = name;
        this.AdjustFlagsAndWidth(colonToken);
        this.colonToken = colonToken;
    }

    /// <summary>IdentifierNameSyntax representing the identifier name.</summary>
    public IdentifierNameSyntax Name { get { return this.name; } }
    /// <summary>SyntaxToken representing colon.</summary>
    public SyntaxToken ColonToken { get { return this.colonToken; } }

    internal override GreenNode GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.name;
            case 1: return this.colonToken;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode parent, int position)
    {
      return new CSharp.Syntax.NameColonSyntax(this, parent, position);
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitNameColon(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitNameColon(this);
    }

    public NameColonSyntax Update(IdentifierNameSyntax name, SyntaxToken colonToken)
    {
        if (name != this.Name || colonToken != this.ColonToken)
        {
            var newNode = SyntaxFactory.NameColon(name, colonToken);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
    {
         return new NameColonSyntax(this.Kind, this.name, this.colonToken, diagnostics, GetAnnotations());
    }

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
    {
         return new NameColonSyntax(this.Kind, this.name, this.colonToken, GetDiagnostics(), annotations);
    }

    internal NameColonSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 2;
      var name = (IdentifierNameSyntax)reader.ReadValue();
      if (name != null)
      {
         AdjustFlagsAndWidth(name);
         this.name = name;
      }
      var colonToken = (SyntaxToken)reader.ReadValue();
      if (colonToken != null)
      {
         AdjustFlagsAndWidth(colonToken);
         this.colonToken = colonToken;
      }
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.name);
      writer.WriteValue(this.colonToken);
    }

    static NameColonSyntax()
    {
       ObjectBinder.RegisterTypeReader(typeof(NameColonSyntax), r => new NameColonSyntax(r));
    }
  }

  /// <summary>Class which represents the syntax node for the variable declaration in an out var declaration or a deconstruction declaration.</summary>
  internal sealed partial class DeclarationExpressionSyntax : ExpressionSyntax
  {
    internal readonly TypeSyntax type;
    internal readonly VariableDesignationSyntax designation;

    internal DeclarationExpressionSyntax(SyntaxKind kind, TypeSyntax type, VariableDesignationSyntax designation, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 2;
        this.AdjustFlagsAndWidth(type);
        this.type = type;
        this.AdjustFlagsAndWidth(designation);
        this.designation = designation;
    }


    internal DeclarationExpressionSyntax(SyntaxKind kind, TypeSyntax type, VariableDesignationSyntax designation, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 2;
        this.AdjustFlagsAndWidth(type);
        this.type = type;
        this.AdjustFlagsAndWidth(designation);
        this.designation = designation;
    }


    internal DeclarationExpressionSyntax(SyntaxKind kind, TypeSyntax type, VariableDesignationSyntax designation)
        : base(kind)
    {
        this.SlotCount = 2;
        this.AdjustFlagsAndWidth(type);
        this.type = type;
        this.AdjustFlagsAndWidth(designation);
        this.designation = designation;
    }

    public TypeSyntax Type { get { return this.type; } }
    /// <summary>Declaration representing the variable declared in an out parameter or deconstruction.</summary>
    public VariableDesignationSyntax Designation { get { return this.designation; } }

    internal override GreenNode GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.type;
            case 1: return this.designation;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode parent, int position)
    {
      return new CSharp.Syntax.DeclarationExpressionSyntax(this, parent, position);
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitDeclarationExpression(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitDeclarationExpression(this);
    }

    public DeclarationExpressionSyntax Update(TypeSyntax type, VariableDesignationSyntax designation)
    {
        if (type != this.Type || designation != this.Designation)
        {
            var newNode = SyntaxFactory.DeclarationExpression(type, designation);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
    {
         return new DeclarationExpressionSyntax(this.Kind, this.type, this.designation, diagnostics, GetAnnotations());
    }

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
    {
         return new DeclarationExpressionSyntax(this.Kind, this.type, this.designation, GetDiagnostics(), annotations);
    }

    internal DeclarationExpressionSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 2;
      var type = (TypeSyntax)reader.ReadValue();
      if (type != null)
      {
         AdjustFlagsAndWidth(type);
         this.type = type;
      }
      var designation = (VariableDesignationSyntax)reader.ReadValue();
      if (designation != null)
      {
         AdjustFlagsAndWidth(designation);
         this.designation = designation;
      }
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.type);
      writer.WriteValue(this.designation);
    }

    static DeclarationExpressionSyntax()
    {
       ObjectBinder.RegisterTypeReader(typeof(DeclarationExpressionSyntax), r => new DeclarationExpressionSyntax(r));
    }
  }

  /// <summary>Class which represents the syntax node for cast expression.</summary>
  internal sealed partial class CastExpressionSyntax : ExpressionSyntax
  {
    internal readonly SyntaxToken openParenToken;
    internal readonly TypeSyntax type;
    internal readonly SyntaxToken closeParenToken;
    internal readonly ExpressionSyntax expression;

    internal CastExpressionSyntax(SyntaxKind kind, SyntaxToken openParenToken, TypeSyntax type, SyntaxToken closeParenToken, ExpressionSyntax expression, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 4;
        this.AdjustFlagsAndWidth(openParenToken);
        this.openParenToken = openParenToken;
        this.AdjustFlagsAndWidth(type);
        this.type = type;
        this.AdjustFlagsAndWidth(closeParenToken);
        this.closeParenToken = closeParenToken;
        this.AdjustFlagsAndWidth(expression);
        this.expression = expression;
    }


    internal CastExpressionSyntax(SyntaxKind kind, SyntaxToken openParenToken, TypeSyntax type, SyntaxToken closeParenToken, ExpressionSyntax expression, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 4;
        this.AdjustFlagsAndWidth(openParenToken);
        this.openParenToken = openParenToken;
        this.AdjustFlagsAndWidth(type);
        this.type = type;
        this.AdjustFlagsAndWidth(closeParenToken);
        this.closeParenToken = closeParenToken;
        this.AdjustFlagsAndWidth(expression);
        this.expression = expression;
    }


    internal CastExpressionSyntax(SyntaxKind kind, SyntaxToken openParenToken, TypeSyntax type, SyntaxToken closeParenToken, ExpressionSyntax expression)
        : base(kind)
    {
        this.SlotCount = 4;
        this.AdjustFlagsAndWidth(openParenToken);
        this.openParenToken = openParenToken;
        this.AdjustFlagsAndWidth(type);
        this.type = type;
        this.AdjustFlagsAndWidth(closeParenToken);
        this.closeParenToken = closeParenToken;
        this.AdjustFlagsAndWidth(expression);
        this.expression = expression;
    }

    /// <summary>SyntaxToken representing the open parenthesis.</summary>
    public SyntaxToken OpenParenToken { get { return this.openParenToken; } }
    /// <summary>TypeSyntax node representing the type to which the expression is being cast.</summary>
    public TypeSyntax Type { get { return this.type; } }
    /// <summary>SyntaxToken representing the close parenthesis.</summary>
    public SyntaxToken CloseParenToken { get { return this.closeParenToken; } }
    /// <summary>ExpressionSyntax node representing the expression that is being casted.</summary>
    public ExpressionSyntax Expression { get { return this.expression; } }

    internal override GreenNode GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.openParenToken;
            case 1: return this.type;
            case 2: return this.closeParenToken;
            case 3: return this.expression;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode parent, int position)
    {
      return new CSharp.Syntax.CastExpressionSyntax(this, parent, position);
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitCastExpression(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitCastExpression(this);
    }

    public CastExpressionSyntax Update(SyntaxToken openParenToken, TypeSyntax type, SyntaxToken closeParenToken, ExpressionSyntax expression)
    {
        if (openParenToken != this.OpenParenToken || type != this.Type || closeParenToken != this.CloseParenToken || expression != this.Expression)
        {
            var newNode = SyntaxFactory.CastExpression(openParenToken, type, closeParenToken, expression);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
    {
         return new CastExpressionSyntax(this.Kind, this.openParenToken, this.type, this.closeParenToken, this.expression, diagnostics, GetAnnotations());
    }

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
    {
         return new CastExpressionSyntax(this.Kind, this.openParenToken, this.type, this.closeParenToken, this.expression, GetDiagnostics(), annotations);
    }

    internal CastExpressionSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 4;
      var openParenToken = (SyntaxToken)reader.ReadValue();
      if (openParenToken != null)
      {
         AdjustFlagsAndWidth(openParenToken);
         this.openParenToken = openParenToken;
      }
      var type = (TypeSyntax)reader.ReadValue();
      if (type != null)
      {
         AdjustFlagsAndWidth(type);
         this.type = type;
      }
      var closeParenToken = (SyntaxToken)reader.ReadValue();
      if (closeParenToken != null)
      {
         AdjustFlagsAndWidth(closeParenToken);
         this.closeParenToken = closeParenToken;
      }
      var expression = (ExpressionSyntax)reader.ReadValue();
      if (expression != null)
      {
         AdjustFlagsAndWidth(expression);
         this.expression = expression;
      }
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.openParenToken);
      writer.WriteValue(this.type);
      writer.WriteValue(this.closeParenToken);
      writer.WriteValue(this.expression);
    }

    static CastExpressionSyntax()
    {
       ObjectBinder.RegisterTypeReader(typeof(CastExpressionSyntax), r => new CastExpressionSyntax(r));
    }
  }

  /// <summary>Provides the base class from which the classes that represent anonymous function expressions are derived.</summary>
  internal abstract partial class AnonymousFunctionExpressionSyntax : ExpressionSyntax
  {
    internal AnonymousFunctionExpressionSyntax(SyntaxKind kind, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
      : base(kind, diagnostics, annotations)
    {
    }
    internal AnonymousFunctionExpressionSyntax(SyntaxKind kind)
      : base(kind)
    {
    }

    protected AnonymousFunctionExpressionSyntax(ObjectReader reader)
       : base(reader)
    {
    }

    /// <summary>Gets the "async" token.</summary>
    public abstract SyntaxToken AsyncKeyword { get; }

    /// <summary>ExpressionSyntax or BlockSyntax representing the body of the lambda expression.</summary>
    public abstract CSharpSyntaxNode Body { get; }
  }

  /// <summary>Class which represents the syntax node for anonymous method expression.</summary>
  internal sealed partial class AnonymousMethodExpressionSyntax : AnonymousFunctionExpressionSyntax
  {
    internal readonly SyntaxToken asyncKeyword;
    internal readonly SyntaxToken delegateKeyword;
    internal readonly ParameterListSyntax parameterList;
    internal readonly CSharpSyntaxNode body;

    internal AnonymousMethodExpressionSyntax(SyntaxKind kind, SyntaxToken asyncKeyword, SyntaxToken delegateKeyword, ParameterListSyntax parameterList, CSharpSyntaxNode body, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 4;
        if (asyncKeyword != null)
        {
            this.AdjustFlagsAndWidth(asyncKeyword);
            this.asyncKeyword = asyncKeyword;
        }
        this.AdjustFlagsAndWidth(delegateKeyword);
        this.delegateKeyword = delegateKeyword;
        if (parameterList != null)
        {
            this.AdjustFlagsAndWidth(parameterList);
            this.parameterList = parameterList;
        }
        this.AdjustFlagsAndWidth(body);
        this.body = body;
    }


    internal AnonymousMethodExpressionSyntax(SyntaxKind kind, SyntaxToken asyncKeyword, SyntaxToken delegateKeyword, ParameterListSyntax parameterList, CSharpSyntaxNode body, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 4;
        if (asyncKeyword != null)
        {
            this.AdjustFlagsAndWidth(asyncKeyword);
            this.asyncKeyword = asyncKeyword;
        }
        this.AdjustFlagsAndWidth(delegateKeyword);
        this.delegateKeyword = delegateKeyword;
        if (parameterList != null)
        {
            this.AdjustFlagsAndWidth(parameterList);
            this.parameterList = parameterList;
        }
        this.AdjustFlagsAndWidth(body);
        this.body = body;
    }


    internal AnonymousMethodExpressionSyntax(SyntaxKind kind, SyntaxToken asyncKeyword, SyntaxToken delegateKeyword, ParameterListSyntax parameterList, CSharpSyntaxNode body)
        : base(kind)
    {
        this.SlotCount = 4;
        if (asyncKeyword != null)
        {
            this.AdjustFlagsAndWidth(asyncKeyword);
            this.asyncKeyword = asyncKeyword;
        }
        this.AdjustFlagsAndWidth(delegateKeyword);
        this.delegateKeyword = delegateKeyword;
        if (parameterList != null)
        {
            this.AdjustFlagsAndWidth(parameterList);
            this.parameterList = parameterList;
        }
        this.AdjustFlagsAndWidth(body);
        this.body = body;
    }

    /// <summary>Gets the "async" token.</summary>
    public override SyntaxToken AsyncKeyword { get { return this.asyncKeyword; } }
    /// <summary>SyntaxToken representing the delegate keyword.</summary>
    public SyntaxToken DelegateKeyword { get { return this.delegateKeyword; } }
    /// <summary>List of parameters of the anonymous method expression, or null if there no parameters are specified.</summary>
    public ParameterListSyntax ParameterList { get { return this.parameterList; } }
    /// <summary>BlockSyntax node representing the body of the anonymous method.</summary>
    public override CSharpSyntaxNode Body { get { return this.body; } }

    internal override GreenNode GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.asyncKeyword;
            case 1: return this.delegateKeyword;
            case 2: return this.parameterList;
            case 3: return this.body;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode parent, int position)
    {
      return new CSharp.Syntax.AnonymousMethodExpressionSyntax(this, parent, position);
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitAnonymousMethodExpression(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitAnonymousMethodExpression(this);
    }

    public AnonymousMethodExpressionSyntax Update(SyntaxToken asyncKeyword, SyntaxToken delegateKeyword, ParameterListSyntax parameterList, CSharpSyntaxNode body)
    {
        if (asyncKeyword != this.AsyncKeyword || delegateKeyword != this.DelegateKeyword || parameterList != this.ParameterList || body != this.Body)
        {
            var newNode = SyntaxFactory.AnonymousMethodExpression(asyncKeyword, delegateKeyword, parameterList, body);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
    {
         return new AnonymousMethodExpressionSyntax(this.Kind, this.asyncKeyword, this.delegateKeyword, this.parameterList, this.body, diagnostics, GetAnnotations());
    }

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
    {
         return new AnonymousMethodExpressionSyntax(this.Kind, this.asyncKeyword, this.delegateKeyword, this.parameterList, this.body, GetDiagnostics(), annotations);
    }

    internal AnonymousMethodExpressionSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 4;
      var asyncKeyword = (SyntaxToken)reader.ReadValue();
      if (asyncKeyword != null)
      {
         AdjustFlagsAndWidth(asyncKeyword);
         this.asyncKeyword = asyncKeyword;
      }
      var delegateKeyword = (SyntaxToken)reader.ReadValue();
      if (delegateKeyword != null)
      {
         AdjustFlagsAndWidth(delegateKeyword);
         this.delegateKeyword = delegateKeyword;
      }
      var parameterList = (ParameterListSyntax)reader.ReadValue();
      if (parameterList != null)
      {
         AdjustFlagsAndWidth(parameterList);
         this.parameterList = parameterList;
      }
      var body = (CSharpSyntaxNode)reader.ReadValue();
      if (body != null)
      {
         AdjustFlagsAndWidth(body);
         this.body = body;
      }
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.asyncKeyword);
      writer.WriteValue(this.delegateKeyword);
      writer.WriteValue(this.parameterList);
      writer.WriteValue(this.body);
    }

    static AnonymousMethodExpressionSyntax()
    {
       ObjectBinder.RegisterTypeReader(typeof(AnonymousMethodExpressionSyntax), r => new AnonymousMethodExpressionSyntax(r));
    }
  }

  /// <summary>Provides the base class from which the classes that represent lambda expressions are derived.</summary>
  internal abstract partial class LambdaExpressionSyntax : AnonymousFunctionExpressionSyntax
  {
    internal LambdaExpressionSyntax(SyntaxKind kind, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
      : base(kind, diagnostics, annotations)
    {
    }
    internal LambdaExpressionSyntax(SyntaxKind kind)
      : base(kind)
    {
    }

    protected LambdaExpressionSyntax(ObjectReader reader)
       : base(reader)
    {
    }

    /// <summary>SyntaxToken representing equals greater than.</summary>
    public abstract SyntaxToken ArrowToken { get; }
  }

  /// <summary>Class which represents the syntax node for a simple lambda expression.</summary>
  internal sealed partial class SimpleLambdaExpressionSyntax : LambdaExpressionSyntax
  {
    internal readonly SyntaxToken asyncKeyword;
    internal readonly ParameterSyntax parameter;
    internal readonly SyntaxToken arrowToken;
    internal readonly CSharpSyntaxNode body;

    internal SimpleLambdaExpressionSyntax(SyntaxKind kind, SyntaxToken asyncKeyword, ParameterSyntax parameter, SyntaxToken arrowToken, CSharpSyntaxNode body, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 4;
        if (asyncKeyword != null)
        {
            this.AdjustFlagsAndWidth(asyncKeyword);
            this.asyncKeyword = asyncKeyword;
        }
        this.AdjustFlagsAndWidth(parameter);
        this.parameter = parameter;
        this.AdjustFlagsAndWidth(arrowToken);
        this.arrowToken = arrowToken;
        this.AdjustFlagsAndWidth(body);
        this.body = body;
    }


    internal SimpleLambdaExpressionSyntax(SyntaxKind kind, SyntaxToken asyncKeyword, ParameterSyntax parameter, SyntaxToken arrowToken, CSharpSyntaxNode body, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 4;
        if (asyncKeyword != null)
        {
            this.AdjustFlagsAndWidth(asyncKeyword);
            this.asyncKeyword = asyncKeyword;
        }
        this.AdjustFlagsAndWidth(parameter);
        this.parameter = parameter;
        this.AdjustFlagsAndWidth(arrowToken);
        this.arrowToken = arrowToken;
        this.AdjustFlagsAndWidth(body);
        this.body = body;
    }


    internal SimpleLambdaExpressionSyntax(SyntaxKind kind, SyntaxToken asyncKeyword, ParameterSyntax parameter, SyntaxToken arrowToken, CSharpSyntaxNode body)
        : base(kind)
    {
        this.SlotCount = 4;
        if (asyncKeyword != null)
        {
            this.AdjustFlagsAndWidth(asyncKeyword);
            this.asyncKeyword = asyncKeyword;
        }
        this.AdjustFlagsAndWidth(parameter);
        this.parameter = parameter;
        this.AdjustFlagsAndWidth(arrowToken);
        this.arrowToken = arrowToken;
        this.AdjustFlagsAndWidth(body);
        this.body = body;
    }

    /// <summary>Gets the "async" token.</summary>
    public override SyntaxToken AsyncKeyword { get { return this.asyncKeyword; } }
    /// <summary>ParameterSyntax node representing the parameter of the lambda expression.</summary>
    public ParameterSyntax Parameter { get { return this.parameter; } }
    /// <summary>SyntaxToken representing equals greater than.</summary>
    public override SyntaxToken ArrowToken { get { return this.arrowToken; } }
    /// <summary>SyntaxNode representing the body of the lambda expression.</summary>
    public override CSharpSyntaxNode Body { get { return this.body; } }

    internal override GreenNode GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.asyncKeyword;
            case 1: return this.parameter;
            case 2: return this.arrowToken;
            case 3: return this.body;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode parent, int position)
    {
      return new CSharp.Syntax.SimpleLambdaExpressionSyntax(this, parent, position);
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitSimpleLambdaExpression(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitSimpleLambdaExpression(this);
    }

    public SimpleLambdaExpressionSyntax Update(SyntaxToken asyncKeyword, ParameterSyntax parameter, SyntaxToken arrowToken, CSharpSyntaxNode body)
    {
        if (asyncKeyword != this.AsyncKeyword || parameter != this.Parameter || arrowToken != this.ArrowToken || body != this.Body)
        {
            var newNode = SyntaxFactory.SimpleLambdaExpression(asyncKeyword, parameter, arrowToken, body);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
    {
         return new SimpleLambdaExpressionSyntax(this.Kind, this.asyncKeyword, this.parameter, this.arrowToken, this.body, diagnostics, GetAnnotations());
    }

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
    {
         return new SimpleLambdaExpressionSyntax(this.Kind, this.asyncKeyword, this.parameter, this.arrowToken, this.body, GetDiagnostics(), annotations);
    }

    internal SimpleLambdaExpressionSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 4;
      var asyncKeyword = (SyntaxToken)reader.ReadValue();
      if (asyncKeyword != null)
      {
         AdjustFlagsAndWidth(asyncKeyword);
         this.asyncKeyword = asyncKeyword;
      }
      var parameter = (ParameterSyntax)reader.ReadValue();
      if (parameter != null)
      {
         AdjustFlagsAndWidth(parameter);
         this.parameter = parameter;
      }
      var arrowToken = (SyntaxToken)reader.ReadValue();
      if (arrowToken != null)
      {
         AdjustFlagsAndWidth(arrowToken);
         this.arrowToken = arrowToken;
      }
      var body = (CSharpSyntaxNode)reader.ReadValue();
      if (body != null)
      {
         AdjustFlagsAndWidth(body);
         this.body = body;
      }
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.asyncKeyword);
      writer.WriteValue(this.parameter);
      writer.WriteValue(this.arrowToken);
      writer.WriteValue(this.body);
    }

    static SimpleLambdaExpressionSyntax()
    {
       ObjectBinder.RegisterTypeReader(typeof(SimpleLambdaExpressionSyntax), r => new SimpleLambdaExpressionSyntax(r));
    }
  }

  internal sealed partial class RefExpressionSyntax : ExpressionSyntax
  {
    internal readonly SyntaxToken refKeyword;
    internal readonly ExpressionSyntax expression;

    internal RefExpressionSyntax(SyntaxKind kind, SyntaxToken refKeyword, ExpressionSyntax expression, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 2;
        this.AdjustFlagsAndWidth(refKeyword);
        this.refKeyword = refKeyword;
        this.AdjustFlagsAndWidth(expression);
        this.expression = expression;
    }


    internal RefExpressionSyntax(SyntaxKind kind, SyntaxToken refKeyword, ExpressionSyntax expression, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 2;
        this.AdjustFlagsAndWidth(refKeyword);
        this.refKeyword = refKeyword;
        this.AdjustFlagsAndWidth(expression);
        this.expression = expression;
    }


    internal RefExpressionSyntax(SyntaxKind kind, SyntaxToken refKeyword, ExpressionSyntax expression)
        : base(kind)
    {
        this.SlotCount = 2;
        this.AdjustFlagsAndWidth(refKeyword);
        this.refKeyword = refKeyword;
        this.AdjustFlagsAndWidth(expression);
        this.expression = expression;
    }

    public SyntaxToken RefKeyword { get { return this.refKeyword; } }
    public ExpressionSyntax Expression { get { return this.expression; } }

    internal override GreenNode GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.refKeyword;
            case 1: return this.expression;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode parent, int position)
    {
      return new CSharp.Syntax.RefExpressionSyntax(this, parent, position);
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitRefExpression(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitRefExpression(this);
    }

    public RefExpressionSyntax Update(SyntaxToken refKeyword, ExpressionSyntax expression)
    {
        if (refKeyword != this.RefKeyword || expression != this.Expression)
        {
            var newNode = SyntaxFactory.RefExpression(refKeyword, expression);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
    {
         return new RefExpressionSyntax(this.Kind, this.refKeyword, this.expression, diagnostics, GetAnnotations());
    }

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
    {
         return new RefExpressionSyntax(this.Kind, this.refKeyword, this.expression, GetDiagnostics(), annotations);
    }

    internal RefExpressionSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 2;
      var refKeyword = (SyntaxToken)reader.ReadValue();
      if (refKeyword != null)
      {
         AdjustFlagsAndWidth(refKeyword);
         this.refKeyword = refKeyword;
      }
      var expression = (ExpressionSyntax)reader.ReadValue();
      if (expression != null)
      {
         AdjustFlagsAndWidth(expression);
         this.expression = expression;
      }
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.refKeyword);
      writer.WriteValue(this.expression);
    }

    static RefExpressionSyntax()
    {
       ObjectBinder.RegisterTypeReader(typeof(RefExpressionSyntax), r => new RefExpressionSyntax(r));
    }
  }

  /// <summary>Class which represents the syntax node for parenthesized lambda expression.</summary>
  internal sealed partial class ParenthesizedLambdaExpressionSyntax : LambdaExpressionSyntax
  {
    internal readonly SyntaxToken asyncKeyword;
    internal readonly ParameterListSyntax parameterList;
    internal readonly SyntaxToken arrowToken;
    internal readonly CSharpSyntaxNode body;

    internal ParenthesizedLambdaExpressionSyntax(SyntaxKind kind, SyntaxToken asyncKeyword, ParameterListSyntax parameterList, SyntaxToken arrowToken, CSharpSyntaxNode body, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 4;
        if (asyncKeyword != null)
        {
            this.AdjustFlagsAndWidth(asyncKeyword);
            this.asyncKeyword = asyncKeyword;
        }
        this.AdjustFlagsAndWidth(parameterList);
        this.parameterList = parameterList;
        this.AdjustFlagsAndWidth(arrowToken);
        this.arrowToken = arrowToken;
        this.AdjustFlagsAndWidth(body);
        this.body = body;
    }


    internal ParenthesizedLambdaExpressionSyntax(SyntaxKind kind, SyntaxToken asyncKeyword, ParameterListSyntax parameterList, SyntaxToken arrowToken, CSharpSyntaxNode body, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 4;
        if (asyncKeyword != null)
        {
            this.AdjustFlagsAndWidth(asyncKeyword);
            this.asyncKeyword = asyncKeyword;
        }
        this.AdjustFlagsAndWidth(parameterList);
        this.parameterList = parameterList;
        this.AdjustFlagsAndWidth(arrowToken);
        this.arrowToken = arrowToken;
        this.AdjustFlagsAndWidth(body);
        this.body = body;
    }


    internal ParenthesizedLambdaExpressionSyntax(SyntaxKind kind, SyntaxToken asyncKeyword, ParameterListSyntax parameterList, SyntaxToken arrowToken, CSharpSyntaxNode body)
        : base(kind)
    {
        this.SlotCount = 4;
        if (asyncKeyword != null)
        {
            this.AdjustFlagsAndWidth(asyncKeyword);
            this.asyncKeyword = asyncKeyword;
        }
        this.AdjustFlagsAndWidth(parameterList);
        this.parameterList = parameterList;
        this.AdjustFlagsAndWidth(arrowToken);
        this.arrowToken = arrowToken;
        this.AdjustFlagsAndWidth(body);
        this.body = body;
    }

    /// <summary>Gets the "async" token.</summary>
    public override SyntaxToken AsyncKeyword { get { return this.asyncKeyword; } }
    /// <summary>ParameterListSyntax node representing the list of parameters for the lambda expression.</summary>
    public ParameterListSyntax ParameterList { get { return this.parameterList; } }
    /// <summary>SyntaxToken representing equals greater than.</summary>
    public override SyntaxToken ArrowToken { get { return this.arrowToken; } }
    /// <summary>SyntaxNode representing the body of the lambda expression.</summary>
    public override CSharpSyntaxNode Body { get { return this.body; } }

    internal override GreenNode GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.asyncKeyword;
            case 1: return this.parameterList;
            case 2: return this.arrowToken;
            case 3: return this.body;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode parent, int position)
    {
      return new CSharp.Syntax.ParenthesizedLambdaExpressionSyntax(this, parent, position);
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitParenthesizedLambdaExpression(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitParenthesizedLambdaExpression(this);
    }

    public ParenthesizedLambdaExpressionSyntax Update(SyntaxToken asyncKeyword, ParameterListSyntax parameterList, SyntaxToken arrowToken, CSharpSyntaxNode body)
    {
        if (asyncKeyword != this.AsyncKeyword || parameterList != this.ParameterList || arrowToken != this.ArrowToken || body != this.Body)
        {
            var newNode = SyntaxFactory.ParenthesizedLambdaExpression(asyncKeyword, parameterList, arrowToken, body);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
    {
         return new ParenthesizedLambdaExpressionSyntax(this.Kind, this.asyncKeyword, this.parameterList, this.arrowToken, this.body, diagnostics, GetAnnotations());
    }

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
    {
         return new ParenthesizedLambdaExpressionSyntax(this.Kind, this.asyncKeyword, this.parameterList, this.arrowToken, this.body, GetDiagnostics(), annotations);
    }

    internal ParenthesizedLambdaExpressionSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 4;
      var asyncKeyword = (SyntaxToken)reader.ReadValue();
      if (asyncKeyword != null)
      {
         AdjustFlagsAndWidth(asyncKeyword);
         this.asyncKeyword = asyncKeyword;
      }
      var parameterList = (ParameterListSyntax)reader.ReadValue();
      if (parameterList != null)
      {
         AdjustFlagsAndWidth(parameterList);
         this.parameterList = parameterList;
      }
      var arrowToken = (SyntaxToken)reader.ReadValue();
      if (arrowToken != null)
      {
         AdjustFlagsAndWidth(arrowToken);
         this.arrowToken = arrowToken;
      }
      var body = (CSharpSyntaxNode)reader.ReadValue();
      if (body != null)
      {
         AdjustFlagsAndWidth(body);
         this.body = body;
      }
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.asyncKeyword);
      writer.WriteValue(this.parameterList);
      writer.WriteValue(this.arrowToken);
      writer.WriteValue(this.body);
    }

    static ParenthesizedLambdaExpressionSyntax()
    {
       ObjectBinder.RegisterTypeReader(typeof(ParenthesizedLambdaExpressionSyntax), r => new ParenthesizedLambdaExpressionSyntax(r));
    }
  }

  /// <summary>Class which represents the syntax node for initializer expression.</summary>
  internal sealed partial class InitializerExpressionSyntax : ExpressionSyntax
  {
    internal readonly SyntaxToken openBraceToken;
    internal readonly GreenNode expressions;
    internal readonly SyntaxToken closeBraceToken;

    internal InitializerExpressionSyntax(SyntaxKind kind, SyntaxToken openBraceToken, GreenNode expressions, SyntaxToken closeBraceToken, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 3;
        this.AdjustFlagsAndWidth(openBraceToken);
        this.openBraceToken = openBraceToken;
        if (expressions != null)
        {
            this.AdjustFlagsAndWidth(expressions);
            this.expressions = expressions;
        }
        this.AdjustFlagsAndWidth(closeBraceToken);
        this.closeBraceToken = closeBraceToken;
    }


    internal InitializerExpressionSyntax(SyntaxKind kind, SyntaxToken openBraceToken, GreenNode expressions, SyntaxToken closeBraceToken, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 3;
        this.AdjustFlagsAndWidth(openBraceToken);
        this.openBraceToken = openBraceToken;
        if (expressions != null)
        {
            this.AdjustFlagsAndWidth(expressions);
            this.expressions = expressions;
        }
        this.AdjustFlagsAndWidth(closeBraceToken);
        this.closeBraceToken = closeBraceToken;
    }


    internal InitializerExpressionSyntax(SyntaxKind kind, SyntaxToken openBraceToken, GreenNode expressions, SyntaxToken closeBraceToken)
        : base(kind)
    {
        this.SlotCount = 3;
        this.AdjustFlagsAndWidth(openBraceToken);
        this.openBraceToken = openBraceToken;
        if (expressions != null)
        {
            this.AdjustFlagsAndWidth(expressions);
            this.expressions = expressions;
        }
        this.AdjustFlagsAndWidth(closeBraceToken);
        this.closeBraceToken = closeBraceToken;
    }

    /// <summary>SyntaxToken representing the open brace.</summary>
    public SyntaxToken OpenBraceToken { get { return this.openBraceToken; } }
    /// <summary>SeparatedSyntaxList of ExpressionSyntax representing the list of expressions in the initializer expression.</summary>
    public Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<ExpressionSyntax> Expressions { get { return new Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<ExpressionSyntax>(new Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<CSharpSyntaxNode>(this.expressions)); } }
    /// <summary>SyntaxToken representing the close brace.</summary>
    public SyntaxToken CloseBraceToken { get { return this.closeBraceToken; } }

    internal override GreenNode GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.openBraceToken;
            case 1: return this.expressions;
            case 2: return this.closeBraceToken;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode parent, int position)
    {
      return new CSharp.Syntax.InitializerExpressionSyntax(this, parent, position);
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitInitializerExpression(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitInitializerExpression(this);
    }

    public InitializerExpressionSyntax Update(SyntaxToken openBraceToken, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<ExpressionSyntax> expressions, SyntaxToken closeBraceToken)
    {
        if (openBraceToken != this.OpenBraceToken || expressions != this.Expressions || closeBraceToken != this.CloseBraceToken)
        {
            var newNode = SyntaxFactory.InitializerExpression(this.Kind, openBraceToken, expressions, closeBraceToken);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
    {
         return new InitializerExpressionSyntax(this.Kind, this.openBraceToken, this.expressions, this.closeBraceToken, diagnostics, GetAnnotations());
    }

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
    {
         return new InitializerExpressionSyntax(this.Kind, this.openBraceToken, this.expressions, this.closeBraceToken, GetDiagnostics(), annotations);
    }

    internal InitializerExpressionSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 3;
      var openBraceToken = (SyntaxToken)reader.ReadValue();
      if (openBraceToken != null)
      {
         AdjustFlagsAndWidth(openBraceToken);
         this.openBraceToken = openBraceToken;
      }
      var expressions = (GreenNode)reader.ReadValue();
      if (expressions != null)
      {
         AdjustFlagsAndWidth(expressions);
         this.expressions = expressions;
      }
      var closeBraceToken = (SyntaxToken)reader.ReadValue();
      if (closeBraceToken != null)
      {
         AdjustFlagsAndWidth(closeBraceToken);
         this.closeBraceToken = closeBraceToken;
      }
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.openBraceToken);
      writer.WriteValue(this.expressions);
      writer.WriteValue(this.closeBraceToken);
    }

    static InitializerExpressionSyntax()
    {
       ObjectBinder.RegisterTypeReader(typeof(InitializerExpressionSyntax), r => new InitializerExpressionSyntax(r));
    }
  }

  /// <summary>Class which represents the syntax node for object creation expression.</summary>
  internal sealed partial class ObjectCreationExpressionSyntax : ExpressionSyntax
  {
    internal readonly SyntaxToken newKeyword;
    internal readonly TypeSyntax type;
    internal readonly ArgumentListSyntax argumentList;
    internal readonly InitializerExpressionSyntax initializer;

    internal ObjectCreationExpressionSyntax(SyntaxKind kind, SyntaxToken newKeyword, TypeSyntax type, ArgumentListSyntax argumentList, InitializerExpressionSyntax initializer, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 4;
        this.AdjustFlagsAndWidth(newKeyword);
        this.newKeyword = newKeyword;
        this.AdjustFlagsAndWidth(type);
        this.type = type;
        if (argumentList != null)
        {
            this.AdjustFlagsAndWidth(argumentList);
            this.argumentList = argumentList;
        }
        if (initializer != null)
        {
            this.AdjustFlagsAndWidth(initializer);
            this.initializer = initializer;
        }
    }


    internal ObjectCreationExpressionSyntax(SyntaxKind kind, SyntaxToken newKeyword, TypeSyntax type, ArgumentListSyntax argumentList, InitializerExpressionSyntax initializer, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 4;
        this.AdjustFlagsAndWidth(newKeyword);
        this.newKeyword = newKeyword;
        this.AdjustFlagsAndWidth(type);
        this.type = type;
        if (argumentList != null)
        {
            this.AdjustFlagsAndWidth(argumentList);
            this.argumentList = argumentList;
        }
        if (initializer != null)
        {
            this.AdjustFlagsAndWidth(initializer);
            this.initializer = initializer;
        }
    }


    internal ObjectCreationExpressionSyntax(SyntaxKind kind, SyntaxToken newKeyword, TypeSyntax type, ArgumentListSyntax argumentList, InitializerExpressionSyntax initializer)
        : base(kind)
    {
        this.SlotCount = 4;
        this.AdjustFlagsAndWidth(newKeyword);
        this.newKeyword = newKeyword;
        this.AdjustFlagsAndWidth(type);
        this.type = type;
        if (argumentList != null)
        {
            this.AdjustFlagsAndWidth(argumentList);
            this.argumentList = argumentList;
        }
        if (initializer != null)
        {
            this.AdjustFlagsAndWidth(initializer);
            this.initializer = initializer;
        }
    }

    /// <summary>SyntaxToken representing the new keyword.</summary>
    public SyntaxToken NewKeyword { get { return this.newKeyword; } }
    /// <summary>TypeSyntax representing the type of the object being created.</summary>
    public TypeSyntax Type { get { return this.type; } }
    /// <summary>ArgumentListSyntax representing the list of arguments passed as part of the object creation expression.</summary>
    public ArgumentListSyntax ArgumentList { get { return this.argumentList; } }
    /// <summary>InitializerExpressionSyntax representing the initializer expression for the object being created.</summary>
    public InitializerExpressionSyntax Initializer { get { return this.initializer; } }

    internal override GreenNode GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.newKeyword;
            case 1: return this.type;
            case 2: return this.argumentList;
            case 3: return this.initializer;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode parent, int position)
    {
      return new CSharp.Syntax.ObjectCreationExpressionSyntax(this, parent, position);
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitObjectCreationExpression(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitObjectCreationExpression(this);
    }

    public ObjectCreationExpressionSyntax Update(SyntaxToken newKeyword, TypeSyntax type, ArgumentListSyntax argumentList, InitializerExpressionSyntax initializer)
    {
        if (newKeyword != this.NewKeyword || type != this.Type || argumentList != this.ArgumentList || initializer != this.Initializer)
        {
            var newNode = SyntaxFactory.ObjectCreationExpression(newKeyword, type, argumentList, initializer);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
    {
         return new ObjectCreationExpressionSyntax(this.Kind, this.newKeyword, this.type, this.argumentList, this.initializer, diagnostics, GetAnnotations());
    }

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
    {
         return new ObjectCreationExpressionSyntax(this.Kind, this.newKeyword, this.type, this.argumentList, this.initializer, GetDiagnostics(), annotations);
    }

    internal ObjectCreationExpressionSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 4;
      var newKeyword = (SyntaxToken)reader.ReadValue();
      if (newKeyword != null)
      {
         AdjustFlagsAndWidth(newKeyword);
         this.newKeyword = newKeyword;
      }
      var type = (TypeSyntax)reader.ReadValue();
      if (type != null)
      {
         AdjustFlagsAndWidth(type);
         this.type = type;
      }
      var argumentList = (ArgumentListSyntax)reader.ReadValue();
      if (argumentList != null)
      {
         AdjustFlagsAndWidth(argumentList);
         this.argumentList = argumentList;
      }
      var initializer = (InitializerExpressionSyntax)reader.ReadValue();
      if (initializer != null)
      {
         AdjustFlagsAndWidth(initializer);
         this.initializer = initializer;
      }
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.newKeyword);
      writer.WriteValue(this.type);
      writer.WriteValue(this.argumentList);
      writer.WriteValue(this.initializer);
    }

    static ObjectCreationExpressionSyntax()
    {
       ObjectBinder.RegisterTypeReader(typeof(ObjectCreationExpressionSyntax), r => new ObjectCreationExpressionSyntax(r));
    }
  }

  internal sealed partial class AnonymousObjectMemberDeclaratorSyntax : CSharpSyntaxNode
  {
    internal readonly NameEqualsSyntax nameEquals;
    internal readonly ExpressionSyntax expression;

    internal AnonymousObjectMemberDeclaratorSyntax(SyntaxKind kind, NameEqualsSyntax nameEquals, ExpressionSyntax expression, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 2;
        if (nameEquals != null)
        {
            this.AdjustFlagsAndWidth(nameEquals);
            this.nameEquals = nameEquals;
        }
        this.AdjustFlagsAndWidth(expression);
        this.expression = expression;
    }


    internal AnonymousObjectMemberDeclaratorSyntax(SyntaxKind kind, NameEqualsSyntax nameEquals, ExpressionSyntax expression, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 2;
        if (nameEquals != null)
        {
            this.AdjustFlagsAndWidth(nameEquals);
            this.nameEquals = nameEquals;
        }
        this.AdjustFlagsAndWidth(expression);
        this.expression = expression;
    }


    internal AnonymousObjectMemberDeclaratorSyntax(SyntaxKind kind, NameEqualsSyntax nameEquals, ExpressionSyntax expression)
        : base(kind)
    {
        this.SlotCount = 2;
        if (nameEquals != null)
        {
            this.AdjustFlagsAndWidth(nameEquals);
            this.nameEquals = nameEquals;
        }
        this.AdjustFlagsAndWidth(expression);
        this.expression = expression;
    }

    /// <summary>NameEqualsSyntax representing the optional name of the member being initialized.</summary>
    public NameEqualsSyntax NameEquals { get { return this.nameEquals; } }
    /// <summary>ExpressionSyntax representing the value the member is initialized with.</summary>
    public ExpressionSyntax Expression { get { return this.expression; } }

    internal override GreenNode GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.nameEquals;
            case 1: return this.expression;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode parent, int position)
    {
      return new CSharp.Syntax.AnonymousObjectMemberDeclaratorSyntax(this, parent, position);
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitAnonymousObjectMemberDeclarator(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitAnonymousObjectMemberDeclarator(this);
    }

    public AnonymousObjectMemberDeclaratorSyntax Update(NameEqualsSyntax nameEquals, ExpressionSyntax expression)
    {
        if (nameEquals != this.NameEquals || expression != this.Expression)
        {
            var newNode = SyntaxFactory.AnonymousObjectMemberDeclarator(nameEquals, expression);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
    {
         return new AnonymousObjectMemberDeclaratorSyntax(this.Kind, this.nameEquals, this.expression, diagnostics, GetAnnotations());
    }

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
    {
         return new AnonymousObjectMemberDeclaratorSyntax(this.Kind, this.nameEquals, this.expression, GetDiagnostics(), annotations);
    }

    internal AnonymousObjectMemberDeclaratorSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 2;
      var nameEquals = (NameEqualsSyntax)reader.ReadValue();
      if (nameEquals != null)
      {
         AdjustFlagsAndWidth(nameEquals);
         this.nameEquals = nameEquals;
      }
      var expression = (ExpressionSyntax)reader.ReadValue();
      if (expression != null)
      {
         AdjustFlagsAndWidth(expression);
         this.expression = expression;
      }
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.nameEquals);
      writer.WriteValue(this.expression);
    }

    static AnonymousObjectMemberDeclaratorSyntax()
    {
       ObjectBinder.RegisterTypeReader(typeof(AnonymousObjectMemberDeclaratorSyntax), r => new AnonymousObjectMemberDeclaratorSyntax(r));
    }
  }

  /// <summary>Class which represents the syntax node for anonymous object creation expression.</summary>
  internal sealed partial class AnonymousObjectCreationExpressionSyntax : ExpressionSyntax
  {
    internal readonly SyntaxToken newKeyword;
    internal readonly SyntaxToken openBraceToken;
    internal readonly GreenNode initializers;
    internal readonly SyntaxToken closeBraceToken;

    internal AnonymousObjectCreationExpressionSyntax(SyntaxKind kind, SyntaxToken newKeyword, SyntaxToken openBraceToken, GreenNode initializers, SyntaxToken closeBraceToken, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 4;
        this.AdjustFlagsAndWidth(newKeyword);
        this.newKeyword = newKeyword;
        this.AdjustFlagsAndWidth(openBraceToken);
        this.openBraceToken = openBraceToken;
        if (initializers != null)
        {
            this.AdjustFlagsAndWidth(initializers);
            this.initializers = initializers;
        }
        this.AdjustFlagsAndWidth(closeBraceToken);
        this.closeBraceToken = closeBraceToken;
    }


    internal AnonymousObjectCreationExpressionSyntax(SyntaxKind kind, SyntaxToken newKeyword, SyntaxToken openBraceToken, GreenNode initializers, SyntaxToken closeBraceToken, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 4;
        this.AdjustFlagsAndWidth(newKeyword);
        this.newKeyword = newKeyword;
        this.AdjustFlagsAndWidth(openBraceToken);
        this.openBraceToken = openBraceToken;
        if (initializers != null)
        {
            this.AdjustFlagsAndWidth(initializers);
            this.initializers = initializers;
        }
        this.AdjustFlagsAndWidth(closeBraceToken);
        this.closeBraceToken = closeBraceToken;
    }


    internal AnonymousObjectCreationExpressionSyntax(SyntaxKind kind, SyntaxToken newKeyword, SyntaxToken openBraceToken, GreenNode initializers, SyntaxToken closeBraceToken)
        : base(kind)
    {
        this.SlotCount = 4;
        this.AdjustFlagsAndWidth(newKeyword);
        this.newKeyword = newKeyword;
        this.AdjustFlagsAndWidth(openBraceToken);
        this.openBraceToken = openBraceToken;
        if (initializers != null)
        {
            this.AdjustFlagsAndWidth(initializers);
            this.initializers = initializers;
        }
        this.AdjustFlagsAndWidth(closeBraceToken);
        this.closeBraceToken = closeBraceToken;
    }

    /// <summary>SyntaxToken representing the new keyword.</summary>
    public SyntaxToken NewKeyword { get { return this.newKeyword; } }
    /// <summary>SyntaxToken representing the open brace.</summary>
    public SyntaxToken OpenBraceToken { get { return this.openBraceToken; } }
    /// <summary>SeparatedSyntaxList of AnonymousObjectMemberDeclaratorSyntax representing the list of object member initializers.</summary>
    public Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<AnonymousObjectMemberDeclaratorSyntax> Initializers { get { return new Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<AnonymousObjectMemberDeclaratorSyntax>(new Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<CSharpSyntaxNode>(this.initializers)); } }
    /// <summary>SyntaxToken representing the close brace.</summary>
    public SyntaxToken CloseBraceToken { get { return this.closeBraceToken; } }

    internal override GreenNode GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.newKeyword;
            case 1: return this.openBraceToken;
            case 2: return this.initializers;
            case 3: return this.closeBraceToken;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode parent, int position)
    {
      return new CSharp.Syntax.AnonymousObjectCreationExpressionSyntax(this, parent, position);
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitAnonymousObjectCreationExpression(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitAnonymousObjectCreationExpression(this);
    }

    public AnonymousObjectCreationExpressionSyntax Update(SyntaxToken newKeyword, SyntaxToken openBraceToken, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<AnonymousObjectMemberDeclaratorSyntax> initializers, SyntaxToken closeBraceToken)
    {
        if (newKeyword != this.NewKeyword || openBraceToken != this.OpenBraceToken || initializers != this.Initializers || closeBraceToken != this.CloseBraceToken)
        {
            var newNode = SyntaxFactory.AnonymousObjectCreationExpression(newKeyword, openBraceToken, initializers, closeBraceToken);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
    {
         return new AnonymousObjectCreationExpressionSyntax(this.Kind, this.newKeyword, this.openBraceToken, this.initializers, this.closeBraceToken, diagnostics, GetAnnotations());
    }

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
    {
         return new AnonymousObjectCreationExpressionSyntax(this.Kind, this.newKeyword, this.openBraceToken, this.initializers, this.closeBraceToken, GetDiagnostics(), annotations);
    }

    internal AnonymousObjectCreationExpressionSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 4;
      var newKeyword = (SyntaxToken)reader.ReadValue();
      if (newKeyword != null)
      {
         AdjustFlagsAndWidth(newKeyword);
         this.newKeyword = newKeyword;
      }
      var openBraceToken = (SyntaxToken)reader.ReadValue();
      if (openBraceToken != null)
      {
         AdjustFlagsAndWidth(openBraceToken);
         this.openBraceToken = openBraceToken;
      }
      var initializers = (GreenNode)reader.ReadValue();
      if (initializers != null)
      {
         AdjustFlagsAndWidth(initializers);
         this.initializers = initializers;
      }
      var closeBraceToken = (SyntaxToken)reader.ReadValue();
      if (closeBraceToken != null)
      {
         AdjustFlagsAndWidth(closeBraceToken);
         this.closeBraceToken = closeBraceToken;
      }
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.newKeyword);
      writer.WriteValue(this.openBraceToken);
      writer.WriteValue(this.initializers);
      writer.WriteValue(this.closeBraceToken);
    }

    static AnonymousObjectCreationExpressionSyntax()
    {
       ObjectBinder.RegisterTypeReader(typeof(AnonymousObjectCreationExpressionSyntax), r => new AnonymousObjectCreationExpressionSyntax(r));
    }
  }

  /// <summary>Class which represents the syntax node for array creation expression.</summary>
  internal sealed partial class ArrayCreationExpressionSyntax : ExpressionSyntax
  {
    internal readonly SyntaxToken newKeyword;
    internal readonly ArrayTypeSyntax type;
    internal readonly InitializerExpressionSyntax initializer;

    internal ArrayCreationExpressionSyntax(SyntaxKind kind, SyntaxToken newKeyword, ArrayTypeSyntax type, InitializerExpressionSyntax initializer, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 3;
        this.AdjustFlagsAndWidth(newKeyword);
        this.newKeyword = newKeyword;
        this.AdjustFlagsAndWidth(type);
        this.type = type;
        if (initializer != null)
        {
            this.AdjustFlagsAndWidth(initializer);
            this.initializer = initializer;
        }
    }


    internal ArrayCreationExpressionSyntax(SyntaxKind kind, SyntaxToken newKeyword, ArrayTypeSyntax type, InitializerExpressionSyntax initializer, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 3;
        this.AdjustFlagsAndWidth(newKeyword);
        this.newKeyword = newKeyword;
        this.AdjustFlagsAndWidth(type);
        this.type = type;
        if (initializer != null)
        {
            this.AdjustFlagsAndWidth(initializer);
            this.initializer = initializer;
        }
    }


    internal ArrayCreationExpressionSyntax(SyntaxKind kind, SyntaxToken newKeyword, ArrayTypeSyntax type, InitializerExpressionSyntax initializer)
        : base(kind)
    {
        this.SlotCount = 3;
        this.AdjustFlagsAndWidth(newKeyword);
        this.newKeyword = newKeyword;
        this.AdjustFlagsAndWidth(type);
        this.type = type;
        if (initializer != null)
        {
            this.AdjustFlagsAndWidth(initializer);
            this.initializer = initializer;
        }
    }

    /// <summary>SyntaxToken representing the new keyword.</summary>
    public SyntaxToken NewKeyword { get { return this.newKeyword; } }
    /// <summary>ArrayTypeSyntax node representing the type of the array.</summary>
    public ArrayTypeSyntax Type { get { return this.type; } }
    /// <summary>InitializerExpressionSyntax node representing the initializer of the array creation expression.</summary>
    public InitializerExpressionSyntax Initializer { get { return this.initializer; } }

    internal override GreenNode GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.newKeyword;
            case 1: return this.type;
            case 2: return this.initializer;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode parent, int position)
    {
      return new CSharp.Syntax.ArrayCreationExpressionSyntax(this, parent, position);
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitArrayCreationExpression(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitArrayCreationExpression(this);
    }

    public ArrayCreationExpressionSyntax Update(SyntaxToken newKeyword, ArrayTypeSyntax type, InitializerExpressionSyntax initializer)
    {
        if (newKeyword != this.NewKeyword || type != this.Type || initializer != this.Initializer)
        {
            var newNode = SyntaxFactory.ArrayCreationExpression(newKeyword, type, initializer);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
    {
         return new ArrayCreationExpressionSyntax(this.Kind, this.newKeyword, this.type, this.initializer, diagnostics, GetAnnotations());
    }

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
    {
         return new ArrayCreationExpressionSyntax(this.Kind, this.newKeyword, this.type, this.initializer, GetDiagnostics(), annotations);
    }

    internal ArrayCreationExpressionSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 3;
      var newKeyword = (SyntaxToken)reader.ReadValue();
      if (newKeyword != null)
      {
         AdjustFlagsAndWidth(newKeyword);
         this.newKeyword = newKeyword;
      }
      var type = (ArrayTypeSyntax)reader.ReadValue();
      if (type != null)
      {
         AdjustFlagsAndWidth(type);
         this.type = type;
      }
      var initializer = (InitializerExpressionSyntax)reader.ReadValue();
      if (initializer != null)
      {
         AdjustFlagsAndWidth(initializer);
         this.initializer = initializer;
      }
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.newKeyword);
      writer.WriteValue(this.type);
      writer.WriteValue(this.initializer);
    }

    static ArrayCreationExpressionSyntax()
    {
       ObjectBinder.RegisterTypeReader(typeof(ArrayCreationExpressionSyntax), r => new ArrayCreationExpressionSyntax(r));
    }
  }

  /// <summary>Class which represents the syntax node for implicit array creation expression.</summary>
  internal sealed partial class ImplicitArrayCreationExpressionSyntax : ExpressionSyntax
  {
    internal readonly SyntaxToken newKeyword;
    internal readonly SyntaxToken openBracketToken;
    internal readonly GreenNode commas;
    internal readonly SyntaxToken closeBracketToken;
    internal readonly InitializerExpressionSyntax initializer;

    internal ImplicitArrayCreationExpressionSyntax(SyntaxKind kind, SyntaxToken newKeyword, SyntaxToken openBracketToken, GreenNode commas, SyntaxToken closeBracketToken, InitializerExpressionSyntax initializer, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 5;
        this.AdjustFlagsAndWidth(newKeyword);
        this.newKeyword = newKeyword;
        this.AdjustFlagsAndWidth(openBracketToken);
        this.openBracketToken = openBracketToken;
        if (commas != null)
        {
            this.AdjustFlagsAndWidth(commas);
            this.commas = commas;
        }
        this.AdjustFlagsAndWidth(closeBracketToken);
        this.closeBracketToken = closeBracketToken;
        this.AdjustFlagsAndWidth(initializer);
        this.initializer = initializer;
    }


    internal ImplicitArrayCreationExpressionSyntax(SyntaxKind kind, SyntaxToken newKeyword, SyntaxToken openBracketToken, GreenNode commas, SyntaxToken closeBracketToken, InitializerExpressionSyntax initializer, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 5;
        this.AdjustFlagsAndWidth(newKeyword);
        this.newKeyword = newKeyword;
        this.AdjustFlagsAndWidth(openBracketToken);
        this.openBracketToken = openBracketToken;
        if (commas != null)
        {
            this.AdjustFlagsAndWidth(commas);
            this.commas = commas;
        }
        this.AdjustFlagsAndWidth(closeBracketToken);
        this.closeBracketToken = closeBracketToken;
        this.AdjustFlagsAndWidth(initializer);
        this.initializer = initializer;
    }


    internal ImplicitArrayCreationExpressionSyntax(SyntaxKind kind, SyntaxToken newKeyword, SyntaxToken openBracketToken, GreenNode commas, SyntaxToken closeBracketToken, InitializerExpressionSyntax initializer)
        : base(kind)
    {
        this.SlotCount = 5;
        this.AdjustFlagsAndWidth(newKeyword);
        this.newKeyword = newKeyword;
        this.AdjustFlagsAndWidth(openBracketToken);
        this.openBracketToken = openBracketToken;
        if (commas != null)
        {
            this.AdjustFlagsAndWidth(commas);
            this.commas = commas;
        }
        this.AdjustFlagsAndWidth(closeBracketToken);
        this.closeBracketToken = closeBracketToken;
        this.AdjustFlagsAndWidth(initializer);
        this.initializer = initializer;
    }

    /// <summary>SyntaxToken representing the new keyword.</summary>
    public SyntaxToken NewKeyword { get { return this.newKeyword; } }
    /// <summary>SyntaxToken representing the open bracket.</summary>
    public SyntaxToken OpenBracketToken { get { return this.openBracketToken; } }
    /// <summary>SyntaxList of SyntaxToken representing the commas in the implicit array creation expression.</summary>
    public Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SyntaxToken> Commas { get { return new Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SyntaxToken>(this.commas); } }
    /// <summary>SyntaxToken representing the close bracket.</summary>
    public SyntaxToken CloseBracketToken { get { return this.closeBracketToken; } }
    /// <summary>InitializerExpressionSyntax representing the initializer expression of the implicit array creation expression.</summary>
    public InitializerExpressionSyntax Initializer { get { return this.initializer; } }

    internal override GreenNode GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.newKeyword;
            case 1: return this.openBracketToken;
            case 2: return this.commas;
            case 3: return this.closeBracketToken;
            case 4: return this.initializer;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode parent, int position)
    {
      return new CSharp.Syntax.ImplicitArrayCreationExpressionSyntax(this, parent, position);
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitImplicitArrayCreationExpression(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitImplicitArrayCreationExpression(this);
    }

    public ImplicitArrayCreationExpressionSyntax Update(SyntaxToken newKeyword, SyntaxToken openBracketToken, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SyntaxToken> commas, SyntaxToken closeBracketToken, InitializerExpressionSyntax initializer)
    {
        if (newKeyword != this.NewKeyword || openBracketToken != this.OpenBracketToken || commas != this.Commas || closeBracketToken != this.CloseBracketToken || initializer != this.Initializer)
        {
            var newNode = SyntaxFactory.ImplicitArrayCreationExpression(newKeyword, openBracketToken, commas, closeBracketToken, initializer);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
    {
         return new ImplicitArrayCreationExpressionSyntax(this.Kind, this.newKeyword, this.openBracketToken, this.commas, this.closeBracketToken, this.initializer, diagnostics, GetAnnotations());
    }

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
    {
         return new ImplicitArrayCreationExpressionSyntax(this.Kind, this.newKeyword, this.openBracketToken, this.commas, this.closeBracketToken, this.initializer, GetDiagnostics(), annotations);
    }

    internal ImplicitArrayCreationExpressionSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 5;
      var newKeyword = (SyntaxToken)reader.ReadValue();
      if (newKeyword != null)
      {
         AdjustFlagsAndWidth(newKeyword);
         this.newKeyword = newKeyword;
      }
      var openBracketToken = (SyntaxToken)reader.ReadValue();
      if (openBracketToken != null)
      {
         AdjustFlagsAndWidth(openBracketToken);
         this.openBracketToken = openBracketToken;
      }
      var commas = (GreenNode)reader.ReadValue();
      if (commas != null)
      {
         AdjustFlagsAndWidth(commas);
         this.commas = commas;
      }
      var closeBracketToken = (SyntaxToken)reader.ReadValue();
      if (closeBracketToken != null)
      {
         AdjustFlagsAndWidth(closeBracketToken);
         this.closeBracketToken = closeBracketToken;
      }
      var initializer = (InitializerExpressionSyntax)reader.ReadValue();
      if (initializer != null)
      {
         AdjustFlagsAndWidth(initializer);
         this.initializer = initializer;
      }
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.newKeyword);
      writer.WriteValue(this.openBracketToken);
      writer.WriteValue(this.commas);
      writer.WriteValue(this.closeBracketToken);
      writer.WriteValue(this.initializer);
    }

    static ImplicitArrayCreationExpressionSyntax()
    {
       ObjectBinder.RegisterTypeReader(typeof(ImplicitArrayCreationExpressionSyntax), r => new ImplicitArrayCreationExpressionSyntax(r));
    }
  }

  /// <summary>Class which represents the syntax node for stackalloc array creation expression.</summary>
  internal sealed partial class StackAllocArrayCreationExpressionSyntax : ExpressionSyntax
  {
    internal readonly SyntaxToken stackAllocKeyword;
    internal readonly TypeSyntax type;

    internal StackAllocArrayCreationExpressionSyntax(SyntaxKind kind, SyntaxToken stackAllocKeyword, TypeSyntax type, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 2;
        this.AdjustFlagsAndWidth(stackAllocKeyword);
        this.stackAllocKeyword = stackAllocKeyword;
        this.AdjustFlagsAndWidth(type);
        this.type = type;
    }


    internal StackAllocArrayCreationExpressionSyntax(SyntaxKind kind, SyntaxToken stackAllocKeyword, TypeSyntax type, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 2;
        this.AdjustFlagsAndWidth(stackAllocKeyword);
        this.stackAllocKeyword = stackAllocKeyword;
        this.AdjustFlagsAndWidth(type);
        this.type = type;
    }


    internal StackAllocArrayCreationExpressionSyntax(SyntaxKind kind, SyntaxToken stackAllocKeyword, TypeSyntax type)
        : base(kind)
    {
        this.SlotCount = 2;
        this.AdjustFlagsAndWidth(stackAllocKeyword);
        this.stackAllocKeyword = stackAllocKeyword;
        this.AdjustFlagsAndWidth(type);
        this.type = type;
    }

    /// <summary>SyntaxToken representing the stackalloc keyword.</summary>
    public SyntaxToken StackAllocKeyword { get { return this.stackAllocKeyword; } }
    /// <summary>TypeSyntax node representing the type of the stackalloc array.</summary>
    public TypeSyntax Type { get { return this.type; } }

    internal override GreenNode GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.stackAllocKeyword;
            case 1: return this.type;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode parent, int position)
    {
      return new CSharp.Syntax.StackAllocArrayCreationExpressionSyntax(this, parent, position);
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitStackAllocArrayCreationExpression(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitStackAllocArrayCreationExpression(this);
    }

    public StackAllocArrayCreationExpressionSyntax Update(SyntaxToken stackAllocKeyword, TypeSyntax type)
    {
        if (stackAllocKeyword != this.StackAllocKeyword || type != this.Type)
        {
            var newNode = SyntaxFactory.StackAllocArrayCreationExpression(stackAllocKeyword, type);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
    {
         return new StackAllocArrayCreationExpressionSyntax(this.Kind, this.stackAllocKeyword, this.type, diagnostics, GetAnnotations());
    }

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
    {
         return new StackAllocArrayCreationExpressionSyntax(this.Kind, this.stackAllocKeyword, this.type, GetDiagnostics(), annotations);
    }

    internal StackAllocArrayCreationExpressionSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 2;
      var stackAllocKeyword = (SyntaxToken)reader.ReadValue();
      if (stackAllocKeyword != null)
      {
         AdjustFlagsAndWidth(stackAllocKeyword);
         this.stackAllocKeyword = stackAllocKeyword;
      }
      var type = (TypeSyntax)reader.ReadValue();
      if (type != null)
      {
         AdjustFlagsAndWidth(type);
         this.type = type;
      }
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.stackAllocKeyword);
      writer.WriteValue(this.type);
    }

    static StackAllocArrayCreationExpressionSyntax()
    {
       ObjectBinder.RegisterTypeReader(typeof(StackAllocArrayCreationExpressionSyntax), r => new StackAllocArrayCreationExpressionSyntax(r));
    }
  }

  internal abstract partial class QueryClauseSyntax : CSharpSyntaxNode
  {
    internal QueryClauseSyntax(SyntaxKind kind, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
      : base(kind, diagnostics, annotations)
    {
    }
    internal QueryClauseSyntax(SyntaxKind kind)
      : base(kind)
    {
    }

    protected QueryClauseSyntax(ObjectReader reader)
       : base(reader)
    {
    }
  }

  internal abstract partial class SelectOrGroupClauseSyntax : CSharpSyntaxNode
  {
    internal SelectOrGroupClauseSyntax(SyntaxKind kind, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
      : base(kind, diagnostics, annotations)
    {
    }
    internal SelectOrGroupClauseSyntax(SyntaxKind kind)
      : base(kind)
    {
    }

    protected SelectOrGroupClauseSyntax(ObjectReader reader)
       : base(reader)
    {
    }
  }

  internal sealed partial class QueryExpressionSyntax : ExpressionSyntax
  {
    internal readonly FromClauseSyntax fromClause;
    internal readonly QueryBodySyntax body;

    internal QueryExpressionSyntax(SyntaxKind kind, FromClauseSyntax fromClause, QueryBodySyntax body, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 2;
        this.AdjustFlagsAndWidth(fromClause);
        this.fromClause = fromClause;
        this.AdjustFlagsAndWidth(body);
        this.body = body;
    }


    internal QueryExpressionSyntax(SyntaxKind kind, FromClauseSyntax fromClause, QueryBodySyntax body, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 2;
        this.AdjustFlagsAndWidth(fromClause);
        this.fromClause = fromClause;
        this.AdjustFlagsAndWidth(body);
        this.body = body;
    }


    internal QueryExpressionSyntax(SyntaxKind kind, FromClauseSyntax fromClause, QueryBodySyntax body)
        : base(kind)
    {
        this.SlotCount = 2;
        this.AdjustFlagsAndWidth(fromClause);
        this.fromClause = fromClause;
        this.AdjustFlagsAndWidth(body);
        this.body = body;
    }

    public FromClauseSyntax FromClause { get { return this.fromClause; } }
    public QueryBodySyntax Body { get { return this.body; } }

    internal override GreenNode GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.fromClause;
            case 1: return this.body;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode parent, int position)
    {
      return new CSharp.Syntax.QueryExpressionSyntax(this, parent, position);
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitQueryExpression(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitQueryExpression(this);
    }

    public QueryExpressionSyntax Update(FromClauseSyntax fromClause, QueryBodySyntax body)
    {
        if (fromClause != this.FromClause || body != this.Body)
        {
            var newNode = SyntaxFactory.QueryExpression(fromClause, body);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
    {
         return new QueryExpressionSyntax(this.Kind, this.fromClause, this.body, diagnostics, GetAnnotations());
    }

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
    {
         return new QueryExpressionSyntax(this.Kind, this.fromClause, this.body, GetDiagnostics(), annotations);
    }

    internal QueryExpressionSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 2;
      var fromClause = (FromClauseSyntax)reader.ReadValue();
      if (fromClause != null)
      {
         AdjustFlagsAndWidth(fromClause);
         this.fromClause = fromClause;
      }
      var body = (QueryBodySyntax)reader.ReadValue();
      if (body != null)
      {
         AdjustFlagsAndWidth(body);
         this.body = body;
      }
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.fromClause);
      writer.WriteValue(this.body);
    }

    static QueryExpressionSyntax()
    {
       ObjectBinder.RegisterTypeReader(typeof(QueryExpressionSyntax), r => new QueryExpressionSyntax(r));
    }
  }

  internal sealed partial class QueryBodySyntax : CSharpSyntaxNode
  {
    internal readonly GreenNode clauses;
    internal readonly SelectOrGroupClauseSyntax selectOrGroup;
    internal readonly QueryContinuationSyntax continuation;

    internal QueryBodySyntax(SyntaxKind kind, GreenNode clauses, SelectOrGroupClauseSyntax selectOrGroup, QueryContinuationSyntax continuation, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 3;
        if (clauses != null)
        {
            this.AdjustFlagsAndWidth(clauses);
            this.clauses = clauses;
        }
        this.AdjustFlagsAndWidth(selectOrGroup);
        this.selectOrGroup = selectOrGroup;
        if (continuation != null)
        {
            this.AdjustFlagsAndWidth(continuation);
            this.continuation = continuation;
        }
    }


    internal QueryBodySyntax(SyntaxKind kind, GreenNode clauses, SelectOrGroupClauseSyntax selectOrGroup, QueryContinuationSyntax continuation, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 3;
        if (clauses != null)
        {
            this.AdjustFlagsAndWidth(clauses);
            this.clauses = clauses;
        }
        this.AdjustFlagsAndWidth(selectOrGroup);
        this.selectOrGroup = selectOrGroup;
        if (continuation != null)
        {
            this.AdjustFlagsAndWidth(continuation);
            this.continuation = continuation;
        }
    }


    internal QueryBodySyntax(SyntaxKind kind, GreenNode clauses, SelectOrGroupClauseSyntax selectOrGroup, QueryContinuationSyntax continuation)
        : base(kind)
    {
        this.SlotCount = 3;
        if (clauses != null)
        {
            this.AdjustFlagsAndWidth(clauses);
            this.clauses = clauses;
        }
        this.AdjustFlagsAndWidth(selectOrGroup);
        this.selectOrGroup = selectOrGroup;
        if (continuation != null)
        {
            this.AdjustFlagsAndWidth(continuation);
            this.continuation = continuation;
        }
    }

    public Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<QueryClauseSyntax> Clauses { get { return new Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<QueryClauseSyntax>(this.clauses); } }
    public SelectOrGroupClauseSyntax SelectOrGroup { get { return this.selectOrGroup; } }
    public QueryContinuationSyntax Continuation { get { return this.continuation; } }

    internal override GreenNode GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.clauses;
            case 1: return this.selectOrGroup;
            case 2: return this.continuation;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode parent, int position)
    {
      return new CSharp.Syntax.QueryBodySyntax(this, parent, position);
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitQueryBody(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitQueryBody(this);
    }

    public QueryBodySyntax Update(Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<QueryClauseSyntax> clauses, SelectOrGroupClauseSyntax selectOrGroup, QueryContinuationSyntax continuation)
    {
        if (clauses != this.Clauses || selectOrGroup != this.SelectOrGroup || continuation != this.Continuation)
        {
            var newNode = SyntaxFactory.QueryBody(clauses, selectOrGroup, continuation);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
    {
         return new QueryBodySyntax(this.Kind, this.clauses, this.selectOrGroup, this.continuation, diagnostics, GetAnnotations());
    }

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
    {
         return new QueryBodySyntax(this.Kind, this.clauses, this.selectOrGroup, this.continuation, GetDiagnostics(), annotations);
    }

    internal QueryBodySyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 3;
      var clauses = (GreenNode)reader.ReadValue();
      if (clauses != null)
      {
         AdjustFlagsAndWidth(clauses);
         this.clauses = clauses;
      }
      var selectOrGroup = (SelectOrGroupClauseSyntax)reader.ReadValue();
      if (selectOrGroup != null)
      {
         AdjustFlagsAndWidth(selectOrGroup);
         this.selectOrGroup = selectOrGroup;
      }
      var continuation = (QueryContinuationSyntax)reader.ReadValue();
      if (continuation != null)
      {
         AdjustFlagsAndWidth(continuation);
         this.continuation = continuation;
      }
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.clauses);
      writer.WriteValue(this.selectOrGroup);
      writer.WriteValue(this.continuation);
    }

    static QueryBodySyntax()
    {
       ObjectBinder.RegisterTypeReader(typeof(QueryBodySyntax), r => new QueryBodySyntax(r));
    }
  }

  internal sealed partial class FromClauseSyntax : QueryClauseSyntax
  {
    internal readonly SyntaxToken fromKeyword;
    internal readonly TypeSyntax type;
    internal readonly SyntaxToken identifier;
    internal readonly SyntaxToken inKeyword;
    internal readonly ExpressionSyntax expression;

    internal FromClauseSyntax(SyntaxKind kind, SyntaxToken fromKeyword, TypeSyntax type, SyntaxToken identifier, SyntaxToken inKeyword, ExpressionSyntax expression, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 5;
        this.AdjustFlagsAndWidth(fromKeyword);
        this.fromKeyword = fromKeyword;
        if (type != null)
        {
            this.AdjustFlagsAndWidth(type);
            this.type = type;
        }
        this.AdjustFlagsAndWidth(identifier);
        this.identifier = identifier;
        this.AdjustFlagsAndWidth(inKeyword);
        this.inKeyword = inKeyword;
        this.AdjustFlagsAndWidth(expression);
        this.expression = expression;
    }


    internal FromClauseSyntax(SyntaxKind kind, SyntaxToken fromKeyword, TypeSyntax type, SyntaxToken identifier, SyntaxToken inKeyword, ExpressionSyntax expression, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 5;
        this.AdjustFlagsAndWidth(fromKeyword);
        this.fromKeyword = fromKeyword;
        if (type != null)
        {
            this.AdjustFlagsAndWidth(type);
            this.type = type;
        }
        this.AdjustFlagsAndWidth(identifier);
        this.identifier = identifier;
        this.AdjustFlagsAndWidth(inKeyword);
        this.inKeyword = inKeyword;
        this.AdjustFlagsAndWidth(expression);
        this.expression = expression;
    }


    internal FromClauseSyntax(SyntaxKind kind, SyntaxToken fromKeyword, TypeSyntax type, SyntaxToken identifier, SyntaxToken inKeyword, ExpressionSyntax expression)
        : base(kind)
    {
        this.SlotCount = 5;
        this.AdjustFlagsAndWidth(fromKeyword);
        this.fromKeyword = fromKeyword;
        if (type != null)
        {
            this.AdjustFlagsAndWidth(type);
            this.type = type;
        }
        this.AdjustFlagsAndWidth(identifier);
        this.identifier = identifier;
        this.AdjustFlagsAndWidth(inKeyword);
        this.inKeyword = inKeyword;
        this.AdjustFlagsAndWidth(expression);
        this.expression = expression;
    }

    public SyntaxToken FromKeyword { get { return this.fromKeyword; } }
    public TypeSyntax Type { get { return this.type; } }
    /// <summary>Gets the identifier.</summary>
    public SyntaxToken Identifier { get { return this.identifier; } }
    public SyntaxToken InKeyword { get { return this.inKeyword; } }
    public ExpressionSyntax Expression { get { return this.expression; } }

    internal override GreenNode GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.fromKeyword;
            case 1: return this.type;
            case 2: return this.identifier;
            case 3: return this.inKeyword;
            case 4: return this.expression;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode parent, int position)
    {
      return new CSharp.Syntax.FromClauseSyntax(this, parent, position);
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitFromClause(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitFromClause(this);
    }

    public FromClauseSyntax Update(SyntaxToken fromKeyword, TypeSyntax type, SyntaxToken identifier, SyntaxToken inKeyword, ExpressionSyntax expression)
    {
        if (fromKeyword != this.FromKeyword || type != this.Type || identifier != this.Identifier || inKeyword != this.InKeyword || expression != this.Expression)
        {
            var newNode = SyntaxFactory.FromClause(fromKeyword, type, identifier, inKeyword, expression);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
    {
         return new FromClauseSyntax(this.Kind, this.fromKeyword, this.type, this.identifier, this.inKeyword, this.expression, diagnostics, GetAnnotations());
    }

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
    {
         return new FromClauseSyntax(this.Kind, this.fromKeyword, this.type, this.identifier, this.inKeyword, this.expression, GetDiagnostics(), annotations);
    }

    internal FromClauseSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 5;
      var fromKeyword = (SyntaxToken)reader.ReadValue();
      if (fromKeyword != null)
      {
         AdjustFlagsAndWidth(fromKeyword);
         this.fromKeyword = fromKeyword;
      }
      var type = (TypeSyntax)reader.ReadValue();
      if (type != null)
      {
         AdjustFlagsAndWidth(type);
         this.type = type;
      }
      var identifier = (SyntaxToken)reader.ReadValue();
      if (identifier != null)
      {
         AdjustFlagsAndWidth(identifier);
         this.identifier = identifier;
      }
      var inKeyword = (SyntaxToken)reader.ReadValue();
      if (inKeyword != null)
      {
         AdjustFlagsAndWidth(inKeyword);
         this.inKeyword = inKeyword;
      }
      var expression = (ExpressionSyntax)reader.ReadValue();
      if (expression != null)
      {
         AdjustFlagsAndWidth(expression);
         this.expression = expression;
      }
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.fromKeyword);
      writer.WriteValue(this.type);
      writer.WriteValue(this.identifier);
      writer.WriteValue(this.inKeyword);
      writer.WriteValue(this.expression);
    }

    static FromClauseSyntax()
    {
       ObjectBinder.RegisterTypeReader(typeof(FromClauseSyntax), r => new FromClauseSyntax(r));
    }
  }

  internal sealed partial class LetClauseSyntax : QueryClauseSyntax
  {
    internal readonly SyntaxToken letKeyword;
    internal readonly SyntaxToken identifier;
    internal readonly SyntaxToken equalsToken;
    internal readonly ExpressionSyntax expression;

    internal LetClauseSyntax(SyntaxKind kind, SyntaxToken letKeyword, SyntaxToken identifier, SyntaxToken equalsToken, ExpressionSyntax expression, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 4;
        this.AdjustFlagsAndWidth(letKeyword);
        this.letKeyword = letKeyword;
        this.AdjustFlagsAndWidth(identifier);
        this.identifier = identifier;
        this.AdjustFlagsAndWidth(equalsToken);
        this.equalsToken = equalsToken;
        this.AdjustFlagsAndWidth(expression);
        this.expression = expression;
    }


    internal LetClauseSyntax(SyntaxKind kind, SyntaxToken letKeyword, SyntaxToken identifier, SyntaxToken equalsToken, ExpressionSyntax expression, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 4;
        this.AdjustFlagsAndWidth(letKeyword);
        this.letKeyword = letKeyword;
        this.AdjustFlagsAndWidth(identifier);
        this.identifier = identifier;
        this.AdjustFlagsAndWidth(equalsToken);
        this.equalsToken = equalsToken;
        this.AdjustFlagsAndWidth(expression);
        this.expression = expression;
    }


    internal LetClauseSyntax(SyntaxKind kind, SyntaxToken letKeyword, SyntaxToken identifier, SyntaxToken equalsToken, ExpressionSyntax expression)
        : base(kind)
    {
        this.SlotCount = 4;
        this.AdjustFlagsAndWidth(letKeyword);
        this.letKeyword = letKeyword;
        this.AdjustFlagsAndWidth(identifier);
        this.identifier = identifier;
        this.AdjustFlagsAndWidth(equalsToken);
        this.equalsToken = equalsToken;
        this.AdjustFlagsAndWidth(expression);
        this.expression = expression;
    }

    public SyntaxToken LetKeyword { get { return this.letKeyword; } }
    /// <summary>Gets the identifier.</summary>
    public SyntaxToken Identifier { get { return this.identifier; } }
    public SyntaxToken EqualsToken { get { return this.equalsToken; } }
    public ExpressionSyntax Expression { get { return this.expression; } }

    internal override GreenNode GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.letKeyword;
            case 1: return this.identifier;
            case 2: return this.equalsToken;
            case 3: return this.expression;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode parent, int position)
    {
      return new CSharp.Syntax.LetClauseSyntax(this, parent, position);
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitLetClause(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitLetClause(this);
    }

    public LetClauseSyntax Update(SyntaxToken letKeyword, SyntaxToken identifier, SyntaxToken equalsToken, ExpressionSyntax expression)
    {
        if (letKeyword != this.LetKeyword || identifier != this.Identifier || equalsToken != this.EqualsToken || expression != this.Expression)
        {
            var newNode = SyntaxFactory.LetClause(letKeyword, identifier, equalsToken, expression);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
    {
         return new LetClauseSyntax(this.Kind, this.letKeyword, this.identifier, this.equalsToken, this.expression, diagnostics, GetAnnotations());
    }

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
    {
         return new LetClauseSyntax(this.Kind, this.letKeyword, this.identifier, this.equalsToken, this.expression, GetDiagnostics(), annotations);
    }

    internal LetClauseSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 4;
      var letKeyword = (SyntaxToken)reader.ReadValue();
      if (letKeyword != null)
      {
         AdjustFlagsAndWidth(letKeyword);
         this.letKeyword = letKeyword;
      }
      var identifier = (SyntaxToken)reader.ReadValue();
      if (identifier != null)
      {
         AdjustFlagsAndWidth(identifier);
         this.identifier = identifier;
      }
      var equalsToken = (SyntaxToken)reader.ReadValue();
      if (equalsToken != null)
      {
         AdjustFlagsAndWidth(equalsToken);
         this.equalsToken = equalsToken;
      }
      var expression = (ExpressionSyntax)reader.ReadValue();
      if (expression != null)
      {
         AdjustFlagsAndWidth(expression);
         this.expression = expression;
      }
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.letKeyword);
      writer.WriteValue(this.identifier);
      writer.WriteValue(this.equalsToken);
      writer.WriteValue(this.expression);
    }

    static LetClauseSyntax()
    {
       ObjectBinder.RegisterTypeReader(typeof(LetClauseSyntax), r => new LetClauseSyntax(r));
    }
  }

  internal sealed partial class JoinClauseSyntax : QueryClauseSyntax
  {
    internal readonly SyntaxToken joinKeyword;
    internal readonly TypeSyntax type;
    internal readonly SyntaxToken identifier;
    internal readonly SyntaxToken inKeyword;
    internal readonly ExpressionSyntax inExpression;
    internal readonly SyntaxToken onKeyword;
    internal readonly ExpressionSyntax leftExpression;
    internal readonly SyntaxToken equalsKeyword;
    internal readonly ExpressionSyntax rightExpression;
    internal readonly JoinIntoClauseSyntax into;

    internal JoinClauseSyntax(SyntaxKind kind, SyntaxToken joinKeyword, TypeSyntax type, SyntaxToken identifier, SyntaxToken inKeyword, ExpressionSyntax inExpression, SyntaxToken onKeyword, ExpressionSyntax leftExpression, SyntaxToken equalsKeyword, ExpressionSyntax rightExpression, JoinIntoClauseSyntax into, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 10;
        this.AdjustFlagsAndWidth(joinKeyword);
        this.joinKeyword = joinKeyword;
        if (type != null)
        {
            this.AdjustFlagsAndWidth(type);
            this.type = type;
        }
        this.AdjustFlagsAndWidth(identifier);
        this.identifier = identifier;
        this.AdjustFlagsAndWidth(inKeyword);
        this.inKeyword = inKeyword;
        this.AdjustFlagsAndWidth(inExpression);
        this.inExpression = inExpression;
        this.AdjustFlagsAndWidth(onKeyword);
        this.onKeyword = onKeyword;
        this.AdjustFlagsAndWidth(leftExpression);
        this.leftExpression = leftExpression;
        this.AdjustFlagsAndWidth(equalsKeyword);
        this.equalsKeyword = equalsKeyword;
        this.AdjustFlagsAndWidth(rightExpression);
        this.rightExpression = rightExpression;
        if (into != null)
        {
            this.AdjustFlagsAndWidth(into);
            this.into = into;
        }
    }


    internal JoinClauseSyntax(SyntaxKind kind, SyntaxToken joinKeyword, TypeSyntax type, SyntaxToken identifier, SyntaxToken inKeyword, ExpressionSyntax inExpression, SyntaxToken onKeyword, ExpressionSyntax leftExpression, SyntaxToken equalsKeyword, ExpressionSyntax rightExpression, JoinIntoClauseSyntax into, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 10;
        this.AdjustFlagsAndWidth(joinKeyword);
        this.joinKeyword = joinKeyword;
        if (type != null)
        {
            this.AdjustFlagsAndWidth(type);
            this.type = type;
        }
        this.AdjustFlagsAndWidth(identifier);
        this.identifier = identifier;
        this.AdjustFlagsAndWidth(inKeyword);
        this.inKeyword = inKeyword;
        this.AdjustFlagsAndWidth(inExpression);
        this.inExpression = inExpression;
        this.AdjustFlagsAndWidth(onKeyword);
        this.onKeyword = onKeyword;
        this.AdjustFlagsAndWidth(leftExpression);
        this.leftExpression = leftExpression;
        this.AdjustFlagsAndWidth(equalsKeyword);
        this.equalsKeyword = equalsKeyword;
        this.AdjustFlagsAndWidth(rightExpression);
        this.rightExpression = rightExpression;
        if (into != null)
        {
            this.AdjustFlagsAndWidth(into);
            this.into = into;
        }
    }


    internal JoinClauseSyntax(SyntaxKind kind, SyntaxToken joinKeyword, TypeSyntax type, SyntaxToken identifier, SyntaxToken inKeyword, ExpressionSyntax inExpression, SyntaxToken onKeyword, ExpressionSyntax leftExpression, SyntaxToken equalsKeyword, ExpressionSyntax rightExpression, JoinIntoClauseSyntax into)
        : base(kind)
    {
        this.SlotCount = 10;
        this.AdjustFlagsAndWidth(joinKeyword);
        this.joinKeyword = joinKeyword;
        if (type != null)
        {
            this.AdjustFlagsAndWidth(type);
            this.type = type;
        }
        this.AdjustFlagsAndWidth(identifier);
        this.identifier = identifier;
        this.AdjustFlagsAndWidth(inKeyword);
        this.inKeyword = inKeyword;
        this.AdjustFlagsAndWidth(inExpression);
        this.inExpression = inExpression;
        this.AdjustFlagsAndWidth(onKeyword);
        this.onKeyword = onKeyword;
        this.AdjustFlagsAndWidth(leftExpression);
        this.leftExpression = leftExpression;
        this.AdjustFlagsAndWidth(equalsKeyword);
        this.equalsKeyword = equalsKeyword;
        this.AdjustFlagsAndWidth(rightExpression);
        this.rightExpression = rightExpression;
        if (into != null)
        {
            this.AdjustFlagsAndWidth(into);
            this.into = into;
        }
    }

    public SyntaxToken JoinKeyword { get { return this.joinKeyword; } }
    public TypeSyntax Type { get { return this.type; } }
    /// <summary>Gets the identifier.</summary>
    public SyntaxToken Identifier { get { return this.identifier; } }
    public SyntaxToken InKeyword { get { return this.inKeyword; } }
    public ExpressionSyntax InExpression { get { return this.inExpression; } }
    public SyntaxToken OnKeyword { get { return this.onKeyword; } }
    public ExpressionSyntax LeftExpression { get { return this.leftExpression; } }
    public SyntaxToken EqualsKeyword { get { return this.equalsKeyword; } }
    public ExpressionSyntax RightExpression { get { return this.rightExpression; } }
    public JoinIntoClauseSyntax Into { get { return this.into; } }

    internal override GreenNode GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.joinKeyword;
            case 1: return this.type;
            case 2: return this.identifier;
            case 3: return this.inKeyword;
            case 4: return this.inExpression;
            case 5: return this.onKeyword;
            case 6: return this.leftExpression;
            case 7: return this.equalsKeyword;
            case 8: return this.rightExpression;
            case 9: return this.into;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode parent, int position)
    {
      return new CSharp.Syntax.JoinClauseSyntax(this, parent, position);
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitJoinClause(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitJoinClause(this);
    }

    public JoinClauseSyntax Update(SyntaxToken joinKeyword, TypeSyntax type, SyntaxToken identifier, SyntaxToken inKeyword, ExpressionSyntax inExpression, SyntaxToken onKeyword, ExpressionSyntax leftExpression, SyntaxToken equalsKeyword, ExpressionSyntax rightExpression, JoinIntoClauseSyntax into)
    {
        if (joinKeyword != this.JoinKeyword || type != this.Type || identifier != this.Identifier || inKeyword != this.InKeyword || inExpression != this.InExpression || onKeyword != this.OnKeyword || leftExpression != this.LeftExpression || equalsKeyword != this.EqualsKeyword || rightExpression != this.RightExpression || into != this.Into)
        {
            var newNode = SyntaxFactory.JoinClause(joinKeyword, type, identifier, inKeyword, inExpression, onKeyword, leftExpression, equalsKeyword, rightExpression, into);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
    {
         return new JoinClauseSyntax(this.Kind, this.joinKeyword, this.type, this.identifier, this.inKeyword, this.inExpression, this.onKeyword, this.leftExpression, this.equalsKeyword, this.rightExpression, this.into, diagnostics, GetAnnotations());
    }

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
    {
         return new JoinClauseSyntax(this.Kind, this.joinKeyword, this.type, this.identifier, this.inKeyword, this.inExpression, this.onKeyword, this.leftExpression, this.equalsKeyword, this.rightExpression, this.into, GetDiagnostics(), annotations);
    }

    internal JoinClauseSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 10;
      var joinKeyword = (SyntaxToken)reader.ReadValue();
      if (joinKeyword != null)
      {
         AdjustFlagsAndWidth(joinKeyword);
         this.joinKeyword = joinKeyword;
      }
      var type = (TypeSyntax)reader.ReadValue();
      if (type != null)
      {
         AdjustFlagsAndWidth(type);
         this.type = type;
      }
      var identifier = (SyntaxToken)reader.ReadValue();
      if (identifier != null)
      {
         AdjustFlagsAndWidth(identifier);
         this.identifier = identifier;
      }
      var inKeyword = (SyntaxToken)reader.ReadValue();
      if (inKeyword != null)
      {
         AdjustFlagsAndWidth(inKeyword);
         this.inKeyword = inKeyword;
      }
      var inExpression = (ExpressionSyntax)reader.ReadValue();
      if (inExpression != null)
      {
         AdjustFlagsAndWidth(inExpression);
         this.inExpression = inExpression;
      }
      var onKeyword = (SyntaxToken)reader.ReadValue();
      if (onKeyword != null)
      {
         AdjustFlagsAndWidth(onKeyword);
         this.onKeyword = onKeyword;
      }
      var leftExpression = (ExpressionSyntax)reader.ReadValue();
      if (leftExpression != null)
      {
         AdjustFlagsAndWidth(leftExpression);
         this.leftExpression = leftExpression;
      }
      var equalsKeyword = (SyntaxToken)reader.ReadValue();
      if (equalsKeyword != null)
      {
         AdjustFlagsAndWidth(equalsKeyword);
         this.equalsKeyword = equalsKeyword;
      }
      var rightExpression = (ExpressionSyntax)reader.ReadValue();
      if (rightExpression != null)
      {
         AdjustFlagsAndWidth(rightExpression);
         this.rightExpression = rightExpression;
      }
      var into = (JoinIntoClauseSyntax)reader.ReadValue();
      if (into != null)
      {
         AdjustFlagsAndWidth(into);
         this.into = into;
      }
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.joinKeyword);
      writer.WriteValue(this.type);
      writer.WriteValue(this.identifier);
      writer.WriteValue(this.inKeyword);
      writer.WriteValue(this.inExpression);
      writer.WriteValue(this.onKeyword);
      writer.WriteValue(this.leftExpression);
      writer.WriteValue(this.equalsKeyword);
      writer.WriteValue(this.rightExpression);
      writer.WriteValue(this.into);
    }

    static JoinClauseSyntax()
    {
       ObjectBinder.RegisterTypeReader(typeof(JoinClauseSyntax), r => new JoinClauseSyntax(r));
    }
  }

  internal sealed partial class JoinIntoClauseSyntax : CSharpSyntaxNode
  {
    internal readonly SyntaxToken intoKeyword;
    internal readonly SyntaxToken identifier;

    internal JoinIntoClauseSyntax(SyntaxKind kind, SyntaxToken intoKeyword, SyntaxToken identifier, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 2;
        this.AdjustFlagsAndWidth(intoKeyword);
        this.intoKeyword = intoKeyword;
        this.AdjustFlagsAndWidth(identifier);
        this.identifier = identifier;
    }


    internal JoinIntoClauseSyntax(SyntaxKind kind, SyntaxToken intoKeyword, SyntaxToken identifier, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 2;
        this.AdjustFlagsAndWidth(intoKeyword);
        this.intoKeyword = intoKeyword;
        this.AdjustFlagsAndWidth(identifier);
        this.identifier = identifier;
    }


    internal JoinIntoClauseSyntax(SyntaxKind kind, SyntaxToken intoKeyword, SyntaxToken identifier)
        : base(kind)
    {
        this.SlotCount = 2;
        this.AdjustFlagsAndWidth(intoKeyword);
        this.intoKeyword = intoKeyword;
        this.AdjustFlagsAndWidth(identifier);
        this.identifier = identifier;
    }

    public SyntaxToken IntoKeyword { get { return this.intoKeyword; } }
    /// <summary>Gets the identifier.</summary>
    public SyntaxToken Identifier { get { return this.identifier; } }

    internal override GreenNode GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.intoKeyword;
            case 1: return this.identifier;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode parent, int position)
    {
      return new CSharp.Syntax.JoinIntoClauseSyntax(this, parent, position);
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitJoinIntoClause(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitJoinIntoClause(this);
    }

    public JoinIntoClauseSyntax Update(SyntaxToken intoKeyword, SyntaxToken identifier)
    {
        if (intoKeyword != this.IntoKeyword || identifier != this.Identifier)
        {
            var newNode = SyntaxFactory.JoinIntoClause(intoKeyword, identifier);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
    {
         return new JoinIntoClauseSyntax(this.Kind, this.intoKeyword, this.identifier, diagnostics, GetAnnotations());
    }

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
    {
         return new JoinIntoClauseSyntax(this.Kind, this.intoKeyword, this.identifier, GetDiagnostics(), annotations);
    }

    internal JoinIntoClauseSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 2;
      var intoKeyword = (SyntaxToken)reader.ReadValue();
      if (intoKeyword != null)
      {
         AdjustFlagsAndWidth(intoKeyword);
         this.intoKeyword = intoKeyword;
      }
      var identifier = (SyntaxToken)reader.ReadValue();
      if (identifier != null)
      {
         AdjustFlagsAndWidth(identifier);
         this.identifier = identifier;
      }
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.intoKeyword);
      writer.WriteValue(this.identifier);
    }

    static JoinIntoClauseSyntax()
    {
       ObjectBinder.RegisterTypeReader(typeof(JoinIntoClauseSyntax), r => new JoinIntoClauseSyntax(r));
    }
  }

  internal sealed partial class WhereClauseSyntax : QueryClauseSyntax
  {
    internal readonly SyntaxToken whereKeyword;
    internal readonly ExpressionSyntax condition;

    internal WhereClauseSyntax(SyntaxKind kind, SyntaxToken whereKeyword, ExpressionSyntax condition, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 2;
        this.AdjustFlagsAndWidth(whereKeyword);
        this.whereKeyword = whereKeyword;
        this.AdjustFlagsAndWidth(condition);
        this.condition = condition;
    }


    internal WhereClauseSyntax(SyntaxKind kind, SyntaxToken whereKeyword, ExpressionSyntax condition, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 2;
        this.AdjustFlagsAndWidth(whereKeyword);
        this.whereKeyword = whereKeyword;
        this.AdjustFlagsAndWidth(condition);
        this.condition = condition;
    }


    internal WhereClauseSyntax(SyntaxKind kind, SyntaxToken whereKeyword, ExpressionSyntax condition)
        : base(kind)
    {
        this.SlotCount = 2;
        this.AdjustFlagsAndWidth(whereKeyword);
        this.whereKeyword = whereKeyword;
        this.AdjustFlagsAndWidth(condition);
        this.condition = condition;
    }

    public SyntaxToken WhereKeyword { get { return this.whereKeyword; } }
    public ExpressionSyntax Condition { get { return this.condition; } }

    internal override GreenNode GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.whereKeyword;
            case 1: return this.condition;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode parent, int position)
    {
      return new CSharp.Syntax.WhereClauseSyntax(this, parent, position);
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitWhereClause(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitWhereClause(this);
    }

    public WhereClauseSyntax Update(SyntaxToken whereKeyword, ExpressionSyntax condition)
    {
        if (whereKeyword != this.WhereKeyword || condition != this.Condition)
        {
            var newNode = SyntaxFactory.WhereClause(whereKeyword, condition);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
    {
         return new WhereClauseSyntax(this.Kind, this.whereKeyword, this.condition, diagnostics, GetAnnotations());
    }

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
    {
         return new WhereClauseSyntax(this.Kind, this.whereKeyword, this.condition, GetDiagnostics(), annotations);
    }

    internal WhereClauseSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 2;
      var whereKeyword = (SyntaxToken)reader.ReadValue();
      if (whereKeyword != null)
      {
         AdjustFlagsAndWidth(whereKeyword);
         this.whereKeyword = whereKeyword;
      }
      var condition = (ExpressionSyntax)reader.ReadValue();
      if (condition != null)
      {
         AdjustFlagsAndWidth(condition);
         this.condition = condition;
      }
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.whereKeyword);
      writer.WriteValue(this.condition);
    }

    static WhereClauseSyntax()
    {
       ObjectBinder.RegisterTypeReader(typeof(WhereClauseSyntax), r => new WhereClauseSyntax(r));
    }
  }

  internal sealed partial class OrderByClauseSyntax : QueryClauseSyntax
  {
    internal readonly SyntaxToken orderByKeyword;
    internal readonly GreenNode orderings;

    internal OrderByClauseSyntax(SyntaxKind kind, SyntaxToken orderByKeyword, GreenNode orderings, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 2;
        this.AdjustFlagsAndWidth(orderByKeyword);
        this.orderByKeyword = orderByKeyword;
        if (orderings != null)
        {
            this.AdjustFlagsAndWidth(orderings);
            this.orderings = orderings;
        }
    }


    internal OrderByClauseSyntax(SyntaxKind kind, SyntaxToken orderByKeyword, GreenNode orderings, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 2;
        this.AdjustFlagsAndWidth(orderByKeyword);
        this.orderByKeyword = orderByKeyword;
        if (orderings != null)
        {
            this.AdjustFlagsAndWidth(orderings);
            this.orderings = orderings;
        }
    }


    internal OrderByClauseSyntax(SyntaxKind kind, SyntaxToken orderByKeyword, GreenNode orderings)
        : base(kind)
    {
        this.SlotCount = 2;
        this.AdjustFlagsAndWidth(orderByKeyword);
        this.orderByKeyword = orderByKeyword;
        if (orderings != null)
        {
            this.AdjustFlagsAndWidth(orderings);
            this.orderings = orderings;
        }
    }

    public SyntaxToken OrderByKeyword { get { return this.orderByKeyword; } }
    public Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<OrderingSyntax> Orderings { get { return new Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<OrderingSyntax>(new Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<CSharpSyntaxNode>(this.orderings)); } }

    internal override GreenNode GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.orderByKeyword;
            case 1: return this.orderings;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode parent, int position)
    {
      return new CSharp.Syntax.OrderByClauseSyntax(this, parent, position);
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitOrderByClause(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitOrderByClause(this);
    }

    public OrderByClauseSyntax Update(SyntaxToken orderByKeyword, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<OrderingSyntax> orderings)
    {
        if (orderByKeyword != this.OrderByKeyword || orderings != this.Orderings)
        {
            var newNode = SyntaxFactory.OrderByClause(orderByKeyword, orderings);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
    {
         return new OrderByClauseSyntax(this.Kind, this.orderByKeyword, this.orderings, diagnostics, GetAnnotations());
    }

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
    {
         return new OrderByClauseSyntax(this.Kind, this.orderByKeyword, this.orderings, GetDiagnostics(), annotations);
    }

    internal OrderByClauseSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 2;
      var orderByKeyword = (SyntaxToken)reader.ReadValue();
      if (orderByKeyword != null)
      {
         AdjustFlagsAndWidth(orderByKeyword);
         this.orderByKeyword = orderByKeyword;
      }
      var orderings = (GreenNode)reader.ReadValue();
      if (orderings != null)
      {
         AdjustFlagsAndWidth(orderings);
         this.orderings = orderings;
      }
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.orderByKeyword);
      writer.WriteValue(this.orderings);
    }

    static OrderByClauseSyntax()
    {
       ObjectBinder.RegisterTypeReader(typeof(OrderByClauseSyntax), r => new OrderByClauseSyntax(r));
    }
  }

  internal sealed partial class OrderingSyntax : CSharpSyntaxNode
  {
    internal readonly ExpressionSyntax expression;
    internal readonly SyntaxToken ascendingOrDescendingKeyword;

    internal OrderingSyntax(SyntaxKind kind, ExpressionSyntax expression, SyntaxToken ascendingOrDescendingKeyword, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 2;
        this.AdjustFlagsAndWidth(expression);
        this.expression = expression;
        if (ascendingOrDescendingKeyword != null)
        {
            this.AdjustFlagsAndWidth(ascendingOrDescendingKeyword);
            this.ascendingOrDescendingKeyword = ascendingOrDescendingKeyword;
        }
    }


    internal OrderingSyntax(SyntaxKind kind, ExpressionSyntax expression, SyntaxToken ascendingOrDescendingKeyword, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 2;
        this.AdjustFlagsAndWidth(expression);
        this.expression = expression;
        if (ascendingOrDescendingKeyword != null)
        {
            this.AdjustFlagsAndWidth(ascendingOrDescendingKeyword);
            this.ascendingOrDescendingKeyword = ascendingOrDescendingKeyword;
        }
    }


    internal OrderingSyntax(SyntaxKind kind, ExpressionSyntax expression, SyntaxToken ascendingOrDescendingKeyword)
        : base(kind)
    {
        this.SlotCount = 2;
        this.AdjustFlagsAndWidth(expression);
        this.expression = expression;
        if (ascendingOrDescendingKeyword != null)
        {
            this.AdjustFlagsAndWidth(ascendingOrDescendingKeyword);
            this.ascendingOrDescendingKeyword = ascendingOrDescendingKeyword;
        }
    }

    public ExpressionSyntax Expression { get { return this.expression; } }
    public SyntaxToken AscendingOrDescendingKeyword { get { return this.ascendingOrDescendingKeyword; } }

    internal override GreenNode GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.expression;
            case 1: return this.ascendingOrDescendingKeyword;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode parent, int position)
    {
      return new CSharp.Syntax.OrderingSyntax(this, parent, position);
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitOrdering(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitOrdering(this);
    }

    public OrderingSyntax Update(ExpressionSyntax expression, SyntaxToken ascendingOrDescendingKeyword)
    {
        if (expression != this.Expression || ascendingOrDescendingKeyword != this.AscendingOrDescendingKeyword)
        {
            var newNode = SyntaxFactory.Ordering(this.Kind, expression, ascendingOrDescendingKeyword);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
    {
         return new OrderingSyntax(this.Kind, this.expression, this.ascendingOrDescendingKeyword, diagnostics, GetAnnotations());
    }

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
    {
         return new OrderingSyntax(this.Kind, this.expression, this.ascendingOrDescendingKeyword, GetDiagnostics(), annotations);
    }

    internal OrderingSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 2;
      var expression = (ExpressionSyntax)reader.ReadValue();
      if (expression != null)
      {
         AdjustFlagsAndWidth(expression);
         this.expression = expression;
      }
      var ascendingOrDescendingKeyword = (SyntaxToken)reader.ReadValue();
      if (ascendingOrDescendingKeyword != null)
      {
         AdjustFlagsAndWidth(ascendingOrDescendingKeyword);
         this.ascendingOrDescendingKeyword = ascendingOrDescendingKeyword;
      }
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.expression);
      writer.WriteValue(this.ascendingOrDescendingKeyword);
    }

    static OrderingSyntax()
    {
       ObjectBinder.RegisterTypeReader(typeof(OrderingSyntax), r => new OrderingSyntax(r));
    }
  }

  internal sealed partial class SelectClauseSyntax : SelectOrGroupClauseSyntax
  {
    internal readonly SyntaxToken selectKeyword;
    internal readonly ExpressionSyntax expression;

    internal SelectClauseSyntax(SyntaxKind kind, SyntaxToken selectKeyword, ExpressionSyntax expression, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 2;
        this.AdjustFlagsAndWidth(selectKeyword);
        this.selectKeyword = selectKeyword;
        this.AdjustFlagsAndWidth(expression);
        this.expression = expression;
    }


    internal SelectClauseSyntax(SyntaxKind kind, SyntaxToken selectKeyword, ExpressionSyntax expression, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 2;
        this.AdjustFlagsAndWidth(selectKeyword);
        this.selectKeyword = selectKeyword;
        this.AdjustFlagsAndWidth(expression);
        this.expression = expression;
    }


    internal SelectClauseSyntax(SyntaxKind kind, SyntaxToken selectKeyword, ExpressionSyntax expression)
        : base(kind)
    {
        this.SlotCount = 2;
        this.AdjustFlagsAndWidth(selectKeyword);
        this.selectKeyword = selectKeyword;
        this.AdjustFlagsAndWidth(expression);
        this.expression = expression;
    }

    public SyntaxToken SelectKeyword { get { return this.selectKeyword; } }
    public ExpressionSyntax Expression { get { return this.expression; } }

    internal override GreenNode GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.selectKeyword;
            case 1: return this.expression;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode parent, int position)
    {
      return new CSharp.Syntax.SelectClauseSyntax(this, parent, position);
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitSelectClause(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitSelectClause(this);
    }

    public SelectClauseSyntax Update(SyntaxToken selectKeyword, ExpressionSyntax expression)
    {
        if (selectKeyword != this.SelectKeyword || expression != this.Expression)
        {
            var newNode = SyntaxFactory.SelectClause(selectKeyword, expression);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
    {
         return new SelectClauseSyntax(this.Kind, this.selectKeyword, this.expression, diagnostics, GetAnnotations());
    }

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
    {
         return new SelectClauseSyntax(this.Kind, this.selectKeyword, this.expression, GetDiagnostics(), annotations);
    }

    internal SelectClauseSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 2;
      var selectKeyword = (SyntaxToken)reader.ReadValue();
      if (selectKeyword != null)
      {
         AdjustFlagsAndWidth(selectKeyword);
         this.selectKeyword = selectKeyword;
      }
      var expression = (ExpressionSyntax)reader.ReadValue();
      if (expression != null)
      {
         AdjustFlagsAndWidth(expression);
         this.expression = expression;
      }
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.selectKeyword);
      writer.WriteValue(this.expression);
    }

    static SelectClauseSyntax()
    {
       ObjectBinder.RegisterTypeReader(typeof(SelectClauseSyntax), r => new SelectClauseSyntax(r));
    }
  }

  internal sealed partial class GroupClauseSyntax : SelectOrGroupClauseSyntax
  {
    internal readonly SyntaxToken groupKeyword;
    internal readonly ExpressionSyntax groupExpression;
    internal readonly SyntaxToken byKeyword;
    internal readonly ExpressionSyntax byExpression;

    internal GroupClauseSyntax(SyntaxKind kind, SyntaxToken groupKeyword, ExpressionSyntax groupExpression, SyntaxToken byKeyword, ExpressionSyntax byExpression, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 4;
        this.AdjustFlagsAndWidth(groupKeyword);
        this.groupKeyword = groupKeyword;
        this.AdjustFlagsAndWidth(groupExpression);
        this.groupExpression = groupExpression;
        this.AdjustFlagsAndWidth(byKeyword);
        this.byKeyword = byKeyword;
        this.AdjustFlagsAndWidth(byExpression);
        this.byExpression = byExpression;
    }


    internal GroupClauseSyntax(SyntaxKind kind, SyntaxToken groupKeyword, ExpressionSyntax groupExpression, SyntaxToken byKeyword, ExpressionSyntax byExpression, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 4;
        this.AdjustFlagsAndWidth(groupKeyword);
        this.groupKeyword = groupKeyword;
        this.AdjustFlagsAndWidth(groupExpression);
        this.groupExpression = groupExpression;
        this.AdjustFlagsAndWidth(byKeyword);
        this.byKeyword = byKeyword;
        this.AdjustFlagsAndWidth(byExpression);
        this.byExpression = byExpression;
    }


    internal GroupClauseSyntax(SyntaxKind kind, SyntaxToken groupKeyword, ExpressionSyntax groupExpression, SyntaxToken byKeyword, ExpressionSyntax byExpression)
        : base(kind)
    {
        this.SlotCount = 4;
        this.AdjustFlagsAndWidth(groupKeyword);
        this.groupKeyword = groupKeyword;
        this.AdjustFlagsAndWidth(groupExpression);
        this.groupExpression = groupExpression;
        this.AdjustFlagsAndWidth(byKeyword);
        this.byKeyword = byKeyword;
        this.AdjustFlagsAndWidth(byExpression);
        this.byExpression = byExpression;
    }

    public SyntaxToken GroupKeyword { get { return this.groupKeyword; } }
    public ExpressionSyntax GroupExpression { get { return this.groupExpression; } }
    public SyntaxToken ByKeyword { get { return this.byKeyword; } }
    public ExpressionSyntax ByExpression { get { return this.byExpression; } }

    internal override GreenNode GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.groupKeyword;
            case 1: return this.groupExpression;
            case 2: return this.byKeyword;
            case 3: return this.byExpression;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode parent, int position)
    {
      return new CSharp.Syntax.GroupClauseSyntax(this, parent, position);
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitGroupClause(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitGroupClause(this);
    }

    public GroupClauseSyntax Update(SyntaxToken groupKeyword, ExpressionSyntax groupExpression, SyntaxToken byKeyword, ExpressionSyntax byExpression)
    {
        if (groupKeyword != this.GroupKeyword || groupExpression != this.GroupExpression || byKeyword != this.ByKeyword || byExpression != this.ByExpression)
        {
            var newNode = SyntaxFactory.GroupClause(groupKeyword, groupExpression, byKeyword, byExpression);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
    {
         return new GroupClauseSyntax(this.Kind, this.groupKeyword, this.groupExpression, this.byKeyword, this.byExpression, diagnostics, GetAnnotations());
    }

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
    {
         return new GroupClauseSyntax(this.Kind, this.groupKeyword, this.groupExpression, this.byKeyword, this.byExpression, GetDiagnostics(), annotations);
    }

    internal GroupClauseSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 4;
      var groupKeyword = (SyntaxToken)reader.ReadValue();
      if (groupKeyword != null)
      {
         AdjustFlagsAndWidth(groupKeyword);
         this.groupKeyword = groupKeyword;
      }
      var groupExpression = (ExpressionSyntax)reader.ReadValue();
      if (groupExpression != null)
      {
         AdjustFlagsAndWidth(groupExpression);
         this.groupExpression = groupExpression;
      }
      var byKeyword = (SyntaxToken)reader.ReadValue();
      if (byKeyword != null)
      {
         AdjustFlagsAndWidth(byKeyword);
         this.byKeyword = byKeyword;
      }
      var byExpression = (ExpressionSyntax)reader.ReadValue();
      if (byExpression != null)
      {
         AdjustFlagsAndWidth(byExpression);
         this.byExpression = byExpression;
      }
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.groupKeyword);
      writer.WriteValue(this.groupExpression);
      writer.WriteValue(this.byKeyword);
      writer.WriteValue(this.byExpression);
    }

    static GroupClauseSyntax()
    {
       ObjectBinder.RegisterTypeReader(typeof(GroupClauseSyntax), r => new GroupClauseSyntax(r));
    }
  }

  internal sealed partial class QueryContinuationSyntax : CSharpSyntaxNode
  {
    internal readonly SyntaxToken intoKeyword;
    internal readonly SyntaxToken identifier;
    internal readonly QueryBodySyntax body;

    internal QueryContinuationSyntax(SyntaxKind kind, SyntaxToken intoKeyword, SyntaxToken identifier, QueryBodySyntax body, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 3;
        this.AdjustFlagsAndWidth(intoKeyword);
        this.intoKeyword = intoKeyword;
        this.AdjustFlagsAndWidth(identifier);
        this.identifier = identifier;
        this.AdjustFlagsAndWidth(body);
        this.body = body;
    }


    internal QueryContinuationSyntax(SyntaxKind kind, SyntaxToken intoKeyword, SyntaxToken identifier, QueryBodySyntax body, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 3;
        this.AdjustFlagsAndWidth(intoKeyword);
        this.intoKeyword = intoKeyword;
        this.AdjustFlagsAndWidth(identifier);
        this.identifier = identifier;
        this.AdjustFlagsAndWidth(body);
        this.body = body;
    }


    internal QueryContinuationSyntax(SyntaxKind kind, SyntaxToken intoKeyword, SyntaxToken identifier, QueryBodySyntax body)
        : base(kind)
    {
        this.SlotCount = 3;
        this.AdjustFlagsAndWidth(intoKeyword);
        this.intoKeyword = intoKeyword;
        this.AdjustFlagsAndWidth(identifier);
        this.identifier = identifier;
        this.AdjustFlagsAndWidth(body);
        this.body = body;
    }

    public SyntaxToken IntoKeyword { get { return this.intoKeyword; } }
    /// <summary>Gets the identifier.</summary>
    public SyntaxToken Identifier { get { return this.identifier; } }
    public QueryBodySyntax Body { get { return this.body; } }

    internal override GreenNode GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.intoKeyword;
            case 1: return this.identifier;
            case 2: return this.body;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode parent, int position)
    {
      return new CSharp.Syntax.QueryContinuationSyntax(this, parent, position);
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitQueryContinuation(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitQueryContinuation(this);
    }

    public QueryContinuationSyntax Update(SyntaxToken intoKeyword, SyntaxToken identifier, QueryBodySyntax body)
    {
        if (intoKeyword != this.IntoKeyword || identifier != this.Identifier || body != this.Body)
        {
            var newNode = SyntaxFactory.QueryContinuation(intoKeyword, identifier, body);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
    {
         return new QueryContinuationSyntax(this.Kind, this.intoKeyword, this.identifier, this.body, diagnostics, GetAnnotations());
    }

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
    {
         return new QueryContinuationSyntax(this.Kind, this.intoKeyword, this.identifier, this.body, GetDiagnostics(), annotations);
    }

    internal QueryContinuationSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 3;
      var intoKeyword = (SyntaxToken)reader.ReadValue();
      if (intoKeyword != null)
      {
         AdjustFlagsAndWidth(intoKeyword);
         this.intoKeyword = intoKeyword;
      }
      var identifier = (SyntaxToken)reader.ReadValue();
      if (identifier != null)
      {
         AdjustFlagsAndWidth(identifier);
         this.identifier = identifier;
      }
      var body = (QueryBodySyntax)reader.ReadValue();
      if (body != null)
      {
         AdjustFlagsAndWidth(body);
         this.body = body;
      }
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.intoKeyword);
      writer.WriteValue(this.identifier);
      writer.WriteValue(this.body);
    }

    static QueryContinuationSyntax()
    {
       ObjectBinder.RegisterTypeReader(typeof(QueryContinuationSyntax), r => new QueryContinuationSyntax(r));
    }
  }

  /// <summary>Class which represents a placeholder in an array size list.</summary>
  internal sealed partial class OmittedArraySizeExpressionSyntax : ExpressionSyntax
  {
    internal readonly SyntaxToken omittedArraySizeExpressionToken;

    internal OmittedArraySizeExpressionSyntax(SyntaxKind kind, SyntaxToken omittedArraySizeExpressionToken, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 1;
        this.AdjustFlagsAndWidth(omittedArraySizeExpressionToken);
        this.omittedArraySizeExpressionToken = omittedArraySizeExpressionToken;
    }


    internal OmittedArraySizeExpressionSyntax(SyntaxKind kind, SyntaxToken omittedArraySizeExpressionToken, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 1;
        this.AdjustFlagsAndWidth(omittedArraySizeExpressionToken);
        this.omittedArraySizeExpressionToken = omittedArraySizeExpressionToken;
    }


    internal OmittedArraySizeExpressionSyntax(SyntaxKind kind, SyntaxToken omittedArraySizeExpressionToken)
        : base(kind)
    {
        this.SlotCount = 1;
        this.AdjustFlagsAndWidth(omittedArraySizeExpressionToken);
        this.omittedArraySizeExpressionToken = omittedArraySizeExpressionToken;
    }

    /// <summary>SyntaxToken representing the omitted array size expression.</summary>
    public SyntaxToken OmittedArraySizeExpressionToken { get { return this.omittedArraySizeExpressionToken; } }

    internal override GreenNode GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.omittedArraySizeExpressionToken;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode parent, int position)
    {
      return new CSharp.Syntax.OmittedArraySizeExpressionSyntax(this, parent, position);
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitOmittedArraySizeExpression(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitOmittedArraySizeExpression(this);
    }

    public OmittedArraySizeExpressionSyntax Update(SyntaxToken omittedArraySizeExpressionToken)
    {
        if (omittedArraySizeExpressionToken != this.OmittedArraySizeExpressionToken)
        {
            var newNode = SyntaxFactory.OmittedArraySizeExpression(omittedArraySizeExpressionToken);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
    {
         return new OmittedArraySizeExpressionSyntax(this.Kind, this.omittedArraySizeExpressionToken, diagnostics, GetAnnotations());
    }

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
    {
         return new OmittedArraySizeExpressionSyntax(this.Kind, this.omittedArraySizeExpressionToken, GetDiagnostics(), annotations);
    }

    internal OmittedArraySizeExpressionSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 1;
      var omittedArraySizeExpressionToken = (SyntaxToken)reader.ReadValue();
      if (omittedArraySizeExpressionToken != null)
      {
         AdjustFlagsAndWidth(omittedArraySizeExpressionToken);
         this.omittedArraySizeExpressionToken = omittedArraySizeExpressionToken;
      }
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.omittedArraySizeExpressionToken);
    }

    static OmittedArraySizeExpressionSyntax()
    {
       ObjectBinder.RegisterTypeReader(typeof(OmittedArraySizeExpressionSyntax), r => new OmittedArraySizeExpressionSyntax(r));
    }
  }

  internal sealed partial class InterpolatedStringExpressionSyntax : ExpressionSyntax
  {
    internal readonly SyntaxToken stringStartToken;
    internal readonly GreenNode contents;
    internal readonly SyntaxToken stringEndToken;

    internal InterpolatedStringExpressionSyntax(SyntaxKind kind, SyntaxToken stringStartToken, GreenNode contents, SyntaxToken stringEndToken, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 3;
        this.AdjustFlagsAndWidth(stringStartToken);
        this.stringStartToken = stringStartToken;
        if (contents != null)
        {
            this.AdjustFlagsAndWidth(contents);
            this.contents = contents;
        }
        this.AdjustFlagsAndWidth(stringEndToken);
        this.stringEndToken = stringEndToken;
    }


    internal InterpolatedStringExpressionSyntax(SyntaxKind kind, SyntaxToken stringStartToken, GreenNode contents, SyntaxToken stringEndToken, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 3;
        this.AdjustFlagsAndWidth(stringStartToken);
        this.stringStartToken = stringStartToken;
        if (contents != null)
        {
            this.AdjustFlagsAndWidth(contents);
            this.contents = contents;
        }
        this.AdjustFlagsAndWidth(stringEndToken);
        this.stringEndToken = stringEndToken;
    }


    internal InterpolatedStringExpressionSyntax(SyntaxKind kind, SyntaxToken stringStartToken, GreenNode contents, SyntaxToken stringEndToken)
        : base(kind)
    {
        this.SlotCount = 3;
        this.AdjustFlagsAndWidth(stringStartToken);
        this.stringStartToken = stringStartToken;
        if (contents != null)
        {
            this.AdjustFlagsAndWidth(contents);
            this.contents = contents;
        }
        this.AdjustFlagsAndWidth(stringEndToken);
        this.stringEndToken = stringEndToken;
    }

    /// <summary>The first part of an interpolated string, $" or $@"</summary>
    public SyntaxToken StringStartToken { get { return this.stringStartToken; } }
    /// <summary>List of parts of the interpolated string, each one is either a literal part or an interpolation.</summary>
    public Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<InterpolatedStringContentSyntax> Contents { get { return new Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<InterpolatedStringContentSyntax>(this.contents); } }
    /// <summary>The closing quote of the interpolated string.</summary>
    public SyntaxToken StringEndToken { get { return this.stringEndToken; } }

    internal override GreenNode GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.stringStartToken;
            case 1: return this.contents;
            case 2: return this.stringEndToken;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode parent, int position)
    {
      return new CSharp.Syntax.InterpolatedStringExpressionSyntax(this, parent, position);
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitInterpolatedStringExpression(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitInterpolatedStringExpression(this);
    }

    public InterpolatedStringExpressionSyntax Update(SyntaxToken stringStartToken, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<InterpolatedStringContentSyntax> contents, SyntaxToken stringEndToken)
    {
        if (stringStartToken != this.StringStartToken || contents != this.Contents || stringEndToken != this.StringEndToken)
        {
            var newNode = SyntaxFactory.InterpolatedStringExpression(stringStartToken, contents, stringEndToken);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
    {
         return new InterpolatedStringExpressionSyntax(this.Kind, this.stringStartToken, this.contents, this.stringEndToken, diagnostics, GetAnnotations());
    }

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
    {
         return new InterpolatedStringExpressionSyntax(this.Kind, this.stringStartToken, this.contents, this.stringEndToken, GetDiagnostics(), annotations);
    }

    internal InterpolatedStringExpressionSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 3;
      var stringStartToken = (SyntaxToken)reader.ReadValue();
      if (stringStartToken != null)
      {
         AdjustFlagsAndWidth(stringStartToken);
         this.stringStartToken = stringStartToken;
      }
      var contents = (GreenNode)reader.ReadValue();
      if (contents != null)
      {
         AdjustFlagsAndWidth(contents);
         this.contents = contents;
      }
      var stringEndToken = (SyntaxToken)reader.ReadValue();
      if (stringEndToken != null)
      {
         AdjustFlagsAndWidth(stringEndToken);
         this.stringEndToken = stringEndToken;
      }
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.stringStartToken);
      writer.WriteValue(this.contents);
      writer.WriteValue(this.stringEndToken);
    }

    static InterpolatedStringExpressionSyntax()
    {
       ObjectBinder.RegisterTypeReader(typeof(InterpolatedStringExpressionSyntax), r => new InterpolatedStringExpressionSyntax(r));
    }
  }

  /// <summary>Class which represents a simple pattern-maching expresion using the "is" keyword.</summary>
  internal sealed partial class IsPatternExpressionSyntax : ExpressionSyntax
  {
    internal readonly ExpressionSyntax expression;
    internal readonly SyntaxToken isKeyword;
    internal readonly PatternSyntax pattern;

    internal IsPatternExpressionSyntax(SyntaxKind kind, ExpressionSyntax expression, SyntaxToken isKeyword, PatternSyntax pattern, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 3;
        this.AdjustFlagsAndWidth(expression);
        this.expression = expression;
        this.AdjustFlagsAndWidth(isKeyword);
        this.isKeyword = isKeyword;
        this.AdjustFlagsAndWidth(pattern);
        this.pattern = pattern;
    }


    internal IsPatternExpressionSyntax(SyntaxKind kind, ExpressionSyntax expression, SyntaxToken isKeyword, PatternSyntax pattern, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 3;
        this.AdjustFlagsAndWidth(expression);
        this.expression = expression;
        this.AdjustFlagsAndWidth(isKeyword);
        this.isKeyword = isKeyword;
        this.AdjustFlagsAndWidth(pattern);
        this.pattern = pattern;
    }


    internal IsPatternExpressionSyntax(SyntaxKind kind, ExpressionSyntax expression, SyntaxToken isKeyword, PatternSyntax pattern)
        : base(kind)
    {
        this.SlotCount = 3;
        this.AdjustFlagsAndWidth(expression);
        this.expression = expression;
        this.AdjustFlagsAndWidth(isKeyword);
        this.isKeyword = isKeyword;
        this.AdjustFlagsAndWidth(pattern);
        this.pattern = pattern;
    }

    /// <summary>ExpressionSyntax node representing the expression on the left of the "is" operator.</summary>
    public ExpressionSyntax Expression { get { return this.expression; } }
    public SyntaxToken IsKeyword { get { return this.isKeyword; } }
    /// <summary>PatternSyntax node representing the pattern on the right of the "is" operator.</summary>
    public PatternSyntax Pattern { get { return this.pattern; } }

    internal override GreenNode GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.expression;
            case 1: return this.isKeyword;
            case 2: return this.pattern;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode parent, int position)
    {
      return new CSharp.Syntax.IsPatternExpressionSyntax(this, parent, position);
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitIsPatternExpression(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitIsPatternExpression(this);
    }

    public IsPatternExpressionSyntax Update(ExpressionSyntax expression, SyntaxToken isKeyword, PatternSyntax pattern)
    {
        if (expression != this.Expression || isKeyword != this.IsKeyword || pattern != this.Pattern)
        {
            var newNode = SyntaxFactory.IsPatternExpression(expression, isKeyword, pattern);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
    {
         return new IsPatternExpressionSyntax(this.Kind, this.expression, this.isKeyword, this.pattern, diagnostics, GetAnnotations());
    }

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
    {
         return new IsPatternExpressionSyntax(this.Kind, this.expression, this.isKeyword, this.pattern, GetDiagnostics(), annotations);
    }

    internal IsPatternExpressionSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 3;
      var expression = (ExpressionSyntax)reader.ReadValue();
      if (expression != null)
      {
         AdjustFlagsAndWidth(expression);
         this.expression = expression;
      }
      var isKeyword = (SyntaxToken)reader.ReadValue();
      if (isKeyword != null)
      {
         AdjustFlagsAndWidth(isKeyword);
         this.isKeyword = isKeyword;
      }
      var pattern = (PatternSyntax)reader.ReadValue();
      if (pattern != null)
      {
         AdjustFlagsAndWidth(pattern);
         this.pattern = pattern;
      }
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.expression);
      writer.WriteValue(this.isKeyword);
      writer.WriteValue(this.pattern);
    }

    static IsPatternExpressionSyntax()
    {
       ObjectBinder.RegisterTypeReader(typeof(IsPatternExpressionSyntax), r => new IsPatternExpressionSyntax(r));
    }
  }

  internal sealed partial class ThrowExpressionSyntax : ExpressionSyntax
  {
    internal readonly SyntaxToken throwKeyword;
    internal readonly ExpressionSyntax expression;

    internal ThrowExpressionSyntax(SyntaxKind kind, SyntaxToken throwKeyword, ExpressionSyntax expression, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 2;
        this.AdjustFlagsAndWidth(throwKeyword);
        this.throwKeyword = throwKeyword;
        this.AdjustFlagsAndWidth(expression);
        this.expression = expression;
    }


    internal ThrowExpressionSyntax(SyntaxKind kind, SyntaxToken throwKeyword, ExpressionSyntax expression, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 2;
        this.AdjustFlagsAndWidth(throwKeyword);
        this.throwKeyword = throwKeyword;
        this.AdjustFlagsAndWidth(expression);
        this.expression = expression;
    }


    internal ThrowExpressionSyntax(SyntaxKind kind, SyntaxToken throwKeyword, ExpressionSyntax expression)
        : base(kind)
    {
        this.SlotCount = 2;
        this.AdjustFlagsAndWidth(throwKeyword);
        this.throwKeyword = throwKeyword;
        this.AdjustFlagsAndWidth(expression);
        this.expression = expression;
    }

    public SyntaxToken ThrowKeyword { get { return this.throwKeyword; } }
    public ExpressionSyntax Expression { get { return this.expression; } }

    internal override GreenNode GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.throwKeyword;
            case 1: return this.expression;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode parent, int position)
    {
      return new CSharp.Syntax.ThrowExpressionSyntax(this, parent, position);
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitThrowExpression(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitThrowExpression(this);
    }

    public ThrowExpressionSyntax Update(SyntaxToken throwKeyword, ExpressionSyntax expression)
    {
        if (throwKeyword != this.ThrowKeyword || expression != this.Expression)
        {
            var newNode = SyntaxFactory.ThrowExpression(throwKeyword, expression);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
    {
         return new ThrowExpressionSyntax(this.Kind, this.throwKeyword, this.expression, diagnostics, GetAnnotations());
    }

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
    {
         return new ThrowExpressionSyntax(this.Kind, this.throwKeyword, this.expression, GetDiagnostics(), annotations);
    }

    internal ThrowExpressionSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 2;
      var throwKeyword = (SyntaxToken)reader.ReadValue();
      if (throwKeyword != null)
      {
         AdjustFlagsAndWidth(throwKeyword);
         this.throwKeyword = throwKeyword;
      }
      var expression = (ExpressionSyntax)reader.ReadValue();
      if (expression != null)
      {
         AdjustFlagsAndWidth(expression);
         this.expression = expression;
      }
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.throwKeyword);
      writer.WriteValue(this.expression);
    }

    static ThrowExpressionSyntax()
    {
       ObjectBinder.RegisterTypeReader(typeof(ThrowExpressionSyntax), r => new ThrowExpressionSyntax(r));
    }
  }

  internal sealed partial class WhenClauseSyntax : CSharpSyntaxNode
  {
    internal readonly SyntaxToken whenKeyword;
    internal readonly ExpressionSyntax condition;

    internal WhenClauseSyntax(SyntaxKind kind, SyntaxToken whenKeyword, ExpressionSyntax condition, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 2;
        this.AdjustFlagsAndWidth(whenKeyword);
        this.whenKeyword = whenKeyword;
        this.AdjustFlagsAndWidth(condition);
        this.condition = condition;
    }


    internal WhenClauseSyntax(SyntaxKind kind, SyntaxToken whenKeyword, ExpressionSyntax condition, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 2;
        this.AdjustFlagsAndWidth(whenKeyword);
        this.whenKeyword = whenKeyword;
        this.AdjustFlagsAndWidth(condition);
        this.condition = condition;
    }


    internal WhenClauseSyntax(SyntaxKind kind, SyntaxToken whenKeyword, ExpressionSyntax condition)
        : base(kind)
    {
        this.SlotCount = 2;
        this.AdjustFlagsAndWidth(whenKeyword);
        this.whenKeyword = whenKeyword;
        this.AdjustFlagsAndWidth(condition);
        this.condition = condition;
    }

    public SyntaxToken WhenKeyword { get { return this.whenKeyword; } }
    public ExpressionSyntax Condition { get { return this.condition; } }

    internal override GreenNode GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.whenKeyword;
            case 1: return this.condition;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode parent, int position)
    {
      return new CSharp.Syntax.WhenClauseSyntax(this, parent, position);
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitWhenClause(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitWhenClause(this);
    }

    public WhenClauseSyntax Update(SyntaxToken whenKeyword, ExpressionSyntax condition)
    {
        if (whenKeyword != this.WhenKeyword || condition != this.Condition)
        {
            var newNode = SyntaxFactory.WhenClause(whenKeyword, condition);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
    {
         return new WhenClauseSyntax(this.Kind, this.whenKeyword, this.condition, diagnostics, GetAnnotations());
    }

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
    {
         return new WhenClauseSyntax(this.Kind, this.whenKeyword, this.condition, GetDiagnostics(), annotations);
    }

    internal WhenClauseSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 2;
      var whenKeyword = (SyntaxToken)reader.ReadValue();
      if (whenKeyword != null)
      {
         AdjustFlagsAndWidth(whenKeyword);
         this.whenKeyword = whenKeyword;
      }
      var condition = (ExpressionSyntax)reader.ReadValue();
      if (condition != null)
      {
         AdjustFlagsAndWidth(condition);
         this.condition = condition;
      }
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.whenKeyword);
      writer.WriteValue(this.condition);
    }

    static WhenClauseSyntax()
    {
       ObjectBinder.RegisterTypeReader(typeof(WhenClauseSyntax), r => new WhenClauseSyntax(r));
    }
  }

  internal abstract partial class PatternSyntax : CSharpSyntaxNode
  {
    internal PatternSyntax(SyntaxKind kind, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
      : base(kind, diagnostics, annotations)
    {
    }
    internal PatternSyntax(SyntaxKind kind)
      : base(kind)
    {
    }

    protected PatternSyntax(ObjectReader reader)
       : base(reader)
    {
    }
  }

  internal sealed partial class DeclarationPatternSyntax : PatternSyntax
  {
    internal readonly TypeSyntax type;
    internal readonly VariableDesignationSyntax designation;

    internal DeclarationPatternSyntax(SyntaxKind kind, TypeSyntax type, VariableDesignationSyntax designation, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 2;
        this.AdjustFlagsAndWidth(type);
        this.type = type;
        this.AdjustFlagsAndWidth(designation);
        this.designation = designation;
    }


    internal DeclarationPatternSyntax(SyntaxKind kind, TypeSyntax type, VariableDesignationSyntax designation, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 2;
        this.AdjustFlagsAndWidth(type);
        this.type = type;
        this.AdjustFlagsAndWidth(designation);
        this.designation = designation;
    }


    internal DeclarationPatternSyntax(SyntaxKind kind, TypeSyntax type, VariableDesignationSyntax designation)
        : base(kind)
    {
        this.SlotCount = 2;
        this.AdjustFlagsAndWidth(type);
        this.type = type;
        this.AdjustFlagsAndWidth(designation);
        this.designation = designation;
    }

    public TypeSyntax Type { get { return this.type; } }
    public VariableDesignationSyntax Designation { get { return this.designation; } }

    internal override GreenNode GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.type;
            case 1: return this.designation;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode parent, int position)
    {
      return new CSharp.Syntax.DeclarationPatternSyntax(this, parent, position);
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitDeclarationPattern(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitDeclarationPattern(this);
    }

    public DeclarationPatternSyntax Update(TypeSyntax type, VariableDesignationSyntax designation)
    {
        if (type != this.Type || designation != this.Designation)
        {
            var newNode = SyntaxFactory.DeclarationPattern(type, designation);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
    {
         return new DeclarationPatternSyntax(this.Kind, this.type, this.designation, diagnostics, GetAnnotations());
    }

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
    {
         return new DeclarationPatternSyntax(this.Kind, this.type, this.designation, GetDiagnostics(), annotations);
    }

    internal DeclarationPatternSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 2;
      var type = (TypeSyntax)reader.ReadValue();
      if (type != null)
      {
         AdjustFlagsAndWidth(type);
         this.type = type;
      }
      var designation = (VariableDesignationSyntax)reader.ReadValue();
      if (designation != null)
      {
         AdjustFlagsAndWidth(designation);
         this.designation = designation;
      }
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.type);
      writer.WriteValue(this.designation);
    }

    static DeclarationPatternSyntax()
    {
       ObjectBinder.RegisterTypeReader(typeof(DeclarationPatternSyntax), r => new DeclarationPatternSyntax(r));
    }
  }

  internal sealed partial class ConstantPatternSyntax : PatternSyntax
  {
    internal readonly ExpressionSyntax expression;

    internal ConstantPatternSyntax(SyntaxKind kind, ExpressionSyntax expression, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 1;
        this.AdjustFlagsAndWidth(expression);
        this.expression = expression;
    }


    internal ConstantPatternSyntax(SyntaxKind kind, ExpressionSyntax expression, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 1;
        this.AdjustFlagsAndWidth(expression);
        this.expression = expression;
    }


    internal ConstantPatternSyntax(SyntaxKind kind, ExpressionSyntax expression)
        : base(kind)
    {
        this.SlotCount = 1;
        this.AdjustFlagsAndWidth(expression);
        this.expression = expression;
    }

    /// <summary>ExpressionSyntax node representing the constant expression.</summary>
    public ExpressionSyntax Expression { get { return this.expression; } }

    internal override GreenNode GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.expression;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode parent, int position)
    {
      return new CSharp.Syntax.ConstantPatternSyntax(this, parent, position);
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitConstantPattern(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitConstantPattern(this);
    }

    public ConstantPatternSyntax Update(ExpressionSyntax expression)
    {
        if (expression != this.Expression)
        {
            var newNode = SyntaxFactory.ConstantPattern(expression);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
    {
         return new ConstantPatternSyntax(this.Kind, this.expression, diagnostics, GetAnnotations());
    }

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
    {
         return new ConstantPatternSyntax(this.Kind, this.expression, GetDiagnostics(), annotations);
    }

    internal ConstantPatternSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 1;
      var expression = (ExpressionSyntax)reader.ReadValue();
      if (expression != null)
      {
         AdjustFlagsAndWidth(expression);
         this.expression = expression;
      }
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.expression);
    }

    static ConstantPatternSyntax()
    {
       ObjectBinder.RegisterTypeReader(typeof(ConstantPatternSyntax), r => new ConstantPatternSyntax(r));
    }
  }

  internal abstract partial class InterpolatedStringContentSyntax : CSharpSyntaxNode
  {
    internal InterpolatedStringContentSyntax(SyntaxKind kind, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
      : base(kind, diagnostics, annotations)
    {
    }
    internal InterpolatedStringContentSyntax(SyntaxKind kind)
      : base(kind)
    {
    }

    protected InterpolatedStringContentSyntax(ObjectReader reader)
       : base(reader)
    {
    }
  }

  internal sealed partial class InterpolatedStringTextSyntax : InterpolatedStringContentSyntax
  {
    internal readonly SyntaxToken textToken;

    internal InterpolatedStringTextSyntax(SyntaxKind kind, SyntaxToken textToken, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 1;
        this.AdjustFlagsAndWidth(textToken);
        this.textToken = textToken;
    }


    internal InterpolatedStringTextSyntax(SyntaxKind kind, SyntaxToken textToken, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 1;
        this.AdjustFlagsAndWidth(textToken);
        this.textToken = textToken;
    }


    internal InterpolatedStringTextSyntax(SyntaxKind kind, SyntaxToken textToken)
        : base(kind)
    {
        this.SlotCount = 1;
        this.AdjustFlagsAndWidth(textToken);
        this.textToken = textToken;
    }

    /// <summary>The text contents of a part of the interpolated string.</summary>
    public SyntaxToken TextToken { get { return this.textToken; } }

    internal override GreenNode GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.textToken;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode parent, int position)
    {
      return new CSharp.Syntax.InterpolatedStringTextSyntax(this, parent, position);
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitInterpolatedStringText(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitInterpolatedStringText(this);
    }

    public InterpolatedStringTextSyntax Update(SyntaxToken textToken)
    {
        if (textToken != this.TextToken)
        {
            var newNode = SyntaxFactory.InterpolatedStringText(textToken);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
    {
         return new InterpolatedStringTextSyntax(this.Kind, this.textToken, diagnostics, GetAnnotations());
    }

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
    {
         return new InterpolatedStringTextSyntax(this.Kind, this.textToken, GetDiagnostics(), annotations);
    }

    internal InterpolatedStringTextSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 1;
      var textToken = (SyntaxToken)reader.ReadValue();
      if (textToken != null)
      {
         AdjustFlagsAndWidth(textToken);
         this.textToken = textToken;
      }
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.textToken);
    }

    static InterpolatedStringTextSyntax()
    {
       ObjectBinder.RegisterTypeReader(typeof(InterpolatedStringTextSyntax), r => new InterpolatedStringTextSyntax(r));
    }
  }

  internal sealed partial class InterpolationSyntax : InterpolatedStringContentSyntax
  {
    internal readonly SyntaxToken openBraceToken;
    internal readonly ExpressionSyntax expression;
    internal readonly InterpolationAlignmentClauseSyntax alignmentClause;
    internal readonly InterpolationFormatClauseSyntax formatClause;
    internal readonly SyntaxToken closeBraceToken;

    internal InterpolationSyntax(SyntaxKind kind, SyntaxToken openBraceToken, ExpressionSyntax expression, InterpolationAlignmentClauseSyntax alignmentClause, InterpolationFormatClauseSyntax formatClause, SyntaxToken closeBraceToken, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 5;
        this.AdjustFlagsAndWidth(openBraceToken);
        this.openBraceToken = openBraceToken;
        this.AdjustFlagsAndWidth(expression);
        this.expression = expression;
        if (alignmentClause != null)
        {
            this.AdjustFlagsAndWidth(alignmentClause);
            this.alignmentClause = alignmentClause;
        }
        if (formatClause != null)
        {
            this.AdjustFlagsAndWidth(formatClause);
            this.formatClause = formatClause;
        }
        this.AdjustFlagsAndWidth(closeBraceToken);
        this.closeBraceToken = closeBraceToken;
    }


    internal InterpolationSyntax(SyntaxKind kind, SyntaxToken openBraceToken, ExpressionSyntax expression, InterpolationAlignmentClauseSyntax alignmentClause, InterpolationFormatClauseSyntax formatClause, SyntaxToken closeBraceToken, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 5;
        this.AdjustFlagsAndWidth(openBraceToken);
        this.openBraceToken = openBraceToken;
        this.AdjustFlagsAndWidth(expression);
        this.expression = expression;
        if (alignmentClause != null)
        {
            this.AdjustFlagsAndWidth(alignmentClause);
            this.alignmentClause = alignmentClause;
        }
        if (formatClause != null)
        {
            this.AdjustFlagsAndWidth(formatClause);
            this.formatClause = formatClause;
        }
        this.AdjustFlagsAndWidth(closeBraceToken);
        this.closeBraceToken = closeBraceToken;
    }


    internal InterpolationSyntax(SyntaxKind kind, SyntaxToken openBraceToken, ExpressionSyntax expression, InterpolationAlignmentClauseSyntax alignmentClause, InterpolationFormatClauseSyntax formatClause, SyntaxToken closeBraceToken)
        : base(kind)
    {
        this.SlotCount = 5;
        this.AdjustFlagsAndWidth(openBraceToken);
        this.openBraceToken = openBraceToken;
        this.AdjustFlagsAndWidth(expression);
        this.expression = expression;
        if (alignmentClause != null)
        {
            this.AdjustFlagsAndWidth(alignmentClause);
            this.alignmentClause = alignmentClause;
        }
        if (formatClause != null)
        {
            this.AdjustFlagsAndWidth(formatClause);
            this.formatClause = formatClause;
        }
        this.AdjustFlagsAndWidth(closeBraceToken);
        this.closeBraceToken = closeBraceToken;
    }

    public SyntaxToken OpenBraceToken { get { return this.openBraceToken; } }
    public ExpressionSyntax Expression { get { return this.expression; } }
    public InterpolationAlignmentClauseSyntax AlignmentClause { get { return this.alignmentClause; } }
    public InterpolationFormatClauseSyntax FormatClause { get { return this.formatClause; } }
    public SyntaxToken CloseBraceToken { get { return this.closeBraceToken; } }

    internal override GreenNode GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.openBraceToken;
            case 1: return this.expression;
            case 2: return this.alignmentClause;
            case 3: return this.formatClause;
            case 4: return this.closeBraceToken;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode parent, int position)
    {
      return new CSharp.Syntax.InterpolationSyntax(this, parent, position);
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitInterpolation(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitInterpolation(this);
    }

    public InterpolationSyntax Update(SyntaxToken openBraceToken, ExpressionSyntax expression, InterpolationAlignmentClauseSyntax alignmentClause, InterpolationFormatClauseSyntax formatClause, SyntaxToken closeBraceToken)
    {
        if (openBraceToken != this.OpenBraceToken || expression != this.Expression || alignmentClause != this.AlignmentClause || formatClause != this.FormatClause || closeBraceToken != this.CloseBraceToken)
        {
            var newNode = SyntaxFactory.Interpolation(openBraceToken, expression, alignmentClause, formatClause, closeBraceToken);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
    {
         return new InterpolationSyntax(this.Kind, this.openBraceToken, this.expression, this.alignmentClause, this.formatClause, this.closeBraceToken, diagnostics, GetAnnotations());
    }

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
    {
         return new InterpolationSyntax(this.Kind, this.openBraceToken, this.expression, this.alignmentClause, this.formatClause, this.closeBraceToken, GetDiagnostics(), annotations);
    }

    internal InterpolationSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 5;
      var openBraceToken = (SyntaxToken)reader.ReadValue();
      if (openBraceToken != null)
      {
         AdjustFlagsAndWidth(openBraceToken);
         this.openBraceToken = openBraceToken;
      }
      var expression = (ExpressionSyntax)reader.ReadValue();
      if (expression != null)
      {
         AdjustFlagsAndWidth(expression);
         this.expression = expression;
      }
      var alignmentClause = (InterpolationAlignmentClauseSyntax)reader.ReadValue();
      if (alignmentClause != null)
      {
         AdjustFlagsAndWidth(alignmentClause);
         this.alignmentClause = alignmentClause;
      }
      var formatClause = (InterpolationFormatClauseSyntax)reader.ReadValue();
      if (formatClause != null)
      {
         AdjustFlagsAndWidth(formatClause);
         this.formatClause = formatClause;
      }
      var closeBraceToken = (SyntaxToken)reader.ReadValue();
      if (closeBraceToken != null)
      {
         AdjustFlagsAndWidth(closeBraceToken);
         this.closeBraceToken = closeBraceToken;
      }
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.openBraceToken);
      writer.WriteValue(this.expression);
      writer.WriteValue(this.alignmentClause);
      writer.WriteValue(this.formatClause);
      writer.WriteValue(this.closeBraceToken);
    }

    static InterpolationSyntax()
    {
       ObjectBinder.RegisterTypeReader(typeof(InterpolationSyntax), r => new InterpolationSyntax(r));
    }
  }

  internal sealed partial class InterpolationAlignmentClauseSyntax : CSharpSyntaxNode
  {
    internal readonly SyntaxToken commaToken;
    internal readonly ExpressionSyntax value;

    internal InterpolationAlignmentClauseSyntax(SyntaxKind kind, SyntaxToken commaToken, ExpressionSyntax value, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 2;
        this.AdjustFlagsAndWidth(commaToken);
        this.commaToken = commaToken;
        this.AdjustFlagsAndWidth(value);
        this.value = value;
    }


    internal InterpolationAlignmentClauseSyntax(SyntaxKind kind, SyntaxToken commaToken, ExpressionSyntax value, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 2;
        this.AdjustFlagsAndWidth(commaToken);
        this.commaToken = commaToken;
        this.AdjustFlagsAndWidth(value);
        this.value = value;
    }


    internal InterpolationAlignmentClauseSyntax(SyntaxKind kind, SyntaxToken commaToken, ExpressionSyntax value)
        : base(kind)
    {
        this.SlotCount = 2;
        this.AdjustFlagsAndWidth(commaToken);
        this.commaToken = commaToken;
        this.AdjustFlagsAndWidth(value);
        this.value = value;
    }

    public SyntaxToken CommaToken { get { return this.commaToken; } }
    public ExpressionSyntax Value { get { return this.value; } }

    internal override GreenNode GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.commaToken;
            case 1: return this.value;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode parent, int position)
    {
      return new CSharp.Syntax.InterpolationAlignmentClauseSyntax(this, parent, position);
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitInterpolationAlignmentClause(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitInterpolationAlignmentClause(this);
    }

    public InterpolationAlignmentClauseSyntax Update(SyntaxToken commaToken, ExpressionSyntax value)
    {
        if (commaToken != this.CommaToken || value != this.Value)
        {
            var newNode = SyntaxFactory.InterpolationAlignmentClause(commaToken, value);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
    {
         return new InterpolationAlignmentClauseSyntax(this.Kind, this.commaToken, this.value, diagnostics, GetAnnotations());
    }

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
    {
         return new InterpolationAlignmentClauseSyntax(this.Kind, this.commaToken, this.value, GetDiagnostics(), annotations);
    }

    internal InterpolationAlignmentClauseSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 2;
      var commaToken = (SyntaxToken)reader.ReadValue();
      if (commaToken != null)
      {
         AdjustFlagsAndWidth(commaToken);
         this.commaToken = commaToken;
      }
      var value = (ExpressionSyntax)reader.ReadValue();
      if (value != null)
      {
         AdjustFlagsAndWidth(value);
         this.value = value;
      }
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.commaToken);
      writer.WriteValue(this.value);
    }

    static InterpolationAlignmentClauseSyntax()
    {
       ObjectBinder.RegisterTypeReader(typeof(InterpolationAlignmentClauseSyntax), r => new InterpolationAlignmentClauseSyntax(r));
    }
  }

  internal sealed partial class InterpolationFormatClauseSyntax : CSharpSyntaxNode
  {
    internal readonly SyntaxToken colonToken;
    internal readonly SyntaxToken formatStringToken;

    internal InterpolationFormatClauseSyntax(SyntaxKind kind, SyntaxToken colonToken, SyntaxToken formatStringToken, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 2;
        this.AdjustFlagsAndWidth(colonToken);
        this.colonToken = colonToken;
        this.AdjustFlagsAndWidth(formatStringToken);
        this.formatStringToken = formatStringToken;
    }


    internal InterpolationFormatClauseSyntax(SyntaxKind kind, SyntaxToken colonToken, SyntaxToken formatStringToken, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 2;
        this.AdjustFlagsAndWidth(colonToken);
        this.colonToken = colonToken;
        this.AdjustFlagsAndWidth(formatStringToken);
        this.formatStringToken = formatStringToken;
    }


    internal InterpolationFormatClauseSyntax(SyntaxKind kind, SyntaxToken colonToken, SyntaxToken formatStringToken)
        : base(kind)
    {
        this.SlotCount = 2;
        this.AdjustFlagsAndWidth(colonToken);
        this.colonToken = colonToken;
        this.AdjustFlagsAndWidth(formatStringToken);
        this.formatStringToken = formatStringToken;
    }

    public SyntaxToken ColonToken { get { return this.colonToken; } }
    /// <summary>The text contents of the format specifier for an interpolation.</summary>
    public SyntaxToken FormatStringToken { get { return this.formatStringToken; } }

    internal override GreenNode GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.colonToken;
            case 1: return this.formatStringToken;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode parent, int position)
    {
      return new CSharp.Syntax.InterpolationFormatClauseSyntax(this, parent, position);
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitInterpolationFormatClause(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitInterpolationFormatClause(this);
    }

    public InterpolationFormatClauseSyntax Update(SyntaxToken colonToken, SyntaxToken formatStringToken)
    {
        if (colonToken != this.ColonToken || formatStringToken != this.FormatStringToken)
        {
            var newNode = SyntaxFactory.InterpolationFormatClause(colonToken, formatStringToken);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
    {
         return new InterpolationFormatClauseSyntax(this.Kind, this.colonToken, this.formatStringToken, diagnostics, GetAnnotations());
    }

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
    {
         return new InterpolationFormatClauseSyntax(this.Kind, this.colonToken, this.formatStringToken, GetDiagnostics(), annotations);
    }

    internal InterpolationFormatClauseSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 2;
      var colonToken = (SyntaxToken)reader.ReadValue();
      if (colonToken != null)
      {
         AdjustFlagsAndWidth(colonToken);
         this.colonToken = colonToken;
      }
      var formatStringToken = (SyntaxToken)reader.ReadValue();
      if (formatStringToken != null)
      {
         AdjustFlagsAndWidth(formatStringToken);
         this.formatStringToken = formatStringToken;
      }
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.colonToken);
      writer.WriteValue(this.formatStringToken);
    }

    static InterpolationFormatClauseSyntax()
    {
       ObjectBinder.RegisterTypeReader(typeof(InterpolationFormatClauseSyntax), r => new InterpolationFormatClauseSyntax(r));
    }
  }

  internal sealed partial class GlobalStatementSyntax : MemberDeclarationSyntax
  {
    internal readonly StatementSyntax statement;

    internal GlobalStatementSyntax(SyntaxKind kind, StatementSyntax statement, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 1;
        this.AdjustFlagsAndWidth(statement);
        this.statement = statement;
    }


    internal GlobalStatementSyntax(SyntaxKind kind, StatementSyntax statement, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 1;
        this.AdjustFlagsAndWidth(statement);
        this.statement = statement;
    }


    internal GlobalStatementSyntax(SyntaxKind kind, StatementSyntax statement)
        : base(kind)
    {
        this.SlotCount = 1;
        this.AdjustFlagsAndWidth(statement);
        this.statement = statement;
    }

    public StatementSyntax Statement { get { return this.statement; } }

    internal override GreenNode GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.statement;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode parent, int position)
    {
      return new CSharp.Syntax.GlobalStatementSyntax(this, parent, position);
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitGlobalStatement(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitGlobalStatement(this);
    }

    public GlobalStatementSyntax Update(StatementSyntax statement)
    {
        if (statement != this.Statement)
        {
            var newNode = SyntaxFactory.GlobalStatement(statement);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
    {
         return new GlobalStatementSyntax(this.Kind, this.statement, diagnostics, GetAnnotations());
    }

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
    {
         return new GlobalStatementSyntax(this.Kind, this.statement, GetDiagnostics(), annotations);
    }

    internal GlobalStatementSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 1;
      var statement = (StatementSyntax)reader.ReadValue();
      if (statement != null)
      {
         AdjustFlagsAndWidth(statement);
         this.statement = statement;
      }
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.statement);
    }

    static GlobalStatementSyntax()
    {
       ObjectBinder.RegisterTypeReader(typeof(GlobalStatementSyntax), r => new GlobalStatementSyntax(r));
    }
  }

  /// <summary>Represents the base class for all statements syntax classes.</summary>
  internal abstract partial class StatementSyntax : CSharpSyntaxNode
  {
    internal StatementSyntax(SyntaxKind kind, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
      : base(kind, diagnostics, annotations)
    {
    }
    internal StatementSyntax(SyntaxKind kind)
      : base(kind)
    {
    }

    protected StatementSyntax(ObjectReader reader)
       : base(reader)
    {
    }
  }

  internal sealed partial class BlockSyntax : StatementSyntax
  {
    internal readonly SyntaxToken openBraceToken;
    internal readonly GreenNode statements;
    internal readonly SyntaxToken closeBraceToken;

    internal BlockSyntax(SyntaxKind kind, SyntaxToken openBraceToken, GreenNode statements, SyntaxToken closeBraceToken, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 3;
        this.AdjustFlagsAndWidth(openBraceToken);
        this.openBraceToken = openBraceToken;
        if (statements != null)
        {
            this.AdjustFlagsAndWidth(statements);
            this.statements = statements;
        }
        this.AdjustFlagsAndWidth(closeBraceToken);
        this.closeBraceToken = closeBraceToken;
    }


    internal BlockSyntax(SyntaxKind kind, SyntaxToken openBraceToken, GreenNode statements, SyntaxToken closeBraceToken, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 3;
        this.AdjustFlagsAndWidth(openBraceToken);
        this.openBraceToken = openBraceToken;
        if (statements != null)
        {
            this.AdjustFlagsAndWidth(statements);
            this.statements = statements;
        }
        this.AdjustFlagsAndWidth(closeBraceToken);
        this.closeBraceToken = closeBraceToken;
    }


    internal BlockSyntax(SyntaxKind kind, SyntaxToken openBraceToken, GreenNode statements, SyntaxToken closeBraceToken)
        : base(kind)
    {
        this.SlotCount = 3;
        this.AdjustFlagsAndWidth(openBraceToken);
        this.openBraceToken = openBraceToken;
        if (statements != null)
        {
            this.AdjustFlagsAndWidth(statements);
            this.statements = statements;
        }
        this.AdjustFlagsAndWidth(closeBraceToken);
        this.closeBraceToken = closeBraceToken;
    }

    public SyntaxToken OpenBraceToken { get { return this.openBraceToken; } }
    public Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<StatementSyntax> Statements { get { return new Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<StatementSyntax>(this.statements); } }
    public SyntaxToken CloseBraceToken { get { return this.closeBraceToken; } }

    internal override GreenNode GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.openBraceToken;
            case 1: return this.statements;
            case 2: return this.closeBraceToken;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode parent, int position)
    {
      return new CSharp.Syntax.BlockSyntax(this, parent, position);
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitBlock(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitBlock(this);
    }

    public BlockSyntax Update(SyntaxToken openBraceToken, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<StatementSyntax> statements, SyntaxToken closeBraceToken)
    {
        if (openBraceToken != this.OpenBraceToken || statements != this.Statements || closeBraceToken != this.CloseBraceToken)
        {
            var newNode = SyntaxFactory.Block(openBraceToken, statements, closeBraceToken);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
    {
         return new BlockSyntax(this.Kind, this.openBraceToken, this.statements, this.closeBraceToken, diagnostics, GetAnnotations());
    }

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
    {
         return new BlockSyntax(this.Kind, this.openBraceToken, this.statements, this.closeBraceToken, GetDiagnostics(), annotations);
    }

    internal BlockSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 3;
      var openBraceToken = (SyntaxToken)reader.ReadValue();
      if (openBraceToken != null)
      {
         AdjustFlagsAndWidth(openBraceToken);
         this.openBraceToken = openBraceToken;
      }
      var statements = (GreenNode)reader.ReadValue();
      if (statements != null)
      {
         AdjustFlagsAndWidth(statements);
         this.statements = statements;
      }
      var closeBraceToken = (SyntaxToken)reader.ReadValue();
      if (closeBraceToken != null)
      {
         AdjustFlagsAndWidth(closeBraceToken);
         this.closeBraceToken = closeBraceToken;
      }
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.openBraceToken);
      writer.WriteValue(this.statements);
      writer.WriteValue(this.closeBraceToken);
    }

    static BlockSyntax()
    {
       ObjectBinder.RegisterTypeReader(typeof(BlockSyntax), r => new BlockSyntax(r));
    }
  }

  internal sealed partial class LocalFunctionStatementSyntax : StatementSyntax
  {
    internal readonly GreenNode modifiers;
    internal readonly TypeSyntax returnType;
    internal readonly SyntaxToken identifier;
    internal readonly TypeParameterListSyntax typeParameterList;
    internal readonly ParameterListSyntax parameterList;
    internal readonly GreenNode constraintClauses;
    internal readonly BlockSyntax body;
    internal readonly ArrowExpressionClauseSyntax expressionBody;
    internal readonly SyntaxToken semicolonToken;

    internal LocalFunctionStatementSyntax(SyntaxKind kind, GreenNode modifiers, TypeSyntax returnType, SyntaxToken identifier, TypeParameterListSyntax typeParameterList, ParameterListSyntax parameterList, GreenNode constraintClauses, BlockSyntax body, ArrowExpressionClauseSyntax expressionBody, SyntaxToken semicolonToken, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 9;
        if (modifiers != null)
        {
            this.AdjustFlagsAndWidth(modifiers);
            this.modifiers = modifiers;
        }
        this.AdjustFlagsAndWidth(returnType);
        this.returnType = returnType;
        this.AdjustFlagsAndWidth(identifier);
        this.identifier = identifier;
        if (typeParameterList != null)
        {
            this.AdjustFlagsAndWidth(typeParameterList);
            this.typeParameterList = typeParameterList;
        }
        this.AdjustFlagsAndWidth(parameterList);
        this.parameterList = parameterList;
        if (constraintClauses != null)
        {
            this.AdjustFlagsAndWidth(constraintClauses);
            this.constraintClauses = constraintClauses;
        }
        if (body != null)
        {
            this.AdjustFlagsAndWidth(body);
            this.body = body;
        }
        if (expressionBody != null)
        {
            this.AdjustFlagsAndWidth(expressionBody);
            this.expressionBody = expressionBody;
        }
        if (semicolonToken != null)
        {
            this.AdjustFlagsAndWidth(semicolonToken);
            this.semicolonToken = semicolonToken;
        }
    }


    internal LocalFunctionStatementSyntax(SyntaxKind kind, GreenNode modifiers, TypeSyntax returnType, SyntaxToken identifier, TypeParameterListSyntax typeParameterList, ParameterListSyntax parameterList, GreenNode constraintClauses, BlockSyntax body, ArrowExpressionClauseSyntax expressionBody, SyntaxToken semicolonToken, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 9;
        if (modifiers != null)
        {
            this.AdjustFlagsAndWidth(modifiers);
            this.modifiers = modifiers;
        }
        this.AdjustFlagsAndWidth(returnType);
        this.returnType = returnType;
        this.AdjustFlagsAndWidth(identifier);
        this.identifier = identifier;
        if (typeParameterList != null)
        {
            this.AdjustFlagsAndWidth(typeParameterList);
            this.typeParameterList = typeParameterList;
        }
        this.AdjustFlagsAndWidth(parameterList);
        this.parameterList = parameterList;
        if (constraintClauses != null)
        {
            this.AdjustFlagsAndWidth(constraintClauses);
            this.constraintClauses = constraintClauses;
        }
        if (body != null)
        {
            this.AdjustFlagsAndWidth(body);
            this.body = body;
        }
        if (expressionBody != null)
        {
            this.AdjustFlagsAndWidth(expressionBody);
            this.expressionBody = expressionBody;
        }
        if (semicolonToken != null)
        {
            this.AdjustFlagsAndWidth(semicolonToken);
            this.semicolonToken = semicolonToken;
        }
    }


    internal LocalFunctionStatementSyntax(SyntaxKind kind, GreenNode modifiers, TypeSyntax returnType, SyntaxToken identifier, TypeParameterListSyntax typeParameterList, ParameterListSyntax parameterList, GreenNode constraintClauses, BlockSyntax body, ArrowExpressionClauseSyntax expressionBody, SyntaxToken semicolonToken)
        : base(kind)
    {
        this.SlotCount = 9;
        if (modifiers != null)
        {
            this.AdjustFlagsAndWidth(modifiers);
            this.modifiers = modifiers;
        }
        this.AdjustFlagsAndWidth(returnType);
        this.returnType = returnType;
        this.AdjustFlagsAndWidth(identifier);
        this.identifier = identifier;
        if (typeParameterList != null)
        {
            this.AdjustFlagsAndWidth(typeParameterList);
            this.typeParameterList = typeParameterList;
        }
        this.AdjustFlagsAndWidth(parameterList);
        this.parameterList = parameterList;
        if (constraintClauses != null)
        {
            this.AdjustFlagsAndWidth(constraintClauses);
            this.constraintClauses = constraintClauses;
        }
        if (body != null)
        {
            this.AdjustFlagsAndWidth(body);
            this.body = body;
        }
        if (expressionBody != null)
        {
            this.AdjustFlagsAndWidth(expressionBody);
            this.expressionBody = expressionBody;
        }
        if (semicolonToken != null)
        {
            this.AdjustFlagsAndWidth(semicolonToken);
            this.semicolonToken = semicolonToken;
        }
    }

    public Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SyntaxToken> Modifiers { get { return new Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SyntaxToken>(this.modifiers); } }
    public TypeSyntax ReturnType { get { return this.returnType; } }
    /// <summary>Gets the identifier.</summary>
    public SyntaxToken Identifier { get { return this.identifier; } }
    public TypeParameterListSyntax TypeParameterList { get { return this.typeParameterList; } }
    public ParameterListSyntax ParameterList { get { return this.parameterList; } }
    public Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<TypeParameterConstraintClauseSyntax> ConstraintClauses { get { return new Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<TypeParameterConstraintClauseSyntax>(this.constraintClauses); } }
    public BlockSyntax Body { get { return this.body; } }
    public ArrowExpressionClauseSyntax ExpressionBody { get { return this.expressionBody; } }
    /// <summary>Gets the optional semicolon token.</summary>
    public SyntaxToken SemicolonToken { get { return this.semicolonToken; } }

    internal override GreenNode GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.modifiers;
            case 1: return this.returnType;
            case 2: return this.identifier;
            case 3: return this.typeParameterList;
            case 4: return this.parameterList;
            case 5: return this.constraintClauses;
            case 6: return this.body;
            case 7: return this.expressionBody;
            case 8: return this.semicolonToken;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode parent, int position)
    {
      return new CSharp.Syntax.LocalFunctionStatementSyntax(this, parent, position);
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitLocalFunctionStatement(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitLocalFunctionStatement(this);
    }

    public LocalFunctionStatementSyntax Update(Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SyntaxToken> modifiers, TypeSyntax returnType, SyntaxToken identifier, TypeParameterListSyntax typeParameterList, ParameterListSyntax parameterList, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<TypeParameterConstraintClauseSyntax> constraintClauses, BlockSyntax body, ArrowExpressionClauseSyntax expressionBody, SyntaxToken semicolonToken)
    {
        if (modifiers != this.Modifiers || returnType != this.ReturnType || identifier != this.Identifier || typeParameterList != this.TypeParameterList || parameterList != this.ParameterList || constraintClauses != this.ConstraintClauses || body != this.Body || expressionBody != this.ExpressionBody || semicolonToken != this.SemicolonToken)
        {
            var newNode = SyntaxFactory.LocalFunctionStatement(modifiers, returnType, identifier, typeParameterList, parameterList, constraintClauses, body, expressionBody, semicolonToken);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
    {
         return new LocalFunctionStatementSyntax(this.Kind, this.modifiers, this.returnType, this.identifier, this.typeParameterList, this.parameterList, this.constraintClauses, this.body, this.expressionBody, this.semicolonToken, diagnostics, GetAnnotations());
    }

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
    {
         return new LocalFunctionStatementSyntax(this.Kind, this.modifiers, this.returnType, this.identifier, this.typeParameterList, this.parameterList, this.constraintClauses, this.body, this.expressionBody, this.semicolonToken, GetDiagnostics(), annotations);
    }

    internal LocalFunctionStatementSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 9;
      var modifiers = (GreenNode)reader.ReadValue();
      if (modifiers != null)
      {
         AdjustFlagsAndWidth(modifiers);
         this.modifiers = modifiers;
      }
      var returnType = (TypeSyntax)reader.ReadValue();
      if (returnType != null)
      {
         AdjustFlagsAndWidth(returnType);
         this.returnType = returnType;
      }
      var identifier = (SyntaxToken)reader.ReadValue();
      if (identifier != null)
      {
         AdjustFlagsAndWidth(identifier);
         this.identifier = identifier;
      }
      var typeParameterList = (TypeParameterListSyntax)reader.ReadValue();
      if (typeParameterList != null)
      {
         AdjustFlagsAndWidth(typeParameterList);
         this.typeParameterList = typeParameterList;
      }
      var parameterList = (ParameterListSyntax)reader.ReadValue();
      if (parameterList != null)
      {
         AdjustFlagsAndWidth(parameterList);
         this.parameterList = parameterList;
      }
      var constraintClauses = (GreenNode)reader.ReadValue();
      if (constraintClauses != null)
      {
         AdjustFlagsAndWidth(constraintClauses);
         this.constraintClauses = constraintClauses;
      }
      var body = (BlockSyntax)reader.ReadValue();
      if (body != null)
      {
         AdjustFlagsAndWidth(body);
         this.body = body;
      }
      var expressionBody = (ArrowExpressionClauseSyntax)reader.ReadValue();
      if (expressionBody != null)
      {
         AdjustFlagsAndWidth(expressionBody);
         this.expressionBody = expressionBody;
      }
      var semicolonToken = (SyntaxToken)reader.ReadValue();
      if (semicolonToken != null)
      {
         AdjustFlagsAndWidth(semicolonToken);
         this.semicolonToken = semicolonToken;
      }
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.modifiers);
      writer.WriteValue(this.returnType);
      writer.WriteValue(this.identifier);
      writer.WriteValue(this.typeParameterList);
      writer.WriteValue(this.parameterList);
      writer.WriteValue(this.constraintClauses);
      writer.WriteValue(this.body);
      writer.WriteValue(this.expressionBody);
      writer.WriteValue(this.semicolonToken);
    }

    static LocalFunctionStatementSyntax()
    {
       ObjectBinder.RegisterTypeReader(typeof(LocalFunctionStatementSyntax), r => new LocalFunctionStatementSyntax(r));
    }
  }

  internal sealed partial class LocalDeclarationStatementSyntax : StatementSyntax
  {
    internal readonly GreenNode modifiers;
    internal readonly VariableDeclarationSyntax declaration;
    internal readonly SyntaxToken semicolonToken;

    internal LocalDeclarationStatementSyntax(SyntaxKind kind, GreenNode modifiers, VariableDeclarationSyntax declaration, SyntaxToken semicolonToken, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 3;
        if (modifiers != null)
        {
            this.AdjustFlagsAndWidth(modifiers);
            this.modifiers = modifiers;
        }
        this.AdjustFlagsAndWidth(declaration);
        this.declaration = declaration;
        this.AdjustFlagsAndWidth(semicolonToken);
        this.semicolonToken = semicolonToken;
    }


    internal LocalDeclarationStatementSyntax(SyntaxKind kind, GreenNode modifiers, VariableDeclarationSyntax declaration, SyntaxToken semicolonToken, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 3;
        if (modifiers != null)
        {
            this.AdjustFlagsAndWidth(modifiers);
            this.modifiers = modifiers;
        }
        this.AdjustFlagsAndWidth(declaration);
        this.declaration = declaration;
        this.AdjustFlagsAndWidth(semicolonToken);
        this.semicolonToken = semicolonToken;
    }


    internal LocalDeclarationStatementSyntax(SyntaxKind kind, GreenNode modifiers, VariableDeclarationSyntax declaration, SyntaxToken semicolonToken)
        : base(kind)
    {
        this.SlotCount = 3;
        if (modifiers != null)
        {
            this.AdjustFlagsAndWidth(modifiers);
            this.modifiers = modifiers;
        }
        this.AdjustFlagsAndWidth(declaration);
        this.declaration = declaration;
        this.AdjustFlagsAndWidth(semicolonToken);
        this.semicolonToken = semicolonToken;
    }

    /// <summary>Gets the modifier list.</summary>
    public Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SyntaxToken> Modifiers { get { return new Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SyntaxToken>(this.modifiers); } }
    public VariableDeclarationSyntax Declaration { get { return this.declaration; } }
    public SyntaxToken SemicolonToken { get { return this.semicolonToken; } }

    internal override GreenNode GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.modifiers;
            case 1: return this.declaration;
            case 2: return this.semicolonToken;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode parent, int position)
    {
      return new CSharp.Syntax.LocalDeclarationStatementSyntax(this, parent, position);
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitLocalDeclarationStatement(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitLocalDeclarationStatement(this);
    }

    public LocalDeclarationStatementSyntax Update(Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SyntaxToken> modifiers, VariableDeclarationSyntax declaration, SyntaxToken semicolonToken)
    {
        if (modifiers != this.Modifiers || declaration != this.Declaration || semicolonToken != this.SemicolonToken)
        {
            var newNode = SyntaxFactory.LocalDeclarationStatement(modifiers, declaration, semicolonToken);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
    {
         return new LocalDeclarationStatementSyntax(this.Kind, this.modifiers, this.declaration, this.semicolonToken, diagnostics, GetAnnotations());
    }

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
    {
         return new LocalDeclarationStatementSyntax(this.Kind, this.modifiers, this.declaration, this.semicolonToken, GetDiagnostics(), annotations);
    }

    internal LocalDeclarationStatementSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 3;
      var modifiers = (GreenNode)reader.ReadValue();
      if (modifiers != null)
      {
         AdjustFlagsAndWidth(modifiers);
         this.modifiers = modifiers;
      }
      var declaration = (VariableDeclarationSyntax)reader.ReadValue();
      if (declaration != null)
      {
         AdjustFlagsAndWidth(declaration);
         this.declaration = declaration;
      }
      var semicolonToken = (SyntaxToken)reader.ReadValue();
      if (semicolonToken != null)
      {
         AdjustFlagsAndWidth(semicolonToken);
         this.semicolonToken = semicolonToken;
      }
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.modifiers);
      writer.WriteValue(this.declaration);
      writer.WriteValue(this.semicolonToken);
    }

    static LocalDeclarationStatementSyntax()
    {
       ObjectBinder.RegisterTypeReader(typeof(LocalDeclarationStatementSyntax), r => new LocalDeclarationStatementSyntax(r));
    }
  }

  internal sealed partial class VariableDeclarationSyntax : CSharpSyntaxNode
  {
    internal readonly TypeSyntax type;
    internal readonly GreenNode variables;

    internal VariableDeclarationSyntax(SyntaxKind kind, TypeSyntax type, GreenNode variables, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 2;
        this.AdjustFlagsAndWidth(type);
        this.type = type;
        if (variables != null)
        {
            this.AdjustFlagsAndWidth(variables);
            this.variables = variables;
        }
    }


    internal VariableDeclarationSyntax(SyntaxKind kind, TypeSyntax type, GreenNode variables, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 2;
        this.AdjustFlagsAndWidth(type);
        this.type = type;
        if (variables != null)
        {
            this.AdjustFlagsAndWidth(variables);
            this.variables = variables;
        }
    }


    internal VariableDeclarationSyntax(SyntaxKind kind, TypeSyntax type, GreenNode variables)
        : base(kind)
    {
        this.SlotCount = 2;
        this.AdjustFlagsAndWidth(type);
        this.type = type;
        if (variables != null)
        {
            this.AdjustFlagsAndWidth(variables);
            this.variables = variables;
        }
    }

    public TypeSyntax Type { get { return this.type; } }
    public Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<VariableDeclaratorSyntax> Variables { get { return new Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<VariableDeclaratorSyntax>(new Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<CSharpSyntaxNode>(this.variables)); } }

    internal override GreenNode GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.type;
            case 1: return this.variables;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode parent, int position)
    {
      return new CSharp.Syntax.VariableDeclarationSyntax(this, parent, position);
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitVariableDeclaration(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitVariableDeclaration(this);
    }

    public VariableDeclarationSyntax Update(TypeSyntax type, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<VariableDeclaratorSyntax> variables)
    {
        if (type != this.Type || variables != this.Variables)
        {
            var newNode = SyntaxFactory.VariableDeclaration(type, variables);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
    {
         return new VariableDeclarationSyntax(this.Kind, this.type, this.variables, diagnostics, GetAnnotations());
    }

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
    {
         return new VariableDeclarationSyntax(this.Kind, this.type, this.variables, GetDiagnostics(), annotations);
    }

    internal VariableDeclarationSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 2;
      var type = (TypeSyntax)reader.ReadValue();
      if (type != null)
      {
         AdjustFlagsAndWidth(type);
         this.type = type;
      }
      var variables = (GreenNode)reader.ReadValue();
      if (variables != null)
      {
         AdjustFlagsAndWidth(variables);
         this.variables = variables;
      }
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.type);
      writer.WriteValue(this.variables);
    }

    static VariableDeclarationSyntax()
    {
       ObjectBinder.RegisterTypeReader(typeof(VariableDeclarationSyntax), r => new VariableDeclarationSyntax(r));
    }
  }

  internal sealed partial class VariableDeclaratorSyntax : CSharpSyntaxNode
  {
    internal readonly SyntaxToken identifier;
    internal readonly BracketedArgumentListSyntax argumentList;
    internal readonly EqualsValueClauseSyntax initializer;

    internal VariableDeclaratorSyntax(SyntaxKind kind, SyntaxToken identifier, BracketedArgumentListSyntax argumentList, EqualsValueClauseSyntax initializer, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 3;
        this.AdjustFlagsAndWidth(identifier);
        this.identifier = identifier;
        if (argumentList != null)
        {
            this.AdjustFlagsAndWidth(argumentList);
            this.argumentList = argumentList;
        }
        if (initializer != null)
        {
            this.AdjustFlagsAndWidth(initializer);
            this.initializer = initializer;
        }
    }


    internal VariableDeclaratorSyntax(SyntaxKind kind, SyntaxToken identifier, BracketedArgumentListSyntax argumentList, EqualsValueClauseSyntax initializer, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 3;
        this.AdjustFlagsAndWidth(identifier);
        this.identifier = identifier;
        if (argumentList != null)
        {
            this.AdjustFlagsAndWidth(argumentList);
            this.argumentList = argumentList;
        }
        if (initializer != null)
        {
            this.AdjustFlagsAndWidth(initializer);
            this.initializer = initializer;
        }
    }


    internal VariableDeclaratorSyntax(SyntaxKind kind, SyntaxToken identifier, BracketedArgumentListSyntax argumentList, EqualsValueClauseSyntax initializer)
        : base(kind)
    {
        this.SlotCount = 3;
        this.AdjustFlagsAndWidth(identifier);
        this.identifier = identifier;
        if (argumentList != null)
        {
            this.AdjustFlagsAndWidth(argumentList);
            this.argumentList = argumentList;
        }
        if (initializer != null)
        {
            this.AdjustFlagsAndWidth(initializer);
            this.initializer = initializer;
        }
    }

    /// <summary>Gets the identifier.</summary>
    public SyntaxToken Identifier { get { return this.identifier; } }
    public BracketedArgumentListSyntax ArgumentList { get { return this.argumentList; } }
    public EqualsValueClauseSyntax Initializer { get { return this.initializer; } }

    internal override GreenNode GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.identifier;
            case 1: return this.argumentList;
            case 2: return this.initializer;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode parent, int position)
    {
      return new CSharp.Syntax.VariableDeclaratorSyntax(this, parent, position);
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitVariableDeclarator(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitVariableDeclarator(this);
    }

    public VariableDeclaratorSyntax Update(SyntaxToken identifier, BracketedArgumentListSyntax argumentList, EqualsValueClauseSyntax initializer)
    {
        if (identifier != this.Identifier || argumentList != this.ArgumentList || initializer != this.Initializer)
        {
            var newNode = SyntaxFactory.VariableDeclarator(identifier, argumentList, initializer);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
    {
         return new VariableDeclaratorSyntax(this.Kind, this.identifier, this.argumentList, this.initializer, diagnostics, GetAnnotations());
    }

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
    {
         return new VariableDeclaratorSyntax(this.Kind, this.identifier, this.argumentList, this.initializer, GetDiagnostics(), annotations);
    }

    internal VariableDeclaratorSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 3;
      var identifier = (SyntaxToken)reader.ReadValue();
      if (identifier != null)
      {
         AdjustFlagsAndWidth(identifier);
         this.identifier = identifier;
      }
      var argumentList = (BracketedArgumentListSyntax)reader.ReadValue();
      if (argumentList != null)
      {
         AdjustFlagsAndWidth(argumentList);
         this.argumentList = argumentList;
      }
      var initializer = (EqualsValueClauseSyntax)reader.ReadValue();
      if (initializer != null)
      {
         AdjustFlagsAndWidth(initializer);
         this.initializer = initializer;
      }
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.identifier);
      writer.WriteValue(this.argumentList);
      writer.WriteValue(this.initializer);
    }

    static VariableDeclaratorSyntax()
    {
       ObjectBinder.RegisterTypeReader(typeof(VariableDeclaratorSyntax), r => new VariableDeclaratorSyntax(r));
    }
  }

  internal sealed partial class EqualsValueClauseSyntax : CSharpSyntaxNode
  {
    internal readonly SyntaxToken equalsToken;
    internal readonly ExpressionSyntax value;

    internal EqualsValueClauseSyntax(SyntaxKind kind, SyntaxToken equalsToken, ExpressionSyntax value, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 2;
        this.AdjustFlagsAndWidth(equalsToken);
        this.equalsToken = equalsToken;
        this.AdjustFlagsAndWidth(value);
        this.value = value;
    }


    internal EqualsValueClauseSyntax(SyntaxKind kind, SyntaxToken equalsToken, ExpressionSyntax value, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 2;
        this.AdjustFlagsAndWidth(equalsToken);
        this.equalsToken = equalsToken;
        this.AdjustFlagsAndWidth(value);
        this.value = value;
    }


    internal EqualsValueClauseSyntax(SyntaxKind kind, SyntaxToken equalsToken, ExpressionSyntax value)
        : base(kind)
    {
        this.SlotCount = 2;
        this.AdjustFlagsAndWidth(equalsToken);
        this.equalsToken = equalsToken;
        this.AdjustFlagsAndWidth(value);
        this.value = value;
    }

    public SyntaxToken EqualsToken { get { return this.equalsToken; } }
    public ExpressionSyntax Value { get { return this.value; } }

    internal override GreenNode GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.equalsToken;
            case 1: return this.value;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode parent, int position)
    {
      return new CSharp.Syntax.EqualsValueClauseSyntax(this, parent, position);
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitEqualsValueClause(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitEqualsValueClause(this);
    }

    public EqualsValueClauseSyntax Update(SyntaxToken equalsToken, ExpressionSyntax value)
    {
        if (equalsToken != this.EqualsToken || value != this.Value)
        {
            var newNode = SyntaxFactory.EqualsValueClause(equalsToken, value);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
    {
         return new EqualsValueClauseSyntax(this.Kind, this.equalsToken, this.value, diagnostics, GetAnnotations());
    }

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
    {
         return new EqualsValueClauseSyntax(this.Kind, this.equalsToken, this.value, GetDiagnostics(), annotations);
    }

    internal EqualsValueClauseSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 2;
      var equalsToken = (SyntaxToken)reader.ReadValue();
      if (equalsToken != null)
      {
         AdjustFlagsAndWidth(equalsToken);
         this.equalsToken = equalsToken;
      }
      var value = (ExpressionSyntax)reader.ReadValue();
      if (value != null)
      {
         AdjustFlagsAndWidth(value);
         this.value = value;
      }
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.equalsToken);
      writer.WriteValue(this.value);
    }

    static EqualsValueClauseSyntax()
    {
       ObjectBinder.RegisterTypeReader(typeof(EqualsValueClauseSyntax), r => new EqualsValueClauseSyntax(r));
    }
  }

  internal abstract partial class VariableDesignationSyntax : CSharpSyntaxNode
  {
    internal VariableDesignationSyntax(SyntaxKind kind, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
      : base(kind, diagnostics, annotations)
    {
    }
    internal VariableDesignationSyntax(SyntaxKind kind)
      : base(kind)
    {
    }

    protected VariableDesignationSyntax(ObjectReader reader)
       : base(reader)
    {
    }
  }

  internal sealed partial class SingleVariableDesignationSyntax : VariableDesignationSyntax
  {
    internal readonly SyntaxToken identifier;

    internal SingleVariableDesignationSyntax(SyntaxKind kind, SyntaxToken identifier, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 1;
        this.AdjustFlagsAndWidth(identifier);
        this.identifier = identifier;
    }


    internal SingleVariableDesignationSyntax(SyntaxKind kind, SyntaxToken identifier, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 1;
        this.AdjustFlagsAndWidth(identifier);
        this.identifier = identifier;
    }


    internal SingleVariableDesignationSyntax(SyntaxKind kind, SyntaxToken identifier)
        : base(kind)
    {
        this.SlotCount = 1;
        this.AdjustFlagsAndWidth(identifier);
        this.identifier = identifier;
    }

    public SyntaxToken Identifier { get { return this.identifier; } }

    internal override GreenNode GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.identifier;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode parent, int position)
    {
      return new CSharp.Syntax.SingleVariableDesignationSyntax(this, parent, position);
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitSingleVariableDesignation(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitSingleVariableDesignation(this);
    }

    public SingleVariableDesignationSyntax Update(SyntaxToken identifier)
    {
        if (identifier != this.Identifier)
        {
            var newNode = SyntaxFactory.SingleVariableDesignation(identifier);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
    {
         return new SingleVariableDesignationSyntax(this.Kind, this.identifier, diagnostics, GetAnnotations());
    }

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
    {
         return new SingleVariableDesignationSyntax(this.Kind, this.identifier, GetDiagnostics(), annotations);
    }

    internal SingleVariableDesignationSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 1;
      var identifier = (SyntaxToken)reader.ReadValue();
      if (identifier != null)
      {
         AdjustFlagsAndWidth(identifier);
         this.identifier = identifier;
      }
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.identifier);
    }

    static SingleVariableDesignationSyntax()
    {
       ObjectBinder.RegisterTypeReader(typeof(SingleVariableDesignationSyntax), r => new SingleVariableDesignationSyntax(r));
    }
  }

  internal sealed partial class DiscardDesignationSyntax : VariableDesignationSyntax
  {
    internal readonly SyntaxToken underscoreToken;

    internal DiscardDesignationSyntax(SyntaxKind kind, SyntaxToken underscoreToken, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 1;
        this.AdjustFlagsAndWidth(underscoreToken);
        this.underscoreToken = underscoreToken;
    }


    internal DiscardDesignationSyntax(SyntaxKind kind, SyntaxToken underscoreToken, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 1;
        this.AdjustFlagsAndWidth(underscoreToken);
        this.underscoreToken = underscoreToken;
    }


    internal DiscardDesignationSyntax(SyntaxKind kind, SyntaxToken underscoreToken)
        : base(kind)
    {
        this.SlotCount = 1;
        this.AdjustFlagsAndWidth(underscoreToken);
        this.underscoreToken = underscoreToken;
    }

    public SyntaxToken UnderscoreToken { get { return this.underscoreToken; } }

    internal override GreenNode GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.underscoreToken;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode parent, int position)
    {
      return new CSharp.Syntax.DiscardDesignationSyntax(this, parent, position);
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitDiscardDesignation(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitDiscardDesignation(this);
    }

    public DiscardDesignationSyntax Update(SyntaxToken underscoreToken)
    {
        if (underscoreToken != this.UnderscoreToken)
        {
            var newNode = SyntaxFactory.DiscardDesignation(underscoreToken);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
    {
         return new DiscardDesignationSyntax(this.Kind, this.underscoreToken, diagnostics, GetAnnotations());
    }

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
    {
         return new DiscardDesignationSyntax(this.Kind, this.underscoreToken, GetDiagnostics(), annotations);
    }

    internal DiscardDesignationSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 1;
      var underscoreToken = (SyntaxToken)reader.ReadValue();
      if (underscoreToken != null)
      {
         AdjustFlagsAndWidth(underscoreToken);
         this.underscoreToken = underscoreToken;
      }
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.underscoreToken);
    }

    static DiscardDesignationSyntax()
    {
       ObjectBinder.RegisterTypeReader(typeof(DiscardDesignationSyntax), r => new DiscardDesignationSyntax(r));
    }
  }

  internal sealed partial class ParenthesizedVariableDesignationSyntax : VariableDesignationSyntax
  {
    internal readonly SyntaxToken openParenToken;
    internal readonly GreenNode variables;
    internal readonly SyntaxToken closeParenToken;

    internal ParenthesizedVariableDesignationSyntax(SyntaxKind kind, SyntaxToken openParenToken, GreenNode variables, SyntaxToken closeParenToken, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 3;
        this.AdjustFlagsAndWidth(openParenToken);
        this.openParenToken = openParenToken;
        if (variables != null)
        {
            this.AdjustFlagsAndWidth(variables);
            this.variables = variables;
        }
        this.AdjustFlagsAndWidth(closeParenToken);
        this.closeParenToken = closeParenToken;
    }


    internal ParenthesizedVariableDesignationSyntax(SyntaxKind kind, SyntaxToken openParenToken, GreenNode variables, SyntaxToken closeParenToken, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 3;
        this.AdjustFlagsAndWidth(openParenToken);
        this.openParenToken = openParenToken;
        if (variables != null)
        {
            this.AdjustFlagsAndWidth(variables);
            this.variables = variables;
        }
        this.AdjustFlagsAndWidth(closeParenToken);
        this.closeParenToken = closeParenToken;
    }


    internal ParenthesizedVariableDesignationSyntax(SyntaxKind kind, SyntaxToken openParenToken, GreenNode variables, SyntaxToken closeParenToken)
        : base(kind)
    {
        this.SlotCount = 3;
        this.AdjustFlagsAndWidth(openParenToken);
        this.openParenToken = openParenToken;
        if (variables != null)
        {
            this.AdjustFlagsAndWidth(variables);
            this.variables = variables;
        }
        this.AdjustFlagsAndWidth(closeParenToken);
        this.closeParenToken = closeParenToken;
    }

    public SyntaxToken OpenParenToken { get { return this.openParenToken; } }
    public Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<VariableDesignationSyntax> Variables { get { return new Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<VariableDesignationSyntax>(new Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<CSharpSyntaxNode>(this.variables)); } }
    public SyntaxToken CloseParenToken { get { return this.closeParenToken; } }

    internal override GreenNode GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.openParenToken;
            case 1: return this.variables;
            case 2: return this.closeParenToken;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode parent, int position)
    {
      return new CSharp.Syntax.ParenthesizedVariableDesignationSyntax(this, parent, position);
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitParenthesizedVariableDesignation(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitParenthesizedVariableDesignation(this);
    }

    public ParenthesizedVariableDesignationSyntax Update(SyntaxToken openParenToken, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<VariableDesignationSyntax> variables, SyntaxToken closeParenToken)
    {
        if (openParenToken != this.OpenParenToken || variables != this.Variables || closeParenToken != this.CloseParenToken)
        {
            var newNode = SyntaxFactory.ParenthesizedVariableDesignation(openParenToken, variables, closeParenToken);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
    {
         return new ParenthesizedVariableDesignationSyntax(this.Kind, this.openParenToken, this.variables, this.closeParenToken, diagnostics, GetAnnotations());
    }

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
    {
         return new ParenthesizedVariableDesignationSyntax(this.Kind, this.openParenToken, this.variables, this.closeParenToken, GetDiagnostics(), annotations);
    }

    internal ParenthesizedVariableDesignationSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 3;
      var openParenToken = (SyntaxToken)reader.ReadValue();
      if (openParenToken != null)
      {
         AdjustFlagsAndWidth(openParenToken);
         this.openParenToken = openParenToken;
      }
      var variables = (GreenNode)reader.ReadValue();
      if (variables != null)
      {
         AdjustFlagsAndWidth(variables);
         this.variables = variables;
      }
      var closeParenToken = (SyntaxToken)reader.ReadValue();
      if (closeParenToken != null)
      {
         AdjustFlagsAndWidth(closeParenToken);
         this.closeParenToken = closeParenToken;
      }
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.openParenToken);
      writer.WriteValue(this.variables);
      writer.WriteValue(this.closeParenToken);
    }

    static ParenthesizedVariableDesignationSyntax()
    {
       ObjectBinder.RegisterTypeReader(typeof(ParenthesizedVariableDesignationSyntax), r => new ParenthesizedVariableDesignationSyntax(r));
    }
  }

  internal sealed partial class ExpressionStatementSyntax : StatementSyntax
  {
    internal readonly ExpressionSyntax expression;
    internal readonly SyntaxToken semicolonToken;

    internal ExpressionStatementSyntax(SyntaxKind kind, ExpressionSyntax expression, SyntaxToken semicolonToken, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 2;
        this.AdjustFlagsAndWidth(expression);
        this.expression = expression;
        this.AdjustFlagsAndWidth(semicolonToken);
        this.semicolonToken = semicolonToken;
    }


    internal ExpressionStatementSyntax(SyntaxKind kind, ExpressionSyntax expression, SyntaxToken semicolonToken, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 2;
        this.AdjustFlagsAndWidth(expression);
        this.expression = expression;
        this.AdjustFlagsAndWidth(semicolonToken);
        this.semicolonToken = semicolonToken;
    }


    internal ExpressionStatementSyntax(SyntaxKind kind, ExpressionSyntax expression, SyntaxToken semicolonToken)
        : base(kind)
    {
        this.SlotCount = 2;
        this.AdjustFlagsAndWidth(expression);
        this.expression = expression;
        this.AdjustFlagsAndWidth(semicolonToken);
        this.semicolonToken = semicolonToken;
    }

    public ExpressionSyntax Expression { get { return this.expression; } }
    public SyntaxToken SemicolonToken { get { return this.semicolonToken; } }

    internal override GreenNode GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.expression;
            case 1: return this.semicolonToken;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode parent, int position)
    {
      return new CSharp.Syntax.ExpressionStatementSyntax(this, parent, position);
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitExpressionStatement(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitExpressionStatement(this);
    }

    public ExpressionStatementSyntax Update(ExpressionSyntax expression, SyntaxToken semicolonToken)
    {
        if (expression != this.Expression || semicolonToken != this.SemicolonToken)
        {
            var newNode = SyntaxFactory.ExpressionStatement(expression, semicolonToken);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
    {
         return new ExpressionStatementSyntax(this.Kind, this.expression, this.semicolonToken, diagnostics, GetAnnotations());
    }

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
    {
         return new ExpressionStatementSyntax(this.Kind, this.expression, this.semicolonToken, GetDiagnostics(), annotations);
    }

    internal ExpressionStatementSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 2;
      var expression = (ExpressionSyntax)reader.ReadValue();
      if (expression != null)
      {
         AdjustFlagsAndWidth(expression);
         this.expression = expression;
      }
      var semicolonToken = (SyntaxToken)reader.ReadValue();
      if (semicolonToken != null)
      {
         AdjustFlagsAndWidth(semicolonToken);
         this.semicolonToken = semicolonToken;
      }
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.expression);
      writer.WriteValue(this.semicolonToken);
    }

    static ExpressionStatementSyntax()
    {
       ObjectBinder.RegisterTypeReader(typeof(ExpressionStatementSyntax), r => new ExpressionStatementSyntax(r));
    }
  }

  internal sealed partial class EmptyStatementSyntax : StatementSyntax
  {
    internal readonly SyntaxToken semicolonToken;

    internal EmptyStatementSyntax(SyntaxKind kind, SyntaxToken semicolonToken, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 1;
        this.AdjustFlagsAndWidth(semicolonToken);
        this.semicolonToken = semicolonToken;
    }


    internal EmptyStatementSyntax(SyntaxKind kind, SyntaxToken semicolonToken, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 1;
        this.AdjustFlagsAndWidth(semicolonToken);
        this.semicolonToken = semicolonToken;
    }


    internal EmptyStatementSyntax(SyntaxKind kind, SyntaxToken semicolonToken)
        : base(kind)
    {
        this.SlotCount = 1;
        this.AdjustFlagsAndWidth(semicolonToken);
        this.semicolonToken = semicolonToken;
    }

    public SyntaxToken SemicolonToken { get { return this.semicolonToken; } }

    internal override GreenNode GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.semicolonToken;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode parent, int position)
    {
      return new CSharp.Syntax.EmptyStatementSyntax(this, parent, position);
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitEmptyStatement(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitEmptyStatement(this);
    }

    public EmptyStatementSyntax Update(SyntaxToken semicolonToken)
    {
        if (semicolonToken != this.SemicolonToken)
        {
            var newNode = SyntaxFactory.EmptyStatement(semicolonToken);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
    {
         return new EmptyStatementSyntax(this.Kind, this.semicolonToken, diagnostics, GetAnnotations());
    }

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
    {
         return new EmptyStatementSyntax(this.Kind, this.semicolonToken, GetDiagnostics(), annotations);
    }

    internal EmptyStatementSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 1;
      var semicolonToken = (SyntaxToken)reader.ReadValue();
      if (semicolonToken != null)
      {
         AdjustFlagsAndWidth(semicolonToken);
         this.semicolonToken = semicolonToken;
      }
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.semicolonToken);
    }

    static EmptyStatementSyntax()
    {
       ObjectBinder.RegisterTypeReader(typeof(EmptyStatementSyntax), r => new EmptyStatementSyntax(r));
    }
  }

  /// <summary>Represents a labeled statement syntax.</summary>
  internal sealed partial class LabeledStatementSyntax : StatementSyntax
  {
    internal readonly SyntaxToken identifier;
    internal readonly SyntaxToken colonToken;
    internal readonly StatementSyntax statement;

    internal LabeledStatementSyntax(SyntaxKind kind, SyntaxToken identifier, SyntaxToken colonToken, StatementSyntax statement, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 3;
        this.AdjustFlagsAndWidth(identifier);
        this.identifier = identifier;
        this.AdjustFlagsAndWidth(colonToken);
        this.colonToken = colonToken;
        this.AdjustFlagsAndWidth(statement);
        this.statement = statement;
    }


    internal LabeledStatementSyntax(SyntaxKind kind, SyntaxToken identifier, SyntaxToken colonToken, StatementSyntax statement, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 3;
        this.AdjustFlagsAndWidth(identifier);
        this.identifier = identifier;
        this.AdjustFlagsAndWidth(colonToken);
        this.colonToken = colonToken;
        this.AdjustFlagsAndWidth(statement);
        this.statement = statement;
    }


    internal LabeledStatementSyntax(SyntaxKind kind, SyntaxToken identifier, SyntaxToken colonToken, StatementSyntax statement)
        : base(kind)
    {
        this.SlotCount = 3;
        this.AdjustFlagsAndWidth(identifier);
        this.identifier = identifier;
        this.AdjustFlagsAndWidth(colonToken);
        this.colonToken = colonToken;
        this.AdjustFlagsAndWidth(statement);
        this.statement = statement;
    }

    /// <summary>Gets the identifier.</summary>
    public SyntaxToken Identifier { get { return this.identifier; } }
    /// <summary>Gets a SyntaxToken that represents the colon succeeding the statement's label.</summary>
    public SyntaxToken ColonToken { get { return this.colonToken; } }
    public StatementSyntax Statement { get { return this.statement; } }

    internal override GreenNode GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.identifier;
            case 1: return this.colonToken;
            case 2: return this.statement;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode parent, int position)
    {
      return new CSharp.Syntax.LabeledStatementSyntax(this, parent, position);
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitLabeledStatement(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitLabeledStatement(this);
    }

    public LabeledStatementSyntax Update(SyntaxToken identifier, SyntaxToken colonToken, StatementSyntax statement)
    {
        if (identifier != this.Identifier || colonToken != this.ColonToken || statement != this.Statement)
        {
            var newNode = SyntaxFactory.LabeledStatement(identifier, colonToken, statement);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
    {
         return new LabeledStatementSyntax(this.Kind, this.identifier, this.colonToken, this.statement, diagnostics, GetAnnotations());
    }

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
    {
         return new LabeledStatementSyntax(this.Kind, this.identifier, this.colonToken, this.statement, GetDiagnostics(), annotations);
    }

    internal LabeledStatementSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 3;
      var identifier = (SyntaxToken)reader.ReadValue();
      if (identifier != null)
      {
         AdjustFlagsAndWidth(identifier);
         this.identifier = identifier;
      }
      var colonToken = (SyntaxToken)reader.ReadValue();
      if (colonToken != null)
      {
         AdjustFlagsAndWidth(colonToken);
         this.colonToken = colonToken;
      }
      var statement = (StatementSyntax)reader.ReadValue();
      if (statement != null)
      {
         AdjustFlagsAndWidth(statement);
         this.statement = statement;
      }
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.identifier);
      writer.WriteValue(this.colonToken);
      writer.WriteValue(this.statement);
    }

    static LabeledStatementSyntax()
    {
       ObjectBinder.RegisterTypeReader(typeof(LabeledStatementSyntax), r => new LabeledStatementSyntax(r));
    }
  }

  /// <summary>
  /// Represents a goto statement syntax
  /// </summary>
  internal sealed partial class GotoStatementSyntax : StatementSyntax
  {
    internal readonly SyntaxToken gotoKeyword;
    internal readonly SyntaxToken caseOrDefaultKeyword;
    internal readonly ExpressionSyntax expression;
    internal readonly SyntaxToken semicolonToken;

    internal GotoStatementSyntax(SyntaxKind kind, SyntaxToken gotoKeyword, SyntaxToken caseOrDefaultKeyword, ExpressionSyntax expression, SyntaxToken semicolonToken, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 4;
        this.AdjustFlagsAndWidth(gotoKeyword);
        this.gotoKeyword = gotoKeyword;
        if (caseOrDefaultKeyword != null)
        {
            this.AdjustFlagsAndWidth(caseOrDefaultKeyword);
            this.caseOrDefaultKeyword = caseOrDefaultKeyword;
        }
        if (expression != null)
        {
            this.AdjustFlagsAndWidth(expression);
            this.expression = expression;
        }
        this.AdjustFlagsAndWidth(semicolonToken);
        this.semicolonToken = semicolonToken;
    }


    internal GotoStatementSyntax(SyntaxKind kind, SyntaxToken gotoKeyword, SyntaxToken caseOrDefaultKeyword, ExpressionSyntax expression, SyntaxToken semicolonToken, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 4;
        this.AdjustFlagsAndWidth(gotoKeyword);
        this.gotoKeyword = gotoKeyword;
        if (caseOrDefaultKeyword != null)
        {
            this.AdjustFlagsAndWidth(caseOrDefaultKeyword);
            this.caseOrDefaultKeyword = caseOrDefaultKeyword;
        }
        if (expression != null)
        {
            this.AdjustFlagsAndWidth(expression);
            this.expression = expression;
        }
        this.AdjustFlagsAndWidth(semicolonToken);
        this.semicolonToken = semicolonToken;
    }


    internal GotoStatementSyntax(SyntaxKind kind, SyntaxToken gotoKeyword, SyntaxToken caseOrDefaultKeyword, ExpressionSyntax expression, SyntaxToken semicolonToken)
        : base(kind)
    {
        this.SlotCount = 4;
        this.AdjustFlagsAndWidth(gotoKeyword);
        this.gotoKeyword = gotoKeyword;
        if (caseOrDefaultKeyword != null)
        {
            this.AdjustFlagsAndWidth(caseOrDefaultKeyword);
            this.caseOrDefaultKeyword = caseOrDefaultKeyword;
        }
        if (expression != null)
        {
            this.AdjustFlagsAndWidth(expression);
            this.expression = expression;
        }
        this.AdjustFlagsAndWidth(semicolonToken);
        this.semicolonToken = semicolonToken;
    }

    /// <summary>
    /// Gets a SyntaxToken that represents the goto keyword.
    /// </summary>
    public SyntaxToken GotoKeyword { get { return this.gotoKeyword; } }
    /// <summary>
    /// Gets a SyntaxToken that represents the case or default keywords if any exists.
    /// </summary>
    public SyntaxToken CaseOrDefaultKeyword { get { return this.caseOrDefaultKeyword; } }
    /// <summary>
    /// Gets a constant expression for a goto case statement.
    /// </summary>
    public ExpressionSyntax Expression { get { return this.expression; } }
    /// <summary>
    /// Gets a SyntaxToken that represents the semi-colon at the end of the statement.
    /// </summary>
    public SyntaxToken SemicolonToken { get { return this.semicolonToken; } }

    internal override GreenNode GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.gotoKeyword;
            case 1: return this.caseOrDefaultKeyword;
            case 2: return this.expression;
            case 3: return this.semicolonToken;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode parent, int position)
    {
      return new CSharp.Syntax.GotoStatementSyntax(this, parent, position);
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitGotoStatement(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitGotoStatement(this);
    }

    public GotoStatementSyntax Update(SyntaxToken gotoKeyword, SyntaxToken caseOrDefaultKeyword, ExpressionSyntax expression, SyntaxToken semicolonToken)
    {
        if (gotoKeyword != this.GotoKeyword || caseOrDefaultKeyword != this.CaseOrDefaultKeyword || expression != this.Expression || semicolonToken != this.SemicolonToken)
        {
            var newNode = SyntaxFactory.GotoStatement(this.Kind, gotoKeyword, caseOrDefaultKeyword, expression, semicolonToken);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
    {
         return new GotoStatementSyntax(this.Kind, this.gotoKeyword, this.caseOrDefaultKeyword, this.expression, this.semicolonToken, diagnostics, GetAnnotations());
    }

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
    {
         return new GotoStatementSyntax(this.Kind, this.gotoKeyword, this.caseOrDefaultKeyword, this.expression, this.semicolonToken, GetDiagnostics(), annotations);
    }

    internal GotoStatementSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 4;
      var gotoKeyword = (SyntaxToken)reader.ReadValue();
      if (gotoKeyword != null)
      {
         AdjustFlagsAndWidth(gotoKeyword);
         this.gotoKeyword = gotoKeyword;
      }
      var caseOrDefaultKeyword = (SyntaxToken)reader.ReadValue();
      if (caseOrDefaultKeyword != null)
      {
         AdjustFlagsAndWidth(caseOrDefaultKeyword);
         this.caseOrDefaultKeyword = caseOrDefaultKeyword;
      }
      var expression = (ExpressionSyntax)reader.ReadValue();
      if (expression != null)
      {
         AdjustFlagsAndWidth(expression);
         this.expression = expression;
      }
      var semicolonToken = (SyntaxToken)reader.ReadValue();
      if (semicolonToken != null)
      {
         AdjustFlagsAndWidth(semicolonToken);
         this.semicolonToken = semicolonToken;
      }
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.gotoKeyword);
      writer.WriteValue(this.caseOrDefaultKeyword);
      writer.WriteValue(this.expression);
      writer.WriteValue(this.semicolonToken);
    }

    static GotoStatementSyntax()
    {
       ObjectBinder.RegisterTypeReader(typeof(GotoStatementSyntax), r => new GotoStatementSyntax(r));
    }
  }

  internal sealed partial class BreakStatementSyntax : StatementSyntax
  {
    internal readonly SyntaxToken breakKeyword;
    internal readonly SyntaxToken semicolonToken;

    internal BreakStatementSyntax(SyntaxKind kind, SyntaxToken breakKeyword, SyntaxToken semicolonToken, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 2;
        this.AdjustFlagsAndWidth(breakKeyword);
        this.breakKeyword = breakKeyword;
        this.AdjustFlagsAndWidth(semicolonToken);
        this.semicolonToken = semicolonToken;
    }


    internal BreakStatementSyntax(SyntaxKind kind, SyntaxToken breakKeyword, SyntaxToken semicolonToken, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 2;
        this.AdjustFlagsAndWidth(breakKeyword);
        this.breakKeyword = breakKeyword;
        this.AdjustFlagsAndWidth(semicolonToken);
        this.semicolonToken = semicolonToken;
    }


    internal BreakStatementSyntax(SyntaxKind kind, SyntaxToken breakKeyword, SyntaxToken semicolonToken)
        : base(kind)
    {
        this.SlotCount = 2;
        this.AdjustFlagsAndWidth(breakKeyword);
        this.breakKeyword = breakKeyword;
        this.AdjustFlagsAndWidth(semicolonToken);
        this.semicolonToken = semicolonToken;
    }

    public SyntaxToken BreakKeyword { get { return this.breakKeyword; } }
    public SyntaxToken SemicolonToken { get { return this.semicolonToken; } }

    internal override GreenNode GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.breakKeyword;
            case 1: return this.semicolonToken;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode parent, int position)
    {
      return new CSharp.Syntax.BreakStatementSyntax(this, parent, position);
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitBreakStatement(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitBreakStatement(this);
    }

    public BreakStatementSyntax Update(SyntaxToken breakKeyword, SyntaxToken semicolonToken)
    {
        if (breakKeyword != this.BreakKeyword || semicolonToken != this.SemicolonToken)
        {
            var newNode = SyntaxFactory.BreakStatement(breakKeyword, semicolonToken);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
    {
         return new BreakStatementSyntax(this.Kind, this.breakKeyword, this.semicolonToken, diagnostics, GetAnnotations());
    }

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
    {
         return new BreakStatementSyntax(this.Kind, this.breakKeyword, this.semicolonToken, GetDiagnostics(), annotations);
    }

    internal BreakStatementSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 2;
      var breakKeyword = (SyntaxToken)reader.ReadValue();
      if (breakKeyword != null)
      {
         AdjustFlagsAndWidth(breakKeyword);
         this.breakKeyword = breakKeyword;
      }
      var semicolonToken = (SyntaxToken)reader.ReadValue();
      if (semicolonToken != null)
      {
         AdjustFlagsAndWidth(semicolonToken);
         this.semicolonToken = semicolonToken;
      }
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.breakKeyword);
      writer.WriteValue(this.semicolonToken);
    }

    static BreakStatementSyntax()
    {
       ObjectBinder.RegisterTypeReader(typeof(BreakStatementSyntax), r => new BreakStatementSyntax(r));
    }
  }

  internal sealed partial class ContinueStatementSyntax : StatementSyntax
  {
    internal readonly SyntaxToken continueKeyword;
    internal readonly SyntaxToken semicolonToken;

    internal ContinueStatementSyntax(SyntaxKind kind, SyntaxToken continueKeyword, SyntaxToken semicolonToken, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 2;
        this.AdjustFlagsAndWidth(continueKeyword);
        this.continueKeyword = continueKeyword;
        this.AdjustFlagsAndWidth(semicolonToken);
        this.semicolonToken = semicolonToken;
    }


    internal ContinueStatementSyntax(SyntaxKind kind, SyntaxToken continueKeyword, SyntaxToken semicolonToken, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 2;
        this.AdjustFlagsAndWidth(continueKeyword);
        this.continueKeyword = continueKeyword;
        this.AdjustFlagsAndWidth(semicolonToken);
        this.semicolonToken = semicolonToken;
    }


    internal ContinueStatementSyntax(SyntaxKind kind, SyntaxToken continueKeyword, SyntaxToken semicolonToken)
        : base(kind)
    {
        this.SlotCount = 2;
        this.AdjustFlagsAndWidth(continueKeyword);
        this.continueKeyword = continueKeyword;
        this.AdjustFlagsAndWidth(semicolonToken);
        this.semicolonToken = semicolonToken;
    }

    public SyntaxToken ContinueKeyword { get { return this.continueKeyword; } }
    public SyntaxToken SemicolonToken { get { return this.semicolonToken; } }

    internal override GreenNode GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.continueKeyword;
            case 1: return this.semicolonToken;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode parent, int position)
    {
      return new CSharp.Syntax.ContinueStatementSyntax(this, parent, position);
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitContinueStatement(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitContinueStatement(this);
    }

    public ContinueStatementSyntax Update(SyntaxToken continueKeyword, SyntaxToken semicolonToken)
    {
        if (continueKeyword != this.ContinueKeyword || semicolonToken != this.SemicolonToken)
        {
            var newNode = SyntaxFactory.ContinueStatement(continueKeyword, semicolonToken);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
    {
         return new ContinueStatementSyntax(this.Kind, this.continueKeyword, this.semicolonToken, diagnostics, GetAnnotations());
    }

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
    {
         return new ContinueStatementSyntax(this.Kind, this.continueKeyword, this.semicolonToken, GetDiagnostics(), annotations);
    }

    internal ContinueStatementSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 2;
      var continueKeyword = (SyntaxToken)reader.ReadValue();
      if (continueKeyword != null)
      {
         AdjustFlagsAndWidth(continueKeyword);
         this.continueKeyword = continueKeyword;
      }
      var semicolonToken = (SyntaxToken)reader.ReadValue();
      if (semicolonToken != null)
      {
         AdjustFlagsAndWidth(semicolonToken);
         this.semicolonToken = semicolonToken;
      }
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.continueKeyword);
      writer.WriteValue(this.semicolonToken);
    }

    static ContinueStatementSyntax()
    {
       ObjectBinder.RegisterTypeReader(typeof(ContinueStatementSyntax), r => new ContinueStatementSyntax(r));
    }
  }

  internal sealed partial class ReturnStatementSyntax : StatementSyntax
  {
    internal readonly SyntaxToken returnKeyword;
    internal readonly ExpressionSyntax expression;
    internal readonly SyntaxToken semicolonToken;

    internal ReturnStatementSyntax(SyntaxKind kind, SyntaxToken returnKeyword, ExpressionSyntax expression, SyntaxToken semicolonToken, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 3;
        this.AdjustFlagsAndWidth(returnKeyword);
        this.returnKeyword = returnKeyword;
        if (expression != null)
        {
            this.AdjustFlagsAndWidth(expression);
            this.expression = expression;
        }
        this.AdjustFlagsAndWidth(semicolonToken);
        this.semicolonToken = semicolonToken;
    }


    internal ReturnStatementSyntax(SyntaxKind kind, SyntaxToken returnKeyword, ExpressionSyntax expression, SyntaxToken semicolonToken, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 3;
        this.AdjustFlagsAndWidth(returnKeyword);
        this.returnKeyword = returnKeyword;
        if (expression != null)
        {
            this.AdjustFlagsAndWidth(expression);
            this.expression = expression;
        }
        this.AdjustFlagsAndWidth(semicolonToken);
        this.semicolonToken = semicolonToken;
    }


    internal ReturnStatementSyntax(SyntaxKind kind, SyntaxToken returnKeyword, ExpressionSyntax expression, SyntaxToken semicolonToken)
        : base(kind)
    {
        this.SlotCount = 3;
        this.AdjustFlagsAndWidth(returnKeyword);
        this.returnKeyword = returnKeyword;
        if (expression != null)
        {
            this.AdjustFlagsAndWidth(expression);
            this.expression = expression;
        }
        this.AdjustFlagsAndWidth(semicolonToken);
        this.semicolonToken = semicolonToken;
    }

    public SyntaxToken ReturnKeyword { get { return this.returnKeyword; } }
    public ExpressionSyntax Expression { get { return this.expression; } }
    public SyntaxToken SemicolonToken { get { return this.semicolonToken; } }

    internal override GreenNode GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.returnKeyword;
            case 1: return this.expression;
            case 2: return this.semicolonToken;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode parent, int position)
    {
      return new CSharp.Syntax.ReturnStatementSyntax(this, parent, position);
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitReturnStatement(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitReturnStatement(this);
    }

    public ReturnStatementSyntax Update(SyntaxToken returnKeyword, ExpressionSyntax expression, SyntaxToken semicolonToken)
    {
        if (returnKeyword != this.ReturnKeyword || expression != this.Expression || semicolonToken != this.SemicolonToken)
        {
            var newNode = SyntaxFactory.ReturnStatement(returnKeyword, expression, semicolonToken);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
    {
         return new ReturnStatementSyntax(this.Kind, this.returnKeyword, this.expression, this.semicolonToken, diagnostics, GetAnnotations());
    }

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
    {
         return new ReturnStatementSyntax(this.Kind, this.returnKeyword, this.expression, this.semicolonToken, GetDiagnostics(), annotations);
    }

    internal ReturnStatementSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 3;
      var returnKeyword = (SyntaxToken)reader.ReadValue();
      if (returnKeyword != null)
      {
         AdjustFlagsAndWidth(returnKeyword);
         this.returnKeyword = returnKeyword;
      }
      var expression = (ExpressionSyntax)reader.ReadValue();
      if (expression != null)
      {
         AdjustFlagsAndWidth(expression);
         this.expression = expression;
      }
      var semicolonToken = (SyntaxToken)reader.ReadValue();
      if (semicolonToken != null)
      {
         AdjustFlagsAndWidth(semicolonToken);
         this.semicolonToken = semicolonToken;
      }
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.returnKeyword);
      writer.WriteValue(this.expression);
      writer.WriteValue(this.semicolonToken);
    }

    static ReturnStatementSyntax()
    {
       ObjectBinder.RegisterTypeReader(typeof(ReturnStatementSyntax), r => new ReturnStatementSyntax(r));
    }
  }

  internal sealed partial class ThrowStatementSyntax : StatementSyntax
  {
    internal readonly SyntaxToken throwKeyword;
    internal readonly ExpressionSyntax expression;
    internal readonly SyntaxToken semicolonToken;

    internal ThrowStatementSyntax(SyntaxKind kind, SyntaxToken throwKeyword, ExpressionSyntax expression, SyntaxToken semicolonToken, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 3;
        this.AdjustFlagsAndWidth(throwKeyword);
        this.throwKeyword = throwKeyword;
        if (expression != null)
        {
            this.AdjustFlagsAndWidth(expression);
            this.expression = expression;
        }
        this.AdjustFlagsAndWidth(semicolonToken);
        this.semicolonToken = semicolonToken;
    }


    internal ThrowStatementSyntax(SyntaxKind kind, SyntaxToken throwKeyword, ExpressionSyntax expression, SyntaxToken semicolonToken, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 3;
        this.AdjustFlagsAndWidth(throwKeyword);
        this.throwKeyword = throwKeyword;
        if (expression != null)
        {
            this.AdjustFlagsAndWidth(expression);
            this.expression = expression;
        }
        this.AdjustFlagsAndWidth(semicolonToken);
        this.semicolonToken = semicolonToken;
    }


    internal ThrowStatementSyntax(SyntaxKind kind, SyntaxToken throwKeyword, ExpressionSyntax expression, SyntaxToken semicolonToken)
        : base(kind)
    {
        this.SlotCount = 3;
        this.AdjustFlagsAndWidth(throwKeyword);
        this.throwKeyword = throwKeyword;
        if (expression != null)
        {
            this.AdjustFlagsAndWidth(expression);
            this.expression = expression;
        }
        this.AdjustFlagsAndWidth(semicolonToken);
        this.semicolonToken = semicolonToken;
    }

    public SyntaxToken ThrowKeyword { get { return this.throwKeyword; } }
    public ExpressionSyntax Expression { get { return this.expression; } }
    public SyntaxToken SemicolonToken { get { return this.semicolonToken; } }

    internal override GreenNode GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.throwKeyword;
            case 1: return this.expression;
            case 2: return this.semicolonToken;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode parent, int position)
    {
      return new CSharp.Syntax.ThrowStatementSyntax(this, parent, position);
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitThrowStatement(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitThrowStatement(this);
    }

    public ThrowStatementSyntax Update(SyntaxToken throwKeyword, ExpressionSyntax expression, SyntaxToken semicolonToken)
    {
        if (throwKeyword != this.ThrowKeyword || expression != this.Expression || semicolonToken != this.SemicolonToken)
        {
            var newNode = SyntaxFactory.ThrowStatement(throwKeyword, expression, semicolonToken);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
    {
         return new ThrowStatementSyntax(this.Kind, this.throwKeyword, this.expression, this.semicolonToken, diagnostics, GetAnnotations());
    }

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
    {
         return new ThrowStatementSyntax(this.Kind, this.throwKeyword, this.expression, this.semicolonToken, GetDiagnostics(), annotations);
    }

    internal ThrowStatementSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 3;
      var throwKeyword = (SyntaxToken)reader.ReadValue();
      if (throwKeyword != null)
      {
         AdjustFlagsAndWidth(throwKeyword);
         this.throwKeyword = throwKeyword;
      }
      var expression = (ExpressionSyntax)reader.ReadValue();
      if (expression != null)
      {
         AdjustFlagsAndWidth(expression);
         this.expression = expression;
      }
      var semicolonToken = (SyntaxToken)reader.ReadValue();
      if (semicolonToken != null)
      {
         AdjustFlagsAndWidth(semicolonToken);
         this.semicolonToken = semicolonToken;
      }
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.throwKeyword);
      writer.WriteValue(this.expression);
      writer.WriteValue(this.semicolonToken);
    }

    static ThrowStatementSyntax()
    {
       ObjectBinder.RegisterTypeReader(typeof(ThrowStatementSyntax), r => new ThrowStatementSyntax(r));
    }
  }

  internal sealed partial class YieldStatementSyntax : StatementSyntax
  {
    internal readonly SyntaxToken yieldKeyword;
    internal readonly SyntaxToken returnOrBreakKeyword;
    internal readonly ExpressionSyntax expression;
    internal readonly SyntaxToken semicolonToken;

    internal YieldStatementSyntax(SyntaxKind kind, SyntaxToken yieldKeyword, SyntaxToken returnOrBreakKeyword, ExpressionSyntax expression, SyntaxToken semicolonToken, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 4;
        this.AdjustFlagsAndWidth(yieldKeyword);
        this.yieldKeyword = yieldKeyword;
        this.AdjustFlagsAndWidth(returnOrBreakKeyword);
        this.returnOrBreakKeyword = returnOrBreakKeyword;
        if (expression != null)
        {
            this.AdjustFlagsAndWidth(expression);
            this.expression = expression;
        }
        this.AdjustFlagsAndWidth(semicolonToken);
        this.semicolonToken = semicolonToken;
    }


    internal YieldStatementSyntax(SyntaxKind kind, SyntaxToken yieldKeyword, SyntaxToken returnOrBreakKeyword, ExpressionSyntax expression, SyntaxToken semicolonToken, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 4;
        this.AdjustFlagsAndWidth(yieldKeyword);
        this.yieldKeyword = yieldKeyword;
        this.AdjustFlagsAndWidth(returnOrBreakKeyword);
        this.returnOrBreakKeyword = returnOrBreakKeyword;
        if (expression != null)
        {
            this.AdjustFlagsAndWidth(expression);
            this.expression = expression;
        }
        this.AdjustFlagsAndWidth(semicolonToken);
        this.semicolonToken = semicolonToken;
    }


    internal YieldStatementSyntax(SyntaxKind kind, SyntaxToken yieldKeyword, SyntaxToken returnOrBreakKeyword, ExpressionSyntax expression, SyntaxToken semicolonToken)
        : base(kind)
    {
        this.SlotCount = 4;
        this.AdjustFlagsAndWidth(yieldKeyword);
        this.yieldKeyword = yieldKeyword;
        this.AdjustFlagsAndWidth(returnOrBreakKeyword);
        this.returnOrBreakKeyword = returnOrBreakKeyword;
        if (expression != null)
        {
            this.AdjustFlagsAndWidth(expression);
            this.expression = expression;
        }
        this.AdjustFlagsAndWidth(semicolonToken);
        this.semicolonToken = semicolonToken;
    }

    public SyntaxToken YieldKeyword { get { return this.yieldKeyword; } }
    public SyntaxToken ReturnOrBreakKeyword { get { return this.returnOrBreakKeyword; } }
    public ExpressionSyntax Expression { get { return this.expression; } }
    public SyntaxToken SemicolonToken { get { return this.semicolonToken; } }

    internal override GreenNode GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.yieldKeyword;
            case 1: return this.returnOrBreakKeyword;
            case 2: return this.expression;
            case 3: return this.semicolonToken;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode parent, int position)
    {
      return new CSharp.Syntax.YieldStatementSyntax(this, parent, position);
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitYieldStatement(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitYieldStatement(this);
    }

    public YieldStatementSyntax Update(SyntaxToken yieldKeyword, SyntaxToken returnOrBreakKeyword, ExpressionSyntax expression, SyntaxToken semicolonToken)
    {
        if (yieldKeyword != this.YieldKeyword || returnOrBreakKeyword != this.ReturnOrBreakKeyword || expression != this.Expression || semicolonToken != this.SemicolonToken)
        {
            var newNode = SyntaxFactory.YieldStatement(this.Kind, yieldKeyword, returnOrBreakKeyword, expression, semicolonToken);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
    {
         return new YieldStatementSyntax(this.Kind, this.yieldKeyword, this.returnOrBreakKeyword, this.expression, this.semicolonToken, diagnostics, GetAnnotations());
    }

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
    {
         return new YieldStatementSyntax(this.Kind, this.yieldKeyword, this.returnOrBreakKeyword, this.expression, this.semicolonToken, GetDiagnostics(), annotations);
    }

    internal YieldStatementSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 4;
      var yieldKeyword = (SyntaxToken)reader.ReadValue();
      if (yieldKeyword != null)
      {
         AdjustFlagsAndWidth(yieldKeyword);
         this.yieldKeyword = yieldKeyword;
      }
      var returnOrBreakKeyword = (SyntaxToken)reader.ReadValue();
      if (returnOrBreakKeyword != null)
      {
         AdjustFlagsAndWidth(returnOrBreakKeyword);
         this.returnOrBreakKeyword = returnOrBreakKeyword;
      }
      var expression = (ExpressionSyntax)reader.ReadValue();
      if (expression != null)
      {
         AdjustFlagsAndWidth(expression);
         this.expression = expression;
      }
      var semicolonToken = (SyntaxToken)reader.ReadValue();
      if (semicolonToken != null)
      {
         AdjustFlagsAndWidth(semicolonToken);
         this.semicolonToken = semicolonToken;
      }
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.yieldKeyword);
      writer.WriteValue(this.returnOrBreakKeyword);
      writer.WriteValue(this.expression);
      writer.WriteValue(this.semicolonToken);
    }

    static YieldStatementSyntax()
    {
       ObjectBinder.RegisterTypeReader(typeof(YieldStatementSyntax), r => new YieldStatementSyntax(r));
    }
  }

  internal sealed partial class WhileStatementSyntax : StatementSyntax
  {
    internal readonly SyntaxToken whileKeyword;
    internal readonly SyntaxToken openParenToken;
    internal readonly ExpressionSyntax condition;
    internal readonly SyntaxToken closeParenToken;
    internal readonly StatementSyntax statement;

    internal WhileStatementSyntax(SyntaxKind kind, SyntaxToken whileKeyword, SyntaxToken openParenToken, ExpressionSyntax condition, SyntaxToken closeParenToken, StatementSyntax statement, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 5;
        this.AdjustFlagsAndWidth(whileKeyword);
        this.whileKeyword = whileKeyword;
        this.AdjustFlagsAndWidth(openParenToken);
        this.openParenToken = openParenToken;
        this.AdjustFlagsAndWidth(condition);
        this.condition = condition;
        this.AdjustFlagsAndWidth(closeParenToken);
        this.closeParenToken = closeParenToken;
        this.AdjustFlagsAndWidth(statement);
        this.statement = statement;
    }


    internal WhileStatementSyntax(SyntaxKind kind, SyntaxToken whileKeyword, SyntaxToken openParenToken, ExpressionSyntax condition, SyntaxToken closeParenToken, StatementSyntax statement, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 5;
        this.AdjustFlagsAndWidth(whileKeyword);
        this.whileKeyword = whileKeyword;
        this.AdjustFlagsAndWidth(openParenToken);
        this.openParenToken = openParenToken;
        this.AdjustFlagsAndWidth(condition);
        this.condition = condition;
        this.AdjustFlagsAndWidth(closeParenToken);
        this.closeParenToken = closeParenToken;
        this.AdjustFlagsAndWidth(statement);
        this.statement = statement;
    }


    internal WhileStatementSyntax(SyntaxKind kind, SyntaxToken whileKeyword, SyntaxToken openParenToken, ExpressionSyntax condition, SyntaxToken closeParenToken, StatementSyntax statement)
        : base(kind)
    {
        this.SlotCount = 5;
        this.AdjustFlagsAndWidth(whileKeyword);
        this.whileKeyword = whileKeyword;
        this.AdjustFlagsAndWidth(openParenToken);
        this.openParenToken = openParenToken;
        this.AdjustFlagsAndWidth(condition);
        this.condition = condition;
        this.AdjustFlagsAndWidth(closeParenToken);
        this.closeParenToken = closeParenToken;
        this.AdjustFlagsAndWidth(statement);
        this.statement = statement;
    }

    public SyntaxToken WhileKeyword { get { return this.whileKeyword; } }
    public SyntaxToken OpenParenToken { get { return this.openParenToken; } }
    public ExpressionSyntax Condition { get { return this.condition; } }
    public SyntaxToken CloseParenToken { get { return this.closeParenToken; } }
    public StatementSyntax Statement { get { return this.statement; } }

    internal override GreenNode GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.whileKeyword;
            case 1: return this.openParenToken;
            case 2: return this.condition;
            case 3: return this.closeParenToken;
            case 4: return this.statement;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode parent, int position)
    {
      return new CSharp.Syntax.WhileStatementSyntax(this, parent, position);
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitWhileStatement(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitWhileStatement(this);
    }

    public WhileStatementSyntax Update(SyntaxToken whileKeyword, SyntaxToken openParenToken, ExpressionSyntax condition, SyntaxToken closeParenToken, StatementSyntax statement)
    {
        if (whileKeyword != this.WhileKeyword || openParenToken != this.OpenParenToken || condition != this.Condition || closeParenToken != this.CloseParenToken || statement != this.Statement)
        {
            var newNode = SyntaxFactory.WhileStatement(whileKeyword, openParenToken, condition, closeParenToken, statement);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
    {
         return new WhileStatementSyntax(this.Kind, this.whileKeyword, this.openParenToken, this.condition, this.closeParenToken, this.statement, diagnostics, GetAnnotations());
    }

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
    {
         return new WhileStatementSyntax(this.Kind, this.whileKeyword, this.openParenToken, this.condition, this.closeParenToken, this.statement, GetDiagnostics(), annotations);
    }

    internal WhileStatementSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 5;
      var whileKeyword = (SyntaxToken)reader.ReadValue();
      if (whileKeyword != null)
      {
         AdjustFlagsAndWidth(whileKeyword);
         this.whileKeyword = whileKeyword;
      }
      var openParenToken = (SyntaxToken)reader.ReadValue();
      if (openParenToken != null)
      {
         AdjustFlagsAndWidth(openParenToken);
         this.openParenToken = openParenToken;
      }
      var condition = (ExpressionSyntax)reader.ReadValue();
      if (condition != null)
      {
         AdjustFlagsAndWidth(condition);
         this.condition = condition;
      }
      var closeParenToken = (SyntaxToken)reader.ReadValue();
      if (closeParenToken != null)
      {
         AdjustFlagsAndWidth(closeParenToken);
         this.closeParenToken = closeParenToken;
      }
      var statement = (StatementSyntax)reader.ReadValue();
      if (statement != null)
      {
         AdjustFlagsAndWidth(statement);
         this.statement = statement;
      }
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.whileKeyword);
      writer.WriteValue(this.openParenToken);
      writer.WriteValue(this.condition);
      writer.WriteValue(this.closeParenToken);
      writer.WriteValue(this.statement);
    }

    static WhileStatementSyntax()
    {
       ObjectBinder.RegisterTypeReader(typeof(WhileStatementSyntax), r => new WhileStatementSyntax(r));
    }
  }

  internal sealed partial class DoStatementSyntax : StatementSyntax
  {
    internal readonly SyntaxToken doKeyword;
    internal readonly StatementSyntax statement;
    internal readonly SyntaxToken whileKeyword;
    internal readonly SyntaxToken openParenToken;
    internal readonly ExpressionSyntax condition;
    internal readonly SyntaxToken closeParenToken;
    internal readonly SyntaxToken semicolonToken;

    internal DoStatementSyntax(SyntaxKind kind, SyntaxToken doKeyword, StatementSyntax statement, SyntaxToken whileKeyword, SyntaxToken openParenToken, ExpressionSyntax condition, SyntaxToken closeParenToken, SyntaxToken semicolonToken, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 7;
        this.AdjustFlagsAndWidth(doKeyword);
        this.doKeyword = doKeyword;
        this.AdjustFlagsAndWidth(statement);
        this.statement = statement;
        this.AdjustFlagsAndWidth(whileKeyword);
        this.whileKeyword = whileKeyword;
        this.AdjustFlagsAndWidth(openParenToken);
        this.openParenToken = openParenToken;
        this.AdjustFlagsAndWidth(condition);
        this.condition = condition;
        this.AdjustFlagsAndWidth(closeParenToken);
        this.closeParenToken = closeParenToken;
        this.AdjustFlagsAndWidth(semicolonToken);
        this.semicolonToken = semicolonToken;
    }


    internal DoStatementSyntax(SyntaxKind kind, SyntaxToken doKeyword, StatementSyntax statement, SyntaxToken whileKeyword, SyntaxToken openParenToken, ExpressionSyntax condition, SyntaxToken closeParenToken, SyntaxToken semicolonToken, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 7;
        this.AdjustFlagsAndWidth(doKeyword);
        this.doKeyword = doKeyword;
        this.AdjustFlagsAndWidth(statement);
        this.statement = statement;
        this.AdjustFlagsAndWidth(whileKeyword);
        this.whileKeyword = whileKeyword;
        this.AdjustFlagsAndWidth(openParenToken);
        this.openParenToken = openParenToken;
        this.AdjustFlagsAndWidth(condition);
        this.condition = condition;
        this.AdjustFlagsAndWidth(closeParenToken);
        this.closeParenToken = closeParenToken;
        this.AdjustFlagsAndWidth(semicolonToken);
        this.semicolonToken = semicolonToken;
    }


    internal DoStatementSyntax(SyntaxKind kind, SyntaxToken doKeyword, StatementSyntax statement, SyntaxToken whileKeyword, SyntaxToken openParenToken, ExpressionSyntax condition, SyntaxToken closeParenToken, SyntaxToken semicolonToken)
        : base(kind)
    {
        this.SlotCount = 7;
        this.AdjustFlagsAndWidth(doKeyword);
        this.doKeyword = doKeyword;
        this.AdjustFlagsAndWidth(statement);
        this.statement = statement;
        this.AdjustFlagsAndWidth(whileKeyword);
        this.whileKeyword = whileKeyword;
        this.AdjustFlagsAndWidth(openParenToken);
        this.openParenToken = openParenToken;
        this.AdjustFlagsAndWidth(condition);
        this.condition = condition;
        this.AdjustFlagsAndWidth(closeParenToken);
        this.closeParenToken = closeParenToken;
        this.AdjustFlagsAndWidth(semicolonToken);
        this.semicolonToken = semicolonToken;
    }

    public SyntaxToken DoKeyword { get { return this.doKeyword; } }
    public StatementSyntax Statement { get { return this.statement; } }
    public SyntaxToken WhileKeyword { get { return this.whileKeyword; } }
    public SyntaxToken OpenParenToken { get { return this.openParenToken; } }
    public ExpressionSyntax Condition { get { return this.condition; } }
    public SyntaxToken CloseParenToken { get { return this.closeParenToken; } }
    public SyntaxToken SemicolonToken { get { return this.semicolonToken; } }

    internal override GreenNode GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.doKeyword;
            case 1: return this.statement;
            case 2: return this.whileKeyword;
            case 3: return this.openParenToken;
            case 4: return this.condition;
            case 5: return this.closeParenToken;
            case 6: return this.semicolonToken;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode parent, int position)
    {
      return new CSharp.Syntax.DoStatementSyntax(this, parent, position);
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitDoStatement(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitDoStatement(this);
    }

    public DoStatementSyntax Update(SyntaxToken doKeyword, StatementSyntax statement, SyntaxToken whileKeyword, SyntaxToken openParenToken, ExpressionSyntax condition, SyntaxToken closeParenToken, SyntaxToken semicolonToken)
    {
        if (doKeyword != this.DoKeyword || statement != this.Statement || whileKeyword != this.WhileKeyword || openParenToken != this.OpenParenToken || condition != this.Condition || closeParenToken != this.CloseParenToken || semicolonToken != this.SemicolonToken)
        {
            var newNode = SyntaxFactory.DoStatement(doKeyword, statement, whileKeyword, openParenToken, condition, closeParenToken, semicolonToken);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
    {
         return new DoStatementSyntax(this.Kind, this.doKeyword, this.statement, this.whileKeyword, this.openParenToken, this.condition, this.closeParenToken, this.semicolonToken, diagnostics, GetAnnotations());
    }

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
    {
         return new DoStatementSyntax(this.Kind, this.doKeyword, this.statement, this.whileKeyword, this.openParenToken, this.condition, this.closeParenToken, this.semicolonToken, GetDiagnostics(), annotations);
    }

    internal DoStatementSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 7;
      var doKeyword = (SyntaxToken)reader.ReadValue();
      if (doKeyword != null)
      {
         AdjustFlagsAndWidth(doKeyword);
         this.doKeyword = doKeyword;
      }
      var statement = (StatementSyntax)reader.ReadValue();
      if (statement != null)
      {
         AdjustFlagsAndWidth(statement);
         this.statement = statement;
      }
      var whileKeyword = (SyntaxToken)reader.ReadValue();
      if (whileKeyword != null)
      {
         AdjustFlagsAndWidth(whileKeyword);
         this.whileKeyword = whileKeyword;
      }
      var openParenToken = (SyntaxToken)reader.ReadValue();
      if (openParenToken != null)
      {
         AdjustFlagsAndWidth(openParenToken);
         this.openParenToken = openParenToken;
      }
      var condition = (ExpressionSyntax)reader.ReadValue();
      if (condition != null)
      {
         AdjustFlagsAndWidth(condition);
         this.condition = condition;
      }
      var closeParenToken = (SyntaxToken)reader.ReadValue();
      if (closeParenToken != null)
      {
         AdjustFlagsAndWidth(closeParenToken);
         this.closeParenToken = closeParenToken;
      }
      var semicolonToken = (SyntaxToken)reader.ReadValue();
      if (semicolonToken != null)
      {
         AdjustFlagsAndWidth(semicolonToken);
         this.semicolonToken = semicolonToken;
      }
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.doKeyword);
      writer.WriteValue(this.statement);
      writer.WriteValue(this.whileKeyword);
      writer.WriteValue(this.openParenToken);
      writer.WriteValue(this.condition);
      writer.WriteValue(this.closeParenToken);
      writer.WriteValue(this.semicolonToken);
    }

    static DoStatementSyntax()
    {
       ObjectBinder.RegisterTypeReader(typeof(DoStatementSyntax), r => new DoStatementSyntax(r));
    }
  }

  internal sealed partial class ForStatementSyntax : StatementSyntax
  {
    internal readonly SyntaxToken forKeyword;
    internal readonly SyntaxToken openParenToken;
    internal readonly VariableDeclarationSyntax declaration;
    internal readonly GreenNode initializers;
    internal readonly SyntaxToken firstSemicolonToken;
    internal readonly ExpressionSyntax condition;
    internal readonly SyntaxToken secondSemicolonToken;
    internal readonly GreenNode incrementors;
    internal readonly SyntaxToken closeParenToken;
    internal readonly StatementSyntax statement;

    internal ForStatementSyntax(SyntaxKind kind, SyntaxToken forKeyword, SyntaxToken openParenToken, VariableDeclarationSyntax declaration, GreenNode initializers, SyntaxToken firstSemicolonToken, ExpressionSyntax condition, SyntaxToken secondSemicolonToken, GreenNode incrementors, SyntaxToken closeParenToken, StatementSyntax statement, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 10;
        this.AdjustFlagsAndWidth(forKeyword);
        this.forKeyword = forKeyword;
        this.AdjustFlagsAndWidth(openParenToken);
        this.openParenToken = openParenToken;
        if (declaration != null)
        {
            this.AdjustFlagsAndWidth(declaration);
            this.declaration = declaration;
        }
        if (initializers != null)
        {
            this.AdjustFlagsAndWidth(initializers);
            this.initializers = initializers;
        }
        this.AdjustFlagsAndWidth(firstSemicolonToken);
        this.firstSemicolonToken = firstSemicolonToken;
        if (condition != null)
        {
            this.AdjustFlagsAndWidth(condition);
            this.condition = condition;
        }
        this.AdjustFlagsAndWidth(secondSemicolonToken);
        this.secondSemicolonToken = secondSemicolonToken;
        if (incrementors != null)
        {
            this.AdjustFlagsAndWidth(incrementors);
            this.incrementors = incrementors;
        }
        this.AdjustFlagsAndWidth(closeParenToken);
        this.closeParenToken = closeParenToken;
        this.AdjustFlagsAndWidth(statement);
        this.statement = statement;
    }


    internal ForStatementSyntax(SyntaxKind kind, SyntaxToken forKeyword, SyntaxToken openParenToken, VariableDeclarationSyntax declaration, GreenNode initializers, SyntaxToken firstSemicolonToken, ExpressionSyntax condition, SyntaxToken secondSemicolonToken, GreenNode incrementors, SyntaxToken closeParenToken, StatementSyntax statement, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 10;
        this.AdjustFlagsAndWidth(forKeyword);
        this.forKeyword = forKeyword;
        this.AdjustFlagsAndWidth(openParenToken);
        this.openParenToken = openParenToken;
        if (declaration != null)
        {
            this.AdjustFlagsAndWidth(declaration);
            this.declaration = declaration;
        }
        if (initializers != null)
        {
            this.AdjustFlagsAndWidth(initializers);
            this.initializers = initializers;
        }
        this.AdjustFlagsAndWidth(firstSemicolonToken);
        this.firstSemicolonToken = firstSemicolonToken;
        if (condition != null)
        {
            this.AdjustFlagsAndWidth(condition);
            this.condition = condition;
        }
        this.AdjustFlagsAndWidth(secondSemicolonToken);
        this.secondSemicolonToken = secondSemicolonToken;
        if (incrementors != null)
        {
            this.AdjustFlagsAndWidth(incrementors);
            this.incrementors = incrementors;
        }
        this.AdjustFlagsAndWidth(closeParenToken);
        this.closeParenToken = closeParenToken;
        this.AdjustFlagsAndWidth(statement);
        this.statement = statement;
    }


    internal ForStatementSyntax(SyntaxKind kind, SyntaxToken forKeyword, SyntaxToken openParenToken, VariableDeclarationSyntax declaration, GreenNode initializers, SyntaxToken firstSemicolonToken, ExpressionSyntax condition, SyntaxToken secondSemicolonToken, GreenNode incrementors, SyntaxToken closeParenToken, StatementSyntax statement)
        : base(kind)
    {
        this.SlotCount = 10;
        this.AdjustFlagsAndWidth(forKeyword);
        this.forKeyword = forKeyword;
        this.AdjustFlagsAndWidth(openParenToken);
        this.openParenToken = openParenToken;
        if (declaration != null)
        {
            this.AdjustFlagsAndWidth(declaration);
            this.declaration = declaration;
        }
        if (initializers != null)
        {
            this.AdjustFlagsAndWidth(initializers);
            this.initializers = initializers;
        }
        this.AdjustFlagsAndWidth(firstSemicolonToken);
        this.firstSemicolonToken = firstSemicolonToken;
        if (condition != null)
        {
            this.AdjustFlagsAndWidth(condition);
            this.condition = condition;
        }
        this.AdjustFlagsAndWidth(secondSemicolonToken);
        this.secondSemicolonToken = secondSemicolonToken;
        if (incrementors != null)
        {
            this.AdjustFlagsAndWidth(incrementors);
            this.incrementors = incrementors;
        }
        this.AdjustFlagsAndWidth(closeParenToken);
        this.closeParenToken = closeParenToken;
        this.AdjustFlagsAndWidth(statement);
        this.statement = statement;
    }

    public SyntaxToken ForKeyword { get { return this.forKeyword; } }
    public SyntaxToken OpenParenToken { get { return this.openParenToken; } }
    public VariableDeclarationSyntax Declaration { get { return this.declaration; } }
    public Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<ExpressionSyntax> Initializers { get { return new Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<ExpressionSyntax>(new Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<CSharpSyntaxNode>(this.initializers)); } }
    public SyntaxToken FirstSemicolonToken { get { return this.firstSemicolonToken; } }
    public ExpressionSyntax Condition { get { return this.condition; } }
    public SyntaxToken SecondSemicolonToken { get { return this.secondSemicolonToken; } }
    public Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<ExpressionSyntax> Incrementors { get { return new Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<ExpressionSyntax>(new Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<CSharpSyntaxNode>(this.incrementors)); } }
    public SyntaxToken CloseParenToken { get { return this.closeParenToken; } }
    public StatementSyntax Statement { get { return this.statement; } }

    internal override GreenNode GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.forKeyword;
            case 1: return this.openParenToken;
            case 2: return this.declaration;
            case 3: return this.initializers;
            case 4: return this.firstSemicolonToken;
            case 5: return this.condition;
            case 6: return this.secondSemicolonToken;
            case 7: return this.incrementors;
            case 8: return this.closeParenToken;
            case 9: return this.statement;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode parent, int position)
    {
      return new CSharp.Syntax.ForStatementSyntax(this, parent, position);
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitForStatement(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitForStatement(this);
    }

    public ForStatementSyntax Update(SyntaxToken forKeyword, SyntaxToken openParenToken, VariableDeclarationSyntax declaration, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<ExpressionSyntax> initializers, SyntaxToken firstSemicolonToken, ExpressionSyntax condition, SyntaxToken secondSemicolonToken, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<ExpressionSyntax> incrementors, SyntaxToken closeParenToken, StatementSyntax statement)
    {
        if (forKeyword != this.ForKeyword || openParenToken != this.OpenParenToken || declaration != this.Declaration || initializers != this.Initializers || firstSemicolonToken != this.FirstSemicolonToken || condition != this.Condition || secondSemicolonToken != this.SecondSemicolonToken || incrementors != this.Incrementors || closeParenToken != this.CloseParenToken || statement != this.Statement)
        {
            var newNode = SyntaxFactory.ForStatement(forKeyword, openParenToken, declaration, initializers, firstSemicolonToken, condition, secondSemicolonToken, incrementors, closeParenToken, statement);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
    {
         return new ForStatementSyntax(this.Kind, this.forKeyword, this.openParenToken, this.declaration, this.initializers, this.firstSemicolonToken, this.condition, this.secondSemicolonToken, this.incrementors, this.closeParenToken, this.statement, diagnostics, GetAnnotations());
    }

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
    {
         return new ForStatementSyntax(this.Kind, this.forKeyword, this.openParenToken, this.declaration, this.initializers, this.firstSemicolonToken, this.condition, this.secondSemicolonToken, this.incrementors, this.closeParenToken, this.statement, GetDiagnostics(), annotations);
    }

    internal ForStatementSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 10;
      var forKeyword = (SyntaxToken)reader.ReadValue();
      if (forKeyword != null)
      {
         AdjustFlagsAndWidth(forKeyword);
         this.forKeyword = forKeyword;
      }
      var openParenToken = (SyntaxToken)reader.ReadValue();
      if (openParenToken != null)
      {
         AdjustFlagsAndWidth(openParenToken);
         this.openParenToken = openParenToken;
      }
      var declaration = (VariableDeclarationSyntax)reader.ReadValue();
      if (declaration != null)
      {
         AdjustFlagsAndWidth(declaration);
         this.declaration = declaration;
      }
      var initializers = (GreenNode)reader.ReadValue();
      if (initializers != null)
      {
         AdjustFlagsAndWidth(initializers);
         this.initializers = initializers;
      }
      var firstSemicolonToken = (SyntaxToken)reader.ReadValue();
      if (firstSemicolonToken != null)
      {
         AdjustFlagsAndWidth(firstSemicolonToken);
         this.firstSemicolonToken = firstSemicolonToken;
      }
      var condition = (ExpressionSyntax)reader.ReadValue();
      if (condition != null)
      {
         AdjustFlagsAndWidth(condition);
         this.condition = condition;
      }
      var secondSemicolonToken = (SyntaxToken)reader.ReadValue();
      if (secondSemicolonToken != null)
      {
         AdjustFlagsAndWidth(secondSemicolonToken);
         this.secondSemicolonToken = secondSemicolonToken;
      }
      var incrementors = (GreenNode)reader.ReadValue();
      if (incrementors != null)
      {
         AdjustFlagsAndWidth(incrementors);
         this.incrementors = incrementors;
      }
      var closeParenToken = (SyntaxToken)reader.ReadValue();
      if (closeParenToken != null)
      {
         AdjustFlagsAndWidth(closeParenToken);
         this.closeParenToken = closeParenToken;
      }
      var statement = (StatementSyntax)reader.ReadValue();
      if (statement != null)
      {
         AdjustFlagsAndWidth(statement);
         this.statement = statement;
      }
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.forKeyword);
      writer.WriteValue(this.openParenToken);
      writer.WriteValue(this.declaration);
      writer.WriteValue(this.initializers);
      writer.WriteValue(this.firstSemicolonToken);
      writer.WriteValue(this.condition);
      writer.WriteValue(this.secondSemicolonToken);
      writer.WriteValue(this.incrementors);
      writer.WriteValue(this.closeParenToken);
      writer.WriteValue(this.statement);
    }

    static ForStatementSyntax()
    {
       ObjectBinder.RegisterTypeReader(typeof(ForStatementSyntax), r => new ForStatementSyntax(r));
    }
  }

  internal abstract partial class CommonForEachStatementSyntax : StatementSyntax
  {
    internal CommonForEachStatementSyntax(SyntaxKind kind, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
      : base(kind, diagnostics, annotations)
    {
    }
    internal CommonForEachStatementSyntax(SyntaxKind kind)
      : base(kind)
    {
    }

    protected CommonForEachStatementSyntax(ObjectReader reader)
       : base(reader)
    {
    }

    public abstract SyntaxToken ForEachKeyword { get; }

    public abstract SyntaxToken OpenParenToken { get; }

    public abstract SyntaxToken InKeyword { get; }

    public abstract ExpressionSyntax Expression { get; }

    public abstract SyntaxToken CloseParenToken { get; }

    public abstract StatementSyntax Statement { get; }
  }

  internal sealed partial class ForEachStatementSyntax : CommonForEachStatementSyntax
  {
    internal readonly SyntaxToken forEachKeyword;
    internal readonly SyntaxToken openParenToken;
    internal readonly TypeSyntax type;
    internal readonly SyntaxToken identifier;
    internal readonly SyntaxToken inKeyword;
    internal readonly ExpressionSyntax expression;
    internal readonly SyntaxToken closeParenToken;
    internal readonly StatementSyntax statement;

    internal ForEachStatementSyntax(SyntaxKind kind, SyntaxToken forEachKeyword, SyntaxToken openParenToken, TypeSyntax type, SyntaxToken identifier, SyntaxToken inKeyword, ExpressionSyntax expression, SyntaxToken closeParenToken, StatementSyntax statement, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 8;
        this.AdjustFlagsAndWidth(forEachKeyword);
        this.forEachKeyword = forEachKeyword;
        this.AdjustFlagsAndWidth(openParenToken);
        this.openParenToken = openParenToken;
        this.AdjustFlagsAndWidth(type);
        this.type = type;
        this.AdjustFlagsAndWidth(identifier);
        this.identifier = identifier;
        this.AdjustFlagsAndWidth(inKeyword);
        this.inKeyword = inKeyword;
        this.AdjustFlagsAndWidth(expression);
        this.expression = expression;
        this.AdjustFlagsAndWidth(closeParenToken);
        this.closeParenToken = closeParenToken;
        this.AdjustFlagsAndWidth(statement);
        this.statement = statement;
    }


    internal ForEachStatementSyntax(SyntaxKind kind, SyntaxToken forEachKeyword, SyntaxToken openParenToken, TypeSyntax type, SyntaxToken identifier, SyntaxToken inKeyword, ExpressionSyntax expression, SyntaxToken closeParenToken, StatementSyntax statement, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 8;
        this.AdjustFlagsAndWidth(forEachKeyword);
        this.forEachKeyword = forEachKeyword;
        this.AdjustFlagsAndWidth(openParenToken);
        this.openParenToken = openParenToken;
        this.AdjustFlagsAndWidth(type);
        this.type = type;
        this.AdjustFlagsAndWidth(identifier);
        this.identifier = identifier;
        this.AdjustFlagsAndWidth(inKeyword);
        this.inKeyword = inKeyword;
        this.AdjustFlagsAndWidth(expression);
        this.expression = expression;
        this.AdjustFlagsAndWidth(closeParenToken);
        this.closeParenToken = closeParenToken;
        this.AdjustFlagsAndWidth(statement);
        this.statement = statement;
    }


    internal ForEachStatementSyntax(SyntaxKind kind, SyntaxToken forEachKeyword, SyntaxToken openParenToken, TypeSyntax type, SyntaxToken identifier, SyntaxToken inKeyword, ExpressionSyntax expression, SyntaxToken closeParenToken, StatementSyntax statement)
        : base(kind)
    {
        this.SlotCount = 8;
        this.AdjustFlagsAndWidth(forEachKeyword);
        this.forEachKeyword = forEachKeyword;
        this.AdjustFlagsAndWidth(openParenToken);
        this.openParenToken = openParenToken;
        this.AdjustFlagsAndWidth(type);
        this.type = type;
        this.AdjustFlagsAndWidth(identifier);
        this.identifier = identifier;
        this.AdjustFlagsAndWidth(inKeyword);
        this.inKeyword = inKeyword;
        this.AdjustFlagsAndWidth(expression);
        this.expression = expression;
        this.AdjustFlagsAndWidth(closeParenToken);
        this.closeParenToken = closeParenToken;
        this.AdjustFlagsAndWidth(statement);
        this.statement = statement;
    }

    public override SyntaxToken ForEachKeyword { get { return this.forEachKeyword; } }
    public override SyntaxToken OpenParenToken { get { return this.openParenToken; } }
    public TypeSyntax Type { get { return this.type; } }
    /// <summary>Gets the identifier.</summary>
    public SyntaxToken Identifier { get { return this.identifier; } }
    public override SyntaxToken InKeyword { get { return this.inKeyword; } }
    public override ExpressionSyntax Expression { get { return this.expression; } }
    public override SyntaxToken CloseParenToken { get { return this.closeParenToken; } }
    public override StatementSyntax Statement { get { return this.statement; } }

    internal override GreenNode GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.forEachKeyword;
            case 1: return this.openParenToken;
            case 2: return this.type;
            case 3: return this.identifier;
            case 4: return this.inKeyword;
            case 5: return this.expression;
            case 6: return this.closeParenToken;
            case 7: return this.statement;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode parent, int position)
    {
      return new CSharp.Syntax.ForEachStatementSyntax(this, parent, position);
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitForEachStatement(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitForEachStatement(this);
    }

    public ForEachStatementSyntax Update(SyntaxToken forEachKeyword, SyntaxToken openParenToken, TypeSyntax type, SyntaxToken identifier, SyntaxToken inKeyword, ExpressionSyntax expression, SyntaxToken closeParenToken, StatementSyntax statement)
    {
        if (forEachKeyword != this.ForEachKeyword || openParenToken != this.OpenParenToken || type != this.Type || identifier != this.Identifier || inKeyword != this.InKeyword || expression != this.Expression || closeParenToken != this.CloseParenToken || statement != this.Statement)
        {
            var newNode = SyntaxFactory.ForEachStatement(forEachKeyword, openParenToken, type, identifier, inKeyword, expression, closeParenToken, statement);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
    {
         return new ForEachStatementSyntax(this.Kind, this.forEachKeyword, this.openParenToken, this.type, this.identifier, this.inKeyword, this.expression, this.closeParenToken, this.statement, diagnostics, GetAnnotations());
    }

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
    {
         return new ForEachStatementSyntax(this.Kind, this.forEachKeyword, this.openParenToken, this.type, this.identifier, this.inKeyword, this.expression, this.closeParenToken, this.statement, GetDiagnostics(), annotations);
    }

    internal ForEachStatementSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 8;
      var forEachKeyword = (SyntaxToken)reader.ReadValue();
      if (forEachKeyword != null)
      {
         AdjustFlagsAndWidth(forEachKeyword);
         this.forEachKeyword = forEachKeyword;
      }
      var openParenToken = (SyntaxToken)reader.ReadValue();
      if (openParenToken != null)
      {
         AdjustFlagsAndWidth(openParenToken);
         this.openParenToken = openParenToken;
      }
      var type = (TypeSyntax)reader.ReadValue();
      if (type != null)
      {
         AdjustFlagsAndWidth(type);
         this.type = type;
      }
      var identifier = (SyntaxToken)reader.ReadValue();
      if (identifier != null)
      {
         AdjustFlagsAndWidth(identifier);
         this.identifier = identifier;
      }
      var inKeyword = (SyntaxToken)reader.ReadValue();
      if (inKeyword != null)
      {
         AdjustFlagsAndWidth(inKeyword);
         this.inKeyword = inKeyword;
      }
      var expression = (ExpressionSyntax)reader.ReadValue();
      if (expression != null)
      {
         AdjustFlagsAndWidth(expression);
         this.expression = expression;
      }
      var closeParenToken = (SyntaxToken)reader.ReadValue();
      if (closeParenToken != null)
      {
         AdjustFlagsAndWidth(closeParenToken);
         this.closeParenToken = closeParenToken;
      }
      var statement = (StatementSyntax)reader.ReadValue();
      if (statement != null)
      {
         AdjustFlagsAndWidth(statement);
         this.statement = statement;
      }
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.forEachKeyword);
      writer.WriteValue(this.openParenToken);
      writer.WriteValue(this.type);
      writer.WriteValue(this.identifier);
      writer.WriteValue(this.inKeyword);
      writer.WriteValue(this.expression);
      writer.WriteValue(this.closeParenToken);
      writer.WriteValue(this.statement);
    }

    static ForEachStatementSyntax()
    {
       ObjectBinder.RegisterTypeReader(typeof(ForEachStatementSyntax), r => new ForEachStatementSyntax(r));
    }
  }

  internal sealed partial class ForEachVariableStatementSyntax : CommonForEachStatementSyntax
  {
    internal readonly SyntaxToken forEachKeyword;
    internal readonly SyntaxToken openParenToken;
    internal readonly ExpressionSyntax variable;
    internal readonly SyntaxToken inKeyword;
    internal readonly ExpressionSyntax expression;
    internal readonly SyntaxToken closeParenToken;
    internal readonly StatementSyntax statement;

    internal ForEachVariableStatementSyntax(SyntaxKind kind, SyntaxToken forEachKeyword, SyntaxToken openParenToken, ExpressionSyntax variable, SyntaxToken inKeyword, ExpressionSyntax expression, SyntaxToken closeParenToken, StatementSyntax statement, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 7;
        this.AdjustFlagsAndWidth(forEachKeyword);
        this.forEachKeyword = forEachKeyword;
        this.AdjustFlagsAndWidth(openParenToken);
        this.openParenToken = openParenToken;
        this.AdjustFlagsAndWidth(variable);
        this.variable = variable;
        this.AdjustFlagsAndWidth(inKeyword);
        this.inKeyword = inKeyword;
        this.AdjustFlagsAndWidth(expression);
        this.expression = expression;
        this.AdjustFlagsAndWidth(closeParenToken);
        this.closeParenToken = closeParenToken;
        this.AdjustFlagsAndWidth(statement);
        this.statement = statement;
    }


    internal ForEachVariableStatementSyntax(SyntaxKind kind, SyntaxToken forEachKeyword, SyntaxToken openParenToken, ExpressionSyntax variable, SyntaxToken inKeyword, ExpressionSyntax expression, SyntaxToken closeParenToken, StatementSyntax statement, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 7;
        this.AdjustFlagsAndWidth(forEachKeyword);
        this.forEachKeyword = forEachKeyword;
        this.AdjustFlagsAndWidth(openParenToken);
        this.openParenToken = openParenToken;
        this.AdjustFlagsAndWidth(variable);
        this.variable = variable;
        this.AdjustFlagsAndWidth(inKeyword);
        this.inKeyword = inKeyword;
        this.AdjustFlagsAndWidth(expression);
        this.expression = expression;
        this.AdjustFlagsAndWidth(closeParenToken);
        this.closeParenToken = closeParenToken;
        this.AdjustFlagsAndWidth(statement);
        this.statement = statement;
    }


    internal ForEachVariableStatementSyntax(SyntaxKind kind, SyntaxToken forEachKeyword, SyntaxToken openParenToken, ExpressionSyntax variable, SyntaxToken inKeyword, ExpressionSyntax expression, SyntaxToken closeParenToken, StatementSyntax statement)
        : base(kind)
    {
        this.SlotCount = 7;
        this.AdjustFlagsAndWidth(forEachKeyword);
        this.forEachKeyword = forEachKeyword;
        this.AdjustFlagsAndWidth(openParenToken);
        this.openParenToken = openParenToken;
        this.AdjustFlagsAndWidth(variable);
        this.variable = variable;
        this.AdjustFlagsAndWidth(inKeyword);
        this.inKeyword = inKeyword;
        this.AdjustFlagsAndWidth(expression);
        this.expression = expression;
        this.AdjustFlagsAndWidth(closeParenToken);
        this.closeParenToken = closeParenToken;
        this.AdjustFlagsAndWidth(statement);
        this.statement = statement;
    }

    public override SyntaxToken ForEachKeyword { get { return this.forEachKeyword; } }
    public override SyntaxToken OpenParenToken { get { return this.openParenToken; } }
    /// <summary>
    /// The variable(s) of the loop. In correct code this is a tuple
    /// literal, declaration expression with a tuple designator, or
    /// a wildcard syntax in the form of a simple identifier. In broken
    /// code it could be something else.
    /// </summary>
    public ExpressionSyntax Variable { get { return this.variable; } }
    public override SyntaxToken InKeyword { get { return this.inKeyword; } }
    public override ExpressionSyntax Expression { get { return this.expression; } }
    public override SyntaxToken CloseParenToken { get { return this.closeParenToken; } }
    public override StatementSyntax Statement { get { return this.statement; } }

    internal override GreenNode GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.forEachKeyword;
            case 1: return this.openParenToken;
            case 2: return this.variable;
            case 3: return this.inKeyword;
            case 4: return this.expression;
            case 5: return this.closeParenToken;
            case 6: return this.statement;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode parent, int position)
    {
      return new CSharp.Syntax.ForEachVariableStatementSyntax(this, parent, position);
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitForEachVariableStatement(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitForEachVariableStatement(this);
    }

    public ForEachVariableStatementSyntax Update(SyntaxToken forEachKeyword, SyntaxToken openParenToken, ExpressionSyntax variable, SyntaxToken inKeyword, ExpressionSyntax expression, SyntaxToken closeParenToken, StatementSyntax statement)
    {
        if (forEachKeyword != this.ForEachKeyword || openParenToken != this.OpenParenToken || variable != this.Variable || inKeyword != this.InKeyword || expression != this.Expression || closeParenToken != this.CloseParenToken || statement != this.Statement)
        {
            var newNode = SyntaxFactory.ForEachVariableStatement(forEachKeyword, openParenToken, variable, inKeyword, expression, closeParenToken, statement);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
    {
         return new ForEachVariableStatementSyntax(this.Kind, this.forEachKeyword, this.openParenToken, this.variable, this.inKeyword, this.expression, this.closeParenToken, this.statement, diagnostics, GetAnnotations());
    }

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
    {
         return new ForEachVariableStatementSyntax(this.Kind, this.forEachKeyword, this.openParenToken, this.variable, this.inKeyword, this.expression, this.closeParenToken, this.statement, GetDiagnostics(), annotations);
    }

    internal ForEachVariableStatementSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 7;
      var forEachKeyword = (SyntaxToken)reader.ReadValue();
      if (forEachKeyword != null)
      {
         AdjustFlagsAndWidth(forEachKeyword);
         this.forEachKeyword = forEachKeyword;
      }
      var openParenToken = (SyntaxToken)reader.ReadValue();
      if (openParenToken != null)
      {
         AdjustFlagsAndWidth(openParenToken);
         this.openParenToken = openParenToken;
      }
      var variable = (ExpressionSyntax)reader.ReadValue();
      if (variable != null)
      {
         AdjustFlagsAndWidth(variable);
         this.variable = variable;
      }
      var inKeyword = (SyntaxToken)reader.ReadValue();
      if (inKeyword != null)
      {
         AdjustFlagsAndWidth(inKeyword);
         this.inKeyword = inKeyword;
      }
      var expression = (ExpressionSyntax)reader.ReadValue();
      if (expression != null)
      {
         AdjustFlagsAndWidth(expression);
         this.expression = expression;
      }
      var closeParenToken = (SyntaxToken)reader.ReadValue();
      if (closeParenToken != null)
      {
         AdjustFlagsAndWidth(closeParenToken);
         this.closeParenToken = closeParenToken;
      }
      var statement = (StatementSyntax)reader.ReadValue();
      if (statement != null)
      {
         AdjustFlagsAndWidth(statement);
         this.statement = statement;
      }
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.forEachKeyword);
      writer.WriteValue(this.openParenToken);
      writer.WriteValue(this.variable);
      writer.WriteValue(this.inKeyword);
      writer.WriteValue(this.expression);
      writer.WriteValue(this.closeParenToken);
      writer.WriteValue(this.statement);
    }

    static ForEachVariableStatementSyntax()
    {
       ObjectBinder.RegisterTypeReader(typeof(ForEachVariableStatementSyntax), r => new ForEachVariableStatementSyntax(r));
    }
  }

  internal sealed partial class UsingStatementSyntax : StatementSyntax
  {
    internal readonly SyntaxToken usingKeyword;
    internal readonly SyntaxToken openParenToken;
    internal readonly VariableDeclarationSyntax declaration;
    internal readonly ExpressionSyntax expression;
    internal readonly SyntaxToken closeParenToken;
    internal readonly StatementSyntax statement;

    internal UsingStatementSyntax(SyntaxKind kind, SyntaxToken usingKeyword, SyntaxToken openParenToken, VariableDeclarationSyntax declaration, ExpressionSyntax expression, SyntaxToken closeParenToken, StatementSyntax statement, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 6;
        this.AdjustFlagsAndWidth(usingKeyword);
        this.usingKeyword = usingKeyword;
        this.AdjustFlagsAndWidth(openParenToken);
        this.openParenToken = openParenToken;
        if (declaration != null)
        {
            this.AdjustFlagsAndWidth(declaration);
            this.declaration = declaration;
        }
        if (expression != null)
        {
            this.AdjustFlagsAndWidth(expression);
            this.expression = expression;
        }
        this.AdjustFlagsAndWidth(closeParenToken);
        this.closeParenToken = closeParenToken;
        this.AdjustFlagsAndWidth(statement);
        this.statement = statement;
    }


    internal UsingStatementSyntax(SyntaxKind kind, SyntaxToken usingKeyword, SyntaxToken openParenToken, VariableDeclarationSyntax declaration, ExpressionSyntax expression, SyntaxToken closeParenToken, StatementSyntax statement, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 6;
        this.AdjustFlagsAndWidth(usingKeyword);
        this.usingKeyword = usingKeyword;
        this.AdjustFlagsAndWidth(openParenToken);
        this.openParenToken = openParenToken;
        if (declaration != null)
        {
            this.AdjustFlagsAndWidth(declaration);
            this.declaration = declaration;
        }
        if (expression != null)
        {
            this.AdjustFlagsAndWidth(expression);
            this.expression = expression;
        }
        this.AdjustFlagsAndWidth(closeParenToken);
        this.closeParenToken = closeParenToken;
        this.AdjustFlagsAndWidth(statement);
        this.statement = statement;
    }


    internal UsingStatementSyntax(SyntaxKind kind, SyntaxToken usingKeyword, SyntaxToken openParenToken, VariableDeclarationSyntax declaration, ExpressionSyntax expression, SyntaxToken closeParenToken, StatementSyntax statement)
        : base(kind)
    {
        this.SlotCount = 6;
        this.AdjustFlagsAndWidth(usingKeyword);
        this.usingKeyword = usingKeyword;
        this.AdjustFlagsAndWidth(openParenToken);
        this.openParenToken = openParenToken;
        if (declaration != null)
        {
            this.AdjustFlagsAndWidth(declaration);
            this.declaration = declaration;
        }
        if (expression != null)
        {
            this.AdjustFlagsAndWidth(expression);
            this.expression = expression;
        }
        this.AdjustFlagsAndWidth(closeParenToken);
        this.closeParenToken = closeParenToken;
        this.AdjustFlagsAndWidth(statement);
        this.statement = statement;
    }

    public SyntaxToken UsingKeyword { get { return this.usingKeyword; } }
    public SyntaxToken OpenParenToken { get { return this.openParenToken; } }
    public VariableDeclarationSyntax Declaration { get { return this.declaration; } }
    public ExpressionSyntax Expression { get { return this.expression; } }
    public SyntaxToken CloseParenToken { get { return this.closeParenToken; } }
    public StatementSyntax Statement { get { return this.statement; } }

    internal override GreenNode GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.usingKeyword;
            case 1: return this.openParenToken;
            case 2: return this.declaration;
            case 3: return this.expression;
            case 4: return this.closeParenToken;
            case 5: return this.statement;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode parent, int position)
    {
      return new CSharp.Syntax.UsingStatementSyntax(this, parent, position);
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitUsingStatement(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitUsingStatement(this);
    }

    public UsingStatementSyntax Update(SyntaxToken usingKeyword, SyntaxToken openParenToken, VariableDeclarationSyntax declaration, ExpressionSyntax expression, SyntaxToken closeParenToken, StatementSyntax statement)
    {
        if (usingKeyword != this.UsingKeyword || openParenToken != this.OpenParenToken || declaration != this.Declaration || expression != this.Expression || closeParenToken != this.CloseParenToken || statement != this.Statement)
        {
            var newNode = SyntaxFactory.UsingStatement(usingKeyword, openParenToken, declaration, expression, closeParenToken, statement);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
    {
         return new UsingStatementSyntax(this.Kind, this.usingKeyword, this.openParenToken, this.declaration, this.expression, this.closeParenToken, this.statement, diagnostics, GetAnnotations());
    }

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
    {
         return new UsingStatementSyntax(this.Kind, this.usingKeyword, this.openParenToken, this.declaration, this.expression, this.closeParenToken, this.statement, GetDiagnostics(), annotations);
    }

    internal UsingStatementSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 6;
      var usingKeyword = (SyntaxToken)reader.ReadValue();
      if (usingKeyword != null)
      {
         AdjustFlagsAndWidth(usingKeyword);
         this.usingKeyword = usingKeyword;
      }
      var openParenToken = (SyntaxToken)reader.ReadValue();
      if (openParenToken != null)
      {
         AdjustFlagsAndWidth(openParenToken);
         this.openParenToken = openParenToken;
      }
      var declaration = (VariableDeclarationSyntax)reader.ReadValue();
      if (declaration != null)
      {
         AdjustFlagsAndWidth(declaration);
         this.declaration = declaration;
      }
      var expression = (ExpressionSyntax)reader.ReadValue();
      if (expression != null)
      {
         AdjustFlagsAndWidth(expression);
         this.expression = expression;
      }
      var closeParenToken = (SyntaxToken)reader.ReadValue();
      if (closeParenToken != null)
      {
         AdjustFlagsAndWidth(closeParenToken);
         this.closeParenToken = closeParenToken;
      }
      var statement = (StatementSyntax)reader.ReadValue();
      if (statement != null)
      {
         AdjustFlagsAndWidth(statement);
         this.statement = statement;
      }
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.usingKeyword);
      writer.WriteValue(this.openParenToken);
      writer.WriteValue(this.declaration);
      writer.WriteValue(this.expression);
      writer.WriteValue(this.closeParenToken);
      writer.WriteValue(this.statement);
    }

    static UsingStatementSyntax()
    {
       ObjectBinder.RegisterTypeReader(typeof(UsingStatementSyntax), r => new UsingStatementSyntax(r));
    }
  }

  internal sealed partial class FixedStatementSyntax : StatementSyntax
  {
    internal readonly SyntaxToken fixedKeyword;
    internal readonly SyntaxToken openParenToken;
    internal readonly VariableDeclarationSyntax declaration;
    internal readonly SyntaxToken closeParenToken;
    internal readonly StatementSyntax statement;

    internal FixedStatementSyntax(SyntaxKind kind, SyntaxToken fixedKeyword, SyntaxToken openParenToken, VariableDeclarationSyntax declaration, SyntaxToken closeParenToken, StatementSyntax statement, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 5;
        this.AdjustFlagsAndWidth(fixedKeyword);
        this.fixedKeyword = fixedKeyword;
        this.AdjustFlagsAndWidth(openParenToken);
        this.openParenToken = openParenToken;
        this.AdjustFlagsAndWidth(declaration);
        this.declaration = declaration;
        this.AdjustFlagsAndWidth(closeParenToken);
        this.closeParenToken = closeParenToken;
        this.AdjustFlagsAndWidth(statement);
        this.statement = statement;
    }


    internal FixedStatementSyntax(SyntaxKind kind, SyntaxToken fixedKeyword, SyntaxToken openParenToken, VariableDeclarationSyntax declaration, SyntaxToken closeParenToken, StatementSyntax statement, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 5;
        this.AdjustFlagsAndWidth(fixedKeyword);
        this.fixedKeyword = fixedKeyword;
        this.AdjustFlagsAndWidth(openParenToken);
        this.openParenToken = openParenToken;
        this.AdjustFlagsAndWidth(declaration);
        this.declaration = declaration;
        this.AdjustFlagsAndWidth(closeParenToken);
        this.closeParenToken = closeParenToken;
        this.AdjustFlagsAndWidth(statement);
        this.statement = statement;
    }


    internal FixedStatementSyntax(SyntaxKind kind, SyntaxToken fixedKeyword, SyntaxToken openParenToken, VariableDeclarationSyntax declaration, SyntaxToken closeParenToken, StatementSyntax statement)
        : base(kind)
    {
        this.SlotCount = 5;
        this.AdjustFlagsAndWidth(fixedKeyword);
        this.fixedKeyword = fixedKeyword;
        this.AdjustFlagsAndWidth(openParenToken);
        this.openParenToken = openParenToken;
        this.AdjustFlagsAndWidth(declaration);
        this.declaration = declaration;
        this.AdjustFlagsAndWidth(closeParenToken);
        this.closeParenToken = closeParenToken;
        this.AdjustFlagsAndWidth(statement);
        this.statement = statement;
    }

    public SyntaxToken FixedKeyword { get { return this.fixedKeyword; } }
    public SyntaxToken OpenParenToken { get { return this.openParenToken; } }
    public VariableDeclarationSyntax Declaration { get { return this.declaration; } }
    public SyntaxToken CloseParenToken { get { return this.closeParenToken; } }
    public StatementSyntax Statement { get { return this.statement; } }

    internal override GreenNode GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.fixedKeyword;
            case 1: return this.openParenToken;
            case 2: return this.declaration;
            case 3: return this.closeParenToken;
            case 4: return this.statement;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode parent, int position)
    {
      return new CSharp.Syntax.FixedStatementSyntax(this, parent, position);
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitFixedStatement(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitFixedStatement(this);
    }

    public FixedStatementSyntax Update(SyntaxToken fixedKeyword, SyntaxToken openParenToken, VariableDeclarationSyntax declaration, SyntaxToken closeParenToken, StatementSyntax statement)
    {
        if (fixedKeyword != this.FixedKeyword || openParenToken != this.OpenParenToken || declaration != this.Declaration || closeParenToken != this.CloseParenToken || statement != this.Statement)
        {
            var newNode = SyntaxFactory.FixedStatement(fixedKeyword, openParenToken, declaration, closeParenToken, statement);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
    {
         return new FixedStatementSyntax(this.Kind, this.fixedKeyword, this.openParenToken, this.declaration, this.closeParenToken, this.statement, diagnostics, GetAnnotations());
    }

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
    {
         return new FixedStatementSyntax(this.Kind, this.fixedKeyword, this.openParenToken, this.declaration, this.closeParenToken, this.statement, GetDiagnostics(), annotations);
    }

    internal FixedStatementSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 5;
      var fixedKeyword = (SyntaxToken)reader.ReadValue();
      if (fixedKeyword != null)
      {
         AdjustFlagsAndWidth(fixedKeyword);
         this.fixedKeyword = fixedKeyword;
      }
      var openParenToken = (SyntaxToken)reader.ReadValue();
      if (openParenToken != null)
      {
         AdjustFlagsAndWidth(openParenToken);
         this.openParenToken = openParenToken;
      }
      var declaration = (VariableDeclarationSyntax)reader.ReadValue();
      if (declaration != null)
      {
         AdjustFlagsAndWidth(declaration);
         this.declaration = declaration;
      }
      var closeParenToken = (SyntaxToken)reader.ReadValue();
      if (closeParenToken != null)
      {
         AdjustFlagsAndWidth(closeParenToken);
         this.closeParenToken = closeParenToken;
      }
      var statement = (StatementSyntax)reader.ReadValue();
      if (statement != null)
      {
         AdjustFlagsAndWidth(statement);
         this.statement = statement;
      }
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.fixedKeyword);
      writer.WriteValue(this.openParenToken);
      writer.WriteValue(this.declaration);
      writer.WriteValue(this.closeParenToken);
      writer.WriteValue(this.statement);
    }

    static FixedStatementSyntax()
    {
       ObjectBinder.RegisterTypeReader(typeof(FixedStatementSyntax), r => new FixedStatementSyntax(r));
    }
  }

  internal sealed partial class CheckedStatementSyntax : StatementSyntax
  {
    internal readonly SyntaxToken keyword;
    internal readonly BlockSyntax block;

    internal CheckedStatementSyntax(SyntaxKind kind, SyntaxToken keyword, BlockSyntax block, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 2;
        this.AdjustFlagsAndWidth(keyword);
        this.keyword = keyword;
        this.AdjustFlagsAndWidth(block);
        this.block = block;
    }


    internal CheckedStatementSyntax(SyntaxKind kind, SyntaxToken keyword, BlockSyntax block, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 2;
        this.AdjustFlagsAndWidth(keyword);
        this.keyword = keyword;
        this.AdjustFlagsAndWidth(block);
        this.block = block;
    }


    internal CheckedStatementSyntax(SyntaxKind kind, SyntaxToken keyword, BlockSyntax block)
        : base(kind)
    {
        this.SlotCount = 2;
        this.AdjustFlagsAndWidth(keyword);
        this.keyword = keyword;
        this.AdjustFlagsAndWidth(block);
        this.block = block;
    }

    public SyntaxToken Keyword { get { return this.keyword; } }
    public BlockSyntax Block { get { return this.block; } }

    internal override GreenNode GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.keyword;
            case 1: return this.block;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode parent, int position)
    {
      return new CSharp.Syntax.CheckedStatementSyntax(this, parent, position);
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitCheckedStatement(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitCheckedStatement(this);
    }

    public CheckedStatementSyntax Update(SyntaxToken keyword, BlockSyntax block)
    {
        if (keyword != this.Keyword || block != this.Block)
        {
            var newNode = SyntaxFactory.CheckedStatement(this.Kind, keyword, block);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
    {
         return new CheckedStatementSyntax(this.Kind, this.keyword, this.block, diagnostics, GetAnnotations());
    }

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
    {
         return new CheckedStatementSyntax(this.Kind, this.keyword, this.block, GetDiagnostics(), annotations);
    }

    internal CheckedStatementSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 2;
      var keyword = (SyntaxToken)reader.ReadValue();
      if (keyword != null)
      {
         AdjustFlagsAndWidth(keyword);
         this.keyword = keyword;
      }
      var block = (BlockSyntax)reader.ReadValue();
      if (block != null)
      {
         AdjustFlagsAndWidth(block);
         this.block = block;
      }
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.keyword);
      writer.WriteValue(this.block);
    }

    static CheckedStatementSyntax()
    {
       ObjectBinder.RegisterTypeReader(typeof(CheckedStatementSyntax), r => new CheckedStatementSyntax(r));
    }
  }

  internal sealed partial class UnsafeStatementSyntax : StatementSyntax
  {
    internal readonly SyntaxToken unsafeKeyword;
    internal readonly BlockSyntax block;

    internal UnsafeStatementSyntax(SyntaxKind kind, SyntaxToken unsafeKeyword, BlockSyntax block, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 2;
        this.AdjustFlagsAndWidth(unsafeKeyword);
        this.unsafeKeyword = unsafeKeyword;
        this.AdjustFlagsAndWidth(block);
        this.block = block;
    }


    internal UnsafeStatementSyntax(SyntaxKind kind, SyntaxToken unsafeKeyword, BlockSyntax block, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 2;
        this.AdjustFlagsAndWidth(unsafeKeyword);
        this.unsafeKeyword = unsafeKeyword;
        this.AdjustFlagsAndWidth(block);
        this.block = block;
    }


    internal UnsafeStatementSyntax(SyntaxKind kind, SyntaxToken unsafeKeyword, BlockSyntax block)
        : base(kind)
    {
        this.SlotCount = 2;
        this.AdjustFlagsAndWidth(unsafeKeyword);
        this.unsafeKeyword = unsafeKeyword;
        this.AdjustFlagsAndWidth(block);
        this.block = block;
    }

    public SyntaxToken UnsafeKeyword { get { return this.unsafeKeyword; } }
    public BlockSyntax Block { get { return this.block; } }

    internal override GreenNode GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.unsafeKeyword;
            case 1: return this.block;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode parent, int position)
    {
      return new CSharp.Syntax.UnsafeStatementSyntax(this, parent, position);
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitUnsafeStatement(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitUnsafeStatement(this);
    }

    public UnsafeStatementSyntax Update(SyntaxToken unsafeKeyword, BlockSyntax block)
    {
        if (unsafeKeyword != this.UnsafeKeyword || block != this.Block)
        {
            var newNode = SyntaxFactory.UnsafeStatement(unsafeKeyword, block);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
    {
         return new UnsafeStatementSyntax(this.Kind, this.unsafeKeyword, this.block, diagnostics, GetAnnotations());
    }

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
    {
         return new UnsafeStatementSyntax(this.Kind, this.unsafeKeyword, this.block, GetDiagnostics(), annotations);
    }

    internal UnsafeStatementSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 2;
      var unsafeKeyword = (SyntaxToken)reader.ReadValue();
      if (unsafeKeyword != null)
      {
         AdjustFlagsAndWidth(unsafeKeyword);
         this.unsafeKeyword = unsafeKeyword;
      }
      var block = (BlockSyntax)reader.ReadValue();
      if (block != null)
      {
         AdjustFlagsAndWidth(block);
         this.block = block;
      }
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.unsafeKeyword);
      writer.WriteValue(this.block);
    }

    static UnsafeStatementSyntax()
    {
       ObjectBinder.RegisterTypeReader(typeof(UnsafeStatementSyntax), r => new UnsafeStatementSyntax(r));
    }
  }

  internal sealed partial class LockStatementSyntax : StatementSyntax
  {
    internal readonly SyntaxToken lockKeyword;
    internal readonly SyntaxToken openParenToken;
    internal readonly ExpressionSyntax expression;
    internal readonly SyntaxToken closeParenToken;
    internal readonly StatementSyntax statement;

    internal LockStatementSyntax(SyntaxKind kind, SyntaxToken lockKeyword, SyntaxToken openParenToken, ExpressionSyntax expression, SyntaxToken closeParenToken, StatementSyntax statement, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 5;
        this.AdjustFlagsAndWidth(lockKeyword);
        this.lockKeyword = lockKeyword;
        this.AdjustFlagsAndWidth(openParenToken);
        this.openParenToken = openParenToken;
        this.AdjustFlagsAndWidth(expression);
        this.expression = expression;
        this.AdjustFlagsAndWidth(closeParenToken);
        this.closeParenToken = closeParenToken;
        this.AdjustFlagsAndWidth(statement);
        this.statement = statement;
    }


    internal LockStatementSyntax(SyntaxKind kind, SyntaxToken lockKeyword, SyntaxToken openParenToken, ExpressionSyntax expression, SyntaxToken closeParenToken, StatementSyntax statement, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 5;
        this.AdjustFlagsAndWidth(lockKeyword);
        this.lockKeyword = lockKeyword;
        this.AdjustFlagsAndWidth(openParenToken);
        this.openParenToken = openParenToken;
        this.AdjustFlagsAndWidth(expression);
        this.expression = expression;
        this.AdjustFlagsAndWidth(closeParenToken);
        this.closeParenToken = closeParenToken;
        this.AdjustFlagsAndWidth(statement);
        this.statement = statement;
    }


    internal LockStatementSyntax(SyntaxKind kind, SyntaxToken lockKeyword, SyntaxToken openParenToken, ExpressionSyntax expression, SyntaxToken closeParenToken, StatementSyntax statement)
        : base(kind)
    {
        this.SlotCount = 5;
        this.AdjustFlagsAndWidth(lockKeyword);
        this.lockKeyword = lockKeyword;
        this.AdjustFlagsAndWidth(openParenToken);
        this.openParenToken = openParenToken;
        this.AdjustFlagsAndWidth(expression);
        this.expression = expression;
        this.AdjustFlagsAndWidth(closeParenToken);
        this.closeParenToken = closeParenToken;
        this.AdjustFlagsAndWidth(statement);
        this.statement = statement;
    }

    public SyntaxToken LockKeyword { get { return this.lockKeyword; } }
    public SyntaxToken OpenParenToken { get { return this.openParenToken; } }
    public ExpressionSyntax Expression { get { return this.expression; } }
    public SyntaxToken CloseParenToken { get { return this.closeParenToken; } }
    public StatementSyntax Statement { get { return this.statement; } }

    internal override GreenNode GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.lockKeyword;
            case 1: return this.openParenToken;
            case 2: return this.expression;
            case 3: return this.closeParenToken;
            case 4: return this.statement;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode parent, int position)
    {
      return new CSharp.Syntax.LockStatementSyntax(this, parent, position);
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitLockStatement(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitLockStatement(this);
    }

    public LockStatementSyntax Update(SyntaxToken lockKeyword, SyntaxToken openParenToken, ExpressionSyntax expression, SyntaxToken closeParenToken, StatementSyntax statement)
    {
        if (lockKeyword != this.LockKeyword || openParenToken != this.OpenParenToken || expression != this.Expression || closeParenToken != this.CloseParenToken || statement != this.Statement)
        {
            var newNode = SyntaxFactory.LockStatement(lockKeyword, openParenToken, expression, closeParenToken, statement);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
    {
         return new LockStatementSyntax(this.Kind, this.lockKeyword, this.openParenToken, this.expression, this.closeParenToken, this.statement, diagnostics, GetAnnotations());
    }

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
    {
         return new LockStatementSyntax(this.Kind, this.lockKeyword, this.openParenToken, this.expression, this.closeParenToken, this.statement, GetDiagnostics(), annotations);
    }

    internal LockStatementSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 5;
      var lockKeyword = (SyntaxToken)reader.ReadValue();
      if (lockKeyword != null)
      {
         AdjustFlagsAndWidth(lockKeyword);
         this.lockKeyword = lockKeyword;
      }
      var openParenToken = (SyntaxToken)reader.ReadValue();
      if (openParenToken != null)
      {
         AdjustFlagsAndWidth(openParenToken);
         this.openParenToken = openParenToken;
      }
      var expression = (ExpressionSyntax)reader.ReadValue();
      if (expression != null)
      {
         AdjustFlagsAndWidth(expression);
         this.expression = expression;
      }
      var closeParenToken = (SyntaxToken)reader.ReadValue();
      if (closeParenToken != null)
      {
         AdjustFlagsAndWidth(closeParenToken);
         this.closeParenToken = closeParenToken;
      }
      var statement = (StatementSyntax)reader.ReadValue();
      if (statement != null)
      {
         AdjustFlagsAndWidth(statement);
         this.statement = statement;
      }
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.lockKeyword);
      writer.WriteValue(this.openParenToken);
      writer.WriteValue(this.expression);
      writer.WriteValue(this.closeParenToken);
      writer.WriteValue(this.statement);
    }

    static LockStatementSyntax()
    {
       ObjectBinder.RegisterTypeReader(typeof(LockStatementSyntax), r => new LockStatementSyntax(r));
    }
  }

  /// <summary>
  /// Represents an if statement syntax.
  /// </summary>
  internal sealed partial class IfStatementSyntax : StatementSyntax
  {
    internal readonly SyntaxToken ifKeyword;
    internal readonly SyntaxToken openParenToken;
    internal readonly ExpressionSyntax condition;
    internal readonly SyntaxToken closeParenToken;
    internal readonly StatementSyntax statement;
    internal readonly ElseClauseSyntax @else;

    internal IfStatementSyntax(SyntaxKind kind, SyntaxToken ifKeyword, SyntaxToken openParenToken, ExpressionSyntax condition, SyntaxToken closeParenToken, StatementSyntax statement, ElseClauseSyntax @else, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 6;
        this.AdjustFlagsAndWidth(ifKeyword);
        this.ifKeyword = ifKeyword;
        this.AdjustFlagsAndWidth(openParenToken);
        this.openParenToken = openParenToken;
        this.AdjustFlagsAndWidth(condition);
        this.condition = condition;
        this.AdjustFlagsAndWidth(closeParenToken);
        this.closeParenToken = closeParenToken;
        this.AdjustFlagsAndWidth(statement);
        this.statement = statement;
        if (@else != null)
        {
            this.AdjustFlagsAndWidth(@else);
            this.@else = @else;
        }
    }


    internal IfStatementSyntax(SyntaxKind kind, SyntaxToken ifKeyword, SyntaxToken openParenToken, ExpressionSyntax condition, SyntaxToken closeParenToken, StatementSyntax statement, ElseClauseSyntax @else, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 6;
        this.AdjustFlagsAndWidth(ifKeyword);
        this.ifKeyword = ifKeyword;
        this.AdjustFlagsAndWidth(openParenToken);
        this.openParenToken = openParenToken;
        this.AdjustFlagsAndWidth(condition);
        this.condition = condition;
        this.AdjustFlagsAndWidth(closeParenToken);
        this.closeParenToken = closeParenToken;
        this.AdjustFlagsAndWidth(statement);
        this.statement = statement;
        if (@else != null)
        {
            this.AdjustFlagsAndWidth(@else);
            this.@else = @else;
        }
    }


    internal IfStatementSyntax(SyntaxKind kind, SyntaxToken ifKeyword, SyntaxToken openParenToken, ExpressionSyntax condition, SyntaxToken closeParenToken, StatementSyntax statement, ElseClauseSyntax @else)
        : base(kind)
    {
        this.SlotCount = 6;
        this.AdjustFlagsAndWidth(ifKeyword);
        this.ifKeyword = ifKeyword;
        this.AdjustFlagsAndWidth(openParenToken);
        this.openParenToken = openParenToken;
        this.AdjustFlagsAndWidth(condition);
        this.condition = condition;
        this.AdjustFlagsAndWidth(closeParenToken);
        this.closeParenToken = closeParenToken;
        this.AdjustFlagsAndWidth(statement);
        this.statement = statement;
        if (@else != null)
        {
            this.AdjustFlagsAndWidth(@else);
            this.@else = @else;
        }
    }

    /// <summary>
    /// Gets a SyntaxToken that represents the if keyword.
    /// </summary>
    public SyntaxToken IfKeyword { get { return this.ifKeyword; } }
    /// <summary>
    /// Gets a SyntaxToken that represents the open parenthesis before the if statement's condition expression.
    /// </summary>
    public SyntaxToken OpenParenToken { get { return this.openParenToken; } }
    /// <summary>
    /// Gets an ExpressionSyntax that represents the condition of the if statement.
    /// </summary>
    public ExpressionSyntax Condition { get { return this.condition; } }
    /// <summary>
    /// Gets a SyntaxToken that represents the close parenthesis after the if statement's condition expression.
    /// </summary>
    public SyntaxToken CloseParenToken { get { return this.closeParenToken; } }
    /// <summary>
    /// Gets a StatementSyntax the represents the statement to be executed when the condition is true.
    /// </summary>
    public StatementSyntax Statement { get { return this.statement; } }
    /// <summary>
    /// Gets an ElseClauseSyntax that represents the statement to be executed when the condition is false if such statement exists.
    /// </summary>
    public ElseClauseSyntax Else { get { return this.@else; } }

    internal override GreenNode GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.ifKeyword;
            case 1: return this.openParenToken;
            case 2: return this.condition;
            case 3: return this.closeParenToken;
            case 4: return this.statement;
            case 5: return this.@else;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode parent, int position)
    {
      return new CSharp.Syntax.IfStatementSyntax(this, parent, position);
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitIfStatement(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitIfStatement(this);
    }

    public IfStatementSyntax Update(SyntaxToken ifKeyword, SyntaxToken openParenToken, ExpressionSyntax condition, SyntaxToken closeParenToken, StatementSyntax statement, ElseClauseSyntax @else)
    {
        if (ifKeyword != this.IfKeyword || openParenToken != this.OpenParenToken || condition != this.Condition || closeParenToken != this.CloseParenToken || statement != this.Statement || @else != this.Else)
        {
            var newNode = SyntaxFactory.IfStatement(ifKeyword, openParenToken, condition, closeParenToken, statement, @else);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
    {
         return new IfStatementSyntax(this.Kind, this.ifKeyword, this.openParenToken, this.condition, this.closeParenToken, this.statement, this.@else, diagnostics, GetAnnotations());
    }

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
    {
         return new IfStatementSyntax(this.Kind, this.ifKeyword, this.openParenToken, this.condition, this.closeParenToken, this.statement, this.@else, GetDiagnostics(), annotations);
    }

    internal IfStatementSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 6;
      var ifKeyword = (SyntaxToken)reader.ReadValue();
      if (ifKeyword != null)
      {
         AdjustFlagsAndWidth(ifKeyword);
         this.ifKeyword = ifKeyword;
      }
      var openParenToken = (SyntaxToken)reader.ReadValue();
      if (openParenToken != null)
      {
         AdjustFlagsAndWidth(openParenToken);
         this.openParenToken = openParenToken;
      }
      var condition = (ExpressionSyntax)reader.ReadValue();
      if (condition != null)
      {
         AdjustFlagsAndWidth(condition);
         this.condition = condition;
      }
      var closeParenToken = (SyntaxToken)reader.ReadValue();
      if (closeParenToken != null)
      {
         AdjustFlagsAndWidth(closeParenToken);
         this.closeParenToken = closeParenToken;
      }
      var statement = (StatementSyntax)reader.ReadValue();
      if (statement != null)
      {
         AdjustFlagsAndWidth(statement);
         this.statement = statement;
      }
      var @else = (ElseClauseSyntax)reader.ReadValue();
      if (@else != null)
      {
         AdjustFlagsAndWidth(@else);
         this.@else = @else;
      }
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.ifKeyword);
      writer.WriteValue(this.openParenToken);
      writer.WriteValue(this.condition);
      writer.WriteValue(this.closeParenToken);
      writer.WriteValue(this.statement);
      writer.WriteValue(this.@else);
    }

    static IfStatementSyntax()
    {
       ObjectBinder.RegisterTypeReader(typeof(IfStatementSyntax), r => new IfStatementSyntax(r));
    }
  }

  /// <summary>Represents an else statement syntax.</summary>
  internal sealed partial class ElseClauseSyntax : CSharpSyntaxNode
  {
    internal readonly SyntaxToken elseKeyword;
    internal readonly StatementSyntax statement;

    internal ElseClauseSyntax(SyntaxKind kind, SyntaxToken elseKeyword, StatementSyntax statement, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 2;
        this.AdjustFlagsAndWidth(elseKeyword);
        this.elseKeyword = elseKeyword;
        this.AdjustFlagsAndWidth(statement);
        this.statement = statement;
    }


    internal ElseClauseSyntax(SyntaxKind kind, SyntaxToken elseKeyword, StatementSyntax statement, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 2;
        this.AdjustFlagsAndWidth(elseKeyword);
        this.elseKeyword = elseKeyword;
        this.AdjustFlagsAndWidth(statement);
        this.statement = statement;
    }


    internal ElseClauseSyntax(SyntaxKind kind, SyntaxToken elseKeyword, StatementSyntax statement)
        : base(kind)
    {
        this.SlotCount = 2;
        this.AdjustFlagsAndWidth(elseKeyword);
        this.elseKeyword = elseKeyword;
        this.AdjustFlagsAndWidth(statement);
        this.statement = statement;
    }

    /// <summary>
    /// Gets a syntax token
    /// </summary>
    public SyntaxToken ElseKeyword { get { return this.elseKeyword; } }
    public StatementSyntax Statement { get { return this.statement; } }

    internal override GreenNode GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.elseKeyword;
            case 1: return this.statement;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode parent, int position)
    {
      return new CSharp.Syntax.ElseClauseSyntax(this, parent, position);
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitElseClause(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitElseClause(this);
    }

    public ElseClauseSyntax Update(SyntaxToken elseKeyword, StatementSyntax statement)
    {
        if (elseKeyword != this.ElseKeyword || statement != this.Statement)
        {
            var newNode = SyntaxFactory.ElseClause(elseKeyword, statement);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
    {
         return new ElseClauseSyntax(this.Kind, this.elseKeyword, this.statement, diagnostics, GetAnnotations());
    }

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
    {
         return new ElseClauseSyntax(this.Kind, this.elseKeyword, this.statement, GetDiagnostics(), annotations);
    }

    internal ElseClauseSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 2;
      var elseKeyword = (SyntaxToken)reader.ReadValue();
      if (elseKeyword != null)
      {
         AdjustFlagsAndWidth(elseKeyword);
         this.elseKeyword = elseKeyword;
      }
      var statement = (StatementSyntax)reader.ReadValue();
      if (statement != null)
      {
         AdjustFlagsAndWidth(statement);
         this.statement = statement;
      }
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.elseKeyword);
      writer.WriteValue(this.statement);
    }

    static ElseClauseSyntax()
    {
       ObjectBinder.RegisterTypeReader(typeof(ElseClauseSyntax), r => new ElseClauseSyntax(r));
    }
  }

  /// <summary>Represents a switch statement syntax.</summary>
  internal sealed partial class SwitchStatementSyntax : StatementSyntax
  {
    internal readonly SyntaxToken switchKeyword;
    internal readonly SyntaxToken openParenToken;
    internal readonly ExpressionSyntax expression;
    internal readonly SyntaxToken closeParenToken;
    internal readonly SyntaxToken openBraceToken;
    internal readonly GreenNode sections;
    internal readonly SyntaxToken closeBraceToken;

    internal SwitchStatementSyntax(SyntaxKind kind, SyntaxToken switchKeyword, SyntaxToken openParenToken, ExpressionSyntax expression, SyntaxToken closeParenToken, SyntaxToken openBraceToken, GreenNode sections, SyntaxToken closeBraceToken, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 7;
        this.AdjustFlagsAndWidth(switchKeyword);
        this.switchKeyword = switchKeyword;
        this.AdjustFlagsAndWidth(openParenToken);
        this.openParenToken = openParenToken;
        this.AdjustFlagsAndWidth(expression);
        this.expression = expression;
        this.AdjustFlagsAndWidth(closeParenToken);
        this.closeParenToken = closeParenToken;
        this.AdjustFlagsAndWidth(openBraceToken);
        this.openBraceToken = openBraceToken;
        if (sections != null)
        {
            this.AdjustFlagsAndWidth(sections);
            this.sections = sections;
        }
        this.AdjustFlagsAndWidth(closeBraceToken);
        this.closeBraceToken = closeBraceToken;
    }


    internal SwitchStatementSyntax(SyntaxKind kind, SyntaxToken switchKeyword, SyntaxToken openParenToken, ExpressionSyntax expression, SyntaxToken closeParenToken, SyntaxToken openBraceToken, GreenNode sections, SyntaxToken closeBraceToken, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 7;
        this.AdjustFlagsAndWidth(switchKeyword);
        this.switchKeyword = switchKeyword;
        this.AdjustFlagsAndWidth(openParenToken);
        this.openParenToken = openParenToken;
        this.AdjustFlagsAndWidth(expression);
        this.expression = expression;
        this.AdjustFlagsAndWidth(closeParenToken);
        this.closeParenToken = closeParenToken;
        this.AdjustFlagsAndWidth(openBraceToken);
        this.openBraceToken = openBraceToken;
        if (sections != null)
        {
            this.AdjustFlagsAndWidth(sections);
            this.sections = sections;
        }
        this.AdjustFlagsAndWidth(closeBraceToken);
        this.closeBraceToken = closeBraceToken;
    }


    internal SwitchStatementSyntax(SyntaxKind kind, SyntaxToken switchKeyword, SyntaxToken openParenToken, ExpressionSyntax expression, SyntaxToken closeParenToken, SyntaxToken openBraceToken, GreenNode sections, SyntaxToken closeBraceToken)
        : base(kind)
    {
        this.SlotCount = 7;
        this.AdjustFlagsAndWidth(switchKeyword);
        this.switchKeyword = switchKeyword;
        this.AdjustFlagsAndWidth(openParenToken);
        this.openParenToken = openParenToken;
        this.AdjustFlagsAndWidth(expression);
        this.expression = expression;
        this.AdjustFlagsAndWidth(closeParenToken);
        this.closeParenToken = closeParenToken;
        this.AdjustFlagsAndWidth(openBraceToken);
        this.openBraceToken = openBraceToken;
        if (sections != null)
        {
            this.AdjustFlagsAndWidth(sections);
            this.sections = sections;
        }
        this.AdjustFlagsAndWidth(closeBraceToken);
        this.closeBraceToken = closeBraceToken;
    }

    /// <summary>
    /// Gets a SyntaxToken that represents the switch keyword.
    /// </summary>
    public SyntaxToken SwitchKeyword { get { return this.switchKeyword; } }
    /// <summary>
    /// Gets a SyntaxToken that represents the open parenthesis preceding the switch expression.
    /// </summary>
    public SyntaxToken OpenParenToken { get { return this.openParenToken; } }
    /// <summary>
    /// Gets an ExpressionSyntax representing the expression of the switch statement.
    /// </summary>
    public ExpressionSyntax Expression { get { return this.expression; } }
    /// <summary>
    /// Gets a SyntaxToken that represents the close parenthesis succeeding the switch expression.
    /// </summary>
    public SyntaxToken CloseParenToken { get { return this.closeParenToken; } }
    /// <summary>
    /// Gets a SyntaxToken that represents the open braces preceding the switch sections.
    /// </summary>
    public SyntaxToken OpenBraceToken { get { return this.openBraceToken; } }
    /// <summary>
    /// Gets a SyntaxList of SwitchSectionSyntax's that represents the switch sections of the switch statement.
    /// </summary>
    public Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SwitchSectionSyntax> Sections { get { return new Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SwitchSectionSyntax>(this.sections); } }
    /// <summary>
    /// Gets a SyntaxToken that represents the open braces succeeding the switch sections.
    /// </summary>
    public SyntaxToken CloseBraceToken { get { return this.closeBraceToken; } }

    internal override GreenNode GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.switchKeyword;
            case 1: return this.openParenToken;
            case 2: return this.expression;
            case 3: return this.closeParenToken;
            case 4: return this.openBraceToken;
            case 5: return this.sections;
            case 6: return this.closeBraceToken;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode parent, int position)
    {
      return new CSharp.Syntax.SwitchStatementSyntax(this, parent, position);
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitSwitchStatement(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitSwitchStatement(this);
    }

    public SwitchStatementSyntax Update(SyntaxToken switchKeyword, SyntaxToken openParenToken, ExpressionSyntax expression, SyntaxToken closeParenToken, SyntaxToken openBraceToken, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SwitchSectionSyntax> sections, SyntaxToken closeBraceToken)
    {
        if (switchKeyword != this.SwitchKeyword || openParenToken != this.OpenParenToken || expression != this.Expression || closeParenToken != this.CloseParenToken || openBraceToken != this.OpenBraceToken || sections != this.Sections || closeBraceToken != this.CloseBraceToken)
        {
            var newNode = SyntaxFactory.SwitchStatement(switchKeyword, openParenToken, expression, closeParenToken, openBraceToken, sections, closeBraceToken);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
    {
         return new SwitchStatementSyntax(this.Kind, this.switchKeyword, this.openParenToken, this.expression, this.closeParenToken, this.openBraceToken, this.sections, this.closeBraceToken, diagnostics, GetAnnotations());
    }

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
    {
         return new SwitchStatementSyntax(this.Kind, this.switchKeyword, this.openParenToken, this.expression, this.closeParenToken, this.openBraceToken, this.sections, this.closeBraceToken, GetDiagnostics(), annotations);
    }

    internal SwitchStatementSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 7;
      var switchKeyword = (SyntaxToken)reader.ReadValue();
      if (switchKeyword != null)
      {
         AdjustFlagsAndWidth(switchKeyword);
         this.switchKeyword = switchKeyword;
      }
      var openParenToken = (SyntaxToken)reader.ReadValue();
      if (openParenToken != null)
      {
         AdjustFlagsAndWidth(openParenToken);
         this.openParenToken = openParenToken;
      }
      var expression = (ExpressionSyntax)reader.ReadValue();
      if (expression != null)
      {
         AdjustFlagsAndWidth(expression);
         this.expression = expression;
      }
      var closeParenToken = (SyntaxToken)reader.ReadValue();
      if (closeParenToken != null)
      {
         AdjustFlagsAndWidth(closeParenToken);
         this.closeParenToken = closeParenToken;
      }
      var openBraceToken = (SyntaxToken)reader.ReadValue();
      if (openBraceToken != null)
      {
         AdjustFlagsAndWidth(openBraceToken);
         this.openBraceToken = openBraceToken;
      }
      var sections = (GreenNode)reader.ReadValue();
      if (sections != null)
      {
         AdjustFlagsAndWidth(sections);
         this.sections = sections;
      }
      var closeBraceToken = (SyntaxToken)reader.ReadValue();
      if (closeBraceToken != null)
      {
         AdjustFlagsAndWidth(closeBraceToken);
         this.closeBraceToken = closeBraceToken;
      }
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.switchKeyword);
      writer.WriteValue(this.openParenToken);
      writer.WriteValue(this.expression);
      writer.WriteValue(this.closeParenToken);
      writer.WriteValue(this.openBraceToken);
      writer.WriteValue(this.sections);
      writer.WriteValue(this.closeBraceToken);
    }

    static SwitchStatementSyntax()
    {
       ObjectBinder.RegisterTypeReader(typeof(SwitchStatementSyntax), r => new SwitchStatementSyntax(r));
    }
  }

  /// <summary>Represents a switch section syntax of a switch statement.</summary>
  internal sealed partial class SwitchSectionSyntax : CSharpSyntaxNode
  {
    internal readonly GreenNode labels;
    internal readonly GreenNode statements;

    internal SwitchSectionSyntax(SyntaxKind kind, GreenNode labels, GreenNode statements, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 2;
        if (labels != null)
        {
            this.AdjustFlagsAndWidth(labels);
            this.labels = labels;
        }
        if (statements != null)
        {
            this.AdjustFlagsAndWidth(statements);
            this.statements = statements;
        }
    }


    internal SwitchSectionSyntax(SyntaxKind kind, GreenNode labels, GreenNode statements, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 2;
        if (labels != null)
        {
            this.AdjustFlagsAndWidth(labels);
            this.labels = labels;
        }
        if (statements != null)
        {
            this.AdjustFlagsAndWidth(statements);
            this.statements = statements;
        }
    }


    internal SwitchSectionSyntax(SyntaxKind kind, GreenNode labels, GreenNode statements)
        : base(kind)
    {
        this.SlotCount = 2;
        if (labels != null)
        {
            this.AdjustFlagsAndWidth(labels);
            this.labels = labels;
        }
        if (statements != null)
        {
            this.AdjustFlagsAndWidth(statements);
            this.statements = statements;
        }
    }

    /// <summary>
    /// Gets a SyntaxList of SwitchLabelSyntax's the represents the possible labels that control can transfer to within the section.
    /// </summary>
    public Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SwitchLabelSyntax> Labels { get { return new Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SwitchLabelSyntax>(this.labels); } }
    /// <summary>
    /// Gets a SyntaxList of StatementSyntax's the represents the statements to be executed when control transfer to a label the belongs to the section.
    /// </summary>
    public Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<StatementSyntax> Statements { get { return new Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<StatementSyntax>(this.statements); } }

    internal override GreenNode GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.labels;
            case 1: return this.statements;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode parent, int position)
    {
      return new CSharp.Syntax.SwitchSectionSyntax(this, parent, position);
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitSwitchSection(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitSwitchSection(this);
    }

    public SwitchSectionSyntax Update(Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SwitchLabelSyntax> labels, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<StatementSyntax> statements)
    {
        if (labels != this.Labels || statements != this.Statements)
        {
            var newNode = SyntaxFactory.SwitchSection(labels, statements);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
    {
         return new SwitchSectionSyntax(this.Kind, this.labels, this.statements, diagnostics, GetAnnotations());
    }

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
    {
         return new SwitchSectionSyntax(this.Kind, this.labels, this.statements, GetDiagnostics(), annotations);
    }

    internal SwitchSectionSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 2;
      var labels = (GreenNode)reader.ReadValue();
      if (labels != null)
      {
         AdjustFlagsAndWidth(labels);
         this.labels = labels;
      }
      var statements = (GreenNode)reader.ReadValue();
      if (statements != null)
      {
         AdjustFlagsAndWidth(statements);
         this.statements = statements;
      }
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.labels);
      writer.WriteValue(this.statements);
    }

    static SwitchSectionSyntax()
    {
       ObjectBinder.RegisterTypeReader(typeof(SwitchSectionSyntax), r => new SwitchSectionSyntax(r));
    }
  }

  /// <summary>Represents a switch label within a switch statement.</summary>
  internal abstract partial class SwitchLabelSyntax : CSharpSyntaxNode
  {
    internal SwitchLabelSyntax(SyntaxKind kind, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
      : base(kind, diagnostics, annotations)
    {
    }
    internal SwitchLabelSyntax(SyntaxKind kind)
      : base(kind)
    {
    }

    protected SwitchLabelSyntax(ObjectReader reader)
       : base(reader)
    {
    }

    /// <summary>
    /// Gets a SyntaxToken that represents a case or default keyword that belongs to a switch label.
    /// </summary>
    public abstract SyntaxToken Keyword { get; }

    /// <summary>
    /// Gets a SyntaxToken that represents the colon that terminates the switch label.
    /// </summary>
    public abstract SyntaxToken ColonToken { get; }
  }

  /// <summary>Represents a case label within a switch statement.</summary>
  internal sealed partial class CasePatternSwitchLabelSyntax : SwitchLabelSyntax
  {
    internal readonly SyntaxToken keyword;
    internal readonly PatternSyntax pattern;
    internal readonly WhenClauseSyntax whenClause;
    internal readonly SyntaxToken colonToken;

    internal CasePatternSwitchLabelSyntax(SyntaxKind kind, SyntaxToken keyword, PatternSyntax pattern, WhenClauseSyntax whenClause, SyntaxToken colonToken, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 4;
        this.AdjustFlagsAndWidth(keyword);
        this.keyword = keyword;
        this.AdjustFlagsAndWidth(pattern);
        this.pattern = pattern;
        if (whenClause != null)
        {
            this.AdjustFlagsAndWidth(whenClause);
            this.whenClause = whenClause;
        }
        this.AdjustFlagsAndWidth(colonToken);
        this.colonToken = colonToken;
    }


    internal CasePatternSwitchLabelSyntax(SyntaxKind kind, SyntaxToken keyword, PatternSyntax pattern, WhenClauseSyntax whenClause, SyntaxToken colonToken, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 4;
        this.AdjustFlagsAndWidth(keyword);
        this.keyword = keyword;
        this.AdjustFlagsAndWidth(pattern);
        this.pattern = pattern;
        if (whenClause != null)
        {
            this.AdjustFlagsAndWidth(whenClause);
            this.whenClause = whenClause;
        }
        this.AdjustFlagsAndWidth(colonToken);
        this.colonToken = colonToken;
    }


    internal CasePatternSwitchLabelSyntax(SyntaxKind kind, SyntaxToken keyword, PatternSyntax pattern, WhenClauseSyntax whenClause, SyntaxToken colonToken)
        : base(kind)
    {
        this.SlotCount = 4;
        this.AdjustFlagsAndWidth(keyword);
        this.keyword = keyword;
        this.AdjustFlagsAndWidth(pattern);
        this.pattern = pattern;
        if (whenClause != null)
        {
            this.AdjustFlagsAndWidth(whenClause);
            this.whenClause = whenClause;
        }
        this.AdjustFlagsAndWidth(colonToken);
        this.colonToken = colonToken;
    }

    /// <summary>Gets the case keyword token.</summary>
    public override SyntaxToken Keyword { get { return this.keyword; } }
    /// <summary>
    /// Gets a PatternSyntax that represents the pattern that gets matched for the case label.
    /// </summary>
    public PatternSyntax Pattern { get { return this.pattern; } }
    public WhenClauseSyntax WhenClause { get { return this.whenClause; } }
    public override SyntaxToken ColonToken { get { return this.colonToken; } }

    internal override GreenNode GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.keyword;
            case 1: return this.pattern;
            case 2: return this.whenClause;
            case 3: return this.colonToken;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode parent, int position)
    {
      return new CSharp.Syntax.CasePatternSwitchLabelSyntax(this, parent, position);
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitCasePatternSwitchLabel(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitCasePatternSwitchLabel(this);
    }

    public CasePatternSwitchLabelSyntax Update(SyntaxToken keyword, PatternSyntax pattern, WhenClauseSyntax whenClause, SyntaxToken colonToken)
    {
        if (keyword != this.Keyword || pattern != this.Pattern || whenClause != this.WhenClause || colonToken != this.ColonToken)
        {
            var newNode = SyntaxFactory.CasePatternSwitchLabel(keyword, pattern, whenClause, colonToken);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
    {
         return new CasePatternSwitchLabelSyntax(this.Kind, this.keyword, this.pattern, this.whenClause, this.colonToken, diagnostics, GetAnnotations());
    }

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
    {
         return new CasePatternSwitchLabelSyntax(this.Kind, this.keyword, this.pattern, this.whenClause, this.colonToken, GetDiagnostics(), annotations);
    }

    internal CasePatternSwitchLabelSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 4;
      var keyword = (SyntaxToken)reader.ReadValue();
      if (keyword != null)
      {
         AdjustFlagsAndWidth(keyword);
         this.keyword = keyword;
      }
      var pattern = (PatternSyntax)reader.ReadValue();
      if (pattern != null)
      {
         AdjustFlagsAndWidth(pattern);
         this.pattern = pattern;
      }
      var whenClause = (WhenClauseSyntax)reader.ReadValue();
      if (whenClause != null)
      {
         AdjustFlagsAndWidth(whenClause);
         this.whenClause = whenClause;
      }
      var colonToken = (SyntaxToken)reader.ReadValue();
      if (colonToken != null)
      {
         AdjustFlagsAndWidth(colonToken);
         this.colonToken = colonToken;
      }
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.keyword);
      writer.WriteValue(this.pattern);
      writer.WriteValue(this.whenClause);
      writer.WriteValue(this.colonToken);
    }

    static CasePatternSwitchLabelSyntax()
    {
       ObjectBinder.RegisterTypeReader(typeof(CasePatternSwitchLabelSyntax), r => new CasePatternSwitchLabelSyntax(r));
    }
  }

  /// <summary>Represents a case label within a switch statement.</summary>
  internal sealed partial class CaseSwitchLabelSyntax : SwitchLabelSyntax
  {
    internal readonly SyntaxToken keyword;
    internal readonly ExpressionSyntax value;
    internal readonly SyntaxToken colonToken;

    internal CaseSwitchLabelSyntax(SyntaxKind kind, SyntaxToken keyword, ExpressionSyntax value, SyntaxToken colonToken, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 3;
        this.AdjustFlagsAndWidth(keyword);
        this.keyword = keyword;
        this.AdjustFlagsAndWidth(value);
        this.value = value;
        this.AdjustFlagsAndWidth(colonToken);
        this.colonToken = colonToken;
    }


    internal CaseSwitchLabelSyntax(SyntaxKind kind, SyntaxToken keyword, ExpressionSyntax value, SyntaxToken colonToken, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 3;
        this.AdjustFlagsAndWidth(keyword);
        this.keyword = keyword;
        this.AdjustFlagsAndWidth(value);
        this.value = value;
        this.AdjustFlagsAndWidth(colonToken);
        this.colonToken = colonToken;
    }


    internal CaseSwitchLabelSyntax(SyntaxKind kind, SyntaxToken keyword, ExpressionSyntax value, SyntaxToken colonToken)
        : base(kind)
    {
        this.SlotCount = 3;
        this.AdjustFlagsAndWidth(keyword);
        this.keyword = keyword;
        this.AdjustFlagsAndWidth(value);
        this.value = value;
        this.AdjustFlagsAndWidth(colonToken);
        this.colonToken = colonToken;
    }

    /// <summary>Gets the case keyword token.</summary>
    public override SyntaxToken Keyword { get { return this.keyword; } }
    /// <summary>
    /// Gets an ExpressionSyntax that represents the constant expression that gets matched for the case label.
    /// </summary>
    public ExpressionSyntax Value { get { return this.value; } }
    public override SyntaxToken ColonToken { get { return this.colonToken; } }

    internal override GreenNode GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.keyword;
            case 1: return this.value;
            case 2: return this.colonToken;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode parent, int position)
    {
      return new CSharp.Syntax.CaseSwitchLabelSyntax(this, parent, position);
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitCaseSwitchLabel(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitCaseSwitchLabel(this);
    }

    public CaseSwitchLabelSyntax Update(SyntaxToken keyword, ExpressionSyntax value, SyntaxToken colonToken)
    {
        if (keyword != this.Keyword || value != this.Value || colonToken != this.ColonToken)
        {
            var newNode = SyntaxFactory.CaseSwitchLabel(keyword, value, colonToken);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
    {
         return new CaseSwitchLabelSyntax(this.Kind, this.keyword, this.value, this.colonToken, diagnostics, GetAnnotations());
    }

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
    {
         return new CaseSwitchLabelSyntax(this.Kind, this.keyword, this.value, this.colonToken, GetDiagnostics(), annotations);
    }

    internal CaseSwitchLabelSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 3;
      var keyword = (SyntaxToken)reader.ReadValue();
      if (keyword != null)
      {
         AdjustFlagsAndWidth(keyword);
         this.keyword = keyword;
      }
      var value = (ExpressionSyntax)reader.ReadValue();
      if (value != null)
      {
         AdjustFlagsAndWidth(value);
         this.value = value;
      }
      var colonToken = (SyntaxToken)reader.ReadValue();
      if (colonToken != null)
      {
         AdjustFlagsAndWidth(colonToken);
         this.colonToken = colonToken;
      }
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.keyword);
      writer.WriteValue(this.value);
      writer.WriteValue(this.colonToken);
    }

    static CaseSwitchLabelSyntax()
    {
       ObjectBinder.RegisterTypeReader(typeof(CaseSwitchLabelSyntax), r => new CaseSwitchLabelSyntax(r));
    }
  }

  /// <summary>Represents a default label within a switch statement.</summary>
  internal sealed partial class DefaultSwitchLabelSyntax : SwitchLabelSyntax
  {
    internal readonly SyntaxToken keyword;
    internal readonly SyntaxToken colonToken;

    internal DefaultSwitchLabelSyntax(SyntaxKind kind, SyntaxToken keyword, SyntaxToken colonToken, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 2;
        this.AdjustFlagsAndWidth(keyword);
        this.keyword = keyword;
        this.AdjustFlagsAndWidth(colonToken);
        this.colonToken = colonToken;
    }


    internal DefaultSwitchLabelSyntax(SyntaxKind kind, SyntaxToken keyword, SyntaxToken colonToken, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 2;
        this.AdjustFlagsAndWidth(keyword);
        this.keyword = keyword;
        this.AdjustFlagsAndWidth(colonToken);
        this.colonToken = colonToken;
    }


    internal DefaultSwitchLabelSyntax(SyntaxKind kind, SyntaxToken keyword, SyntaxToken colonToken)
        : base(kind)
    {
        this.SlotCount = 2;
        this.AdjustFlagsAndWidth(keyword);
        this.keyword = keyword;
        this.AdjustFlagsAndWidth(colonToken);
        this.colonToken = colonToken;
    }

    /// <summary>Gets the default keyword token.</summary>
    public override SyntaxToken Keyword { get { return this.keyword; } }
    public override SyntaxToken ColonToken { get { return this.colonToken; } }

    internal override GreenNode GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.keyword;
            case 1: return this.colonToken;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode parent, int position)
    {
      return new CSharp.Syntax.DefaultSwitchLabelSyntax(this, parent, position);
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitDefaultSwitchLabel(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitDefaultSwitchLabel(this);
    }

    public DefaultSwitchLabelSyntax Update(SyntaxToken keyword, SyntaxToken colonToken)
    {
        if (keyword != this.Keyword || colonToken != this.ColonToken)
        {
            var newNode = SyntaxFactory.DefaultSwitchLabel(keyword, colonToken);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
    {
         return new DefaultSwitchLabelSyntax(this.Kind, this.keyword, this.colonToken, diagnostics, GetAnnotations());
    }

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
    {
         return new DefaultSwitchLabelSyntax(this.Kind, this.keyword, this.colonToken, GetDiagnostics(), annotations);
    }

    internal DefaultSwitchLabelSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 2;
      var keyword = (SyntaxToken)reader.ReadValue();
      if (keyword != null)
      {
         AdjustFlagsAndWidth(keyword);
         this.keyword = keyword;
      }
      var colonToken = (SyntaxToken)reader.ReadValue();
      if (colonToken != null)
      {
         AdjustFlagsAndWidth(colonToken);
         this.colonToken = colonToken;
      }
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.keyword);
      writer.WriteValue(this.colonToken);
    }

    static DefaultSwitchLabelSyntax()
    {
       ObjectBinder.RegisterTypeReader(typeof(DefaultSwitchLabelSyntax), r => new DefaultSwitchLabelSyntax(r));
    }
  }

  internal sealed partial class TryStatementSyntax : StatementSyntax
  {
    internal readonly SyntaxToken tryKeyword;
    internal readonly BlockSyntax block;
    internal readonly GreenNode catches;
    internal readonly FinallyClauseSyntax @finally;

    internal TryStatementSyntax(SyntaxKind kind, SyntaxToken tryKeyword, BlockSyntax block, GreenNode catches, FinallyClauseSyntax @finally, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 4;
        this.AdjustFlagsAndWidth(tryKeyword);
        this.tryKeyword = tryKeyword;
        this.AdjustFlagsAndWidth(block);
        this.block = block;
        if (catches != null)
        {
            this.AdjustFlagsAndWidth(catches);
            this.catches = catches;
        }
        if (@finally != null)
        {
            this.AdjustFlagsAndWidth(@finally);
            this.@finally = @finally;
        }
    }


    internal TryStatementSyntax(SyntaxKind kind, SyntaxToken tryKeyword, BlockSyntax block, GreenNode catches, FinallyClauseSyntax @finally, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 4;
        this.AdjustFlagsAndWidth(tryKeyword);
        this.tryKeyword = tryKeyword;
        this.AdjustFlagsAndWidth(block);
        this.block = block;
        if (catches != null)
        {
            this.AdjustFlagsAndWidth(catches);
            this.catches = catches;
        }
        if (@finally != null)
        {
            this.AdjustFlagsAndWidth(@finally);
            this.@finally = @finally;
        }
    }


    internal TryStatementSyntax(SyntaxKind kind, SyntaxToken tryKeyword, BlockSyntax block, GreenNode catches, FinallyClauseSyntax @finally)
        : base(kind)
    {
        this.SlotCount = 4;
        this.AdjustFlagsAndWidth(tryKeyword);
        this.tryKeyword = tryKeyword;
        this.AdjustFlagsAndWidth(block);
        this.block = block;
        if (catches != null)
        {
            this.AdjustFlagsAndWidth(catches);
            this.catches = catches;
        }
        if (@finally != null)
        {
            this.AdjustFlagsAndWidth(@finally);
            this.@finally = @finally;
        }
    }

    public SyntaxToken TryKeyword { get { return this.tryKeyword; } }
    public BlockSyntax Block { get { return this.block; } }
    public Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<CatchClauseSyntax> Catches { get { return new Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<CatchClauseSyntax>(this.catches); } }
    public FinallyClauseSyntax Finally { get { return this.@finally; } }

    internal override GreenNode GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.tryKeyword;
            case 1: return this.block;
            case 2: return this.catches;
            case 3: return this.@finally;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode parent, int position)
    {
      return new CSharp.Syntax.TryStatementSyntax(this, parent, position);
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitTryStatement(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitTryStatement(this);
    }

    public TryStatementSyntax Update(SyntaxToken tryKeyword, BlockSyntax block, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<CatchClauseSyntax> catches, FinallyClauseSyntax @finally)
    {
        if (tryKeyword != this.TryKeyword || block != this.Block || catches != this.Catches || @finally != this.Finally)
        {
            var newNode = SyntaxFactory.TryStatement(tryKeyword, block, catches, @finally);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
    {
         return new TryStatementSyntax(this.Kind, this.tryKeyword, this.block, this.catches, this.@finally, diagnostics, GetAnnotations());
    }

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
    {
         return new TryStatementSyntax(this.Kind, this.tryKeyword, this.block, this.catches, this.@finally, GetDiagnostics(), annotations);
    }

    internal TryStatementSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 4;
      var tryKeyword = (SyntaxToken)reader.ReadValue();
      if (tryKeyword != null)
      {
         AdjustFlagsAndWidth(tryKeyword);
         this.tryKeyword = tryKeyword;
      }
      var block = (BlockSyntax)reader.ReadValue();
      if (block != null)
      {
         AdjustFlagsAndWidth(block);
         this.block = block;
      }
      var catches = (GreenNode)reader.ReadValue();
      if (catches != null)
      {
         AdjustFlagsAndWidth(catches);
         this.catches = catches;
      }
      var @finally = (FinallyClauseSyntax)reader.ReadValue();
      if (@finally != null)
      {
         AdjustFlagsAndWidth(@finally);
         this.@finally = @finally;
      }
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.tryKeyword);
      writer.WriteValue(this.block);
      writer.WriteValue(this.catches);
      writer.WriteValue(this.@finally);
    }

    static TryStatementSyntax()
    {
       ObjectBinder.RegisterTypeReader(typeof(TryStatementSyntax), r => new TryStatementSyntax(r));
    }
  }

  internal sealed partial class CatchClauseSyntax : CSharpSyntaxNode
  {
    internal readonly SyntaxToken catchKeyword;
    internal readonly CatchDeclarationSyntax declaration;
    internal readonly CatchFilterClauseSyntax filter;
    internal readonly BlockSyntax block;

    internal CatchClauseSyntax(SyntaxKind kind, SyntaxToken catchKeyword, CatchDeclarationSyntax declaration, CatchFilterClauseSyntax filter, BlockSyntax block, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 4;
        this.AdjustFlagsAndWidth(catchKeyword);
        this.catchKeyword = catchKeyword;
        if (declaration != null)
        {
            this.AdjustFlagsAndWidth(declaration);
            this.declaration = declaration;
        }
        if (filter != null)
        {
            this.AdjustFlagsAndWidth(filter);
            this.filter = filter;
        }
        this.AdjustFlagsAndWidth(block);
        this.block = block;
    }


    internal CatchClauseSyntax(SyntaxKind kind, SyntaxToken catchKeyword, CatchDeclarationSyntax declaration, CatchFilterClauseSyntax filter, BlockSyntax block, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 4;
        this.AdjustFlagsAndWidth(catchKeyword);
        this.catchKeyword = catchKeyword;
        if (declaration != null)
        {
            this.AdjustFlagsAndWidth(declaration);
            this.declaration = declaration;
        }
        if (filter != null)
        {
            this.AdjustFlagsAndWidth(filter);
            this.filter = filter;
        }
        this.AdjustFlagsAndWidth(block);
        this.block = block;
    }


    internal CatchClauseSyntax(SyntaxKind kind, SyntaxToken catchKeyword, CatchDeclarationSyntax declaration, CatchFilterClauseSyntax filter, BlockSyntax block)
        : base(kind)
    {
        this.SlotCount = 4;
        this.AdjustFlagsAndWidth(catchKeyword);
        this.catchKeyword = catchKeyword;
        if (declaration != null)
        {
            this.AdjustFlagsAndWidth(declaration);
            this.declaration = declaration;
        }
        if (filter != null)
        {
            this.AdjustFlagsAndWidth(filter);
            this.filter = filter;
        }
        this.AdjustFlagsAndWidth(block);
        this.block = block;
    }

    public SyntaxToken CatchKeyword { get { return this.catchKeyword; } }
    public CatchDeclarationSyntax Declaration { get { return this.declaration; } }
    public CatchFilterClauseSyntax Filter { get { return this.filter; } }
    public BlockSyntax Block { get { return this.block; } }

    internal override GreenNode GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.catchKeyword;
            case 1: return this.declaration;
            case 2: return this.filter;
            case 3: return this.block;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode parent, int position)
    {
      return new CSharp.Syntax.CatchClauseSyntax(this, parent, position);
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitCatchClause(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitCatchClause(this);
    }

    public CatchClauseSyntax Update(SyntaxToken catchKeyword, CatchDeclarationSyntax declaration, CatchFilterClauseSyntax filter, BlockSyntax block)
    {
        if (catchKeyword != this.CatchKeyword || declaration != this.Declaration || filter != this.Filter || block != this.Block)
        {
            var newNode = SyntaxFactory.CatchClause(catchKeyword, declaration, filter, block);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
    {
         return new CatchClauseSyntax(this.Kind, this.catchKeyword, this.declaration, this.filter, this.block, diagnostics, GetAnnotations());
    }

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
    {
         return new CatchClauseSyntax(this.Kind, this.catchKeyword, this.declaration, this.filter, this.block, GetDiagnostics(), annotations);
    }

    internal CatchClauseSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 4;
      var catchKeyword = (SyntaxToken)reader.ReadValue();
      if (catchKeyword != null)
      {
         AdjustFlagsAndWidth(catchKeyword);
         this.catchKeyword = catchKeyword;
      }
      var declaration = (CatchDeclarationSyntax)reader.ReadValue();
      if (declaration != null)
      {
         AdjustFlagsAndWidth(declaration);
         this.declaration = declaration;
      }
      var filter = (CatchFilterClauseSyntax)reader.ReadValue();
      if (filter != null)
      {
         AdjustFlagsAndWidth(filter);
         this.filter = filter;
      }
      var block = (BlockSyntax)reader.ReadValue();
      if (block != null)
      {
         AdjustFlagsAndWidth(block);
         this.block = block;
      }
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.catchKeyword);
      writer.WriteValue(this.declaration);
      writer.WriteValue(this.filter);
      writer.WriteValue(this.block);
    }

    static CatchClauseSyntax()
    {
       ObjectBinder.RegisterTypeReader(typeof(CatchClauseSyntax), r => new CatchClauseSyntax(r));
    }
  }

  internal sealed partial class CatchDeclarationSyntax : CSharpSyntaxNode
  {
    internal readonly SyntaxToken openParenToken;
    internal readonly TypeSyntax type;
    internal readonly SyntaxToken identifier;
    internal readonly SyntaxToken closeParenToken;

    internal CatchDeclarationSyntax(SyntaxKind kind, SyntaxToken openParenToken, TypeSyntax type, SyntaxToken identifier, SyntaxToken closeParenToken, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 4;
        this.AdjustFlagsAndWidth(openParenToken);
        this.openParenToken = openParenToken;
        this.AdjustFlagsAndWidth(type);
        this.type = type;
        if (identifier != null)
        {
            this.AdjustFlagsAndWidth(identifier);
            this.identifier = identifier;
        }
        this.AdjustFlagsAndWidth(closeParenToken);
        this.closeParenToken = closeParenToken;
    }


    internal CatchDeclarationSyntax(SyntaxKind kind, SyntaxToken openParenToken, TypeSyntax type, SyntaxToken identifier, SyntaxToken closeParenToken, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 4;
        this.AdjustFlagsAndWidth(openParenToken);
        this.openParenToken = openParenToken;
        this.AdjustFlagsAndWidth(type);
        this.type = type;
        if (identifier != null)
        {
            this.AdjustFlagsAndWidth(identifier);
            this.identifier = identifier;
        }
        this.AdjustFlagsAndWidth(closeParenToken);
        this.closeParenToken = closeParenToken;
    }


    internal CatchDeclarationSyntax(SyntaxKind kind, SyntaxToken openParenToken, TypeSyntax type, SyntaxToken identifier, SyntaxToken closeParenToken)
        : base(kind)
    {
        this.SlotCount = 4;
        this.AdjustFlagsAndWidth(openParenToken);
        this.openParenToken = openParenToken;
        this.AdjustFlagsAndWidth(type);
        this.type = type;
        if (identifier != null)
        {
            this.AdjustFlagsAndWidth(identifier);
            this.identifier = identifier;
        }
        this.AdjustFlagsAndWidth(closeParenToken);
        this.closeParenToken = closeParenToken;
    }

    public SyntaxToken OpenParenToken { get { return this.openParenToken; } }
    public TypeSyntax Type { get { return this.type; } }
    public SyntaxToken Identifier { get { return this.identifier; } }
    public SyntaxToken CloseParenToken { get { return this.closeParenToken; } }

    internal override GreenNode GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.openParenToken;
            case 1: return this.type;
            case 2: return this.identifier;
            case 3: return this.closeParenToken;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode parent, int position)
    {
      return new CSharp.Syntax.CatchDeclarationSyntax(this, parent, position);
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitCatchDeclaration(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitCatchDeclaration(this);
    }

    public CatchDeclarationSyntax Update(SyntaxToken openParenToken, TypeSyntax type, SyntaxToken identifier, SyntaxToken closeParenToken)
    {
        if (openParenToken != this.OpenParenToken || type != this.Type || identifier != this.Identifier || closeParenToken != this.CloseParenToken)
        {
            var newNode = SyntaxFactory.CatchDeclaration(openParenToken, type, identifier, closeParenToken);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
    {
         return new CatchDeclarationSyntax(this.Kind, this.openParenToken, this.type, this.identifier, this.closeParenToken, diagnostics, GetAnnotations());
    }

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
    {
         return new CatchDeclarationSyntax(this.Kind, this.openParenToken, this.type, this.identifier, this.closeParenToken, GetDiagnostics(), annotations);
    }

    internal CatchDeclarationSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 4;
      var openParenToken = (SyntaxToken)reader.ReadValue();
      if (openParenToken != null)
      {
         AdjustFlagsAndWidth(openParenToken);
         this.openParenToken = openParenToken;
      }
      var type = (TypeSyntax)reader.ReadValue();
      if (type != null)
      {
         AdjustFlagsAndWidth(type);
         this.type = type;
      }
      var identifier = (SyntaxToken)reader.ReadValue();
      if (identifier != null)
      {
         AdjustFlagsAndWidth(identifier);
         this.identifier = identifier;
      }
      var closeParenToken = (SyntaxToken)reader.ReadValue();
      if (closeParenToken != null)
      {
         AdjustFlagsAndWidth(closeParenToken);
         this.closeParenToken = closeParenToken;
      }
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.openParenToken);
      writer.WriteValue(this.type);
      writer.WriteValue(this.identifier);
      writer.WriteValue(this.closeParenToken);
    }

    static CatchDeclarationSyntax()
    {
       ObjectBinder.RegisterTypeReader(typeof(CatchDeclarationSyntax), r => new CatchDeclarationSyntax(r));
    }
  }

  internal sealed partial class CatchFilterClauseSyntax : CSharpSyntaxNode
  {
    internal readonly SyntaxToken whenKeyword;
    internal readonly SyntaxToken openParenToken;
    internal readonly ExpressionSyntax filterExpression;
    internal readonly SyntaxToken closeParenToken;

    internal CatchFilterClauseSyntax(SyntaxKind kind, SyntaxToken whenKeyword, SyntaxToken openParenToken, ExpressionSyntax filterExpression, SyntaxToken closeParenToken, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 4;
        this.AdjustFlagsAndWidth(whenKeyword);
        this.whenKeyword = whenKeyword;
        this.AdjustFlagsAndWidth(openParenToken);
        this.openParenToken = openParenToken;
        this.AdjustFlagsAndWidth(filterExpression);
        this.filterExpression = filterExpression;
        this.AdjustFlagsAndWidth(closeParenToken);
        this.closeParenToken = closeParenToken;
    }


    internal CatchFilterClauseSyntax(SyntaxKind kind, SyntaxToken whenKeyword, SyntaxToken openParenToken, ExpressionSyntax filterExpression, SyntaxToken closeParenToken, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 4;
        this.AdjustFlagsAndWidth(whenKeyword);
        this.whenKeyword = whenKeyword;
        this.AdjustFlagsAndWidth(openParenToken);
        this.openParenToken = openParenToken;
        this.AdjustFlagsAndWidth(filterExpression);
        this.filterExpression = filterExpression;
        this.AdjustFlagsAndWidth(closeParenToken);
        this.closeParenToken = closeParenToken;
    }


    internal CatchFilterClauseSyntax(SyntaxKind kind, SyntaxToken whenKeyword, SyntaxToken openParenToken, ExpressionSyntax filterExpression, SyntaxToken closeParenToken)
        : base(kind)
    {
        this.SlotCount = 4;
        this.AdjustFlagsAndWidth(whenKeyword);
        this.whenKeyword = whenKeyword;
        this.AdjustFlagsAndWidth(openParenToken);
        this.openParenToken = openParenToken;
        this.AdjustFlagsAndWidth(filterExpression);
        this.filterExpression = filterExpression;
        this.AdjustFlagsAndWidth(closeParenToken);
        this.closeParenToken = closeParenToken;
    }

    public SyntaxToken WhenKeyword { get { return this.whenKeyword; } }
    public SyntaxToken OpenParenToken { get { return this.openParenToken; } }
    public ExpressionSyntax FilterExpression { get { return this.filterExpression; } }
    public SyntaxToken CloseParenToken { get { return this.closeParenToken; } }

    internal override GreenNode GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.whenKeyword;
            case 1: return this.openParenToken;
            case 2: return this.filterExpression;
            case 3: return this.closeParenToken;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode parent, int position)
    {
      return new CSharp.Syntax.CatchFilterClauseSyntax(this, parent, position);
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitCatchFilterClause(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitCatchFilterClause(this);
    }

    public CatchFilterClauseSyntax Update(SyntaxToken whenKeyword, SyntaxToken openParenToken, ExpressionSyntax filterExpression, SyntaxToken closeParenToken)
    {
        if (whenKeyword != this.WhenKeyword || openParenToken != this.OpenParenToken || filterExpression != this.FilterExpression || closeParenToken != this.CloseParenToken)
        {
            var newNode = SyntaxFactory.CatchFilterClause(whenKeyword, openParenToken, filterExpression, closeParenToken);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
    {
         return new CatchFilterClauseSyntax(this.Kind, this.whenKeyword, this.openParenToken, this.filterExpression, this.closeParenToken, diagnostics, GetAnnotations());
    }

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
    {
         return new CatchFilterClauseSyntax(this.Kind, this.whenKeyword, this.openParenToken, this.filterExpression, this.closeParenToken, GetDiagnostics(), annotations);
    }

    internal CatchFilterClauseSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 4;
      var whenKeyword = (SyntaxToken)reader.ReadValue();
      if (whenKeyword != null)
      {
         AdjustFlagsAndWidth(whenKeyword);
         this.whenKeyword = whenKeyword;
      }
      var openParenToken = (SyntaxToken)reader.ReadValue();
      if (openParenToken != null)
      {
         AdjustFlagsAndWidth(openParenToken);
         this.openParenToken = openParenToken;
      }
      var filterExpression = (ExpressionSyntax)reader.ReadValue();
      if (filterExpression != null)
      {
         AdjustFlagsAndWidth(filterExpression);
         this.filterExpression = filterExpression;
      }
      var closeParenToken = (SyntaxToken)reader.ReadValue();
      if (closeParenToken != null)
      {
         AdjustFlagsAndWidth(closeParenToken);
         this.closeParenToken = closeParenToken;
      }
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.whenKeyword);
      writer.WriteValue(this.openParenToken);
      writer.WriteValue(this.filterExpression);
      writer.WriteValue(this.closeParenToken);
    }

    static CatchFilterClauseSyntax()
    {
       ObjectBinder.RegisterTypeReader(typeof(CatchFilterClauseSyntax), r => new CatchFilterClauseSyntax(r));
    }
  }

  internal sealed partial class FinallyClauseSyntax : CSharpSyntaxNode
  {
    internal readonly SyntaxToken finallyKeyword;
    internal readonly BlockSyntax block;

    internal FinallyClauseSyntax(SyntaxKind kind, SyntaxToken finallyKeyword, BlockSyntax block, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 2;
        this.AdjustFlagsAndWidth(finallyKeyword);
        this.finallyKeyword = finallyKeyword;
        this.AdjustFlagsAndWidth(block);
        this.block = block;
    }


    internal FinallyClauseSyntax(SyntaxKind kind, SyntaxToken finallyKeyword, BlockSyntax block, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 2;
        this.AdjustFlagsAndWidth(finallyKeyword);
        this.finallyKeyword = finallyKeyword;
        this.AdjustFlagsAndWidth(block);
        this.block = block;
    }


    internal FinallyClauseSyntax(SyntaxKind kind, SyntaxToken finallyKeyword, BlockSyntax block)
        : base(kind)
    {
        this.SlotCount = 2;
        this.AdjustFlagsAndWidth(finallyKeyword);
        this.finallyKeyword = finallyKeyword;
        this.AdjustFlagsAndWidth(block);
        this.block = block;
    }

    public SyntaxToken FinallyKeyword { get { return this.finallyKeyword; } }
    public BlockSyntax Block { get { return this.block; } }

    internal override GreenNode GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.finallyKeyword;
            case 1: return this.block;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode parent, int position)
    {
      return new CSharp.Syntax.FinallyClauseSyntax(this, parent, position);
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitFinallyClause(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitFinallyClause(this);
    }

    public FinallyClauseSyntax Update(SyntaxToken finallyKeyword, BlockSyntax block)
    {
        if (finallyKeyword != this.FinallyKeyword || block != this.Block)
        {
            var newNode = SyntaxFactory.FinallyClause(finallyKeyword, block);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
    {
         return new FinallyClauseSyntax(this.Kind, this.finallyKeyword, this.block, diagnostics, GetAnnotations());
    }

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
    {
         return new FinallyClauseSyntax(this.Kind, this.finallyKeyword, this.block, GetDiagnostics(), annotations);
    }

    internal FinallyClauseSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 2;
      var finallyKeyword = (SyntaxToken)reader.ReadValue();
      if (finallyKeyword != null)
      {
         AdjustFlagsAndWidth(finallyKeyword);
         this.finallyKeyword = finallyKeyword;
      }
      var block = (BlockSyntax)reader.ReadValue();
      if (block != null)
      {
         AdjustFlagsAndWidth(block);
         this.block = block;
      }
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.finallyKeyword);
      writer.WriteValue(this.block);
    }

    static FinallyClauseSyntax()
    {
       ObjectBinder.RegisterTypeReader(typeof(FinallyClauseSyntax), r => new FinallyClauseSyntax(r));
    }
  }

  internal sealed partial class CompilationUnitSyntax : CSharpSyntaxNode
  {
    internal readonly GreenNode externs;
    internal readonly GreenNode usings;
    internal readonly GreenNode attributeLists;
    internal readonly GreenNode members;
    internal readonly SyntaxToken endOfFileToken;

    internal CompilationUnitSyntax(SyntaxKind kind, GreenNode externs, GreenNode usings, GreenNode attributeLists, GreenNode members, SyntaxToken endOfFileToken, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 5;
        if (externs != null)
        {
            this.AdjustFlagsAndWidth(externs);
            this.externs = externs;
        }
        if (usings != null)
        {
            this.AdjustFlagsAndWidth(usings);
            this.usings = usings;
        }
        if (attributeLists != null)
        {
            this.AdjustFlagsAndWidth(attributeLists);
            this.attributeLists = attributeLists;
        }
        if (members != null)
        {
            this.AdjustFlagsAndWidth(members);
            this.members = members;
        }
        this.AdjustFlagsAndWidth(endOfFileToken);
        this.endOfFileToken = endOfFileToken;
    }


    internal CompilationUnitSyntax(SyntaxKind kind, GreenNode externs, GreenNode usings, GreenNode attributeLists, GreenNode members, SyntaxToken endOfFileToken, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 5;
        if (externs != null)
        {
            this.AdjustFlagsAndWidth(externs);
            this.externs = externs;
        }
        if (usings != null)
        {
            this.AdjustFlagsAndWidth(usings);
            this.usings = usings;
        }
        if (attributeLists != null)
        {
            this.AdjustFlagsAndWidth(attributeLists);
            this.attributeLists = attributeLists;
        }
        if (members != null)
        {
            this.AdjustFlagsAndWidth(members);
            this.members = members;
        }
        this.AdjustFlagsAndWidth(endOfFileToken);
        this.endOfFileToken = endOfFileToken;
    }


    internal CompilationUnitSyntax(SyntaxKind kind, GreenNode externs, GreenNode usings, GreenNode attributeLists, GreenNode members, SyntaxToken endOfFileToken)
        : base(kind)
    {
        this.SlotCount = 5;
        if (externs != null)
        {
            this.AdjustFlagsAndWidth(externs);
            this.externs = externs;
        }
        if (usings != null)
        {
            this.AdjustFlagsAndWidth(usings);
            this.usings = usings;
        }
        if (attributeLists != null)
        {
            this.AdjustFlagsAndWidth(attributeLists);
            this.attributeLists = attributeLists;
        }
        if (members != null)
        {
            this.AdjustFlagsAndWidth(members);
            this.members = members;
        }
        this.AdjustFlagsAndWidth(endOfFileToken);
        this.endOfFileToken = endOfFileToken;
    }

    public Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<ExternAliasDirectiveSyntax> Externs { get { return new Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<ExternAliasDirectiveSyntax>(this.externs); } }
    public Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<UsingDirectiveSyntax> Usings { get { return new Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<UsingDirectiveSyntax>(this.usings); } }
    /// <summary>Gets the attribute declaration list.</summary>
    public Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<AttributeListSyntax> AttributeLists { get { return new Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<AttributeListSyntax>(this.attributeLists); } }
    public Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<MemberDeclarationSyntax> Members { get { return new Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<MemberDeclarationSyntax>(this.members); } }
    public SyntaxToken EndOfFileToken { get { return this.endOfFileToken; } }

    internal override GreenNode GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.externs;
            case 1: return this.usings;
            case 2: return this.attributeLists;
            case 3: return this.members;
            case 4: return this.endOfFileToken;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode parent, int position)
    {
      return new CSharp.Syntax.CompilationUnitSyntax(this, parent, position);
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitCompilationUnit(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitCompilationUnit(this);
    }

    public CompilationUnitSyntax Update(Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<ExternAliasDirectiveSyntax> externs, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<UsingDirectiveSyntax> usings, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<AttributeListSyntax> attributeLists, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<MemberDeclarationSyntax> members, SyntaxToken endOfFileToken)
    {
        if (externs != this.Externs || usings != this.Usings || attributeLists != this.AttributeLists || members != this.Members || endOfFileToken != this.EndOfFileToken)
        {
            var newNode = SyntaxFactory.CompilationUnit(externs, usings, attributeLists, members, endOfFileToken);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
    {
         return new CompilationUnitSyntax(this.Kind, this.externs, this.usings, this.attributeLists, this.members, this.endOfFileToken, diagnostics, GetAnnotations());
    }

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
    {
         return new CompilationUnitSyntax(this.Kind, this.externs, this.usings, this.attributeLists, this.members, this.endOfFileToken, GetDiagnostics(), annotations);
    }

    internal CompilationUnitSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 5;
      var externs = (GreenNode)reader.ReadValue();
      if (externs != null)
      {
         AdjustFlagsAndWidth(externs);
         this.externs = externs;
      }
      var usings = (GreenNode)reader.ReadValue();
      if (usings != null)
      {
         AdjustFlagsAndWidth(usings);
         this.usings = usings;
      }
      var attributeLists = (GreenNode)reader.ReadValue();
      if (attributeLists != null)
      {
         AdjustFlagsAndWidth(attributeLists);
         this.attributeLists = attributeLists;
      }
      var members = (GreenNode)reader.ReadValue();
      if (members != null)
      {
         AdjustFlagsAndWidth(members);
         this.members = members;
      }
      var endOfFileToken = (SyntaxToken)reader.ReadValue();
      if (endOfFileToken != null)
      {
         AdjustFlagsAndWidth(endOfFileToken);
         this.endOfFileToken = endOfFileToken;
      }
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.externs);
      writer.WriteValue(this.usings);
      writer.WriteValue(this.attributeLists);
      writer.WriteValue(this.members);
      writer.WriteValue(this.endOfFileToken);
    }

    static CompilationUnitSyntax()
    {
       ObjectBinder.RegisterTypeReader(typeof(CompilationUnitSyntax), r => new CompilationUnitSyntax(r));
    }
  }

  /// <summary>
  /// Represents an ExternAlias directive syntax, e.g. "extern alias MyAlias;" with specifying "/r:MyAlias=SomeAssembly.dll " on the compiler command line.
  /// </summary>
  internal sealed partial class ExternAliasDirectiveSyntax : CSharpSyntaxNode
  {
    internal readonly SyntaxToken externKeyword;
    internal readonly SyntaxToken aliasKeyword;
    internal readonly SyntaxToken identifier;
    internal readonly SyntaxToken semicolonToken;

    internal ExternAliasDirectiveSyntax(SyntaxKind kind, SyntaxToken externKeyword, SyntaxToken aliasKeyword, SyntaxToken identifier, SyntaxToken semicolonToken, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 4;
        this.AdjustFlagsAndWidth(externKeyword);
        this.externKeyword = externKeyword;
        this.AdjustFlagsAndWidth(aliasKeyword);
        this.aliasKeyword = aliasKeyword;
        this.AdjustFlagsAndWidth(identifier);
        this.identifier = identifier;
        this.AdjustFlagsAndWidth(semicolonToken);
        this.semicolonToken = semicolonToken;
    }


    internal ExternAliasDirectiveSyntax(SyntaxKind kind, SyntaxToken externKeyword, SyntaxToken aliasKeyword, SyntaxToken identifier, SyntaxToken semicolonToken, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 4;
        this.AdjustFlagsAndWidth(externKeyword);
        this.externKeyword = externKeyword;
        this.AdjustFlagsAndWidth(aliasKeyword);
        this.aliasKeyword = aliasKeyword;
        this.AdjustFlagsAndWidth(identifier);
        this.identifier = identifier;
        this.AdjustFlagsAndWidth(semicolonToken);
        this.semicolonToken = semicolonToken;
    }


    internal ExternAliasDirectiveSyntax(SyntaxKind kind, SyntaxToken externKeyword, SyntaxToken aliasKeyword, SyntaxToken identifier, SyntaxToken semicolonToken)
        : base(kind)
    {
        this.SlotCount = 4;
        this.AdjustFlagsAndWidth(externKeyword);
        this.externKeyword = externKeyword;
        this.AdjustFlagsAndWidth(aliasKeyword);
        this.aliasKeyword = aliasKeyword;
        this.AdjustFlagsAndWidth(identifier);
        this.identifier = identifier;
        this.AdjustFlagsAndWidth(semicolonToken);
        this.semicolonToken = semicolonToken;
    }

    /// <summary>SyntaxToken representing the extern keyword.</summary>
    public SyntaxToken ExternKeyword { get { return this.externKeyword; } }
    /// <summary>SyntaxToken representing the alias keyword.</summary>
    public SyntaxToken AliasKeyword { get { return this.aliasKeyword; } }
    /// <summary>Gets the identifier.</summary>
    public SyntaxToken Identifier { get { return this.identifier; } }
    /// <summary>SyntaxToken representing the semicolon token.</summary>
    public SyntaxToken SemicolonToken { get { return this.semicolonToken; } }

    internal override GreenNode GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.externKeyword;
            case 1: return this.aliasKeyword;
            case 2: return this.identifier;
            case 3: return this.semicolonToken;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode parent, int position)
    {
      return new CSharp.Syntax.ExternAliasDirectiveSyntax(this, parent, position);
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitExternAliasDirective(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitExternAliasDirective(this);
    }

    public ExternAliasDirectiveSyntax Update(SyntaxToken externKeyword, SyntaxToken aliasKeyword, SyntaxToken identifier, SyntaxToken semicolonToken)
    {
        if (externKeyword != this.ExternKeyword || aliasKeyword != this.AliasKeyword || identifier != this.Identifier || semicolonToken != this.SemicolonToken)
        {
            var newNode = SyntaxFactory.ExternAliasDirective(externKeyword, aliasKeyword, identifier, semicolonToken);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
    {
         return new ExternAliasDirectiveSyntax(this.Kind, this.externKeyword, this.aliasKeyword, this.identifier, this.semicolonToken, diagnostics, GetAnnotations());
    }

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
    {
         return new ExternAliasDirectiveSyntax(this.Kind, this.externKeyword, this.aliasKeyword, this.identifier, this.semicolonToken, GetDiagnostics(), annotations);
    }

    internal ExternAliasDirectiveSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 4;
      var externKeyword = (SyntaxToken)reader.ReadValue();
      if (externKeyword != null)
      {
         AdjustFlagsAndWidth(externKeyword);
         this.externKeyword = externKeyword;
      }
      var aliasKeyword = (SyntaxToken)reader.ReadValue();
      if (aliasKeyword != null)
      {
         AdjustFlagsAndWidth(aliasKeyword);
         this.aliasKeyword = aliasKeyword;
      }
      var identifier = (SyntaxToken)reader.ReadValue();
      if (identifier != null)
      {
         AdjustFlagsAndWidth(identifier);
         this.identifier = identifier;
      }
      var semicolonToken = (SyntaxToken)reader.ReadValue();
      if (semicolonToken != null)
      {
         AdjustFlagsAndWidth(semicolonToken);
         this.semicolonToken = semicolonToken;
      }
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.externKeyword);
      writer.WriteValue(this.aliasKeyword);
      writer.WriteValue(this.identifier);
      writer.WriteValue(this.semicolonToken);
    }

    static ExternAliasDirectiveSyntax()
    {
       ObjectBinder.RegisterTypeReader(typeof(ExternAliasDirectiveSyntax), r => new ExternAliasDirectiveSyntax(r));
    }
  }

  internal sealed partial class UsingDirectiveSyntax : CSharpSyntaxNode
  {
    internal readonly SyntaxToken usingKeyword;
    internal readonly SyntaxToken staticKeyword;
    internal readonly NameEqualsSyntax alias;
    internal readonly NameSyntax name;
    internal readonly SyntaxToken semicolonToken;

    internal UsingDirectiveSyntax(SyntaxKind kind, SyntaxToken usingKeyword, SyntaxToken staticKeyword, NameEqualsSyntax alias, NameSyntax name, SyntaxToken semicolonToken, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 5;
        this.AdjustFlagsAndWidth(usingKeyword);
        this.usingKeyword = usingKeyword;
        if (staticKeyword != null)
        {
            this.AdjustFlagsAndWidth(staticKeyword);
            this.staticKeyword = staticKeyword;
        }
        if (alias != null)
        {
            this.AdjustFlagsAndWidth(alias);
            this.alias = alias;
        }
        this.AdjustFlagsAndWidth(name);
        this.name = name;
        this.AdjustFlagsAndWidth(semicolonToken);
        this.semicolonToken = semicolonToken;
    }


    internal UsingDirectiveSyntax(SyntaxKind kind, SyntaxToken usingKeyword, SyntaxToken staticKeyword, NameEqualsSyntax alias, NameSyntax name, SyntaxToken semicolonToken, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 5;
        this.AdjustFlagsAndWidth(usingKeyword);
        this.usingKeyword = usingKeyword;
        if (staticKeyword != null)
        {
            this.AdjustFlagsAndWidth(staticKeyword);
            this.staticKeyword = staticKeyword;
        }
        if (alias != null)
        {
            this.AdjustFlagsAndWidth(alias);
            this.alias = alias;
        }
        this.AdjustFlagsAndWidth(name);
        this.name = name;
        this.AdjustFlagsAndWidth(semicolonToken);
        this.semicolonToken = semicolonToken;
    }


    internal UsingDirectiveSyntax(SyntaxKind kind, SyntaxToken usingKeyword, SyntaxToken staticKeyword, NameEqualsSyntax alias, NameSyntax name, SyntaxToken semicolonToken)
        : base(kind)
    {
        this.SlotCount = 5;
        this.AdjustFlagsAndWidth(usingKeyword);
        this.usingKeyword = usingKeyword;
        if (staticKeyword != null)
        {
            this.AdjustFlagsAndWidth(staticKeyword);
            this.staticKeyword = staticKeyword;
        }
        if (alias != null)
        {
            this.AdjustFlagsAndWidth(alias);
            this.alias = alias;
        }
        this.AdjustFlagsAndWidth(name);
        this.name = name;
        this.AdjustFlagsAndWidth(semicolonToken);
        this.semicolonToken = semicolonToken;
    }

    public SyntaxToken UsingKeyword { get { return this.usingKeyword; } }
    public SyntaxToken StaticKeyword { get { return this.staticKeyword; } }
    public NameEqualsSyntax Alias { get { return this.alias; } }
    public NameSyntax Name { get { return this.name; } }
    public SyntaxToken SemicolonToken { get { return this.semicolonToken; } }

    internal override GreenNode GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.usingKeyword;
            case 1: return this.staticKeyword;
            case 2: return this.alias;
            case 3: return this.name;
            case 4: return this.semicolonToken;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode parent, int position)
    {
      return new CSharp.Syntax.UsingDirectiveSyntax(this, parent, position);
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitUsingDirective(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitUsingDirective(this);
    }

    public UsingDirectiveSyntax Update(SyntaxToken usingKeyword, SyntaxToken staticKeyword, NameEqualsSyntax alias, NameSyntax name, SyntaxToken semicolonToken)
    {
        if (usingKeyword != this.UsingKeyword || staticKeyword != this.StaticKeyword || alias != this.Alias || name != this.Name || semicolonToken != this.SemicolonToken)
        {
            var newNode = SyntaxFactory.UsingDirective(usingKeyword, staticKeyword, alias, name, semicolonToken);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
    {
         return new UsingDirectiveSyntax(this.Kind, this.usingKeyword, this.staticKeyword, this.alias, this.name, this.semicolonToken, diagnostics, GetAnnotations());
    }

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
    {
         return new UsingDirectiveSyntax(this.Kind, this.usingKeyword, this.staticKeyword, this.alias, this.name, this.semicolonToken, GetDiagnostics(), annotations);
    }

    internal UsingDirectiveSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 5;
      var usingKeyword = (SyntaxToken)reader.ReadValue();
      if (usingKeyword != null)
      {
         AdjustFlagsAndWidth(usingKeyword);
         this.usingKeyword = usingKeyword;
      }
      var staticKeyword = (SyntaxToken)reader.ReadValue();
      if (staticKeyword != null)
      {
         AdjustFlagsAndWidth(staticKeyword);
         this.staticKeyword = staticKeyword;
      }
      var alias = (NameEqualsSyntax)reader.ReadValue();
      if (alias != null)
      {
         AdjustFlagsAndWidth(alias);
         this.alias = alias;
      }
      var name = (NameSyntax)reader.ReadValue();
      if (name != null)
      {
         AdjustFlagsAndWidth(name);
         this.name = name;
      }
      var semicolonToken = (SyntaxToken)reader.ReadValue();
      if (semicolonToken != null)
      {
         AdjustFlagsAndWidth(semicolonToken);
         this.semicolonToken = semicolonToken;
      }
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.usingKeyword);
      writer.WriteValue(this.staticKeyword);
      writer.WriteValue(this.alias);
      writer.WriteValue(this.name);
      writer.WriteValue(this.semicolonToken);
    }

    static UsingDirectiveSyntax()
    {
       ObjectBinder.RegisterTypeReader(typeof(UsingDirectiveSyntax), r => new UsingDirectiveSyntax(r));
    }
  }

  /// <summary>Member declaration syntax.</summary>
  internal abstract partial class MemberDeclarationSyntax : CSharpSyntaxNode
  {
    internal MemberDeclarationSyntax(SyntaxKind kind, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
      : base(kind, diagnostics, annotations)
    {
    }
    internal MemberDeclarationSyntax(SyntaxKind kind)
      : base(kind)
    {
    }

    protected MemberDeclarationSyntax(ObjectReader reader)
       : base(reader)
    {
    }
  }

  internal sealed partial class NamespaceDeclarationSyntax : MemberDeclarationSyntax
  {
    internal readonly SyntaxToken namespaceKeyword;
    internal readonly NameSyntax name;
    internal readonly SyntaxToken openBraceToken;
    internal readonly GreenNode externs;
    internal readonly GreenNode usings;
    internal readonly GreenNode members;
    internal readonly SyntaxToken closeBraceToken;
    internal readonly SyntaxToken semicolonToken;

    internal NamespaceDeclarationSyntax(SyntaxKind kind, SyntaxToken namespaceKeyword, NameSyntax name, SyntaxToken openBraceToken, GreenNode externs, GreenNode usings, GreenNode members, SyntaxToken closeBraceToken, SyntaxToken semicolonToken, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 8;
        this.AdjustFlagsAndWidth(namespaceKeyword);
        this.namespaceKeyword = namespaceKeyword;
        this.AdjustFlagsAndWidth(name);
        this.name = name;
        this.AdjustFlagsAndWidth(openBraceToken);
        this.openBraceToken = openBraceToken;
        if (externs != null)
        {
            this.AdjustFlagsAndWidth(externs);
            this.externs = externs;
        }
        if (usings != null)
        {
            this.AdjustFlagsAndWidth(usings);
            this.usings = usings;
        }
        if (members != null)
        {
            this.AdjustFlagsAndWidth(members);
            this.members = members;
        }
        this.AdjustFlagsAndWidth(closeBraceToken);
        this.closeBraceToken = closeBraceToken;
        if (semicolonToken != null)
        {
            this.AdjustFlagsAndWidth(semicolonToken);
            this.semicolonToken = semicolonToken;
        }
    }


    internal NamespaceDeclarationSyntax(SyntaxKind kind, SyntaxToken namespaceKeyword, NameSyntax name, SyntaxToken openBraceToken, GreenNode externs, GreenNode usings, GreenNode members, SyntaxToken closeBraceToken, SyntaxToken semicolonToken, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 8;
        this.AdjustFlagsAndWidth(namespaceKeyword);
        this.namespaceKeyword = namespaceKeyword;
        this.AdjustFlagsAndWidth(name);
        this.name = name;
        this.AdjustFlagsAndWidth(openBraceToken);
        this.openBraceToken = openBraceToken;
        if (externs != null)
        {
            this.AdjustFlagsAndWidth(externs);
            this.externs = externs;
        }
        if (usings != null)
        {
            this.AdjustFlagsAndWidth(usings);
            this.usings = usings;
        }
        if (members != null)
        {
            this.AdjustFlagsAndWidth(members);
            this.members = members;
        }
        this.AdjustFlagsAndWidth(closeBraceToken);
        this.closeBraceToken = closeBraceToken;
        if (semicolonToken != null)
        {
            this.AdjustFlagsAndWidth(semicolonToken);
            this.semicolonToken = semicolonToken;
        }
    }


    internal NamespaceDeclarationSyntax(SyntaxKind kind, SyntaxToken namespaceKeyword, NameSyntax name, SyntaxToken openBraceToken, GreenNode externs, GreenNode usings, GreenNode members, SyntaxToken closeBraceToken, SyntaxToken semicolonToken)
        : base(kind)
    {
        this.SlotCount = 8;
        this.AdjustFlagsAndWidth(namespaceKeyword);
        this.namespaceKeyword = namespaceKeyword;
        this.AdjustFlagsAndWidth(name);
        this.name = name;
        this.AdjustFlagsAndWidth(openBraceToken);
        this.openBraceToken = openBraceToken;
        if (externs != null)
        {
            this.AdjustFlagsAndWidth(externs);
            this.externs = externs;
        }
        if (usings != null)
        {
            this.AdjustFlagsAndWidth(usings);
            this.usings = usings;
        }
        if (members != null)
        {
            this.AdjustFlagsAndWidth(members);
            this.members = members;
        }
        this.AdjustFlagsAndWidth(closeBraceToken);
        this.closeBraceToken = closeBraceToken;
        if (semicolonToken != null)
        {
            this.AdjustFlagsAndWidth(semicolonToken);
            this.semicolonToken = semicolonToken;
        }
    }

    public SyntaxToken NamespaceKeyword { get { return this.namespaceKeyword; } }
    public NameSyntax Name { get { return this.name; } }
    public SyntaxToken OpenBraceToken { get { return this.openBraceToken; } }
    public Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<ExternAliasDirectiveSyntax> Externs { get { return new Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<ExternAliasDirectiveSyntax>(this.externs); } }
    public Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<UsingDirectiveSyntax> Usings { get { return new Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<UsingDirectiveSyntax>(this.usings); } }
    public Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<MemberDeclarationSyntax> Members { get { return new Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<MemberDeclarationSyntax>(this.members); } }
    public SyntaxToken CloseBraceToken { get { return this.closeBraceToken; } }
    /// <summary>Gets the optional semicolon token.</summary>
    public SyntaxToken SemicolonToken { get { return this.semicolonToken; } }

    internal override GreenNode GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.namespaceKeyword;
            case 1: return this.name;
            case 2: return this.openBraceToken;
            case 3: return this.externs;
            case 4: return this.usings;
            case 5: return this.members;
            case 6: return this.closeBraceToken;
            case 7: return this.semicolonToken;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode parent, int position)
    {
      return new CSharp.Syntax.NamespaceDeclarationSyntax(this, parent, position);
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitNamespaceDeclaration(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitNamespaceDeclaration(this);
    }

    public NamespaceDeclarationSyntax Update(SyntaxToken namespaceKeyword, NameSyntax name, SyntaxToken openBraceToken, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<ExternAliasDirectiveSyntax> externs, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<UsingDirectiveSyntax> usings, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<MemberDeclarationSyntax> members, SyntaxToken closeBraceToken, SyntaxToken semicolonToken)
    {
        if (namespaceKeyword != this.NamespaceKeyword || name != this.Name || openBraceToken != this.OpenBraceToken || externs != this.Externs || usings != this.Usings || members != this.Members || closeBraceToken != this.CloseBraceToken || semicolonToken != this.SemicolonToken)
        {
            var newNode = SyntaxFactory.NamespaceDeclaration(namespaceKeyword, name, openBraceToken, externs, usings, members, closeBraceToken, semicolonToken);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
    {
         return new NamespaceDeclarationSyntax(this.Kind, this.namespaceKeyword, this.name, this.openBraceToken, this.externs, this.usings, this.members, this.closeBraceToken, this.semicolonToken, diagnostics, GetAnnotations());
    }

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
    {
         return new NamespaceDeclarationSyntax(this.Kind, this.namespaceKeyword, this.name, this.openBraceToken, this.externs, this.usings, this.members, this.closeBraceToken, this.semicolonToken, GetDiagnostics(), annotations);
    }

    internal NamespaceDeclarationSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 8;
      var namespaceKeyword = (SyntaxToken)reader.ReadValue();
      if (namespaceKeyword != null)
      {
         AdjustFlagsAndWidth(namespaceKeyword);
         this.namespaceKeyword = namespaceKeyword;
      }
      var name = (NameSyntax)reader.ReadValue();
      if (name != null)
      {
         AdjustFlagsAndWidth(name);
         this.name = name;
      }
      var openBraceToken = (SyntaxToken)reader.ReadValue();
      if (openBraceToken != null)
      {
         AdjustFlagsAndWidth(openBraceToken);
         this.openBraceToken = openBraceToken;
      }
      var externs = (GreenNode)reader.ReadValue();
      if (externs != null)
      {
         AdjustFlagsAndWidth(externs);
         this.externs = externs;
      }
      var usings = (GreenNode)reader.ReadValue();
      if (usings != null)
      {
         AdjustFlagsAndWidth(usings);
         this.usings = usings;
      }
      var members = (GreenNode)reader.ReadValue();
      if (members != null)
      {
         AdjustFlagsAndWidth(members);
         this.members = members;
      }
      var closeBraceToken = (SyntaxToken)reader.ReadValue();
      if (closeBraceToken != null)
      {
         AdjustFlagsAndWidth(closeBraceToken);
         this.closeBraceToken = closeBraceToken;
      }
      var semicolonToken = (SyntaxToken)reader.ReadValue();
      if (semicolonToken != null)
      {
         AdjustFlagsAndWidth(semicolonToken);
         this.semicolonToken = semicolonToken;
      }
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.namespaceKeyword);
      writer.WriteValue(this.name);
      writer.WriteValue(this.openBraceToken);
      writer.WriteValue(this.externs);
      writer.WriteValue(this.usings);
      writer.WriteValue(this.members);
      writer.WriteValue(this.closeBraceToken);
      writer.WriteValue(this.semicolonToken);
    }

    static NamespaceDeclarationSyntax()
    {
       ObjectBinder.RegisterTypeReader(typeof(NamespaceDeclarationSyntax), r => new NamespaceDeclarationSyntax(r));
    }
  }

  /// <summary>Class representing one or more attributes applied to a language construct.</summary>
  internal sealed partial class AttributeListSyntax : CSharpSyntaxNode
  {
    internal readonly SyntaxToken openBracketToken;
    internal readonly AttributeTargetSpecifierSyntax target;
    internal readonly GreenNode attributes;
    internal readonly SyntaxToken closeBracketToken;

    internal AttributeListSyntax(SyntaxKind kind, SyntaxToken openBracketToken, AttributeTargetSpecifierSyntax target, GreenNode attributes, SyntaxToken closeBracketToken, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 4;
        this.AdjustFlagsAndWidth(openBracketToken);
        this.openBracketToken = openBracketToken;
        if (target != null)
        {
            this.AdjustFlagsAndWidth(target);
            this.target = target;
        }
        if (attributes != null)
        {
            this.AdjustFlagsAndWidth(attributes);
            this.attributes = attributes;
        }
        this.AdjustFlagsAndWidth(closeBracketToken);
        this.closeBracketToken = closeBracketToken;
    }


    internal AttributeListSyntax(SyntaxKind kind, SyntaxToken openBracketToken, AttributeTargetSpecifierSyntax target, GreenNode attributes, SyntaxToken closeBracketToken, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 4;
        this.AdjustFlagsAndWidth(openBracketToken);
        this.openBracketToken = openBracketToken;
        if (target != null)
        {
            this.AdjustFlagsAndWidth(target);
            this.target = target;
        }
        if (attributes != null)
        {
            this.AdjustFlagsAndWidth(attributes);
            this.attributes = attributes;
        }
        this.AdjustFlagsAndWidth(closeBracketToken);
        this.closeBracketToken = closeBracketToken;
    }


    internal AttributeListSyntax(SyntaxKind kind, SyntaxToken openBracketToken, AttributeTargetSpecifierSyntax target, GreenNode attributes, SyntaxToken closeBracketToken)
        : base(kind)
    {
        this.SlotCount = 4;
        this.AdjustFlagsAndWidth(openBracketToken);
        this.openBracketToken = openBracketToken;
        if (target != null)
        {
            this.AdjustFlagsAndWidth(target);
            this.target = target;
        }
        if (attributes != null)
        {
            this.AdjustFlagsAndWidth(attributes);
            this.attributes = attributes;
        }
        this.AdjustFlagsAndWidth(closeBracketToken);
        this.closeBracketToken = closeBracketToken;
    }

    /// <summary>Gets the open bracket token.</summary>
    public SyntaxToken OpenBracketToken { get { return this.openBracketToken; } }
    /// <summary>Gets the optional construct targeted by the attribute.</summary>
    public AttributeTargetSpecifierSyntax Target { get { return this.target; } }
    /// <summary>Gets the attribute declaration list.</summary>
    public Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<AttributeSyntax> Attributes { get { return new Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<AttributeSyntax>(new Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<CSharpSyntaxNode>(this.attributes)); } }
    /// <summary>Gets the close bracket token.</summary>
    public SyntaxToken CloseBracketToken { get { return this.closeBracketToken; } }

    internal override GreenNode GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.openBracketToken;
            case 1: return this.target;
            case 2: return this.attributes;
            case 3: return this.closeBracketToken;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode parent, int position)
    {
      return new CSharp.Syntax.AttributeListSyntax(this, parent, position);
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitAttributeList(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitAttributeList(this);
    }

    public AttributeListSyntax Update(SyntaxToken openBracketToken, AttributeTargetSpecifierSyntax target, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<AttributeSyntax> attributes, SyntaxToken closeBracketToken)
    {
        if (openBracketToken != this.OpenBracketToken || target != this.Target || attributes != this.Attributes || closeBracketToken != this.CloseBracketToken)
        {
            var newNode = SyntaxFactory.AttributeList(openBracketToken, target, attributes, closeBracketToken);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
    {
         return new AttributeListSyntax(this.Kind, this.openBracketToken, this.target, this.attributes, this.closeBracketToken, diagnostics, GetAnnotations());
    }

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
    {
         return new AttributeListSyntax(this.Kind, this.openBracketToken, this.target, this.attributes, this.closeBracketToken, GetDiagnostics(), annotations);
    }

    internal AttributeListSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 4;
      var openBracketToken = (SyntaxToken)reader.ReadValue();
      if (openBracketToken != null)
      {
         AdjustFlagsAndWidth(openBracketToken);
         this.openBracketToken = openBracketToken;
      }
      var target = (AttributeTargetSpecifierSyntax)reader.ReadValue();
      if (target != null)
      {
         AdjustFlagsAndWidth(target);
         this.target = target;
      }
      var attributes = (GreenNode)reader.ReadValue();
      if (attributes != null)
      {
         AdjustFlagsAndWidth(attributes);
         this.attributes = attributes;
      }
      var closeBracketToken = (SyntaxToken)reader.ReadValue();
      if (closeBracketToken != null)
      {
         AdjustFlagsAndWidth(closeBracketToken);
         this.closeBracketToken = closeBracketToken;
      }
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.openBracketToken);
      writer.WriteValue(this.target);
      writer.WriteValue(this.attributes);
      writer.WriteValue(this.closeBracketToken);
    }

    static AttributeListSyntax()
    {
       ObjectBinder.RegisterTypeReader(typeof(AttributeListSyntax), r => new AttributeListSyntax(r));
    }
  }

  /// <summary>Class representing what language construct an attribute targets.</summary>
  internal sealed partial class AttributeTargetSpecifierSyntax : CSharpSyntaxNode
  {
    internal readonly SyntaxToken identifier;
    internal readonly SyntaxToken colonToken;

    internal AttributeTargetSpecifierSyntax(SyntaxKind kind, SyntaxToken identifier, SyntaxToken colonToken, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 2;
        this.AdjustFlagsAndWidth(identifier);
        this.identifier = identifier;
        this.AdjustFlagsAndWidth(colonToken);
        this.colonToken = colonToken;
    }


    internal AttributeTargetSpecifierSyntax(SyntaxKind kind, SyntaxToken identifier, SyntaxToken colonToken, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 2;
        this.AdjustFlagsAndWidth(identifier);
        this.identifier = identifier;
        this.AdjustFlagsAndWidth(colonToken);
        this.colonToken = colonToken;
    }


    internal AttributeTargetSpecifierSyntax(SyntaxKind kind, SyntaxToken identifier, SyntaxToken colonToken)
        : base(kind)
    {
        this.SlotCount = 2;
        this.AdjustFlagsAndWidth(identifier);
        this.identifier = identifier;
        this.AdjustFlagsAndWidth(colonToken);
        this.colonToken = colonToken;
    }

    /// <summary>Gets the identifier.</summary>
    public SyntaxToken Identifier { get { return this.identifier; } }
    /// <summary>Gets the colon token.</summary>
    public SyntaxToken ColonToken { get { return this.colonToken; } }

    internal override GreenNode GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.identifier;
            case 1: return this.colonToken;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode parent, int position)
    {
      return new CSharp.Syntax.AttributeTargetSpecifierSyntax(this, parent, position);
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitAttributeTargetSpecifier(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitAttributeTargetSpecifier(this);
    }

    public AttributeTargetSpecifierSyntax Update(SyntaxToken identifier, SyntaxToken colonToken)
    {
        if (identifier != this.Identifier || colonToken != this.ColonToken)
        {
            var newNode = SyntaxFactory.AttributeTargetSpecifier(identifier, colonToken);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
    {
         return new AttributeTargetSpecifierSyntax(this.Kind, this.identifier, this.colonToken, diagnostics, GetAnnotations());
    }

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
    {
         return new AttributeTargetSpecifierSyntax(this.Kind, this.identifier, this.colonToken, GetDiagnostics(), annotations);
    }

    internal AttributeTargetSpecifierSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 2;
      var identifier = (SyntaxToken)reader.ReadValue();
      if (identifier != null)
      {
         AdjustFlagsAndWidth(identifier);
         this.identifier = identifier;
      }
      var colonToken = (SyntaxToken)reader.ReadValue();
      if (colonToken != null)
      {
         AdjustFlagsAndWidth(colonToken);
         this.colonToken = colonToken;
      }
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.identifier);
      writer.WriteValue(this.colonToken);
    }

    static AttributeTargetSpecifierSyntax()
    {
       ObjectBinder.RegisterTypeReader(typeof(AttributeTargetSpecifierSyntax), r => new AttributeTargetSpecifierSyntax(r));
    }
  }

  /// <summary>Attribute syntax.</summary>
  internal sealed partial class AttributeSyntax : CSharpSyntaxNode
  {
    internal readonly NameSyntax name;
    internal readonly AttributeArgumentListSyntax argumentList;

    internal AttributeSyntax(SyntaxKind kind, NameSyntax name, AttributeArgumentListSyntax argumentList, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 2;
        this.AdjustFlagsAndWidth(name);
        this.name = name;
        if (argumentList != null)
        {
            this.AdjustFlagsAndWidth(argumentList);
            this.argumentList = argumentList;
        }
    }


    internal AttributeSyntax(SyntaxKind kind, NameSyntax name, AttributeArgumentListSyntax argumentList, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 2;
        this.AdjustFlagsAndWidth(name);
        this.name = name;
        if (argumentList != null)
        {
            this.AdjustFlagsAndWidth(argumentList);
            this.argumentList = argumentList;
        }
    }


    internal AttributeSyntax(SyntaxKind kind, NameSyntax name, AttributeArgumentListSyntax argumentList)
        : base(kind)
    {
        this.SlotCount = 2;
        this.AdjustFlagsAndWidth(name);
        this.name = name;
        if (argumentList != null)
        {
            this.AdjustFlagsAndWidth(argumentList);
            this.argumentList = argumentList;
        }
    }

    /// <summary>Gets the name.</summary>
    public NameSyntax Name { get { return this.name; } }
    public AttributeArgumentListSyntax ArgumentList { get { return this.argumentList; } }

    internal override GreenNode GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.name;
            case 1: return this.argumentList;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode parent, int position)
    {
      return new CSharp.Syntax.AttributeSyntax(this, parent, position);
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitAttribute(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitAttribute(this);
    }

    public AttributeSyntax Update(NameSyntax name, AttributeArgumentListSyntax argumentList)
    {
        if (name != this.Name || argumentList != this.ArgumentList)
        {
            var newNode = SyntaxFactory.Attribute(name, argumentList);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
    {
         return new AttributeSyntax(this.Kind, this.name, this.argumentList, diagnostics, GetAnnotations());
    }

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
    {
         return new AttributeSyntax(this.Kind, this.name, this.argumentList, GetDiagnostics(), annotations);
    }

    internal AttributeSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 2;
      var name = (NameSyntax)reader.ReadValue();
      if (name != null)
      {
         AdjustFlagsAndWidth(name);
         this.name = name;
      }
      var argumentList = (AttributeArgumentListSyntax)reader.ReadValue();
      if (argumentList != null)
      {
         AdjustFlagsAndWidth(argumentList);
         this.argumentList = argumentList;
      }
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.name);
      writer.WriteValue(this.argumentList);
    }

    static AttributeSyntax()
    {
       ObjectBinder.RegisterTypeReader(typeof(AttributeSyntax), r => new AttributeSyntax(r));
    }
  }

  /// <summary>Attribute argument list syntax.</summary>
  internal sealed partial class AttributeArgumentListSyntax : CSharpSyntaxNode
  {
    internal readonly SyntaxToken openParenToken;
    internal readonly GreenNode arguments;
    internal readonly SyntaxToken closeParenToken;

    internal AttributeArgumentListSyntax(SyntaxKind kind, SyntaxToken openParenToken, GreenNode arguments, SyntaxToken closeParenToken, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 3;
        this.AdjustFlagsAndWidth(openParenToken);
        this.openParenToken = openParenToken;
        if (arguments != null)
        {
            this.AdjustFlagsAndWidth(arguments);
            this.arguments = arguments;
        }
        this.AdjustFlagsAndWidth(closeParenToken);
        this.closeParenToken = closeParenToken;
    }


    internal AttributeArgumentListSyntax(SyntaxKind kind, SyntaxToken openParenToken, GreenNode arguments, SyntaxToken closeParenToken, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 3;
        this.AdjustFlagsAndWidth(openParenToken);
        this.openParenToken = openParenToken;
        if (arguments != null)
        {
            this.AdjustFlagsAndWidth(arguments);
            this.arguments = arguments;
        }
        this.AdjustFlagsAndWidth(closeParenToken);
        this.closeParenToken = closeParenToken;
    }


    internal AttributeArgumentListSyntax(SyntaxKind kind, SyntaxToken openParenToken, GreenNode arguments, SyntaxToken closeParenToken)
        : base(kind)
    {
        this.SlotCount = 3;
        this.AdjustFlagsAndWidth(openParenToken);
        this.openParenToken = openParenToken;
        if (arguments != null)
        {
            this.AdjustFlagsAndWidth(arguments);
            this.arguments = arguments;
        }
        this.AdjustFlagsAndWidth(closeParenToken);
        this.closeParenToken = closeParenToken;
    }

    /// <summary>Gets the open paren token.</summary>
    public SyntaxToken OpenParenToken { get { return this.openParenToken; } }
    /// <summary>Gets the arguments syntax list.</summary>
    public Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<AttributeArgumentSyntax> Arguments { get { return new Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<AttributeArgumentSyntax>(new Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<CSharpSyntaxNode>(this.arguments)); } }
    /// <summary>Gets the close paren token.</summary>
    public SyntaxToken CloseParenToken { get { return this.closeParenToken; } }

    internal override GreenNode GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.openParenToken;
            case 1: return this.arguments;
            case 2: return this.closeParenToken;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode parent, int position)
    {
      return new CSharp.Syntax.AttributeArgumentListSyntax(this, parent, position);
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitAttributeArgumentList(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitAttributeArgumentList(this);
    }

    public AttributeArgumentListSyntax Update(SyntaxToken openParenToken, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<AttributeArgumentSyntax> arguments, SyntaxToken closeParenToken)
    {
        if (openParenToken != this.OpenParenToken || arguments != this.Arguments || closeParenToken != this.CloseParenToken)
        {
            var newNode = SyntaxFactory.AttributeArgumentList(openParenToken, arguments, closeParenToken);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
    {
         return new AttributeArgumentListSyntax(this.Kind, this.openParenToken, this.arguments, this.closeParenToken, diagnostics, GetAnnotations());
    }

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
    {
         return new AttributeArgumentListSyntax(this.Kind, this.openParenToken, this.arguments, this.closeParenToken, GetDiagnostics(), annotations);
    }

    internal AttributeArgumentListSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 3;
      var openParenToken = (SyntaxToken)reader.ReadValue();
      if (openParenToken != null)
      {
         AdjustFlagsAndWidth(openParenToken);
         this.openParenToken = openParenToken;
      }
      var arguments = (GreenNode)reader.ReadValue();
      if (arguments != null)
      {
         AdjustFlagsAndWidth(arguments);
         this.arguments = arguments;
      }
      var closeParenToken = (SyntaxToken)reader.ReadValue();
      if (closeParenToken != null)
      {
         AdjustFlagsAndWidth(closeParenToken);
         this.closeParenToken = closeParenToken;
      }
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.openParenToken);
      writer.WriteValue(this.arguments);
      writer.WriteValue(this.closeParenToken);
    }

    static AttributeArgumentListSyntax()
    {
       ObjectBinder.RegisterTypeReader(typeof(AttributeArgumentListSyntax), r => new AttributeArgumentListSyntax(r));
    }
  }

  /// <summary>Attribute argument syntax.</summary>
  internal sealed partial class AttributeArgumentSyntax : CSharpSyntaxNode
  {
    internal readonly NameEqualsSyntax nameEquals;
    internal readonly NameColonSyntax nameColon;
    internal readonly ExpressionSyntax expression;

    internal AttributeArgumentSyntax(SyntaxKind kind, NameEqualsSyntax nameEquals, NameColonSyntax nameColon, ExpressionSyntax expression, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 3;
        if (nameEquals != null)
        {
            this.AdjustFlagsAndWidth(nameEquals);
            this.nameEquals = nameEquals;
        }
        if (nameColon != null)
        {
            this.AdjustFlagsAndWidth(nameColon);
            this.nameColon = nameColon;
        }
        this.AdjustFlagsAndWidth(expression);
        this.expression = expression;
    }


    internal AttributeArgumentSyntax(SyntaxKind kind, NameEqualsSyntax nameEquals, NameColonSyntax nameColon, ExpressionSyntax expression, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 3;
        if (nameEquals != null)
        {
            this.AdjustFlagsAndWidth(nameEquals);
            this.nameEquals = nameEquals;
        }
        if (nameColon != null)
        {
            this.AdjustFlagsAndWidth(nameColon);
            this.nameColon = nameColon;
        }
        this.AdjustFlagsAndWidth(expression);
        this.expression = expression;
    }


    internal AttributeArgumentSyntax(SyntaxKind kind, NameEqualsSyntax nameEquals, NameColonSyntax nameColon, ExpressionSyntax expression)
        : base(kind)
    {
        this.SlotCount = 3;
        if (nameEquals != null)
        {
            this.AdjustFlagsAndWidth(nameEquals);
            this.nameEquals = nameEquals;
        }
        if (nameColon != null)
        {
            this.AdjustFlagsAndWidth(nameColon);
            this.nameColon = nameColon;
        }
        this.AdjustFlagsAndWidth(expression);
        this.expression = expression;
    }

    public NameEqualsSyntax NameEquals { get { return this.nameEquals; } }
    public NameColonSyntax NameColon { get { return this.nameColon; } }
    /// <summary>Gets the expression.</summary>
    public ExpressionSyntax Expression { get { return this.expression; } }

    internal override GreenNode GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.nameEquals;
            case 1: return this.nameColon;
            case 2: return this.expression;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode parent, int position)
    {
      return new CSharp.Syntax.AttributeArgumentSyntax(this, parent, position);
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitAttributeArgument(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitAttributeArgument(this);
    }

    public AttributeArgumentSyntax Update(NameEqualsSyntax nameEquals, NameColonSyntax nameColon, ExpressionSyntax expression)
    {
        if (nameEquals != this.NameEquals || nameColon != this.NameColon || expression != this.Expression)
        {
            var newNode = SyntaxFactory.AttributeArgument(nameEquals, nameColon, expression);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
    {
         return new AttributeArgumentSyntax(this.Kind, this.nameEquals, this.nameColon, this.expression, diagnostics, GetAnnotations());
    }

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
    {
         return new AttributeArgumentSyntax(this.Kind, this.nameEquals, this.nameColon, this.expression, GetDiagnostics(), annotations);
    }

    internal AttributeArgumentSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 3;
      var nameEquals = (NameEqualsSyntax)reader.ReadValue();
      if (nameEquals != null)
      {
         AdjustFlagsAndWidth(nameEquals);
         this.nameEquals = nameEquals;
      }
      var nameColon = (NameColonSyntax)reader.ReadValue();
      if (nameColon != null)
      {
         AdjustFlagsAndWidth(nameColon);
         this.nameColon = nameColon;
      }
      var expression = (ExpressionSyntax)reader.ReadValue();
      if (expression != null)
      {
         AdjustFlagsAndWidth(expression);
         this.expression = expression;
      }
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.nameEquals);
      writer.WriteValue(this.nameColon);
      writer.WriteValue(this.expression);
    }

    static AttributeArgumentSyntax()
    {
       ObjectBinder.RegisterTypeReader(typeof(AttributeArgumentSyntax), r => new AttributeArgumentSyntax(r));
    }
  }

  /// <summary>Class representing an identifier name followed by an equals token.</summary>
  internal sealed partial class NameEqualsSyntax : CSharpSyntaxNode
  {
    internal readonly IdentifierNameSyntax name;
    internal readonly SyntaxToken equalsToken;

    internal NameEqualsSyntax(SyntaxKind kind, IdentifierNameSyntax name, SyntaxToken equalsToken, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 2;
        this.AdjustFlagsAndWidth(name);
        this.name = name;
        this.AdjustFlagsAndWidth(equalsToken);
        this.equalsToken = equalsToken;
    }


    internal NameEqualsSyntax(SyntaxKind kind, IdentifierNameSyntax name, SyntaxToken equalsToken, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 2;
        this.AdjustFlagsAndWidth(name);
        this.name = name;
        this.AdjustFlagsAndWidth(equalsToken);
        this.equalsToken = equalsToken;
    }


    internal NameEqualsSyntax(SyntaxKind kind, IdentifierNameSyntax name, SyntaxToken equalsToken)
        : base(kind)
    {
        this.SlotCount = 2;
        this.AdjustFlagsAndWidth(name);
        this.name = name;
        this.AdjustFlagsAndWidth(equalsToken);
        this.equalsToken = equalsToken;
    }

    /// <summary>Gets the identifier name.</summary>
    public IdentifierNameSyntax Name { get { return this.name; } }
    public SyntaxToken EqualsToken { get { return this.equalsToken; } }

    internal override GreenNode GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.name;
            case 1: return this.equalsToken;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode parent, int position)
    {
      return new CSharp.Syntax.NameEqualsSyntax(this, parent, position);
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitNameEquals(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitNameEquals(this);
    }

    public NameEqualsSyntax Update(IdentifierNameSyntax name, SyntaxToken equalsToken)
    {
        if (name != this.Name || equalsToken != this.EqualsToken)
        {
            var newNode = SyntaxFactory.NameEquals(name, equalsToken);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
    {
         return new NameEqualsSyntax(this.Kind, this.name, this.equalsToken, diagnostics, GetAnnotations());
    }

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
    {
         return new NameEqualsSyntax(this.Kind, this.name, this.equalsToken, GetDiagnostics(), annotations);
    }

    internal NameEqualsSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 2;
      var name = (IdentifierNameSyntax)reader.ReadValue();
      if (name != null)
      {
         AdjustFlagsAndWidth(name);
         this.name = name;
      }
      var equalsToken = (SyntaxToken)reader.ReadValue();
      if (equalsToken != null)
      {
         AdjustFlagsAndWidth(equalsToken);
         this.equalsToken = equalsToken;
      }
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.name);
      writer.WriteValue(this.equalsToken);
    }

    static NameEqualsSyntax()
    {
       ObjectBinder.RegisterTypeReader(typeof(NameEqualsSyntax), r => new NameEqualsSyntax(r));
    }
  }

  /// <summary>Type parameter list syntax.</summary>
  internal sealed partial class TypeParameterListSyntax : CSharpSyntaxNode
  {
    internal readonly SyntaxToken lessThanToken;
    internal readonly GreenNode parameters;
    internal readonly SyntaxToken greaterThanToken;

    internal TypeParameterListSyntax(SyntaxKind kind, SyntaxToken lessThanToken, GreenNode parameters, SyntaxToken greaterThanToken, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 3;
        this.AdjustFlagsAndWidth(lessThanToken);
        this.lessThanToken = lessThanToken;
        if (parameters != null)
        {
            this.AdjustFlagsAndWidth(parameters);
            this.parameters = parameters;
        }
        this.AdjustFlagsAndWidth(greaterThanToken);
        this.greaterThanToken = greaterThanToken;
    }


    internal TypeParameterListSyntax(SyntaxKind kind, SyntaxToken lessThanToken, GreenNode parameters, SyntaxToken greaterThanToken, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 3;
        this.AdjustFlagsAndWidth(lessThanToken);
        this.lessThanToken = lessThanToken;
        if (parameters != null)
        {
            this.AdjustFlagsAndWidth(parameters);
            this.parameters = parameters;
        }
        this.AdjustFlagsAndWidth(greaterThanToken);
        this.greaterThanToken = greaterThanToken;
    }


    internal TypeParameterListSyntax(SyntaxKind kind, SyntaxToken lessThanToken, GreenNode parameters, SyntaxToken greaterThanToken)
        : base(kind)
    {
        this.SlotCount = 3;
        this.AdjustFlagsAndWidth(lessThanToken);
        this.lessThanToken = lessThanToken;
        if (parameters != null)
        {
            this.AdjustFlagsAndWidth(parameters);
            this.parameters = parameters;
        }
        this.AdjustFlagsAndWidth(greaterThanToken);
        this.greaterThanToken = greaterThanToken;
    }

    /// <summary>Gets the &lt; token.</summary>
    public SyntaxToken LessThanToken { get { return this.lessThanToken; } }
    /// <summary>Gets the parameter list.</summary>
    public Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<TypeParameterSyntax> Parameters { get { return new Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<TypeParameterSyntax>(new Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<CSharpSyntaxNode>(this.parameters)); } }
    /// <summary>Gets the &gt; token.</summary>
    public SyntaxToken GreaterThanToken { get { return this.greaterThanToken; } }

    internal override GreenNode GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.lessThanToken;
            case 1: return this.parameters;
            case 2: return this.greaterThanToken;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode parent, int position)
    {
      return new CSharp.Syntax.TypeParameterListSyntax(this, parent, position);
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitTypeParameterList(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitTypeParameterList(this);
    }

    public TypeParameterListSyntax Update(SyntaxToken lessThanToken, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<TypeParameterSyntax> parameters, SyntaxToken greaterThanToken)
    {
        if (lessThanToken != this.LessThanToken || parameters != this.Parameters || greaterThanToken != this.GreaterThanToken)
        {
            var newNode = SyntaxFactory.TypeParameterList(lessThanToken, parameters, greaterThanToken);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
    {
         return new TypeParameterListSyntax(this.Kind, this.lessThanToken, this.parameters, this.greaterThanToken, diagnostics, GetAnnotations());
    }

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
    {
         return new TypeParameterListSyntax(this.Kind, this.lessThanToken, this.parameters, this.greaterThanToken, GetDiagnostics(), annotations);
    }

    internal TypeParameterListSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 3;
      var lessThanToken = (SyntaxToken)reader.ReadValue();
      if (lessThanToken != null)
      {
         AdjustFlagsAndWidth(lessThanToken);
         this.lessThanToken = lessThanToken;
      }
      var parameters = (GreenNode)reader.ReadValue();
      if (parameters != null)
      {
         AdjustFlagsAndWidth(parameters);
         this.parameters = parameters;
      }
      var greaterThanToken = (SyntaxToken)reader.ReadValue();
      if (greaterThanToken != null)
      {
         AdjustFlagsAndWidth(greaterThanToken);
         this.greaterThanToken = greaterThanToken;
      }
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.lessThanToken);
      writer.WriteValue(this.parameters);
      writer.WriteValue(this.greaterThanToken);
    }

    static TypeParameterListSyntax()
    {
       ObjectBinder.RegisterTypeReader(typeof(TypeParameterListSyntax), r => new TypeParameterListSyntax(r));
    }
  }

  /// <summary>Type parameter syntax.</summary>
  internal sealed partial class TypeParameterSyntax : CSharpSyntaxNode
  {
    internal readonly GreenNode attributeLists;
    internal readonly SyntaxToken varianceKeyword;
    internal readonly SyntaxToken identifier;

    internal TypeParameterSyntax(SyntaxKind kind, GreenNode attributeLists, SyntaxToken varianceKeyword, SyntaxToken identifier, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 3;
        if (attributeLists != null)
        {
            this.AdjustFlagsAndWidth(attributeLists);
            this.attributeLists = attributeLists;
        }
        if (varianceKeyword != null)
        {
            this.AdjustFlagsAndWidth(varianceKeyword);
            this.varianceKeyword = varianceKeyword;
        }
        this.AdjustFlagsAndWidth(identifier);
        this.identifier = identifier;
    }


    internal TypeParameterSyntax(SyntaxKind kind, GreenNode attributeLists, SyntaxToken varianceKeyword, SyntaxToken identifier, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 3;
        if (attributeLists != null)
        {
            this.AdjustFlagsAndWidth(attributeLists);
            this.attributeLists = attributeLists;
        }
        if (varianceKeyword != null)
        {
            this.AdjustFlagsAndWidth(varianceKeyword);
            this.varianceKeyword = varianceKeyword;
        }
        this.AdjustFlagsAndWidth(identifier);
        this.identifier = identifier;
    }


    internal TypeParameterSyntax(SyntaxKind kind, GreenNode attributeLists, SyntaxToken varianceKeyword, SyntaxToken identifier)
        : base(kind)
    {
        this.SlotCount = 3;
        if (attributeLists != null)
        {
            this.AdjustFlagsAndWidth(attributeLists);
            this.attributeLists = attributeLists;
        }
        if (varianceKeyword != null)
        {
            this.AdjustFlagsAndWidth(varianceKeyword);
            this.varianceKeyword = varianceKeyword;
        }
        this.AdjustFlagsAndWidth(identifier);
        this.identifier = identifier;
    }

    /// <summary>Gets the attribute declaration list.</summary>
    public Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<AttributeListSyntax> AttributeLists { get { return new Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<AttributeListSyntax>(this.attributeLists); } }
    public SyntaxToken VarianceKeyword { get { return this.varianceKeyword; } }
    /// <summary>Gets the identifier.</summary>
    public SyntaxToken Identifier { get { return this.identifier; } }

    internal override GreenNode GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.attributeLists;
            case 1: return this.varianceKeyword;
            case 2: return this.identifier;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode parent, int position)
    {
      return new CSharp.Syntax.TypeParameterSyntax(this, parent, position);
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitTypeParameter(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitTypeParameter(this);
    }

    public TypeParameterSyntax Update(Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<AttributeListSyntax> attributeLists, SyntaxToken varianceKeyword, SyntaxToken identifier)
    {
        if (attributeLists != this.AttributeLists || varianceKeyword != this.VarianceKeyword || identifier != this.Identifier)
        {
            var newNode = SyntaxFactory.TypeParameter(attributeLists, varianceKeyword, identifier);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
    {
         return new TypeParameterSyntax(this.Kind, this.attributeLists, this.varianceKeyword, this.identifier, diagnostics, GetAnnotations());
    }

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
    {
         return new TypeParameterSyntax(this.Kind, this.attributeLists, this.varianceKeyword, this.identifier, GetDiagnostics(), annotations);
    }

    internal TypeParameterSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 3;
      var attributeLists = (GreenNode)reader.ReadValue();
      if (attributeLists != null)
      {
         AdjustFlagsAndWidth(attributeLists);
         this.attributeLists = attributeLists;
      }
      var varianceKeyword = (SyntaxToken)reader.ReadValue();
      if (varianceKeyword != null)
      {
         AdjustFlagsAndWidth(varianceKeyword);
         this.varianceKeyword = varianceKeyword;
      }
      var identifier = (SyntaxToken)reader.ReadValue();
      if (identifier != null)
      {
         AdjustFlagsAndWidth(identifier);
         this.identifier = identifier;
      }
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.attributeLists);
      writer.WriteValue(this.varianceKeyword);
      writer.WriteValue(this.identifier);
    }

    static TypeParameterSyntax()
    {
       ObjectBinder.RegisterTypeReader(typeof(TypeParameterSyntax), r => new TypeParameterSyntax(r));
    }
  }

  /// <summary>Base class for type declaration syntax.</summary>
  internal abstract partial class BaseTypeDeclarationSyntax : MemberDeclarationSyntax
  {
    internal BaseTypeDeclarationSyntax(SyntaxKind kind, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
      : base(kind, diagnostics, annotations)
    {
    }
    internal BaseTypeDeclarationSyntax(SyntaxKind kind)
      : base(kind)
    {
    }

    protected BaseTypeDeclarationSyntax(ObjectReader reader)
       : base(reader)
    {
    }

    /// <summary>Gets the attribute declaration list.</summary>
    public abstract Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<AttributeListSyntax> AttributeLists { get; }

    /// <summary>Gets the modifier list.</summary>
    public abstract Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SyntaxToken> Modifiers { get; }

    /// <summary>Gets the identifier.</summary>
    public abstract SyntaxToken Identifier { get; }

    /// <summary>Gets the base type list.</summary>
    public abstract BaseListSyntax BaseList { get; }

    /// <summary>Gets the open brace token.</summary>
    public abstract SyntaxToken OpenBraceToken { get; }

    /// <summary>Gets the close brace token.</summary>
    public abstract SyntaxToken CloseBraceToken { get; }

    /// <summary>Gets the optional semicolon token.</summary>
    public abstract SyntaxToken SemicolonToken { get; }
  }

  /// <summary>Base class for type declaration syntax (class, struct, interface).</summary>
  internal abstract partial class TypeDeclarationSyntax : BaseTypeDeclarationSyntax
  {
    internal TypeDeclarationSyntax(SyntaxKind kind, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
      : base(kind, diagnostics, annotations)
    {
    }
    internal TypeDeclarationSyntax(SyntaxKind kind)
      : base(kind)
    {
    }

    protected TypeDeclarationSyntax(ObjectReader reader)
       : base(reader)
    {
    }

    /// <summary>Gets the type keyword token ("class", "struct", "interface").</summary>
    public abstract SyntaxToken Keyword { get; }

    public abstract TypeParameterListSyntax TypeParameterList { get; }

    /// <summary>Gets the type constraint list.</summary>
    public abstract Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<TypeParameterConstraintClauseSyntax> ConstraintClauses { get; }

    /// <summary>Gets the member declarations.</summary>
    public abstract Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<MemberDeclarationSyntax> Members { get; }
  }

  /// <summary>Class type declaration syntax.</summary>
  internal sealed partial class ClassDeclarationSyntax : TypeDeclarationSyntax
  {
    internal readonly GreenNode attributeLists;
    internal readonly GreenNode modifiers;
    internal readonly SyntaxToken keyword;
    internal readonly SyntaxToken identifier;
    internal readonly TypeParameterListSyntax typeParameterList;
    internal readonly BaseListSyntax baseList;
    internal readonly GreenNode constraintClauses;
    internal readonly SyntaxToken openBraceToken;
    internal readonly GreenNode members;
    internal readonly SyntaxToken closeBraceToken;
    internal readonly SyntaxToken semicolonToken;

    internal ClassDeclarationSyntax(SyntaxKind kind, GreenNode attributeLists, GreenNode modifiers, SyntaxToken keyword, SyntaxToken identifier, TypeParameterListSyntax typeParameterList, BaseListSyntax baseList, GreenNode constraintClauses, SyntaxToken openBraceToken, GreenNode members, SyntaxToken closeBraceToken, SyntaxToken semicolonToken, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 11;
        if (attributeLists != null)
        {
            this.AdjustFlagsAndWidth(attributeLists);
            this.attributeLists = attributeLists;
        }
        if (modifiers != null)
        {
            this.AdjustFlagsAndWidth(modifiers);
            this.modifiers = modifiers;
        }
        this.AdjustFlagsAndWidth(keyword);
        this.keyword = keyword;
        this.AdjustFlagsAndWidth(identifier);
        this.identifier = identifier;
        if (typeParameterList != null)
        {
            this.AdjustFlagsAndWidth(typeParameterList);
            this.typeParameterList = typeParameterList;
        }
        if (baseList != null)
        {
            this.AdjustFlagsAndWidth(baseList);
            this.baseList = baseList;
        }
        if (constraintClauses != null)
        {
            this.AdjustFlagsAndWidth(constraintClauses);
            this.constraintClauses = constraintClauses;
        }
        this.AdjustFlagsAndWidth(openBraceToken);
        this.openBraceToken = openBraceToken;
        if (members != null)
        {
            this.AdjustFlagsAndWidth(members);
            this.members = members;
        }
        this.AdjustFlagsAndWidth(closeBraceToken);
        this.closeBraceToken = closeBraceToken;
        if (semicolonToken != null)
        {
            this.AdjustFlagsAndWidth(semicolonToken);
            this.semicolonToken = semicolonToken;
        }
    }


    internal ClassDeclarationSyntax(SyntaxKind kind, GreenNode attributeLists, GreenNode modifiers, SyntaxToken keyword, SyntaxToken identifier, TypeParameterListSyntax typeParameterList, BaseListSyntax baseList, GreenNode constraintClauses, SyntaxToken openBraceToken, GreenNode members, SyntaxToken closeBraceToken, SyntaxToken semicolonToken, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 11;
        if (attributeLists != null)
        {
            this.AdjustFlagsAndWidth(attributeLists);
            this.attributeLists = attributeLists;
        }
        if (modifiers != null)
        {
            this.AdjustFlagsAndWidth(modifiers);
            this.modifiers = modifiers;
        }
        this.AdjustFlagsAndWidth(keyword);
        this.keyword = keyword;
        this.AdjustFlagsAndWidth(identifier);
        this.identifier = identifier;
        if (typeParameterList != null)
        {
            this.AdjustFlagsAndWidth(typeParameterList);
            this.typeParameterList = typeParameterList;
        }
        if (baseList != null)
        {
            this.AdjustFlagsAndWidth(baseList);
            this.baseList = baseList;
        }
        if (constraintClauses != null)
        {
            this.AdjustFlagsAndWidth(constraintClauses);
            this.constraintClauses = constraintClauses;
        }
        this.AdjustFlagsAndWidth(openBraceToken);
        this.openBraceToken = openBraceToken;
        if (members != null)
        {
            this.AdjustFlagsAndWidth(members);
            this.members = members;
        }
        this.AdjustFlagsAndWidth(closeBraceToken);
        this.closeBraceToken = closeBraceToken;
        if (semicolonToken != null)
        {
            this.AdjustFlagsAndWidth(semicolonToken);
            this.semicolonToken = semicolonToken;
        }
    }


    internal ClassDeclarationSyntax(SyntaxKind kind, GreenNode attributeLists, GreenNode modifiers, SyntaxToken keyword, SyntaxToken identifier, TypeParameterListSyntax typeParameterList, BaseListSyntax baseList, GreenNode constraintClauses, SyntaxToken openBraceToken, GreenNode members, SyntaxToken closeBraceToken, SyntaxToken semicolonToken)
        : base(kind)
    {
        this.SlotCount = 11;
        if (attributeLists != null)
        {
            this.AdjustFlagsAndWidth(attributeLists);
            this.attributeLists = attributeLists;
        }
        if (modifiers != null)
        {
            this.AdjustFlagsAndWidth(modifiers);
            this.modifiers = modifiers;
        }
        this.AdjustFlagsAndWidth(keyword);
        this.keyword = keyword;
        this.AdjustFlagsAndWidth(identifier);
        this.identifier = identifier;
        if (typeParameterList != null)
        {
            this.AdjustFlagsAndWidth(typeParameterList);
            this.typeParameterList = typeParameterList;
        }
        if (baseList != null)
        {
            this.AdjustFlagsAndWidth(baseList);
            this.baseList = baseList;
        }
        if (constraintClauses != null)
        {
            this.AdjustFlagsAndWidth(constraintClauses);
            this.constraintClauses = constraintClauses;
        }
        this.AdjustFlagsAndWidth(openBraceToken);
        this.openBraceToken = openBraceToken;
        if (members != null)
        {
            this.AdjustFlagsAndWidth(members);
            this.members = members;
        }
        this.AdjustFlagsAndWidth(closeBraceToken);
        this.closeBraceToken = closeBraceToken;
        if (semicolonToken != null)
        {
            this.AdjustFlagsAndWidth(semicolonToken);
            this.semicolonToken = semicolonToken;
        }
    }

    public override Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<AttributeListSyntax> AttributeLists { get { return new Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<AttributeListSyntax>(this.attributeLists); } }
    public override Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SyntaxToken> Modifiers { get { return new Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SyntaxToken>(this.modifiers); } }
    /// <summary>Gets the class keyword token.</summary>
    public override SyntaxToken Keyword { get { return this.keyword; } }
    public override SyntaxToken Identifier { get { return this.identifier; } }
    public override TypeParameterListSyntax TypeParameterList { get { return this.typeParameterList; } }
    public override BaseListSyntax BaseList { get { return this.baseList; } }
    public override Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<TypeParameterConstraintClauseSyntax> ConstraintClauses { get { return new Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<TypeParameterConstraintClauseSyntax>(this.constraintClauses); } }
    public override SyntaxToken OpenBraceToken { get { return this.openBraceToken; } }
    public override Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<MemberDeclarationSyntax> Members { get { return new Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<MemberDeclarationSyntax>(this.members); } }
    public override SyntaxToken CloseBraceToken { get { return this.closeBraceToken; } }
    public override SyntaxToken SemicolonToken { get { return this.semicolonToken; } }

    internal override GreenNode GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.attributeLists;
            case 1: return this.modifiers;
            case 2: return this.keyword;
            case 3: return this.identifier;
            case 4: return this.typeParameterList;
            case 5: return this.baseList;
            case 6: return this.constraintClauses;
            case 7: return this.openBraceToken;
            case 8: return this.members;
            case 9: return this.closeBraceToken;
            case 10: return this.semicolonToken;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode parent, int position)
    {
      return new CSharp.Syntax.ClassDeclarationSyntax(this, parent, position);
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitClassDeclaration(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitClassDeclaration(this);
    }

    public ClassDeclarationSyntax Update(Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<AttributeListSyntax> attributeLists, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SyntaxToken> modifiers, SyntaxToken keyword, SyntaxToken identifier, TypeParameterListSyntax typeParameterList, BaseListSyntax baseList, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<TypeParameterConstraintClauseSyntax> constraintClauses, SyntaxToken openBraceToken, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<MemberDeclarationSyntax> members, SyntaxToken closeBraceToken, SyntaxToken semicolonToken)
    {
        if (attributeLists != this.AttributeLists || modifiers != this.Modifiers || keyword != this.Keyword || identifier != this.Identifier || typeParameterList != this.TypeParameterList || baseList != this.BaseList || constraintClauses != this.ConstraintClauses || openBraceToken != this.OpenBraceToken || members != this.Members || closeBraceToken != this.CloseBraceToken || semicolonToken != this.SemicolonToken)
        {
            var newNode = SyntaxFactory.ClassDeclaration(attributeLists, modifiers, keyword, identifier, typeParameterList, baseList, constraintClauses, openBraceToken, members, closeBraceToken, semicolonToken);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
    {
         return new ClassDeclarationSyntax(this.Kind, this.attributeLists, this.modifiers, this.keyword, this.identifier, this.typeParameterList, this.baseList, this.constraintClauses, this.openBraceToken, this.members, this.closeBraceToken, this.semicolonToken, diagnostics, GetAnnotations());
    }

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
    {
         return new ClassDeclarationSyntax(this.Kind, this.attributeLists, this.modifiers, this.keyword, this.identifier, this.typeParameterList, this.baseList, this.constraintClauses, this.openBraceToken, this.members, this.closeBraceToken, this.semicolonToken, GetDiagnostics(), annotations);
    }

    internal ClassDeclarationSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 11;
      var attributeLists = (GreenNode)reader.ReadValue();
      if (attributeLists != null)
      {
         AdjustFlagsAndWidth(attributeLists);
         this.attributeLists = attributeLists;
      }
      var modifiers = (GreenNode)reader.ReadValue();
      if (modifiers != null)
      {
         AdjustFlagsAndWidth(modifiers);
         this.modifiers = modifiers;
      }
      var keyword = (SyntaxToken)reader.ReadValue();
      if (keyword != null)
      {
         AdjustFlagsAndWidth(keyword);
         this.keyword = keyword;
      }
      var identifier = (SyntaxToken)reader.ReadValue();
      if (identifier != null)
      {
         AdjustFlagsAndWidth(identifier);
         this.identifier = identifier;
      }
      var typeParameterList = (TypeParameterListSyntax)reader.ReadValue();
      if (typeParameterList != null)
      {
         AdjustFlagsAndWidth(typeParameterList);
         this.typeParameterList = typeParameterList;
      }
      var baseList = (BaseListSyntax)reader.ReadValue();
      if (baseList != null)
      {
         AdjustFlagsAndWidth(baseList);
         this.baseList = baseList;
      }
      var constraintClauses = (GreenNode)reader.ReadValue();
      if (constraintClauses != null)
      {
         AdjustFlagsAndWidth(constraintClauses);
         this.constraintClauses = constraintClauses;
      }
      var openBraceToken = (SyntaxToken)reader.ReadValue();
      if (openBraceToken != null)
      {
         AdjustFlagsAndWidth(openBraceToken);
         this.openBraceToken = openBraceToken;
      }
      var members = (GreenNode)reader.ReadValue();
      if (members != null)
      {
         AdjustFlagsAndWidth(members);
         this.members = members;
      }
      var closeBraceToken = (SyntaxToken)reader.ReadValue();
      if (closeBraceToken != null)
      {
         AdjustFlagsAndWidth(closeBraceToken);
         this.closeBraceToken = closeBraceToken;
      }
      var semicolonToken = (SyntaxToken)reader.ReadValue();
      if (semicolonToken != null)
      {
         AdjustFlagsAndWidth(semicolonToken);
         this.semicolonToken = semicolonToken;
      }
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.attributeLists);
      writer.WriteValue(this.modifiers);
      writer.WriteValue(this.keyword);
      writer.WriteValue(this.identifier);
      writer.WriteValue(this.typeParameterList);
      writer.WriteValue(this.baseList);
      writer.WriteValue(this.constraintClauses);
      writer.WriteValue(this.openBraceToken);
      writer.WriteValue(this.members);
      writer.WriteValue(this.closeBraceToken);
      writer.WriteValue(this.semicolonToken);
    }

    static ClassDeclarationSyntax()
    {
       ObjectBinder.RegisterTypeReader(typeof(ClassDeclarationSyntax), r => new ClassDeclarationSyntax(r));
    }
  }

  /// <summary>Struct type declaration syntax.</summary>
  internal sealed partial class StructDeclarationSyntax : TypeDeclarationSyntax
  {
    internal readonly GreenNode attributeLists;
    internal readonly GreenNode modifiers;
    internal readonly SyntaxToken keyword;
    internal readonly SyntaxToken identifier;
    internal readonly TypeParameterListSyntax typeParameterList;
    internal readonly BaseListSyntax baseList;
    internal readonly GreenNode constraintClauses;
    internal readonly SyntaxToken openBraceToken;
    internal readonly GreenNode members;
    internal readonly SyntaxToken closeBraceToken;
    internal readonly SyntaxToken semicolonToken;

    internal StructDeclarationSyntax(SyntaxKind kind, GreenNode attributeLists, GreenNode modifiers, SyntaxToken keyword, SyntaxToken identifier, TypeParameterListSyntax typeParameterList, BaseListSyntax baseList, GreenNode constraintClauses, SyntaxToken openBraceToken, GreenNode members, SyntaxToken closeBraceToken, SyntaxToken semicolonToken, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 11;
        if (attributeLists != null)
        {
            this.AdjustFlagsAndWidth(attributeLists);
            this.attributeLists = attributeLists;
        }
        if (modifiers != null)
        {
            this.AdjustFlagsAndWidth(modifiers);
            this.modifiers = modifiers;
        }
        this.AdjustFlagsAndWidth(keyword);
        this.keyword = keyword;
        this.AdjustFlagsAndWidth(identifier);
        this.identifier = identifier;
        if (typeParameterList != null)
        {
            this.AdjustFlagsAndWidth(typeParameterList);
            this.typeParameterList = typeParameterList;
        }
        if (baseList != null)
        {
            this.AdjustFlagsAndWidth(baseList);
            this.baseList = baseList;
        }
        if (constraintClauses != null)
        {
            this.AdjustFlagsAndWidth(constraintClauses);
            this.constraintClauses = constraintClauses;
        }
        this.AdjustFlagsAndWidth(openBraceToken);
        this.openBraceToken = openBraceToken;
        if (members != null)
        {
            this.AdjustFlagsAndWidth(members);
            this.members = members;
        }
        this.AdjustFlagsAndWidth(closeBraceToken);
        this.closeBraceToken = closeBraceToken;
        if (semicolonToken != null)
        {
            this.AdjustFlagsAndWidth(semicolonToken);
            this.semicolonToken = semicolonToken;
        }
    }


    internal StructDeclarationSyntax(SyntaxKind kind, GreenNode attributeLists, GreenNode modifiers, SyntaxToken keyword, SyntaxToken identifier, TypeParameterListSyntax typeParameterList, BaseListSyntax baseList, GreenNode constraintClauses, SyntaxToken openBraceToken, GreenNode members, SyntaxToken closeBraceToken, SyntaxToken semicolonToken, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 11;
        if (attributeLists != null)
        {
            this.AdjustFlagsAndWidth(attributeLists);
            this.attributeLists = attributeLists;
        }
        if (modifiers != null)
        {
            this.AdjustFlagsAndWidth(modifiers);
            this.modifiers = modifiers;
        }
        this.AdjustFlagsAndWidth(keyword);
        this.keyword = keyword;
        this.AdjustFlagsAndWidth(identifier);
        this.identifier = identifier;
        if (typeParameterList != null)
        {
            this.AdjustFlagsAndWidth(typeParameterList);
            this.typeParameterList = typeParameterList;
        }
        if (baseList != null)
        {
            this.AdjustFlagsAndWidth(baseList);
            this.baseList = baseList;
        }
        if (constraintClauses != null)
        {
            this.AdjustFlagsAndWidth(constraintClauses);
            this.constraintClauses = constraintClauses;
        }
        this.AdjustFlagsAndWidth(openBraceToken);
        this.openBraceToken = openBraceToken;
        if (members != null)
        {
            this.AdjustFlagsAndWidth(members);
            this.members = members;
        }
        this.AdjustFlagsAndWidth(closeBraceToken);
        this.closeBraceToken = closeBraceToken;
        if (semicolonToken != null)
        {
            this.AdjustFlagsAndWidth(semicolonToken);
            this.semicolonToken = semicolonToken;
        }
    }


    internal StructDeclarationSyntax(SyntaxKind kind, GreenNode attributeLists, GreenNode modifiers, SyntaxToken keyword, SyntaxToken identifier, TypeParameterListSyntax typeParameterList, BaseListSyntax baseList, GreenNode constraintClauses, SyntaxToken openBraceToken, GreenNode members, SyntaxToken closeBraceToken, SyntaxToken semicolonToken)
        : base(kind)
    {
        this.SlotCount = 11;
        if (attributeLists != null)
        {
            this.AdjustFlagsAndWidth(attributeLists);
            this.attributeLists = attributeLists;
        }
        if (modifiers != null)
        {
            this.AdjustFlagsAndWidth(modifiers);
            this.modifiers = modifiers;
        }
        this.AdjustFlagsAndWidth(keyword);
        this.keyword = keyword;
        this.AdjustFlagsAndWidth(identifier);
        this.identifier = identifier;
        if (typeParameterList != null)
        {
            this.AdjustFlagsAndWidth(typeParameterList);
            this.typeParameterList = typeParameterList;
        }
        if (baseList != null)
        {
            this.AdjustFlagsAndWidth(baseList);
            this.baseList = baseList;
        }
        if (constraintClauses != null)
        {
            this.AdjustFlagsAndWidth(constraintClauses);
            this.constraintClauses = constraintClauses;
        }
        this.AdjustFlagsAndWidth(openBraceToken);
        this.openBraceToken = openBraceToken;
        if (members != null)
        {
            this.AdjustFlagsAndWidth(members);
            this.members = members;
        }
        this.AdjustFlagsAndWidth(closeBraceToken);
        this.closeBraceToken = closeBraceToken;
        if (semicolonToken != null)
        {
            this.AdjustFlagsAndWidth(semicolonToken);
            this.semicolonToken = semicolonToken;
        }
    }

    public override Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<AttributeListSyntax> AttributeLists { get { return new Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<AttributeListSyntax>(this.attributeLists); } }
    public override Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SyntaxToken> Modifiers { get { return new Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SyntaxToken>(this.modifiers); } }
    /// <summary>Gets the struct keyword token.</summary>
    public override SyntaxToken Keyword { get { return this.keyword; } }
    public override SyntaxToken Identifier { get { return this.identifier; } }
    public override TypeParameterListSyntax TypeParameterList { get { return this.typeParameterList; } }
    public override BaseListSyntax BaseList { get { return this.baseList; } }
    public override Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<TypeParameterConstraintClauseSyntax> ConstraintClauses { get { return new Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<TypeParameterConstraintClauseSyntax>(this.constraintClauses); } }
    public override SyntaxToken OpenBraceToken { get { return this.openBraceToken; } }
    public override Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<MemberDeclarationSyntax> Members { get { return new Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<MemberDeclarationSyntax>(this.members); } }
    public override SyntaxToken CloseBraceToken { get { return this.closeBraceToken; } }
    public override SyntaxToken SemicolonToken { get { return this.semicolonToken; } }

    internal override GreenNode GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.attributeLists;
            case 1: return this.modifiers;
            case 2: return this.keyword;
            case 3: return this.identifier;
            case 4: return this.typeParameterList;
            case 5: return this.baseList;
            case 6: return this.constraintClauses;
            case 7: return this.openBraceToken;
            case 8: return this.members;
            case 9: return this.closeBraceToken;
            case 10: return this.semicolonToken;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode parent, int position)
    {
      return new CSharp.Syntax.StructDeclarationSyntax(this, parent, position);
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitStructDeclaration(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitStructDeclaration(this);
    }

    public StructDeclarationSyntax Update(Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<AttributeListSyntax> attributeLists, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SyntaxToken> modifiers, SyntaxToken keyword, SyntaxToken identifier, TypeParameterListSyntax typeParameterList, BaseListSyntax baseList, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<TypeParameterConstraintClauseSyntax> constraintClauses, SyntaxToken openBraceToken, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<MemberDeclarationSyntax> members, SyntaxToken closeBraceToken, SyntaxToken semicolonToken)
    {
        if (attributeLists != this.AttributeLists || modifiers != this.Modifiers || keyword != this.Keyword || identifier != this.Identifier || typeParameterList != this.TypeParameterList || baseList != this.BaseList || constraintClauses != this.ConstraintClauses || openBraceToken != this.OpenBraceToken || members != this.Members || closeBraceToken != this.CloseBraceToken || semicolonToken != this.SemicolonToken)
        {
            var newNode = SyntaxFactory.StructDeclaration(attributeLists, modifiers, keyword, identifier, typeParameterList, baseList, constraintClauses, openBraceToken, members, closeBraceToken, semicolonToken);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
    {
         return new StructDeclarationSyntax(this.Kind, this.attributeLists, this.modifiers, this.keyword, this.identifier, this.typeParameterList, this.baseList, this.constraintClauses, this.openBraceToken, this.members, this.closeBraceToken, this.semicolonToken, diagnostics, GetAnnotations());
    }

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
    {
         return new StructDeclarationSyntax(this.Kind, this.attributeLists, this.modifiers, this.keyword, this.identifier, this.typeParameterList, this.baseList, this.constraintClauses, this.openBraceToken, this.members, this.closeBraceToken, this.semicolonToken, GetDiagnostics(), annotations);
    }

    internal StructDeclarationSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 11;
      var attributeLists = (GreenNode)reader.ReadValue();
      if (attributeLists != null)
      {
         AdjustFlagsAndWidth(attributeLists);
         this.attributeLists = attributeLists;
      }
      var modifiers = (GreenNode)reader.ReadValue();
      if (modifiers != null)
      {
         AdjustFlagsAndWidth(modifiers);
         this.modifiers = modifiers;
      }
      var keyword = (SyntaxToken)reader.ReadValue();
      if (keyword != null)
      {
         AdjustFlagsAndWidth(keyword);
         this.keyword = keyword;
      }
      var identifier = (SyntaxToken)reader.ReadValue();
      if (identifier != null)
      {
         AdjustFlagsAndWidth(identifier);
         this.identifier = identifier;
      }
      var typeParameterList = (TypeParameterListSyntax)reader.ReadValue();
      if (typeParameterList != null)
      {
         AdjustFlagsAndWidth(typeParameterList);
         this.typeParameterList = typeParameterList;
      }
      var baseList = (BaseListSyntax)reader.ReadValue();
      if (baseList != null)
      {
         AdjustFlagsAndWidth(baseList);
         this.baseList = baseList;
      }
      var constraintClauses = (GreenNode)reader.ReadValue();
      if (constraintClauses != null)
      {
         AdjustFlagsAndWidth(constraintClauses);
         this.constraintClauses = constraintClauses;
      }
      var openBraceToken = (SyntaxToken)reader.ReadValue();
      if (openBraceToken != null)
      {
         AdjustFlagsAndWidth(openBraceToken);
         this.openBraceToken = openBraceToken;
      }
      var members = (GreenNode)reader.ReadValue();
      if (members != null)
      {
         AdjustFlagsAndWidth(members);
         this.members = members;
      }
      var closeBraceToken = (SyntaxToken)reader.ReadValue();
      if (closeBraceToken != null)
      {
         AdjustFlagsAndWidth(closeBraceToken);
         this.closeBraceToken = closeBraceToken;
      }
      var semicolonToken = (SyntaxToken)reader.ReadValue();
      if (semicolonToken != null)
      {
         AdjustFlagsAndWidth(semicolonToken);
         this.semicolonToken = semicolonToken;
      }
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.attributeLists);
      writer.WriteValue(this.modifiers);
      writer.WriteValue(this.keyword);
      writer.WriteValue(this.identifier);
      writer.WriteValue(this.typeParameterList);
      writer.WriteValue(this.baseList);
      writer.WriteValue(this.constraintClauses);
      writer.WriteValue(this.openBraceToken);
      writer.WriteValue(this.members);
      writer.WriteValue(this.closeBraceToken);
      writer.WriteValue(this.semicolonToken);
    }

    static StructDeclarationSyntax()
    {
       ObjectBinder.RegisterTypeReader(typeof(StructDeclarationSyntax), r => new StructDeclarationSyntax(r));
    }
  }

  /// <summary>Interface type declaration syntax.</summary>
  internal sealed partial class InterfaceDeclarationSyntax : TypeDeclarationSyntax
  {
    internal readonly GreenNode attributeLists;
    internal readonly GreenNode modifiers;
    internal readonly SyntaxToken keyword;
    internal readonly SyntaxToken identifier;
    internal readonly TypeParameterListSyntax typeParameterList;
    internal readonly BaseListSyntax baseList;
    internal readonly GreenNode constraintClauses;
    internal readonly SyntaxToken openBraceToken;
    internal readonly GreenNode members;
    internal readonly SyntaxToken closeBraceToken;
    internal readonly SyntaxToken semicolonToken;

    internal InterfaceDeclarationSyntax(SyntaxKind kind, GreenNode attributeLists, GreenNode modifiers, SyntaxToken keyword, SyntaxToken identifier, TypeParameterListSyntax typeParameterList, BaseListSyntax baseList, GreenNode constraintClauses, SyntaxToken openBraceToken, GreenNode members, SyntaxToken closeBraceToken, SyntaxToken semicolonToken, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 11;
        if (attributeLists != null)
        {
            this.AdjustFlagsAndWidth(attributeLists);
            this.attributeLists = attributeLists;
        }
        if (modifiers != null)
        {
            this.AdjustFlagsAndWidth(modifiers);
            this.modifiers = modifiers;
        }
        this.AdjustFlagsAndWidth(keyword);
        this.keyword = keyword;
        this.AdjustFlagsAndWidth(identifier);
        this.identifier = identifier;
        if (typeParameterList != null)
        {
            this.AdjustFlagsAndWidth(typeParameterList);
            this.typeParameterList = typeParameterList;
        }
        if (baseList != null)
        {
            this.AdjustFlagsAndWidth(baseList);
            this.baseList = baseList;
        }
        if (constraintClauses != null)
        {
            this.AdjustFlagsAndWidth(constraintClauses);
            this.constraintClauses = constraintClauses;
        }
        this.AdjustFlagsAndWidth(openBraceToken);
        this.openBraceToken = openBraceToken;
        if (members != null)
        {
            this.AdjustFlagsAndWidth(members);
            this.members = members;
        }
        this.AdjustFlagsAndWidth(closeBraceToken);
        this.closeBraceToken = closeBraceToken;
        if (semicolonToken != null)
        {
            this.AdjustFlagsAndWidth(semicolonToken);
            this.semicolonToken = semicolonToken;
        }
    }


    internal InterfaceDeclarationSyntax(SyntaxKind kind, GreenNode attributeLists, GreenNode modifiers, SyntaxToken keyword, SyntaxToken identifier, TypeParameterListSyntax typeParameterList, BaseListSyntax baseList, GreenNode constraintClauses, SyntaxToken openBraceToken, GreenNode members, SyntaxToken closeBraceToken, SyntaxToken semicolonToken, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 11;
        if (attributeLists != null)
        {
            this.AdjustFlagsAndWidth(attributeLists);
            this.attributeLists = attributeLists;
        }
        if (modifiers != null)
        {
            this.AdjustFlagsAndWidth(modifiers);
            this.modifiers = modifiers;
        }
        this.AdjustFlagsAndWidth(keyword);
        this.keyword = keyword;
        this.AdjustFlagsAndWidth(identifier);
        this.identifier = identifier;
        if (typeParameterList != null)
        {
            this.AdjustFlagsAndWidth(typeParameterList);
            this.typeParameterList = typeParameterList;
        }
        if (baseList != null)
        {
            this.AdjustFlagsAndWidth(baseList);
            this.baseList = baseList;
        }
        if (constraintClauses != null)
        {
            this.AdjustFlagsAndWidth(constraintClauses);
            this.constraintClauses = constraintClauses;
        }
        this.AdjustFlagsAndWidth(openBraceToken);
        this.openBraceToken = openBraceToken;
        if (members != null)
        {
            this.AdjustFlagsAndWidth(members);
            this.members = members;
        }
        this.AdjustFlagsAndWidth(closeBraceToken);
        this.closeBraceToken = closeBraceToken;
        if (semicolonToken != null)
        {
            this.AdjustFlagsAndWidth(semicolonToken);
            this.semicolonToken = semicolonToken;
        }
    }


    internal InterfaceDeclarationSyntax(SyntaxKind kind, GreenNode attributeLists, GreenNode modifiers, SyntaxToken keyword, SyntaxToken identifier, TypeParameterListSyntax typeParameterList, BaseListSyntax baseList, GreenNode constraintClauses, SyntaxToken openBraceToken, GreenNode members, SyntaxToken closeBraceToken, SyntaxToken semicolonToken)
        : base(kind)
    {
        this.SlotCount = 11;
        if (attributeLists != null)
        {
            this.AdjustFlagsAndWidth(attributeLists);
            this.attributeLists = attributeLists;
        }
        if (modifiers != null)
        {
            this.AdjustFlagsAndWidth(modifiers);
            this.modifiers = modifiers;
        }
        this.AdjustFlagsAndWidth(keyword);
        this.keyword = keyword;
        this.AdjustFlagsAndWidth(identifier);
        this.identifier = identifier;
        if (typeParameterList != null)
        {
            this.AdjustFlagsAndWidth(typeParameterList);
            this.typeParameterList = typeParameterList;
        }
        if (baseList != null)
        {
            this.AdjustFlagsAndWidth(baseList);
            this.baseList = baseList;
        }
        if (constraintClauses != null)
        {
            this.AdjustFlagsAndWidth(constraintClauses);
            this.constraintClauses = constraintClauses;
        }
        this.AdjustFlagsAndWidth(openBraceToken);
        this.openBraceToken = openBraceToken;
        if (members != null)
        {
            this.AdjustFlagsAndWidth(members);
            this.members = members;
        }
        this.AdjustFlagsAndWidth(closeBraceToken);
        this.closeBraceToken = closeBraceToken;
        if (semicolonToken != null)
        {
            this.AdjustFlagsAndWidth(semicolonToken);
            this.semicolonToken = semicolonToken;
        }
    }

    public override Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<AttributeListSyntax> AttributeLists { get { return new Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<AttributeListSyntax>(this.attributeLists); } }
    public override Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SyntaxToken> Modifiers { get { return new Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SyntaxToken>(this.modifiers); } }
    /// <summary>Gets the interface keyword token.</summary>
    public override SyntaxToken Keyword { get { return this.keyword; } }
    public override SyntaxToken Identifier { get { return this.identifier; } }
    public override TypeParameterListSyntax TypeParameterList { get { return this.typeParameterList; } }
    public override BaseListSyntax BaseList { get { return this.baseList; } }
    public override Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<TypeParameterConstraintClauseSyntax> ConstraintClauses { get { return new Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<TypeParameterConstraintClauseSyntax>(this.constraintClauses); } }
    public override SyntaxToken OpenBraceToken { get { return this.openBraceToken; } }
    public override Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<MemberDeclarationSyntax> Members { get { return new Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<MemberDeclarationSyntax>(this.members); } }
    public override SyntaxToken CloseBraceToken { get { return this.closeBraceToken; } }
    public override SyntaxToken SemicolonToken { get { return this.semicolonToken; } }

    internal override GreenNode GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.attributeLists;
            case 1: return this.modifiers;
            case 2: return this.keyword;
            case 3: return this.identifier;
            case 4: return this.typeParameterList;
            case 5: return this.baseList;
            case 6: return this.constraintClauses;
            case 7: return this.openBraceToken;
            case 8: return this.members;
            case 9: return this.closeBraceToken;
            case 10: return this.semicolonToken;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode parent, int position)
    {
      return new CSharp.Syntax.InterfaceDeclarationSyntax(this, parent, position);
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitInterfaceDeclaration(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitInterfaceDeclaration(this);
    }

    public InterfaceDeclarationSyntax Update(Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<AttributeListSyntax> attributeLists, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SyntaxToken> modifiers, SyntaxToken keyword, SyntaxToken identifier, TypeParameterListSyntax typeParameterList, BaseListSyntax baseList, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<TypeParameterConstraintClauseSyntax> constraintClauses, SyntaxToken openBraceToken, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<MemberDeclarationSyntax> members, SyntaxToken closeBraceToken, SyntaxToken semicolonToken)
    {
        if (attributeLists != this.AttributeLists || modifiers != this.Modifiers || keyword != this.Keyword || identifier != this.Identifier || typeParameterList != this.TypeParameterList || baseList != this.BaseList || constraintClauses != this.ConstraintClauses || openBraceToken != this.OpenBraceToken || members != this.Members || closeBraceToken != this.CloseBraceToken || semicolonToken != this.SemicolonToken)
        {
            var newNode = SyntaxFactory.InterfaceDeclaration(attributeLists, modifiers, keyword, identifier, typeParameterList, baseList, constraintClauses, openBraceToken, members, closeBraceToken, semicolonToken);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
    {
         return new InterfaceDeclarationSyntax(this.Kind, this.attributeLists, this.modifiers, this.keyword, this.identifier, this.typeParameterList, this.baseList, this.constraintClauses, this.openBraceToken, this.members, this.closeBraceToken, this.semicolonToken, diagnostics, GetAnnotations());
    }

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
    {
         return new InterfaceDeclarationSyntax(this.Kind, this.attributeLists, this.modifiers, this.keyword, this.identifier, this.typeParameterList, this.baseList, this.constraintClauses, this.openBraceToken, this.members, this.closeBraceToken, this.semicolonToken, GetDiagnostics(), annotations);
    }

    internal InterfaceDeclarationSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 11;
      var attributeLists = (GreenNode)reader.ReadValue();
      if (attributeLists != null)
      {
         AdjustFlagsAndWidth(attributeLists);
         this.attributeLists = attributeLists;
      }
      var modifiers = (GreenNode)reader.ReadValue();
      if (modifiers != null)
      {
         AdjustFlagsAndWidth(modifiers);
         this.modifiers = modifiers;
      }
      var keyword = (SyntaxToken)reader.ReadValue();
      if (keyword != null)
      {
         AdjustFlagsAndWidth(keyword);
         this.keyword = keyword;
      }
      var identifier = (SyntaxToken)reader.ReadValue();
      if (identifier != null)
      {
         AdjustFlagsAndWidth(identifier);
         this.identifier = identifier;
      }
      var typeParameterList = (TypeParameterListSyntax)reader.ReadValue();
      if (typeParameterList != null)
      {
         AdjustFlagsAndWidth(typeParameterList);
         this.typeParameterList = typeParameterList;
      }
      var baseList = (BaseListSyntax)reader.ReadValue();
      if (baseList != null)
      {
         AdjustFlagsAndWidth(baseList);
         this.baseList = baseList;
      }
      var constraintClauses = (GreenNode)reader.ReadValue();
      if (constraintClauses != null)
      {
         AdjustFlagsAndWidth(constraintClauses);
         this.constraintClauses = constraintClauses;
      }
      var openBraceToken = (SyntaxToken)reader.ReadValue();
      if (openBraceToken != null)
      {
         AdjustFlagsAndWidth(openBraceToken);
         this.openBraceToken = openBraceToken;
      }
      var members = (GreenNode)reader.ReadValue();
      if (members != null)
      {
         AdjustFlagsAndWidth(members);
         this.members = members;
      }
      var closeBraceToken = (SyntaxToken)reader.ReadValue();
      if (closeBraceToken != null)
      {
         AdjustFlagsAndWidth(closeBraceToken);
         this.closeBraceToken = closeBraceToken;
      }
      var semicolonToken = (SyntaxToken)reader.ReadValue();
      if (semicolonToken != null)
      {
         AdjustFlagsAndWidth(semicolonToken);
         this.semicolonToken = semicolonToken;
      }
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.attributeLists);
      writer.WriteValue(this.modifiers);
      writer.WriteValue(this.keyword);
      writer.WriteValue(this.identifier);
      writer.WriteValue(this.typeParameterList);
      writer.WriteValue(this.baseList);
      writer.WriteValue(this.constraintClauses);
      writer.WriteValue(this.openBraceToken);
      writer.WriteValue(this.members);
      writer.WriteValue(this.closeBraceToken);
      writer.WriteValue(this.semicolonToken);
    }

    static InterfaceDeclarationSyntax()
    {
       ObjectBinder.RegisterTypeReader(typeof(InterfaceDeclarationSyntax), r => new InterfaceDeclarationSyntax(r));
    }
  }

  /// <summary>Enum type declaration syntax.</summary>
  internal sealed partial class EnumDeclarationSyntax : BaseTypeDeclarationSyntax
  {
    internal readonly GreenNode attributeLists;
    internal readonly GreenNode modifiers;
    internal readonly SyntaxToken enumKeyword;
    internal readonly SyntaxToken identifier;
    internal readonly BaseListSyntax baseList;
    internal readonly SyntaxToken openBraceToken;
    internal readonly GreenNode members;
    internal readonly SyntaxToken closeBraceToken;
    internal readonly SyntaxToken semicolonToken;

    internal EnumDeclarationSyntax(SyntaxKind kind, GreenNode attributeLists, GreenNode modifiers, SyntaxToken enumKeyword, SyntaxToken identifier, BaseListSyntax baseList, SyntaxToken openBraceToken, GreenNode members, SyntaxToken closeBraceToken, SyntaxToken semicolonToken, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 9;
        if (attributeLists != null)
        {
            this.AdjustFlagsAndWidth(attributeLists);
            this.attributeLists = attributeLists;
        }
        if (modifiers != null)
        {
            this.AdjustFlagsAndWidth(modifiers);
            this.modifiers = modifiers;
        }
        this.AdjustFlagsAndWidth(enumKeyword);
        this.enumKeyword = enumKeyword;
        this.AdjustFlagsAndWidth(identifier);
        this.identifier = identifier;
        if (baseList != null)
        {
            this.AdjustFlagsAndWidth(baseList);
            this.baseList = baseList;
        }
        this.AdjustFlagsAndWidth(openBraceToken);
        this.openBraceToken = openBraceToken;
        if (members != null)
        {
            this.AdjustFlagsAndWidth(members);
            this.members = members;
        }
        this.AdjustFlagsAndWidth(closeBraceToken);
        this.closeBraceToken = closeBraceToken;
        if (semicolonToken != null)
        {
            this.AdjustFlagsAndWidth(semicolonToken);
            this.semicolonToken = semicolonToken;
        }
    }


    internal EnumDeclarationSyntax(SyntaxKind kind, GreenNode attributeLists, GreenNode modifiers, SyntaxToken enumKeyword, SyntaxToken identifier, BaseListSyntax baseList, SyntaxToken openBraceToken, GreenNode members, SyntaxToken closeBraceToken, SyntaxToken semicolonToken, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 9;
        if (attributeLists != null)
        {
            this.AdjustFlagsAndWidth(attributeLists);
            this.attributeLists = attributeLists;
        }
        if (modifiers != null)
        {
            this.AdjustFlagsAndWidth(modifiers);
            this.modifiers = modifiers;
        }
        this.AdjustFlagsAndWidth(enumKeyword);
        this.enumKeyword = enumKeyword;
        this.AdjustFlagsAndWidth(identifier);
        this.identifier = identifier;
        if (baseList != null)
        {
            this.AdjustFlagsAndWidth(baseList);
            this.baseList = baseList;
        }
        this.AdjustFlagsAndWidth(openBraceToken);
        this.openBraceToken = openBraceToken;
        if (members != null)
        {
            this.AdjustFlagsAndWidth(members);
            this.members = members;
        }
        this.AdjustFlagsAndWidth(closeBraceToken);
        this.closeBraceToken = closeBraceToken;
        if (semicolonToken != null)
        {
            this.AdjustFlagsAndWidth(semicolonToken);
            this.semicolonToken = semicolonToken;
        }
    }


    internal EnumDeclarationSyntax(SyntaxKind kind, GreenNode attributeLists, GreenNode modifiers, SyntaxToken enumKeyword, SyntaxToken identifier, BaseListSyntax baseList, SyntaxToken openBraceToken, GreenNode members, SyntaxToken closeBraceToken, SyntaxToken semicolonToken)
        : base(kind)
    {
        this.SlotCount = 9;
        if (attributeLists != null)
        {
            this.AdjustFlagsAndWidth(attributeLists);
            this.attributeLists = attributeLists;
        }
        if (modifiers != null)
        {
            this.AdjustFlagsAndWidth(modifiers);
            this.modifiers = modifiers;
        }
        this.AdjustFlagsAndWidth(enumKeyword);
        this.enumKeyword = enumKeyword;
        this.AdjustFlagsAndWidth(identifier);
        this.identifier = identifier;
        if (baseList != null)
        {
            this.AdjustFlagsAndWidth(baseList);
            this.baseList = baseList;
        }
        this.AdjustFlagsAndWidth(openBraceToken);
        this.openBraceToken = openBraceToken;
        if (members != null)
        {
            this.AdjustFlagsAndWidth(members);
            this.members = members;
        }
        this.AdjustFlagsAndWidth(closeBraceToken);
        this.closeBraceToken = closeBraceToken;
        if (semicolonToken != null)
        {
            this.AdjustFlagsAndWidth(semicolonToken);
            this.semicolonToken = semicolonToken;
        }
    }

    public override Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<AttributeListSyntax> AttributeLists { get { return new Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<AttributeListSyntax>(this.attributeLists); } }
    public override Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SyntaxToken> Modifiers { get { return new Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SyntaxToken>(this.modifiers); } }
    /// <summary>Gets the enum keyword token.</summary>
    public SyntaxToken EnumKeyword { get { return this.enumKeyword; } }
    public override SyntaxToken Identifier { get { return this.identifier; } }
    public override BaseListSyntax BaseList { get { return this.baseList; } }
    public override SyntaxToken OpenBraceToken { get { return this.openBraceToken; } }
    /// <summary>Gets the members declaration list.</summary>
    public Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<EnumMemberDeclarationSyntax> Members { get { return new Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<EnumMemberDeclarationSyntax>(new Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<CSharpSyntaxNode>(this.members)); } }
    public override SyntaxToken CloseBraceToken { get { return this.closeBraceToken; } }
    /// <summary>Gets the optional semicolon token.</summary>
    public override SyntaxToken SemicolonToken { get { return this.semicolonToken; } }

    internal override GreenNode GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.attributeLists;
            case 1: return this.modifiers;
            case 2: return this.enumKeyword;
            case 3: return this.identifier;
            case 4: return this.baseList;
            case 5: return this.openBraceToken;
            case 6: return this.members;
            case 7: return this.closeBraceToken;
            case 8: return this.semicolonToken;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode parent, int position)
    {
      return new CSharp.Syntax.EnumDeclarationSyntax(this, parent, position);
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitEnumDeclaration(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitEnumDeclaration(this);
    }

    public EnumDeclarationSyntax Update(Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<AttributeListSyntax> attributeLists, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SyntaxToken> modifiers, SyntaxToken enumKeyword, SyntaxToken identifier, BaseListSyntax baseList, SyntaxToken openBraceToken, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<EnumMemberDeclarationSyntax> members, SyntaxToken closeBraceToken, SyntaxToken semicolonToken)
    {
        if (attributeLists != this.AttributeLists || modifiers != this.Modifiers || enumKeyword != this.EnumKeyword || identifier != this.Identifier || baseList != this.BaseList || openBraceToken != this.OpenBraceToken || members != this.Members || closeBraceToken != this.CloseBraceToken || semicolonToken != this.SemicolonToken)
        {
            var newNode = SyntaxFactory.EnumDeclaration(attributeLists, modifiers, enumKeyword, identifier, baseList, openBraceToken, members, closeBraceToken, semicolonToken);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
    {
         return new EnumDeclarationSyntax(this.Kind, this.attributeLists, this.modifiers, this.enumKeyword, this.identifier, this.baseList, this.openBraceToken, this.members, this.closeBraceToken, this.semicolonToken, diagnostics, GetAnnotations());
    }

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
    {
         return new EnumDeclarationSyntax(this.Kind, this.attributeLists, this.modifiers, this.enumKeyword, this.identifier, this.baseList, this.openBraceToken, this.members, this.closeBraceToken, this.semicolonToken, GetDiagnostics(), annotations);
    }

    internal EnumDeclarationSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 9;
      var attributeLists = (GreenNode)reader.ReadValue();
      if (attributeLists != null)
      {
         AdjustFlagsAndWidth(attributeLists);
         this.attributeLists = attributeLists;
      }
      var modifiers = (GreenNode)reader.ReadValue();
      if (modifiers != null)
      {
         AdjustFlagsAndWidth(modifiers);
         this.modifiers = modifiers;
      }
      var enumKeyword = (SyntaxToken)reader.ReadValue();
      if (enumKeyword != null)
      {
         AdjustFlagsAndWidth(enumKeyword);
         this.enumKeyword = enumKeyword;
      }
      var identifier = (SyntaxToken)reader.ReadValue();
      if (identifier != null)
      {
         AdjustFlagsAndWidth(identifier);
         this.identifier = identifier;
      }
      var baseList = (BaseListSyntax)reader.ReadValue();
      if (baseList != null)
      {
         AdjustFlagsAndWidth(baseList);
         this.baseList = baseList;
      }
      var openBraceToken = (SyntaxToken)reader.ReadValue();
      if (openBraceToken != null)
      {
         AdjustFlagsAndWidth(openBraceToken);
         this.openBraceToken = openBraceToken;
      }
      var members = (GreenNode)reader.ReadValue();
      if (members != null)
      {
         AdjustFlagsAndWidth(members);
         this.members = members;
      }
      var closeBraceToken = (SyntaxToken)reader.ReadValue();
      if (closeBraceToken != null)
      {
         AdjustFlagsAndWidth(closeBraceToken);
         this.closeBraceToken = closeBraceToken;
      }
      var semicolonToken = (SyntaxToken)reader.ReadValue();
      if (semicolonToken != null)
      {
         AdjustFlagsAndWidth(semicolonToken);
         this.semicolonToken = semicolonToken;
      }
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.attributeLists);
      writer.WriteValue(this.modifiers);
      writer.WriteValue(this.enumKeyword);
      writer.WriteValue(this.identifier);
      writer.WriteValue(this.baseList);
      writer.WriteValue(this.openBraceToken);
      writer.WriteValue(this.members);
      writer.WriteValue(this.closeBraceToken);
      writer.WriteValue(this.semicolonToken);
    }

    static EnumDeclarationSyntax()
    {
       ObjectBinder.RegisterTypeReader(typeof(EnumDeclarationSyntax), r => new EnumDeclarationSyntax(r));
    }
  }

  /// <summary>Delegate declaration syntax.</summary>
  internal sealed partial class DelegateDeclarationSyntax : MemberDeclarationSyntax
  {
    internal readonly GreenNode attributeLists;
    internal readonly GreenNode modifiers;
    internal readonly SyntaxToken delegateKeyword;
    internal readonly TypeSyntax returnType;
    internal readonly SyntaxToken identifier;
    internal readonly TypeParameterListSyntax typeParameterList;
    internal readonly ParameterListSyntax parameterList;
    internal readonly GreenNode constraintClauses;
    internal readonly SyntaxToken semicolonToken;

    internal DelegateDeclarationSyntax(SyntaxKind kind, GreenNode attributeLists, GreenNode modifiers, SyntaxToken delegateKeyword, TypeSyntax returnType, SyntaxToken identifier, TypeParameterListSyntax typeParameterList, ParameterListSyntax parameterList, GreenNode constraintClauses, SyntaxToken semicolonToken, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 9;
        if (attributeLists != null)
        {
            this.AdjustFlagsAndWidth(attributeLists);
            this.attributeLists = attributeLists;
        }
        if (modifiers != null)
        {
            this.AdjustFlagsAndWidth(modifiers);
            this.modifiers = modifiers;
        }
        this.AdjustFlagsAndWidth(delegateKeyword);
        this.delegateKeyword = delegateKeyword;
        this.AdjustFlagsAndWidth(returnType);
        this.returnType = returnType;
        this.AdjustFlagsAndWidth(identifier);
        this.identifier = identifier;
        if (typeParameterList != null)
        {
            this.AdjustFlagsAndWidth(typeParameterList);
            this.typeParameterList = typeParameterList;
        }
        this.AdjustFlagsAndWidth(parameterList);
        this.parameterList = parameterList;
        if (constraintClauses != null)
        {
            this.AdjustFlagsAndWidth(constraintClauses);
            this.constraintClauses = constraintClauses;
        }
        this.AdjustFlagsAndWidth(semicolonToken);
        this.semicolonToken = semicolonToken;
    }


    internal DelegateDeclarationSyntax(SyntaxKind kind, GreenNode attributeLists, GreenNode modifiers, SyntaxToken delegateKeyword, TypeSyntax returnType, SyntaxToken identifier, TypeParameterListSyntax typeParameterList, ParameterListSyntax parameterList, GreenNode constraintClauses, SyntaxToken semicolonToken, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 9;
        if (attributeLists != null)
        {
            this.AdjustFlagsAndWidth(attributeLists);
            this.attributeLists = attributeLists;
        }
        if (modifiers != null)
        {
            this.AdjustFlagsAndWidth(modifiers);
            this.modifiers = modifiers;
        }
        this.AdjustFlagsAndWidth(delegateKeyword);
        this.delegateKeyword = delegateKeyword;
        this.AdjustFlagsAndWidth(returnType);
        this.returnType = returnType;
        this.AdjustFlagsAndWidth(identifier);
        this.identifier = identifier;
        if (typeParameterList != null)
        {
            this.AdjustFlagsAndWidth(typeParameterList);
            this.typeParameterList = typeParameterList;
        }
        this.AdjustFlagsAndWidth(parameterList);
        this.parameterList = parameterList;
        if (constraintClauses != null)
        {
            this.AdjustFlagsAndWidth(constraintClauses);
            this.constraintClauses = constraintClauses;
        }
        this.AdjustFlagsAndWidth(semicolonToken);
        this.semicolonToken = semicolonToken;
    }


    internal DelegateDeclarationSyntax(SyntaxKind kind, GreenNode attributeLists, GreenNode modifiers, SyntaxToken delegateKeyword, TypeSyntax returnType, SyntaxToken identifier, TypeParameterListSyntax typeParameterList, ParameterListSyntax parameterList, GreenNode constraintClauses, SyntaxToken semicolonToken)
        : base(kind)
    {
        this.SlotCount = 9;
        if (attributeLists != null)
        {
            this.AdjustFlagsAndWidth(attributeLists);
            this.attributeLists = attributeLists;
        }
        if (modifiers != null)
        {
            this.AdjustFlagsAndWidth(modifiers);
            this.modifiers = modifiers;
        }
        this.AdjustFlagsAndWidth(delegateKeyword);
        this.delegateKeyword = delegateKeyword;
        this.AdjustFlagsAndWidth(returnType);
        this.returnType = returnType;
        this.AdjustFlagsAndWidth(identifier);
        this.identifier = identifier;
        if (typeParameterList != null)
        {
            this.AdjustFlagsAndWidth(typeParameterList);
            this.typeParameterList = typeParameterList;
        }
        this.AdjustFlagsAndWidth(parameterList);
        this.parameterList = parameterList;
        if (constraintClauses != null)
        {
            this.AdjustFlagsAndWidth(constraintClauses);
            this.constraintClauses = constraintClauses;
        }
        this.AdjustFlagsAndWidth(semicolonToken);
        this.semicolonToken = semicolonToken;
    }

    /// <summary>Gets the attribute declaration list.</summary>
    public Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<AttributeListSyntax> AttributeLists { get { return new Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<AttributeListSyntax>(this.attributeLists); } }
    /// <summary>Gets the modifier list.</summary>
    public Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SyntaxToken> Modifiers { get { return new Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SyntaxToken>(this.modifiers); } }
    /// <summary>Gets the "delegate" keyword.</summary>
    public SyntaxToken DelegateKeyword { get { return this.delegateKeyword; } }
    /// <summary>Gets the return type.</summary>
    public TypeSyntax ReturnType { get { return this.returnType; } }
    /// <summary>Gets the identifier.</summary>
    public SyntaxToken Identifier { get { return this.identifier; } }
    public TypeParameterListSyntax TypeParameterList { get { return this.typeParameterList; } }
    /// <summary>Gets the parameter list.</summary>
    public ParameterListSyntax ParameterList { get { return this.parameterList; } }
    /// <summary>Gets the constraint clause list.</summary>
    public Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<TypeParameterConstraintClauseSyntax> ConstraintClauses { get { return new Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<TypeParameterConstraintClauseSyntax>(this.constraintClauses); } }
    /// <summary>Gets the semicolon token.</summary>
    public SyntaxToken SemicolonToken { get { return this.semicolonToken; } }

    internal override GreenNode GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.attributeLists;
            case 1: return this.modifiers;
            case 2: return this.delegateKeyword;
            case 3: return this.returnType;
            case 4: return this.identifier;
            case 5: return this.typeParameterList;
            case 6: return this.parameterList;
            case 7: return this.constraintClauses;
            case 8: return this.semicolonToken;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode parent, int position)
    {
      return new CSharp.Syntax.DelegateDeclarationSyntax(this, parent, position);
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitDelegateDeclaration(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitDelegateDeclaration(this);
    }

    public DelegateDeclarationSyntax Update(Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<AttributeListSyntax> attributeLists, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SyntaxToken> modifiers, SyntaxToken delegateKeyword, TypeSyntax returnType, SyntaxToken identifier, TypeParameterListSyntax typeParameterList, ParameterListSyntax parameterList, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<TypeParameterConstraintClauseSyntax> constraintClauses, SyntaxToken semicolonToken)
    {
        if (attributeLists != this.AttributeLists || modifiers != this.Modifiers || delegateKeyword != this.DelegateKeyword || returnType != this.ReturnType || identifier != this.Identifier || typeParameterList != this.TypeParameterList || parameterList != this.ParameterList || constraintClauses != this.ConstraintClauses || semicolonToken != this.SemicolonToken)
        {
            var newNode = SyntaxFactory.DelegateDeclaration(attributeLists, modifiers, delegateKeyword, returnType, identifier, typeParameterList, parameterList, constraintClauses, semicolonToken);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
    {
         return new DelegateDeclarationSyntax(this.Kind, this.attributeLists, this.modifiers, this.delegateKeyword, this.returnType, this.identifier, this.typeParameterList, this.parameterList, this.constraintClauses, this.semicolonToken, diagnostics, GetAnnotations());
    }

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
    {
         return new DelegateDeclarationSyntax(this.Kind, this.attributeLists, this.modifiers, this.delegateKeyword, this.returnType, this.identifier, this.typeParameterList, this.parameterList, this.constraintClauses, this.semicolonToken, GetDiagnostics(), annotations);
    }

    internal DelegateDeclarationSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 9;
      var attributeLists = (GreenNode)reader.ReadValue();
      if (attributeLists != null)
      {
         AdjustFlagsAndWidth(attributeLists);
         this.attributeLists = attributeLists;
      }
      var modifiers = (GreenNode)reader.ReadValue();
      if (modifiers != null)
      {
         AdjustFlagsAndWidth(modifiers);
         this.modifiers = modifiers;
      }
      var delegateKeyword = (SyntaxToken)reader.ReadValue();
      if (delegateKeyword != null)
      {
         AdjustFlagsAndWidth(delegateKeyword);
         this.delegateKeyword = delegateKeyword;
      }
      var returnType = (TypeSyntax)reader.ReadValue();
      if (returnType != null)
      {
         AdjustFlagsAndWidth(returnType);
         this.returnType = returnType;
      }
      var identifier = (SyntaxToken)reader.ReadValue();
      if (identifier != null)
      {
         AdjustFlagsAndWidth(identifier);
         this.identifier = identifier;
      }
      var typeParameterList = (TypeParameterListSyntax)reader.ReadValue();
      if (typeParameterList != null)
      {
         AdjustFlagsAndWidth(typeParameterList);
         this.typeParameterList = typeParameterList;
      }
      var parameterList = (ParameterListSyntax)reader.ReadValue();
      if (parameterList != null)
      {
         AdjustFlagsAndWidth(parameterList);
         this.parameterList = parameterList;
      }
      var constraintClauses = (GreenNode)reader.ReadValue();
      if (constraintClauses != null)
      {
         AdjustFlagsAndWidth(constraintClauses);
         this.constraintClauses = constraintClauses;
      }
      var semicolonToken = (SyntaxToken)reader.ReadValue();
      if (semicolonToken != null)
      {
         AdjustFlagsAndWidth(semicolonToken);
         this.semicolonToken = semicolonToken;
      }
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.attributeLists);
      writer.WriteValue(this.modifiers);
      writer.WriteValue(this.delegateKeyword);
      writer.WriteValue(this.returnType);
      writer.WriteValue(this.identifier);
      writer.WriteValue(this.typeParameterList);
      writer.WriteValue(this.parameterList);
      writer.WriteValue(this.constraintClauses);
      writer.WriteValue(this.semicolonToken);
    }

    static DelegateDeclarationSyntax()
    {
       ObjectBinder.RegisterTypeReader(typeof(DelegateDeclarationSyntax), r => new DelegateDeclarationSyntax(r));
    }
  }

  internal sealed partial class EnumMemberDeclarationSyntax : MemberDeclarationSyntax
  {
    internal readonly GreenNode attributeLists;
    internal readonly SyntaxToken identifier;
    internal readonly EqualsValueClauseSyntax equalsValue;

    internal EnumMemberDeclarationSyntax(SyntaxKind kind, GreenNode attributeLists, SyntaxToken identifier, EqualsValueClauseSyntax equalsValue, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 3;
        if (attributeLists != null)
        {
            this.AdjustFlagsAndWidth(attributeLists);
            this.attributeLists = attributeLists;
        }
        this.AdjustFlagsAndWidth(identifier);
        this.identifier = identifier;
        if (equalsValue != null)
        {
            this.AdjustFlagsAndWidth(equalsValue);
            this.equalsValue = equalsValue;
        }
    }


    internal EnumMemberDeclarationSyntax(SyntaxKind kind, GreenNode attributeLists, SyntaxToken identifier, EqualsValueClauseSyntax equalsValue, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 3;
        if (attributeLists != null)
        {
            this.AdjustFlagsAndWidth(attributeLists);
            this.attributeLists = attributeLists;
        }
        this.AdjustFlagsAndWidth(identifier);
        this.identifier = identifier;
        if (equalsValue != null)
        {
            this.AdjustFlagsAndWidth(equalsValue);
            this.equalsValue = equalsValue;
        }
    }


    internal EnumMemberDeclarationSyntax(SyntaxKind kind, GreenNode attributeLists, SyntaxToken identifier, EqualsValueClauseSyntax equalsValue)
        : base(kind)
    {
        this.SlotCount = 3;
        if (attributeLists != null)
        {
            this.AdjustFlagsAndWidth(attributeLists);
            this.attributeLists = attributeLists;
        }
        this.AdjustFlagsAndWidth(identifier);
        this.identifier = identifier;
        if (equalsValue != null)
        {
            this.AdjustFlagsAndWidth(equalsValue);
            this.equalsValue = equalsValue;
        }
    }

    /// <summary>Gets the attribute declaration list.</summary>
    public Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<AttributeListSyntax> AttributeLists { get { return new Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<AttributeListSyntax>(this.attributeLists); } }
    /// <summary>Gets the identifier.</summary>
    public SyntaxToken Identifier { get { return this.identifier; } }
    public EqualsValueClauseSyntax EqualsValue { get { return this.equalsValue; } }

    internal override GreenNode GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.attributeLists;
            case 1: return this.identifier;
            case 2: return this.equalsValue;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode parent, int position)
    {
      return new CSharp.Syntax.EnumMemberDeclarationSyntax(this, parent, position);
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitEnumMemberDeclaration(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitEnumMemberDeclaration(this);
    }

    public EnumMemberDeclarationSyntax Update(Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<AttributeListSyntax> attributeLists, SyntaxToken identifier, EqualsValueClauseSyntax equalsValue)
    {
        if (attributeLists != this.AttributeLists || identifier != this.Identifier || equalsValue != this.EqualsValue)
        {
            var newNode = SyntaxFactory.EnumMemberDeclaration(attributeLists, identifier, equalsValue);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
    {
         return new EnumMemberDeclarationSyntax(this.Kind, this.attributeLists, this.identifier, this.equalsValue, diagnostics, GetAnnotations());
    }

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
    {
         return new EnumMemberDeclarationSyntax(this.Kind, this.attributeLists, this.identifier, this.equalsValue, GetDiagnostics(), annotations);
    }

    internal EnumMemberDeclarationSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 3;
      var attributeLists = (GreenNode)reader.ReadValue();
      if (attributeLists != null)
      {
         AdjustFlagsAndWidth(attributeLists);
         this.attributeLists = attributeLists;
      }
      var identifier = (SyntaxToken)reader.ReadValue();
      if (identifier != null)
      {
         AdjustFlagsAndWidth(identifier);
         this.identifier = identifier;
      }
      var equalsValue = (EqualsValueClauseSyntax)reader.ReadValue();
      if (equalsValue != null)
      {
         AdjustFlagsAndWidth(equalsValue);
         this.equalsValue = equalsValue;
      }
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.attributeLists);
      writer.WriteValue(this.identifier);
      writer.WriteValue(this.equalsValue);
    }

    static EnumMemberDeclarationSyntax()
    {
       ObjectBinder.RegisterTypeReader(typeof(EnumMemberDeclarationSyntax), r => new EnumMemberDeclarationSyntax(r));
    }
  }

  /// <summary>Base list syntax.</summary>
  internal sealed partial class BaseListSyntax : CSharpSyntaxNode
  {
    internal readonly SyntaxToken colonToken;
    internal readonly GreenNode types;

    internal BaseListSyntax(SyntaxKind kind, SyntaxToken colonToken, GreenNode types, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 2;
        this.AdjustFlagsAndWidth(colonToken);
        this.colonToken = colonToken;
        if (types != null)
        {
            this.AdjustFlagsAndWidth(types);
            this.types = types;
        }
    }


    internal BaseListSyntax(SyntaxKind kind, SyntaxToken colonToken, GreenNode types, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 2;
        this.AdjustFlagsAndWidth(colonToken);
        this.colonToken = colonToken;
        if (types != null)
        {
            this.AdjustFlagsAndWidth(types);
            this.types = types;
        }
    }


    internal BaseListSyntax(SyntaxKind kind, SyntaxToken colonToken, GreenNode types)
        : base(kind)
    {
        this.SlotCount = 2;
        this.AdjustFlagsAndWidth(colonToken);
        this.colonToken = colonToken;
        if (types != null)
        {
            this.AdjustFlagsAndWidth(types);
            this.types = types;
        }
    }

    /// <summary>Gets the colon token.</summary>
    public SyntaxToken ColonToken { get { return this.colonToken; } }
    /// <summary>Gets the base type references.</summary>
    public Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<BaseTypeSyntax> Types { get { return new Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<BaseTypeSyntax>(new Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<CSharpSyntaxNode>(this.types)); } }

    internal override GreenNode GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.colonToken;
            case 1: return this.types;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode parent, int position)
    {
      return new CSharp.Syntax.BaseListSyntax(this, parent, position);
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitBaseList(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitBaseList(this);
    }

    public BaseListSyntax Update(SyntaxToken colonToken, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<BaseTypeSyntax> types)
    {
        if (colonToken != this.ColonToken || types != this.Types)
        {
            var newNode = SyntaxFactory.BaseList(colonToken, types);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
    {
         return new BaseListSyntax(this.Kind, this.colonToken, this.types, diagnostics, GetAnnotations());
    }

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
    {
         return new BaseListSyntax(this.Kind, this.colonToken, this.types, GetDiagnostics(), annotations);
    }

    internal BaseListSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 2;
      var colonToken = (SyntaxToken)reader.ReadValue();
      if (colonToken != null)
      {
         AdjustFlagsAndWidth(colonToken);
         this.colonToken = colonToken;
      }
      var types = (GreenNode)reader.ReadValue();
      if (types != null)
      {
         AdjustFlagsAndWidth(types);
         this.types = types;
      }
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.colonToken);
      writer.WriteValue(this.types);
    }

    static BaseListSyntax()
    {
       ObjectBinder.RegisterTypeReader(typeof(BaseListSyntax), r => new BaseListSyntax(r));
    }
  }

  /// <summary>Provides the base class from which the classes that represent base type syntax nodes are derived. This is an abstract class.</summary>
  internal abstract partial class BaseTypeSyntax : CSharpSyntaxNode
  {
    internal BaseTypeSyntax(SyntaxKind kind, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
      : base(kind, diagnostics, annotations)
    {
    }
    internal BaseTypeSyntax(SyntaxKind kind)
      : base(kind)
    {
    }

    protected BaseTypeSyntax(ObjectReader reader)
       : base(reader)
    {
    }

    public abstract TypeSyntax Type { get; }
  }

  internal sealed partial class SimpleBaseTypeSyntax : BaseTypeSyntax
  {
    internal readonly TypeSyntax type;

    internal SimpleBaseTypeSyntax(SyntaxKind kind, TypeSyntax type, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 1;
        this.AdjustFlagsAndWidth(type);
        this.type = type;
    }


    internal SimpleBaseTypeSyntax(SyntaxKind kind, TypeSyntax type, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 1;
        this.AdjustFlagsAndWidth(type);
        this.type = type;
    }


    internal SimpleBaseTypeSyntax(SyntaxKind kind, TypeSyntax type)
        : base(kind)
    {
        this.SlotCount = 1;
        this.AdjustFlagsAndWidth(type);
        this.type = type;
    }

    public override TypeSyntax Type { get { return this.type; } }

    internal override GreenNode GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.type;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode parent, int position)
    {
      return new CSharp.Syntax.SimpleBaseTypeSyntax(this, parent, position);
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitSimpleBaseType(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitSimpleBaseType(this);
    }

    public SimpleBaseTypeSyntax Update(TypeSyntax type)
    {
        if (type != this.Type)
        {
            var newNode = SyntaxFactory.SimpleBaseType(type);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
    {
         return new SimpleBaseTypeSyntax(this.Kind, this.type, diagnostics, GetAnnotations());
    }

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
    {
         return new SimpleBaseTypeSyntax(this.Kind, this.type, GetDiagnostics(), annotations);
    }

    internal SimpleBaseTypeSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 1;
      var type = (TypeSyntax)reader.ReadValue();
      if (type != null)
      {
         AdjustFlagsAndWidth(type);
         this.type = type;
      }
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.type);
    }

    static SimpleBaseTypeSyntax()
    {
       ObjectBinder.RegisterTypeReader(typeof(SimpleBaseTypeSyntax), r => new SimpleBaseTypeSyntax(r));
    }
  }

  /// <summary>Type parameter constraint clause.</summary>
  internal sealed partial class TypeParameterConstraintClauseSyntax : CSharpSyntaxNode
  {
    internal readonly SyntaxToken whereKeyword;
    internal readonly IdentifierNameSyntax name;
    internal readonly SyntaxToken colonToken;
    internal readonly GreenNode constraints;

    internal TypeParameterConstraintClauseSyntax(SyntaxKind kind, SyntaxToken whereKeyword, IdentifierNameSyntax name, SyntaxToken colonToken, GreenNode constraints, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 4;
        this.AdjustFlagsAndWidth(whereKeyword);
        this.whereKeyword = whereKeyword;
        this.AdjustFlagsAndWidth(name);
        this.name = name;
        this.AdjustFlagsAndWidth(colonToken);
        this.colonToken = colonToken;
        if (constraints != null)
        {
            this.AdjustFlagsAndWidth(constraints);
            this.constraints = constraints;
        }
    }


    internal TypeParameterConstraintClauseSyntax(SyntaxKind kind, SyntaxToken whereKeyword, IdentifierNameSyntax name, SyntaxToken colonToken, GreenNode constraints, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 4;
        this.AdjustFlagsAndWidth(whereKeyword);
        this.whereKeyword = whereKeyword;
        this.AdjustFlagsAndWidth(name);
        this.name = name;
        this.AdjustFlagsAndWidth(colonToken);
        this.colonToken = colonToken;
        if (constraints != null)
        {
            this.AdjustFlagsAndWidth(constraints);
            this.constraints = constraints;
        }
    }


    internal TypeParameterConstraintClauseSyntax(SyntaxKind kind, SyntaxToken whereKeyword, IdentifierNameSyntax name, SyntaxToken colonToken, GreenNode constraints)
        : base(kind)
    {
        this.SlotCount = 4;
        this.AdjustFlagsAndWidth(whereKeyword);
        this.whereKeyword = whereKeyword;
        this.AdjustFlagsAndWidth(name);
        this.name = name;
        this.AdjustFlagsAndWidth(colonToken);
        this.colonToken = colonToken;
        if (constraints != null)
        {
            this.AdjustFlagsAndWidth(constraints);
            this.constraints = constraints;
        }
    }

    public SyntaxToken WhereKeyword { get { return this.whereKeyword; } }
    /// <summary>Gets the identifier.</summary>
    public IdentifierNameSyntax Name { get { return this.name; } }
    /// <summary>Gets the colon token.</summary>
    public SyntaxToken ColonToken { get { return this.colonToken; } }
    /// <summary>Gets the constraints list.</summary>
    public Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<TypeParameterConstraintSyntax> Constraints { get { return new Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<TypeParameterConstraintSyntax>(new Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<CSharpSyntaxNode>(this.constraints)); } }

    internal override GreenNode GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.whereKeyword;
            case 1: return this.name;
            case 2: return this.colonToken;
            case 3: return this.constraints;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode parent, int position)
    {
      return new CSharp.Syntax.TypeParameterConstraintClauseSyntax(this, parent, position);
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitTypeParameterConstraintClause(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitTypeParameterConstraintClause(this);
    }

    public TypeParameterConstraintClauseSyntax Update(SyntaxToken whereKeyword, IdentifierNameSyntax name, SyntaxToken colonToken, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<TypeParameterConstraintSyntax> constraints)
    {
        if (whereKeyword != this.WhereKeyword || name != this.Name || colonToken != this.ColonToken || constraints != this.Constraints)
        {
            var newNode = SyntaxFactory.TypeParameterConstraintClause(whereKeyword, name, colonToken, constraints);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
    {
         return new TypeParameterConstraintClauseSyntax(this.Kind, this.whereKeyword, this.name, this.colonToken, this.constraints, diagnostics, GetAnnotations());
    }

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
    {
         return new TypeParameterConstraintClauseSyntax(this.Kind, this.whereKeyword, this.name, this.colonToken, this.constraints, GetDiagnostics(), annotations);
    }

    internal TypeParameterConstraintClauseSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 4;
      var whereKeyword = (SyntaxToken)reader.ReadValue();
      if (whereKeyword != null)
      {
         AdjustFlagsAndWidth(whereKeyword);
         this.whereKeyword = whereKeyword;
      }
      var name = (IdentifierNameSyntax)reader.ReadValue();
      if (name != null)
      {
         AdjustFlagsAndWidth(name);
         this.name = name;
      }
      var colonToken = (SyntaxToken)reader.ReadValue();
      if (colonToken != null)
      {
         AdjustFlagsAndWidth(colonToken);
         this.colonToken = colonToken;
      }
      var constraints = (GreenNode)reader.ReadValue();
      if (constraints != null)
      {
         AdjustFlagsAndWidth(constraints);
         this.constraints = constraints;
      }
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.whereKeyword);
      writer.WriteValue(this.name);
      writer.WriteValue(this.colonToken);
      writer.WriteValue(this.constraints);
    }

    static TypeParameterConstraintClauseSyntax()
    {
       ObjectBinder.RegisterTypeReader(typeof(TypeParameterConstraintClauseSyntax), r => new TypeParameterConstraintClauseSyntax(r));
    }
  }

  /// <summary>Base type for type parameter constraint syntax.</summary>
  internal abstract partial class TypeParameterConstraintSyntax : CSharpSyntaxNode
  {
    internal TypeParameterConstraintSyntax(SyntaxKind kind, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
      : base(kind, diagnostics, annotations)
    {
    }
    internal TypeParameterConstraintSyntax(SyntaxKind kind)
      : base(kind)
    {
    }

    protected TypeParameterConstraintSyntax(ObjectReader reader)
       : base(reader)
    {
    }
  }

  /// <summary>Constructor constraint syntax.</summary>
  internal sealed partial class ConstructorConstraintSyntax : TypeParameterConstraintSyntax
  {
    internal readonly SyntaxToken newKeyword;
    internal readonly SyntaxToken openParenToken;
    internal readonly SyntaxToken closeParenToken;

    internal ConstructorConstraintSyntax(SyntaxKind kind, SyntaxToken newKeyword, SyntaxToken openParenToken, SyntaxToken closeParenToken, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 3;
        this.AdjustFlagsAndWidth(newKeyword);
        this.newKeyword = newKeyword;
        this.AdjustFlagsAndWidth(openParenToken);
        this.openParenToken = openParenToken;
        this.AdjustFlagsAndWidth(closeParenToken);
        this.closeParenToken = closeParenToken;
    }


    internal ConstructorConstraintSyntax(SyntaxKind kind, SyntaxToken newKeyword, SyntaxToken openParenToken, SyntaxToken closeParenToken, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 3;
        this.AdjustFlagsAndWidth(newKeyword);
        this.newKeyword = newKeyword;
        this.AdjustFlagsAndWidth(openParenToken);
        this.openParenToken = openParenToken;
        this.AdjustFlagsAndWidth(closeParenToken);
        this.closeParenToken = closeParenToken;
    }


    internal ConstructorConstraintSyntax(SyntaxKind kind, SyntaxToken newKeyword, SyntaxToken openParenToken, SyntaxToken closeParenToken)
        : base(kind)
    {
        this.SlotCount = 3;
        this.AdjustFlagsAndWidth(newKeyword);
        this.newKeyword = newKeyword;
        this.AdjustFlagsAndWidth(openParenToken);
        this.openParenToken = openParenToken;
        this.AdjustFlagsAndWidth(closeParenToken);
        this.closeParenToken = closeParenToken;
    }

    /// <summary>Gets the "new" keyword.</summary>
    public SyntaxToken NewKeyword { get { return this.newKeyword; } }
    /// <summary>Gets the open paren keyword.</summary>
    public SyntaxToken OpenParenToken { get { return this.openParenToken; } }
    /// <summary>Gets the close paren keyword.</summary>
    public SyntaxToken CloseParenToken { get { return this.closeParenToken; } }

    internal override GreenNode GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.newKeyword;
            case 1: return this.openParenToken;
            case 2: return this.closeParenToken;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode parent, int position)
    {
      return new CSharp.Syntax.ConstructorConstraintSyntax(this, parent, position);
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitConstructorConstraint(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitConstructorConstraint(this);
    }

    public ConstructorConstraintSyntax Update(SyntaxToken newKeyword, SyntaxToken openParenToken, SyntaxToken closeParenToken)
    {
        if (newKeyword != this.NewKeyword || openParenToken != this.OpenParenToken || closeParenToken != this.CloseParenToken)
        {
            var newNode = SyntaxFactory.ConstructorConstraint(newKeyword, openParenToken, closeParenToken);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
    {
         return new ConstructorConstraintSyntax(this.Kind, this.newKeyword, this.openParenToken, this.closeParenToken, diagnostics, GetAnnotations());
    }

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
    {
         return new ConstructorConstraintSyntax(this.Kind, this.newKeyword, this.openParenToken, this.closeParenToken, GetDiagnostics(), annotations);
    }

    internal ConstructorConstraintSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 3;
      var newKeyword = (SyntaxToken)reader.ReadValue();
      if (newKeyword != null)
      {
         AdjustFlagsAndWidth(newKeyword);
         this.newKeyword = newKeyword;
      }
      var openParenToken = (SyntaxToken)reader.ReadValue();
      if (openParenToken != null)
      {
         AdjustFlagsAndWidth(openParenToken);
         this.openParenToken = openParenToken;
      }
      var closeParenToken = (SyntaxToken)reader.ReadValue();
      if (closeParenToken != null)
      {
         AdjustFlagsAndWidth(closeParenToken);
         this.closeParenToken = closeParenToken;
      }
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.newKeyword);
      writer.WriteValue(this.openParenToken);
      writer.WriteValue(this.closeParenToken);
    }

    static ConstructorConstraintSyntax()
    {
       ObjectBinder.RegisterTypeReader(typeof(ConstructorConstraintSyntax), r => new ConstructorConstraintSyntax(r));
    }
  }

  /// <summary>Base type for class or struct constraint syntax.</summary>
  internal sealed partial class ClassOrStructConstraintSyntax : TypeParameterConstraintSyntax
  {
    internal readonly SyntaxToken classOrStructKeyword;

    internal ClassOrStructConstraintSyntax(SyntaxKind kind, SyntaxToken classOrStructKeyword, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 1;
        this.AdjustFlagsAndWidth(classOrStructKeyword);
        this.classOrStructKeyword = classOrStructKeyword;
    }


    internal ClassOrStructConstraintSyntax(SyntaxKind kind, SyntaxToken classOrStructKeyword, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 1;
        this.AdjustFlagsAndWidth(classOrStructKeyword);
        this.classOrStructKeyword = classOrStructKeyword;
    }


    internal ClassOrStructConstraintSyntax(SyntaxKind kind, SyntaxToken classOrStructKeyword)
        : base(kind)
    {
        this.SlotCount = 1;
        this.AdjustFlagsAndWidth(classOrStructKeyword);
        this.classOrStructKeyword = classOrStructKeyword;
    }

    /// <summary>Gets the constraint keyword ("class" or "struct").</summary>
    public SyntaxToken ClassOrStructKeyword { get { return this.classOrStructKeyword; } }

    internal override GreenNode GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.classOrStructKeyword;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode parent, int position)
    {
      return new CSharp.Syntax.ClassOrStructConstraintSyntax(this, parent, position);
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitClassOrStructConstraint(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitClassOrStructConstraint(this);
    }

    public ClassOrStructConstraintSyntax Update(SyntaxToken classOrStructKeyword)
    {
        if (classOrStructKeyword != this.ClassOrStructKeyword)
        {
            var newNode = SyntaxFactory.ClassOrStructConstraint(this.Kind, classOrStructKeyword);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
    {
         return new ClassOrStructConstraintSyntax(this.Kind, this.classOrStructKeyword, diagnostics, GetAnnotations());
    }

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
    {
         return new ClassOrStructConstraintSyntax(this.Kind, this.classOrStructKeyword, GetDiagnostics(), annotations);
    }

    internal ClassOrStructConstraintSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 1;
      var classOrStructKeyword = (SyntaxToken)reader.ReadValue();
      if (classOrStructKeyword != null)
      {
         AdjustFlagsAndWidth(classOrStructKeyword);
         this.classOrStructKeyword = classOrStructKeyword;
      }
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.classOrStructKeyword);
    }

    static ClassOrStructConstraintSyntax()
    {
       ObjectBinder.RegisterTypeReader(typeof(ClassOrStructConstraintSyntax), r => new ClassOrStructConstraintSyntax(r));
    }
  }

  /// <summary>Type constraint syntax.</summary>
  internal sealed partial class TypeConstraintSyntax : TypeParameterConstraintSyntax
  {
    internal readonly TypeSyntax type;

    internal TypeConstraintSyntax(SyntaxKind kind, TypeSyntax type, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 1;
        this.AdjustFlagsAndWidth(type);
        this.type = type;
    }


    internal TypeConstraintSyntax(SyntaxKind kind, TypeSyntax type, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 1;
        this.AdjustFlagsAndWidth(type);
        this.type = type;
    }


    internal TypeConstraintSyntax(SyntaxKind kind, TypeSyntax type)
        : base(kind)
    {
        this.SlotCount = 1;
        this.AdjustFlagsAndWidth(type);
        this.type = type;
    }

    /// <summary>Gets the type syntax.</summary>
    public TypeSyntax Type { get { return this.type; } }

    internal override GreenNode GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.type;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode parent, int position)
    {
      return new CSharp.Syntax.TypeConstraintSyntax(this, parent, position);
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitTypeConstraint(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitTypeConstraint(this);
    }

    public TypeConstraintSyntax Update(TypeSyntax type)
    {
        if (type != this.Type)
        {
            var newNode = SyntaxFactory.TypeConstraint(type);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
    {
         return new TypeConstraintSyntax(this.Kind, this.type, diagnostics, GetAnnotations());
    }

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
    {
         return new TypeConstraintSyntax(this.Kind, this.type, GetDiagnostics(), annotations);
    }

    internal TypeConstraintSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 1;
      var type = (TypeSyntax)reader.ReadValue();
      if (type != null)
      {
         AdjustFlagsAndWidth(type);
         this.type = type;
      }
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.type);
    }

    static TypeConstraintSyntax()
    {
       ObjectBinder.RegisterTypeReader(typeof(TypeConstraintSyntax), r => new TypeConstraintSyntax(r));
    }
  }

  internal abstract partial class BaseFieldDeclarationSyntax : MemberDeclarationSyntax
  {
    internal BaseFieldDeclarationSyntax(SyntaxKind kind, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
      : base(kind, diagnostics, annotations)
    {
    }
    internal BaseFieldDeclarationSyntax(SyntaxKind kind)
      : base(kind)
    {
    }

    protected BaseFieldDeclarationSyntax(ObjectReader reader)
       : base(reader)
    {
    }

    /// <summary>Gets the attribute declaration list.</summary>
    public abstract Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<AttributeListSyntax> AttributeLists { get; }

    /// <summary>Gets the modifier list.</summary>
    public abstract Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SyntaxToken> Modifiers { get; }

    public abstract VariableDeclarationSyntax Declaration { get; }

    public abstract SyntaxToken SemicolonToken { get; }
  }

  internal sealed partial class FieldDeclarationSyntax : BaseFieldDeclarationSyntax
  {
    internal readonly GreenNode attributeLists;
    internal readonly GreenNode modifiers;
    internal readonly VariableDeclarationSyntax declaration;
    internal readonly SyntaxToken semicolonToken;

    internal FieldDeclarationSyntax(SyntaxKind kind, GreenNode attributeLists, GreenNode modifiers, VariableDeclarationSyntax declaration, SyntaxToken semicolonToken, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 4;
        if (attributeLists != null)
        {
            this.AdjustFlagsAndWidth(attributeLists);
            this.attributeLists = attributeLists;
        }
        if (modifiers != null)
        {
            this.AdjustFlagsAndWidth(modifiers);
            this.modifiers = modifiers;
        }
        this.AdjustFlagsAndWidth(declaration);
        this.declaration = declaration;
        this.AdjustFlagsAndWidth(semicolonToken);
        this.semicolonToken = semicolonToken;
    }


    internal FieldDeclarationSyntax(SyntaxKind kind, GreenNode attributeLists, GreenNode modifiers, VariableDeclarationSyntax declaration, SyntaxToken semicolonToken, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 4;
        if (attributeLists != null)
        {
            this.AdjustFlagsAndWidth(attributeLists);
            this.attributeLists = attributeLists;
        }
        if (modifiers != null)
        {
            this.AdjustFlagsAndWidth(modifiers);
            this.modifiers = modifiers;
        }
        this.AdjustFlagsAndWidth(declaration);
        this.declaration = declaration;
        this.AdjustFlagsAndWidth(semicolonToken);
        this.semicolonToken = semicolonToken;
    }


    internal FieldDeclarationSyntax(SyntaxKind kind, GreenNode attributeLists, GreenNode modifiers, VariableDeclarationSyntax declaration, SyntaxToken semicolonToken)
        : base(kind)
    {
        this.SlotCount = 4;
        if (attributeLists != null)
        {
            this.AdjustFlagsAndWidth(attributeLists);
            this.attributeLists = attributeLists;
        }
        if (modifiers != null)
        {
            this.AdjustFlagsAndWidth(modifiers);
            this.modifiers = modifiers;
        }
        this.AdjustFlagsAndWidth(declaration);
        this.declaration = declaration;
        this.AdjustFlagsAndWidth(semicolonToken);
        this.semicolonToken = semicolonToken;
    }

    /// <summary>Gets the attribute declaration list.</summary>
    public override Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<AttributeListSyntax> AttributeLists { get { return new Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<AttributeListSyntax>(this.attributeLists); } }
    /// <summary>Gets the modifier list.</summary>
    public override Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SyntaxToken> Modifiers { get { return new Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SyntaxToken>(this.modifiers); } }
    public override VariableDeclarationSyntax Declaration { get { return this.declaration; } }
    public override SyntaxToken SemicolonToken { get { return this.semicolonToken; } }

    internal override GreenNode GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.attributeLists;
            case 1: return this.modifiers;
            case 2: return this.declaration;
            case 3: return this.semicolonToken;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode parent, int position)
    {
      return new CSharp.Syntax.FieldDeclarationSyntax(this, parent, position);
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitFieldDeclaration(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitFieldDeclaration(this);
    }

    public FieldDeclarationSyntax Update(Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<AttributeListSyntax> attributeLists, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SyntaxToken> modifiers, VariableDeclarationSyntax declaration, SyntaxToken semicolonToken)
    {
        if (attributeLists != this.AttributeLists || modifiers != this.Modifiers || declaration != this.Declaration || semicolonToken != this.SemicolonToken)
        {
            var newNode = SyntaxFactory.FieldDeclaration(attributeLists, modifiers, declaration, semicolonToken);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
    {
         return new FieldDeclarationSyntax(this.Kind, this.attributeLists, this.modifiers, this.declaration, this.semicolonToken, diagnostics, GetAnnotations());
    }

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
    {
         return new FieldDeclarationSyntax(this.Kind, this.attributeLists, this.modifiers, this.declaration, this.semicolonToken, GetDiagnostics(), annotations);
    }

    internal FieldDeclarationSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 4;
      var attributeLists = (GreenNode)reader.ReadValue();
      if (attributeLists != null)
      {
         AdjustFlagsAndWidth(attributeLists);
         this.attributeLists = attributeLists;
      }
      var modifiers = (GreenNode)reader.ReadValue();
      if (modifiers != null)
      {
         AdjustFlagsAndWidth(modifiers);
         this.modifiers = modifiers;
      }
      var declaration = (VariableDeclarationSyntax)reader.ReadValue();
      if (declaration != null)
      {
         AdjustFlagsAndWidth(declaration);
         this.declaration = declaration;
      }
      var semicolonToken = (SyntaxToken)reader.ReadValue();
      if (semicolonToken != null)
      {
         AdjustFlagsAndWidth(semicolonToken);
         this.semicolonToken = semicolonToken;
      }
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.attributeLists);
      writer.WriteValue(this.modifiers);
      writer.WriteValue(this.declaration);
      writer.WriteValue(this.semicolonToken);
    }

    static FieldDeclarationSyntax()
    {
       ObjectBinder.RegisterTypeReader(typeof(FieldDeclarationSyntax), r => new FieldDeclarationSyntax(r));
    }
  }

  internal sealed partial class EventFieldDeclarationSyntax : BaseFieldDeclarationSyntax
  {
    internal readonly GreenNode attributeLists;
    internal readonly GreenNode modifiers;
    internal readonly SyntaxToken eventKeyword;
    internal readonly VariableDeclarationSyntax declaration;
    internal readonly SyntaxToken semicolonToken;

    internal EventFieldDeclarationSyntax(SyntaxKind kind, GreenNode attributeLists, GreenNode modifiers, SyntaxToken eventKeyword, VariableDeclarationSyntax declaration, SyntaxToken semicolonToken, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 5;
        if (attributeLists != null)
        {
            this.AdjustFlagsAndWidth(attributeLists);
            this.attributeLists = attributeLists;
        }
        if (modifiers != null)
        {
            this.AdjustFlagsAndWidth(modifiers);
            this.modifiers = modifiers;
        }
        this.AdjustFlagsAndWidth(eventKeyword);
        this.eventKeyword = eventKeyword;
        this.AdjustFlagsAndWidth(declaration);
        this.declaration = declaration;
        this.AdjustFlagsAndWidth(semicolonToken);
        this.semicolonToken = semicolonToken;
    }


    internal EventFieldDeclarationSyntax(SyntaxKind kind, GreenNode attributeLists, GreenNode modifiers, SyntaxToken eventKeyword, VariableDeclarationSyntax declaration, SyntaxToken semicolonToken, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 5;
        if (attributeLists != null)
        {
            this.AdjustFlagsAndWidth(attributeLists);
            this.attributeLists = attributeLists;
        }
        if (modifiers != null)
        {
            this.AdjustFlagsAndWidth(modifiers);
            this.modifiers = modifiers;
        }
        this.AdjustFlagsAndWidth(eventKeyword);
        this.eventKeyword = eventKeyword;
        this.AdjustFlagsAndWidth(declaration);
        this.declaration = declaration;
        this.AdjustFlagsAndWidth(semicolonToken);
        this.semicolonToken = semicolonToken;
    }


    internal EventFieldDeclarationSyntax(SyntaxKind kind, GreenNode attributeLists, GreenNode modifiers, SyntaxToken eventKeyword, VariableDeclarationSyntax declaration, SyntaxToken semicolonToken)
        : base(kind)
    {
        this.SlotCount = 5;
        if (attributeLists != null)
        {
            this.AdjustFlagsAndWidth(attributeLists);
            this.attributeLists = attributeLists;
        }
        if (modifiers != null)
        {
            this.AdjustFlagsAndWidth(modifiers);
            this.modifiers = modifiers;
        }
        this.AdjustFlagsAndWidth(eventKeyword);
        this.eventKeyword = eventKeyword;
        this.AdjustFlagsAndWidth(declaration);
        this.declaration = declaration;
        this.AdjustFlagsAndWidth(semicolonToken);
        this.semicolonToken = semicolonToken;
    }

    /// <summary>Gets the attribute declaration list.</summary>
    public override Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<AttributeListSyntax> AttributeLists { get { return new Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<AttributeListSyntax>(this.attributeLists); } }
    /// <summary>Gets the modifier list.</summary>
    public override Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SyntaxToken> Modifiers { get { return new Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SyntaxToken>(this.modifiers); } }
    public SyntaxToken EventKeyword { get { return this.eventKeyword; } }
    public override VariableDeclarationSyntax Declaration { get { return this.declaration; } }
    public override SyntaxToken SemicolonToken { get { return this.semicolonToken; } }

    internal override GreenNode GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.attributeLists;
            case 1: return this.modifiers;
            case 2: return this.eventKeyword;
            case 3: return this.declaration;
            case 4: return this.semicolonToken;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode parent, int position)
    {
      return new CSharp.Syntax.EventFieldDeclarationSyntax(this, parent, position);
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitEventFieldDeclaration(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitEventFieldDeclaration(this);
    }

    public EventFieldDeclarationSyntax Update(Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<AttributeListSyntax> attributeLists, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SyntaxToken> modifiers, SyntaxToken eventKeyword, VariableDeclarationSyntax declaration, SyntaxToken semicolonToken)
    {
        if (attributeLists != this.AttributeLists || modifiers != this.Modifiers || eventKeyword != this.EventKeyword || declaration != this.Declaration || semicolonToken != this.SemicolonToken)
        {
            var newNode = SyntaxFactory.EventFieldDeclaration(attributeLists, modifiers, eventKeyword, declaration, semicolonToken);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
    {
         return new EventFieldDeclarationSyntax(this.Kind, this.attributeLists, this.modifiers, this.eventKeyword, this.declaration, this.semicolonToken, diagnostics, GetAnnotations());
    }

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
    {
         return new EventFieldDeclarationSyntax(this.Kind, this.attributeLists, this.modifiers, this.eventKeyword, this.declaration, this.semicolonToken, GetDiagnostics(), annotations);
    }

    internal EventFieldDeclarationSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 5;
      var attributeLists = (GreenNode)reader.ReadValue();
      if (attributeLists != null)
      {
         AdjustFlagsAndWidth(attributeLists);
         this.attributeLists = attributeLists;
      }
      var modifiers = (GreenNode)reader.ReadValue();
      if (modifiers != null)
      {
         AdjustFlagsAndWidth(modifiers);
         this.modifiers = modifiers;
      }
      var eventKeyword = (SyntaxToken)reader.ReadValue();
      if (eventKeyword != null)
      {
         AdjustFlagsAndWidth(eventKeyword);
         this.eventKeyword = eventKeyword;
      }
      var declaration = (VariableDeclarationSyntax)reader.ReadValue();
      if (declaration != null)
      {
         AdjustFlagsAndWidth(declaration);
         this.declaration = declaration;
      }
      var semicolonToken = (SyntaxToken)reader.ReadValue();
      if (semicolonToken != null)
      {
         AdjustFlagsAndWidth(semicolonToken);
         this.semicolonToken = semicolonToken;
      }
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.attributeLists);
      writer.WriteValue(this.modifiers);
      writer.WriteValue(this.eventKeyword);
      writer.WriteValue(this.declaration);
      writer.WriteValue(this.semicolonToken);
    }

    static EventFieldDeclarationSyntax()
    {
       ObjectBinder.RegisterTypeReader(typeof(EventFieldDeclarationSyntax), r => new EventFieldDeclarationSyntax(r));
    }
  }

  internal sealed partial class ExplicitInterfaceSpecifierSyntax : CSharpSyntaxNode
  {
    internal readonly NameSyntax name;
    internal readonly SyntaxToken dotToken;

    internal ExplicitInterfaceSpecifierSyntax(SyntaxKind kind, NameSyntax name, SyntaxToken dotToken, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 2;
        this.AdjustFlagsAndWidth(name);
        this.name = name;
        this.AdjustFlagsAndWidth(dotToken);
        this.dotToken = dotToken;
    }


    internal ExplicitInterfaceSpecifierSyntax(SyntaxKind kind, NameSyntax name, SyntaxToken dotToken, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 2;
        this.AdjustFlagsAndWidth(name);
        this.name = name;
        this.AdjustFlagsAndWidth(dotToken);
        this.dotToken = dotToken;
    }


    internal ExplicitInterfaceSpecifierSyntax(SyntaxKind kind, NameSyntax name, SyntaxToken dotToken)
        : base(kind)
    {
        this.SlotCount = 2;
        this.AdjustFlagsAndWidth(name);
        this.name = name;
        this.AdjustFlagsAndWidth(dotToken);
        this.dotToken = dotToken;
    }

    public NameSyntax Name { get { return this.name; } }
    public SyntaxToken DotToken { get { return this.dotToken; } }

    internal override GreenNode GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.name;
            case 1: return this.dotToken;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode parent, int position)
    {
      return new CSharp.Syntax.ExplicitInterfaceSpecifierSyntax(this, parent, position);
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitExplicitInterfaceSpecifier(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitExplicitInterfaceSpecifier(this);
    }

    public ExplicitInterfaceSpecifierSyntax Update(NameSyntax name, SyntaxToken dotToken)
    {
        if (name != this.Name || dotToken != this.DotToken)
        {
            var newNode = SyntaxFactory.ExplicitInterfaceSpecifier(name, dotToken);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
    {
         return new ExplicitInterfaceSpecifierSyntax(this.Kind, this.name, this.dotToken, diagnostics, GetAnnotations());
    }

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
    {
         return new ExplicitInterfaceSpecifierSyntax(this.Kind, this.name, this.dotToken, GetDiagnostics(), annotations);
    }

    internal ExplicitInterfaceSpecifierSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 2;
      var name = (NameSyntax)reader.ReadValue();
      if (name != null)
      {
         AdjustFlagsAndWidth(name);
         this.name = name;
      }
      var dotToken = (SyntaxToken)reader.ReadValue();
      if (dotToken != null)
      {
         AdjustFlagsAndWidth(dotToken);
         this.dotToken = dotToken;
      }
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.name);
      writer.WriteValue(this.dotToken);
    }

    static ExplicitInterfaceSpecifierSyntax()
    {
       ObjectBinder.RegisterTypeReader(typeof(ExplicitInterfaceSpecifierSyntax), r => new ExplicitInterfaceSpecifierSyntax(r));
    }
  }

  /// <summary>Base type for method declaration syntax.</summary>
  internal abstract partial class BaseMethodDeclarationSyntax : MemberDeclarationSyntax
  {
    internal BaseMethodDeclarationSyntax(SyntaxKind kind, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
      : base(kind, diagnostics, annotations)
    {
    }
    internal BaseMethodDeclarationSyntax(SyntaxKind kind)
      : base(kind)
    {
    }

    protected BaseMethodDeclarationSyntax(ObjectReader reader)
       : base(reader)
    {
    }

    /// <summary>Gets the attribute declaration list.</summary>
    public abstract Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<AttributeListSyntax> AttributeLists { get; }

    /// <summary>Gets the modifier list.</summary>
    public abstract Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SyntaxToken> Modifiers { get; }

    /// <summary>Gets the parameter list.</summary>
    public abstract ParameterListSyntax ParameterList { get; }

    public abstract BlockSyntax Body { get; }

    public abstract ArrowExpressionClauseSyntax ExpressionBody { get; }

    /// <summary>Gets the optional semicolon token.</summary>
    public abstract SyntaxToken SemicolonToken { get; }
  }

  /// <summary>Method declaration syntax.</summary>
  internal sealed partial class MethodDeclarationSyntax : BaseMethodDeclarationSyntax
  {
    internal readonly GreenNode attributeLists;
    internal readonly GreenNode modifiers;
    internal readonly TypeSyntax returnType;
    internal readonly ExplicitInterfaceSpecifierSyntax explicitInterfaceSpecifier;
    internal readonly SyntaxToken identifier;
    internal readonly TypeParameterListSyntax typeParameterList;
    internal readonly ParameterListSyntax parameterList;
    internal readonly GreenNode constraintClauses;
    internal readonly BlockSyntax body;
    internal readonly ArrowExpressionClauseSyntax expressionBody;
    internal readonly SyntaxToken semicolonToken;

    internal MethodDeclarationSyntax(SyntaxKind kind, GreenNode attributeLists, GreenNode modifiers, TypeSyntax returnType, ExplicitInterfaceSpecifierSyntax explicitInterfaceSpecifier, SyntaxToken identifier, TypeParameterListSyntax typeParameterList, ParameterListSyntax parameterList, GreenNode constraintClauses, BlockSyntax body, ArrowExpressionClauseSyntax expressionBody, SyntaxToken semicolonToken, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 11;
        if (attributeLists != null)
        {
            this.AdjustFlagsAndWidth(attributeLists);
            this.attributeLists = attributeLists;
        }
        if (modifiers != null)
        {
            this.AdjustFlagsAndWidth(modifiers);
            this.modifiers = modifiers;
        }
        this.AdjustFlagsAndWidth(returnType);
        this.returnType = returnType;
        if (explicitInterfaceSpecifier != null)
        {
            this.AdjustFlagsAndWidth(explicitInterfaceSpecifier);
            this.explicitInterfaceSpecifier = explicitInterfaceSpecifier;
        }
        this.AdjustFlagsAndWidth(identifier);
        this.identifier = identifier;
        if (typeParameterList != null)
        {
            this.AdjustFlagsAndWidth(typeParameterList);
            this.typeParameterList = typeParameterList;
        }
        this.AdjustFlagsAndWidth(parameterList);
        this.parameterList = parameterList;
        if (constraintClauses != null)
        {
            this.AdjustFlagsAndWidth(constraintClauses);
            this.constraintClauses = constraintClauses;
        }
        if (body != null)
        {
            this.AdjustFlagsAndWidth(body);
            this.body = body;
        }
        if (expressionBody != null)
        {
            this.AdjustFlagsAndWidth(expressionBody);
            this.expressionBody = expressionBody;
        }
        if (semicolonToken != null)
        {
            this.AdjustFlagsAndWidth(semicolonToken);
            this.semicolonToken = semicolonToken;
        }
    }


    internal MethodDeclarationSyntax(SyntaxKind kind, GreenNode attributeLists, GreenNode modifiers, TypeSyntax returnType, ExplicitInterfaceSpecifierSyntax explicitInterfaceSpecifier, SyntaxToken identifier, TypeParameterListSyntax typeParameterList, ParameterListSyntax parameterList, GreenNode constraintClauses, BlockSyntax body, ArrowExpressionClauseSyntax expressionBody, SyntaxToken semicolonToken, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 11;
        if (attributeLists != null)
        {
            this.AdjustFlagsAndWidth(attributeLists);
            this.attributeLists = attributeLists;
        }
        if (modifiers != null)
        {
            this.AdjustFlagsAndWidth(modifiers);
            this.modifiers = modifiers;
        }
        this.AdjustFlagsAndWidth(returnType);
        this.returnType = returnType;
        if (explicitInterfaceSpecifier != null)
        {
            this.AdjustFlagsAndWidth(explicitInterfaceSpecifier);
            this.explicitInterfaceSpecifier = explicitInterfaceSpecifier;
        }
        this.AdjustFlagsAndWidth(identifier);
        this.identifier = identifier;
        if (typeParameterList != null)
        {
            this.AdjustFlagsAndWidth(typeParameterList);
            this.typeParameterList = typeParameterList;
        }
        this.AdjustFlagsAndWidth(parameterList);
        this.parameterList = parameterList;
        if (constraintClauses != null)
        {
            this.AdjustFlagsAndWidth(constraintClauses);
            this.constraintClauses = constraintClauses;
        }
        if (body != null)
        {
            this.AdjustFlagsAndWidth(body);
            this.body = body;
        }
        if (expressionBody != null)
        {
            this.AdjustFlagsAndWidth(expressionBody);
            this.expressionBody = expressionBody;
        }
        if (semicolonToken != null)
        {
            this.AdjustFlagsAndWidth(semicolonToken);
            this.semicolonToken = semicolonToken;
        }
    }


    internal MethodDeclarationSyntax(SyntaxKind kind, GreenNode attributeLists, GreenNode modifiers, TypeSyntax returnType, ExplicitInterfaceSpecifierSyntax explicitInterfaceSpecifier, SyntaxToken identifier, TypeParameterListSyntax typeParameterList, ParameterListSyntax parameterList, GreenNode constraintClauses, BlockSyntax body, ArrowExpressionClauseSyntax expressionBody, SyntaxToken semicolonToken)
        : base(kind)
    {
        this.SlotCount = 11;
        if (attributeLists != null)
        {
            this.AdjustFlagsAndWidth(attributeLists);
            this.attributeLists = attributeLists;
        }
        if (modifiers != null)
        {
            this.AdjustFlagsAndWidth(modifiers);
            this.modifiers = modifiers;
        }
        this.AdjustFlagsAndWidth(returnType);
        this.returnType = returnType;
        if (explicitInterfaceSpecifier != null)
        {
            this.AdjustFlagsAndWidth(explicitInterfaceSpecifier);
            this.explicitInterfaceSpecifier = explicitInterfaceSpecifier;
        }
        this.AdjustFlagsAndWidth(identifier);
        this.identifier = identifier;
        if (typeParameterList != null)
        {
            this.AdjustFlagsAndWidth(typeParameterList);
            this.typeParameterList = typeParameterList;
        }
        this.AdjustFlagsAndWidth(parameterList);
        this.parameterList = parameterList;
        if (constraintClauses != null)
        {
            this.AdjustFlagsAndWidth(constraintClauses);
            this.constraintClauses = constraintClauses;
        }
        if (body != null)
        {
            this.AdjustFlagsAndWidth(body);
            this.body = body;
        }
        if (expressionBody != null)
        {
            this.AdjustFlagsAndWidth(expressionBody);
            this.expressionBody = expressionBody;
        }
        if (semicolonToken != null)
        {
            this.AdjustFlagsAndWidth(semicolonToken);
            this.semicolonToken = semicolonToken;
        }
    }

    public override Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<AttributeListSyntax> AttributeLists { get { return new Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<AttributeListSyntax>(this.attributeLists); } }
    public override Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SyntaxToken> Modifiers { get { return new Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SyntaxToken>(this.modifiers); } }
    /// <summary>Gets the return type syntax.</summary>
    public TypeSyntax ReturnType { get { return this.returnType; } }
    public ExplicitInterfaceSpecifierSyntax ExplicitInterfaceSpecifier { get { return this.explicitInterfaceSpecifier; } }
    /// <summary>Gets the identifier.</summary>
    public SyntaxToken Identifier { get { return this.identifier; } }
    public TypeParameterListSyntax TypeParameterList { get { return this.typeParameterList; } }
    public override ParameterListSyntax ParameterList { get { return this.parameterList; } }
    /// <summary>Gets the constraint clause list.</summary>
    public Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<TypeParameterConstraintClauseSyntax> ConstraintClauses { get { return new Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<TypeParameterConstraintClauseSyntax>(this.constraintClauses); } }
    public override BlockSyntax Body { get { return this.body; } }
    public override ArrowExpressionClauseSyntax ExpressionBody { get { return this.expressionBody; } }
    /// <summary>Gets the optional semicolon token.</summary>
    public override SyntaxToken SemicolonToken { get { return this.semicolonToken; } }

    internal override GreenNode GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.attributeLists;
            case 1: return this.modifiers;
            case 2: return this.returnType;
            case 3: return this.explicitInterfaceSpecifier;
            case 4: return this.identifier;
            case 5: return this.typeParameterList;
            case 6: return this.parameterList;
            case 7: return this.constraintClauses;
            case 8: return this.body;
            case 9: return this.expressionBody;
            case 10: return this.semicolonToken;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode parent, int position)
    {
      return new CSharp.Syntax.MethodDeclarationSyntax(this, parent, position);
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitMethodDeclaration(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitMethodDeclaration(this);
    }

    public MethodDeclarationSyntax Update(Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<AttributeListSyntax> attributeLists, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SyntaxToken> modifiers, TypeSyntax returnType, ExplicitInterfaceSpecifierSyntax explicitInterfaceSpecifier, SyntaxToken identifier, TypeParameterListSyntax typeParameterList, ParameterListSyntax parameterList, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<TypeParameterConstraintClauseSyntax> constraintClauses, BlockSyntax body, ArrowExpressionClauseSyntax expressionBody, SyntaxToken semicolonToken)
    {
        if (attributeLists != this.AttributeLists || modifiers != this.Modifiers || returnType != this.ReturnType || explicitInterfaceSpecifier != this.ExplicitInterfaceSpecifier || identifier != this.Identifier || typeParameterList != this.TypeParameterList || parameterList != this.ParameterList || constraintClauses != this.ConstraintClauses || body != this.Body || expressionBody != this.ExpressionBody || semicolonToken != this.SemicolonToken)
        {
            var newNode = SyntaxFactory.MethodDeclaration(attributeLists, modifiers, returnType, explicitInterfaceSpecifier, identifier, typeParameterList, parameterList, constraintClauses, body, expressionBody, semicolonToken);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
    {
         return new MethodDeclarationSyntax(this.Kind, this.attributeLists, this.modifiers, this.returnType, this.explicitInterfaceSpecifier, this.identifier, this.typeParameterList, this.parameterList, this.constraintClauses, this.body, this.expressionBody, this.semicolonToken, diagnostics, GetAnnotations());
    }

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
    {
         return new MethodDeclarationSyntax(this.Kind, this.attributeLists, this.modifiers, this.returnType, this.explicitInterfaceSpecifier, this.identifier, this.typeParameterList, this.parameterList, this.constraintClauses, this.body, this.expressionBody, this.semicolonToken, GetDiagnostics(), annotations);
    }

    internal MethodDeclarationSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 11;
      var attributeLists = (GreenNode)reader.ReadValue();
      if (attributeLists != null)
      {
         AdjustFlagsAndWidth(attributeLists);
         this.attributeLists = attributeLists;
      }
      var modifiers = (GreenNode)reader.ReadValue();
      if (modifiers != null)
      {
         AdjustFlagsAndWidth(modifiers);
         this.modifiers = modifiers;
      }
      var returnType = (TypeSyntax)reader.ReadValue();
      if (returnType != null)
      {
         AdjustFlagsAndWidth(returnType);
         this.returnType = returnType;
      }
      var explicitInterfaceSpecifier = (ExplicitInterfaceSpecifierSyntax)reader.ReadValue();
      if (explicitInterfaceSpecifier != null)
      {
         AdjustFlagsAndWidth(explicitInterfaceSpecifier);
         this.explicitInterfaceSpecifier = explicitInterfaceSpecifier;
      }
      var identifier = (SyntaxToken)reader.ReadValue();
      if (identifier != null)
      {
         AdjustFlagsAndWidth(identifier);
         this.identifier = identifier;
      }
      var typeParameterList = (TypeParameterListSyntax)reader.ReadValue();
      if (typeParameterList != null)
      {
         AdjustFlagsAndWidth(typeParameterList);
         this.typeParameterList = typeParameterList;
      }
      var parameterList = (ParameterListSyntax)reader.ReadValue();
      if (parameterList != null)
      {
         AdjustFlagsAndWidth(parameterList);
         this.parameterList = parameterList;
      }
      var constraintClauses = (GreenNode)reader.ReadValue();
      if (constraintClauses != null)
      {
         AdjustFlagsAndWidth(constraintClauses);
         this.constraintClauses = constraintClauses;
      }
      var body = (BlockSyntax)reader.ReadValue();
      if (body != null)
      {
         AdjustFlagsAndWidth(body);
         this.body = body;
      }
      var expressionBody = (ArrowExpressionClauseSyntax)reader.ReadValue();
      if (expressionBody != null)
      {
         AdjustFlagsAndWidth(expressionBody);
         this.expressionBody = expressionBody;
      }
      var semicolonToken = (SyntaxToken)reader.ReadValue();
      if (semicolonToken != null)
      {
         AdjustFlagsAndWidth(semicolonToken);
         this.semicolonToken = semicolonToken;
      }
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.attributeLists);
      writer.WriteValue(this.modifiers);
      writer.WriteValue(this.returnType);
      writer.WriteValue(this.explicitInterfaceSpecifier);
      writer.WriteValue(this.identifier);
      writer.WriteValue(this.typeParameterList);
      writer.WriteValue(this.parameterList);
      writer.WriteValue(this.constraintClauses);
      writer.WriteValue(this.body);
      writer.WriteValue(this.expressionBody);
      writer.WriteValue(this.semicolonToken);
    }

    static MethodDeclarationSyntax()
    {
       ObjectBinder.RegisterTypeReader(typeof(MethodDeclarationSyntax), r => new MethodDeclarationSyntax(r));
    }
  }

  /// <summary>Operator declaration syntax.</summary>
  internal sealed partial class OperatorDeclarationSyntax : BaseMethodDeclarationSyntax
  {
    internal readonly GreenNode attributeLists;
    internal readonly GreenNode modifiers;
    internal readonly TypeSyntax returnType;
    internal readonly SyntaxToken operatorKeyword;
    internal readonly SyntaxToken operatorToken;
    internal readonly ParameterListSyntax parameterList;
    internal readonly BlockSyntax body;
    internal readonly ArrowExpressionClauseSyntax expressionBody;
    internal readonly SyntaxToken semicolonToken;

    internal OperatorDeclarationSyntax(SyntaxKind kind, GreenNode attributeLists, GreenNode modifiers, TypeSyntax returnType, SyntaxToken operatorKeyword, SyntaxToken operatorToken, ParameterListSyntax parameterList, BlockSyntax body, ArrowExpressionClauseSyntax expressionBody, SyntaxToken semicolonToken, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 9;
        if (attributeLists != null)
        {
            this.AdjustFlagsAndWidth(attributeLists);
            this.attributeLists = attributeLists;
        }
        if (modifiers != null)
        {
            this.AdjustFlagsAndWidth(modifiers);
            this.modifiers = modifiers;
        }
        this.AdjustFlagsAndWidth(returnType);
        this.returnType = returnType;
        this.AdjustFlagsAndWidth(operatorKeyword);
        this.operatorKeyword = operatorKeyword;
        this.AdjustFlagsAndWidth(operatorToken);
        this.operatorToken = operatorToken;
        this.AdjustFlagsAndWidth(parameterList);
        this.parameterList = parameterList;
        if (body != null)
        {
            this.AdjustFlagsAndWidth(body);
            this.body = body;
        }
        if (expressionBody != null)
        {
            this.AdjustFlagsAndWidth(expressionBody);
            this.expressionBody = expressionBody;
        }
        if (semicolonToken != null)
        {
            this.AdjustFlagsAndWidth(semicolonToken);
            this.semicolonToken = semicolonToken;
        }
    }


    internal OperatorDeclarationSyntax(SyntaxKind kind, GreenNode attributeLists, GreenNode modifiers, TypeSyntax returnType, SyntaxToken operatorKeyword, SyntaxToken operatorToken, ParameterListSyntax parameterList, BlockSyntax body, ArrowExpressionClauseSyntax expressionBody, SyntaxToken semicolonToken, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 9;
        if (attributeLists != null)
        {
            this.AdjustFlagsAndWidth(attributeLists);
            this.attributeLists = attributeLists;
        }
        if (modifiers != null)
        {
            this.AdjustFlagsAndWidth(modifiers);
            this.modifiers = modifiers;
        }
        this.AdjustFlagsAndWidth(returnType);
        this.returnType = returnType;
        this.AdjustFlagsAndWidth(operatorKeyword);
        this.operatorKeyword = operatorKeyword;
        this.AdjustFlagsAndWidth(operatorToken);
        this.operatorToken = operatorToken;
        this.AdjustFlagsAndWidth(parameterList);
        this.parameterList = parameterList;
        if (body != null)
        {
            this.AdjustFlagsAndWidth(body);
            this.body = body;
        }
        if (expressionBody != null)
        {
            this.AdjustFlagsAndWidth(expressionBody);
            this.expressionBody = expressionBody;
        }
        if (semicolonToken != null)
        {
            this.AdjustFlagsAndWidth(semicolonToken);
            this.semicolonToken = semicolonToken;
        }
    }


    internal OperatorDeclarationSyntax(SyntaxKind kind, GreenNode attributeLists, GreenNode modifiers, TypeSyntax returnType, SyntaxToken operatorKeyword, SyntaxToken operatorToken, ParameterListSyntax parameterList, BlockSyntax body, ArrowExpressionClauseSyntax expressionBody, SyntaxToken semicolonToken)
        : base(kind)
    {
        this.SlotCount = 9;
        if (attributeLists != null)
        {
            this.AdjustFlagsAndWidth(attributeLists);
            this.attributeLists = attributeLists;
        }
        if (modifiers != null)
        {
            this.AdjustFlagsAndWidth(modifiers);
            this.modifiers = modifiers;
        }
        this.AdjustFlagsAndWidth(returnType);
        this.returnType = returnType;
        this.AdjustFlagsAndWidth(operatorKeyword);
        this.operatorKeyword = operatorKeyword;
        this.AdjustFlagsAndWidth(operatorToken);
        this.operatorToken = operatorToken;
        this.AdjustFlagsAndWidth(parameterList);
        this.parameterList = parameterList;
        if (body != null)
        {
            this.AdjustFlagsAndWidth(body);
            this.body = body;
        }
        if (expressionBody != null)
        {
            this.AdjustFlagsAndWidth(expressionBody);
            this.expressionBody = expressionBody;
        }
        if (semicolonToken != null)
        {
            this.AdjustFlagsAndWidth(semicolonToken);
            this.semicolonToken = semicolonToken;
        }
    }

    public override Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<AttributeListSyntax> AttributeLists { get { return new Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<AttributeListSyntax>(this.attributeLists); } }
    public override Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SyntaxToken> Modifiers { get { return new Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SyntaxToken>(this.modifiers); } }
    /// <summary>Gets the return type.</summary>
    public TypeSyntax ReturnType { get { return this.returnType; } }
    /// <summary>Gets the "operator" keyword.</summary>
    public SyntaxToken OperatorKeyword { get { return this.operatorKeyword; } }
    /// <summary>Gets the operator token.</summary>
    public SyntaxToken OperatorToken { get { return this.operatorToken; } }
    public override ParameterListSyntax ParameterList { get { return this.parameterList; } }
    public override BlockSyntax Body { get { return this.body; } }
    public override ArrowExpressionClauseSyntax ExpressionBody { get { return this.expressionBody; } }
    public override SyntaxToken SemicolonToken { get { return this.semicolonToken; } }

    internal override GreenNode GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.attributeLists;
            case 1: return this.modifiers;
            case 2: return this.returnType;
            case 3: return this.operatorKeyword;
            case 4: return this.operatorToken;
            case 5: return this.parameterList;
            case 6: return this.body;
            case 7: return this.expressionBody;
            case 8: return this.semicolonToken;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode parent, int position)
    {
      return new CSharp.Syntax.OperatorDeclarationSyntax(this, parent, position);
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitOperatorDeclaration(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitOperatorDeclaration(this);
    }

    public OperatorDeclarationSyntax Update(Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<AttributeListSyntax> attributeLists, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SyntaxToken> modifiers, TypeSyntax returnType, SyntaxToken operatorKeyword, SyntaxToken operatorToken, ParameterListSyntax parameterList, BlockSyntax body, ArrowExpressionClauseSyntax expressionBody, SyntaxToken semicolonToken)
    {
        if (attributeLists != this.AttributeLists || modifiers != this.Modifiers || returnType != this.ReturnType || operatorKeyword != this.OperatorKeyword || operatorToken != this.OperatorToken || parameterList != this.ParameterList || body != this.Body || expressionBody != this.ExpressionBody || semicolonToken != this.SemicolonToken)
        {
            var newNode = SyntaxFactory.OperatorDeclaration(attributeLists, modifiers, returnType, operatorKeyword, operatorToken, parameterList, body, expressionBody, semicolonToken);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
    {
         return new OperatorDeclarationSyntax(this.Kind, this.attributeLists, this.modifiers, this.returnType, this.operatorKeyword, this.operatorToken, this.parameterList, this.body, this.expressionBody, this.semicolonToken, diagnostics, GetAnnotations());
    }

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
    {
         return new OperatorDeclarationSyntax(this.Kind, this.attributeLists, this.modifiers, this.returnType, this.operatorKeyword, this.operatorToken, this.parameterList, this.body, this.expressionBody, this.semicolonToken, GetDiagnostics(), annotations);
    }

    internal OperatorDeclarationSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 9;
      var attributeLists = (GreenNode)reader.ReadValue();
      if (attributeLists != null)
      {
         AdjustFlagsAndWidth(attributeLists);
         this.attributeLists = attributeLists;
      }
      var modifiers = (GreenNode)reader.ReadValue();
      if (modifiers != null)
      {
         AdjustFlagsAndWidth(modifiers);
         this.modifiers = modifiers;
      }
      var returnType = (TypeSyntax)reader.ReadValue();
      if (returnType != null)
      {
         AdjustFlagsAndWidth(returnType);
         this.returnType = returnType;
      }
      var operatorKeyword = (SyntaxToken)reader.ReadValue();
      if (operatorKeyword != null)
      {
         AdjustFlagsAndWidth(operatorKeyword);
         this.operatorKeyword = operatorKeyword;
      }
      var operatorToken = (SyntaxToken)reader.ReadValue();
      if (operatorToken != null)
      {
         AdjustFlagsAndWidth(operatorToken);
         this.operatorToken = operatorToken;
      }
      var parameterList = (ParameterListSyntax)reader.ReadValue();
      if (parameterList != null)
      {
         AdjustFlagsAndWidth(parameterList);
         this.parameterList = parameterList;
      }
      var body = (BlockSyntax)reader.ReadValue();
      if (body != null)
      {
         AdjustFlagsAndWidth(body);
         this.body = body;
      }
      var expressionBody = (ArrowExpressionClauseSyntax)reader.ReadValue();
      if (expressionBody != null)
      {
         AdjustFlagsAndWidth(expressionBody);
         this.expressionBody = expressionBody;
      }
      var semicolonToken = (SyntaxToken)reader.ReadValue();
      if (semicolonToken != null)
      {
         AdjustFlagsAndWidth(semicolonToken);
         this.semicolonToken = semicolonToken;
      }
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.attributeLists);
      writer.WriteValue(this.modifiers);
      writer.WriteValue(this.returnType);
      writer.WriteValue(this.operatorKeyword);
      writer.WriteValue(this.operatorToken);
      writer.WriteValue(this.parameterList);
      writer.WriteValue(this.body);
      writer.WriteValue(this.expressionBody);
      writer.WriteValue(this.semicolonToken);
    }

    static OperatorDeclarationSyntax()
    {
       ObjectBinder.RegisterTypeReader(typeof(OperatorDeclarationSyntax), r => new OperatorDeclarationSyntax(r));
    }
  }

  /// <summary>Conversion operator declaration syntax.</summary>
  internal sealed partial class ConversionOperatorDeclarationSyntax : BaseMethodDeclarationSyntax
  {
    internal readonly GreenNode attributeLists;
    internal readonly GreenNode modifiers;
    internal readonly SyntaxToken implicitOrExplicitKeyword;
    internal readonly SyntaxToken operatorKeyword;
    internal readonly TypeSyntax type;
    internal readonly ParameterListSyntax parameterList;
    internal readonly BlockSyntax body;
    internal readonly ArrowExpressionClauseSyntax expressionBody;
    internal readonly SyntaxToken semicolonToken;

    internal ConversionOperatorDeclarationSyntax(SyntaxKind kind, GreenNode attributeLists, GreenNode modifiers, SyntaxToken implicitOrExplicitKeyword, SyntaxToken operatorKeyword, TypeSyntax type, ParameterListSyntax parameterList, BlockSyntax body, ArrowExpressionClauseSyntax expressionBody, SyntaxToken semicolonToken, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 9;
        if (attributeLists != null)
        {
            this.AdjustFlagsAndWidth(attributeLists);
            this.attributeLists = attributeLists;
        }
        if (modifiers != null)
        {
            this.AdjustFlagsAndWidth(modifiers);
            this.modifiers = modifiers;
        }
        this.AdjustFlagsAndWidth(implicitOrExplicitKeyword);
        this.implicitOrExplicitKeyword = implicitOrExplicitKeyword;
        this.AdjustFlagsAndWidth(operatorKeyword);
        this.operatorKeyword = operatorKeyword;
        this.AdjustFlagsAndWidth(type);
        this.type = type;
        this.AdjustFlagsAndWidth(parameterList);
        this.parameterList = parameterList;
        if (body != null)
        {
            this.AdjustFlagsAndWidth(body);
            this.body = body;
        }
        if (expressionBody != null)
        {
            this.AdjustFlagsAndWidth(expressionBody);
            this.expressionBody = expressionBody;
        }
        if (semicolonToken != null)
        {
            this.AdjustFlagsAndWidth(semicolonToken);
            this.semicolonToken = semicolonToken;
        }
    }


    internal ConversionOperatorDeclarationSyntax(SyntaxKind kind, GreenNode attributeLists, GreenNode modifiers, SyntaxToken implicitOrExplicitKeyword, SyntaxToken operatorKeyword, TypeSyntax type, ParameterListSyntax parameterList, BlockSyntax body, ArrowExpressionClauseSyntax expressionBody, SyntaxToken semicolonToken, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 9;
        if (attributeLists != null)
        {
            this.AdjustFlagsAndWidth(attributeLists);
            this.attributeLists = attributeLists;
        }
        if (modifiers != null)
        {
            this.AdjustFlagsAndWidth(modifiers);
            this.modifiers = modifiers;
        }
        this.AdjustFlagsAndWidth(implicitOrExplicitKeyword);
        this.implicitOrExplicitKeyword = implicitOrExplicitKeyword;
        this.AdjustFlagsAndWidth(operatorKeyword);
        this.operatorKeyword = operatorKeyword;
        this.AdjustFlagsAndWidth(type);
        this.type = type;
        this.AdjustFlagsAndWidth(parameterList);
        this.parameterList = parameterList;
        if (body != null)
        {
            this.AdjustFlagsAndWidth(body);
            this.body = body;
        }
        if (expressionBody != null)
        {
            this.AdjustFlagsAndWidth(expressionBody);
            this.expressionBody = expressionBody;
        }
        if (semicolonToken != null)
        {
            this.AdjustFlagsAndWidth(semicolonToken);
            this.semicolonToken = semicolonToken;
        }
    }


    internal ConversionOperatorDeclarationSyntax(SyntaxKind kind, GreenNode attributeLists, GreenNode modifiers, SyntaxToken implicitOrExplicitKeyword, SyntaxToken operatorKeyword, TypeSyntax type, ParameterListSyntax parameterList, BlockSyntax body, ArrowExpressionClauseSyntax expressionBody, SyntaxToken semicolonToken)
        : base(kind)
    {
        this.SlotCount = 9;
        if (attributeLists != null)
        {
            this.AdjustFlagsAndWidth(attributeLists);
            this.attributeLists = attributeLists;
        }
        if (modifiers != null)
        {
            this.AdjustFlagsAndWidth(modifiers);
            this.modifiers = modifiers;
        }
        this.AdjustFlagsAndWidth(implicitOrExplicitKeyword);
        this.implicitOrExplicitKeyword = implicitOrExplicitKeyword;
        this.AdjustFlagsAndWidth(operatorKeyword);
        this.operatorKeyword = operatorKeyword;
        this.AdjustFlagsAndWidth(type);
        this.type = type;
        this.AdjustFlagsAndWidth(parameterList);
        this.parameterList = parameterList;
        if (body != null)
        {
            this.AdjustFlagsAndWidth(body);
            this.body = body;
        }
        if (expressionBody != null)
        {
            this.AdjustFlagsAndWidth(expressionBody);
            this.expressionBody = expressionBody;
        }
        if (semicolonToken != null)
        {
            this.AdjustFlagsAndWidth(semicolonToken);
            this.semicolonToken = semicolonToken;
        }
    }

    public override Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<AttributeListSyntax> AttributeLists { get { return new Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<AttributeListSyntax>(this.attributeLists); } }
    public override Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SyntaxToken> Modifiers { get { return new Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SyntaxToken>(this.modifiers); } }
    /// <summary>Gets the "implicit" or "explicit" token.</summary>
    public SyntaxToken ImplicitOrExplicitKeyword { get { return this.implicitOrExplicitKeyword; } }
    /// <summary>Gets the "operator" token.</summary>
    public SyntaxToken OperatorKeyword { get { return this.operatorKeyword; } }
    /// <summary>Gets the type.</summary>
    public TypeSyntax Type { get { return this.type; } }
    public override ParameterListSyntax ParameterList { get { return this.parameterList; } }
    public override BlockSyntax Body { get { return this.body; } }
    public override ArrowExpressionClauseSyntax ExpressionBody { get { return this.expressionBody; } }
    /// <summary>Gets the optional semicolon token.</summary>
    public override SyntaxToken SemicolonToken { get { return this.semicolonToken; } }

    internal override GreenNode GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.attributeLists;
            case 1: return this.modifiers;
            case 2: return this.implicitOrExplicitKeyword;
            case 3: return this.operatorKeyword;
            case 4: return this.type;
            case 5: return this.parameterList;
            case 6: return this.body;
            case 7: return this.expressionBody;
            case 8: return this.semicolonToken;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode parent, int position)
    {
      return new CSharp.Syntax.ConversionOperatorDeclarationSyntax(this, parent, position);
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitConversionOperatorDeclaration(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitConversionOperatorDeclaration(this);
    }

    public ConversionOperatorDeclarationSyntax Update(Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<AttributeListSyntax> attributeLists, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SyntaxToken> modifiers, SyntaxToken implicitOrExplicitKeyword, SyntaxToken operatorKeyword, TypeSyntax type, ParameterListSyntax parameterList, BlockSyntax body, ArrowExpressionClauseSyntax expressionBody, SyntaxToken semicolonToken)
    {
        if (attributeLists != this.AttributeLists || modifiers != this.Modifiers || implicitOrExplicitKeyword != this.ImplicitOrExplicitKeyword || operatorKeyword != this.OperatorKeyword || type != this.Type || parameterList != this.ParameterList || body != this.Body || expressionBody != this.ExpressionBody || semicolonToken != this.SemicolonToken)
        {
            var newNode = SyntaxFactory.ConversionOperatorDeclaration(attributeLists, modifiers, implicitOrExplicitKeyword, operatorKeyword, type, parameterList, body, expressionBody, semicolonToken);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
    {
         return new ConversionOperatorDeclarationSyntax(this.Kind, this.attributeLists, this.modifiers, this.implicitOrExplicitKeyword, this.operatorKeyword, this.type, this.parameterList, this.body, this.expressionBody, this.semicolonToken, diagnostics, GetAnnotations());
    }

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
    {
         return new ConversionOperatorDeclarationSyntax(this.Kind, this.attributeLists, this.modifiers, this.implicitOrExplicitKeyword, this.operatorKeyword, this.type, this.parameterList, this.body, this.expressionBody, this.semicolonToken, GetDiagnostics(), annotations);
    }

    internal ConversionOperatorDeclarationSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 9;
      var attributeLists = (GreenNode)reader.ReadValue();
      if (attributeLists != null)
      {
         AdjustFlagsAndWidth(attributeLists);
         this.attributeLists = attributeLists;
      }
      var modifiers = (GreenNode)reader.ReadValue();
      if (modifiers != null)
      {
         AdjustFlagsAndWidth(modifiers);
         this.modifiers = modifiers;
      }
      var implicitOrExplicitKeyword = (SyntaxToken)reader.ReadValue();
      if (implicitOrExplicitKeyword != null)
      {
         AdjustFlagsAndWidth(implicitOrExplicitKeyword);
         this.implicitOrExplicitKeyword = implicitOrExplicitKeyword;
      }
      var operatorKeyword = (SyntaxToken)reader.ReadValue();
      if (operatorKeyword != null)
      {
         AdjustFlagsAndWidth(operatorKeyword);
         this.operatorKeyword = operatorKeyword;
      }
      var type = (TypeSyntax)reader.ReadValue();
      if (type != null)
      {
         AdjustFlagsAndWidth(type);
         this.type = type;
      }
      var parameterList = (ParameterListSyntax)reader.ReadValue();
      if (parameterList != null)
      {
         AdjustFlagsAndWidth(parameterList);
         this.parameterList = parameterList;
      }
      var body = (BlockSyntax)reader.ReadValue();
      if (body != null)
      {
         AdjustFlagsAndWidth(body);
         this.body = body;
      }
      var expressionBody = (ArrowExpressionClauseSyntax)reader.ReadValue();
      if (expressionBody != null)
      {
         AdjustFlagsAndWidth(expressionBody);
         this.expressionBody = expressionBody;
      }
      var semicolonToken = (SyntaxToken)reader.ReadValue();
      if (semicolonToken != null)
      {
         AdjustFlagsAndWidth(semicolonToken);
         this.semicolonToken = semicolonToken;
      }
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.attributeLists);
      writer.WriteValue(this.modifiers);
      writer.WriteValue(this.implicitOrExplicitKeyword);
      writer.WriteValue(this.operatorKeyword);
      writer.WriteValue(this.type);
      writer.WriteValue(this.parameterList);
      writer.WriteValue(this.body);
      writer.WriteValue(this.expressionBody);
      writer.WriteValue(this.semicolonToken);
    }

    static ConversionOperatorDeclarationSyntax()
    {
       ObjectBinder.RegisterTypeReader(typeof(ConversionOperatorDeclarationSyntax), r => new ConversionOperatorDeclarationSyntax(r));
    }
  }

  /// <summary>Constructor declaration syntax.</summary>
  internal sealed partial class ConstructorDeclarationSyntax : BaseMethodDeclarationSyntax
  {
    internal readonly GreenNode attributeLists;
    internal readonly GreenNode modifiers;
    internal readonly SyntaxToken identifier;
    internal readonly ParameterListSyntax parameterList;
    internal readonly ConstructorInitializerSyntax initializer;
    internal readonly BlockSyntax body;
    internal readonly ArrowExpressionClauseSyntax expressionBody;
    internal readonly SyntaxToken semicolonToken;

    internal ConstructorDeclarationSyntax(SyntaxKind kind, GreenNode attributeLists, GreenNode modifiers, SyntaxToken identifier, ParameterListSyntax parameterList, ConstructorInitializerSyntax initializer, BlockSyntax body, ArrowExpressionClauseSyntax expressionBody, SyntaxToken semicolonToken, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 8;
        if (attributeLists != null)
        {
            this.AdjustFlagsAndWidth(attributeLists);
            this.attributeLists = attributeLists;
        }
        if (modifiers != null)
        {
            this.AdjustFlagsAndWidth(modifiers);
            this.modifiers = modifiers;
        }
        this.AdjustFlagsAndWidth(identifier);
        this.identifier = identifier;
        this.AdjustFlagsAndWidth(parameterList);
        this.parameterList = parameterList;
        if (initializer != null)
        {
            this.AdjustFlagsAndWidth(initializer);
            this.initializer = initializer;
        }
        if (body != null)
        {
            this.AdjustFlagsAndWidth(body);
            this.body = body;
        }
        if (expressionBody != null)
        {
            this.AdjustFlagsAndWidth(expressionBody);
            this.expressionBody = expressionBody;
        }
        if (semicolonToken != null)
        {
            this.AdjustFlagsAndWidth(semicolonToken);
            this.semicolonToken = semicolonToken;
        }
    }


    internal ConstructorDeclarationSyntax(SyntaxKind kind, GreenNode attributeLists, GreenNode modifiers, SyntaxToken identifier, ParameterListSyntax parameterList, ConstructorInitializerSyntax initializer, BlockSyntax body, ArrowExpressionClauseSyntax expressionBody, SyntaxToken semicolonToken, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 8;
        if (attributeLists != null)
        {
            this.AdjustFlagsAndWidth(attributeLists);
            this.attributeLists = attributeLists;
        }
        if (modifiers != null)
        {
            this.AdjustFlagsAndWidth(modifiers);
            this.modifiers = modifiers;
        }
        this.AdjustFlagsAndWidth(identifier);
        this.identifier = identifier;
        this.AdjustFlagsAndWidth(parameterList);
        this.parameterList = parameterList;
        if (initializer != null)
        {
            this.AdjustFlagsAndWidth(initializer);
            this.initializer = initializer;
        }
        if (body != null)
        {
            this.AdjustFlagsAndWidth(body);
            this.body = body;
        }
        if (expressionBody != null)
        {
            this.AdjustFlagsAndWidth(expressionBody);
            this.expressionBody = expressionBody;
        }
        if (semicolonToken != null)
        {
            this.AdjustFlagsAndWidth(semicolonToken);
            this.semicolonToken = semicolonToken;
        }
    }


    internal ConstructorDeclarationSyntax(SyntaxKind kind, GreenNode attributeLists, GreenNode modifiers, SyntaxToken identifier, ParameterListSyntax parameterList, ConstructorInitializerSyntax initializer, BlockSyntax body, ArrowExpressionClauseSyntax expressionBody, SyntaxToken semicolonToken)
        : base(kind)
    {
        this.SlotCount = 8;
        if (attributeLists != null)
        {
            this.AdjustFlagsAndWidth(attributeLists);
            this.attributeLists = attributeLists;
        }
        if (modifiers != null)
        {
            this.AdjustFlagsAndWidth(modifiers);
            this.modifiers = modifiers;
        }
        this.AdjustFlagsAndWidth(identifier);
        this.identifier = identifier;
        this.AdjustFlagsAndWidth(parameterList);
        this.parameterList = parameterList;
        if (initializer != null)
        {
            this.AdjustFlagsAndWidth(initializer);
            this.initializer = initializer;
        }
        if (body != null)
        {
            this.AdjustFlagsAndWidth(body);
            this.body = body;
        }
        if (expressionBody != null)
        {
            this.AdjustFlagsAndWidth(expressionBody);
            this.expressionBody = expressionBody;
        }
        if (semicolonToken != null)
        {
            this.AdjustFlagsAndWidth(semicolonToken);
            this.semicolonToken = semicolonToken;
        }
    }

    public override Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<AttributeListSyntax> AttributeLists { get { return new Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<AttributeListSyntax>(this.attributeLists); } }
    public override Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SyntaxToken> Modifiers { get { return new Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SyntaxToken>(this.modifiers); } }
    /// <summary>Gets the identifier.</summary>
    public SyntaxToken Identifier { get { return this.identifier; } }
    public override ParameterListSyntax ParameterList { get { return this.parameterList; } }
    public ConstructorInitializerSyntax Initializer { get { return this.initializer; } }
    public override BlockSyntax Body { get { return this.body; } }
    public override ArrowExpressionClauseSyntax ExpressionBody { get { return this.expressionBody; } }
    /// <summary>Gets the optional semicolon token.</summary>
    public override SyntaxToken SemicolonToken { get { return this.semicolonToken; } }

    internal override GreenNode GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.attributeLists;
            case 1: return this.modifiers;
            case 2: return this.identifier;
            case 3: return this.parameterList;
            case 4: return this.initializer;
            case 5: return this.body;
            case 6: return this.expressionBody;
            case 7: return this.semicolonToken;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode parent, int position)
    {
      return new CSharp.Syntax.ConstructorDeclarationSyntax(this, parent, position);
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitConstructorDeclaration(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitConstructorDeclaration(this);
    }

    public ConstructorDeclarationSyntax Update(Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<AttributeListSyntax> attributeLists, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SyntaxToken> modifiers, SyntaxToken identifier, ParameterListSyntax parameterList, ConstructorInitializerSyntax initializer, BlockSyntax body, ArrowExpressionClauseSyntax expressionBody, SyntaxToken semicolonToken)
    {
        if (attributeLists != this.AttributeLists || modifiers != this.Modifiers || identifier != this.Identifier || parameterList != this.ParameterList || initializer != this.Initializer || body != this.Body || expressionBody != this.ExpressionBody || semicolonToken != this.SemicolonToken)
        {
            var newNode = SyntaxFactory.ConstructorDeclaration(attributeLists, modifiers, identifier, parameterList, initializer, body, expressionBody, semicolonToken);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
    {
         return new ConstructorDeclarationSyntax(this.Kind, this.attributeLists, this.modifiers, this.identifier, this.parameterList, this.initializer, this.body, this.expressionBody, this.semicolonToken, diagnostics, GetAnnotations());
    }

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
    {
         return new ConstructorDeclarationSyntax(this.Kind, this.attributeLists, this.modifiers, this.identifier, this.parameterList, this.initializer, this.body, this.expressionBody, this.semicolonToken, GetDiagnostics(), annotations);
    }

    internal ConstructorDeclarationSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 8;
      var attributeLists = (GreenNode)reader.ReadValue();
      if (attributeLists != null)
      {
         AdjustFlagsAndWidth(attributeLists);
         this.attributeLists = attributeLists;
      }
      var modifiers = (GreenNode)reader.ReadValue();
      if (modifiers != null)
      {
         AdjustFlagsAndWidth(modifiers);
         this.modifiers = modifiers;
      }
      var identifier = (SyntaxToken)reader.ReadValue();
      if (identifier != null)
      {
         AdjustFlagsAndWidth(identifier);
         this.identifier = identifier;
      }
      var parameterList = (ParameterListSyntax)reader.ReadValue();
      if (parameterList != null)
      {
         AdjustFlagsAndWidth(parameterList);
         this.parameterList = parameterList;
      }
      var initializer = (ConstructorInitializerSyntax)reader.ReadValue();
      if (initializer != null)
      {
         AdjustFlagsAndWidth(initializer);
         this.initializer = initializer;
      }
      var body = (BlockSyntax)reader.ReadValue();
      if (body != null)
      {
         AdjustFlagsAndWidth(body);
         this.body = body;
      }
      var expressionBody = (ArrowExpressionClauseSyntax)reader.ReadValue();
      if (expressionBody != null)
      {
         AdjustFlagsAndWidth(expressionBody);
         this.expressionBody = expressionBody;
      }
      var semicolonToken = (SyntaxToken)reader.ReadValue();
      if (semicolonToken != null)
      {
         AdjustFlagsAndWidth(semicolonToken);
         this.semicolonToken = semicolonToken;
      }
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.attributeLists);
      writer.WriteValue(this.modifiers);
      writer.WriteValue(this.identifier);
      writer.WriteValue(this.parameterList);
      writer.WriteValue(this.initializer);
      writer.WriteValue(this.body);
      writer.WriteValue(this.expressionBody);
      writer.WriteValue(this.semicolonToken);
    }

    static ConstructorDeclarationSyntax()
    {
       ObjectBinder.RegisterTypeReader(typeof(ConstructorDeclarationSyntax), r => new ConstructorDeclarationSyntax(r));
    }
  }

  /// <summary>Constructor initializer syntax.</summary>
  internal sealed partial class ConstructorInitializerSyntax : CSharpSyntaxNode
  {
    internal readonly SyntaxToken colonToken;
    internal readonly SyntaxToken thisOrBaseKeyword;
    internal readonly ArgumentListSyntax argumentList;

    internal ConstructorInitializerSyntax(SyntaxKind kind, SyntaxToken colonToken, SyntaxToken thisOrBaseKeyword, ArgumentListSyntax argumentList, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 3;
        this.AdjustFlagsAndWidth(colonToken);
        this.colonToken = colonToken;
        this.AdjustFlagsAndWidth(thisOrBaseKeyword);
        this.thisOrBaseKeyword = thisOrBaseKeyword;
        this.AdjustFlagsAndWidth(argumentList);
        this.argumentList = argumentList;
    }


    internal ConstructorInitializerSyntax(SyntaxKind kind, SyntaxToken colonToken, SyntaxToken thisOrBaseKeyword, ArgumentListSyntax argumentList, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 3;
        this.AdjustFlagsAndWidth(colonToken);
        this.colonToken = colonToken;
        this.AdjustFlagsAndWidth(thisOrBaseKeyword);
        this.thisOrBaseKeyword = thisOrBaseKeyword;
        this.AdjustFlagsAndWidth(argumentList);
        this.argumentList = argumentList;
    }


    internal ConstructorInitializerSyntax(SyntaxKind kind, SyntaxToken colonToken, SyntaxToken thisOrBaseKeyword, ArgumentListSyntax argumentList)
        : base(kind)
    {
        this.SlotCount = 3;
        this.AdjustFlagsAndWidth(colonToken);
        this.colonToken = colonToken;
        this.AdjustFlagsAndWidth(thisOrBaseKeyword);
        this.thisOrBaseKeyword = thisOrBaseKeyword;
        this.AdjustFlagsAndWidth(argumentList);
        this.argumentList = argumentList;
    }

    /// <summary>Gets the colon token.</summary>
    public SyntaxToken ColonToken { get { return this.colonToken; } }
    /// <summary>Gets the "this" or "base" keyword.</summary>
    public SyntaxToken ThisOrBaseKeyword { get { return this.thisOrBaseKeyword; } }
    public ArgumentListSyntax ArgumentList { get { return this.argumentList; } }

    internal override GreenNode GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.colonToken;
            case 1: return this.thisOrBaseKeyword;
            case 2: return this.argumentList;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode parent, int position)
    {
      return new CSharp.Syntax.ConstructorInitializerSyntax(this, parent, position);
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitConstructorInitializer(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitConstructorInitializer(this);
    }

    public ConstructorInitializerSyntax Update(SyntaxToken colonToken, SyntaxToken thisOrBaseKeyword, ArgumentListSyntax argumentList)
    {
        if (colonToken != this.ColonToken || thisOrBaseKeyword != this.ThisOrBaseKeyword || argumentList != this.ArgumentList)
        {
            var newNode = SyntaxFactory.ConstructorInitializer(this.Kind, colonToken, thisOrBaseKeyword, argumentList);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
    {
         return new ConstructorInitializerSyntax(this.Kind, this.colonToken, this.thisOrBaseKeyword, this.argumentList, diagnostics, GetAnnotations());
    }

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
    {
         return new ConstructorInitializerSyntax(this.Kind, this.colonToken, this.thisOrBaseKeyword, this.argumentList, GetDiagnostics(), annotations);
    }

    internal ConstructorInitializerSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 3;
      var colonToken = (SyntaxToken)reader.ReadValue();
      if (colonToken != null)
      {
         AdjustFlagsAndWidth(colonToken);
         this.colonToken = colonToken;
      }
      var thisOrBaseKeyword = (SyntaxToken)reader.ReadValue();
      if (thisOrBaseKeyword != null)
      {
         AdjustFlagsAndWidth(thisOrBaseKeyword);
         this.thisOrBaseKeyword = thisOrBaseKeyword;
      }
      var argumentList = (ArgumentListSyntax)reader.ReadValue();
      if (argumentList != null)
      {
         AdjustFlagsAndWidth(argumentList);
         this.argumentList = argumentList;
      }
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.colonToken);
      writer.WriteValue(this.thisOrBaseKeyword);
      writer.WriteValue(this.argumentList);
    }

    static ConstructorInitializerSyntax()
    {
       ObjectBinder.RegisterTypeReader(typeof(ConstructorInitializerSyntax), r => new ConstructorInitializerSyntax(r));
    }
  }

  /// <summary>Destructor declaration syntax.</summary>
  internal sealed partial class DestructorDeclarationSyntax : BaseMethodDeclarationSyntax
  {
    internal readonly GreenNode attributeLists;
    internal readonly GreenNode modifiers;
    internal readonly SyntaxToken tildeToken;
    internal readonly SyntaxToken identifier;
    internal readonly ParameterListSyntax parameterList;
    internal readonly BlockSyntax body;
    internal readonly ArrowExpressionClauseSyntax expressionBody;
    internal readonly SyntaxToken semicolonToken;

    internal DestructorDeclarationSyntax(SyntaxKind kind, GreenNode attributeLists, GreenNode modifiers, SyntaxToken tildeToken, SyntaxToken identifier, ParameterListSyntax parameterList, BlockSyntax body, ArrowExpressionClauseSyntax expressionBody, SyntaxToken semicolonToken, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 8;
        if (attributeLists != null)
        {
            this.AdjustFlagsAndWidth(attributeLists);
            this.attributeLists = attributeLists;
        }
        if (modifiers != null)
        {
            this.AdjustFlagsAndWidth(modifiers);
            this.modifiers = modifiers;
        }
        this.AdjustFlagsAndWidth(tildeToken);
        this.tildeToken = tildeToken;
        this.AdjustFlagsAndWidth(identifier);
        this.identifier = identifier;
        this.AdjustFlagsAndWidth(parameterList);
        this.parameterList = parameterList;
        if (body != null)
        {
            this.AdjustFlagsAndWidth(body);
            this.body = body;
        }
        if (expressionBody != null)
        {
            this.AdjustFlagsAndWidth(expressionBody);
            this.expressionBody = expressionBody;
        }
        if (semicolonToken != null)
        {
            this.AdjustFlagsAndWidth(semicolonToken);
            this.semicolonToken = semicolonToken;
        }
    }


    internal DestructorDeclarationSyntax(SyntaxKind kind, GreenNode attributeLists, GreenNode modifiers, SyntaxToken tildeToken, SyntaxToken identifier, ParameterListSyntax parameterList, BlockSyntax body, ArrowExpressionClauseSyntax expressionBody, SyntaxToken semicolonToken, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 8;
        if (attributeLists != null)
        {
            this.AdjustFlagsAndWidth(attributeLists);
            this.attributeLists = attributeLists;
        }
        if (modifiers != null)
        {
            this.AdjustFlagsAndWidth(modifiers);
            this.modifiers = modifiers;
        }
        this.AdjustFlagsAndWidth(tildeToken);
        this.tildeToken = tildeToken;
        this.AdjustFlagsAndWidth(identifier);
        this.identifier = identifier;
        this.AdjustFlagsAndWidth(parameterList);
        this.parameterList = parameterList;
        if (body != null)
        {
            this.AdjustFlagsAndWidth(body);
            this.body = body;
        }
        if (expressionBody != null)
        {
            this.AdjustFlagsAndWidth(expressionBody);
            this.expressionBody = expressionBody;
        }
        if (semicolonToken != null)
        {
            this.AdjustFlagsAndWidth(semicolonToken);
            this.semicolonToken = semicolonToken;
        }
    }


    internal DestructorDeclarationSyntax(SyntaxKind kind, GreenNode attributeLists, GreenNode modifiers, SyntaxToken tildeToken, SyntaxToken identifier, ParameterListSyntax parameterList, BlockSyntax body, ArrowExpressionClauseSyntax expressionBody, SyntaxToken semicolonToken)
        : base(kind)
    {
        this.SlotCount = 8;
        if (attributeLists != null)
        {
            this.AdjustFlagsAndWidth(attributeLists);
            this.attributeLists = attributeLists;
        }
        if (modifiers != null)
        {
            this.AdjustFlagsAndWidth(modifiers);
            this.modifiers = modifiers;
        }
        this.AdjustFlagsAndWidth(tildeToken);
        this.tildeToken = tildeToken;
        this.AdjustFlagsAndWidth(identifier);
        this.identifier = identifier;
        this.AdjustFlagsAndWidth(parameterList);
        this.parameterList = parameterList;
        if (body != null)
        {
            this.AdjustFlagsAndWidth(body);
            this.body = body;
        }
        if (expressionBody != null)
        {
            this.AdjustFlagsAndWidth(expressionBody);
            this.expressionBody = expressionBody;
        }
        if (semicolonToken != null)
        {
            this.AdjustFlagsAndWidth(semicolonToken);
            this.semicolonToken = semicolonToken;
        }
    }

    public override Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<AttributeListSyntax> AttributeLists { get { return new Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<AttributeListSyntax>(this.attributeLists); } }
    public override Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SyntaxToken> Modifiers { get { return new Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SyntaxToken>(this.modifiers); } }
    /// <summary>Gets the tilde token.</summary>
    public SyntaxToken TildeToken { get { return this.tildeToken; } }
    /// <summary>Gets the identifier.</summary>
    public SyntaxToken Identifier { get { return this.identifier; } }
    public override ParameterListSyntax ParameterList { get { return this.parameterList; } }
    public override BlockSyntax Body { get { return this.body; } }
    public override ArrowExpressionClauseSyntax ExpressionBody { get { return this.expressionBody; } }
    /// <summary>Gets the optional semicolon token.</summary>
    public override SyntaxToken SemicolonToken { get { return this.semicolonToken; } }

    internal override GreenNode GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.attributeLists;
            case 1: return this.modifiers;
            case 2: return this.tildeToken;
            case 3: return this.identifier;
            case 4: return this.parameterList;
            case 5: return this.body;
            case 6: return this.expressionBody;
            case 7: return this.semicolonToken;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode parent, int position)
    {
      return new CSharp.Syntax.DestructorDeclarationSyntax(this, parent, position);
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitDestructorDeclaration(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitDestructorDeclaration(this);
    }

    public DestructorDeclarationSyntax Update(Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<AttributeListSyntax> attributeLists, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SyntaxToken> modifiers, SyntaxToken tildeToken, SyntaxToken identifier, ParameterListSyntax parameterList, BlockSyntax body, ArrowExpressionClauseSyntax expressionBody, SyntaxToken semicolonToken)
    {
        if (attributeLists != this.AttributeLists || modifiers != this.Modifiers || tildeToken != this.TildeToken || identifier != this.Identifier || parameterList != this.ParameterList || body != this.Body || expressionBody != this.ExpressionBody || semicolonToken != this.SemicolonToken)
        {
            var newNode = SyntaxFactory.DestructorDeclaration(attributeLists, modifiers, tildeToken, identifier, parameterList, body, expressionBody, semicolonToken);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
    {
         return new DestructorDeclarationSyntax(this.Kind, this.attributeLists, this.modifiers, this.tildeToken, this.identifier, this.parameterList, this.body, this.expressionBody, this.semicolonToken, diagnostics, GetAnnotations());
    }

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
    {
         return new DestructorDeclarationSyntax(this.Kind, this.attributeLists, this.modifiers, this.tildeToken, this.identifier, this.parameterList, this.body, this.expressionBody, this.semicolonToken, GetDiagnostics(), annotations);
    }

    internal DestructorDeclarationSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 8;
      var attributeLists = (GreenNode)reader.ReadValue();
      if (attributeLists != null)
      {
         AdjustFlagsAndWidth(attributeLists);
         this.attributeLists = attributeLists;
      }
      var modifiers = (GreenNode)reader.ReadValue();
      if (modifiers != null)
      {
         AdjustFlagsAndWidth(modifiers);
         this.modifiers = modifiers;
      }
      var tildeToken = (SyntaxToken)reader.ReadValue();
      if (tildeToken != null)
      {
         AdjustFlagsAndWidth(tildeToken);
         this.tildeToken = tildeToken;
      }
      var identifier = (SyntaxToken)reader.ReadValue();
      if (identifier != null)
      {
         AdjustFlagsAndWidth(identifier);
         this.identifier = identifier;
      }
      var parameterList = (ParameterListSyntax)reader.ReadValue();
      if (parameterList != null)
      {
         AdjustFlagsAndWidth(parameterList);
         this.parameterList = parameterList;
      }
      var body = (BlockSyntax)reader.ReadValue();
      if (body != null)
      {
         AdjustFlagsAndWidth(body);
         this.body = body;
      }
      var expressionBody = (ArrowExpressionClauseSyntax)reader.ReadValue();
      if (expressionBody != null)
      {
         AdjustFlagsAndWidth(expressionBody);
         this.expressionBody = expressionBody;
      }
      var semicolonToken = (SyntaxToken)reader.ReadValue();
      if (semicolonToken != null)
      {
         AdjustFlagsAndWidth(semicolonToken);
         this.semicolonToken = semicolonToken;
      }
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.attributeLists);
      writer.WriteValue(this.modifiers);
      writer.WriteValue(this.tildeToken);
      writer.WriteValue(this.identifier);
      writer.WriteValue(this.parameterList);
      writer.WriteValue(this.body);
      writer.WriteValue(this.expressionBody);
      writer.WriteValue(this.semicolonToken);
    }

    static DestructorDeclarationSyntax()
    {
       ObjectBinder.RegisterTypeReader(typeof(DestructorDeclarationSyntax), r => new DestructorDeclarationSyntax(r));
    }
  }

  /// <summary>Base type for property declaration syntax.</summary>
  internal abstract partial class BasePropertyDeclarationSyntax : MemberDeclarationSyntax
  {
    internal BasePropertyDeclarationSyntax(SyntaxKind kind, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
      : base(kind, diagnostics, annotations)
    {
    }
    internal BasePropertyDeclarationSyntax(SyntaxKind kind)
      : base(kind)
    {
    }

    protected BasePropertyDeclarationSyntax(ObjectReader reader)
       : base(reader)
    {
    }

    /// <summary>Gets the attribute declaration list.</summary>
    public abstract Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<AttributeListSyntax> AttributeLists { get; }

    /// <summary>Gets the modifier list.</summary>
    public abstract Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SyntaxToken> Modifiers { get; }

    /// <summary>Gets the type syntax.</summary>
    public abstract TypeSyntax Type { get; }

    /// <summary>Gets the optional explicit interface specifier.</summary>
    public abstract ExplicitInterfaceSpecifierSyntax ExplicitInterfaceSpecifier { get; }

    public abstract AccessorListSyntax AccessorList { get; }
  }

  internal sealed partial class PropertyDeclarationSyntax : BasePropertyDeclarationSyntax
  {
    internal readonly GreenNode attributeLists;
    internal readonly GreenNode modifiers;
    internal readonly TypeSyntax type;
    internal readonly ExplicitInterfaceSpecifierSyntax explicitInterfaceSpecifier;
    internal readonly SyntaxToken identifier;
    internal readonly AccessorListSyntax accessorList;
    internal readonly ArrowExpressionClauseSyntax expressionBody;
    internal readonly EqualsValueClauseSyntax initializer;
    internal readonly SyntaxToken semicolonToken;

    internal PropertyDeclarationSyntax(SyntaxKind kind, GreenNode attributeLists, GreenNode modifiers, TypeSyntax type, ExplicitInterfaceSpecifierSyntax explicitInterfaceSpecifier, SyntaxToken identifier, AccessorListSyntax accessorList, ArrowExpressionClauseSyntax expressionBody, EqualsValueClauseSyntax initializer, SyntaxToken semicolonToken, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 9;
        if (attributeLists != null)
        {
            this.AdjustFlagsAndWidth(attributeLists);
            this.attributeLists = attributeLists;
        }
        if (modifiers != null)
        {
            this.AdjustFlagsAndWidth(modifiers);
            this.modifiers = modifiers;
        }
        this.AdjustFlagsAndWidth(type);
        this.type = type;
        if (explicitInterfaceSpecifier != null)
        {
            this.AdjustFlagsAndWidth(explicitInterfaceSpecifier);
            this.explicitInterfaceSpecifier = explicitInterfaceSpecifier;
        }
        this.AdjustFlagsAndWidth(identifier);
        this.identifier = identifier;
        if (accessorList != null)
        {
            this.AdjustFlagsAndWidth(accessorList);
            this.accessorList = accessorList;
        }
        if (expressionBody != null)
        {
            this.AdjustFlagsAndWidth(expressionBody);
            this.expressionBody = expressionBody;
        }
        if (initializer != null)
        {
            this.AdjustFlagsAndWidth(initializer);
            this.initializer = initializer;
        }
        if (semicolonToken != null)
        {
            this.AdjustFlagsAndWidth(semicolonToken);
            this.semicolonToken = semicolonToken;
        }
    }


    internal PropertyDeclarationSyntax(SyntaxKind kind, GreenNode attributeLists, GreenNode modifiers, TypeSyntax type, ExplicitInterfaceSpecifierSyntax explicitInterfaceSpecifier, SyntaxToken identifier, AccessorListSyntax accessorList, ArrowExpressionClauseSyntax expressionBody, EqualsValueClauseSyntax initializer, SyntaxToken semicolonToken, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 9;
        if (attributeLists != null)
        {
            this.AdjustFlagsAndWidth(attributeLists);
            this.attributeLists = attributeLists;
        }
        if (modifiers != null)
        {
            this.AdjustFlagsAndWidth(modifiers);
            this.modifiers = modifiers;
        }
        this.AdjustFlagsAndWidth(type);
        this.type = type;
        if (explicitInterfaceSpecifier != null)
        {
            this.AdjustFlagsAndWidth(explicitInterfaceSpecifier);
            this.explicitInterfaceSpecifier = explicitInterfaceSpecifier;
        }
        this.AdjustFlagsAndWidth(identifier);
        this.identifier = identifier;
        if (accessorList != null)
        {
            this.AdjustFlagsAndWidth(accessorList);
            this.accessorList = accessorList;
        }
        if (expressionBody != null)
        {
            this.AdjustFlagsAndWidth(expressionBody);
            this.expressionBody = expressionBody;
        }
        if (initializer != null)
        {
            this.AdjustFlagsAndWidth(initializer);
            this.initializer = initializer;
        }
        if (semicolonToken != null)
        {
            this.AdjustFlagsAndWidth(semicolonToken);
            this.semicolonToken = semicolonToken;
        }
    }


    internal PropertyDeclarationSyntax(SyntaxKind kind, GreenNode attributeLists, GreenNode modifiers, TypeSyntax type, ExplicitInterfaceSpecifierSyntax explicitInterfaceSpecifier, SyntaxToken identifier, AccessorListSyntax accessorList, ArrowExpressionClauseSyntax expressionBody, EqualsValueClauseSyntax initializer, SyntaxToken semicolonToken)
        : base(kind)
    {
        this.SlotCount = 9;
        if (attributeLists != null)
        {
            this.AdjustFlagsAndWidth(attributeLists);
            this.attributeLists = attributeLists;
        }
        if (modifiers != null)
        {
            this.AdjustFlagsAndWidth(modifiers);
            this.modifiers = modifiers;
        }
        this.AdjustFlagsAndWidth(type);
        this.type = type;
        if (explicitInterfaceSpecifier != null)
        {
            this.AdjustFlagsAndWidth(explicitInterfaceSpecifier);
            this.explicitInterfaceSpecifier = explicitInterfaceSpecifier;
        }
        this.AdjustFlagsAndWidth(identifier);
        this.identifier = identifier;
        if (accessorList != null)
        {
            this.AdjustFlagsAndWidth(accessorList);
            this.accessorList = accessorList;
        }
        if (expressionBody != null)
        {
            this.AdjustFlagsAndWidth(expressionBody);
            this.expressionBody = expressionBody;
        }
        if (initializer != null)
        {
            this.AdjustFlagsAndWidth(initializer);
            this.initializer = initializer;
        }
        if (semicolonToken != null)
        {
            this.AdjustFlagsAndWidth(semicolonToken);
            this.semicolonToken = semicolonToken;
        }
    }

    public override Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<AttributeListSyntax> AttributeLists { get { return new Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<AttributeListSyntax>(this.attributeLists); } }
    public override Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SyntaxToken> Modifiers { get { return new Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SyntaxToken>(this.modifiers); } }
    public override TypeSyntax Type { get { return this.type; } }
    public override ExplicitInterfaceSpecifierSyntax ExplicitInterfaceSpecifier { get { return this.explicitInterfaceSpecifier; } }
    /// <summary>Gets the identifier.</summary>
    public SyntaxToken Identifier { get { return this.identifier; } }
    public override AccessorListSyntax AccessorList { get { return this.accessorList; } }
    public ArrowExpressionClauseSyntax ExpressionBody { get { return this.expressionBody; } }
    public EqualsValueClauseSyntax Initializer { get { return this.initializer; } }
    public SyntaxToken SemicolonToken { get { return this.semicolonToken; } }

    internal override GreenNode GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.attributeLists;
            case 1: return this.modifiers;
            case 2: return this.type;
            case 3: return this.explicitInterfaceSpecifier;
            case 4: return this.identifier;
            case 5: return this.accessorList;
            case 6: return this.expressionBody;
            case 7: return this.initializer;
            case 8: return this.semicolonToken;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode parent, int position)
    {
      return new CSharp.Syntax.PropertyDeclarationSyntax(this, parent, position);
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitPropertyDeclaration(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitPropertyDeclaration(this);
    }

    public PropertyDeclarationSyntax Update(Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<AttributeListSyntax> attributeLists, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SyntaxToken> modifiers, TypeSyntax type, ExplicitInterfaceSpecifierSyntax explicitInterfaceSpecifier, SyntaxToken identifier, AccessorListSyntax accessorList, ArrowExpressionClauseSyntax expressionBody, EqualsValueClauseSyntax initializer, SyntaxToken semicolonToken)
    {
        if (attributeLists != this.AttributeLists || modifiers != this.Modifiers || type != this.Type || explicitInterfaceSpecifier != this.ExplicitInterfaceSpecifier || identifier != this.Identifier || accessorList != this.AccessorList || expressionBody != this.ExpressionBody || initializer != this.Initializer || semicolonToken != this.SemicolonToken)
        {
            var newNode = SyntaxFactory.PropertyDeclaration(attributeLists, modifiers, type, explicitInterfaceSpecifier, identifier, accessorList, expressionBody, initializer, semicolonToken);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
    {
         return new PropertyDeclarationSyntax(this.Kind, this.attributeLists, this.modifiers, this.type, this.explicitInterfaceSpecifier, this.identifier, this.accessorList, this.expressionBody, this.initializer, this.semicolonToken, diagnostics, GetAnnotations());
    }

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
    {
         return new PropertyDeclarationSyntax(this.Kind, this.attributeLists, this.modifiers, this.type, this.explicitInterfaceSpecifier, this.identifier, this.accessorList, this.expressionBody, this.initializer, this.semicolonToken, GetDiagnostics(), annotations);
    }

    internal PropertyDeclarationSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 9;
      var attributeLists = (GreenNode)reader.ReadValue();
      if (attributeLists != null)
      {
         AdjustFlagsAndWidth(attributeLists);
         this.attributeLists = attributeLists;
      }
      var modifiers = (GreenNode)reader.ReadValue();
      if (modifiers != null)
      {
         AdjustFlagsAndWidth(modifiers);
         this.modifiers = modifiers;
      }
      var type = (TypeSyntax)reader.ReadValue();
      if (type != null)
      {
         AdjustFlagsAndWidth(type);
         this.type = type;
      }
      var explicitInterfaceSpecifier = (ExplicitInterfaceSpecifierSyntax)reader.ReadValue();
      if (explicitInterfaceSpecifier != null)
      {
         AdjustFlagsAndWidth(explicitInterfaceSpecifier);
         this.explicitInterfaceSpecifier = explicitInterfaceSpecifier;
      }
      var identifier = (SyntaxToken)reader.ReadValue();
      if (identifier != null)
      {
         AdjustFlagsAndWidth(identifier);
         this.identifier = identifier;
      }
      var accessorList = (AccessorListSyntax)reader.ReadValue();
      if (accessorList != null)
      {
         AdjustFlagsAndWidth(accessorList);
         this.accessorList = accessorList;
      }
      var expressionBody = (ArrowExpressionClauseSyntax)reader.ReadValue();
      if (expressionBody != null)
      {
         AdjustFlagsAndWidth(expressionBody);
         this.expressionBody = expressionBody;
      }
      var initializer = (EqualsValueClauseSyntax)reader.ReadValue();
      if (initializer != null)
      {
         AdjustFlagsAndWidth(initializer);
         this.initializer = initializer;
      }
      var semicolonToken = (SyntaxToken)reader.ReadValue();
      if (semicolonToken != null)
      {
         AdjustFlagsAndWidth(semicolonToken);
         this.semicolonToken = semicolonToken;
      }
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.attributeLists);
      writer.WriteValue(this.modifiers);
      writer.WriteValue(this.type);
      writer.WriteValue(this.explicitInterfaceSpecifier);
      writer.WriteValue(this.identifier);
      writer.WriteValue(this.accessorList);
      writer.WriteValue(this.expressionBody);
      writer.WriteValue(this.initializer);
      writer.WriteValue(this.semicolonToken);
    }

    static PropertyDeclarationSyntax()
    {
       ObjectBinder.RegisterTypeReader(typeof(PropertyDeclarationSyntax), r => new PropertyDeclarationSyntax(r));
    }
  }

  /// <summary>The syntax for the expression body of an expression-bodied member.</summary>
  internal sealed partial class ArrowExpressionClauseSyntax : CSharpSyntaxNode
  {
    internal readonly SyntaxToken arrowToken;
    internal readonly ExpressionSyntax expression;

    internal ArrowExpressionClauseSyntax(SyntaxKind kind, SyntaxToken arrowToken, ExpressionSyntax expression, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 2;
        this.AdjustFlagsAndWidth(arrowToken);
        this.arrowToken = arrowToken;
        this.AdjustFlagsAndWidth(expression);
        this.expression = expression;
    }


    internal ArrowExpressionClauseSyntax(SyntaxKind kind, SyntaxToken arrowToken, ExpressionSyntax expression, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 2;
        this.AdjustFlagsAndWidth(arrowToken);
        this.arrowToken = arrowToken;
        this.AdjustFlagsAndWidth(expression);
        this.expression = expression;
    }


    internal ArrowExpressionClauseSyntax(SyntaxKind kind, SyntaxToken arrowToken, ExpressionSyntax expression)
        : base(kind)
    {
        this.SlotCount = 2;
        this.AdjustFlagsAndWidth(arrowToken);
        this.arrowToken = arrowToken;
        this.AdjustFlagsAndWidth(expression);
        this.expression = expression;
    }

    public SyntaxToken ArrowToken { get { return this.arrowToken; } }
    public ExpressionSyntax Expression { get { return this.expression; } }

    internal override GreenNode GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.arrowToken;
            case 1: return this.expression;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode parent, int position)
    {
      return new CSharp.Syntax.ArrowExpressionClauseSyntax(this, parent, position);
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitArrowExpressionClause(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitArrowExpressionClause(this);
    }

    public ArrowExpressionClauseSyntax Update(SyntaxToken arrowToken, ExpressionSyntax expression)
    {
        if (arrowToken != this.ArrowToken || expression != this.Expression)
        {
            var newNode = SyntaxFactory.ArrowExpressionClause(arrowToken, expression);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
    {
         return new ArrowExpressionClauseSyntax(this.Kind, this.arrowToken, this.expression, diagnostics, GetAnnotations());
    }

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
    {
         return new ArrowExpressionClauseSyntax(this.Kind, this.arrowToken, this.expression, GetDiagnostics(), annotations);
    }

    internal ArrowExpressionClauseSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 2;
      var arrowToken = (SyntaxToken)reader.ReadValue();
      if (arrowToken != null)
      {
         AdjustFlagsAndWidth(arrowToken);
         this.arrowToken = arrowToken;
      }
      var expression = (ExpressionSyntax)reader.ReadValue();
      if (expression != null)
      {
         AdjustFlagsAndWidth(expression);
         this.expression = expression;
      }
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.arrowToken);
      writer.WriteValue(this.expression);
    }

    static ArrowExpressionClauseSyntax()
    {
       ObjectBinder.RegisterTypeReader(typeof(ArrowExpressionClauseSyntax), r => new ArrowExpressionClauseSyntax(r));
    }
  }

  internal sealed partial class EventDeclarationSyntax : BasePropertyDeclarationSyntax
  {
    internal readonly GreenNode attributeLists;
    internal readonly GreenNode modifiers;
    internal readonly SyntaxToken eventKeyword;
    internal readonly TypeSyntax type;
    internal readonly ExplicitInterfaceSpecifierSyntax explicitInterfaceSpecifier;
    internal readonly SyntaxToken identifier;
    internal readonly AccessorListSyntax accessorList;

    internal EventDeclarationSyntax(SyntaxKind kind, GreenNode attributeLists, GreenNode modifiers, SyntaxToken eventKeyword, TypeSyntax type, ExplicitInterfaceSpecifierSyntax explicitInterfaceSpecifier, SyntaxToken identifier, AccessorListSyntax accessorList, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 7;
        if (attributeLists != null)
        {
            this.AdjustFlagsAndWidth(attributeLists);
            this.attributeLists = attributeLists;
        }
        if (modifiers != null)
        {
            this.AdjustFlagsAndWidth(modifiers);
            this.modifiers = modifiers;
        }
        this.AdjustFlagsAndWidth(eventKeyword);
        this.eventKeyword = eventKeyword;
        this.AdjustFlagsAndWidth(type);
        this.type = type;
        if (explicitInterfaceSpecifier != null)
        {
            this.AdjustFlagsAndWidth(explicitInterfaceSpecifier);
            this.explicitInterfaceSpecifier = explicitInterfaceSpecifier;
        }
        this.AdjustFlagsAndWidth(identifier);
        this.identifier = identifier;
        this.AdjustFlagsAndWidth(accessorList);
        this.accessorList = accessorList;
    }


    internal EventDeclarationSyntax(SyntaxKind kind, GreenNode attributeLists, GreenNode modifiers, SyntaxToken eventKeyword, TypeSyntax type, ExplicitInterfaceSpecifierSyntax explicitInterfaceSpecifier, SyntaxToken identifier, AccessorListSyntax accessorList, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 7;
        if (attributeLists != null)
        {
            this.AdjustFlagsAndWidth(attributeLists);
            this.attributeLists = attributeLists;
        }
        if (modifiers != null)
        {
            this.AdjustFlagsAndWidth(modifiers);
            this.modifiers = modifiers;
        }
        this.AdjustFlagsAndWidth(eventKeyword);
        this.eventKeyword = eventKeyword;
        this.AdjustFlagsAndWidth(type);
        this.type = type;
        if (explicitInterfaceSpecifier != null)
        {
            this.AdjustFlagsAndWidth(explicitInterfaceSpecifier);
            this.explicitInterfaceSpecifier = explicitInterfaceSpecifier;
        }
        this.AdjustFlagsAndWidth(identifier);
        this.identifier = identifier;
        this.AdjustFlagsAndWidth(accessorList);
        this.accessorList = accessorList;
    }


    internal EventDeclarationSyntax(SyntaxKind kind, GreenNode attributeLists, GreenNode modifiers, SyntaxToken eventKeyword, TypeSyntax type, ExplicitInterfaceSpecifierSyntax explicitInterfaceSpecifier, SyntaxToken identifier, AccessorListSyntax accessorList)
        : base(kind)
    {
        this.SlotCount = 7;
        if (attributeLists != null)
        {
            this.AdjustFlagsAndWidth(attributeLists);
            this.attributeLists = attributeLists;
        }
        if (modifiers != null)
        {
            this.AdjustFlagsAndWidth(modifiers);
            this.modifiers = modifiers;
        }
        this.AdjustFlagsAndWidth(eventKeyword);
        this.eventKeyword = eventKeyword;
        this.AdjustFlagsAndWidth(type);
        this.type = type;
        if (explicitInterfaceSpecifier != null)
        {
            this.AdjustFlagsAndWidth(explicitInterfaceSpecifier);
            this.explicitInterfaceSpecifier = explicitInterfaceSpecifier;
        }
        this.AdjustFlagsAndWidth(identifier);
        this.identifier = identifier;
        this.AdjustFlagsAndWidth(accessorList);
        this.accessorList = accessorList;
    }

    public override Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<AttributeListSyntax> AttributeLists { get { return new Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<AttributeListSyntax>(this.attributeLists); } }
    public override Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SyntaxToken> Modifiers { get { return new Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SyntaxToken>(this.modifiers); } }
    public SyntaxToken EventKeyword { get { return this.eventKeyword; } }
    public override TypeSyntax Type { get { return this.type; } }
    public override ExplicitInterfaceSpecifierSyntax ExplicitInterfaceSpecifier { get { return this.explicitInterfaceSpecifier; } }
    /// <summary>Gets the identifier.</summary>
    public SyntaxToken Identifier { get { return this.identifier; } }
    public override AccessorListSyntax AccessorList { get { return this.accessorList; } }

    internal override GreenNode GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.attributeLists;
            case 1: return this.modifiers;
            case 2: return this.eventKeyword;
            case 3: return this.type;
            case 4: return this.explicitInterfaceSpecifier;
            case 5: return this.identifier;
            case 6: return this.accessorList;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode parent, int position)
    {
      return new CSharp.Syntax.EventDeclarationSyntax(this, parent, position);
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitEventDeclaration(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitEventDeclaration(this);
    }

    public EventDeclarationSyntax Update(Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<AttributeListSyntax> attributeLists, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SyntaxToken> modifiers, SyntaxToken eventKeyword, TypeSyntax type, ExplicitInterfaceSpecifierSyntax explicitInterfaceSpecifier, SyntaxToken identifier, AccessorListSyntax accessorList)
    {
        if (attributeLists != this.AttributeLists || modifiers != this.Modifiers || eventKeyword != this.EventKeyword || type != this.Type || explicitInterfaceSpecifier != this.ExplicitInterfaceSpecifier || identifier != this.Identifier || accessorList != this.AccessorList)
        {
            var newNode = SyntaxFactory.EventDeclaration(attributeLists, modifiers, eventKeyword, type, explicitInterfaceSpecifier, identifier, accessorList);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
    {
         return new EventDeclarationSyntax(this.Kind, this.attributeLists, this.modifiers, this.eventKeyword, this.type, this.explicitInterfaceSpecifier, this.identifier, this.accessorList, diagnostics, GetAnnotations());
    }

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
    {
         return new EventDeclarationSyntax(this.Kind, this.attributeLists, this.modifiers, this.eventKeyword, this.type, this.explicitInterfaceSpecifier, this.identifier, this.accessorList, GetDiagnostics(), annotations);
    }

    internal EventDeclarationSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 7;
      var attributeLists = (GreenNode)reader.ReadValue();
      if (attributeLists != null)
      {
         AdjustFlagsAndWidth(attributeLists);
         this.attributeLists = attributeLists;
      }
      var modifiers = (GreenNode)reader.ReadValue();
      if (modifiers != null)
      {
         AdjustFlagsAndWidth(modifiers);
         this.modifiers = modifiers;
      }
      var eventKeyword = (SyntaxToken)reader.ReadValue();
      if (eventKeyword != null)
      {
         AdjustFlagsAndWidth(eventKeyword);
         this.eventKeyword = eventKeyword;
      }
      var type = (TypeSyntax)reader.ReadValue();
      if (type != null)
      {
         AdjustFlagsAndWidth(type);
         this.type = type;
      }
      var explicitInterfaceSpecifier = (ExplicitInterfaceSpecifierSyntax)reader.ReadValue();
      if (explicitInterfaceSpecifier != null)
      {
         AdjustFlagsAndWidth(explicitInterfaceSpecifier);
         this.explicitInterfaceSpecifier = explicitInterfaceSpecifier;
      }
      var identifier = (SyntaxToken)reader.ReadValue();
      if (identifier != null)
      {
         AdjustFlagsAndWidth(identifier);
         this.identifier = identifier;
      }
      var accessorList = (AccessorListSyntax)reader.ReadValue();
      if (accessorList != null)
      {
         AdjustFlagsAndWidth(accessorList);
         this.accessorList = accessorList;
      }
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.attributeLists);
      writer.WriteValue(this.modifiers);
      writer.WriteValue(this.eventKeyword);
      writer.WriteValue(this.type);
      writer.WriteValue(this.explicitInterfaceSpecifier);
      writer.WriteValue(this.identifier);
      writer.WriteValue(this.accessorList);
    }

    static EventDeclarationSyntax()
    {
       ObjectBinder.RegisterTypeReader(typeof(EventDeclarationSyntax), r => new EventDeclarationSyntax(r));
    }
  }

  internal sealed partial class IndexerDeclarationSyntax : BasePropertyDeclarationSyntax
  {
    internal readonly GreenNode attributeLists;
    internal readonly GreenNode modifiers;
    internal readonly TypeSyntax type;
    internal readonly ExplicitInterfaceSpecifierSyntax explicitInterfaceSpecifier;
    internal readonly SyntaxToken thisKeyword;
    internal readonly BracketedParameterListSyntax parameterList;
    internal readonly AccessorListSyntax accessorList;
    internal readonly ArrowExpressionClauseSyntax expressionBody;
    internal readonly SyntaxToken semicolonToken;

    internal IndexerDeclarationSyntax(SyntaxKind kind, GreenNode attributeLists, GreenNode modifiers, TypeSyntax type, ExplicitInterfaceSpecifierSyntax explicitInterfaceSpecifier, SyntaxToken thisKeyword, BracketedParameterListSyntax parameterList, AccessorListSyntax accessorList, ArrowExpressionClauseSyntax expressionBody, SyntaxToken semicolonToken, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 9;
        if (attributeLists != null)
        {
            this.AdjustFlagsAndWidth(attributeLists);
            this.attributeLists = attributeLists;
        }
        if (modifiers != null)
        {
            this.AdjustFlagsAndWidth(modifiers);
            this.modifiers = modifiers;
        }
        this.AdjustFlagsAndWidth(type);
        this.type = type;
        if (explicitInterfaceSpecifier != null)
        {
            this.AdjustFlagsAndWidth(explicitInterfaceSpecifier);
            this.explicitInterfaceSpecifier = explicitInterfaceSpecifier;
        }
        this.AdjustFlagsAndWidth(thisKeyword);
        this.thisKeyword = thisKeyword;
        this.AdjustFlagsAndWidth(parameterList);
        this.parameterList = parameterList;
        if (accessorList != null)
        {
            this.AdjustFlagsAndWidth(accessorList);
            this.accessorList = accessorList;
        }
        if (expressionBody != null)
        {
            this.AdjustFlagsAndWidth(expressionBody);
            this.expressionBody = expressionBody;
        }
        if (semicolonToken != null)
        {
            this.AdjustFlagsAndWidth(semicolonToken);
            this.semicolonToken = semicolonToken;
        }
    }


    internal IndexerDeclarationSyntax(SyntaxKind kind, GreenNode attributeLists, GreenNode modifiers, TypeSyntax type, ExplicitInterfaceSpecifierSyntax explicitInterfaceSpecifier, SyntaxToken thisKeyword, BracketedParameterListSyntax parameterList, AccessorListSyntax accessorList, ArrowExpressionClauseSyntax expressionBody, SyntaxToken semicolonToken, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 9;
        if (attributeLists != null)
        {
            this.AdjustFlagsAndWidth(attributeLists);
            this.attributeLists = attributeLists;
        }
        if (modifiers != null)
        {
            this.AdjustFlagsAndWidth(modifiers);
            this.modifiers = modifiers;
        }
        this.AdjustFlagsAndWidth(type);
        this.type = type;
        if (explicitInterfaceSpecifier != null)
        {
            this.AdjustFlagsAndWidth(explicitInterfaceSpecifier);
            this.explicitInterfaceSpecifier = explicitInterfaceSpecifier;
        }
        this.AdjustFlagsAndWidth(thisKeyword);
        this.thisKeyword = thisKeyword;
        this.AdjustFlagsAndWidth(parameterList);
        this.parameterList = parameterList;
        if (accessorList != null)
        {
            this.AdjustFlagsAndWidth(accessorList);
            this.accessorList = accessorList;
        }
        if (expressionBody != null)
        {
            this.AdjustFlagsAndWidth(expressionBody);
            this.expressionBody = expressionBody;
        }
        if (semicolonToken != null)
        {
            this.AdjustFlagsAndWidth(semicolonToken);
            this.semicolonToken = semicolonToken;
        }
    }


    internal IndexerDeclarationSyntax(SyntaxKind kind, GreenNode attributeLists, GreenNode modifiers, TypeSyntax type, ExplicitInterfaceSpecifierSyntax explicitInterfaceSpecifier, SyntaxToken thisKeyword, BracketedParameterListSyntax parameterList, AccessorListSyntax accessorList, ArrowExpressionClauseSyntax expressionBody, SyntaxToken semicolonToken)
        : base(kind)
    {
        this.SlotCount = 9;
        if (attributeLists != null)
        {
            this.AdjustFlagsAndWidth(attributeLists);
            this.attributeLists = attributeLists;
        }
        if (modifiers != null)
        {
            this.AdjustFlagsAndWidth(modifiers);
            this.modifiers = modifiers;
        }
        this.AdjustFlagsAndWidth(type);
        this.type = type;
        if (explicitInterfaceSpecifier != null)
        {
            this.AdjustFlagsAndWidth(explicitInterfaceSpecifier);
            this.explicitInterfaceSpecifier = explicitInterfaceSpecifier;
        }
        this.AdjustFlagsAndWidth(thisKeyword);
        this.thisKeyword = thisKeyword;
        this.AdjustFlagsAndWidth(parameterList);
        this.parameterList = parameterList;
        if (accessorList != null)
        {
            this.AdjustFlagsAndWidth(accessorList);
            this.accessorList = accessorList;
        }
        if (expressionBody != null)
        {
            this.AdjustFlagsAndWidth(expressionBody);
            this.expressionBody = expressionBody;
        }
        if (semicolonToken != null)
        {
            this.AdjustFlagsAndWidth(semicolonToken);
            this.semicolonToken = semicolonToken;
        }
    }

    public override Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<AttributeListSyntax> AttributeLists { get { return new Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<AttributeListSyntax>(this.attributeLists); } }
    public override Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SyntaxToken> Modifiers { get { return new Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SyntaxToken>(this.modifiers); } }
    public override TypeSyntax Type { get { return this.type; } }
    public override ExplicitInterfaceSpecifierSyntax ExplicitInterfaceSpecifier { get { return this.explicitInterfaceSpecifier; } }
    public SyntaxToken ThisKeyword { get { return this.thisKeyword; } }
    /// <summary>Gets the parameter list.</summary>
    public BracketedParameterListSyntax ParameterList { get { return this.parameterList; } }
    public override AccessorListSyntax AccessorList { get { return this.accessorList; } }
    public ArrowExpressionClauseSyntax ExpressionBody { get { return this.expressionBody; } }
    public SyntaxToken SemicolonToken { get { return this.semicolonToken; } }

    internal override GreenNode GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.attributeLists;
            case 1: return this.modifiers;
            case 2: return this.type;
            case 3: return this.explicitInterfaceSpecifier;
            case 4: return this.thisKeyword;
            case 5: return this.parameterList;
            case 6: return this.accessorList;
            case 7: return this.expressionBody;
            case 8: return this.semicolonToken;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode parent, int position)
    {
      return new CSharp.Syntax.IndexerDeclarationSyntax(this, parent, position);
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitIndexerDeclaration(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitIndexerDeclaration(this);
    }

    public IndexerDeclarationSyntax Update(Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<AttributeListSyntax> attributeLists, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SyntaxToken> modifiers, TypeSyntax type, ExplicitInterfaceSpecifierSyntax explicitInterfaceSpecifier, SyntaxToken thisKeyword, BracketedParameterListSyntax parameterList, AccessorListSyntax accessorList, ArrowExpressionClauseSyntax expressionBody, SyntaxToken semicolonToken)
    {
        if (attributeLists != this.AttributeLists || modifiers != this.Modifiers || type != this.Type || explicitInterfaceSpecifier != this.ExplicitInterfaceSpecifier || thisKeyword != this.ThisKeyword || parameterList != this.ParameterList || accessorList != this.AccessorList || expressionBody != this.ExpressionBody || semicolonToken != this.SemicolonToken)
        {
            var newNode = SyntaxFactory.IndexerDeclaration(attributeLists, modifiers, type, explicitInterfaceSpecifier, thisKeyword, parameterList, accessorList, expressionBody, semicolonToken);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
    {
         return new IndexerDeclarationSyntax(this.Kind, this.attributeLists, this.modifiers, this.type, this.explicitInterfaceSpecifier, this.thisKeyword, this.parameterList, this.accessorList, this.expressionBody, this.semicolonToken, diagnostics, GetAnnotations());
    }

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
    {
         return new IndexerDeclarationSyntax(this.Kind, this.attributeLists, this.modifiers, this.type, this.explicitInterfaceSpecifier, this.thisKeyword, this.parameterList, this.accessorList, this.expressionBody, this.semicolonToken, GetDiagnostics(), annotations);
    }

    internal IndexerDeclarationSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 9;
      var attributeLists = (GreenNode)reader.ReadValue();
      if (attributeLists != null)
      {
         AdjustFlagsAndWidth(attributeLists);
         this.attributeLists = attributeLists;
      }
      var modifiers = (GreenNode)reader.ReadValue();
      if (modifiers != null)
      {
         AdjustFlagsAndWidth(modifiers);
         this.modifiers = modifiers;
      }
      var type = (TypeSyntax)reader.ReadValue();
      if (type != null)
      {
         AdjustFlagsAndWidth(type);
         this.type = type;
      }
      var explicitInterfaceSpecifier = (ExplicitInterfaceSpecifierSyntax)reader.ReadValue();
      if (explicitInterfaceSpecifier != null)
      {
         AdjustFlagsAndWidth(explicitInterfaceSpecifier);
         this.explicitInterfaceSpecifier = explicitInterfaceSpecifier;
      }
      var thisKeyword = (SyntaxToken)reader.ReadValue();
      if (thisKeyword != null)
      {
         AdjustFlagsAndWidth(thisKeyword);
         this.thisKeyword = thisKeyword;
      }
      var parameterList = (BracketedParameterListSyntax)reader.ReadValue();
      if (parameterList != null)
      {
         AdjustFlagsAndWidth(parameterList);
         this.parameterList = parameterList;
      }
      var accessorList = (AccessorListSyntax)reader.ReadValue();
      if (accessorList != null)
      {
         AdjustFlagsAndWidth(accessorList);
         this.accessorList = accessorList;
      }
      var expressionBody = (ArrowExpressionClauseSyntax)reader.ReadValue();
      if (expressionBody != null)
      {
         AdjustFlagsAndWidth(expressionBody);
         this.expressionBody = expressionBody;
      }
      var semicolonToken = (SyntaxToken)reader.ReadValue();
      if (semicolonToken != null)
      {
         AdjustFlagsAndWidth(semicolonToken);
         this.semicolonToken = semicolonToken;
      }
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.attributeLists);
      writer.WriteValue(this.modifiers);
      writer.WriteValue(this.type);
      writer.WriteValue(this.explicitInterfaceSpecifier);
      writer.WriteValue(this.thisKeyword);
      writer.WriteValue(this.parameterList);
      writer.WriteValue(this.accessorList);
      writer.WriteValue(this.expressionBody);
      writer.WriteValue(this.semicolonToken);
    }

    static IndexerDeclarationSyntax()
    {
       ObjectBinder.RegisterTypeReader(typeof(IndexerDeclarationSyntax), r => new IndexerDeclarationSyntax(r));
    }
  }

  internal sealed partial class AccessorListSyntax : CSharpSyntaxNode
  {
    internal readonly SyntaxToken openBraceToken;
    internal readonly GreenNode accessors;
    internal readonly SyntaxToken closeBraceToken;

    internal AccessorListSyntax(SyntaxKind kind, SyntaxToken openBraceToken, GreenNode accessors, SyntaxToken closeBraceToken, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 3;
        this.AdjustFlagsAndWidth(openBraceToken);
        this.openBraceToken = openBraceToken;
        if (accessors != null)
        {
            this.AdjustFlagsAndWidth(accessors);
            this.accessors = accessors;
        }
        this.AdjustFlagsAndWidth(closeBraceToken);
        this.closeBraceToken = closeBraceToken;
    }


    internal AccessorListSyntax(SyntaxKind kind, SyntaxToken openBraceToken, GreenNode accessors, SyntaxToken closeBraceToken, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 3;
        this.AdjustFlagsAndWidth(openBraceToken);
        this.openBraceToken = openBraceToken;
        if (accessors != null)
        {
            this.AdjustFlagsAndWidth(accessors);
            this.accessors = accessors;
        }
        this.AdjustFlagsAndWidth(closeBraceToken);
        this.closeBraceToken = closeBraceToken;
    }


    internal AccessorListSyntax(SyntaxKind kind, SyntaxToken openBraceToken, GreenNode accessors, SyntaxToken closeBraceToken)
        : base(kind)
    {
        this.SlotCount = 3;
        this.AdjustFlagsAndWidth(openBraceToken);
        this.openBraceToken = openBraceToken;
        if (accessors != null)
        {
            this.AdjustFlagsAndWidth(accessors);
            this.accessors = accessors;
        }
        this.AdjustFlagsAndWidth(closeBraceToken);
        this.closeBraceToken = closeBraceToken;
    }

    public SyntaxToken OpenBraceToken { get { return this.openBraceToken; } }
    public Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<AccessorDeclarationSyntax> Accessors { get { return new Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<AccessorDeclarationSyntax>(this.accessors); } }
    public SyntaxToken CloseBraceToken { get { return this.closeBraceToken; } }

    internal override GreenNode GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.openBraceToken;
            case 1: return this.accessors;
            case 2: return this.closeBraceToken;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode parent, int position)
    {
      return new CSharp.Syntax.AccessorListSyntax(this, parent, position);
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitAccessorList(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitAccessorList(this);
    }

    public AccessorListSyntax Update(SyntaxToken openBraceToken, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<AccessorDeclarationSyntax> accessors, SyntaxToken closeBraceToken)
    {
        if (openBraceToken != this.OpenBraceToken || accessors != this.Accessors || closeBraceToken != this.CloseBraceToken)
        {
            var newNode = SyntaxFactory.AccessorList(openBraceToken, accessors, closeBraceToken);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
    {
         return new AccessorListSyntax(this.Kind, this.openBraceToken, this.accessors, this.closeBraceToken, diagnostics, GetAnnotations());
    }

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
    {
         return new AccessorListSyntax(this.Kind, this.openBraceToken, this.accessors, this.closeBraceToken, GetDiagnostics(), annotations);
    }

    internal AccessorListSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 3;
      var openBraceToken = (SyntaxToken)reader.ReadValue();
      if (openBraceToken != null)
      {
         AdjustFlagsAndWidth(openBraceToken);
         this.openBraceToken = openBraceToken;
      }
      var accessors = (GreenNode)reader.ReadValue();
      if (accessors != null)
      {
         AdjustFlagsAndWidth(accessors);
         this.accessors = accessors;
      }
      var closeBraceToken = (SyntaxToken)reader.ReadValue();
      if (closeBraceToken != null)
      {
         AdjustFlagsAndWidth(closeBraceToken);
         this.closeBraceToken = closeBraceToken;
      }
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.openBraceToken);
      writer.WriteValue(this.accessors);
      writer.WriteValue(this.closeBraceToken);
    }

    static AccessorListSyntax()
    {
       ObjectBinder.RegisterTypeReader(typeof(AccessorListSyntax), r => new AccessorListSyntax(r));
    }
  }

  internal sealed partial class AccessorDeclarationSyntax : CSharpSyntaxNode
  {
    internal readonly GreenNode attributeLists;
    internal readonly GreenNode modifiers;
    internal readonly SyntaxToken keyword;
    internal readonly BlockSyntax body;
    internal readonly ArrowExpressionClauseSyntax expressionBody;
    internal readonly SyntaxToken semicolonToken;

    internal AccessorDeclarationSyntax(SyntaxKind kind, GreenNode attributeLists, GreenNode modifiers, SyntaxToken keyword, BlockSyntax body, ArrowExpressionClauseSyntax expressionBody, SyntaxToken semicolonToken, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 6;
        if (attributeLists != null)
        {
            this.AdjustFlagsAndWidth(attributeLists);
            this.attributeLists = attributeLists;
        }
        if (modifiers != null)
        {
            this.AdjustFlagsAndWidth(modifiers);
            this.modifiers = modifiers;
        }
        this.AdjustFlagsAndWidth(keyword);
        this.keyword = keyword;
        if (body != null)
        {
            this.AdjustFlagsAndWidth(body);
            this.body = body;
        }
        if (expressionBody != null)
        {
            this.AdjustFlagsAndWidth(expressionBody);
            this.expressionBody = expressionBody;
        }
        if (semicolonToken != null)
        {
            this.AdjustFlagsAndWidth(semicolonToken);
            this.semicolonToken = semicolonToken;
        }
    }


    internal AccessorDeclarationSyntax(SyntaxKind kind, GreenNode attributeLists, GreenNode modifiers, SyntaxToken keyword, BlockSyntax body, ArrowExpressionClauseSyntax expressionBody, SyntaxToken semicolonToken, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 6;
        if (attributeLists != null)
        {
            this.AdjustFlagsAndWidth(attributeLists);
            this.attributeLists = attributeLists;
        }
        if (modifiers != null)
        {
            this.AdjustFlagsAndWidth(modifiers);
            this.modifiers = modifiers;
        }
        this.AdjustFlagsAndWidth(keyword);
        this.keyword = keyword;
        if (body != null)
        {
            this.AdjustFlagsAndWidth(body);
            this.body = body;
        }
        if (expressionBody != null)
        {
            this.AdjustFlagsAndWidth(expressionBody);
            this.expressionBody = expressionBody;
        }
        if (semicolonToken != null)
        {
            this.AdjustFlagsAndWidth(semicolonToken);
            this.semicolonToken = semicolonToken;
        }
    }


    internal AccessorDeclarationSyntax(SyntaxKind kind, GreenNode attributeLists, GreenNode modifiers, SyntaxToken keyword, BlockSyntax body, ArrowExpressionClauseSyntax expressionBody, SyntaxToken semicolonToken)
        : base(kind)
    {
        this.SlotCount = 6;
        if (attributeLists != null)
        {
            this.AdjustFlagsAndWidth(attributeLists);
            this.attributeLists = attributeLists;
        }
        if (modifiers != null)
        {
            this.AdjustFlagsAndWidth(modifiers);
            this.modifiers = modifiers;
        }
        this.AdjustFlagsAndWidth(keyword);
        this.keyword = keyword;
        if (body != null)
        {
            this.AdjustFlagsAndWidth(body);
            this.body = body;
        }
        if (expressionBody != null)
        {
            this.AdjustFlagsAndWidth(expressionBody);
            this.expressionBody = expressionBody;
        }
        if (semicolonToken != null)
        {
            this.AdjustFlagsAndWidth(semicolonToken);
            this.semicolonToken = semicolonToken;
        }
    }

    /// <summary>Gets the attribute declaration list.</summary>
    public Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<AttributeListSyntax> AttributeLists { get { return new Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<AttributeListSyntax>(this.attributeLists); } }
    /// <summary>Gets the modifier list.</summary>
    public Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SyntaxToken> Modifiers { get { return new Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SyntaxToken>(this.modifiers); } }
    /// <summary>Gets the keyword token, or identifier if an erroneous accessor declaration.</summary>
    public SyntaxToken Keyword { get { return this.keyword; } }
    /// <summary>Gets the optional body block which may be empty, but it is null if there are no braces.</summary>
    public BlockSyntax Body { get { return this.body; } }
    /// <summary>Gets the optional expression body.</summary>
    public ArrowExpressionClauseSyntax ExpressionBody { get { return this.expressionBody; } }
    /// <summary>Gets the optional semicolon token.</summary>
    public SyntaxToken SemicolonToken { get { return this.semicolonToken; } }

    internal override GreenNode GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.attributeLists;
            case 1: return this.modifiers;
            case 2: return this.keyword;
            case 3: return this.body;
            case 4: return this.expressionBody;
            case 5: return this.semicolonToken;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode parent, int position)
    {
      return new CSharp.Syntax.AccessorDeclarationSyntax(this, parent, position);
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitAccessorDeclaration(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitAccessorDeclaration(this);
    }

    public AccessorDeclarationSyntax Update(Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<AttributeListSyntax> attributeLists, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SyntaxToken> modifiers, SyntaxToken keyword, BlockSyntax body, ArrowExpressionClauseSyntax expressionBody, SyntaxToken semicolonToken)
    {
        if (attributeLists != this.AttributeLists || modifiers != this.Modifiers || keyword != this.Keyword || body != this.Body || expressionBody != this.ExpressionBody || semicolonToken != this.SemicolonToken)
        {
            var newNode = SyntaxFactory.AccessorDeclaration(this.Kind, attributeLists, modifiers, keyword, body, expressionBody, semicolonToken);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
    {
         return new AccessorDeclarationSyntax(this.Kind, this.attributeLists, this.modifiers, this.keyword, this.body, this.expressionBody, this.semicolonToken, diagnostics, GetAnnotations());
    }

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
    {
         return new AccessorDeclarationSyntax(this.Kind, this.attributeLists, this.modifiers, this.keyword, this.body, this.expressionBody, this.semicolonToken, GetDiagnostics(), annotations);
    }

    internal AccessorDeclarationSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 6;
      var attributeLists = (GreenNode)reader.ReadValue();
      if (attributeLists != null)
      {
         AdjustFlagsAndWidth(attributeLists);
         this.attributeLists = attributeLists;
      }
      var modifiers = (GreenNode)reader.ReadValue();
      if (modifiers != null)
      {
         AdjustFlagsAndWidth(modifiers);
         this.modifiers = modifiers;
      }
      var keyword = (SyntaxToken)reader.ReadValue();
      if (keyword != null)
      {
         AdjustFlagsAndWidth(keyword);
         this.keyword = keyword;
      }
      var body = (BlockSyntax)reader.ReadValue();
      if (body != null)
      {
         AdjustFlagsAndWidth(body);
         this.body = body;
      }
      var expressionBody = (ArrowExpressionClauseSyntax)reader.ReadValue();
      if (expressionBody != null)
      {
         AdjustFlagsAndWidth(expressionBody);
         this.expressionBody = expressionBody;
      }
      var semicolonToken = (SyntaxToken)reader.ReadValue();
      if (semicolonToken != null)
      {
         AdjustFlagsAndWidth(semicolonToken);
         this.semicolonToken = semicolonToken;
      }
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.attributeLists);
      writer.WriteValue(this.modifiers);
      writer.WriteValue(this.keyword);
      writer.WriteValue(this.body);
      writer.WriteValue(this.expressionBody);
      writer.WriteValue(this.semicolonToken);
    }

    static AccessorDeclarationSyntax()
    {
       ObjectBinder.RegisterTypeReader(typeof(AccessorDeclarationSyntax), r => new AccessorDeclarationSyntax(r));
    }
  }

  /// <summary>Base type for parameter list syntax.</summary>
  internal abstract partial class BaseParameterListSyntax : CSharpSyntaxNode
  {
    internal BaseParameterListSyntax(SyntaxKind kind, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
      : base(kind, diagnostics, annotations)
    {
    }
    internal BaseParameterListSyntax(SyntaxKind kind)
      : base(kind)
    {
    }

    protected BaseParameterListSyntax(ObjectReader reader)
       : base(reader)
    {
    }

    /// <summary>Gets the parameter list.</summary>
    public abstract Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<ParameterSyntax> Parameters { get; }
  }

  /// <summary>Parameter list syntax.</summary>
  internal sealed partial class ParameterListSyntax : BaseParameterListSyntax
  {
    internal readonly SyntaxToken openParenToken;
    internal readonly GreenNode parameters;
    internal readonly SyntaxToken closeParenToken;

    internal ParameterListSyntax(SyntaxKind kind, SyntaxToken openParenToken, GreenNode parameters, SyntaxToken closeParenToken, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 3;
        this.AdjustFlagsAndWidth(openParenToken);
        this.openParenToken = openParenToken;
        if (parameters != null)
        {
            this.AdjustFlagsAndWidth(parameters);
            this.parameters = parameters;
        }
        this.AdjustFlagsAndWidth(closeParenToken);
        this.closeParenToken = closeParenToken;
    }


    internal ParameterListSyntax(SyntaxKind kind, SyntaxToken openParenToken, GreenNode parameters, SyntaxToken closeParenToken, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 3;
        this.AdjustFlagsAndWidth(openParenToken);
        this.openParenToken = openParenToken;
        if (parameters != null)
        {
            this.AdjustFlagsAndWidth(parameters);
            this.parameters = parameters;
        }
        this.AdjustFlagsAndWidth(closeParenToken);
        this.closeParenToken = closeParenToken;
    }


    internal ParameterListSyntax(SyntaxKind kind, SyntaxToken openParenToken, GreenNode parameters, SyntaxToken closeParenToken)
        : base(kind)
    {
        this.SlotCount = 3;
        this.AdjustFlagsAndWidth(openParenToken);
        this.openParenToken = openParenToken;
        if (parameters != null)
        {
            this.AdjustFlagsAndWidth(parameters);
            this.parameters = parameters;
        }
        this.AdjustFlagsAndWidth(closeParenToken);
        this.closeParenToken = closeParenToken;
    }

    /// <summary>Gets the open paren token.</summary>
    public SyntaxToken OpenParenToken { get { return this.openParenToken; } }
    public override Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<ParameterSyntax> Parameters { get { return new Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<ParameterSyntax>(new Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<CSharpSyntaxNode>(this.parameters)); } }
    /// <summary>Gets the close paren token.</summary>
    public SyntaxToken CloseParenToken { get { return this.closeParenToken; } }

    internal override GreenNode GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.openParenToken;
            case 1: return this.parameters;
            case 2: return this.closeParenToken;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode parent, int position)
    {
      return new CSharp.Syntax.ParameterListSyntax(this, parent, position);
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitParameterList(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitParameterList(this);
    }

    public ParameterListSyntax Update(SyntaxToken openParenToken, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<ParameterSyntax> parameters, SyntaxToken closeParenToken)
    {
        if (openParenToken != this.OpenParenToken || parameters != this.Parameters || closeParenToken != this.CloseParenToken)
        {
            var newNode = SyntaxFactory.ParameterList(openParenToken, parameters, closeParenToken);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
    {
         return new ParameterListSyntax(this.Kind, this.openParenToken, this.parameters, this.closeParenToken, diagnostics, GetAnnotations());
    }

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
    {
         return new ParameterListSyntax(this.Kind, this.openParenToken, this.parameters, this.closeParenToken, GetDiagnostics(), annotations);
    }

    internal ParameterListSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 3;
      var openParenToken = (SyntaxToken)reader.ReadValue();
      if (openParenToken != null)
      {
         AdjustFlagsAndWidth(openParenToken);
         this.openParenToken = openParenToken;
      }
      var parameters = (GreenNode)reader.ReadValue();
      if (parameters != null)
      {
         AdjustFlagsAndWidth(parameters);
         this.parameters = parameters;
      }
      var closeParenToken = (SyntaxToken)reader.ReadValue();
      if (closeParenToken != null)
      {
         AdjustFlagsAndWidth(closeParenToken);
         this.closeParenToken = closeParenToken;
      }
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.openParenToken);
      writer.WriteValue(this.parameters);
      writer.WriteValue(this.closeParenToken);
    }

    static ParameterListSyntax()
    {
       ObjectBinder.RegisterTypeReader(typeof(ParameterListSyntax), r => new ParameterListSyntax(r));
    }
  }

  /// <summary>Parameter list syntax with surrounding brackets.</summary>
  internal sealed partial class BracketedParameterListSyntax : BaseParameterListSyntax
  {
    internal readonly SyntaxToken openBracketToken;
    internal readonly GreenNode parameters;
    internal readonly SyntaxToken closeBracketToken;

    internal BracketedParameterListSyntax(SyntaxKind kind, SyntaxToken openBracketToken, GreenNode parameters, SyntaxToken closeBracketToken, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 3;
        this.AdjustFlagsAndWidth(openBracketToken);
        this.openBracketToken = openBracketToken;
        if (parameters != null)
        {
            this.AdjustFlagsAndWidth(parameters);
            this.parameters = parameters;
        }
        this.AdjustFlagsAndWidth(closeBracketToken);
        this.closeBracketToken = closeBracketToken;
    }


    internal BracketedParameterListSyntax(SyntaxKind kind, SyntaxToken openBracketToken, GreenNode parameters, SyntaxToken closeBracketToken, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 3;
        this.AdjustFlagsAndWidth(openBracketToken);
        this.openBracketToken = openBracketToken;
        if (parameters != null)
        {
            this.AdjustFlagsAndWidth(parameters);
            this.parameters = parameters;
        }
        this.AdjustFlagsAndWidth(closeBracketToken);
        this.closeBracketToken = closeBracketToken;
    }


    internal BracketedParameterListSyntax(SyntaxKind kind, SyntaxToken openBracketToken, GreenNode parameters, SyntaxToken closeBracketToken)
        : base(kind)
    {
        this.SlotCount = 3;
        this.AdjustFlagsAndWidth(openBracketToken);
        this.openBracketToken = openBracketToken;
        if (parameters != null)
        {
            this.AdjustFlagsAndWidth(parameters);
            this.parameters = parameters;
        }
        this.AdjustFlagsAndWidth(closeBracketToken);
        this.closeBracketToken = closeBracketToken;
    }

    /// <summary>Gets the open bracket token.</summary>
    public SyntaxToken OpenBracketToken { get { return this.openBracketToken; } }
    public override Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<ParameterSyntax> Parameters { get { return new Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<ParameterSyntax>(new Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<CSharpSyntaxNode>(this.parameters)); } }
    /// <summary>Gets the close bracket token.</summary>
    public SyntaxToken CloseBracketToken { get { return this.closeBracketToken; } }

    internal override GreenNode GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.openBracketToken;
            case 1: return this.parameters;
            case 2: return this.closeBracketToken;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode parent, int position)
    {
      return new CSharp.Syntax.BracketedParameterListSyntax(this, parent, position);
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitBracketedParameterList(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitBracketedParameterList(this);
    }

    public BracketedParameterListSyntax Update(SyntaxToken openBracketToken, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<ParameterSyntax> parameters, SyntaxToken closeBracketToken)
    {
        if (openBracketToken != this.OpenBracketToken || parameters != this.Parameters || closeBracketToken != this.CloseBracketToken)
        {
            var newNode = SyntaxFactory.BracketedParameterList(openBracketToken, parameters, closeBracketToken);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
    {
         return new BracketedParameterListSyntax(this.Kind, this.openBracketToken, this.parameters, this.closeBracketToken, diagnostics, GetAnnotations());
    }

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
    {
         return new BracketedParameterListSyntax(this.Kind, this.openBracketToken, this.parameters, this.closeBracketToken, GetDiagnostics(), annotations);
    }

    internal BracketedParameterListSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 3;
      var openBracketToken = (SyntaxToken)reader.ReadValue();
      if (openBracketToken != null)
      {
         AdjustFlagsAndWidth(openBracketToken);
         this.openBracketToken = openBracketToken;
      }
      var parameters = (GreenNode)reader.ReadValue();
      if (parameters != null)
      {
         AdjustFlagsAndWidth(parameters);
         this.parameters = parameters;
      }
      var closeBracketToken = (SyntaxToken)reader.ReadValue();
      if (closeBracketToken != null)
      {
         AdjustFlagsAndWidth(closeBracketToken);
         this.closeBracketToken = closeBracketToken;
      }
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.openBracketToken);
      writer.WriteValue(this.parameters);
      writer.WriteValue(this.closeBracketToken);
    }

    static BracketedParameterListSyntax()
    {
       ObjectBinder.RegisterTypeReader(typeof(BracketedParameterListSyntax), r => new BracketedParameterListSyntax(r));
    }
  }

  /// <summary>Parameter syntax.</summary>
  internal sealed partial class ParameterSyntax : CSharpSyntaxNode
  {
    internal readonly GreenNode attributeLists;
    internal readonly GreenNode modifiers;
    internal readonly TypeSyntax type;
    internal readonly SyntaxToken identifier;
    internal readonly EqualsValueClauseSyntax @default;

    internal ParameterSyntax(SyntaxKind kind, GreenNode attributeLists, GreenNode modifiers, TypeSyntax type, SyntaxToken identifier, EqualsValueClauseSyntax @default, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 5;
        if (attributeLists != null)
        {
            this.AdjustFlagsAndWidth(attributeLists);
            this.attributeLists = attributeLists;
        }
        if (modifiers != null)
        {
            this.AdjustFlagsAndWidth(modifiers);
            this.modifiers = modifiers;
        }
        if (type != null)
        {
            this.AdjustFlagsAndWidth(type);
            this.type = type;
        }
        this.AdjustFlagsAndWidth(identifier);
        this.identifier = identifier;
        if (@default != null)
        {
            this.AdjustFlagsAndWidth(@default);
            this.@default = @default;
        }
    }


    internal ParameterSyntax(SyntaxKind kind, GreenNode attributeLists, GreenNode modifiers, TypeSyntax type, SyntaxToken identifier, EqualsValueClauseSyntax @default, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 5;
        if (attributeLists != null)
        {
            this.AdjustFlagsAndWidth(attributeLists);
            this.attributeLists = attributeLists;
        }
        if (modifiers != null)
        {
            this.AdjustFlagsAndWidth(modifiers);
            this.modifiers = modifiers;
        }
        if (type != null)
        {
            this.AdjustFlagsAndWidth(type);
            this.type = type;
        }
        this.AdjustFlagsAndWidth(identifier);
        this.identifier = identifier;
        if (@default != null)
        {
            this.AdjustFlagsAndWidth(@default);
            this.@default = @default;
        }
    }


    internal ParameterSyntax(SyntaxKind kind, GreenNode attributeLists, GreenNode modifiers, TypeSyntax type, SyntaxToken identifier, EqualsValueClauseSyntax @default)
        : base(kind)
    {
        this.SlotCount = 5;
        if (attributeLists != null)
        {
            this.AdjustFlagsAndWidth(attributeLists);
            this.attributeLists = attributeLists;
        }
        if (modifiers != null)
        {
            this.AdjustFlagsAndWidth(modifiers);
            this.modifiers = modifiers;
        }
        if (type != null)
        {
            this.AdjustFlagsAndWidth(type);
            this.type = type;
        }
        this.AdjustFlagsAndWidth(identifier);
        this.identifier = identifier;
        if (@default != null)
        {
            this.AdjustFlagsAndWidth(@default);
            this.@default = @default;
        }
    }

    /// <summary>Gets the attribute declaration list.</summary>
    public Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<AttributeListSyntax> AttributeLists { get { return new Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<AttributeListSyntax>(this.attributeLists); } }
    /// <summary>Gets the modifier list.</summary>
    public Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SyntaxToken> Modifiers { get { return new Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SyntaxToken>(this.modifiers); } }
    public TypeSyntax Type { get { return this.type; } }
    /// <summary>Gets the identifier.</summary>
    public SyntaxToken Identifier { get { return this.identifier; } }
    public EqualsValueClauseSyntax Default { get { return this.@default; } }

    internal override GreenNode GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.attributeLists;
            case 1: return this.modifiers;
            case 2: return this.type;
            case 3: return this.identifier;
            case 4: return this.@default;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode parent, int position)
    {
      return new CSharp.Syntax.ParameterSyntax(this, parent, position);
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitParameter(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitParameter(this);
    }

    public ParameterSyntax Update(Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<AttributeListSyntax> attributeLists, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SyntaxToken> modifiers, TypeSyntax type, SyntaxToken identifier, EqualsValueClauseSyntax @default)
    {
        if (attributeLists != this.AttributeLists || modifiers != this.Modifiers || type != this.Type || identifier != this.Identifier || @default != this.Default)
        {
            var newNode = SyntaxFactory.Parameter(attributeLists, modifiers, type, identifier, @default);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
    {
         return new ParameterSyntax(this.Kind, this.attributeLists, this.modifiers, this.type, this.identifier, this.@default, diagnostics, GetAnnotations());
    }

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
    {
         return new ParameterSyntax(this.Kind, this.attributeLists, this.modifiers, this.type, this.identifier, this.@default, GetDiagnostics(), annotations);
    }

    internal ParameterSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 5;
      var attributeLists = (GreenNode)reader.ReadValue();
      if (attributeLists != null)
      {
         AdjustFlagsAndWidth(attributeLists);
         this.attributeLists = attributeLists;
      }
      var modifiers = (GreenNode)reader.ReadValue();
      if (modifiers != null)
      {
         AdjustFlagsAndWidth(modifiers);
         this.modifiers = modifiers;
      }
      var type = (TypeSyntax)reader.ReadValue();
      if (type != null)
      {
         AdjustFlagsAndWidth(type);
         this.type = type;
      }
      var identifier = (SyntaxToken)reader.ReadValue();
      if (identifier != null)
      {
         AdjustFlagsAndWidth(identifier);
         this.identifier = identifier;
      }
      var @default = (EqualsValueClauseSyntax)reader.ReadValue();
      if (@default != null)
      {
         AdjustFlagsAndWidth(@default);
         this.@default = @default;
      }
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.attributeLists);
      writer.WriteValue(this.modifiers);
      writer.WriteValue(this.type);
      writer.WriteValue(this.identifier);
      writer.WriteValue(this.@default);
    }

    static ParameterSyntax()
    {
       ObjectBinder.RegisterTypeReader(typeof(ParameterSyntax), r => new ParameterSyntax(r));
    }
  }

  internal sealed partial class IncompleteMemberSyntax : MemberDeclarationSyntax
  {
    internal readonly GreenNode attributeLists;
    internal readonly GreenNode modifiers;
    internal readonly TypeSyntax type;

    internal IncompleteMemberSyntax(SyntaxKind kind, GreenNode attributeLists, GreenNode modifiers, TypeSyntax type, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 3;
        if (attributeLists != null)
        {
            this.AdjustFlagsAndWidth(attributeLists);
            this.attributeLists = attributeLists;
        }
        if (modifiers != null)
        {
            this.AdjustFlagsAndWidth(modifiers);
            this.modifiers = modifiers;
        }
        if (type != null)
        {
            this.AdjustFlagsAndWidth(type);
            this.type = type;
        }
    }


    internal IncompleteMemberSyntax(SyntaxKind kind, GreenNode attributeLists, GreenNode modifiers, TypeSyntax type, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 3;
        if (attributeLists != null)
        {
            this.AdjustFlagsAndWidth(attributeLists);
            this.attributeLists = attributeLists;
        }
        if (modifiers != null)
        {
            this.AdjustFlagsAndWidth(modifiers);
            this.modifiers = modifiers;
        }
        if (type != null)
        {
            this.AdjustFlagsAndWidth(type);
            this.type = type;
        }
    }


    internal IncompleteMemberSyntax(SyntaxKind kind, GreenNode attributeLists, GreenNode modifiers, TypeSyntax type)
        : base(kind)
    {
        this.SlotCount = 3;
        if (attributeLists != null)
        {
            this.AdjustFlagsAndWidth(attributeLists);
            this.attributeLists = attributeLists;
        }
        if (modifiers != null)
        {
            this.AdjustFlagsAndWidth(modifiers);
            this.modifiers = modifiers;
        }
        if (type != null)
        {
            this.AdjustFlagsAndWidth(type);
            this.type = type;
        }
    }

    /// <summary>Gets the attribute declaration list.</summary>
    public Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<AttributeListSyntax> AttributeLists { get { return new Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<AttributeListSyntax>(this.attributeLists); } }
    /// <summary>Gets the modifier list.</summary>
    public Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SyntaxToken> Modifiers { get { return new Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SyntaxToken>(this.modifiers); } }
    public TypeSyntax Type { get { return this.type; } }

    internal override GreenNode GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.attributeLists;
            case 1: return this.modifiers;
            case 2: return this.type;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode parent, int position)
    {
      return new CSharp.Syntax.IncompleteMemberSyntax(this, parent, position);
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitIncompleteMember(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitIncompleteMember(this);
    }

    public IncompleteMemberSyntax Update(Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<AttributeListSyntax> attributeLists, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SyntaxToken> modifiers, TypeSyntax type)
    {
        if (attributeLists != this.AttributeLists || modifiers != this.Modifiers || type != this.Type)
        {
            var newNode = SyntaxFactory.IncompleteMember(attributeLists, modifiers, type);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
    {
         return new IncompleteMemberSyntax(this.Kind, this.attributeLists, this.modifiers, this.type, diagnostics, GetAnnotations());
    }

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
    {
         return new IncompleteMemberSyntax(this.Kind, this.attributeLists, this.modifiers, this.type, GetDiagnostics(), annotations);
    }

    internal IncompleteMemberSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 3;
      var attributeLists = (GreenNode)reader.ReadValue();
      if (attributeLists != null)
      {
         AdjustFlagsAndWidth(attributeLists);
         this.attributeLists = attributeLists;
      }
      var modifiers = (GreenNode)reader.ReadValue();
      if (modifiers != null)
      {
         AdjustFlagsAndWidth(modifiers);
         this.modifiers = modifiers;
      }
      var type = (TypeSyntax)reader.ReadValue();
      if (type != null)
      {
         AdjustFlagsAndWidth(type);
         this.type = type;
      }
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.attributeLists);
      writer.WriteValue(this.modifiers);
      writer.WriteValue(this.type);
    }

    static IncompleteMemberSyntax()
    {
       ObjectBinder.RegisterTypeReader(typeof(IncompleteMemberSyntax), r => new IncompleteMemberSyntax(r));
    }
  }

  internal sealed partial class SkippedTokensTriviaSyntax : StructuredTriviaSyntax
  {
    internal readonly GreenNode tokens;

    internal SkippedTokensTriviaSyntax(SyntaxKind kind, GreenNode tokens, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 1;
        if (tokens != null)
        {
            this.AdjustFlagsAndWidth(tokens);
            this.tokens = tokens;
        }
    }


    internal SkippedTokensTriviaSyntax(SyntaxKind kind, GreenNode tokens, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 1;
        if (tokens != null)
        {
            this.AdjustFlagsAndWidth(tokens);
            this.tokens = tokens;
        }
    }


    internal SkippedTokensTriviaSyntax(SyntaxKind kind, GreenNode tokens)
        : base(kind)
    {
        this.SlotCount = 1;
        if (tokens != null)
        {
            this.AdjustFlagsAndWidth(tokens);
            this.tokens = tokens;
        }
    }

    public Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SyntaxToken> Tokens { get { return new Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SyntaxToken>(this.tokens); } }

    internal override GreenNode GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.tokens;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode parent, int position)
    {
      return new CSharp.Syntax.SkippedTokensTriviaSyntax(this, parent, position);
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitSkippedTokensTrivia(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitSkippedTokensTrivia(this);
    }

    public SkippedTokensTriviaSyntax Update(Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SyntaxToken> tokens)
    {
        if (tokens != this.Tokens)
        {
            var newNode = SyntaxFactory.SkippedTokensTrivia(tokens);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
    {
         return new SkippedTokensTriviaSyntax(this.Kind, this.tokens, diagnostics, GetAnnotations());
    }

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
    {
         return new SkippedTokensTriviaSyntax(this.Kind, this.tokens, GetDiagnostics(), annotations);
    }

    internal SkippedTokensTriviaSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 1;
      var tokens = (GreenNode)reader.ReadValue();
      if (tokens != null)
      {
         AdjustFlagsAndWidth(tokens);
         this.tokens = tokens;
      }
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.tokens);
    }

    static SkippedTokensTriviaSyntax()
    {
       ObjectBinder.RegisterTypeReader(typeof(SkippedTokensTriviaSyntax), r => new SkippedTokensTriviaSyntax(r));
    }
  }

  internal sealed partial class DocumentationCommentTriviaSyntax : StructuredTriviaSyntax
  {
    internal readonly GreenNode content;
    internal readonly SyntaxToken endOfComment;

    internal DocumentationCommentTriviaSyntax(SyntaxKind kind, GreenNode content, SyntaxToken endOfComment, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 2;
        if (content != null)
        {
            this.AdjustFlagsAndWidth(content);
            this.content = content;
        }
        this.AdjustFlagsAndWidth(endOfComment);
        this.endOfComment = endOfComment;
    }


    internal DocumentationCommentTriviaSyntax(SyntaxKind kind, GreenNode content, SyntaxToken endOfComment, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 2;
        if (content != null)
        {
            this.AdjustFlagsAndWidth(content);
            this.content = content;
        }
        this.AdjustFlagsAndWidth(endOfComment);
        this.endOfComment = endOfComment;
    }


    internal DocumentationCommentTriviaSyntax(SyntaxKind kind, GreenNode content, SyntaxToken endOfComment)
        : base(kind)
    {
        this.SlotCount = 2;
        if (content != null)
        {
            this.AdjustFlagsAndWidth(content);
            this.content = content;
        }
        this.AdjustFlagsAndWidth(endOfComment);
        this.endOfComment = endOfComment;
    }

    public Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<XmlNodeSyntax> Content { get { return new Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<XmlNodeSyntax>(this.content); } }
    public SyntaxToken EndOfComment { get { return this.endOfComment; } }

    internal override GreenNode GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.content;
            case 1: return this.endOfComment;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode parent, int position)
    {
      return new CSharp.Syntax.DocumentationCommentTriviaSyntax(this, parent, position);
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitDocumentationCommentTrivia(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitDocumentationCommentTrivia(this);
    }

    public DocumentationCommentTriviaSyntax Update(Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<XmlNodeSyntax> content, SyntaxToken endOfComment)
    {
        if (content != this.Content || endOfComment != this.EndOfComment)
        {
            var newNode = SyntaxFactory.DocumentationCommentTrivia(this.Kind, content, endOfComment);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
    {
         return new DocumentationCommentTriviaSyntax(this.Kind, this.content, this.endOfComment, diagnostics, GetAnnotations());
    }

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
    {
         return new DocumentationCommentTriviaSyntax(this.Kind, this.content, this.endOfComment, GetDiagnostics(), annotations);
    }

    internal DocumentationCommentTriviaSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 2;
      var content = (GreenNode)reader.ReadValue();
      if (content != null)
      {
         AdjustFlagsAndWidth(content);
         this.content = content;
      }
      var endOfComment = (SyntaxToken)reader.ReadValue();
      if (endOfComment != null)
      {
         AdjustFlagsAndWidth(endOfComment);
         this.endOfComment = endOfComment;
      }
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.content);
      writer.WriteValue(this.endOfComment);
    }

    static DocumentationCommentTriviaSyntax()
    {
       ObjectBinder.RegisterTypeReader(typeof(DocumentationCommentTriviaSyntax), r => new DocumentationCommentTriviaSyntax(r));
    }
  }

  /// <summary>
  /// A symbol referenced by a cref attribute (e.g. in a &lt;see&gt; or &lt;seealso&gt; documentation comment tag).
  /// For example, the M in &lt;see cref="M" /&gt;.
  /// </summary>
  internal abstract partial class CrefSyntax : CSharpSyntaxNode
  {
    internal CrefSyntax(SyntaxKind kind, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
      : base(kind, diagnostics, annotations)
    {
    }
    internal CrefSyntax(SyntaxKind kind)
      : base(kind)
    {
    }

    protected CrefSyntax(ObjectReader reader)
       : base(reader)
    {
    }
  }

  /// <summary>
  /// A symbol reference that definitely refers to a type.
  /// For example, "int", "A::B", "A.B", "A&lt;T&gt;", but not "M()" (has parameter list) or "this" (indexer).
  /// NOTE: TypeCrefSyntax, QualifiedCrefSyntax, and MemberCrefSyntax overlap.  The syntax in a TypeCrefSyntax
  /// will always be bound as type, so it's safer to use QualifiedCrefSyntax or MemberCrefSyntax if the symbol
  /// might be a non-type member.
  /// </summary>
  internal sealed partial class TypeCrefSyntax : CrefSyntax
  {
    internal readonly TypeSyntax type;

    internal TypeCrefSyntax(SyntaxKind kind, TypeSyntax type, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 1;
        this.AdjustFlagsAndWidth(type);
        this.type = type;
    }


    internal TypeCrefSyntax(SyntaxKind kind, TypeSyntax type, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 1;
        this.AdjustFlagsAndWidth(type);
        this.type = type;
    }


    internal TypeCrefSyntax(SyntaxKind kind, TypeSyntax type)
        : base(kind)
    {
        this.SlotCount = 1;
        this.AdjustFlagsAndWidth(type);
        this.type = type;
    }

    public TypeSyntax Type { get { return this.type; } }

    internal override GreenNode GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.type;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode parent, int position)
    {
      return new CSharp.Syntax.TypeCrefSyntax(this, parent, position);
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitTypeCref(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitTypeCref(this);
    }

    public TypeCrefSyntax Update(TypeSyntax type)
    {
        if (type != this.Type)
        {
            var newNode = SyntaxFactory.TypeCref(type);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
    {
         return new TypeCrefSyntax(this.Kind, this.type, diagnostics, GetAnnotations());
    }

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
    {
         return new TypeCrefSyntax(this.Kind, this.type, GetDiagnostics(), annotations);
    }

    internal TypeCrefSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 1;
      var type = (TypeSyntax)reader.ReadValue();
      if (type != null)
      {
         AdjustFlagsAndWidth(type);
         this.type = type;
      }
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.type);
    }

    static TypeCrefSyntax()
    {
       ObjectBinder.RegisterTypeReader(typeof(TypeCrefSyntax), r => new TypeCrefSyntax(r));
    }
  }

  /// <summary>
  /// A symbol reference to a type or non-type member that is qualified by an enclosing type or namespace.
  /// For example, cref="System.String.ToString()".
  /// NOTE: TypeCrefSyntax, QualifiedCrefSyntax, and MemberCrefSyntax overlap.  The syntax in a TypeCrefSyntax
  /// will always be bound as type, so it's safer to use QualifiedCrefSyntax or MemberCrefSyntax if the symbol
  /// might be a non-type member.
  /// </summary>
  internal sealed partial class QualifiedCrefSyntax : CrefSyntax
  {
    internal readonly TypeSyntax container;
    internal readonly SyntaxToken dotToken;
    internal readonly MemberCrefSyntax member;

    internal QualifiedCrefSyntax(SyntaxKind kind, TypeSyntax container, SyntaxToken dotToken, MemberCrefSyntax member, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 3;
        this.AdjustFlagsAndWidth(container);
        this.container = container;
        this.AdjustFlagsAndWidth(dotToken);
        this.dotToken = dotToken;
        this.AdjustFlagsAndWidth(member);
        this.member = member;
    }


    internal QualifiedCrefSyntax(SyntaxKind kind, TypeSyntax container, SyntaxToken dotToken, MemberCrefSyntax member, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 3;
        this.AdjustFlagsAndWidth(container);
        this.container = container;
        this.AdjustFlagsAndWidth(dotToken);
        this.dotToken = dotToken;
        this.AdjustFlagsAndWidth(member);
        this.member = member;
    }


    internal QualifiedCrefSyntax(SyntaxKind kind, TypeSyntax container, SyntaxToken dotToken, MemberCrefSyntax member)
        : base(kind)
    {
        this.SlotCount = 3;
        this.AdjustFlagsAndWidth(container);
        this.container = container;
        this.AdjustFlagsAndWidth(dotToken);
        this.dotToken = dotToken;
        this.AdjustFlagsAndWidth(member);
        this.member = member;
    }

    public TypeSyntax Container { get { return this.container; } }
    public SyntaxToken DotToken { get { return this.dotToken; } }
    public MemberCrefSyntax Member { get { return this.member; } }

    internal override GreenNode GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.container;
            case 1: return this.dotToken;
            case 2: return this.member;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode parent, int position)
    {
      return new CSharp.Syntax.QualifiedCrefSyntax(this, parent, position);
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitQualifiedCref(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitQualifiedCref(this);
    }

    public QualifiedCrefSyntax Update(TypeSyntax container, SyntaxToken dotToken, MemberCrefSyntax member)
    {
        if (container != this.Container || dotToken != this.DotToken || member != this.Member)
        {
            var newNode = SyntaxFactory.QualifiedCref(container, dotToken, member);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
    {
         return new QualifiedCrefSyntax(this.Kind, this.container, this.dotToken, this.member, diagnostics, GetAnnotations());
    }

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
    {
         return new QualifiedCrefSyntax(this.Kind, this.container, this.dotToken, this.member, GetDiagnostics(), annotations);
    }

    internal QualifiedCrefSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 3;
      var container = (TypeSyntax)reader.ReadValue();
      if (container != null)
      {
         AdjustFlagsAndWidth(container);
         this.container = container;
      }
      var dotToken = (SyntaxToken)reader.ReadValue();
      if (dotToken != null)
      {
         AdjustFlagsAndWidth(dotToken);
         this.dotToken = dotToken;
      }
      var member = (MemberCrefSyntax)reader.ReadValue();
      if (member != null)
      {
         AdjustFlagsAndWidth(member);
         this.member = member;
      }
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.container);
      writer.WriteValue(this.dotToken);
      writer.WriteValue(this.member);
    }

    static QualifiedCrefSyntax()
    {
       ObjectBinder.RegisterTypeReader(typeof(QualifiedCrefSyntax), r => new QualifiedCrefSyntax(r));
    }
  }

  /// <summary>
  /// The unqualified part of a CrefSyntax.
  /// For example, "ToString()" in "object.ToString()".
  /// NOTE: TypeCrefSyntax, QualifiedCrefSyntax, and MemberCrefSyntax overlap.  The syntax in a TypeCrefSyntax
  /// will always be bound as type, so it's safer to use QualifiedCrefSyntax or MemberCrefSyntax if the symbol
  /// might be a non-type member.
  /// </summary>
  internal abstract partial class MemberCrefSyntax : CrefSyntax
  {
    internal MemberCrefSyntax(SyntaxKind kind, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
      : base(kind, diagnostics, annotations)
    {
    }
    internal MemberCrefSyntax(SyntaxKind kind)
      : base(kind)
    {
    }

    protected MemberCrefSyntax(ObjectReader reader)
       : base(reader)
    {
    }
  }

  /// <summary>
  /// A MemberCrefSyntax specified by a name (an identifier, predefined type keyword, or an alias-qualified name,
  /// with an optional type parameter list) and an optional parameter list.
  /// For example, "M", "M&lt;T&gt;" or "M(int)".
  /// Also, "A::B()" or "string()".
  /// </summary>
  internal sealed partial class NameMemberCrefSyntax : MemberCrefSyntax
  {
    internal readonly TypeSyntax name;
    internal readonly CrefParameterListSyntax parameters;

    internal NameMemberCrefSyntax(SyntaxKind kind, TypeSyntax name, CrefParameterListSyntax parameters, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 2;
        this.AdjustFlagsAndWidth(name);
        this.name = name;
        if (parameters != null)
        {
            this.AdjustFlagsAndWidth(parameters);
            this.parameters = parameters;
        }
    }


    internal NameMemberCrefSyntax(SyntaxKind kind, TypeSyntax name, CrefParameterListSyntax parameters, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 2;
        this.AdjustFlagsAndWidth(name);
        this.name = name;
        if (parameters != null)
        {
            this.AdjustFlagsAndWidth(parameters);
            this.parameters = parameters;
        }
    }


    internal NameMemberCrefSyntax(SyntaxKind kind, TypeSyntax name, CrefParameterListSyntax parameters)
        : base(kind)
    {
        this.SlotCount = 2;
        this.AdjustFlagsAndWidth(name);
        this.name = name;
        if (parameters != null)
        {
            this.AdjustFlagsAndWidth(parameters);
            this.parameters = parameters;
        }
    }

    public TypeSyntax Name { get { return this.name; } }
    public CrefParameterListSyntax Parameters { get { return this.parameters; } }

    internal override GreenNode GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.name;
            case 1: return this.parameters;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode parent, int position)
    {
      return new CSharp.Syntax.NameMemberCrefSyntax(this, parent, position);
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitNameMemberCref(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitNameMemberCref(this);
    }

    public NameMemberCrefSyntax Update(TypeSyntax name, CrefParameterListSyntax parameters)
    {
        if (name != this.Name || parameters != this.Parameters)
        {
            var newNode = SyntaxFactory.NameMemberCref(name, parameters);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
    {
         return new NameMemberCrefSyntax(this.Kind, this.name, this.parameters, diagnostics, GetAnnotations());
    }

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
    {
         return new NameMemberCrefSyntax(this.Kind, this.name, this.parameters, GetDiagnostics(), annotations);
    }

    internal NameMemberCrefSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 2;
      var name = (TypeSyntax)reader.ReadValue();
      if (name != null)
      {
         AdjustFlagsAndWidth(name);
         this.name = name;
      }
      var parameters = (CrefParameterListSyntax)reader.ReadValue();
      if (parameters != null)
      {
         AdjustFlagsAndWidth(parameters);
         this.parameters = parameters;
      }
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.name);
      writer.WriteValue(this.parameters);
    }

    static NameMemberCrefSyntax()
    {
       ObjectBinder.RegisterTypeReader(typeof(NameMemberCrefSyntax), r => new NameMemberCrefSyntax(r));
    }
  }

  /// <summary>
  /// A MemberCrefSyntax specified by a this keyword and an optional parameter list.
  /// For example, "this" or "this[int]".
  /// </summary>
  internal sealed partial class IndexerMemberCrefSyntax : MemberCrefSyntax
  {
    internal readonly SyntaxToken thisKeyword;
    internal readonly CrefBracketedParameterListSyntax parameters;

    internal IndexerMemberCrefSyntax(SyntaxKind kind, SyntaxToken thisKeyword, CrefBracketedParameterListSyntax parameters, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 2;
        this.AdjustFlagsAndWidth(thisKeyword);
        this.thisKeyword = thisKeyword;
        if (parameters != null)
        {
            this.AdjustFlagsAndWidth(parameters);
            this.parameters = parameters;
        }
    }


    internal IndexerMemberCrefSyntax(SyntaxKind kind, SyntaxToken thisKeyword, CrefBracketedParameterListSyntax parameters, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 2;
        this.AdjustFlagsAndWidth(thisKeyword);
        this.thisKeyword = thisKeyword;
        if (parameters != null)
        {
            this.AdjustFlagsAndWidth(parameters);
            this.parameters = parameters;
        }
    }


    internal IndexerMemberCrefSyntax(SyntaxKind kind, SyntaxToken thisKeyword, CrefBracketedParameterListSyntax parameters)
        : base(kind)
    {
        this.SlotCount = 2;
        this.AdjustFlagsAndWidth(thisKeyword);
        this.thisKeyword = thisKeyword;
        if (parameters != null)
        {
            this.AdjustFlagsAndWidth(parameters);
            this.parameters = parameters;
        }
    }

    public SyntaxToken ThisKeyword { get { return this.thisKeyword; } }
    public CrefBracketedParameterListSyntax Parameters { get { return this.parameters; } }

    internal override GreenNode GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.thisKeyword;
            case 1: return this.parameters;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode parent, int position)
    {
      return new CSharp.Syntax.IndexerMemberCrefSyntax(this, parent, position);
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitIndexerMemberCref(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitIndexerMemberCref(this);
    }

    public IndexerMemberCrefSyntax Update(SyntaxToken thisKeyword, CrefBracketedParameterListSyntax parameters)
    {
        if (thisKeyword != this.ThisKeyword || parameters != this.Parameters)
        {
            var newNode = SyntaxFactory.IndexerMemberCref(thisKeyword, parameters);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
    {
         return new IndexerMemberCrefSyntax(this.Kind, this.thisKeyword, this.parameters, diagnostics, GetAnnotations());
    }

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
    {
         return new IndexerMemberCrefSyntax(this.Kind, this.thisKeyword, this.parameters, GetDiagnostics(), annotations);
    }

    internal IndexerMemberCrefSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 2;
      var thisKeyword = (SyntaxToken)reader.ReadValue();
      if (thisKeyword != null)
      {
         AdjustFlagsAndWidth(thisKeyword);
         this.thisKeyword = thisKeyword;
      }
      var parameters = (CrefBracketedParameterListSyntax)reader.ReadValue();
      if (parameters != null)
      {
         AdjustFlagsAndWidth(parameters);
         this.parameters = parameters;
      }
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.thisKeyword);
      writer.WriteValue(this.parameters);
    }

    static IndexerMemberCrefSyntax()
    {
       ObjectBinder.RegisterTypeReader(typeof(IndexerMemberCrefSyntax), r => new IndexerMemberCrefSyntax(r));
    }
  }

  /// <summary>
  /// A MemberCrefSyntax specified by an operator keyword, an operator symbol and an optional parameter list.
  /// For example, "operator +" or "operator -[int]".
  /// NOTE: the operator must be overloadable.
  /// </summary>
  internal sealed partial class OperatorMemberCrefSyntax : MemberCrefSyntax
  {
    internal readonly SyntaxToken operatorKeyword;
    internal readonly SyntaxToken operatorToken;
    internal readonly CrefParameterListSyntax parameters;

    internal OperatorMemberCrefSyntax(SyntaxKind kind, SyntaxToken operatorKeyword, SyntaxToken operatorToken, CrefParameterListSyntax parameters, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 3;
        this.AdjustFlagsAndWidth(operatorKeyword);
        this.operatorKeyword = operatorKeyword;
        this.AdjustFlagsAndWidth(operatorToken);
        this.operatorToken = operatorToken;
        if (parameters != null)
        {
            this.AdjustFlagsAndWidth(parameters);
            this.parameters = parameters;
        }
    }


    internal OperatorMemberCrefSyntax(SyntaxKind kind, SyntaxToken operatorKeyword, SyntaxToken operatorToken, CrefParameterListSyntax parameters, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 3;
        this.AdjustFlagsAndWidth(operatorKeyword);
        this.operatorKeyword = operatorKeyword;
        this.AdjustFlagsAndWidth(operatorToken);
        this.operatorToken = operatorToken;
        if (parameters != null)
        {
            this.AdjustFlagsAndWidth(parameters);
            this.parameters = parameters;
        }
    }


    internal OperatorMemberCrefSyntax(SyntaxKind kind, SyntaxToken operatorKeyword, SyntaxToken operatorToken, CrefParameterListSyntax parameters)
        : base(kind)
    {
        this.SlotCount = 3;
        this.AdjustFlagsAndWidth(operatorKeyword);
        this.operatorKeyword = operatorKeyword;
        this.AdjustFlagsAndWidth(operatorToken);
        this.operatorToken = operatorToken;
        if (parameters != null)
        {
            this.AdjustFlagsAndWidth(parameters);
            this.parameters = parameters;
        }
    }

    public SyntaxToken OperatorKeyword { get { return this.operatorKeyword; } }
    /// <summary>Gets the operator token.</summary>
    public SyntaxToken OperatorToken { get { return this.operatorToken; } }
    public CrefParameterListSyntax Parameters { get { return this.parameters; } }

    internal override GreenNode GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.operatorKeyword;
            case 1: return this.operatorToken;
            case 2: return this.parameters;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode parent, int position)
    {
      return new CSharp.Syntax.OperatorMemberCrefSyntax(this, parent, position);
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitOperatorMemberCref(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitOperatorMemberCref(this);
    }

    public OperatorMemberCrefSyntax Update(SyntaxToken operatorKeyword, SyntaxToken operatorToken, CrefParameterListSyntax parameters)
    {
        if (operatorKeyword != this.OperatorKeyword || operatorToken != this.OperatorToken || parameters != this.Parameters)
        {
            var newNode = SyntaxFactory.OperatorMemberCref(operatorKeyword, operatorToken, parameters);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
    {
         return new OperatorMemberCrefSyntax(this.Kind, this.operatorKeyword, this.operatorToken, this.parameters, diagnostics, GetAnnotations());
    }

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
    {
         return new OperatorMemberCrefSyntax(this.Kind, this.operatorKeyword, this.operatorToken, this.parameters, GetDiagnostics(), annotations);
    }

    internal OperatorMemberCrefSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 3;
      var operatorKeyword = (SyntaxToken)reader.ReadValue();
      if (operatorKeyword != null)
      {
         AdjustFlagsAndWidth(operatorKeyword);
         this.operatorKeyword = operatorKeyword;
      }
      var operatorToken = (SyntaxToken)reader.ReadValue();
      if (operatorToken != null)
      {
         AdjustFlagsAndWidth(operatorToken);
         this.operatorToken = operatorToken;
      }
      var parameters = (CrefParameterListSyntax)reader.ReadValue();
      if (parameters != null)
      {
         AdjustFlagsAndWidth(parameters);
         this.parameters = parameters;
      }
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.operatorKeyword);
      writer.WriteValue(this.operatorToken);
      writer.WriteValue(this.parameters);
    }

    static OperatorMemberCrefSyntax()
    {
       ObjectBinder.RegisterTypeReader(typeof(OperatorMemberCrefSyntax), r => new OperatorMemberCrefSyntax(r));
    }
  }

  /// <summary>
  /// A MemberCrefSyntax specified by an implicit or explicit keyword, an operator keyword, a destination type, and an optional parameter list.
  /// For example, "implicit operator int" or "explicit operator MyType(int)".
  /// </summary>
  internal sealed partial class ConversionOperatorMemberCrefSyntax : MemberCrefSyntax
  {
    internal readonly SyntaxToken implicitOrExplicitKeyword;
    internal readonly SyntaxToken operatorKeyword;
    internal readonly TypeSyntax type;
    internal readonly CrefParameterListSyntax parameters;

    internal ConversionOperatorMemberCrefSyntax(SyntaxKind kind, SyntaxToken implicitOrExplicitKeyword, SyntaxToken operatorKeyword, TypeSyntax type, CrefParameterListSyntax parameters, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 4;
        this.AdjustFlagsAndWidth(implicitOrExplicitKeyword);
        this.implicitOrExplicitKeyword = implicitOrExplicitKeyword;
        this.AdjustFlagsAndWidth(operatorKeyword);
        this.operatorKeyword = operatorKeyword;
        this.AdjustFlagsAndWidth(type);
        this.type = type;
        if (parameters != null)
        {
            this.AdjustFlagsAndWidth(parameters);
            this.parameters = parameters;
        }
    }


    internal ConversionOperatorMemberCrefSyntax(SyntaxKind kind, SyntaxToken implicitOrExplicitKeyword, SyntaxToken operatorKeyword, TypeSyntax type, CrefParameterListSyntax parameters, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 4;
        this.AdjustFlagsAndWidth(implicitOrExplicitKeyword);
        this.implicitOrExplicitKeyword = implicitOrExplicitKeyword;
        this.AdjustFlagsAndWidth(operatorKeyword);
        this.operatorKeyword = operatorKeyword;
        this.AdjustFlagsAndWidth(type);
        this.type = type;
        if (parameters != null)
        {
            this.AdjustFlagsAndWidth(parameters);
            this.parameters = parameters;
        }
    }


    internal ConversionOperatorMemberCrefSyntax(SyntaxKind kind, SyntaxToken implicitOrExplicitKeyword, SyntaxToken operatorKeyword, TypeSyntax type, CrefParameterListSyntax parameters)
        : base(kind)
    {
        this.SlotCount = 4;
        this.AdjustFlagsAndWidth(implicitOrExplicitKeyword);
        this.implicitOrExplicitKeyword = implicitOrExplicitKeyword;
        this.AdjustFlagsAndWidth(operatorKeyword);
        this.operatorKeyword = operatorKeyword;
        this.AdjustFlagsAndWidth(type);
        this.type = type;
        if (parameters != null)
        {
            this.AdjustFlagsAndWidth(parameters);
            this.parameters = parameters;
        }
    }

    public SyntaxToken ImplicitOrExplicitKeyword { get { return this.implicitOrExplicitKeyword; } }
    public SyntaxToken OperatorKeyword { get { return this.operatorKeyword; } }
    public TypeSyntax Type { get { return this.type; } }
    public CrefParameterListSyntax Parameters { get { return this.parameters; } }

    internal override GreenNode GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.implicitOrExplicitKeyword;
            case 1: return this.operatorKeyword;
            case 2: return this.type;
            case 3: return this.parameters;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode parent, int position)
    {
      return new CSharp.Syntax.ConversionOperatorMemberCrefSyntax(this, parent, position);
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitConversionOperatorMemberCref(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitConversionOperatorMemberCref(this);
    }

    public ConversionOperatorMemberCrefSyntax Update(SyntaxToken implicitOrExplicitKeyword, SyntaxToken operatorKeyword, TypeSyntax type, CrefParameterListSyntax parameters)
    {
        if (implicitOrExplicitKeyword != this.ImplicitOrExplicitKeyword || operatorKeyword != this.OperatorKeyword || type != this.Type || parameters != this.Parameters)
        {
            var newNode = SyntaxFactory.ConversionOperatorMemberCref(implicitOrExplicitKeyword, operatorKeyword, type, parameters);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
    {
         return new ConversionOperatorMemberCrefSyntax(this.Kind, this.implicitOrExplicitKeyword, this.operatorKeyword, this.type, this.parameters, diagnostics, GetAnnotations());
    }

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
    {
         return new ConversionOperatorMemberCrefSyntax(this.Kind, this.implicitOrExplicitKeyword, this.operatorKeyword, this.type, this.parameters, GetDiagnostics(), annotations);
    }

    internal ConversionOperatorMemberCrefSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 4;
      var implicitOrExplicitKeyword = (SyntaxToken)reader.ReadValue();
      if (implicitOrExplicitKeyword != null)
      {
         AdjustFlagsAndWidth(implicitOrExplicitKeyword);
         this.implicitOrExplicitKeyword = implicitOrExplicitKeyword;
      }
      var operatorKeyword = (SyntaxToken)reader.ReadValue();
      if (operatorKeyword != null)
      {
         AdjustFlagsAndWidth(operatorKeyword);
         this.operatorKeyword = operatorKeyword;
      }
      var type = (TypeSyntax)reader.ReadValue();
      if (type != null)
      {
         AdjustFlagsAndWidth(type);
         this.type = type;
      }
      var parameters = (CrefParameterListSyntax)reader.ReadValue();
      if (parameters != null)
      {
         AdjustFlagsAndWidth(parameters);
         this.parameters = parameters;
      }
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.implicitOrExplicitKeyword);
      writer.WriteValue(this.operatorKeyword);
      writer.WriteValue(this.type);
      writer.WriteValue(this.parameters);
    }

    static ConversionOperatorMemberCrefSyntax()
    {
       ObjectBinder.RegisterTypeReader(typeof(ConversionOperatorMemberCrefSyntax), r => new ConversionOperatorMemberCrefSyntax(r));
    }
  }

  /// <summary>
  /// A list of cref parameters with surrounding punctuation.
  /// Unlike regular parameters, cref parameters do not have names.
  /// </summary>
  internal abstract partial class BaseCrefParameterListSyntax : CSharpSyntaxNode
  {
    internal BaseCrefParameterListSyntax(SyntaxKind kind, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
      : base(kind, diagnostics, annotations)
    {
    }
    internal BaseCrefParameterListSyntax(SyntaxKind kind)
      : base(kind)
    {
    }

    protected BaseCrefParameterListSyntax(ObjectReader reader)
       : base(reader)
    {
    }

    /// <summary>Gets the parameter list.</summary>
    public abstract Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<CrefParameterSyntax> Parameters { get; }
  }

  /// <summary>
  /// A parenthesized list of cref parameters.
  /// </summary>
  internal sealed partial class CrefParameterListSyntax : BaseCrefParameterListSyntax
  {
    internal readonly SyntaxToken openParenToken;
    internal readonly GreenNode parameters;
    internal readonly SyntaxToken closeParenToken;

    internal CrefParameterListSyntax(SyntaxKind kind, SyntaxToken openParenToken, GreenNode parameters, SyntaxToken closeParenToken, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 3;
        this.AdjustFlagsAndWidth(openParenToken);
        this.openParenToken = openParenToken;
        if (parameters != null)
        {
            this.AdjustFlagsAndWidth(parameters);
            this.parameters = parameters;
        }
        this.AdjustFlagsAndWidth(closeParenToken);
        this.closeParenToken = closeParenToken;
    }


    internal CrefParameterListSyntax(SyntaxKind kind, SyntaxToken openParenToken, GreenNode parameters, SyntaxToken closeParenToken, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 3;
        this.AdjustFlagsAndWidth(openParenToken);
        this.openParenToken = openParenToken;
        if (parameters != null)
        {
            this.AdjustFlagsAndWidth(parameters);
            this.parameters = parameters;
        }
        this.AdjustFlagsAndWidth(closeParenToken);
        this.closeParenToken = closeParenToken;
    }


    internal CrefParameterListSyntax(SyntaxKind kind, SyntaxToken openParenToken, GreenNode parameters, SyntaxToken closeParenToken)
        : base(kind)
    {
        this.SlotCount = 3;
        this.AdjustFlagsAndWidth(openParenToken);
        this.openParenToken = openParenToken;
        if (parameters != null)
        {
            this.AdjustFlagsAndWidth(parameters);
            this.parameters = parameters;
        }
        this.AdjustFlagsAndWidth(closeParenToken);
        this.closeParenToken = closeParenToken;
    }

    /// <summary>Gets the open paren token.</summary>
    public SyntaxToken OpenParenToken { get { return this.openParenToken; } }
    public override Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<CrefParameterSyntax> Parameters { get { return new Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<CrefParameterSyntax>(new Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<CSharpSyntaxNode>(this.parameters)); } }
    /// <summary>Gets the close paren token.</summary>
    public SyntaxToken CloseParenToken { get { return this.closeParenToken; } }

    internal override GreenNode GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.openParenToken;
            case 1: return this.parameters;
            case 2: return this.closeParenToken;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode parent, int position)
    {
      return new CSharp.Syntax.CrefParameterListSyntax(this, parent, position);
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitCrefParameterList(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitCrefParameterList(this);
    }

    public CrefParameterListSyntax Update(SyntaxToken openParenToken, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<CrefParameterSyntax> parameters, SyntaxToken closeParenToken)
    {
        if (openParenToken != this.OpenParenToken || parameters != this.Parameters || closeParenToken != this.CloseParenToken)
        {
            var newNode = SyntaxFactory.CrefParameterList(openParenToken, parameters, closeParenToken);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
    {
         return new CrefParameterListSyntax(this.Kind, this.openParenToken, this.parameters, this.closeParenToken, diagnostics, GetAnnotations());
    }

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
    {
         return new CrefParameterListSyntax(this.Kind, this.openParenToken, this.parameters, this.closeParenToken, GetDiagnostics(), annotations);
    }

    internal CrefParameterListSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 3;
      var openParenToken = (SyntaxToken)reader.ReadValue();
      if (openParenToken != null)
      {
         AdjustFlagsAndWidth(openParenToken);
         this.openParenToken = openParenToken;
      }
      var parameters = (GreenNode)reader.ReadValue();
      if (parameters != null)
      {
         AdjustFlagsAndWidth(parameters);
         this.parameters = parameters;
      }
      var closeParenToken = (SyntaxToken)reader.ReadValue();
      if (closeParenToken != null)
      {
         AdjustFlagsAndWidth(closeParenToken);
         this.closeParenToken = closeParenToken;
      }
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.openParenToken);
      writer.WriteValue(this.parameters);
      writer.WriteValue(this.closeParenToken);
    }

    static CrefParameterListSyntax()
    {
       ObjectBinder.RegisterTypeReader(typeof(CrefParameterListSyntax), r => new CrefParameterListSyntax(r));
    }
  }

  /// <summary>
  /// A bracketed list of cref parameters.
  /// </summary>
  internal sealed partial class CrefBracketedParameterListSyntax : BaseCrefParameterListSyntax
  {
    internal readonly SyntaxToken openBracketToken;
    internal readonly GreenNode parameters;
    internal readonly SyntaxToken closeBracketToken;

    internal CrefBracketedParameterListSyntax(SyntaxKind kind, SyntaxToken openBracketToken, GreenNode parameters, SyntaxToken closeBracketToken, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 3;
        this.AdjustFlagsAndWidth(openBracketToken);
        this.openBracketToken = openBracketToken;
        if (parameters != null)
        {
            this.AdjustFlagsAndWidth(parameters);
            this.parameters = parameters;
        }
        this.AdjustFlagsAndWidth(closeBracketToken);
        this.closeBracketToken = closeBracketToken;
    }


    internal CrefBracketedParameterListSyntax(SyntaxKind kind, SyntaxToken openBracketToken, GreenNode parameters, SyntaxToken closeBracketToken, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 3;
        this.AdjustFlagsAndWidth(openBracketToken);
        this.openBracketToken = openBracketToken;
        if (parameters != null)
        {
            this.AdjustFlagsAndWidth(parameters);
            this.parameters = parameters;
        }
        this.AdjustFlagsAndWidth(closeBracketToken);
        this.closeBracketToken = closeBracketToken;
    }


    internal CrefBracketedParameterListSyntax(SyntaxKind kind, SyntaxToken openBracketToken, GreenNode parameters, SyntaxToken closeBracketToken)
        : base(kind)
    {
        this.SlotCount = 3;
        this.AdjustFlagsAndWidth(openBracketToken);
        this.openBracketToken = openBracketToken;
        if (parameters != null)
        {
            this.AdjustFlagsAndWidth(parameters);
            this.parameters = parameters;
        }
        this.AdjustFlagsAndWidth(closeBracketToken);
        this.closeBracketToken = closeBracketToken;
    }

    /// <summary>Gets the open bracket token.</summary>
    public SyntaxToken OpenBracketToken { get { return this.openBracketToken; } }
    public override Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<CrefParameterSyntax> Parameters { get { return new Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<CrefParameterSyntax>(new Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<CSharpSyntaxNode>(this.parameters)); } }
    /// <summary>Gets the close bracket token.</summary>
    public SyntaxToken CloseBracketToken { get { return this.closeBracketToken; } }

    internal override GreenNode GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.openBracketToken;
            case 1: return this.parameters;
            case 2: return this.closeBracketToken;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode parent, int position)
    {
      return new CSharp.Syntax.CrefBracketedParameterListSyntax(this, parent, position);
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitCrefBracketedParameterList(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitCrefBracketedParameterList(this);
    }

    public CrefBracketedParameterListSyntax Update(SyntaxToken openBracketToken, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<CrefParameterSyntax> parameters, SyntaxToken closeBracketToken)
    {
        if (openBracketToken != this.OpenBracketToken || parameters != this.Parameters || closeBracketToken != this.CloseBracketToken)
        {
            var newNode = SyntaxFactory.CrefBracketedParameterList(openBracketToken, parameters, closeBracketToken);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
    {
         return new CrefBracketedParameterListSyntax(this.Kind, this.openBracketToken, this.parameters, this.closeBracketToken, diagnostics, GetAnnotations());
    }

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
    {
         return new CrefBracketedParameterListSyntax(this.Kind, this.openBracketToken, this.parameters, this.closeBracketToken, GetDiagnostics(), annotations);
    }

    internal CrefBracketedParameterListSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 3;
      var openBracketToken = (SyntaxToken)reader.ReadValue();
      if (openBracketToken != null)
      {
         AdjustFlagsAndWidth(openBracketToken);
         this.openBracketToken = openBracketToken;
      }
      var parameters = (GreenNode)reader.ReadValue();
      if (parameters != null)
      {
         AdjustFlagsAndWidth(parameters);
         this.parameters = parameters;
      }
      var closeBracketToken = (SyntaxToken)reader.ReadValue();
      if (closeBracketToken != null)
      {
         AdjustFlagsAndWidth(closeBracketToken);
         this.closeBracketToken = closeBracketToken;
      }
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.openBracketToken);
      writer.WriteValue(this.parameters);
      writer.WriteValue(this.closeBracketToken);
    }

    static CrefBracketedParameterListSyntax()
    {
       ObjectBinder.RegisterTypeReader(typeof(CrefBracketedParameterListSyntax), r => new CrefBracketedParameterListSyntax(r));
    }
  }

  /// <summary>
  /// An element of a BaseCrefParameterListSyntax.
  /// Unlike a regular parameter, a cref parameter has only an optional ref or out keyword and a type -
  /// there is no name and there are no attributes or other modifiers.
  /// </summary>
  internal sealed partial class CrefParameterSyntax : CSharpSyntaxNode
  {
    internal readonly SyntaxToken refOrOutKeyword;
    internal readonly TypeSyntax type;

    internal CrefParameterSyntax(SyntaxKind kind, SyntaxToken refOrOutKeyword, TypeSyntax type, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 2;
        if (refOrOutKeyword != null)
        {
            this.AdjustFlagsAndWidth(refOrOutKeyword);
            this.refOrOutKeyword = refOrOutKeyword;
        }
        this.AdjustFlagsAndWidth(type);
        this.type = type;
    }


    internal CrefParameterSyntax(SyntaxKind kind, SyntaxToken refOrOutKeyword, TypeSyntax type, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 2;
        if (refOrOutKeyword != null)
        {
            this.AdjustFlagsAndWidth(refOrOutKeyword);
            this.refOrOutKeyword = refOrOutKeyword;
        }
        this.AdjustFlagsAndWidth(type);
        this.type = type;
    }


    internal CrefParameterSyntax(SyntaxKind kind, SyntaxToken refOrOutKeyword, TypeSyntax type)
        : base(kind)
    {
        this.SlotCount = 2;
        if (refOrOutKeyword != null)
        {
            this.AdjustFlagsAndWidth(refOrOutKeyword);
            this.refOrOutKeyword = refOrOutKeyword;
        }
        this.AdjustFlagsAndWidth(type);
        this.type = type;
    }

    public SyntaxToken RefOrOutKeyword { get { return this.refOrOutKeyword; } }
    public TypeSyntax Type { get { return this.type; } }

    internal override GreenNode GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.refOrOutKeyword;
            case 1: return this.type;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode parent, int position)
    {
      return new CSharp.Syntax.CrefParameterSyntax(this, parent, position);
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitCrefParameter(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitCrefParameter(this);
    }

    public CrefParameterSyntax Update(SyntaxToken refOrOutKeyword, TypeSyntax type)
    {
        if (refOrOutKeyword != this.RefOrOutKeyword || type != this.Type)
        {
            var newNode = SyntaxFactory.CrefParameter(refOrOutKeyword, type);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
    {
         return new CrefParameterSyntax(this.Kind, this.refOrOutKeyword, this.type, diagnostics, GetAnnotations());
    }

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
    {
         return new CrefParameterSyntax(this.Kind, this.refOrOutKeyword, this.type, GetDiagnostics(), annotations);
    }

    internal CrefParameterSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 2;
      var refOrOutKeyword = (SyntaxToken)reader.ReadValue();
      if (refOrOutKeyword != null)
      {
         AdjustFlagsAndWidth(refOrOutKeyword);
         this.refOrOutKeyword = refOrOutKeyword;
      }
      var type = (TypeSyntax)reader.ReadValue();
      if (type != null)
      {
         AdjustFlagsAndWidth(type);
         this.type = type;
      }
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.refOrOutKeyword);
      writer.WriteValue(this.type);
    }

    static CrefParameterSyntax()
    {
       ObjectBinder.RegisterTypeReader(typeof(CrefParameterSyntax), r => new CrefParameterSyntax(r));
    }
  }

  internal abstract partial class XmlNodeSyntax : CSharpSyntaxNode
  {
    internal XmlNodeSyntax(SyntaxKind kind, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
      : base(kind, diagnostics, annotations)
    {
    }
    internal XmlNodeSyntax(SyntaxKind kind)
      : base(kind)
    {
    }

    protected XmlNodeSyntax(ObjectReader reader)
       : base(reader)
    {
    }
  }

  internal sealed partial class XmlElementSyntax : XmlNodeSyntax
  {
    internal readonly XmlElementStartTagSyntax startTag;
    internal readonly GreenNode content;
    internal readonly XmlElementEndTagSyntax endTag;

    internal XmlElementSyntax(SyntaxKind kind, XmlElementStartTagSyntax startTag, GreenNode content, XmlElementEndTagSyntax endTag, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 3;
        this.AdjustFlagsAndWidth(startTag);
        this.startTag = startTag;
        if (content != null)
        {
            this.AdjustFlagsAndWidth(content);
            this.content = content;
        }
        this.AdjustFlagsAndWidth(endTag);
        this.endTag = endTag;
    }


    internal XmlElementSyntax(SyntaxKind kind, XmlElementStartTagSyntax startTag, GreenNode content, XmlElementEndTagSyntax endTag, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 3;
        this.AdjustFlagsAndWidth(startTag);
        this.startTag = startTag;
        if (content != null)
        {
            this.AdjustFlagsAndWidth(content);
            this.content = content;
        }
        this.AdjustFlagsAndWidth(endTag);
        this.endTag = endTag;
    }


    internal XmlElementSyntax(SyntaxKind kind, XmlElementStartTagSyntax startTag, GreenNode content, XmlElementEndTagSyntax endTag)
        : base(kind)
    {
        this.SlotCount = 3;
        this.AdjustFlagsAndWidth(startTag);
        this.startTag = startTag;
        if (content != null)
        {
            this.AdjustFlagsAndWidth(content);
            this.content = content;
        }
        this.AdjustFlagsAndWidth(endTag);
        this.endTag = endTag;
    }

    public XmlElementStartTagSyntax StartTag { get { return this.startTag; } }
    public Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<XmlNodeSyntax> Content { get { return new Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<XmlNodeSyntax>(this.content); } }
    public XmlElementEndTagSyntax EndTag { get { return this.endTag; } }

    internal override GreenNode GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.startTag;
            case 1: return this.content;
            case 2: return this.endTag;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode parent, int position)
    {
      return new CSharp.Syntax.XmlElementSyntax(this, parent, position);
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitXmlElement(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitXmlElement(this);
    }

    public XmlElementSyntax Update(XmlElementStartTagSyntax startTag, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<XmlNodeSyntax> content, XmlElementEndTagSyntax endTag)
    {
        if (startTag != this.StartTag || content != this.Content || endTag != this.EndTag)
        {
            var newNode = SyntaxFactory.XmlElement(startTag, content, endTag);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
    {
         return new XmlElementSyntax(this.Kind, this.startTag, this.content, this.endTag, diagnostics, GetAnnotations());
    }

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
    {
         return new XmlElementSyntax(this.Kind, this.startTag, this.content, this.endTag, GetDiagnostics(), annotations);
    }

    internal XmlElementSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 3;
      var startTag = (XmlElementStartTagSyntax)reader.ReadValue();
      if (startTag != null)
      {
         AdjustFlagsAndWidth(startTag);
         this.startTag = startTag;
      }
      var content = (GreenNode)reader.ReadValue();
      if (content != null)
      {
         AdjustFlagsAndWidth(content);
         this.content = content;
      }
      var endTag = (XmlElementEndTagSyntax)reader.ReadValue();
      if (endTag != null)
      {
         AdjustFlagsAndWidth(endTag);
         this.endTag = endTag;
      }
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.startTag);
      writer.WriteValue(this.content);
      writer.WriteValue(this.endTag);
    }

    static XmlElementSyntax()
    {
       ObjectBinder.RegisterTypeReader(typeof(XmlElementSyntax), r => new XmlElementSyntax(r));
    }
  }

  internal sealed partial class XmlElementStartTagSyntax : CSharpSyntaxNode
  {
    internal readonly SyntaxToken lessThanToken;
    internal readonly XmlNameSyntax name;
    internal readonly GreenNode attributes;
    internal readonly SyntaxToken greaterThanToken;

    internal XmlElementStartTagSyntax(SyntaxKind kind, SyntaxToken lessThanToken, XmlNameSyntax name, GreenNode attributes, SyntaxToken greaterThanToken, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 4;
        this.AdjustFlagsAndWidth(lessThanToken);
        this.lessThanToken = lessThanToken;
        this.AdjustFlagsAndWidth(name);
        this.name = name;
        if (attributes != null)
        {
            this.AdjustFlagsAndWidth(attributes);
            this.attributes = attributes;
        }
        this.AdjustFlagsAndWidth(greaterThanToken);
        this.greaterThanToken = greaterThanToken;
    }


    internal XmlElementStartTagSyntax(SyntaxKind kind, SyntaxToken lessThanToken, XmlNameSyntax name, GreenNode attributes, SyntaxToken greaterThanToken, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 4;
        this.AdjustFlagsAndWidth(lessThanToken);
        this.lessThanToken = lessThanToken;
        this.AdjustFlagsAndWidth(name);
        this.name = name;
        if (attributes != null)
        {
            this.AdjustFlagsAndWidth(attributes);
            this.attributes = attributes;
        }
        this.AdjustFlagsAndWidth(greaterThanToken);
        this.greaterThanToken = greaterThanToken;
    }


    internal XmlElementStartTagSyntax(SyntaxKind kind, SyntaxToken lessThanToken, XmlNameSyntax name, GreenNode attributes, SyntaxToken greaterThanToken)
        : base(kind)
    {
        this.SlotCount = 4;
        this.AdjustFlagsAndWidth(lessThanToken);
        this.lessThanToken = lessThanToken;
        this.AdjustFlagsAndWidth(name);
        this.name = name;
        if (attributes != null)
        {
            this.AdjustFlagsAndWidth(attributes);
            this.attributes = attributes;
        }
        this.AdjustFlagsAndWidth(greaterThanToken);
        this.greaterThanToken = greaterThanToken;
    }

    public SyntaxToken LessThanToken { get { return this.lessThanToken; } }
    public XmlNameSyntax Name { get { return this.name; } }
    public Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<XmlAttributeSyntax> Attributes { get { return new Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<XmlAttributeSyntax>(this.attributes); } }
    public SyntaxToken GreaterThanToken { get { return this.greaterThanToken; } }

    internal override GreenNode GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.lessThanToken;
            case 1: return this.name;
            case 2: return this.attributes;
            case 3: return this.greaterThanToken;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode parent, int position)
    {
      return new CSharp.Syntax.XmlElementStartTagSyntax(this, parent, position);
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitXmlElementStartTag(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitXmlElementStartTag(this);
    }

    public XmlElementStartTagSyntax Update(SyntaxToken lessThanToken, XmlNameSyntax name, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<XmlAttributeSyntax> attributes, SyntaxToken greaterThanToken)
    {
        if (lessThanToken != this.LessThanToken || name != this.Name || attributes != this.Attributes || greaterThanToken != this.GreaterThanToken)
        {
            var newNode = SyntaxFactory.XmlElementStartTag(lessThanToken, name, attributes, greaterThanToken);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
    {
         return new XmlElementStartTagSyntax(this.Kind, this.lessThanToken, this.name, this.attributes, this.greaterThanToken, diagnostics, GetAnnotations());
    }

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
    {
         return new XmlElementStartTagSyntax(this.Kind, this.lessThanToken, this.name, this.attributes, this.greaterThanToken, GetDiagnostics(), annotations);
    }

    internal XmlElementStartTagSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 4;
      var lessThanToken = (SyntaxToken)reader.ReadValue();
      if (lessThanToken != null)
      {
         AdjustFlagsAndWidth(lessThanToken);
         this.lessThanToken = lessThanToken;
      }
      var name = (XmlNameSyntax)reader.ReadValue();
      if (name != null)
      {
         AdjustFlagsAndWidth(name);
         this.name = name;
      }
      var attributes = (GreenNode)reader.ReadValue();
      if (attributes != null)
      {
         AdjustFlagsAndWidth(attributes);
         this.attributes = attributes;
      }
      var greaterThanToken = (SyntaxToken)reader.ReadValue();
      if (greaterThanToken != null)
      {
         AdjustFlagsAndWidth(greaterThanToken);
         this.greaterThanToken = greaterThanToken;
      }
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.lessThanToken);
      writer.WriteValue(this.name);
      writer.WriteValue(this.attributes);
      writer.WriteValue(this.greaterThanToken);
    }

    static XmlElementStartTagSyntax()
    {
       ObjectBinder.RegisterTypeReader(typeof(XmlElementStartTagSyntax), r => new XmlElementStartTagSyntax(r));
    }
  }

  internal sealed partial class XmlElementEndTagSyntax : CSharpSyntaxNode
  {
    internal readonly SyntaxToken lessThanSlashToken;
    internal readonly XmlNameSyntax name;
    internal readonly SyntaxToken greaterThanToken;

    internal XmlElementEndTagSyntax(SyntaxKind kind, SyntaxToken lessThanSlashToken, XmlNameSyntax name, SyntaxToken greaterThanToken, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 3;
        this.AdjustFlagsAndWidth(lessThanSlashToken);
        this.lessThanSlashToken = lessThanSlashToken;
        this.AdjustFlagsAndWidth(name);
        this.name = name;
        this.AdjustFlagsAndWidth(greaterThanToken);
        this.greaterThanToken = greaterThanToken;
    }


    internal XmlElementEndTagSyntax(SyntaxKind kind, SyntaxToken lessThanSlashToken, XmlNameSyntax name, SyntaxToken greaterThanToken, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 3;
        this.AdjustFlagsAndWidth(lessThanSlashToken);
        this.lessThanSlashToken = lessThanSlashToken;
        this.AdjustFlagsAndWidth(name);
        this.name = name;
        this.AdjustFlagsAndWidth(greaterThanToken);
        this.greaterThanToken = greaterThanToken;
    }


    internal XmlElementEndTagSyntax(SyntaxKind kind, SyntaxToken lessThanSlashToken, XmlNameSyntax name, SyntaxToken greaterThanToken)
        : base(kind)
    {
        this.SlotCount = 3;
        this.AdjustFlagsAndWidth(lessThanSlashToken);
        this.lessThanSlashToken = lessThanSlashToken;
        this.AdjustFlagsAndWidth(name);
        this.name = name;
        this.AdjustFlagsAndWidth(greaterThanToken);
        this.greaterThanToken = greaterThanToken;
    }

    public SyntaxToken LessThanSlashToken { get { return this.lessThanSlashToken; } }
    public XmlNameSyntax Name { get { return this.name; } }
    public SyntaxToken GreaterThanToken { get { return this.greaterThanToken; } }

    internal override GreenNode GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.lessThanSlashToken;
            case 1: return this.name;
            case 2: return this.greaterThanToken;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode parent, int position)
    {
      return new CSharp.Syntax.XmlElementEndTagSyntax(this, parent, position);
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitXmlElementEndTag(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitXmlElementEndTag(this);
    }

    public XmlElementEndTagSyntax Update(SyntaxToken lessThanSlashToken, XmlNameSyntax name, SyntaxToken greaterThanToken)
    {
        if (lessThanSlashToken != this.LessThanSlashToken || name != this.Name || greaterThanToken != this.GreaterThanToken)
        {
            var newNode = SyntaxFactory.XmlElementEndTag(lessThanSlashToken, name, greaterThanToken);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
    {
         return new XmlElementEndTagSyntax(this.Kind, this.lessThanSlashToken, this.name, this.greaterThanToken, diagnostics, GetAnnotations());
    }

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
    {
         return new XmlElementEndTagSyntax(this.Kind, this.lessThanSlashToken, this.name, this.greaterThanToken, GetDiagnostics(), annotations);
    }

    internal XmlElementEndTagSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 3;
      var lessThanSlashToken = (SyntaxToken)reader.ReadValue();
      if (lessThanSlashToken != null)
      {
         AdjustFlagsAndWidth(lessThanSlashToken);
         this.lessThanSlashToken = lessThanSlashToken;
      }
      var name = (XmlNameSyntax)reader.ReadValue();
      if (name != null)
      {
         AdjustFlagsAndWidth(name);
         this.name = name;
      }
      var greaterThanToken = (SyntaxToken)reader.ReadValue();
      if (greaterThanToken != null)
      {
         AdjustFlagsAndWidth(greaterThanToken);
         this.greaterThanToken = greaterThanToken;
      }
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.lessThanSlashToken);
      writer.WriteValue(this.name);
      writer.WriteValue(this.greaterThanToken);
    }

    static XmlElementEndTagSyntax()
    {
       ObjectBinder.RegisterTypeReader(typeof(XmlElementEndTagSyntax), r => new XmlElementEndTagSyntax(r));
    }
  }

  internal sealed partial class XmlEmptyElementSyntax : XmlNodeSyntax
  {
    internal readonly SyntaxToken lessThanToken;
    internal readonly XmlNameSyntax name;
    internal readonly GreenNode attributes;
    internal readonly SyntaxToken slashGreaterThanToken;

    internal XmlEmptyElementSyntax(SyntaxKind kind, SyntaxToken lessThanToken, XmlNameSyntax name, GreenNode attributes, SyntaxToken slashGreaterThanToken, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 4;
        this.AdjustFlagsAndWidth(lessThanToken);
        this.lessThanToken = lessThanToken;
        this.AdjustFlagsAndWidth(name);
        this.name = name;
        if (attributes != null)
        {
            this.AdjustFlagsAndWidth(attributes);
            this.attributes = attributes;
        }
        this.AdjustFlagsAndWidth(slashGreaterThanToken);
        this.slashGreaterThanToken = slashGreaterThanToken;
    }


    internal XmlEmptyElementSyntax(SyntaxKind kind, SyntaxToken lessThanToken, XmlNameSyntax name, GreenNode attributes, SyntaxToken slashGreaterThanToken, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 4;
        this.AdjustFlagsAndWidth(lessThanToken);
        this.lessThanToken = lessThanToken;
        this.AdjustFlagsAndWidth(name);
        this.name = name;
        if (attributes != null)
        {
            this.AdjustFlagsAndWidth(attributes);
            this.attributes = attributes;
        }
        this.AdjustFlagsAndWidth(slashGreaterThanToken);
        this.slashGreaterThanToken = slashGreaterThanToken;
    }


    internal XmlEmptyElementSyntax(SyntaxKind kind, SyntaxToken lessThanToken, XmlNameSyntax name, GreenNode attributes, SyntaxToken slashGreaterThanToken)
        : base(kind)
    {
        this.SlotCount = 4;
        this.AdjustFlagsAndWidth(lessThanToken);
        this.lessThanToken = lessThanToken;
        this.AdjustFlagsAndWidth(name);
        this.name = name;
        if (attributes != null)
        {
            this.AdjustFlagsAndWidth(attributes);
            this.attributes = attributes;
        }
        this.AdjustFlagsAndWidth(slashGreaterThanToken);
        this.slashGreaterThanToken = slashGreaterThanToken;
    }

    public SyntaxToken LessThanToken { get { return this.lessThanToken; } }
    public XmlNameSyntax Name { get { return this.name; } }
    public Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<XmlAttributeSyntax> Attributes { get { return new Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<XmlAttributeSyntax>(this.attributes); } }
    public SyntaxToken SlashGreaterThanToken { get { return this.slashGreaterThanToken; } }

    internal override GreenNode GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.lessThanToken;
            case 1: return this.name;
            case 2: return this.attributes;
            case 3: return this.slashGreaterThanToken;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode parent, int position)
    {
      return new CSharp.Syntax.XmlEmptyElementSyntax(this, parent, position);
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitXmlEmptyElement(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitXmlEmptyElement(this);
    }

    public XmlEmptyElementSyntax Update(SyntaxToken lessThanToken, XmlNameSyntax name, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<XmlAttributeSyntax> attributes, SyntaxToken slashGreaterThanToken)
    {
        if (lessThanToken != this.LessThanToken || name != this.Name || attributes != this.Attributes || slashGreaterThanToken != this.SlashGreaterThanToken)
        {
            var newNode = SyntaxFactory.XmlEmptyElement(lessThanToken, name, attributes, slashGreaterThanToken);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
    {
         return new XmlEmptyElementSyntax(this.Kind, this.lessThanToken, this.name, this.attributes, this.slashGreaterThanToken, diagnostics, GetAnnotations());
    }

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
    {
         return new XmlEmptyElementSyntax(this.Kind, this.lessThanToken, this.name, this.attributes, this.slashGreaterThanToken, GetDiagnostics(), annotations);
    }

    internal XmlEmptyElementSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 4;
      var lessThanToken = (SyntaxToken)reader.ReadValue();
      if (lessThanToken != null)
      {
         AdjustFlagsAndWidth(lessThanToken);
         this.lessThanToken = lessThanToken;
      }
      var name = (XmlNameSyntax)reader.ReadValue();
      if (name != null)
      {
         AdjustFlagsAndWidth(name);
         this.name = name;
      }
      var attributes = (GreenNode)reader.ReadValue();
      if (attributes != null)
      {
         AdjustFlagsAndWidth(attributes);
         this.attributes = attributes;
      }
      var slashGreaterThanToken = (SyntaxToken)reader.ReadValue();
      if (slashGreaterThanToken != null)
      {
         AdjustFlagsAndWidth(slashGreaterThanToken);
         this.slashGreaterThanToken = slashGreaterThanToken;
      }
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.lessThanToken);
      writer.WriteValue(this.name);
      writer.WriteValue(this.attributes);
      writer.WriteValue(this.slashGreaterThanToken);
    }

    static XmlEmptyElementSyntax()
    {
       ObjectBinder.RegisterTypeReader(typeof(XmlEmptyElementSyntax), r => new XmlEmptyElementSyntax(r));
    }
  }

  internal sealed partial class XmlNameSyntax : CSharpSyntaxNode
  {
    internal readonly XmlPrefixSyntax prefix;
    internal readonly SyntaxToken localName;

    internal XmlNameSyntax(SyntaxKind kind, XmlPrefixSyntax prefix, SyntaxToken localName, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 2;
        if (prefix != null)
        {
            this.AdjustFlagsAndWidth(prefix);
            this.prefix = prefix;
        }
        this.AdjustFlagsAndWidth(localName);
        this.localName = localName;
    }


    internal XmlNameSyntax(SyntaxKind kind, XmlPrefixSyntax prefix, SyntaxToken localName, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 2;
        if (prefix != null)
        {
            this.AdjustFlagsAndWidth(prefix);
            this.prefix = prefix;
        }
        this.AdjustFlagsAndWidth(localName);
        this.localName = localName;
    }


    internal XmlNameSyntax(SyntaxKind kind, XmlPrefixSyntax prefix, SyntaxToken localName)
        : base(kind)
    {
        this.SlotCount = 2;
        if (prefix != null)
        {
            this.AdjustFlagsAndWidth(prefix);
            this.prefix = prefix;
        }
        this.AdjustFlagsAndWidth(localName);
        this.localName = localName;
    }

    public XmlPrefixSyntax Prefix { get { return this.prefix; } }
    public SyntaxToken LocalName { get { return this.localName; } }

    internal override GreenNode GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.prefix;
            case 1: return this.localName;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode parent, int position)
    {
      return new CSharp.Syntax.XmlNameSyntax(this, parent, position);
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitXmlName(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitXmlName(this);
    }

    public XmlNameSyntax Update(XmlPrefixSyntax prefix, SyntaxToken localName)
    {
        if (prefix != this.Prefix || localName != this.LocalName)
        {
            var newNode = SyntaxFactory.XmlName(prefix, localName);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
    {
         return new XmlNameSyntax(this.Kind, this.prefix, this.localName, diagnostics, GetAnnotations());
    }

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
    {
         return new XmlNameSyntax(this.Kind, this.prefix, this.localName, GetDiagnostics(), annotations);
    }

    internal XmlNameSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 2;
      var prefix = (XmlPrefixSyntax)reader.ReadValue();
      if (prefix != null)
      {
         AdjustFlagsAndWidth(prefix);
         this.prefix = prefix;
      }
      var localName = (SyntaxToken)reader.ReadValue();
      if (localName != null)
      {
         AdjustFlagsAndWidth(localName);
         this.localName = localName;
      }
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.prefix);
      writer.WriteValue(this.localName);
    }

    static XmlNameSyntax()
    {
       ObjectBinder.RegisterTypeReader(typeof(XmlNameSyntax), r => new XmlNameSyntax(r));
    }
  }

  internal sealed partial class XmlPrefixSyntax : CSharpSyntaxNode
  {
    internal readonly SyntaxToken prefix;
    internal readonly SyntaxToken colonToken;

    internal XmlPrefixSyntax(SyntaxKind kind, SyntaxToken prefix, SyntaxToken colonToken, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 2;
        this.AdjustFlagsAndWidth(prefix);
        this.prefix = prefix;
        this.AdjustFlagsAndWidth(colonToken);
        this.colonToken = colonToken;
    }


    internal XmlPrefixSyntax(SyntaxKind kind, SyntaxToken prefix, SyntaxToken colonToken, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 2;
        this.AdjustFlagsAndWidth(prefix);
        this.prefix = prefix;
        this.AdjustFlagsAndWidth(colonToken);
        this.colonToken = colonToken;
    }


    internal XmlPrefixSyntax(SyntaxKind kind, SyntaxToken prefix, SyntaxToken colonToken)
        : base(kind)
    {
        this.SlotCount = 2;
        this.AdjustFlagsAndWidth(prefix);
        this.prefix = prefix;
        this.AdjustFlagsAndWidth(colonToken);
        this.colonToken = colonToken;
    }

    public SyntaxToken Prefix { get { return this.prefix; } }
    public SyntaxToken ColonToken { get { return this.colonToken; } }

    internal override GreenNode GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.prefix;
            case 1: return this.colonToken;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode parent, int position)
    {
      return new CSharp.Syntax.XmlPrefixSyntax(this, parent, position);
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitXmlPrefix(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitXmlPrefix(this);
    }

    public XmlPrefixSyntax Update(SyntaxToken prefix, SyntaxToken colonToken)
    {
        if (prefix != this.Prefix || colonToken != this.ColonToken)
        {
            var newNode = SyntaxFactory.XmlPrefix(prefix, colonToken);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
    {
         return new XmlPrefixSyntax(this.Kind, this.prefix, this.colonToken, diagnostics, GetAnnotations());
    }

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
    {
         return new XmlPrefixSyntax(this.Kind, this.prefix, this.colonToken, GetDiagnostics(), annotations);
    }

    internal XmlPrefixSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 2;
      var prefix = (SyntaxToken)reader.ReadValue();
      if (prefix != null)
      {
         AdjustFlagsAndWidth(prefix);
         this.prefix = prefix;
      }
      var colonToken = (SyntaxToken)reader.ReadValue();
      if (colonToken != null)
      {
         AdjustFlagsAndWidth(colonToken);
         this.colonToken = colonToken;
      }
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.prefix);
      writer.WriteValue(this.colonToken);
    }

    static XmlPrefixSyntax()
    {
       ObjectBinder.RegisterTypeReader(typeof(XmlPrefixSyntax), r => new XmlPrefixSyntax(r));
    }
  }

  internal abstract partial class XmlAttributeSyntax : CSharpSyntaxNode
  {
    internal XmlAttributeSyntax(SyntaxKind kind, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
      : base(kind, diagnostics, annotations)
    {
    }
    internal XmlAttributeSyntax(SyntaxKind kind)
      : base(kind)
    {
    }

    protected XmlAttributeSyntax(ObjectReader reader)
       : base(reader)
    {
    }

    public abstract XmlNameSyntax Name { get; }

    public abstract SyntaxToken EqualsToken { get; }

    public abstract SyntaxToken StartQuoteToken { get; }

    public abstract SyntaxToken EndQuoteToken { get; }
  }

  internal sealed partial class XmlTextAttributeSyntax : XmlAttributeSyntax
  {
    internal readonly XmlNameSyntax name;
    internal readonly SyntaxToken equalsToken;
    internal readonly SyntaxToken startQuoteToken;
    internal readonly GreenNode textTokens;
    internal readonly SyntaxToken endQuoteToken;

    internal XmlTextAttributeSyntax(SyntaxKind kind, XmlNameSyntax name, SyntaxToken equalsToken, SyntaxToken startQuoteToken, GreenNode textTokens, SyntaxToken endQuoteToken, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 5;
        this.AdjustFlagsAndWidth(name);
        this.name = name;
        this.AdjustFlagsAndWidth(equalsToken);
        this.equalsToken = equalsToken;
        this.AdjustFlagsAndWidth(startQuoteToken);
        this.startQuoteToken = startQuoteToken;
        if (textTokens != null)
        {
            this.AdjustFlagsAndWidth(textTokens);
            this.textTokens = textTokens;
        }
        this.AdjustFlagsAndWidth(endQuoteToken);
        this.endQuoteToken = endQuoteToken;
    }


    internal XmlTextAttributeSyntax(SyntaxKind kind, XmlNameSyntax name, SyntaxToken equalsToken, SyntaxToken startQuoteToken, GreenNode textTokens, SyntaxToken endQuoteToken, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 5;
        this.AdjustFlagsAndWidth(name);
        this.name = name;
        this.AdjustFlagsAndWidth(equalsToken);
        this.equalsToken = equalsToken;
        this.AdjustFlagsAndWidth(startQuoteToken);
        this.startQuoteToken = startQuoteToken;
        if (textTokens != null)
        {
            this.AdjustFlagsAndWidth(textTokens);
            this.textTokens = textTokens;
        }
        this.AdjustFlagsAndWidth(endQuoteToken);
        this.endQuoteToken = endQuoteToken;
    }


    internal XmlTextAttributeSyntax(SyntaxKind kind, XmlNameSyntax name, SyntaxToken equalsToken, SyntaxToken startQuoteToken, GreenNode textTokens, SyntaxToken endQuoteToken)
        : base(kind)
    {
        this.SlotCount = 5;
        this.AdjustFlagsAndWidth(name);
        this.name = name;
        this.AdjustFlagsAndWidth(equalsToken);
        this.equalsToken = equalsToken;
        this.AdjustFlagsAndWidth(startQuoteToken);
        this.startQuoteToken = startQuoteToken;
        if (textTokens != null)
        {
            this.AdjustFlagsAndWidth(textTokens);
            this.textTokens = textTokens;
        }
        this.AdjustFlagsAndWidth(endQuoteToken);
        this.endQuoteToken = endQuoteToken;
    }

    public override XmlNameSyntax Name { get { return this.name; } }
    public override SyntaxToken EqualsToken { get { return this.equalsToken; } }
    public override SyntaxToken StartQuoteToken { get { return this.startQuoteToken; } }
    public Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SyntaxToken> TextTokens { get { return new Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SyntaxToken>(this.textTokens); } }
    public override SyntaxToken EndQuoteToken { get { return this.endQuoteToken; } }

    internal override GreenNode GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.name;
            case 1: return this.equalsToken;
            case 2: return this.startQuoteToken;
            case 3: return this.textTokens;
            case 4: return this.endQuoteToken;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode parent, int position)
    {
      return new CSharp.Syntax.XmlTextAttributeSyntax(this, parent, position);
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitXmlTextAttribute(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitXmlTextAttribute(this);
    }

    public XmlTextAttributeSyntax Update(XmlNameSyntax name, SyntaxToken equalsToken, SyntaxToken startQuoteToken, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SyntaxToken> textTokens, SyntaxToken endQuoteToken)
    {
        if (name != this.Name || equalsToken != this.EqualsToken || startQuoteToken != this.StartQuoteToken || textTokens != this.TextTokens || endQuoteToken != this.EndQuoteToken)
        {
            var newNode = SyntaxFactory.XmlTextAttribute(name, equalsToken, startQuoteToken, textTokens, endQuoteToken);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
    {
         return new XmlTextAttributeSyntax(this.Kind, this.name, this.equalsToken, this.startQuoteToken, this.textTokens, this.endQuoteToken, diagnostics, GetAnnotations());
    }

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
    {
         return new XmlTextAttributeSyntax(this.Kind, this.name, this.equalsToken, this.startQuoteToken, this.textTokens, this.endQuoteToken, GetDiagnostics(), annotations);
    }

    internal XmlTextAttributeSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 5;
      var name = (XmlNameSyntax)reader.ReadValue();
      if (name != null)
      {
         AdjustFlagsAndWidth(name);
         this.name = name;
      }
      var equalsToken = (SyntaxToken)reader.ReadValue();
      if (equalsToken != null)
      {
         AdjustFlagsAndWidth(equalsToken);
         this.equalsToken = equalsToken;
      }
      var startQuoteToken = (SyntaxToken)reader.ReadValue();
      if (startQuoteToken != null)
      {
         AdjustFlagsAndWidth(startQuoteToken);
         this.startQuoteToken = startQuoteToken;
      }
      var textTokens = (GreenNode)reader.ReadValue();
      if (textTokens != null)
      {
         AdjustFlagsAndWidth(textTokens);
         this.textTokens = textTokens;
      }
      var endQuoteToken = (SyntaxToken)reader.ReadValue();
      if (endQuoteToken != null)
      {
         AdjustFlagsAndWidth(endQuoteToken);
         this.endQuoteToken = endQuoteToken;
      }
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.name);
      writer.WriteValue(this.equalsToken);
      writer.WriteValue(this.startQuoteToken);
      writer.WriteValue(this.textTokens);
      writer.WriteValue(this.endQuoteToken);
    }

    static XmlTextAttributeSyntax()
    {
       ObjectBinder.RegisterTypeReader(typeof(XmlTextAttributeSyntax), r => new XmlTextAttributeSyntax(r));
    }
  }

  internal sealed partial class XmlCrefAttributeSyntax : XmlAttributeSyntax
  {
    internal readonly XmlNameSyntax name;
    internal readonly SyntaxToken equalsToken;
    internal readonly SyntaxToken startQuoteToken;
    internal readonly CrefSyntax cref;
    internal readonly SyntaxToken endQuoteToken;

    internal XmlCrefAttributeSyntax(SyntaxKind kind, XmlNameSyntax name, SyntaxToken equalsToken, SyntaxToken startQuoteToken, CrefSyntax cref, SyntaxToken endQuoteToken, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 5;
        this.AdjustFlagsAndWidth(name);
        this.name = name;
        this.AdjustFlagsAndWidth(equalsToken);
        this.equalsToken = equalsToken;
        this.AdjustFlagsAndWidth(startQuoteToken);
        this.startQuoteToken = startQuoteToken;
        this.AdjustFlagsAndWidth(cref);
        this.cref = cref;
        this.AdjustFlagsAndWidth(endQuoteToken);
        this.endQuoteToken = endQuoteToken;
    }


    internal XmlCrefAttributeSyntax(SyntaxKind kind, XmlNameSyntax name, SyntaxToken equalsToken, SyntaxToken startQuoteToken, CrefSyntax cref, SyntaxToken endQuoteToken, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 5;
        this.AdjustFlagsAndWidth(name);
        this.name = name;
        this.AdjustFlagsAndWidth(equalsToken);
        this.equalsToken = equalsToken;
        this.AdjustFlagsAndWidth(startQuoteToken);
        this.startQuoteToken = startQuoteToken;
        this.AdjustFlagsAndWidth(cref);
        this.cref = cref;
        this.AdjustFlagsAndWidth(endQuoteToken);
        this.endQuoteToken = endQuoteToken;
    }


    internal XmlCrefAttributeSyntax(SyntaxKind kind, XmlNameSyntax name, SyntaxToken equalsToken, SyntaxToken startQuoteToken, CrefSyntax cref, SyntaxToken endQuoteToken)
        : base(kind)
    {
        this.SlotCount = 5;
        this.AdjustFlagsAndWidth(name);
        this.name = name;
        this.AdjustFlagsAndWidth(equalsToken);
        this.equalsToken = equalsToken;
        this.AdjustFlagsAndWidth(startQuoteToken);
        this.startQuoteToken = startQuoteToken;
        this.AdjustFlagsAndWidth(cref);
        this.cref = cref;
        this.AdjustFlagsAndWidth(endQuoteToken);
        this.endQuoteToken = endQuoteToken;
    }

    public override XmlNameSyntax Name { get { return this.name; } }
    public override SyntaxToken EqualsToken { get { return this.equalsToken; } }
    public override SyntaxToken StartQuoteToken { get { return this.startQuoteToken; } }
    public CrefSyntax Cref { get { return this.cref; } }
    public override SyntaxToken EndQuoteToken { get { return this.endQuoteToken; } }

    internal override GreenNode GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.name;
            case 1: return this.equalsToken;
            case 2: return this.startQuoteToken;
            case 3: return this.cref;
            case 4: return this.endQuoteToken;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode parent, int position)
    {
      return new CSharp.Syntax.XmlCrefAttributeSyntax(this, parent, position);
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitXmlCrefAttribute(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitXmlCrefAttribute(this);
    }

    public XmlCrefAttributeSyntax Update(XmlNameSyntax name, SyntaxToken equalsToken, SyntaxToken startQuoteToken, CrefSyntax cref, SyntaxToken endQuoteToken)
    {
        if (name != this.Name || equalsToken != this.EqualsToken || startQuoteToken != this.StartQuoteToken || cref != this.Cref || endQuoteToken != this.EndQuoteToken)
        {
            var newNode = SyntaxFactory.XmlCrefAttribute(name, equalsToken, startQuoteToken, cref, endQuoteToken);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
    {
         return new XmlCrefAttributeSyntax(this.Kind, this.name, this.equalsToken, this.startQuoteToken, this.cref, this.endQuoteToken, diagnostics, GetAnnotations());
    }

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
    {
         return new XmlCrefAttributeSyntax(this.Kind, this.name, this.equalsToken, this.startQuoteToken, this.cref, this.endQuoteToken, GetDiagnostics(), annotations);
    }

    internal XmlCrefAttributeSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 5;
      var name = (XmlNameSyntax)reader.ReadValue();
      if (name != null)
      {
         AdjustFlagsAndWidth(name);
         this.name = name;
      }
      var equalsToken = (SyntaxToken)reader.ReadValue();
      if (equalsToken != null)
      {
         AdjustFlagsAndWidth(equalsToken);
         this.equalsToken = equalsToken;
      }
      var startQuoteToken = (SyntaxToken)reader.ReadValue();
      if (startQuoteToken != null)
      {
         AdjustFlagsAndWidth(startQuoteToken);
         this.startQuoteToken = startQuoteToken;
      }
      var cref = (CrefSyntax)reader.ReadValue();
      if (cref != null)
      {
         AdjustFlagsAndWidth(cref);
         this.cref = cref;
      }
      var endQuoteToken = (SyntaxToken)reader.ReadValue();
      if (endQuoteToken != null)
      {
         AdjustFlagsAndWidth(endQuoteToken);
         this.endQuoteToken = endQuoteToken;
      }
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.name);
      writer.WriteValue(this.equalsToken);
      writer.WriteValue(this.startQuoteToken);
      writer.WriteValue(this.cref);
      writer.WriteValue(this.endQuoteToken);
    }

    static XmlCrefAttributeSyntax()
    {
       ObjectBinder.RegisterTypeReader(typeof(XmlCrefAttributeSyntax), r => new XmlCrefAttributeSyntax(r));
    }
  }

  internal sealed partial class XmlNameAttributeSyntax : XmlAttributeSyntax
  {
    internal readonly XmlNameSyntax name;
    internal readonly SyntaxToken equalsToken;
    internal readonly SyntaxToken startQuoteToken;
    internal readonly IdentifierNameSyntax identifier;
    internal readonly SyntaxToken endQuoteToken;

    internal XmlNameAttributeSyntax(SyntaxKind kind, XmlNameSyntax name, SyntaxToken equalsToken, SyntaxToken startQuoteToken, IdentifierNameSyntax identifier, SyntaxToken endQuoteToken, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 5;
        this.AdjustFlagsAndWidth(name);
        this.name = name;
        this.AdjustFlagsAndWidth(equalsToken);
        this.equalsToken = equalsToken;
        this.AdjustFlagsAndWidth(startQuoteToken);
        this.startQuoteToken = startQuoteToken;
        this.AdjustFlagsAndWidth(identifier);
        this.identifier = identifier;
        this.AdjustFlagsAndWidth(endQuoteToken);
        this.endQuoteToken = endQuoteToken;
    }


    internal XmlNameAttributeSyntax(SyntaxKind kind, XmlNameSyntax name, SyntaxToken equalsToken, SyntaxToken startQuoteToken, IdentifierNameSyntax identifier, SyntaxToken endQuoteToken, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 5;
        this.AdjustFlagsAndWidth(name);
        this.name = name;
        this.AdjustFlagsAndWidth(equalsToken);
        this.equalsToken = equalsToken;
        this.AdjustFlagsAndWidth(startQuoteToken);
        this.startQuoteToken = startQuoteToken;
        this.AdjustFlagsAndWidth(identifier);
        this.identifier = identifier;
        this.AdjustFlagsAndWidth(endQuoteToken);
        this.endQuoteToken = endQuoteToken;
    }


    internal XmlNameAttributeSyntax(SyntaxKind kind, XmlNameSyntax name, SyntaxToken equalsToken, SyntaxToken startQuoteToken, IdentifierNameSyntax identifier, SyntaxToken endQuoteToken)
        : base(kind)
    {
        this.SlotCount = 5;
        this.AdjustFlagsAndWidth(name);
        this.name = name;
        this.AdjustFlagsAndWidth(equalsToken);
        this.equalsToken = equalsToken;
        this.AdjustFlagsAndWidth(startQuoteToken);
        this.startQuoteToken = startQuoteToken;
        this.AdjustFlagsAndWidth(identifier);
        this.identifier = identifier;
        this.AdjustFlagsAndWidth(endQuoteToken);
        this.endQuoteToken = endQuoteToken;
    }

    public override XmlNameSyntax Name { get { return this.name; } }
    public override SyntaxToken EqualsToken { get { return this.equalsToken; } }
    public override SyntaxToken StartQuoteToken { get { return this.startQuoteToken; } }
    public IdentifierNameSyntax Identifier { get { return this.identifier; } }
    public override SyntaxToken EndQuoteToken { get { return this.endQuoteToken; } }

    internal override GreenNode GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.name;
            case 1: return this.equalsToken;
            case 2: return this.startQuoteToken;
            case 3: return this.identifier;
            case 4: return this.endQuoteToken;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode parent, int position)
    {
      return new CSharp.Syntax.XmlNameAttributeSyntax(this, parent, position);
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitXmlNameAttribute(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitXmlNameAttribute(this);
    }

    public XmlNameAttributeSyntax Update(XmlNameSyntax name, SyntaxToken equalsToken, SyntaxToken startQuoteToken, IdentifierNameSyntax identifier, SyntaxToken endQuoteToken)
    {
        if (name != this.Name || equalsToken != this.EqualsToken || startQuoteToken != this.StartQuoteToken || identifier != this.Identifier || endQuoteToken != this.EndQuoteToken)
        {
            var newNode = SyntaxFactory.XmlNameAttribute(name, equalsToken, startQuoteToken, identifier, endQuoteToken);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
    {
         return new XmlNameAttributeSyntax(this.Kind, this.name, this.equalsToken, this.startQuoteToken, this.identifier, this.endQuoteToken, diagnostics, GetAnnotations());
    }

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
    {
         return new XmlNameAttributeSyntax(this.Kind, this.name, this.equalsToken, this.startQuoteToken, this.identifier, this.endQuoteToken, GetDiagnostics(), annotations);
    }

    internal XmlNameAttributeSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 5;
      var name = (XmlNameSyntax)reader.ReadValue();
      if (name != null)
      {
         AdjustFlagsAndWidth(name);
         this.name = name;
      }
      var equalsToken = (SyntaxToken)reader.ReadValue();
      if (equalsToken != null)
      {
         AdjustFlagsAndWidth(equalsToken);
         this.equalsToken = equalsToken;
      }
      var startQuoteToken = (SyntaxToken)reader.ReadValue();
      if (startQuoteToken != null)
      {
         AdjustFlagsAndWidth(startQuoteToken);
         this.startQuoteToken = startQuoteToken;
      }
      var identifier = (IdentifierNameSyntax)reader.ReadValue();
      if (identifier != null)
      {
         AdjustFlagsAndWidth(identifier);
         this.identifier = identifier;
      }
      var endQuoteToken = (SyntaxToken)reader.ReadValue();
      if (endQuoteToken != null)
      {
         AdjustFlagsAndWidth(endQuoteToken);
         this.endQuoteToken = endQuoteToken;
      }
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.name);
      writer.WriteValue(this.equalsToken);
      writer.WriteValue(this.startQuoteToken);
      writer.WriteValue(this.identifier);
      writer.WriteValue(this.endQuoteToken);
    }

    static XmlNameAttributeSyntax()
    {
       ObjectBinder.RegisterTypeReader(typeof(XmlNameAttributeSyntax), r => new XmlNameAttributeSyntax(r));
    }
  }

  internal sealed partial class XmlTextSyntax : XmlNodeSyntax
  {
    internal readonly GreenNode textTokens;

    internal XmlTextSyntax(SyntaxKind kind, GreenNode textTokens, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 1;
        if (textTokens != null)
        {
            this.AdjustFlagsAndWidth(textTokens);
            this.textTokens = textTokens;
        }
    }


    internal XmlTextSyntax(SyntaxKind kind, GreenNode textTokens, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 1;
        if (textTokens != null)
        {
            this.AdjustFlagsAndWidth(textTokens);
            this.textTokens = textTokens;
        }
    }


    internal XmlTextSyntax(SyntaxKind kind, GreenNode textTokens)
        : base(kind)
    {
        this.SlotCount = 1;
        if (textTokens != null)
        {
            this.AdjustFlagsAndWidth(textTokens);
            this.textTokens = textTokens;
        }
    }

    public Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SyntaxToken> TextTokens { get { return new Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SyntaxToken>(this.textTokens); } }

    internal override GreenNode GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.textTokens;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode parent, int position)
    {
      return new CSharp.Syntax.XmlTextSyntax(this, parent, position);
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitXmlText(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitXmlText(this);
    }

    public XmlTextSyntax Update(Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SyntaxToken> textTokens)
    {
        if (textTokens != this.TextTokens)
        {
            var newNode = SyntaxFactory.XmlText(textTokens);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
    {
         return new XmlTextSyntax(this.Kind, this.textTokens, diagnostics, GetAnnotations());
    }

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
    {
         return new XmlTextSyntax(this.Kind, this.textTokens, GetDiagnostics(), annotations);
    }

    internal XmlTextSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 1;
      var textTokens = (GreenNode)reader.ReadValue();
      if (textTokens != null)
      {
         AdjustFlagsAndWidth(textTokens);
         this.textTokens = textTokens;
      }
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.textTokens);
    }

    static XmlTextSyntax()
    {
       ObjectBinder.RegisterTypeReader(typeof(XmlTextSyntax), r => new XmlTextSyntax(r));
    }
  }

  internal sealed partial class XmlCDataSectionSyntax : XmlNodeSyntax
  {
    internal readonly SyntaxToken startCDataToken;
    internal readonly GreenNode textTokens;
    internal readonly SyntaxToken endCDataToken;

    internal XmlCDataSectionSyntax(SyntaxKind kind, SyntaxToken startCDataToken, GreenNode textTokens, SyntaxToken endCDataToken, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 3;
        this.AdjustFlagsAndWidth(startCDataToken);
        this.startCDataToken = startCDataToken;
        if (textTokens != null)
        {
            this.AdjustFlagsAndWidth(textTokens);
            this.textTokens = textTokens;
        }
        this.AdjustFlagsAndWidth(endCDataToken);
        this.endCDataToken = endCDataToken;
    }


    internal XmlCDataSectionSyntax(SyntaxKind kind, SyntaxToken startCDataToken, GreenNode textTokens, SyntaxToken endCDataToken, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 3;
        this.AdjustFlagsAndWidth(startCDataToken);
        this.startCDataToken = startCDataToken;
        if (textTokens != null)
        {
            this.AdjustFlagsAndWidth(textTokens);
            this.textTokens = textTokens;
        }
        this.AdjustFlagsAndWidth(endCDataToken);
        this.endCDataToken = endCDataToken;
    }


    internal XmlCDataSectionSyntax(SyntaxKind kind, SyntaxToken startCDataToken, GreenNode textTokens, SyntaxToken endCDataToken)
        : base(kind)
    {
        this.SlotCount = 3;
        this.AdjustFlagsAndWidth(startCDataToken);
        this.startCDataToken = startCDataToken;
        if (textTokens != null)
        {
            this.AdjustFlagsAndWidth(textTokens);
            this.textTokens = textTokens;
        }
        this.AdjustFlagsAndWidth(endCDataToken);
        this.endCDataToken = endCDataToken;
    }

    public SyntaxToken StartCDataToken { get { return this.startCDataToken; } }
    public Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SyntaxToken> TextTokens { get { return new Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SyntaxToken>(this.textTokens); } }
    public SyntaxToken EndCDataToken { get { return this.endCDataToken; } }

    internal override GreenNode GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.startCDataToken;
            case 1: return this.textTokens;
            case 2: return this.endCDataToken;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode parent, int position)
    {
      return new CSharp.Syntax.XmlCDataSectionSyntax(this, parent, position);
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitXmlCDataSection(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitXmlCDataSection(this);
    }

    public XmlCDataSectionSyntax Update(SyntaxToken startCDataToken, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SyntaxToken> textTokens, SyntaxToken endCDataToken)
    {
        if (startCDataToken != this.StartCDataToken || textTokens != this.TextTokens || endCDataToken != this.EndCDataToken)
        {
            var newNode = SyntaxFactory.XmlCDataSection(startCDataToken, textTokens, endCDataToken);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
    {
         return new XmlCDataSectionSyntax(this.Kind, this.startCDataToken, this.textTokens, this.endCDataToken, diagnostics, GetAnnotations());
    }

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
    {
         return new XmlCDataSectionSyntax(this.Kind, this.startCDataToken, this.textTokens, this.endCDataToken, GetDiagnostics(), annotations);
    }

    internal XmlCDataSectionSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 3;
      var startCDataToken = (SyntaxToken)reader.ReadValue();
      if (startCDataToken != null)
      {
         AdjustFlagsAndWidth(startCDataToken);
         this.startCDataToken = startCDataToken;
      }
      var textTokens = (GreenNode)reader.ReadValue();
      if (textTokens != null)
      {
         AdjustFlagsAndWidth(textTokens);
         this.textTokens = textTokens;
      }
      var endCDataToken = (SyntaxToken)reader.ReadValue();
      if (endCDataToken != null)
      {
         AdjustFlagsAndWidth(endCDataToken);
         this.endCDataToken = endCDataToken;
      }
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.startCDataToken);
      writer.WriteValue(this.textTokens);
      writer.WriteValue(this.endCDataToken);
    }

    static XmlCDataSectionSyntax()
    {
       ObjectBinder.RegisterTypeReader(typeof(XmlCDataSectionSyntax), r => new XmlCDataSectionSyntax(r));
    }
  }

  internal sealed partial class XmlProcessingInstructionSyntax : XmlNodeSyntax
  {
    internal readonly SyntaxToken startProcessingInstructionToken;
    internal readonly XmlNameSyntax name;
    internal readonly GreenNode textTokens;
    internal readonly SyntaxToken endProcessingInstructionToken;

    internal XmlProcessingInstructionSyntax(SyntaxKind kind, SyntaxToken startProcessingInstructionToken, XmlNameSyntax name, GreenNode textTokens, SyntaxToken endProcessingInstructionToken, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 4;
        this.AdjustFlagsAndWidth(startProcessingInstructionToken);
        this.startProcessingInstructionToken = startProcessingInstructionToken;
        this.AdjustFlagsAndWidth(name);
        this.name = name;
        if (textTokens != null)
        {
            this.AdjustFlagsAndWidth(textTokens);
            this.textTokens = textTokens;
        }
        this.AdjustFlagsAndWidth(endProcessingInstructionToken);
        this.endProcessingInstructionToken = endProcessingInstructionToken;
    }


    internal XmlProcessingInstructionSyntax(SyntaxKind kind, SyntaxToken startProcessingInstructionToken, XmlNameSyntax name, GreenNode textTokens, SyntaxToken endProcessingInstructionToken, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 4;
        this.AdjustFlagsAndWidth(startProcessingInstructionToken);
        this.startProcessingInstructionToken = startProcessingInstructionToken;
        this.AdjustFlagsAndWidth(name);
        this.name = name;
        if (textTokens != null)
        {
            this.AdjustFlagsAndWidth(textTokens);
            this.textTokens = textTokens;
        }
        this.AdjustFlagsAndWidth(endProcessingInstructionToken);
        this.endProcessingInstructionToken = endProcessingInstructionToken;
    }


    internal XmlProcessingInstructionSyntax(SyntaxKind kind, SyntaxToken startProcessingInstructionToken, XmlNameSyntax name, GreenNode textTokens, SyntaxToken endProcessingInstructionToken)
        : base(kind)
    {
        this.SlotCount = 4;
        this.AdjustFlagsAndWidth(startProcessingInstructionToken);
        this.startProcessingInstructionToken = startProcessingInstructionToken;
        this.AdjustFlagsAndWidth(name);
        this.name = name;
        if (textTokens != null)
        {
            this.AdjustFlagsAndWidth(textTokens);
            this.textTokens = textTokens;
        }
        this.AdjustFlagsAndWidth(endProcessingInstructionToken);
        this.endProcessingInstructionToken = endProcessingInstructionToken;
    }

    public SyntaxToken StartProcessingInstructionToken { get { return this.startProcessingInstructionToken; } }
    public XmlNameSyntax Name { get { return this.name; } }
    public Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SyntaxToken> TextTokens { get { return new Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SyntaxToken>(this.textTokens); } }
    public SyntaxToken EndProcessingInstructionToken { get { return this.endProcessingInstructionToken; } }

    internal override GreenNode GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.startProcessingInstructionToken;
            case 1: return this.name;
            case 2: return this.textTokens;
            case 3: return this.endProcessingInstructionToken;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode parent, int position)
    {
      return new CSharp.Syntax.XmlProcessingInstructionSyntax(this, parent, position);
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitXmlProcessingInstruction(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitXmlProcessingInstruction(this);
    }

    public XmlProcessingInstructionSyntax Update(SyntaxToken startProcessingInstructionToken, XmlNameSyntax name, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SyntaxToken> textTokens, SyntaxToken endProcessingInstructionToken)
    {
        if (startProcessingInstructionToken != this.StartProcessingInstructionToken || name != this.Name || textTokens != this.TextTokens || endProcessingInstructionToken != this.EndProcessingInstructionToken)
        {
            var newNode = SyntaxFactory.XmlProcessingInstruction(startProcessingInstructionToken, name, textTokens, endProcessingInstructionToken);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
    {
         return new XmlProcessingInstructionSyntax(this.Kind, this.startProcessingInstructionToken, this.name, this.textTokens, this.endProcessingInstructionToken, diagnostics, GetAnnotations());
    }

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
    {
         return new XmlProcessingInstructionSyntax(this.Kind, this.startProcessingInstructionToken, this.name, this.textTokens, this.endProcessingInstructionToken, GetDiagnostics(), annotations);
    }

    internal XmlProcessingInstructionSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 4;
      var startProcessingInstructionToken = (SyntaxToken)reader.ReadValue();
      if (startProcessingInstructionToken != null)
      {
         AdjustFlagsAndWidth(startProcessingInstructionToken);
         this.startProcessingInstructionToken = startProcessingInstructionToken;
      }
      var name = (XmlNameSyntax)reader.ReadValue();
      if (name != null)
      {
         AdjustFlagsAndWidth(name);
         this.name = name;
      }
      var textTokens = (GreenNode)reader.ReadValue();
      if (textTokens != null)
      {
         AdjustFlagsAndWidth(textTokens);
         this.textTokens = textTokens;
      }
      var endProcessingInstructionToken = (SyntaxToken)reader.ReadValue();
      if (endProcessingInstructionToken != null)
      {
         AdjustFlagsAndWidth(endProcessingInstructionToken);
         this.endProcessingInstructionToken = endProcessingInstructionToken;
      }
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.startProcessingInstructionToken);
      writer.WriteValue(this.name);
      writer.WriteValue(this.textTokens);
      writer.WriteValue(this.endProcessingInstructionToken);
    }

    static XmlProcessingInstructionSyntax()
    {
       ObjectBinder.RegisterTypeReader(typeof(XmlProcessingInstructionSyntax), r => new XmlProcessingInstructionSyntax(r));
    }
  }

  internal sealed partial class XmlCommentSyntax : XmlNodeSyntax
  {
    internal readonly SyntaxToken lessThanExclamationMinusMinusToken;
    internal readonly GreenNode textTokens;
    internal readonly SyntaxToken minusMinusGreaterThanToken;

    internal XmlCommentSyntax(SyntaxKind kind, SyntaxToken lessThanExclamationMinusMinusToken, GreenNode textTokens, SyntaxToken minusMinusGreaterThanToken, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 3;
        this.AdjustFlagsAndWidth(lessThanExclamationMinusMinusToken);
        this.lessThanExclamationMinusMinusToken = lessThanExclamationMinusMinusToken;
        if (textTokens != null)
        {
            this.AdjustFlagsAndWidth(textTokens);
            this.textTokens = textTokens;
        }
        this.AdjustFlagsAndWidth(minusMinusGreaterThanToken);
        this.minusMinusGreaterThanToken = minusMinusGreaterThanToken;
    }


    internal XmlCommentSyntax(SyntaxKind kind, SyntaxToken lessThanExclamationMinusMinusToken, GreenNode textTokens, SyntaxToken minusMinusGreaterThanToken, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 3;
        this.AdjustFlagsAndWidth(lessThanExclamationMinusMinusToken);
        this.lessThanExclamationMinusMinusToken = lessThanExclamationMinusMinusToken;
        if (textTokens != null)
        {
            this.AdjustFlagsAndWidth(textTokens);
            this.textTokens = textTokens;
        }
        this.AdjustFlagsAndWidth(minusMinusGreaterThanToken);
        this.minusMinusGreaterThanToken = minusMinusGreaterThanToken;
    }


    internal XmlCommentSyntax(SyntaxKind kind, SyntaxToken lessThanExclamationMinusMinusToken, GreenNode textTokens, SyntaxToken minusMinusGreaterThanToken)
        : base(kind)
    {
        this.SlotCount = 3;
        this.AdjustFlagsAndWidth(lessThanExclamationMinusMinusToken);
        this.lessThanExclamationMinusMinusToken = lessThanExclamationMinusMinusToken;
        if (textTokens != null)
        {
            this.AdjustFlagsAndWidth(textTokens);
            this.textTokens = textTokens;
        }
        this.AdjustFlagsAndWidth(minusMinusGreaterThanToken);
        this.minusMinusGreaterThanToken = minusMinusGreaterThanToken;
    }

    public SyntaxToken LessThanExclamationMinusMinusToken { get { return this.lessThanExclamationMinusMinusToken; } }
    public Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SyntaxToken> TextTokens { get { return new Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SyntaxToken>(this.textTokens); } }
    public SyntaxToken MinusMinusGreaterThanToken { get { return this.minusMinusGreaterThanToken; } }

    internal override GreenNode GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.lessThanExclamationMinusMinusToken;
            case 1: return this.textTokens;
            case 2: return this.minusMinusGreaterThanToken;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode parent, int position)
    {
      return new CSharp.Syntax.XmlCommentSyntax(this, parent, position);
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitXmlComment(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitXmlComment(this);
    }

    public XmlCommentSyntax Update(SyntaxToken lessThanExclamationMinusMinusToken, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SyntaxToken> textTokens, SyntaxToken minusMinusGreaterThanToken)
    {
        if (lessThanExclamationMinusMinusToken != this.LessThanExclamationMinusMinusToken || textTokens != this.TextTokens || minusMinusGreaterThanToken != this.MinusMinusGreaterThanToken)
        {
            var newNode = SyntaxFactory.XmlComment(lessThanExclamationMinusMinusToken, textTokens, minusMinusGreaterThanToken);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
    {
         return new XmlCommentSyntax(this.Kind, this.lessThanExclamationMinusMinusToken, this.textTokens, this.minusMinusGreaterThanToken, diagnostics, GetAnnotations());
    }

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
    {
         return new XmlCommentSyntax(this.Kind, this.lessThanExclamationMinusMinusToken, this.textTokens, this.minusMinusGreaterThanToken, GetDiagnostics(), annotations);
    }

    internal XmlCommentSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 3;
      var lessThanExclamationMinusMinusToken = (SyntaxToken)reader.ReadValue();
      if (lessThanExclamationMinusMinusToken != null)
      {
         AdjustFlagsAndWidth(lessThanExclamationMinusMinusToken);
         this.lessThanExclamationMinusMinusToken = lessThanExclamationMinusMinusToken;
      }
      var textTokens = (GreenNode)reader.ReadValue();
      if (textTokens != null)
      {
         AdjustFlagsAndWidth(textTokens);
         this.textTokens = textTokens;
      }
      var minusMinusGreaterThanToken = (SyntaxToken)reader.ReadValue();
      if (minusMinusGreaterThanToken != null)
      {
         AdjustFlagsAndWidth(minusMinusGreaterThanToken);
         this.minusMinusGreaterThanToken = minusMinusGreaterThanToken;
      }
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.lessThanExclamationMinusMinusToken);
      writer.WriteValue(this.textTokens);
      writer.WriteValue(this.minusMinusGreaterThanToken);
    }

    static XmlCommentSyntax()
    {
       ObjectBinder.RegisterTypeReader(typeof(XmlCommentSyntax), r => new XmlCommentSyntax(r));
    }
  }

  internal abstract partial class DirectiveTriviaSyntax : StructuredTriviaSyntax
  {
    internal DirectiveTriviaSyntax(SyntaxKind kind, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
      : base(kind, diagnostics, annotations)
    {
      this.flags |= NodeFlags.ContainsDirectives;
    }
    internal DirectiveTriviaSyntax(SyntaxKind kind)
      : base(kind)
    {
      this.flags |= NodeFlags.ContainsDirectives;
    }

    protected DirectiveTriviaSyntax(ObjectReader reader)
       : base(reader)
    {
      this.flags |= NodeFlags.ContainsDirectives;
    }

    public abstract SyntaxToken HashToken { get; }

    public abstract SyntaxToken EndOfDirectiveToken { get; }

   public abstract bool IsActive { get; }
  }

  internal abstract partial class BranchingDirectiveTriviaSyntax : DirectiveTriviaSyntax
  {
    internal BranchingDirectiveTriviaSyntax(SyntaxKind kind, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
      : base(kind, diagnostics, annotations)
    {
    }
    internal BranchingDirectiveTriviaSyntax(SyntaxKind kind)
      : base(kind)
    {
    }

    protected BranchingDirectiveTriviaSyntax(ObjectReader reader)
       : base(reader)
    {
    }

   public abstract bool BranchTaken { get; }
  }

  internal abstract partial class ConditionalDirectiveTriviaSyntax : BranchingDirectiveTriviaSyntax
  {
    internal ConditionalDirectiveTriviaSyntax(SyntaxKind kind, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
      : base(kind, diagnostics, annotations)
    {
    }
    internal ConditionalDirectiveTriviaSyntax(SyntaxKind kind)
      : base(kind)
    {
    }

    protected ConditionalDirectiveTriviaSyntax(ObjectReader reader)
       : base(reader)
    {
    }

    public abstract ExpressionSyntax Condition { get; }

   public abstract bool ConditionValue { get; }
  }

  internal sealed partial class IfDirectiveTriviaSyntax : ConditionalDirectiveTriviaSyntax
  {
    internal readonly SyntaxToken hashToken;
    internal readonly SyntaxToken ifKeyword;
    internal readonly ExpressionSyntax condition;
    internal readonly SyntaxToken endOfDirectiveToken;
    internal readonly bool isActive;
    internal readonly bool branchTaken;
    internal readonly bool conditionValue;

    internal IfDirectiveTriviaSyntax(SyntaxKind kind, SyntaxToken hashToken, SyntaxToken ifKeyword, ExpressionSyntax condition, SyntaxToken endOfDirectiveToken, bool isActive, bool branchTaken, bool conditionValue, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 4;
        this.AdjustFlagsAndWidth(hashToken);
        this.hashToken = hashToken;
        this.AdjustFlagsAndWidth(ifKeyword);
        this.ifKeyword = ifKeyword;
        this.AdjustFlagsAndWidth(condition);
        this.condition = condition;
        this.AdjustFlagsAndWidth(endOfDirectiveToken);
        this.endOfDirectiveToken = endOfDirectiveToken;
        this.isActive = isActive;
        this.branchTaken = branchTaken;
        this.conditionValue = conditionValue;
    }


    internal IfDirectiveTriviaSyntax(SyntaxKind kind, SyntaxToken hashToken, SyntaxToken ifKeyword, ExpressionSyntax condition, SyntaxToken endOfDirectiveToken, bool isActive, bool branchTaken, bool conditionValue, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 4;
        this.AdjustFlagsAndWidth(hashToken);
        this.hashToken = hashToken;
        this.AdjustFlagsAndWidth(ifKeyword);
        this.ifKeyword = ifKeyword;
        this.AdjustFlagsAndWidth(condition);
        this.condition = condition;
        this.AdjustFlagsAndWidth(endOfDirectiveToken);
        this.endOfDirectiveToken = endOfDirectiveToken;
        this.isActive = isActive;
        this.branchTaken = branchTaken;
        this.conditionValue = conditionValue;
    }


    internal IfDirectiveTriviaSyntax(SyntaxKind kind, SyntaxToken hashToken, SyntaxToken ifKeyword, ExpressionSyntax condition, SyntaxToken endOfDirectiveToken, bool isActive, bool branchTaken, bool conditionValue)
        : base(kind)
    {
        this.SlotCount = 4;
        this.AdjustFlagsAndWidth(hashToken);
        this.hashToken = hashToken;
        this.AdjustFlagsAndWidth(ifKeyword);
        this.ifKeyword = ifKeyword;
        this.AdjustFlagsAndWidth(condition);
        this.condition = condition;
        this.AdjustFlagsAndWidth(endOfDirectiveToken);
        this.endOfDirectiveToken = endOfDirectiveToken;
        this.isActive = isActive;
        this.branchTaken = branchTaken;
        this.conditionValue = conditionValue;
    }

    public override SyntaxToken HashToken { get { return this.hashToken; } }
    public SyntaxToken IfKeyword { get { return this.ifKeyword; } }
    public override ExpressionSyntax Condition { get { return this.condition; } }
    public override SyntaxToken EndOfDirectiveToken { get { return this.endOfDirectiveToken; } }
    public override bool IsActive { get { return this.isActive; } }
    public override bool BranchTaken { get { return this.branchTaken; } }
    public override bool ConditionValue { get { return this.conditionValue; } }

    internal override GreenNode GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.hashToken;
            case 1: return this.ifKeyword;
            case 2: return this.condition;
            case 3: return this.endOfDirectiveToken;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode parent, int position)
    {
      return new CSharp.Syntax.IfDirectiveTriviaSyntax(this, parent, position);
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitIfDirectiveTrivia(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitIfDirectiveTrivia(this);
    }

    public IfDirectiveTriviaSyntax Update(SyntaxToken hashToken, SyntaxToken ifKeyword, ExpressionSyntax condition, SyntaxToken endOfDirectiveToken, bool isActive, bool branchTaken, bool conditionValue)
    {
        if (hashToken != this.HashToken || ifKeyword != this.IfKeyword || condition != this.Condition || endOfDirectiveToken != this.EndOfDirectiveToken)
        {
            var newNode = SyntaxFactory.IfDirectiveTrivia(hashToken, ifKeyword, condition, endOfDirectiveToken, isActive, branchTaken, conditionValue);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
    {
         return new IfDirectiveTriviaSyntax(this.Kind, this.hashToken, this.ifKeyword, this.condition, this.endOfDirectiveToken, this.isActive, this.branchTaken, this.conditionValue, diagnostics, GetAnnotations());
    }

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
    {
         return new IfDirectiveTriviaSyntax(this.Kind, this.hashToken, this.ifKeyword, this.condition, this.endOfDirectiveToken, this.isActive, this.branchTaken, this.conditionValue, GetDiagnostics(), annotations);
    }

    internal IfDirectiveTriviaSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 4;
      var hashToken = (SyntaxToken)reader.ReadValue();
      if (hashToken != null)
      {
         AdjustFlagsAndWidth(hashToken);
         this.hashToken = hashToken;
      }
      var ifKeyword = (SyntaxToken)reader.ReadValue();
      if (ifKeyword != null)
      {
         AdjustFlagsAndWidth(ifKeyword);
         this.ifKeyword = ifKeyword;
      }
      var condition = (ExpressionSyntax)reader.ReadValue();
      if (condition != null)
      {
         AdjustFlagsAndWidth(condition);
         this.condition = condition;
      }
      var endOfDirectiveToken = (SyntaxToken)reader.ReadValue();
      if (endOfDirectiveToken != null)
      {
         AdjustFlagsAndWidth(endOfDirectiveToken);
         this.endOfDirectiveToken = endOfDirectiveToken;
      }
      this.isActive = (bool)reader.ReadBoolean();
      this.branchTaken = (bool)reader.ReadBoolean();
      this.conditionValue = (bool)reader.ReadBoolean();
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.hashToken);
      writer.WriteValue(this.ifKeyword);
      writer.WriteValue(this.condition);
      writer.WriteValue(this.endOfDirectiveToken);
      writer.WriteBoolean(this.isActive);
      writer.WriteBoolean(this.branchTaken);
      writer.WriteBoolean(this.conditionValue);
    }

    static IfDirectiveTriviaSyntax()
    {
       ObjectBinder.RegisterTypeReader(typeof(IfDirectiveTriviaSyntax), r => new IfDirectiveTriviaSyntax(r));
    }
  }

  internal sealed partial class ElifDirectiveTriviaSyntax : ConditionalDirectiveTriviaSyntax
  {
    internal readonly SyntaxToken hashToken;
    internal readonly SyntaxToken elifKeyword;
    internal readonly ExpressionSyntax condition;
    internal readonly SyntaxToken endOfDirectiveToken;
    internal readonly bool isActive;
    internal readonly bool branchTaken;
    internal readonly bool conditionValue;

    internal ElifDirectiveTriviaSyntax(SyntaxKind kind, SyntaxToken hashToken, SyntaxToken elifKeyword, ExpressionSyntax condition, SyntaxToken endOfDirectiveToken, bool isActive, bool branchTaken, bool conditionValue, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 4;
        this.AdjustFlagsAndWidth(hashToken);
        this.hashToken = hashToken;
        this.AdjustFlagsAndWidth(elifKeyword);
        this.elifKeyword = elifKeyword;
        this.AdjustFlagsAndWidth(condition);
        this.condition = condition;
        this.AdjustFlagsAndWidth(endOfDirectiveToken);
        this.endOfDirectiveToken = endOfDirectiveToken;
        this.isActive = isActive;
        this.branchTaken = branchTaken;
        this.conditionValue = conditionValue;
    }


    internal ElifDirectiveTriviaSyntax(SyntaxKind kind, SyntaxToken hashToken, SyntaxToken elifKeyword, ExpressionSyntax condition, SyntaxToken endOfDirectiveToken, bool isActive, bool branchTaken, bool conditionValue, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 4;
        this.AdjustFlagsAndWidth(hashToken);
        this.hashToken = hashToken;
        this.AdjustFlagsAndWidth(elifKeyword);
        this.elifKeyword = elifKeyword;
        this.AdjustFlagsAndWidth(condition);
        this.condition = condition;
        this.AdjustFlagsAndWidth(endOfDirectiveToken);
        this.endOfDirectiveToken = endOfDirectiveToken;
        this.isActive = isActive;
        this.branchTaken = branchTaken;
        this.conditionValue = conditionValue;
    }


    internal ElifDirectiveTriviaSyntax(SyntaxKind kind, SyntaxToken hashToken, SyntaxToken elifKeyword, ExpressionSyntax condition, SyntaxToken endOfDirectiveToken, bool isActive, bool branchTaken, bool conditionValue)
        : base(kind)
    {
        this.SlotCount = 4;
        this.AdjustFlagsAndWidth(hashToken);
        this.hashToken = hashToken;
        this.AdjustFlagsAndWidth(elifKeyword);
        this.elifKeyword = elifKeyword;
        this.AdjustFlagsAndWidth(condition);
        this.condition = condition;
        this.AdjustFlagsAndWidth(endOfDirectiveToken);
        this.endOfDirectiveToken = endOfDirectiveToken;
        this.isActive = isActive;
        this.branchTaken = branchTaken;
        this.conditionValue = conditionValue;
    }

    public override SyntaxToken HashToken { get { return this.hashToken; } }
    public SyntaxToken ElifKeyword { get { return this.elifKeyword; } }
    public override ExpressionSyntax Condition { get { return this.condition; } }
    public override SyntaxToken EndOfDirectiveToken { get { return this.endOfDirectiveToken; } }
    public override bool IsActive { get { return this.isActive; } }
    public override bool BranchTaken { get { return this.branchTaken; } }
    public override bool ConditionValue { get { return this.conditionValue; } }

    internal override GreenNode GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.hashToken;
            case 1: return this.elifKeyword;
            case 2: return this.condition;
            case 3: return this.endOfDirectiveToken;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode parent, int position)
    {
      return new CSharp.Syntax.ElifDirectiveTriviaSyntax(this, parent, position);
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitElifDirectiveTrivia(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitElifDirectiveTrivia(this);
    }

    public ElifDirectiveTriviaSyntax Update(SyntaxToken hashToken, SyntaxToken elifKeyword, ExpressionSyntax condition, SyntaxToken endOfDirectiveToken, bool isActive, bool branchTaken, bool conditionValue)
    {
        if (hashToken != this.HashToken || elifKeyword != this.ElifKeyword || condition != this.Condition || endOfDirectiveToken != this.EndOfDirectiveToken)
        {
            var newNode = SyntaxFactory.ElifDirectiveTrivia(hashToken, elifKeyword, condition, endOfDirectiveToken, isActive, branchTaken, conditionValue);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
    {
         return new ElifDirectiveTriviaSyntax(this.Kind, this.hashToken, this.elifKeyword, this.condition, this.endOfDirectiveToken, this.isActive, this.branchTaken, this.conditionValue, diagnostics, GetAnnotations());
    }

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
    {
         return new ElifDirectiveTriviaSyntax(this.Kind, this.hashToken, this.elifKeyword, this.condition, this.endOfDirectiveToken, this.isActive, this.branchTaken, this.conditionValue, GetDiagnostics(), annotations);
    }

    internal ElifDirectiveTriviaSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 4;
      var hashToken = (SyntaxToken)reader.ReadValue();
      if (hashToken != null)
      {
         AdjustFlagsAndWidth(hashToken);
         this.hashToken = hashToken;
      }
      var elifKeyword = (SyntaxToken)reader.ReadValue();
      if (elifKeyword != null)
      {
         AdjustFlagsAndWidth(elifKeyword);
         this.elifKeyword = elifKeyword;
      }
      var condition = (ExpressionSyntax)reader.ReadValue();
      if (condition != null)
      {
         AdjustFlagsAndWidth(condition);
         this.condition = condition;
      }
      var endOfDirectiveToken = (SyntaxToken)reader.ReadValue();
      if (endOfDirectiveToken != null)
      {
         AdjustFlagsAndWidth(endOfDirectiveToken);
         this.endOfDirectiveToken = endOfDirectiveToken;
      }
      this.isActive = (bool)reader.ReadBoolean();
      this.branchTaken = (bool)reader.ReadBoolean();
      this.conditionValue = (bool)reader.ReadBoolean();
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.hashToken);
      writer.WriteValue(this.elifKeyword);
      writer.WriteValue(this.condition);
      writer.WriteValue(this.endOfDirectiveToken);
      writer.WriteBoolean(this.isActive);
      writer.WriteBoolean(this.branchTaken);
      writer.WriteBoolean(this.conditionValue);
    }

    static ElifDirectiveTriviaSyntax()
    {
       ObjectBinder.RegisterTypeReader(typeof(ElifDirectiveTriviaSyntax), r => new ElifDirectiveTriviaSyntax(r));
    }
  }

  internal sealed partial class ElseDirectiveTriviaSyntax : BranchingDirectiveTriviaSyntax
  {
    internal readonly SyntaxToken hashToken;
    internal readonly SyntaxToken elseKeyword;
    internal readonly SyntaxToken endOfDirectiveToken;
    internal readonly bool isActive;
    internal readonly bool branchTaken;

    internal ElseDirectiveTriviaSyntax(SyntaxKind kind, SyntaxToken hashToken, SyntaxToken elseKeyword, SyntaxToken endOfDirectiveToken, bool isActive, bool branchTaken, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 3;
        this.AdjustFlagsAndWidth(hashToken);
        this.hashToken = hashToken;
        this.AdjustFlagsAndWidth(elseKeyword);
        this.elseKeyword = elseKeyword;
        this.AdjustFlagsAndWidth(endOfDirectiveToken);
        this.endOfDirectiveToken = endOfDirectiveToken;
        this.isActive = isActive;
        this.branchTaken = branchTaken;
    }


    internal ElseDirectiveTriviaSyntax(SyntaxKind kind, SyntaxToken hashToken, SyntaxToken elseKeyword, SyntaxToken endOfDirectiveToken, bool isActive, bool branchTaken, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 3;
        this.AdjustFlagsAndWidth(hashToken);
        this.hashToken = hashToken;
        this.AdjustFlagsAndWidth(elseKeyword);
        this.elseKeyword = elseKeyword;
        this.AdjustFlagsAndWidth(endOfDirectiveToken);
        this.endOfDirectiveToken = endOfDirectiveToken;
        this.isActive = isActive;
        this.branchTaken = branchTaken;
    }


    internal ElseDirectiveTriviaSyntax(SyntaxKind kind, SyntaxToken hashToken, SyntaxToken elseKeyword, SyntaxToken endOfDirectiveToken, bool isActive, bool branchTaken)
        : base(kind)
    {
        this.SlotCount = 3;
        this.AdjustFlagsAndWidth(hashToken);
        this.hashToken = hashToken;
        this.AdjustFlagsAndWidth(elseKeyword);
        this.elseKeyword = elseKeyword;
        this.AdjustFlagsAndWidth(endOfDirectiveToken);
        this.endOfDirectiveToken = endOfDirectiveToken;
        this.isActive = isActive;
        this.branchTaken = branchTaken;
    }

    public override SyntaxToken HashToken { get { return this.hashToken; } }
    public SyntaxToken ElseKeyword { get { return this.elseKeyword; } }
    public override SyntaxToken EndOfDirectiveToken { get { return this.endOfDirectiveToken; } }
    public override bool IsActive { get { return this.isActive; } }
    public override bool BranchTaken { get { return this.branchTaken; } }

    internal override GreenNode GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.hashToken;
            case 1: return this.elseKeyword;
            case 2: return this.endOfDirectiveToken;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode parent, int position)
    {
      return new CSharp.Syntax.ElseDirectiveTriviaSyntax(this, parent, position);
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitElseDirectiveTrivia(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitElseDirectiveTrivia(this);
    }

    public ElseDirectiveTriviaSyntax Update(SyntaxToken hashToken, SyntaxToken elseKeyword, SyntaxToken endOfDirectiveToken, bool isActive, bool branchTaken)
    {
        if (hashToken != this.HashToken || elseKeyword != this.ElseKeyword || endOfDirectiveToken != this.EndOfDirectiveToken)
        {
            var newNode = SyntaxFactory.ElseDirectiveTrivia(hashToken, elseKeyword, endOfDirectiveToken, isActive, branchTaken);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
    {
         return new ElseDirectiveTriviaSyntax(this.Kind, this.hashToken, this.elseKeyword, this.endOfDirectiveToken, this.isActive, this.branchTaken, diagnostics, GetAnnotations());
    }

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
    {
         return new ElseDirectiveTriviaSyntax(this.Kind, this.hashToken, this.elseKeyword, this.endOfDirectiveToken, this.isActive, this.branchTaken, GetDiagnostics(), annotations);
    }

    internal ElseDirectiveTriviaSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 3;
      var hashToken = (SyntaxToken)reader.ReadValue();
      if (hashToken != null)
      {
         AdjustFlagsAndWidth(hashToken);
         this.hashToken = hashToken;
      }
      var elseKeyword = (SyntaxToken)reader.ReadValue();
      if (elseKeyword != null)
      {
         AdjustFlagsAndWidth(elseKeyword);
         this.elseKeyword = elseKeyword;
      }
      var endOfDirectiveToken = (SyntaxToken)reader.ReadValue();
      if (endOfDirectiveToken != null)
      {
         AdjustFlagsAndWidth(endOfDirectiveToken);
         this.endOfDirectiveToken = endOfDirectiveToken;
      }
      this.isActive = (bool)reader.ReadBoolean();
      this.branchTaken = (bool)reader.ReadBoolean();
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.hashToken);
      writer.WriteValue(this.elseKeyword);
      writer.WriteValue(this.endOfDirectiveToken);
      writer.WriteBoolean(this.isActive);
      writer.WriteBoolean(this.branchTaken);
    }

    static ElseDirectiveTriviaSyntax()
    {
       ObjectBinder.RegisterTypeReader(typeof(ElseDirectiveTriviaSyntax), r => new ElseDirectiveTriviaSyntax(r));
    }
  }

  internal sealed partial class EndIfDirectiveTriviaSyntax : DirectiveTriviaSyntax
  {
    internal readonly SyntaxToken hashToken;
    internal readonly SyntaxToken endIfKeyword;
    internal readonly SyntaxToken endOfDirectiveToken;
    internal readonly bool isActive;

    internal EndIfDirectiveTriviaSyntax(SyntaxKind kind, SyntaxToken hashToken, SyntaxToken endIfKeyword, SyntaxToken endOfDirectiveToken, bool isActive, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 3;
        this.AdjustFlagsAndWidth(hashToken);
        this.hashToken = hashToken;
        this.AdjustFlagsAndWidth(endIfKeyword);
        this.endIfKeyword = endIfKeyword;
        this.AdjustFlagsAndWidth(endOfDirectiveToken);
        this.endOfDirectiveToken = endOfDirectiveToken;
        this.isActive = isActive;
    }


    internal EndIfDirectiveTriviaSyntax(SyntaxKind kind, SyntaxToken hashToken, SyntaxToken endIfKeyword, SyntaxToken endOfDirectiveToken, bool isActive, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 3;
        this.AdjustFlagsAndWidth(hashToken);
        this.hashToken = hashToken;
        this.AdjustFlagsAndWidth(endIfKeyword);
        this.endIfKeyword = endIfKeyword;
        this.AdjustFlagsAndWidth(endOfDirectiveToken);
        this.endOfDirectiveToken = endOfDirectiveToken;
        this.isActive = isActive;
    }


    internal EndIfDirectiveTriviaSyntax(SyntaxKind kind, SyntaxToken hashToken, SyntaxToken endIfKeyword, SyntaxToken endOfDirectiveToken, bool isActive)
        : base(kind)
    {
        this.SlotCount = 3;
        this.AdjustFlagsAndWidth(hashToken);
        this.hashToken = hashToken;
        this.AdjustFlagsAndWidth(endIfKeyword);
        this.endIfKeyword = endIfKeyword;
        this.AdjustFlagsAndWidth(endOfDirectiveToken);
        this.endOfDirectiveToken = endOfDirectiveToken;
        this.isActive = isActive;
    }

    public override SyntaxToken HashToken { get { return this.hashToken; } }
    public SyntaxToken EndIfKeyword { get { return this.endIfKeyword; } }
    public override SyntaxToken EndOfDirectiveToken { get { return this.endOfDirectiveToken; } }
    public override bool IsActive { get { return this.isActive; } }

    internal override GreenNode GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.hashToken;
            case 1: return this.endIfKeyword;
            case 2: return this.endOfDirectiveToken;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode parent, int position)
    {
      return new CSharp.Syntax.EndIfDirectiveTriviaSyntax(this, parent, position);
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitEndIfDirectiveTrivia(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitEndIfDirectiveTrivia(this);
    }

    public EndIfDirectiveTriviaSyntax Update(SyntaxToken hashToken, SyntaxToken endIfKeyword, SyntaxToken endOfDirectiveToken, bool isActive)
    {
        if (hashToken != this.HashToken || endIfKeyword != this.EndIfKeyword || endOfDirectiveToken != this.EndOfDirectiveToken)
        {
            var newNode = SyntaxFactory.EndIfDirectiveTrivia(hashToken, endIfKeyword, endOfDirectiveToken, isActive);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
    {
         return new EndIfDirectiveTriviaSyntax(this.Kind, this.hashToken, this.endIfKeyword, this.endOfDirectiveToken, this.isActive, diagnostics, GetAnnotations());
    }

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
    {
         return new EndIfDirectiveTriviaSyntax(this.Kind, this.hashToken, this.endIfKeyword, this.endOfDirectiveToken, this.isActive, GetDiagnostics(), annotations);
    }

    internal EndIfDirectiveTriviaSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 3;
      var hashToken = (SyntaxToken)reader.ReadValue();
      if (hashToken != null)
      {
         AdjustFlagsAndWidth(hashToken);
         this.hashToken = hashToken;
      }
      var endIfKeyword = (SyntaxToken)reader.ReadValue();
      if (endIfKeyword != null)
      {
         AdjustFlagsAndWidth(endIfKeyword);
         this.endIfKeyword = endIfKeyword;
      }
      var endOfDirectiveToken = (SyntaxToken)reader.ReadValue();
      if (endOfDirectiveToken != null)
      {
         AdjustFlagsAndWidth(endOfDirectiveToken);
         this.endOfDirectiveToken = endOfDirectiveToken;
      }
      this.isActive = (bool)reader.ReadBoolean();
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.hashToken);
      writer.WriteValue(this.endIfKeyword);
      writer.WriteValue(this.endOfDirectiveToken);
      writer.WriteBoolean(this.isActive);
    }

    static EndIfDirectiveTriviaSyntax()
    {
       ObjectBinder.RegisterTypeReader(typeof(EndIfDirectiveTriviaSyntax), r => new EndIfDirectiveTriviaSyntax(r));
    }
  }

  internal sealed partial class RegionDirectiveTriviaSyntax : DirectiveTriviaSyntax
  {
    internal readonly SyntaxToken hashToken;
    internal readonly SyntaxToken regionKeyword;
    internal readonly SyntaxToken endOfDirectiveToken;
    internal readonly bool isActive;

    internal RegionDirectiveTriviaSyntax(SyntaxKind kind, SyntaxToken hashToken, SyntaxToken regionKeyword, SyntaxToken endOfDirectiveToken, bool isActive, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 3;
        this.AdjustFlagsAndWidth(hashToken);
        this.hashToken = hashToken;
        this.AdjustFlagsAndWidth(regionKeyword);
        this.regionKeyword = regionKeyword;
        this.AdjustFlagsAndWidth(endOfDirectiveToken);
        this.endOfDirectiveToken = endOfDirectiveToken;
        this.isActive = isActive;
    }


    internal RegionDirectiveTriviaSyntax(SyntaxKind kind, SyntaxToken hashToken, SyntaxToken regionKeyword, SyntaxToken endOfDirectiveToken, bool isActive, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 3;
        this.AdjustFlagsAndWidth(hashToken);
        this.hashToken = hashToken;
        this.AdjustFlagsAndWidth(regionKeyword);
        this.regionKeyword = regionKeyword;
        this.AdjustFlagsAndWidth(endOfDirectiveToken);
        this.endOfDirectiveToken = endOfDirectiveToken;
        this.isActive = isActive;
    }


    internal RegionDirectiveTriviaSyntax(SyntaxKind kind, SyntaxToken hashToken, SyntaxToken regionKeyword, SyntaxToken endOfDirectiveToken, bool isActive)
        : base(kind)
    {
        this.SlotCount = 3;
        this.AdjustFlagsAndWidth(hashToken);
        this.hashToken = hashToken;
        this.AdjustFlagsAndWidth(regionKeyword);
        this.regionKeyword = regionKeyword;
        this.AdjustFlagsAndWidth(endOfDirectiveToken);
        this.endOfDirectiveToken = endOfDirectiveToken;
        this.isActive = isActive;
    }

    public override SyntaxToken HashToken { get { return this.hashToken; } }
    public SyntaxToken RegionKeyword { get { return this.regionKeyword; } }
    public override SyntaxToken EndOfDirectiveToken { get { return this.endOfDirectiveToken; } }
    public override bool IsActive { get { return this.isActive; } }

    internal override GreenNode GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.hashToken;
            case 1: return this.regionKeyword;
            case 2: return this.endOfDirectiveToken;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode parent, int position)
    {
      return new CSharp.Syntax.RegionDirectiveTriviaSyntax(this, parent, position);
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitRegionDirectiveTrivia(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitRegionDirectiveTrivia(this);
    }

    public RegionDirectiveTriviaSyntax Update(SyntaxToken hashToken, SyntaxToken regionKeyword, SyntaxToken endOfDirectiveToken, bool isActive)
    {
        if (hashToken != this.HashToken || regionKeyword != this.RegionKeyword || endOfDirectiveToken != this.EndOfDirectiveToken)
        {
            var newNode = SyntaxFactory.RegionDirectiveTrivia(hashToken, regionKeyword, endOfDirectiveToken, isActive);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
    {
         return new RegionDirectiveTriviaSyntax(this.Kind, this.hashToken, this.regionKeyword, this.endOfDirectiveToken, this.isActive, diagnostics, GetAnnotations());
    }

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
    {
         return new RegionDirectiveTriviaSyntax(this.Kind, this.hashToken, this.regionKeyword, this.endOfDirectiveToken, this.isActive, GetDiagnostics(), annotations);
    }

    internal RegionDirectiveTriviaSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 3;
      var hashToken = (SyntaxToken)reader.ReadValue();
      if (hashToken != null)
      {
         AdjustFlagsAndWidth(hashToken);
         this.hashToken = hashToken;
      }
      var regionKeyword = (SyntaxToken)reader.ReadValue();
      if (regionKeyword != null)
      {
         AdjustFlagsAndWidth(regionKeyword);
         this.regionKeyword = regionKeyword;
      }
      var endOfDirectiveToken = (SyntaxToken)reader.ReadValue();
      if (endOfDirectiveToken != null)
      {
         AdjustFlagsAndWidth(endOfDirectiveToken);
         this.endOfDirectiveToken = endOfDirectiveToken;
      }
      this.isActive = (bool)reader.ReadBoolean();
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.hashToken);
      writer.WriteValue(this.regionKeyword);
      writer.WriteValue(this.endOfDirectiveToken);
      writer.WriteBoolean(this.isActive);
    }

    static RegionDirectiveTriviaSyntax()
    {
       ObjectBinder.RegisterTypeReader(typeof(RegionDirectiveTriviaSyntax), r => new RegionDirectiveTriviaSyntax(r));
    }
  }

  internal sealed partial class EndRegionDirectiveTriviaSyntax : DirectiveTriviaSyntax
  {
    internal readonly SyntaxToken hashToken;
    internal readonly SyntaxToken endRegionKeyword;
    internal readonly SyntaxToken endOfDirectiveToken;
    internal readonly bool isActive;

    internal EndRegionDirectiveTriviaSyntax(SyntaxKind kind, SyntaxToken hashToken, SyntaxToken endRegionKeyword, SyntaxToken endOfDirectiveToken, bool isActive, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 3;
        this.AdjustFlagsAndWidth(hashToken);
        this.hashToken = hashToken;
        this.AdjustFlagsAndWidth(endRegionKeyword);
        this.endRegionKeyword = endRegionKeyword;
        this.AdjustFlagsAndWidth(endOfDirectiveToken);
        this.endOfDirectiveToken = endOfDirectiveToken;
        this.isActive = isActive;
    }


    internal EndRegionDirectiveTriviaSyntax(SyntaxKind kind, SyntaxToken hashToken, SyntaxToken endRegionKeyword, SyntaxToken endOfDirectiveToken, bool isActive, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 3;
        this.AdjustFlagsAndWidth(hashToken);
        this.hashToken = hashToken;
        this.AdjustFlagsAndWidth(endRegionKeyword);
        this.endRegionKeyword = endRegionKeyword;
        this.AdjustFlagsAndWidth(endOfDirectiveToken);
        this.endOfDirectiveToken = endOfDirectiveToken;
        this.isActive = isActive;
    }


    internal EndRegionDirectiveTriviaSyntax(SyntaxKind kind, SyntaxToken hashToken, SyntaxToken endRegionKeyword, SyntaxToken endOfDirectiveToken, bool isActive)
        : base(kind)
    {
        this.SlotCount = 3;
        this.AdjustFlagsAndWidth(hashToken);
        this.hashToken = hashToken;
        this.AdjustFlagsAndWidth(endRegionKeyword);
        this.endRegionKeyword = endRegionKeyword;
        this.AdjustFlagsAndWidth(endOfDirectiveToken);
        this.endOfDirectiveToken = endOfDirectiveToken;
        this.isActive = isActive;
    }

    public override SyntaxToken HashToken { get { return this.hashToken; } }
    public SyntaxToken EndRegionKeyword { get { return this.endRegionKeyword; } }
    public override SyntaxToken EndOfDirectiveToken { get { return this.endOfDirectiveToken; } }
    public override bool IsActive { get { return this.isActive; } }

    internal override GreenNode GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.hashToken;
            case 1: return this.endRegionKeyword;
            case 2: return this.endOfDirectiveToken;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode parent, int position)
    {
      return new CSharp.Syntax.EndRegionDirectiveTriviaSyntax(this, parent, position);
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitEndRegionDirectiveTrivia(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitEndRegionDirectiveTrivia(this);
    }

    public EndRegionDirectiveTriviaSyntax Update(SyntaxToken hashToken, SyntaxToken endRegionKeyword, SyntaxToken endOfDirectiveToken, bool isActive)
    {
        if (hashToken != this.HashToken || endRegionKeyword != this.EndRegionKeyword || endOfDirectiveToken != this.EndOfDirectiveToken)
        {
            var newNode = SyntaxFactory.EndRegionDirectiveTrivia(hashToken, endRegionKeyword, endOfDirectiveToken, isActive);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
    {
         return new EndRegionDirectiveTriviaSyntax(this.Kind, this.hashToken, this.endRegionKeyword, this.endOfDirectiveToken, this.isActive, diagnostics, GetAnnotations());
    }

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
    {
         return new EndRegionDirectiveTriviaSyntax(this.Kind, this.hashToken, this.endRegionKeyword, this.endOfDirectiveToken, this.isActive, GetDiagnostics(), annotations);
    }

    internal EndRegionDirectiveTriviaSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 3;
      var hashToken = (SyntaxToken)reader.ReadValue();
      if (hashToken != null)
      {
         AdjustFlagsAndWidth(hashToken);
         this.hashToken = hashToken;
      }
      var endRegionKeyword = (SyntaxToken)reader.ReadValue();
      if (endRegionKeyword != null)
      {
         AdjustFlagsAndWidth(endRegionKeyword);
         this.endRegionKeyword = endRegionKeyword;
      }
      var endOfDirectiveToken = (SyntaxToken)reader.ReadValue();
      if (endOfDirectiveToken != null)
      {
         AdjustFlagsAndWidth(endOfDirectiveToken);
         this.endOfDirectiveToken = endOfDirectiveToken;
      }
      this.isActive = (bool)reader.ReadBoolean();
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.hashToken);
      writer.WriteValue(this.endRegionKeyword);
      writer.WriteValue(this.endOfDirectiveToken);
      writer.WriteBoolean(this.isActive);
    }

    static EndRegionDirectiveTriviaSyntax()
    {
       ObjectBinder.RegisterTypeReader(typeof(EndRegionDirectiveTriviaSyntax), r => new EndRegionDirectiveTriviaSyntax(r));
    }
  }

  internal sealed partial class ErrorDirectiveTriviaSyntax : DirectiveTriviaSyntax
  {
    internal readonly SyntaxToken hashToken;
    internal readonly SyntaxToken errorKeyword;
    internal readonly SyntaxToken endOfDirectiveToken;
    internal readonly bool isActive;

    internal ErrorDirectiveTriviaSyntax(SyntaxKind kind, SyntaxToken hashToken, SyntaxToken errorKeyword, SyntaxToken endOfDirectiveToken, bool isActive, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 3;
        this.AdjustFlagsAndWidth(hashToken);
        this.hashToken = hashToken;
        this.AdjustFlagsAndWidth(errorKeyword);
        this.errorKeyword = errorKeyword;
        this.AdjustFlagsAndWidth(endOfDirectiveToken);
        this.endOfDirectiveToken = endOfDirectiveToken;
        this.isActive = isActive;
    }


    internal ErrorDirectiveTriviaSyntax(SyntaxKind kind, SyntaxToken hashToken, SyntaxToken errorKeyword, SyntaxToken endOfDirectiveToken, bool isActive, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 3;
        this.AdjustFlagsAndWidth(hashToken);
        this.hashToken = hashToken;
        this.AdjustFlagsAndWidth(errorKeyword);
        this.errorKeyword = errorKeyword;
        this.AdjustFlagsAndWidth(endOfDirectiveToken);
        this.endOfDirectiveToken = endOfDirectiveToken;
        this.isActive = isActive;
    }


    internal ErrorDirectiveTriviaSyntax(SyntaxKind kind, SyntaxToken hashToken, SyntaxToken errorKeyword, SyntaxToken endOfDirectiveToken, bool isActive)
        : base(kind)
    {
        this.SlotCount = 3;
        this.AdjustFlagsAndWidth(hashToken);
        this.hashToken = hashToken;
        this.AdjustFlagsAndWidth(errorKeyword);
        this.errorKeyword = errorKeyword;
        this.AdjustFlagsAndWidth(endOfDirectiveToken);
        this.endOfDirectiveToken = endOfDirectiveToken;
        this.isActive = isActive;
    }

    public override SyntaxToken HashToken { get { return this.hashToken; } }
    public SyntaxToken ErrorKeyword { get { return this.errorKeyword; } }
    public override SyntaxToken EndOfDirectiveToken { get { return this.endOfDirectiveToken; } }
    public override bool IsActive { get { return this.isActive; } }

    internal override GreenNode GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.hashToken;
            case 1: return this.errorKeyword;
            case 2: return this.endOfDirectiveToken;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode parent, int position)
    {
      return new CSharp.Syntax.ErrorDirectiveTriviaSyntax(this, parent, position);
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitErrorDirectiveTrivia(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitErrorDirectiveTrivia(this);
    }

    public ErrorDirectiveTriviaSyntax Update(SyntaxToken hashToken, SyntaxToken errorKeyword, SyntaxToken endOfDirectiveToken, bool isActive)
    {
        if (hashToken != this.HashToken || errorKeyword != this.ErrorKeyword || endOfDirectiveToken != this.EndOfDirectiveToken)
        {
            var newNode = SyntaxFactory.ErrorDirectiveTrivia(hashToken, errorKeyword, endOfDirectiveToken, isActive);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
    {
         return new ErrorDirectiveTriviaSyntax(this.Kind, this.hashToken, this.errorKeyword, this.endOfDirectiveToken, this.isActive, diagnostics, GetAnnotations());
    }

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
    {
         return new ErrorDirectiveTriviaSyntax(this.Kind, this.hashToken, this.errorKeyword, this.endOfDirectiveToken, this.isActive, GetDiagnostics(), annotations);
    }

    internal ErrorDirectiveTriviaSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 3;
      var hashToken = (SyntaxToken)reader.ReadValue();
      if (hashToken != null)
      {
         AdjustFlagsAndWidth(hashToken);
         this.hashToken = hashToken;
      }
      var errorKeyword = (SyntaxToken)reader.ReadValue();
      if (errorKeyword != null)
      {
         AdjustFlagsAndWidth(errorKeyword);
         this.errorKeyword = errorKeyword;
      }
      var endOfDirectiveToken = (SyntaxToken)reader.ReadValue();
      if (endOfDirectiveToken != null)
      {
         AdjustFlagsAndWidth(endOfDirectiveToken);
         this.endOfDirectiveToken = endOfDirectiveToken;
      }
      this.isActive = (bool)reader.ReadBoolean();
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.hashToken);
      writer.WriteValue(this.errorKeyword);
      writer.WriteValue(this.endOfDirectiveToken);
      writer.WriteBoolean(this.isActive);
    }

    static ErrorDirectiveTriviaSyntax()
    {
       ObjectBinder.RegisterTypeReader(typeof(ErrorDirectiveTriviaSyntax), r => new ErrorDirectiveTriviaSyntax(r));
    }
  }

  internal sealed partial class WarningDirectiveTriviaSyntax : DirectiveTriviaSyntax
  {
    internal readonly SyntaxToken hashToken;
    internal readonly SyntaxToken warningKeyword;
    internal readonly SyntaxToken endOfDirectiveToken;
    internal readonly bool isActive;

    internal WarningDirectiveTriviaSyntax(SyntaxKind kind, SyntaxToken hashToken, SyntaxToken warningKeyword, SyntaxToken endOfDirectiveToken, bool isActive, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 3;
        this.AdjustFlagsAndWidth(hashToken);
        this.hashToken = hashToken;
        this.AdjustFlagsAndWidth(warningKeyword);
        this.warningKeyword = warningKeyword;
        this.AdjustFlagsAndWidth(endOfDirectiveToken);
        this.endOfDirectiveToken = endOfDirectiveToken;
        this.isActive = isActive;
    }


    internal WarningDirectiveTriviaSyntax(SyntaxKind kind, SyntaxToken hashToken, SyntaxToken warningKeyword, SyntaxToken endOfDirectiveToken, bool isActive, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 3;
        this.AdjustFlagsAndWidth(hashToken);
        this.hashToken = hashToken;
        this.AdjustFlagsAndWidth(warningKeyword);
        this.warningKeyword = warningKeyword;
        this.AdjustFlagsAndWidth(endOfDirectiveToken);
        this.endOfDirectiveToken = endOfDirectiveToken;
        this.isActive = isActive;
    }


    internal WarningDirectiveTriviaSyntax(SyntaxKind kind, SyntaxToken hashToken, SyntaxToken warningKeyword, SyntaxToken endOfDirectiveToken, bool isActive)
        : base(kind)
    {
        this.SlotCount = 3;
        this.AdjustFlagsAndWidth(hashToken);
        this.hashToken = hashToken;
        this.AdjustFlagsAndWidth(warningKeyword);
        this.warningKeyword = warningKeyword;
        this.AdjustFlagsAndWidth(endOfDirectiveToken);
        this.endOfDirectiveToken = endOfDirectiveToken;
        this.isActive = isActive;
    }

    public override SyntaxToken HashToken { get { return this.hashToken; } }
    public SyntaxToken WarningKeyword { get { return this.warningKeyword; } }
    public override SyntaxToken EndOfDirectiveToken { get { return this.endOfDirectiveToken; } }
    public override bool IsActive { get { return this.isActive; } }

    internal override GreenNode GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.hashToken;
            case 1: return this.warningKeyword;
            case 2: return this.endOfDirectiveToken;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode parent, int position)
    {
      return new CSharp.Syntax.WarningDirectiveTriviaSyntax(this, parent, position);
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitWarningDirectiveTrivia(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitWarningDirectiveTrivia(this);
    }

    public WarningDirectiveTriviaSyntax Update(SyntaxToken hashToken, SyntaxToken warningKeyword, SyntaxToken endOfDirectiveToken, bool isActive)
    {
        if (hashToken != this.HashToken || warningKeyword != this.WarningKeyword || endOfDirectiveToken != this.EndOfDirectiveToken)
        {
            var newNode = SyntaxFactory.WarningDirectiveTrivia(hashToken, warningKeyword, endOfDirectiveToken, isActive);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
    {
         return new WarningDirectiveTriviaSyntax(this.Kind, this.hashToken, this.warningKeyword, this.endOfDirectiveToken, this.isActive, diagnostics, GetAnnotations());
    }

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
    {
         return new WarningDirectiveTriviaSyntax(this.Kind, this.hashToken, this.warningKeyword, this.endOfDirectiveToken, this.isActive, GetDiagnostics(), annotations);
    }

    internal WarningDirectiveTriviaSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 3;
      var hashToken = (SyntaxToken)reader.ReadValue();
      if (hashToken != null)
      {
         AdjustFlagsAndWidth(hashToken);
         this.hashToken = hashToken;
      }
      var warningKeyword = (SyntaxToken)reader.ReadValue();
      if (warningKeyword != null)
      {
         AdjustFlagsAndWidth(warningKeyword);
         this.warningKeyword = warningKeyword;
      }
      var endOfDirectiveToken = (SyntaxToken)reader.ReadValue();
      if (endOfDirectiveToken != null)
      {
         AdjustFlagsAndWidth(endOfDirectiveToken);
         this.endOfDirectiveToken = endOfDirectiveToken;
      }
      this.isActive = (bool)reader.ReadBoolean();
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.hashToken);
      writer.WriteValue(this.warningKeyword);
      writer.WriteValue(this.endOfDirectiveToken);
      writer.WriteBoolean(this.isActive);
    }

    static WarningDirectiveTriviaSyntax()
    {
       ObjectBinder.RegisterTypeReader(typeof(WarningDirectiveTriviaSyntax), r => new WarningDirectiveTriviaSyntax(r));
    }
  }

  internal sealed partial class BadDirectiveTriviaSyntax : DirectiveTriviaSyntax
  {
    internal readonly SyntaxToken hashToken;
    internal readonly SyntaxToken identifier;
    internal readonly SyntaxToken endOfDirectiveToken;
    internal readonly bool isActive;

    internal BadDirectiveTriviaSyntax(SyntaxKind kind, SyntaxToken hashToken, SyntaxToken identifier, SyntaxToken endOfDirectiveToken, bool isActive, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 3;
        this.AdjustFlagsAndWidth(hashToken);
        this.hashToken = hashToken;
        this.AdjustFlagsAndWidth(identifier);
        this.identifier = identifier;
        this.AdjustFlagsAndWidth(endOfDirectiveToken);
        this.endOfDirectiveToken = endOfDirectiveToken;
        this.isActive = isActive;
    }


    internal BadDirectiveTriviaSyntax(SyntaxKind kind, SyntaxToken hashToken, SyntaxToken identifier, SyntaxToken endOfDirectiveToken, bool isActive, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 3;
        this.AdjustFlagsAndWidth(hashToken);
        this.hashToken = hashToken;
        this.AdjustFlagsAndWidth(identifier);
        this.identifier = identifier;
        this.AdjustFlagsAndWidth(endOfDirectiveToken);
        this.endOfDirectiveToken = endOfDirectiveToken;
        this.isActive = isActive;
    }


    internal BadDirectiveTriviaSyntax(SyntaxKind kind, SyntaxToken hashToken, SyntaxToken identifier, SyntaxToken endOfDirectiveToken, bool isActive)
        : base(kind)
    {
        this.SlotCount = 3;
        this.AdjustFlagsAndWidth(hashToken);
        this.hashToken = hashToken;
        this.AdjustFlagsAndWidth(identifier);
        this.identifier = identifier;
        this.AdjustFlagsAndWidth(endOfDirectiveToken);
        this.endOfDirectiveToken = endOfDirectiveToken;
        this.isActive = isActive;
    }

    public override SyntaxToken HashToken { get { return this.hashToken; } }
    public SyntaxToken Identifier { get { return this.identifier; } }
    public override SyntaxToken EndOfDirectiveToken { get { return this.endOfDirectiveToken; } }
    public override bool IsActive { get { return this.isActive; } }

    internal override GreenNode GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.hashToken;
            case 1: return this.identifier;
            case 2: return this.endOfDirectiveToken;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode parent, int position)
    {
      return new CSharp.Syntax.BadDirectiveTriviaSyntax(this, parent, position);
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitBadDirectiveTrivia(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitBadDirectiveTrivia(this);
    }

    public BadDirectiveTriviaSyntax Update(SyntaxToken hashToken, SyntaxToken identifier, SyntaxToken endOfDirectiveToken, bool isActive)
    {
        if (hashToken != this.HashToken || identifier != this.Identifier || endOfDirectiveToken != this.EndOfDirectiveToken)
        {
            var newNode = SyntaxFactory.BadDirectiveTrivia(hashToken, identifier, endOfDirectiveToken, isActive);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
    {
         return new BadDirectiveTriviaSyntax(this.Kind, this.hashToken, this.identifier, this.endOfDirectiveToken, this.isActive, diagnostics, GetAnnotations());
    }

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
    {
         return new BadDirectiveTriviaSyntax(this.Kind, this.hashToken, this.identifier, this.endOfDirectiveToken, this.isActive, GetDiagnostics(), annotations);
    }

    internal BadDirectiveTriviaSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 3;
      var hashToken = (SyntaxToken)reader.ReadValue();
      if (hashToken != null)
      {
         AdjustFlagsAndWidth(hashToken);
         this.hashToken = hashToken;
      }
      var identifier = (SyntaxToken)reader.ReadValue();
      if (identifier != null)
      {
         AdjustFlagsAndWidth(identifier);
         this.identifier = identifier;
      }
      var endOfDirectiveToken = (SyntaxToken)reader.ReadValue();
      if (endOfDirectiveToken != null)
      {
         AdjustFlagsAndWidth(endOfDirectiveToken);
         this.endOfDirectiveToken = endOfDirectiveToken;
      }
      this.isActive = (bool)reader.ReadBoolean();
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.hashToken);
      writer.WriteValue(this.identifier);
      writer.WriteValue(this.endOfDirectiveToken);
      writer.WriteBoolean(this.isActive);
    }

    static BadDirectiveTriviaSyntax()
    {
       ObjectBinder.RegisterTypeReader(typeof(BadDirectiveTriviaSyntax), r => new BadDirectiveTriviaSyntax(r));
    }
  }

  internal sealed partial class DefineDirectiveTriviaSyntax : DirectiveTriviaSyntax
  {
    internal readonly SyntaxToken hashToken;
    internal readonly SyntaxToken defineKeyword;
    internal readonly SyntaxToken name;
    internal readonly SyntaxToken endOfDirectiveToken;
    internal readonly bool isActive;

    internal DefineDirectiveTriviaSyntax(SyntaxKind kind, SyntaxToken hashToken, SyntaxToken defineKeyword, SyntaxToken name, SyntaxToken endOfDirectiveToken, bool isActive, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 4;
        this.AdjustFlagsAndWidth(hashToken);
        this.hashToken = hashToken;
        this.AdjustFlagsAndWidth(defineKeyword);
        this.defineKeyword = defineKeyword;
        this.AdjustFlagsAndWidth(name);
        this.name = name;
        this.AdjustFlagsAndWidth(endOfDirectiveToken);
        this.endOfDirectiveToken = endOfDirectiveToken;
        this.isActive = isActive;
    }


    internal DefineDirectiveTriviaSyntax(SyntaxKind kind, SyntaxToken hashToken, SyntaxToken defineKeyword, SyntaxToken name, SyntaxToken endOfDirectiveToken, bool isActive, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 4;
        this.AdjustFlagsAndWidth(hashToken);
        this.hashToken = hashToken;
        this.AdjustFlagsAndWidth(defineKeyword);
        this.defineKeyword = defineKeyword;
        this.AdjustFlagsAndWidth(name);
        this.name = name;
        this.AdjustFlagsAndWidth(endOfDirectiveToken);
        this.endOfDirectiveToken = endOfDirectiveToken;
        this.isActive = isActive;
    }


    internal DefineDirectiveTriviaSyntax(SyntaxKind kind, SyntaxToken hashToken, SyntaxToken defineKeyword, SyntaxToken name, SyntaxToken endOfDirectiveToken, bool isActive)
        : base(kind)
    {
        this.SlotCount = 4;
        this.AdjustFlagsAndWidth(hashToken);
        this.hashToken = hashToken;
        this.AdjustFlagsAndWidth(defineKeyword);
        this.defineKeyword = defineKeyword;
        this.AdjustFlagsAndWidth(name);
        this.name = name;
        this.AdjustFlagsAndWidth(endOfDirectiveToken);
        this.endOfDirectiveToken = endOfDirectiveToken;
        this.isActive = isActive;
    }

    public override SyntaxToken HashToken { get { return this.hashToken; } }
    public SyntaxToken DefineKeyword { get { return this.defineKeyword; } }
    public SyntaxToken Name { get { return this.name; } }
    public override SyntaxToken EndOfDirectiveToken { get { return this.endOfDirectiveToken; } }
    public override bool IsActive { get { return this.isActive; } }

    internal override GreenNode GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.hashToken;
            case 1: return this.defineKeyword;
            case 2: return this.name;
            case 3: return this.endOfDirectiveToken;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode parent, int position)
    {
      return new CSharp.Syntax.DefineDirectiveTriviaSyntax(this, parent, position);
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitDefineDirectiveTrivia(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitDefineDirectiveTrivia(this);
    }

    public DefineDirectiveTriviaSyntax Update(SyntaxToken hashToken, SyntaxToken defineKeyword, SyntaxToken name, SyntaxToken endOfDirectiveToken, bool isActive)
    {
        if (hashToken != this.HashToken || defineKeyword != this.DefineKeyword || name != this.Name || endOfDirectiveToken != this.EndOfDirectiveToken)
        {
            var newNode = SyntaxFactory.DefineDirectiveTrivia(hashToken, defineKeyword, name, endOfDirectiveToken, isActive);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
    {
         return new DefineDirectiveTriviaSyntax(this.Kind, this.hashToken, this.defineKeyword, this.name, this.endOfDirectiveToken, this.isActive, diagnostics, GetAnnotations());
    }

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
    {
         return new DefineDirectiveTriviaSyntax(this.Kind, this.hashToken, this.defineKeyword, this.name, this.endOfDirectiveToken, this.isActive, GetDiagnostics(), annotations);
    }

    internal DefineDirectiveTriviaSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 4;
      var hashToken = (SyntaxToken)reader.ReadValue();
      if (hashToken != null)
      {
         AdjustFlagsAndWidth(hashToken);
         this.hashToken = hashToken;
      }
      var defineKeyword = (SyntaxToken)reader.ReadValue();
      if (defineKeyword != null)
      {
         AdjustFlagsAndWidth(defineKeyword);
         this.defineKeyword = defineKeyword;
      }
      var name = (SyntaxToken)reader.ReadValue();
      if (name != null)
      {
         AdjustFlagsAndWidth(name);
         this.name = name;
      }
      var endOfDirectiveToken = (SyntaxToken)reader.ReadValue();
      if (endOfDirectiveToken != null)
      {
         AdjustFlagsAndWidth(endOfDirectiveToken);
         this.endOfDirectiveToken = endOfDirectiveToken;
      }
      this.isActive = (bool)reader.ReadBoolean();
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.hashToken);
      writer.WriteValue(this.defineKeyword);
      writer.WriteValue(this.name);
      writer.WriteValue(this.endOfDirectiveToken);
      writer.WriteBoolean(this.isActive);
    }

    static DefineDirectiveTriviaSyntax()
    {
       ObjectBinder.RegisterTypeReader(typeof(DefineDirectiveTriviaSyntax), r => new DefineDirectiveTriviaSyntax(r));
    }
  }

  internal sealed partial class UndefDirectiveTriviaSyntax : DirectiveTriviaSyntax
  {
    internal readonly SyntaxToken hashToken;
    internal readonly SyntaxToken undefKeyword;
    internal readonly SyntaxToken name;
    internal readonly SyntaxToken endOfDirectiveToken;
    internal readonly bool isActive;

    internal UndefDirectiveTriviaSyntax(SyntaxKind kind, SyntaxToken hashToken, SyntaxToken undefKeyword, SyntaxToken name, SyntaxToken endOfDirectiveToken, bool isActive, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 4;
        this.AdjustFlagsAndWidth(hashToken);
        this.hashToken = hashToken;
        this.AdjustFlagsAndWidth(undefKeyword);
        this.undefKeyword = undefKeyword;
        this.AdjustFlagsAndWidth(name);
        this.name = name;
        this.AdjustFlagsAndWidth(endOfDirectiveToken);
        this.endOfDirectiveToken = endOfDirectiveToken;
        this.isActive = isActive;
    }


    internal UndefDirectiveTriviaSyntax(SyntaxKind kind, SyntaxToken hashToken, SyntaxToken undefKeyword, SyntaxToken name, SyntaxToken endOfDirectiveToken, bool isActive, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 4;
        this.AdjustFlagsAndWidth(hashToken);
        this.hashToken = hashToken;
        this.AdjustFlagsAndWidth(undefKeyword);
        this.undefKeyword = undefKeyword;
        this.AdjustFlagsAndWidth(name);
        this.name = name;
        this.AdjustFlagsAndWidth(endOfDirectiveToken);
        this.endOfDirectiveToken = endOfDirectiveToken;
        this.isActive = isActive;
    }


    internal UndefDirectiveTriviaSyntax(SyntaxKind kind, SyntaxToken hashToken, SyntaxToken undefKeyword, SyntaxToken name, SyntaxToken endOfDirectiveToken, bool isActive)
        : base(kind)
    {
        this.SlotCount = 4;
        this.AdjustFlagsAndWidth(hashToken);
        this.hashToken = hashToken;
        this.AdjustFlagsAndWidth(undefKeyword);
        this.undefKeyword = undefKeyword;
        this.AdjustFlagsAndWidth(name);
        this.name = name;
        this.AdjustFlagsAndWidth(endOfDirectiveToken);
        this.endOfDirectiveToken = endOfDirectiveToken;
        this.isActive = isActive;
    }

    public override SyntaxToken HashToken { get { return this.hashToken; } }
    public SyntaxToken UndefKeyword { get { return this.undefKeyword; } }
    public SyntaxToken Name { get { return this.name; } }
    public override SyntaxToken EndOfDirectiveToken { get { return this.endOfDirectiveToken; } }
    public override bool IsActive { get { return this.isActive; } }

    internal override GreenNode GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.hashToken;
            case 1: return this.undefKeyword;
            case 2: return this.name;
            case 3: return this.endOfDirectiveToken;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode parent, int position)
    {
      return new CSharp.Syntax.UndefDirectiveTriviaSyntax(this, parent, position);
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitUndefDirectiveTrivia(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitUndefDirectiveTrivia(this);
    }

    public UndefDirectiveTriviaSyntax Update(SyntaxToken hashToken, SyntaxToken undefKeyword, SyntaxToken name, SyntaxToken endOfDirectiveToken, bool isActive)
    {
        if (hashToken != this.HashToken || undefKeyword != this.UndefKeyword || name != this.Name || endOfDirectiveToken != this.EndOfDirectiveToken)
        {
            var newNode = SyntaxFactory.UndefDirectiveTrivia(hashToken, undefKeyword, name, endOfDirectiveToken, isActive);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
    {
         return new UndefDirectiveTriviaSyntax(this.Kind, this.hashToken, this.undefKeyword, this.name, this.endOfDirectiveToken, this.isActive, diagnostics, GetAnnotations());
    }

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
    {
         return new UndefDirectiveTriviaSyntax(this.Kind, this.hashToken, this.undefKeyword, this.name, this.endOfDirectiveToken, this.isActive, GetDiagnostics(), annotations);
    }

    internal UndefDirectiveTriviaSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 4;
      var hashToken = (SyntaxToken)reader.ReadValue();
      if (hashToken != null)
      {
         AdjustFlagsAndWidth(hashToken);
         this.hashToken = hashToken;
      }
      var undefKeyword = (SyntaxToken)reader.ReadValue();
      if (undefKeyword != null)
      {
         AdjustFlagsAndWidth(undefKeyword);
         this.undefKeyword = undefKeyword;
      }
      var name = (SyntaxToken)reader.ReadValue();
      if (name != null)
      {
         AdjustFlagsAndWidth(name);
         this.name = name;
      }
      var endOfDirectiveToken = (SyntaxToken)reader.ReadValue();
      if (endOfDirectiveToken != null)
      {
         AdjustFlagsAndWidth(endOfDirectiveToken);
         this.endOfDirectiveToken = endOfDirectiveToken;
      }
      this.isActive = (bool)reader.ReadBoolean();
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.hashToken);
      writer.WriteValue(this.undefKeyword);
      writer.WriteValue(this.name);
      writer.WriteValue(this.endOfDirectiveToken);
      writer.WriteBoolean(this.isActive);
    }

    static UndefDirectiveTriviaSyntax()
    {
       ObjectBinder.RegisterTypeReader(typeof(UndefDirectiveTriviaSyntax), r => new UndefDirectiveTriviaSyntax(r));
    }
  }

  internal sealed partial class LineDirectiveTriviaSyntax : DirectiveTriviaSyntax
  {
    internal readonly SyntaxToken hashToken;
    internal readonly SyntaxToken lineKeyword;
    internal readonly SyntaxToken line;
    internal readonly SyntaxToken file;
    internal readonly SyntaxToken endOfDirectiveToken;
    internal readonly bool isActive;

    internal LineDirectiveTriviaSyntax(SyntaxKind kind, SyntaxToken hashToken, SyntaxToken lineKeyword, SyntaxToken line, SyntaxToken file, SyntaxToken endOfDirectiveToken, bool isActive, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 5;
        this.AdjustFlagsAndWidth(hashToken);
        this.hashToken = hashToken;
        this.AdjustFlagsAndWidth(lineKeyword);
        this.lineKeyword = lineKeyword;
        this.AdjustFlagsAndWidth(line);
        this.line = line;
        if (file != null)
        {
            this.AdjustFlagsAndWidth(file);
            this.file = file;
        }
        this.AdjustFlagsAndWidth(endOfDirectiveToken);
        this.endOfDirectiveToken = endOfDirectiveToken;
        this.isActive = isActive;
    }


    internal LineDirectiveTriviaSyntax(SyntaxKind kind, SyntaxToken hashToken, SyntaxToken lineKeyword, SyntaxToken line, SyntaxToken file, SyntaxToken endOfDirectiveToken, bool isActive, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 5;
        this.AdjustFlagsAndWidth(hashToken);
        this.hashToken = hashToken;
        this.AdjustFlagsAndWidth(lineKeyword);
        this.lineKeyword = lineKeyword;
        this.AdjustFlagsAndWidth(line);
        this.line = line;
        if (file != null)
        {
            this.AdjustFlagsAndWidth(file);
            this.file = file;
        }
        this.AdjustFlagsAndWidth(endOfDirectiveToken);
        this.endOfDirectiveToken = endOfDirectiveToken;
        this.isActive = isActive;
    }


    internal LineDirectiveTriviaSyntax(SyntaxKind kind, SyntaxToken hashToken, SyntaxToken lineKeyword, SyntaxToken line, SyntaxToken file, SyntaxToken endOfDirectiveToken, bool isActive)
        : base(kind)
    {
        this.SlotCount = 5;
        this.AdjustFlagsAndWidth(hashToken);
        this.hashToken = hashToken;
        this.AdjustFlagsAndWidth(lineKeyword);
        this.lineKeyword = lineKeyword;
        this.AdjustFlagsAndWidth(line);
        this.line = line;
        if (file != null)
        {
            this.AdjustFlagsAndWidth(file);
            this.file = file;
        }
        this.AdjustFlagsAndWidth(endOfDirectiveToken);
        this.endOfDirectiveToken = endOfDirectiveToken;
        this.isActive = isActive;
    }

    public override SyntaxToken HashToken { get { return this.hashToken; } }
    public SyntaxToken LineKeyword { get { return this.lineKeyword; } }
    public SyntaxToken Line { get { return this.line; } }
    public SyntaxToken File { get { return this.file; } }
    public override SyntaxToken EndOfDirectiveToken { get { return this.endOfDirectiveToken; } }
    public override bool IsActive { get { return this.isActive; } }

    internal override GreenNode GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.hashToken;
            case 1: return this.lineKeyword;
            case 2: return this.line;
            case 3: return this.file;
            case 4: return this.endOfDirectiveToken;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode parent, int position)
    {
      return new CSharp.Syntax.LineDirectiveTriviaSyntax(this, parent, position);
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitLineDirectiveTrivia(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitLineDirectiveTrivia(this);
    }

    public LineDirectiveTriviaSyntax Update(SyntaxToken hashToken, SyntaxToken lineKeyword, SyntaxToken line, SyntaxToken file, SyntaxToken endOfDirectiveToken, bool isActive)
    {
        if (hashToken != this.HashToken || lineKeyword != this.LineKeyword || line != this.Line || file != this.File || endOfDirectiveToken != this.EndOfDirectiveToken)
        {
            var newNode = SyntaxFactory.LineDirectiveTrivia(hashToken, lineKeyword, line, file, endOfDirectiveToken, isActive);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
    {
         return new LineDirectiveTriviaSyntax(this.Kind, this.hashToken, this.lineKeyword, this.line, this.file, this.endOfDirectiveToken, this.isActive, diagnostics, GetAnnotations());
    }

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
    {
         return new LineDirectiveTriviaSyntax(this.Kind, this.hashToken, this.lineKeyword, this.line, this.file, this.endOfDirectiveToken, this.isActive, GetDiagnostics(), annotations);
    }

    internal LineDirectiveTriviaSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 5;
      var hashToken = (SyntaxToken)reader.ReadValue();
      if (hashToken != null)
      {
         AdjustFlagsAndWidth(hashToken);
         this.hashToken = hashToken;
      }
      var lineKeyword = (SyntaxToken)reader.ReadValue();
      if (lineKeyword != null)
      {
         AdjustFlagsAndWidth(lineKeyword);
         this.lineKeyword = lineKeyword;
      }
      var line = (SyntaxToken)reader.ReadValue();
      if (line != null)
      {
         AdjustFlagsAndWidth(line);
         this.line = line;
      }
      var file = (SyntaxToken)reader.ReadValue();
      if (file != null)
      {
         AdjustFlagsAndWidth(file);
         this.file = file;
      }
      var endOfDirectiveToken = (SyntaxToken)reader.ReadValue();
      if (endOfDirectiveToken != null)
      {
         AdjustFlagsAndWidth(endOfDirectiveToken);
         this.endOfDirectiveToken = endOfDirectiveToken;
      }
      this.isActive = (bool)reader.ReadBoolean();
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.hashToken);
      writer.WriteValue(this.lineKeyword);
      writer.WriteValue(this.line);
      writer.WriteValue(this.file);
      writer.WriteValue(this.endOfDirectiveToken);
      writer.WriteBoolean(this.isActive);
    }

    static LineDirectiveTriviaSyntax()
    {
       ObjectBinder.RegisterTypeReader(typeof(LineDirectiveTriviaSyntax), r => new LineDirectiveTriviaSyntax(r));
    }
  }

  internal sealed partial class PragmaWarningDirectiveTriviaSyntax : DirectiveTriviaSyntax
  {
    internal readonly SyntaxToken hashToken;
    internal readonly SyntaxToken pragmaKeyword;
    internal readonly SyntaxToken warningKeyword;
    internal readonly SyntaxToken disableOrRestoreKeyword;
    internal readonly GreenNode errorCodes;
    internal readonly SyntaxToken endOfDirectiveToken;
    internal readonly bool isActive;

    internal PragmaWarningDirectiveTriviaSyntax(SyntaxKind kind, SyntaxToken hashToken, SyntaxToken pragmaKeyword, SyntaxToken warningKeyword, SyntaxToken disableOrRestoreKeyword, GreenNode errorCodes, SyntaxToken endOfDirectiveToken, bool isActive, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 6;
        this.AdjustFlagsAndWidth(hashToken);
        this.hashToken = hashToken;
        this.AdjustFlagsAndWidth(pragmaKeyword);
        this.pragmaKeyword = pragmaKeyword;
        this.AdjustFlagsAndWidth(warningKeyword);
        this.warningKeyword = warningKeyword;
        this.AdjustFlagsAndWidth(disableOrRestoreKeyword);
        this.disableOrRestoreKeyword = disableOrRestoreKeyword;
        if (errorCodes != null)
        {
            this.AdjustFlagsAndWidth(errorCodes);
            this.errorCodes = errorCodes;
        }
        this.AdjustFlagsAndWidth(endOfDirectiveToken);
        this.endOfDirectiveToken = endOfDirectiveToken;
        this.isActive = isActive;
    }


    internal PragmaWarningDirectiveTriviaSyntax(SyntaxKind kind, SyntaxToken hashToken, SyntaxToken pragmaKeyword, SyntaxToken warningKeyword, SyntaxToken disableOrRestoreKeyword, GreenNode errorCodes, SyntaxToken endOfDirectiveToken, bool isActive, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 6;
        this.AdjustFlagsAndWidth(hashToken);
        this.hashToken = hashToken;
        this.AdjustFlagsAndWidth(pragmaKeyword);
        this.pragmaKeyword = pragmaKeyword;
        this.AdjustFlagsAndWidth(warningKeyword);
        this.warningKeyword = warningKeyword;
        this.AdjustFlagsAndWidth(disableOrRestoreKeyword);
        this.disableOrRestoreKeyword = disableOrRestoreKeyword;
        if (errorCodes != null)
        {
            this.AdjustFlagsAndWidth(errorCodes);
            this.errorCodes = errorCodes;
        }
        this.AdjustFlagsAndWidth(endOfDirectiveToken);
        this.endOfDirectiveToken = endOfDirectiveToken;
        this.isActive = isActive;
    }


    internal PragmaWarningDirectiveTriviaSyntax(SyntaxKind kind, SyntaxToken hashToken, SyntaxToken pragmaKeyword, SyntaxToken warningKeyword, SyntaxToken disableOrRestoreKeyword, GreenNode errorCodes, SyntaxToken endOfDirectiveToken, bool isActive)
        : base(kind)
    {
        this.SlotCount = 6;
        this.AdjustFlagsAndWidth(hashToken);
        this.hashToken = hashToken;
        this.AdjustFlagsAndWidth(pragmaKeyword);
        this.pragmaKeyword = pragmaKeyword;
        this.AdjustFlagsAndWidth(warningKeyword);
        this.warningKeyword = warningKeyword;
        this.AdjustFlagsAndWidth(disableOrRestoreKeyword);
        this.disableOrRestoreKeyword = disableOrRestoreKeyword;
        if (errorCodes != null)
        {
            this.AdjustFlagsAndWidth(errorCodes);
            this.errorCodes = errorCodes;
        }
        this.AdjustFlagsAndWidth(endOfDirectiveToken);
        this.endOfDirectiveToken = endOfDirectiveToken;
        this.isActive = isActive;
    }

    public override SyntaxToken HashToken { get { return this.hashToken; } }
    public SyntaxToken PragmaKeyword { get { return this.pragmaKeyword; } }
    public SyntaxToken WarningKeyword { get { return this.warningKeyword; } }
    public SyntaxToken DisableOrRestoreKeyword { get { return this.disableOrRestoreKeyword; } }
    public Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<ExpressionSyntax> ErrorCodes { get { return new Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<ExpressionSyntax>(new Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<CSharpSyntaxNode>(this.errorCodes)); } }
    public override SyntaxToken EndOfDirectiveToken { get { return this.endOfDirectiveToken; } }
    public override bool IsActive { get { return this.isActive; } }

    internal override GreenNode GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.hashToken;
            case 1: return this.pragmaKeyword;
            case 2: return this.warningKeyword;
            case 3: return this.disableOrRestoreKeyword;
            case 4: return this.errorCodes;
            case 5: return this.endOfDirectiveToken;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode parent, int position)
    {
      return new CSharp.Syntax.PragmaWarningDirectiveTriviaSyntax(this, parent, position);
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitPragmaWarningDirectiveTrivia(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitPragmaWarningDirectiveTrivia(this);
    }

    public PragmaWarningDirectiveTriviaSyntax Update(SyntaxToken hashToken, SyntaxToken pragmaKeyword, SyntaxToken warningKeyword, SyntaxToken disableOrRestoreKeyword, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<ExpressionSyntax> errorCodes, SyntaxToken endOfDirectiveToken, bool isActive)
    {
        if (hashToken != this.HashToken || pragmaKeyword != this.PragmaKeyword || warningKeyword != this.WarningKeyword || disableOrRestoreKeyword != this.DisableOrRestoreKeyword || errorCodes != this.ErrorCodes || endOfDirectiveToken != this.EndOfDirectiveToken)
        {
            var newNode = SyntaxFactory.PragmaWarningDirectiveTrivia(hashToken, pragmaKeyword, warningKeyword, disableOrRestoreKeyword, errorCodes, endOfDirectiveToken, isActive);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
    {
         return new PragmaWarningDirectiveTriviaSyntax(this.Kind, this.hashToken, this.pragmaKeyword, this.warningKeyword, this.disableOrRestoreKeyword, this.errorCodes, this.endOfDirectiveToken, this.isActive, diagnostics, GetAnnotations());
    }

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
    {
         return new PragmaWarningDirectiveTriviaSyntax(this.Kind, this.hashToken, this.pragmaKeyword, this.warningKeyword, this.disableOrRestoreKeyword, this.errorCodes, this.endOfDirectiveToken, this.isActive, GetDiagnostics(), annotations);
    }

    internal PragmaWarningDirectiveTriviaSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 6;
      var hashToken = (SyntaxToken)reader.ReadValue();
      if (hashToken != null)
      {
         AdjustFlagsAndWidth(hashToken);
         this.hashToken = hashToken;
      }
      var pragmaKeyword = (SyntaxToken)reader.ReadValue();
      if (pragmaKeyword != null)
      {
         AdjustFlagsAndWidth(pragmaKeyword);
         this.pragmaKeyword = pragmaKeyword;
      }
      var warningKeyword = (SyntaxToken)reader.ReadValue();
      if (warningKeyword != null)
      {
         AdjustFlagsAndWidth(warningKeyword);
         this.warningKeyword = warningKeyword;
      }
      var disableOrRestoreKeyword = (SyntaxToken)reader.ReadValue();
      if (disableOrRestoreKeyword != null)
      {
         AdjustFlagsAndWidth(disableOrRestoreKeyword);
         this.disableOrRestoreKeyword = disableOrRestoreKeyword;
      }
      var errorCodes = (GreenNode)reader.ReadValue();
      if (errorCodes != null)
      {
         AdjustFlagsAndWidth(errorCodes);
         this.errorCodes = errorCodes;
      }
      var endOfDirectiveToken = (SyntaxToken)reader.ReadValue();
      if (endOfDirectiveToken != null)
      {
         AdjustFlagsAndWidth(endOfDirectiveToken);
         this.endOfDirectiveToken = endOfDirectiveToken;
      }
      this.isActive = (bool)reader.ReadBoolean();
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.hashToken);
      writer.WriteValue(this.pragmaKeyword);
      writer.WriteValue(this.warningKeyword);
      writer.WriteValue(this.disableOrRestoreKeyword);
      writer.WriteValue(this.errorCodes);
      writer.WriteValue(this.endOfDirectiveToken);
      writer.WriteBoolean(this.isActive);
    }

    static PragmaWarningDirectiveTriviaSyntax()
    {
       ObjectBinder.RegisterTypeReader(typeof(PragmaWarningDirectiveTriviaSyntax), r => new PragmaWarningDirectiveTriviaSyntax(r));
    }
  }

  internal sealed partial class PragmaChecksumDirectiveTriviaSyntax : DirectiveTriviaSyntax
  {
    internal readonly SyntaxToken hashToken;
    internal readonly SyntaxToken pragmaKeyword;
    internal readonly SyntaxToken checksumKeyword;
    internal readonly SyntaxToken file;
    internal readonly SyntaxToken guid;
    internal readonly SyntaxToken bytes;
    internal readonly SyntaxToken endOfDirectiveToken;
    internal readonly bool isActive;

    internal PragmaChecksumDirectiveTriviaSyntax(SyntaxKind kind, SyntaxToken hashToken, SyntaxToken pragmaKeyword, SyntaxToken checksumKeyword, SyntaxToken file, SyntaxToken guid, SyntaxToken bytes, SyntaxToken endOfDirectiveToken, bool isActive, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 7;
        this.AdjustFlagsAndWidth(hashToken);
        this.hashToken = hashToken;
        this.AdjustFlagsAndWidth(pragmaKeyword);
        this.pragmaKeyword = pragmaKeyword;
        this.AdjustFlagsAndWidth(checksumKeyword);
        this.checksumKeyword = checksumKeyword;
        this.AdjustFlagsAndWidth(file);
        this.file = file;
        this.AdjustFlagsAndWidth(guid);
        this.guid = guid;
        this.AdjustFlagsAndWidth(bytes);
        this.bytes = bytes;
        this.AdjustFlagsAndWidth(endOfDirectiveToken);
        this.endOfDirectiveToken = endOfDirectiveToken;
        this.isActive = isActive;
    }


    internal PragmaChecksumDirectiveTriviaSyntax(SyntaxKind kind, SyntaxToken hashToken, SyntaxToken pragmaKeyword, SyntaxToken checksumKeyword, SyntaxToken file, SyntaxToken guid, SyntaxToken bytes, SyntaxToken endOfDirectiveToken, bool isActive, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 7;
        this.AdjustFlagsAndWidth(hashToken);
        this.hashToken = hashToken;
        this.AdjustFlagsAndWidth(pragmaKeyword);
        this.pragmaKeyword = pragmaKeyword;
        this.AdjustFlagsAndWidth(checksumKeyword);
        this.checksumKeyword = checksumKeyword;
        this.AdjustFlagsAndWidth(file);
        this.file = file;
        this.AdjustFlagsAndWidth(guid);
        this.guid = guid;
        this.AdjustFlagsAndWidth(bytes);
        this.bytes = bytes;
        this.AdjustFlagsAndWidth(endOfDirectiveToken);
        this.endOfDirectiveToken = endOfDirectiveToken;
        this.isActive = isActive;
    }


    internal PragmaChecksumDirectiveTriviaSyntax(SyntaxKind kind, SyntaxToken hashToken, SyntaxToken pragmaKeyword, SyntaxToken checksumKeyword, SyntaxToken file, SyntaxToken guid, SyntaxToken bytes, SyntaxToken endOfDirectiveToken, bool isActive)
        : base(kind)
    {
        this.SlotCount = 7;
        this.AdjustFlagsAndWidth(hashToken);
        this.hashToken = hashToken;
        this.AdjustFlagsAndWidth(pragmaKeyword);
        this.pragmaKeyword = pragmaKeyword;
        this.AdjustFlagsAndWidth(checksumKeyword);
        this.checksumKeyword = checksumKeyword;
        this.AdjustFlagsAndWidth(file);
        this.file = file;
        this.AdjustFlagsAndWidth(guid);
        this.guid = guid;
        this.AdjustFlagsAndWidth(bytes);
        this.bytes = bytes;
        this.AdjustFlagsAndWidth(endOfDirectiveToken);
        this.endOfDirectiveToken = endOfDirectiveToken;
        this.isActive = isActive;
    }

    public override SyntaxToken HashToken { get { return this.hashToken; } }
    public SyntaxToken PragmaKeyword { get { return this.pragmaKeyword; } }
    public SyntaxToken ChecksumKeyword { get { return this.checksumKeyword; } }
    public SyntaxToken File { get { return this.file; } }
    public SyntaxToken Guid { get { return this.guid; } }
    public SyntaxToken Bytes { get { return this.bytes; } }
    public override SyntaxToken EndOfDirectiveToken { get { return this.endOfDirectiveToken; } }
    public override bool IsActive { get { return this.isActive; } }

    internal override GreenNode GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.hashToken;
            case 1: return this.pragmaKeyword;
            case 2: return this.checksumKeyword;
            case 3: return this.file;
            case 4: return this.guid;
            case 5: return this.bytes;
            case 6: return this.endOfDirectiveToken;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode parent, int position)
    {
      return new CSharp.Syntax.PragmaChecksumDirectiveTriviaSyntax(this, parent, position);
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitPragmaChecksumDirectiveTrivia(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitPragmaChecksumDirectiveTrivia(this);
    }

    public PragmaChecksumDirectiveTriviaSyntax Update(SyntaxToken hashToken, SyntaxToken pragmaKeyword, SyntaxToken checksumKeyword, SyntaxToken file, SyntaxToken guid, SyntaxToken bytes, SyntaxToken endOfDirectiveToken, bool isActive)
    {
        if (hashToken != this.HashToken || pragmaKeyword != this.PragmaKeyword || checksumKeyword != this.ChecksumKeyword || file != this.File || guid != this.Guid || bytes != this.Bytes || endOfDirectiveToken != this.EndOfDirectiveToken)
        {
            var newNode = SyntaxFactory.PragmaChecksumDirectiveTrivia(hashToken, pragmaKeyword, checksumKeyword, file, guid, bytes, endOfDirectiveToken, isActive);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
    {
         return new PragmaChecksumDirectiveTriviaSyntax(this.Kind, this.hashToken, this.pragmaKeyword, this.checksumKeyword, this.file, this.guid, this.bytes, this.endOfDirectiveToken, this.isActive, diagnostics, GetAnnotations());
    }

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
    {
         return new PragmaChecksumDirectiveTriviaSyntax(this.Kind, this.hashToken, this.pragmaKeyword, this.checksumKeyword, this.file, this.guid, this.bytes, this.endOfDirectiveToken, this.isActive, GetDiagnostics(), annotations);
    }

    internal PragmaChecksumDirectiveTriviaSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 7;
      var hashToken = (SyntaxToken)reader.ReadValue();
      if (hashToken != null)
      {
         AdjustFlagsAndWidth(hashToken);
         this.hashToken = hashToken;
      }
      var pragmaKeyword = (SyntaxToken)reader.ReadValue();
      if (pragmaKeyword != null)
      {
         AdjustFlagsAndWidth(pragmaKeyword);
         this.pragmaKeyword = pragmaKeyword;
      }
      var checksumKeyword = (SyntaxToken)reader.ReadValue();
      if (checksumKeyword != null)
      {
         AdjustFlagsAndWidth(checksumKeyword);
         this.checksumKeyword = checksumKeyword;
      }
      var file = (SyntaxToken)reader.ReadValue();
      if (file != null)
      {
         AdjustFlagsAndWidth(file);
         this.file = file;
      }
      var guid = (SyntaxToken)reader.ReadValue();
      if (guid != null)
      {
         AdjustFlagsAndWidth(guid);
         this.guid = guid;
      }
      var bytes = (SyntaxToken)reader.ReadValue();
      if (bytes != null)
      {
         AdjustFlagsAndWidth(bytes);
         this.bytes = bytes;
      }
      var endOfDirectiveToken = (SyntaxToken)reader.ReadValue();
      if (endOfDirectiveToken != null)
      {
         AdjustFlagsAndWidth(endOfDirectiveToken);
         this.endOfDirectiveToken = endOfDirectiveToken;
      }
      this.isActive = (bool)reader.ReadBoolean();
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.hashToken);
      writer.WriteValue(this.pragmaKeyword);
      writer.WriteValue(this.checksumKeyword);
      writer.WriteValue(this.file);
      writer.WriteValue(this.guid);
      writer.WriteValue(this.bytes);
      writer.WriteValue(this.endOfDirectiveToken);
      writer.WriteBoolean(this.isActive);
    }

    static PragmaChecksumDirectiveTriviaSyntax()
    {
       ObjectBinder.RegisterTypeReader(typeof(PragmaChecksumDirectiveTriviaSyntax), r => new PragmaChecksumDirectiveTriviaSyntax(r));
    }
  }

  internal sealed partial class ReferenceDirectiveTriviaSyntax : DirectiveTriviaSyntax
  {
    internal readonly SyntaxToken hashToken;
    internal readonly SyntaxToken referenceKeyword;
    internal readonly SyntaxToken file;
    internal readonly SyntaxToken endOfDirectiveToken;
    internal readonly bool isActive;

    internal ReferenceDirectiveTriviaSyntax(SyntaxKind kind, SyntaxToken hashToken, SyntaxToken referenceKeyword, SyntaxToken file, SyntaxToken endOfDirectiveToken, bool isActive, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 4;
        this.AdjustFlagsAndWidth(hashToken);
        this.hashToken = hashToken;
        this.AdjustFlagsAndWidth(referenceKeyword);
        this.referenceKeyword = referenceKeyword;
        this.AdjustFlagsAndWidth(file);
        this.file = file;
        this.AdjustFlagsAndWidth(endOfDirectiveToken);
        this.endOfDirectiveToken = endOfDirectiveToken;
        this.isActive = isActive;
    }


    internal ReferenceDirectiveTriviaSyntax(SyntaxKind kind, SyntaxToken hashToken, SyntaxToken referenceKeyword, SyntaxToken file, SyntaxToken endOfDirectiveToken, bool isActive, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 4;
        this.AdjustFlagsAndWidth(hashToken);
        this.hashToken = hashToken;
        this.AdjustFlagsAndWidth(referenceKeyword);
        this.referenceKeyword = referenceKeyword;
        this.AdjustFlagsAndWidth(file);
        this.file = file;
        this.AdjustFlagsAndWidth(endOfDirectiveToken);
        this.endOfDirectiveToken = endOfDirectiveToken;
        this.isActive = isActive;
    }


    internal ReferenceDirectiveTriviaSyntax(SyntaxKind kind, SyntaxToken hashToken, SyntaxToken referenceKeyword, SyntaxToken file, SyntaxToken endOfDirectiveToken, bool isActive)
        : base(kind)
    {
        this.SlotCount = 4;
        this.AdjustFlagsAndWidth(hashToken);
        this.hashToken = hashToken;
        this.AdjustFlagsAndWidth(referenceKeyword);
        this.referenceKeyword = referenceKeyword;
        this.AdjustFlagsAndWidth(file);
        this.file = file;
        this.AdjustFlagsAndWidth(endOfDirectiveToken);
        this.endOfDirectiveToken = endOfDirectiveToken;
        this.isActive = isActive;
    }

    public override SyntaxToken HashToken { get { return this.hashToken; } }
    public SyntaxToken ReferenceKeyword { get { return this.referenceKeyword; } }
    public SyntaxToken File { get { return this.file; } }
    public override SyntaxToken EndOfDirectiveToken { get { return this.endOfDirectiveToken; } }
    public override bool IsActive { get { return this.isActive; } }

    internal override GreenNode GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.hashToken;
            case 1: return this.referenceKeyword;
            case 2: return this.file;
            case 3: return this.endOfDirectiveToken;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode parent, int position)
    {
      return new CSharp.Syntax.ReferenceDirectiveTriviaSyntax(this, parent, position);
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitReferenceDirectiveTrivia(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitReferenceDirectiveTrivia(this);
    }

    public ReferenceDirectiveTriviaSyntax Update(SyntaxToken hashToken, SyntaxToken referenceKeyword, SyntaxToken file, SyntaxToken endOfDirectiveToken, bool isActive)
    {
        if (hashToken != this.HashToken || referenceKeyword != this.ReferenceKeyword || file != this.File || endOfDirectiveToken != this.EndOfDirectiveToken)
        {
            var newNode = SyntaxFactory.ReferenceDirectiveTrivia(hashToken, referenceKeyword, file, endOfDirectiveToken, isActive);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
    {
         return new ReferenceDirectiveTriviaSyntax(this.Kind, this.hashToken, this.referenceKeyword, this.file, this.endOfDirectiveToken, this.isActive, diagnostics, GetAnnotations());
    }

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
    {
         return new ReferenceDirectiveTriviaSyntax(this.Kind, this.hashToken, this.referenceKeyword, this.file, this.endOfDirectiveToken, this.isActive, GetDiagnostics(), annotations);
    }

    internal ReferenceDirectiveTriviaSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 4;
      var hashToken = (SyntaxToken)reader.ReadValue();
      if (hashToken != null)
      {
         AdjustFlagsAndWidth(hashToken);
         this.hashToken = hashToken;
      }
      var referenceKeyword = (SyntaxToken)reader.ReadValue();
      if (referenceKeyword != null)
      {
         AdjustFlagsAndWidth(referenceKeyword);
         this.referenceKeyword = referenceKeyword;
      }
      var file = (SyntaxToken)reader.ReadValue();
      if (file != null)
      {
         AdjustFlagsAndWidth(file);
         this.file = file;
      }
      var endOfDirectiveToken = (SyntaxToken)reader.ReadValue();
      if (endOfDirectiveToken != null)
      {
         AdjustFlagsAndWidth(endOfDirectiveToken);
         this.endOfDirectiveToken = endOfDirectiveToken;
      }
      this.isActive = (bool)reader.ReadBoolean();
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.hashToken);
      writer.WriteValue(this.referenceKeyword);
      writer.WriteValue(this.file);
      writer.WriteValue(this.endOfDirectiveToken);
      writer.WriteBoolean(this.isActive);
    }

    static ReferenceDirectiveTriviaSyntax()
    {
       ObjectBinder.RegisterTypeReader(typeof(ReferenceDirectiveTriviaSyntax), r => new ReferenceDirectiveTriviaSyntax(r));
    }
  }

  internal sealed partial class LoadDirectiveTriviaSyntax : DirectiveTriviaSyntax
  {
    internal readonly SyntaxToken hashToken;
    internal readonly SyntaxToken loadKeyword;
    internal readonly SyntaxToken file;
    internal readonly SyntaxToken endOfDirectiveToken;
    internal readonly bool isActive;

    internal LoadDirectiveTriviaSyntax(SyntaxKind kind, SyntaxToken hashToken, SyntaxToken loadKeyword, SyntaxToken file, SyntaxToken endOfDirectiveToken, bool isActive, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 4;
        this.AdjustFlagsAndWidth(hashToken);
        this.hashToken = hashToken;
        this.AdjustFlagsAndWidth(loadKeyword);
        this.loadKeyword = loadKeyword;
        this.AdjustFlagsAndWidth(file);
        this.file = file;
        this.AdjustFlagsAndWidth(endOfDirectiveToken);
        this.endOfDirectiveToken = endOfDirectiveToken;
        this.isActive = isActive;
    }


    internal LoadDirectiveTriviaSyntax(SyntaxKind kind, SyntaxToken hashToken, SyntaxToken loadKeyword, SyntaxToken file, SyntaxToken endOfDirectiveToken, bool isActive, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 4;
        this.AdjustFlagsAndWidth(hashToken);
        this.hashToken = hashToken;
        this.AdjustFlagsAndWidth(loadKeyword);
        this.loadKeyword = loadKeyword;
        this.AdjustFlagsAndWidth(file);
        this.file = file;
        this.AdjustFlagsAndWidth(endOfDirectiveToken);
        this.endOfDirectiveToken = endOfDirectiveToken;
        this.isActive = isActive;
    }


    internal LoadDirectiveTriviaSyntax(SyntaxKind kind, SyntaxToken hashToken, SyntaxToken loadKeyword, SyntaxToken file, SyntaxToken endOfDirectiveToken, bool isActive)
        : base(kind)
    {
        this.SlotCount = 4;
        this.AdjustFlagsAndWidth(hashToken);
        this.hashToken = hashToken;
        this.AdjustFlagsAndWidth(loadKeyword);
        this.loadKeyword = loadKeyword;
        this.AdjustFlagsAndWidth(file);
        this.file = file;
        this.AdjustFlagsAndWidth(endOfDirectiveToken);
        this.endOfDirectiveToken = endOfDirectiveToken;
        this.isActive = isActive;
    }

    public override SyntaxToken HashToken { get { return this.hashToken; } }
    public SyntaxToken LoadKeyword { get { return this.loadKeyword; } }
    public SyntaxToken File { get { return this.file; } }
    public override SyntaxToken EndOfDirectiveToken { get { return this.endOfDirectiveToken; } }
    public override bool IsActive { get { return this.isActive; } }

    internal override GreenNode GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.hashToken;
            case 1: return this.loadKeyword;
            case 2: return this.file;
            case 3: return this.endOfDirectiveToken;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode parent, int position)
    {
      return new CSharp.Syntax.LoadDirectiveTriviaSyntax(this, parent, position);
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitLoadDirectiveTrivia(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitLoadDirectiveTrivia(this);
    }

    public LoadDirectiveTriviaSyntax Update(SyntaxToken hashToken, SyntaxToken loadKeyword, SyntaxToken file, SyntaxToken endOfDirectiveToken, bool isActive)
    {
        if (hashToken != this.HashToken || loadKeyword != this.LoadKeyword || file != this.File || endOfDirectiveToken != this.EndOfDirectiveToken)
        {
            var newNode = SyntaxFactory.LoadDirectiveTrivia(hashToken, loadKeyword, file, endOfDirectiveToken, isActive);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
    {
         return new LoadDirectiveTriviaSyntax(this.Kind, this.hashToken, this.loadKeyword, this.file, this.endOfDirectiveToken, this.isActive, diagnostics, GetAnnotations());
    }

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
    {
         return new LoadDirectiveTriviaSyntax(this.Kind, this.hashToken, this.loadKeyword, this.file, this.endOfDirectiveToken, this.isActive, GetDiagnostics(), annotations);
    }

    internal LoadDirectiveTriviaSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 4;
      var hashToken = (SyntaxToken)reader.ReadValue();
      if (hashToken != null)
      {
         AdjustFlagsAndWidth(hashToken);
         this.hashToken = hashToken;
      }
      var loadKeyword = (SyntaxToken)reader.ReadValue();
      if (loadKeyword != null)
      {
         AdjustFlagsAndWidth(loadKeyword);
         this.loadKeyword = loadKeyword;
      }
      var file = (SyntaxToken)reader.ReadValue();
      if (file != null)
      {
         AdjustFlagsAndWidth(file);
         this.file = file;
      }
      var endOfDirectiveToken = (SyntaxToken)reader.ReadValue();
      if (endOfDirectiveToken != null)
      {
         AdjustFlagsAndWidth(endOfDirectiveToken);
         this.endOfDirectiveToken = endOfDirectiveToken;
      }
      this.isActive = (bool)reader.ReadBoolean();
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.hashToken);
      writer.WriteValue(this.loadKeyword);
      writer.WriteValue(this.file);
      writer.WriteValue(this.endOfDirectiveToken);
      writer.WriteBoolean(this.isActive);
    }

    static LoadDirectiveTriviaSyntax()
    {
       ObjectBinder.RegisterTypeReader(typeof(LoadDirectiveTriviaSyntax), r => new LoadDirectiveTriviaSyntax(r));
    }
  }

  internal sealed partial class ShebangDirectiveTriviaSyntax : DirectiveTriviaSyntax
  {
    internal readonly SyntaxToken hashToken;
    internal readonly SyntaxToken exclamationToken;
    internal readonly SyntaxToken endOfDirectiveToken;
    internal readonly bool isActive;

    internal ShebangDirectiveTriviaSyntax(SyntaxKind kind, SyntaxToken hashToken, SyntaxToken exclamationToken, SyntaxToken endOfDirectiveToken, bool isActive, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations)
        : base(kind, diagnostics, annotations)
    {
        this.SlotCount = 3;
        this.AdjustFlagsAndWidth(hashToken);
        this.hashToken = hashToken;
        this.AdjustFlagsAndWidth(exclamationToken);
        this.exclamationToken = exclamationToken;
        this.AdjustFlagsAndWidth(endOfDirectiveToken);
        this.endOfDirectiveToken = endOfDirectiveToken;
        this.isActive = isActive;
    }


    internal ShebangDirectiveTriviaSyntax(SyntaxKind kind, SyntaxToken hashToken, SyntaxToken exclamationToken, SyntaxToken endOfDirectiveToken, bool isActive, SyntaxFactoryContext context)
        : base(kind)
    {
        this.SetFactoryContext(context);
        this.SlotCount = 3;
        this.AdjustFlagsAndWidth(hashToken);
        this.hashToken = hashToken;
        this.AdjustFlagsAndWidth(exclamationToken);
        this.exclamationToken = exclamationToken;
        this.AdjustFlagsAndWidth(endOfDirectiveToken);
        this.endOfDirectiveToken = endOfDirectiveToken;
        this.isActive = isActive;
    }


    internal ShebangDirectiveTriviaSyntax(SyntaxKind kind, SyntaxToken hashToken, SyntaxToken exclamationToken, SyntaxToken endOfDirectiveToken, bool isActive)
        : base(kind)
    {
        this.SlotCount = 3;
        this.AdjustFlagsAndWidth(hashToken);
        this.hashToken = hashToken;
        this.AdjustFlagsAndWidth(exclamationToken);
        this.exclamationToken = exclamationToken;
        this.AdjustFlagsAndWidth(endOfDirectiveToken);
        this.endOfDirectiveToken = endOfDirectiveToken;
        this.isActive = isActive;
    }

    public override SyntaxToken HashToken { get { return this.hashToken; } }
    public SyntaxToken ExclamationToken { get { return this.exclamationToken; } }
    public override SyntaxToken EndOfDirectiveToken { get { return this.endOfDirectiveToken; } }
    public override bool IsActive { get { return this.isActive; } }

    internal override GreenNode GetSlot(int index)
    {
        switch (index)
        {
            case 0: return this.hashToken;
            case 1: return this.exclamationToken;
            case 2: return this.endOfDirectiveToken;
            default: return null;
        }
    }

    internal override SyntaxNode CreateRed(SyntaxNode parent, int position)
    {
      return new CSharp.Syntax.ShebangDirectiveTriviaSyntax(this, parent, position);
    }

    public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor)
    {
        return visitor.VisitShebangDirectiveTrivia(this);
    }

    public override void Accept(CSharpSyntaxVisitor visitor)
    {
        visitor.VisitShebangDirectiveTrivia(this);
    }

    public ShebangDirectiveTriviaSyntax Update(SyntaxToken hashToken, SyntaxToken exclamationToken, SyntaxToken endOfDirectiveToken, bool isActive)
    {
        if (hashToken != this.HashToken || exclamationToken != this.ExclamationToken || endOfDirectiveToken != this.EndOfDirectiveToken)
        {
            var newNode = SyntaxFactory.ShebangDirectiveTrivia(hashToken, exclamationToken, endOfDirectiveToken, isActive);
            var diags = this.GetDiagnostics();
            if (diags != null && diags.Length > 0)
               newNode = newNode.WithDiagnosticsGreen(diags);
            var annotations = this.GetAnnotations();
            if (annotations != null && annotations.Length > 0)
               newNode = newNode.WithAnnotationsGreen(annotations);
            return newNode;
        }

        return this;
    }

    internal override GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics)
    {
         return new ShebangDirectiveTriviaSyntax(this.Kind, this.hashToken, this.exclamationToken, this.endOfDirectiveToken, this.isActive, diagnostics, GetAnnotations());
    }

    internal override GreenNode SetAnnotations(SyntaxAnnotation[] annotations)
    {
         return new ShebangDirectiveTriviaSyntax(this.Kind, this.hashToken, this.exclamationToken, this.endOfDirectiveToken, this.isActive, GetDiagnostics(), annotations);
    }

    internal ShebangDirectiveTriviaSyntax(ObjectReader reader)
        : base(reader)
    {
      this.SlotCount = 3;
      var hashToken = (SyntaxToken)reader.ReadValue();
      if (hashToken != null)
      {
         AdjustFlagsAndWidth(hashToken);
         this.hashToken = hashToken;
      }
      var exclamationToken = (SyntaxToken)reader.ReadValue();
      if (exclamationToken != null)
      {
         AdjustFlagsAndWidth(exclamationToken);
         this.exclamationToken = exclamationToken;
      }
      var endOfDirectiveToken = (SyntaxToken)reader.ReadValue();
      if (endOfDirectiveToken != null)
      {
         AdjustFlagsAndWidth(endOfDirectiveToken);
         this.endOfDirectiveToken = endOfDirectiveToken;
      }
      this.isActive = (bool)reader.ReadBoolean();
    }

    internal override void WriteTo(ObjectWriter writer)
    {
      base.WriteTo(writer);
      writer.WriteValue(this.hashToken);
      writer.WriteValue(this.exclamationToken);
      writer.WriteValue(this.endOfDirectiveToken);
      writer.WriteBoolean(this.isActive);
    }

    static ShebangDirectiveTriviaSyntax()
    {
       ObjectBinder.RegisterTypeReader(typeof(ShebangDirectiveTriviaSyntax), r => new ShebangDirectiveTriviaSyntax(r));
    }
  }

  internal partial class CSharpSyntaxVisitor<TResult>
  {
    public virtual TResult VisitIdentifierName(IdentifierNameSyntax node)
    {
      return this.DefaultVisit(node);
    }

    public virtual TResult VisitQualifiedName(QualifiedNameSyntax node)
    {
      return this.DefaultVisit(node);
    }

    public virtual TResult VisitGenericName(GenericNameSyntax node)
    {
      return this.DefaultVisit(node);
    }

    public virtual TResult VisitTypeArgumentList(TypeArgumentListSyntax node)
    {
      return this.DefaultVisit(node);
    }

    public virtual TResult VisitAliasQualifiedName(AliasQualifiedNameSyntax node)
    {
      return this.DefaultVisit(node);
    }

    public virtual TResult VisitPredefinedType(PredefinedTypeSyntax node)
    {
      return this.DefaultVisit(node);
    }

    public virtual TResult VisitArrayType(ArrayTypeSyntax node)
    {
      return this.DefaultVisit(node);
    }

    public virtual TResult VisitArrayRankSpecifier(ArrayRankSpecifierSyntax node)
    {
      return this.DefaultVisit(node);
    }

    public virtual TResult VisitPointerType(PointerTypeSyntax node)
    {
      return this.DefaultVisit(node);
    }

    public virtual TResult VisitNullableType(NullableTypeSyntax node)
    {
      return this.DefaultVisit(node);
    }

    public virtual TResult VisitTupleType(TupleTypeSyntax node)
    {
      return this.DefaultVisit(node);
    }

    public virtual TResult VisitTupleElement(TupleElementSyntax node)
    {
      return this.DefaultVisit(node);
    }

    public virtual TResult VisitOmittedTypeArgument(OmittedTypeArgumentSyntax node)
    {
      return this.DefaultVisit(node);
    }

    public virtual TResult VisitRefType(RefTypeSyntax node)
    {
      return this.DefaultVisit(node);
    }

    public virtual TResult VisitParenthesizedExpression(ParenthesizedExpressionSyntax node)
    {
      return this.DefaultVisit(node);
    }

    public virtual TResult VisitTupleExpression(TupleExpressionSyntax node)
    {
      return this.DefaultVisit(node);
    }

    public virtual TResult VisitPrefixUnaryExpression(PrefixUnaryExpressionSyntax node)
    {
      return this.DefaultVisit(node);
    }

    public virtual TResult VisitAwaitExpression(AwaitExpressionSyntax node)
    {
      return this.DefaultVisit(node);
    }

    public virtual TResult VisitPostfixUnaryExpression(PostfixUnaryExpressionSyntax node)
    {
      return this.DefaultVisit(node);
    }

    public virtual TResult VisitMemberAccessExpression(MemberAccessExpressionSyntax node)
    {
      return this.DefaultVisit(node);
    }

    public virtual TResult VisitConditionalAccessExpression(ConditionalAccessExpressionSyntax node)
    {
      return this.DefaultVisit(node);
    }

    public virtual TResult VisitMemberBindingExpression(MemberBindingExpressionSyntax node)
    {
      return this.DefaultVisit(node);
    }

    public virtual TResult VisitElementBindingExpression(ElementBindingExpressionSyntax node)
    {
      return this.DefaultVisit(node);
    }

    public virtual TResult VisitImplicitElementAccess(ImplicitElementAccessSyntax node)
    {
      return this.DefaultVisit(node);
    }

    public virtual TResult VisitBinaryExpression(BinaryExpressionSyntax node)
    {
      return this.DefaultVisit(node);
    }

    public virtual TResult VisitAssignmentExpression(AssignmentExpressionSyntax node)
    {
      return this.DefaultVisit(node);
    }

    public virtual TResult VisitConditionalExpression(ConditionalExpressionSyntax node)
    {
      return this.DefaultVisit(node);
    }

    public virtual TResult VisitThisExpression(ThisExpressionSyntax node)
    {
      return this.DefaultVisit(node);
    }

    public virtual TResult VisitBaseExpression(BaseExpressionSyntax node)
    {
      return this.DefaultVisit(node);
    }

    public virtual TResult VisitLiteralExpression(LiteralExpressionSyntax node)
    {
      return this.DefaultVisit(node);
    }

    public virtual TResult VisitMakeRefExpression(MakeRefExpressionSyntax node)
    {
      return this.DefaultVisit(node);
    }

    public virtual TResult VisitRefTypeExpression(RefTypeExpressionSyntax node)
    {
      return this.DefaultVisit(node);
    }

    public virtual TResult VisitRefValueExpression(RefValueExpressionSyntax node)
    {
      return this.DefaultVisit(node);
    }

    public virtual TResult VisitCheckedExpression(CheckedExpressionSyntax node)
    {
      return this.DefaultVisit(node);
    }

    public virtual TResult VisitDefaultExpression(DefaultExpressionSyntax node)
    {
      return this.DefaultVisit(node);
    }

    public virtual TResult VisitTypeOfExpression(TypeOfExpressionSyntax node)
    {
      return this.DefaultVisit(node);
    }

    public virtual TResult VisitSizeOfExpression(SizeOfExpressionSyntax node)
    {
      return this.DefaultVisit(node);
    }

    public virtual TResult VisitInvocationExpression(InvocationExpressionSyntax node)
    {
      return this.DefaultVisit(node);
    }

    public virtual TResult VisitElementAccessExpression(ElementAccessExpressionSyntax node)
    {
      return this.DefaultVisit(node);
    }

    public virtual TResult VisitArgumentList(ArgumentListSyntax node)
    {
      return this.DefaultVisit(node);
    }

    public virtual TResult VisitBracketedArgumentList(BracketedArgumentListSyntax node)
    {
      return this.DefaultVisit(node);
    }

    public virtual TResult VisitArgument(ArgumentSyntax node)
    {
      return this.DefaultVisit(node);
    }

    public virtual TResult VisitNameColon(NameColonSyntax node)
    {
      return this.DefaultVisit(node);
    }

    public virtual TResult VisitDeclarationExpression(DeclarationExpressionSyntax node)
    {
      return this.DefaultVisit(node);
    }

    public virtual TResult VisitCastExpression(CastExpressionSyntax node)
    {
      return this.DefaultVisit(node);
    }

    public virtual TResult VisitAnonymousMethodExpression(AnonymousMethodExpressionSyntax node)
    {
      return this.DefaultVisit(node);
    }

    public virtual TResult VisitSimpleLambdaExpression(SimpleLambdaExpressionSyntax node)
    {
      return this.DefaultVisit(node);
    }

    public virtual TResult VisitRefExpression(RefExpressionSyntax node)
    {
      return this.DefaultVisit(node);
    }

    public virtual TResult VisitParenthesizedLambdaExpression(ParenthesizedLambdaExpressionSyntax node)
    {
      return this.DefaultVisit(node);
    }

    public virtual TResult VisitInitializerExpression(InitializerExpressionSyntax node)
    {
      return this.DefaultVisit(node);
    }

    public virtual TResult VisitObjectCreationExpression(ObjectCreationExpressionSyntax node)
    {
      return this.DefaultVisit(node);
    }

    public virtual TResult VisitAnonymousObjectMemberDeclarator(AnonymousObjectMemberDeclaratorSyntax node)
    {
      return this.DefaultVisit(node);
    }

    public virtual TResult VisitAnonymousObjectCreationExpression(AnonymousObjectCreationExpressionSyntax node)
    {
      return this.DefaultVisit(node);
    }

    public virtual TResult VisitArrayCreationExpression(ArrayCreationExpressionSyntax node)
    {
      return this.DefaultVisit(node);
    }

    public virtual TResult VisitImplicitArrayCreationExpression(ImplicitArrayCreationExpressionSyntax node)
    {
      return this.DefaultVisit(node);
    }

    public virtual TResult VisitStackAllocArrayCreationExpression(StackAllocArrayCreationExpressionSyntax node)
    {
      return this.DefaultVisit(node);
    }

    public virtual TResult VisitQueryExpression(QueryExpressionSyntax node)
    {
      return this.DefaultVisit(node);
    }

    public virtual TResult VisitQueryBody(QueryBodySyntax node)
    {
      return this.DefaultVisit(node);
    }

    public virtual TResult VisitFromClause(FromClauseSyntax node)
    {
      return this.DefaultVisit(node);
    }

    public virtual TResult VisitLetClause(LetClauseSyntax node)
    {
      return this.DefaultVisit(node);
    }

    public virtual TResult VisitJoinClause(JoinClauseSyntax node)
    {
      return this.DefaultVisit(node);
    }

    public virtual TResult VisitJoinIntoClause(JoinIntoClauseSyntax node)
    {
      return this.DefaultVisit(node);
    }

    public virtual TResult VisitWhereClause(WhereClauseSyntax node)
    {
      return this.DefaultVisit(node);
    }

    public virtual TResult VisitOrderByClause(OrderByClauseSyntax node)
    {
      return this.DefaultVisit(node);
    }

    public virtual TResult VisitOrdering(OrderingSyntax node)
    {
      return this.DefaultVisit(node);
    }

    public virtual TResult VisitSelectClause(SelectClauseSyntax node)
    {
      return this.DefaultVisit(node);
    }

    public virtual TResult VisitGroupClause(GroupClauseSyntax node)
    {
      return this.DefaultVisit(node);
    }

    public virtual TResult VisitQueryContinuation(QueryContinuationSyntax node)
    {
      return this.DefaultVisit(node);
    }

    public virtual TResult VisitOmittedArraySizeExpression(OmittedArraySizeExpressionSyntax node)
    {
      return this.DefaultVisit(node);
    }

    public virtual TResult VisitInterpolatedStringExpression(InterpolatedStringExpressionSyntax node)
    {
      return this.DefaultVisit(node);
    }

    public virtual TResult VisitIsPatternExpression(IsPatternExpressionSyntax node)
    {
      return this.DefaultVisit(node);
    }

    public virtual TResult VisitThrowExpression(ThrowExpressionSyntax node)
    {
      return this.DefaultVisit(node);
    }

    public virtual TResult VisitWhenClause(WhenClauseSyntax node)
    {
      return this.DefaultVisit(node);
    }

    public virtual TResult VisitDeclarationPattern(DeclarationPatternSyntax node)
    {
      return this.DefaultVisit(node);
    }

    public virtual TResult VisitConstantPattern(ConstantPatternSyntax node)
    {
      return this.DefaultVisit(node);
    }

    public virtual TResult VisitInterpolatedStringText(InterpolatedStringTextSyntax node)
    {
      return this.DefaultVisit(node);
    }

    public virtual TResult VisitInterpolation(InterpolationSyntax node)
    {
      return this.DefaultVisit(node);
    }

    public virtual TResult VisitInterpolationAlignmentClause(InterpolationAlignmentClauseSyntax node)
    {
      return this.DefaultVisit(node);
    }

    public virtual TResult VisitInterpolationFormatClause(InterpolationFormatClauseSyntax node)
    {
      return this.DefaultVisit(node);
    }

    public virtual TResult VisitGlobalStatement(GlobalStatementSyntax node)
    {
      return this.DefaultVisit(node);
    }

    public virtual TResult VisitBlock(BlockSyntax node)
    {
      return this.DefaultVisit(node);
    }

    public virtual TResult VisitLocalFunctionStatement(LocalFunctionStatementSyntax node)
    {
      return this.DefaultVisit(node);
    }

    public virtual TResult VisitLocalDeclarationStatement(LocalDeclarationStatementSyntax node)
    {
      return this.DefaultVisit(node);
    }

    public virtual TResult VisitVariableDeclaration(VariableDeclarationSyntax node)
    {
      return this.DefaultVisit(node);
    }

    public virtual TResult VisitVariableDeclarator(VariableDeclaratorSyntax node)
    {
      return this.DefaultVisit(node);
    }

    public virtual TResult VisitEqualsValueClause(EqualsValueClauseSyntax node)
    {
      return this.DefaultVisit(node);
    }

    public virtual TResult VisitSingleVariableDesignation(SingleVariableDesignationSyntax node)
    {
      return this.DefaultVisit(node);
    }

    public virtual TResult VisitDiscardDesignation(DiscardDesignationSyntax node)
    {
      return this.DefaultVisit(node);
    }

    public virtual TResult VisitParenthesizedVariableDesignation(ParenthesizedVariableDesignationSyntax node)
    {
      return this.DefaultVisit(node);
    }

    public virtual TResult VisitExpressionStatement(ExpressionStatementSyntax node)
    {
      return this.DefaultVisit(node);
    }

    public virtual TResult VisitEmptyStatement(EmptyStatementSyntax node)
    {
      return this.DefaultVisit(node);
    }

    public virtual TResult VisitLabeledStatement(LabeledStatementSyntax node)
    {
      return this.DefaultVisit(node);
    }

    public virtual TResult VisitGotoStatement(GotoStatementSyntax node)
    {
      return this.DefaultVisit(node);
    }

    public virtual TResult VisitBreakStatement(BreakStatementSyntax node)
    {
      return this.DefaultVisit(node);
    }

    public virtual TResult VisitContinueStatement(ContinueStatementSyntax node)
    {
      return this.DefaultVisit(node);
    }

    public virtual TResult VisitReturnStatement(ReturnStatementSyntax node)
    {
      return this.DefaultVisit(node);
    }

    public virtual TResult VisitThrowStatement(ThrowStatementSyntax node)
    {
      return this.DefaultVisit(node);
    }

    public virtual TResult VisitYieldStatement(YieldStatementSyntax node)
    {
      return this.DefaultVisit(node);
    }

    public virtual TResult VisitWhileStatement(WhileStatementSyntax node)
    {
      return this.DefaultVisit(node);
    }

    public virtual TResult VisitDoStatement(DoStatementSyntax node)
    {
      return this.DefaultVisit(node);
    }

    public virtual TResult VisitForStatement(ForStatementSyntax node)
    {
      return this.DefaultVisit(node);
    }

    public virtual TResult VisitForEachStatement(ForEachStatementSyntax node)
    {
      return this.DefaultVisit(node);
    }

    public virtual TResult VisitForEachVariableStatement(ForEachVariableStatementSyntax node)
    {
      return this.DefaultVisit(node);
    }

    public virtual TResult VisitUsingStatement(UsingStatementSyntax node)
    {
      return this.DefaultVisit(node);
    }

    public virtual TResult VisitFixedStatement(FixedStatementSyntax node)
    {
      return this.DefaultVisit(node);
    }

    public virtual TResult VisitCheckedStatement(CheckedStatementSyntax node)
    {
      return this.DefaultVisit(node);
    }

    public virtual TResult VisitUnsafeStatement(UnsafeStatementSyntax node)
    {
      return this.DefaultVisit(node);
    }

    public virtual TResult VisitLockStatement(LockStatementSyntax node)
    {
      return this.DefaultVisit(node);
    }

    public virtual TResult VisitIfStatement(IfStatementSyntax node)
    {
      return this.DefaultVisit(node);
    }

    public virtual TResult VisitElseClause(ElseClauseSyntax node)
    {
      return this.DefaultVisit(node);
    }

    public virtual TResult VisitSwitchStatement(SwitchStatementSyntax node)
    {
      return this.DefaultVisit(node);
    }

    public virtual TResult VisitSwitchSection(SwitchSectionSyntax node)
    {
      return this.DefaultVisit(node);
    }

    public virtual TResult VisitCasePatternSwitchLabel(CasePatternSwitchLabelSyntax node)
    {
      return this.DefaultVisit(node);
    }

    public virtual TResult VisitCaseSwitchLabel(CaseSwitchLabelSyntax node)
    {
      return this.DefaultVisit(node);
    }

    public virtual TResult VisitDefaultSwitchLabel(DefaultSwitchLabelSyntax node)
    {
      return this.DefaultVisit(node);
    }

    public virtual TResult VisitTryStatement(TryStatementSyntax node)
    {
      return this.DefaultVisit(node);
    }

    public virtual TResult VisitCatchClause(CatchClauseSyntax node)
    {
      return this.DefaultVisit(node);
    }

    public virtual TResult VisitCatchDeclaration(CatchDeclarationSyntax node)
    {
      return this.DefaultVisit(node);
    }

    public virtual TResult VisitCatchFilterClause(CatchFilterClauseSyntax node)
    {
      return this.DefaultVisit(node);
    }

    public virtual TResult VisitFinallyClause(FinallyClauseSyntax node)
    {
      return this.DefaultVisit(node);
    }

    public virtual TResult VisitCompilationUnit(CompilationUnitSyntax node)
    {
      return this.DefaultVisit(node);
    }

    public virtual TResult VisitExternAliasDirective(ExternAliasDirectiveSyntax node)
    {
      return this.DefaultVisit(node);
    }

    public virtual TResult VisitUsingDirective(UsingDirectiveSyntax node)
    {
      return this.DefaultVisit(node);
    }

    public virtual TResult VisitNamespaceDeclaration(NamespaceDeclarationSyntax node)
    {
      return this.DefaultVisit(node);
    }

    public virtual TResult VisitAttributeList(AttributeListSyntax node)
    {
      return this.DefaultVisit(node);
    }

    public virtual TResult VisitAttributeTargetSpecifier(AttributeTargetSpecifierSyntax node)
    {
      return this.DefaultVisit(node);
    }

    public virtual TResult VisitAttribute(AttributeSyntax node)
    {
      return this.DefaultVisit(node);
    }

    public virtual TResult VisitAttributeArgumentList(AttributeArgumentListSyntax node)
    {
      return this.DefaultVisit(node);
    }

    public virtual TResult VisitAttributeArgument(AttributeArgumentSyntax node)
    {
      return this.DefaultVisit(node);
    }

    public virtual TResult VisitNameEquals(NameEqualsSyntax node)
    {
      return this.DefaultVisit(node);
    }

    public virtual TResult VisitTypeParameterList(TypeParameterListSyntax node)
    {
      return this.DefaultVisit(node);
    }

    public virtual TResult VisitTypeParameter(TypeParameterSyntax node)
    {
      return this.DefaultVisit(node);
    }

    public virtual TResult VisitClassDeclaration(ClassDeclarationSyntax node)
    {
      return this.DefaultVisit(node);
    }

    public virtual TResult VisitStructDeclaration(StructDeclarationSyntax node)
    {
      return this.DefaultVisit(node);
    }

    public virtual TResult VisitInterfaceDeclaration(InterfaceDeclarationSyntax node)
    {
      return this.DefaultVisit(node);
    }

    public virtual TResult VisitEnumDeclaration(EnumDeclarationSyntax node)
    {
      return this.DefaultVisit(node);
    }

    public virtual TResult VisitDelegateDeclaration(DelegateDeclarationSyntax node)
    {
      return this.DefaultVisit(node);
    }

    public virtual TResult VisitEnumMemberDeclaration(EnumMemberDeclarationSyntax node)
    {
      return this.DefaultVisit(node);
    }

    public virtual TResult VisitBaseList(BaseListSyntax node)
    {
      return this.DefaultVisit(node);
    }

    public virtual TResult VisitSimpleBaseType(SimpleBaseTypeSyntax node)
    {
      return this.DefaultVisit(node);
    }

    public virtual TResult VisitTypeParameterConstraintClause(TypeParameterConstraintClauseSyntax node)
    {
      return this.DefaultVisit(node);
    }

    public virtual TResult VisitConstructorConstraint(ConstructorConstraintSyntax node)
    {
      return this.DefaultVisit(node);
    }

    public virtual TResult VisitClassOrStructConstraint(ClassOrStructConstraintSyntax node)
    {
      return this.DefaultVisit(node);
    }

    public virtual TResult VisitTypeConstraint(TypeConstraintSyntax node)
    {
      return this.DefaultVisit(node);
    }

    public virtual TResult VisitFieldDeclaration(FieldDeclarationSyntax node)
    {
      return this.DefaultVisit(node);
    }

    public virtual TResult VisitEventFieldDeclaration(EventFieldDeclarationSyntax node)
    {
      return this.DefaultVisit(node);
    }

    public virtual TResult VisitExplicitInterfaceSpecifier(ExplicitInterfaceSpecifierSyntax node)
    {
      return this.DefaultVisit(node);
    }

    public virtual TResult VisitMethodDeclaration(MethodDeclarationSyntax node)
    {
      return this.DefaultVisit(node);
    }

    public virtual TResult VisitOperatorDeclaration(OperatorDeclarationSyntax node)
    {
      return this.DefaultVisit(node);
    }

    public virtual TResult VisitConversionOperatorDeclaration(ConversionOperatorDeclarationSyntax node)
    {
      return this.DefaultVisit(node);
    }

    public virtual TResult VisitConstructorDeclaration(ConstructorDeclarationSyntax node)
    {
      return this.DefaultVisit(node);
    }

    public virtual TResult VisitConstructorInitializer(ConstructorInitializerSyntax node)
    {
      return this.DefaultVisit(node);
    }

    public virtual TResult VisitDestructorDeclaration(DestructorDeclarationSyntax node)
    {
      return this.DefaultVisit(node);
    }

    public virtual TResult VisitPropertyDeclaration(PropertyDeclarationSyntax node)
    {
      return this.DefaultVisit(node);
    }

    public virtual TResult VisitArrowExpressionClause(ArrowExpressionClauseSyntax node)
    {
      return this.DefaultVisit(node);
    }

    public virtual TResult VisitEventDeclaration(EventDeclarationSyntax node)
    {
      return this.DefaultVisit(node);
    }

    public virtual TResult VisitIndexerDeclaration(IndexerDeclarationSyntax node)
    {
      return this.DefaultVisit(node);
    }

    public virtual TResult VisitAccessorList(AccessorListSyntax node)
    {
      return this.DefaultVisit(node);
    }

    public virtual TResult VisitAccessorDeclaration(AccessorDeclarationSyntax node)
    {
      return this.DefaultVisit(node);
    }

    public virtual TResult VisitParameterList(ParameterListSyntax node)
    {
      return this.DefaultVisit(node);
    }

    public virtual TResult VisitBracketedParameterList(BracketedParameterListSyntax node)
    {
      return this.DefaultVisit(node);
    }

    public virtual TResult VisitParameter(ParameterSyntax node)
    {
      return this.DefaultVisit(node);
    }

    public virtual TResult VisitIncompleteMember(IncompleteMemberSyntax node)
    {
      return this.DefaultVisit(node);
    }

    public virtual TResult VisitSkippedTokensTrivia(SkippedTokensTriviaSyntax node)
    {
      return this.DefaultVisit(node);
    }

    public virtual TResult VisitDocumentationCommentTrivia(DocumentationCommentTriviaSyntax node)
    {
      return this.DefaultVisit(node);
    }

    public virtual TResult VisitTypeCref(TypeCrefSyntax node)
    {
      return this.DefaultVisit(node);
    }

    public virtual TResult VisitQualifiedCref(QualifiedCrefSyntax node)
    {
      return this.DefaultVisit(node);
    }

    public virtual TResult VisitNameMemberCref(NameMemberCrefSyntax node)
    {
      return this.DefaultVisit(node);
    }

    public virtual TResult VisitIndexerMemberCref(IndexerMemberCrefSyntax node)
    {
      return this.DefaultVisit(node);
    }

    public virtual TResult VisitOperatorMemberCref(OperatorMemberCrefSyntax node)
    {
      return this.DefaultVisit(node);
    }

    public virtual TResult VisitConversionOperatorMemberCref(ConversionOperatorMemberCrefSyntax node)
    {
      return this.DefaultVisit(node);
    }

    public virtual TResult VisitCrefParameterList(CrefParameterListSyntax node)
    {
      return this.DefaultVisit(node);
    }

    public virtual TResult VisitCrefBracketedParameterList(CrefBracketedParameterListSyntax node)
    {
      return this.DefaultVisit(node);
    }

    public virtual TResult VisitCrefParameter(CrefParameterSyntax node)
    {
      return this.DefaultVisit(node);
    }

    public virtual TResult VisitXmlElement(XmlElementSyntax node)
    {
      return this.DefaultVisit(node);
    }

    public virtual TResult VisitXmlElementStartTag(XmlElementStartTagSyntax node)
    {
      return this.DefaultVisit(node);
    }

    public virtual TResult VisitXmlElementEndTag(XmlElementEndTagSyntax node)
    {
      return this.DefaultVisit(node);
    }

    public virtual TResult VisitXmlEmptyElement(XmlEmptyElementSyntax node)
    {
      return this.DefaultVisit(node);
    }

    public virtual TResult VisitXmlName(XmlNameSyntax node)
    {
      return this.DefaultVisit(node);
    }

    public virtual TResult VisitXmlPrefix(XmlPrefixSyntax node)
    {
      return this.DefaultVisit(node);
    }

    public virtual TResult VisitXmlTextAttribute(XmlTextAttributeSyntax node)
    {
      return this.DefaultVisit(node);
    }

    public virtual TResult VisitXmlCrefAttribute(XmlCrefAttributeSyntax node)
    {
      return this.DefaultVisit(node);
    }

    public virtual TResult VisitXmlNameAttribute(XmlNameAttributeSyntax node)
    {
      return this.DefaultVisit(node);
    }

    public virtual TResult VisitXmlText(XmlTextSyntax node)
    {
      return this.DefaultVisit(node);
    }

    public virtual TResult VisitXmlCDataSection(XmlCDataSectionSyntax node)
    {
      return this.DefaultVisit(node);
    }

    public virtual TResult VisitXmlProcessingInstruction(XmlProcessingInstructionSyntax node)
    {
      return this.DefaultVisit(node);
    }

    public virtual TResult VisitXmlComment(XmlCommentSyntax node)
    {
      return this.DefaultVisit(node);
    }

    public virtual TResult VisitIfDirectiveTrivia(IfDirectiveTriviaSyntax node)
    {
      return this.DefaultVisit(node);
    }

    public virtual TResult VisitElifDirectiveTrivia(ElifDirectiveTriviaSyntax node)
    {
      return this.DefaultVisit(node);
    }

    public virtual TResult VisitElseDirectiveTrivia(ElseDirectiveTriviaSyntax node)
    {
      return this.DefaultVisit(node);
    }

    public virtual TResult VisitEndIfDirectiveTrivia(EndIfDirectiveTriviaSyntax node)
    {
      return this.DefaultVisit(node);
    }

    public virtual TResult VisitRegionDirectiveTrivia(RegionDirectiveTriviaSyntax node)
    {
      return this.DefaultVisit(node);
    }

    public virtual TResult VisitEndRegionDirectiveTrivia(EndRegionDirectiveTriviaSyntax node)
    {
      return this.DefaultVisit(node);
    }

    public virtual TResult VisitErrorDirectiveTrivia(ErrorDirectiveTriviaSyntax node)
    {
      return this.DefaultVisit(node);
    }

    public virtual TResult VisitWarningDirectiveTrivia(WarningDirectiveTriviaSyntax node)
    {
      return this.DefaultVisit(node);
    }

    public virtual TResult VisitBadDirectiveTrivia(BadDirectiveTriviaSyntax node)
    {
      return this.DefaultVisit(node);
    }

    public virtual TResult VisitDefineDirectiveTrivia(DefineDirectiveTriviaSyntax node)
    {
      return this.DefaultVisit(node);
    }

    public virtual TResult VisitUndefDirectiveTrivia(UndefDirectiveTriviaSyntax node)
    {
      return this.DefaultVisit(node);
    }

    public virtual TResult VisitLineDirectiveTrivia(LineDirectiveTriviaSyntax node)
    {
      return this.DefaultVisit(node);
    }

    public virtual TResult VisitPragmaWarningDirectiveTrivia(PragmaWarningDirectiveTriviaSyntax node)
    {
      return this.DefaultVisit(node);
    }

    public virtual TResult VisitPragmaChecksumDirectiveTrivia(PragmaChecksumDirectiveTriviaSyntax node)
    {
      return this.DefaultVisit(node);
    }

    public virtual TResult VisitReferenceDirectiveTrivia(ReferenceDirectiveTriviaSyntax node)
    {
      return this.DefaultVisit(node);
    }

    public virtual TResult VisitLoadDirectiveTrivia(LoadDirectiveTriviaSyntax node)
    {
      return this.DefaultVisit(node);
    }

    public virtual TResult VisitShebangDirectiveTrivia(ShebangDirectiveTriviaSyntax node)
    {
      return this.DefaultVisit(node);
    }
  }


  internal partial class CSharpSyntaxVisitor
  {
    public virtual void VisitIdentifierName(IdentifierNameSyntax node)
    {
      this.DefaultVisit(node);
    }

    public virtual void VisitQualifiedName(QualifiedNameSyntax node)
    {
      this.DefaultVisit(node);
    }

    public virtual void VisitGenericName(GenericNameSyntax node)
    {
      this.DefaultVisit(node);
    }

    public virtual void VisitTypeArgumentList(TypeArgumentListSyntax node)
    {
      this.DefaultVisit(node);
    }

    public virtual void VisitAliasQualifiedName(AliasQualifiedNameSyntax node)
    {
      this.DefaultVisit(node);
    }

    public virtual void VisitPredefinedType(PredefinedTypeSyntax node)
    {
      this.DefaultVisit(node);
    }

    public virtual void VisitArrayType(ArrayTypeSyntax node)
    {
      this.DefaultVisit(node);
    }

    public virtual void VisitArrayRankSpecifier(ArrayRankSpecifierSyntax node)
    {
      this.DefaultVisit(node);
    }

    public virtual void VisitPointerType(PointerTypeSyntax node)
    {
      this.DefaultVisit(node);
    }

    public virtual void VisitNullableType(NullableTypeSyntax node)
    {
      this.DefaultVisit(node);
    }

    public virtual void VisitTupleType(TupleTypeSyntax node)
    {
      this.DefaultVisit(node);
    }

    public virtual void VisitTupleElement(TupleElementSyntax node)
    {
      this.DefaultVisit(node);
    }

    public virtual void VisitOmittedTypeArgument(OmittedTypeArgumentSyntax node)
    {
      this.DefaultVisit(node);
    }

    public virtual void VisitRefType(RefTypeSyntax node)
    {
      this.DefaultVisit(node);
    }

    public virtual void VisitParenthesizedExpression(ParenthesizedExpressionSyntax node)
    {
      this.DefaultVisit(node);
    }

    public virtual void VisitTupleExpression(TupleExpressionSyntax node)
    {
      this.DefaultVisit(node);
    }

    public virtual void VisitPrefixUnaryExpression(PrefixUnaryExpressionSyntax node)
    {
      this.DefaultVisit(node);
    }

    public virtual void VisitAwaitExpression(AwaitExpressionSyntax node)
    {
      this.DefaultVisit(node);
    }

    public virtual void VisitPostfixUnaryExpression(PostfixUnaryExpressionSyntax node)
    {
      this.DefaultVisit(node);
    }

    public virtual void VisitMemberAccessExpression(MemberAccessExpressionSyntax node)
    {
      this.DefaultVisit(node);
    }

    public virtual void VisitConditionalAccessExpression(ConditionalAccessExpressionSyntax node)
    {
      this.DefaultVisit(node);
    }

    public virtual void VisitMemberBindingExpression(MemberBindingExpressionSyntax node)
    {
      this.DefaultVisit(node);
    }

    public virtual void VisitElementBindingExpression(ElementBindingExpressionSyntax node)
    {
      this.DefaultVisit(node);
    }

    public virtual void VisitImplicitElementAccess(ImplicitElementAccessSyntax node)
    {
      this.DefaultVisit(node);
    }

    public virtual void VisitBinaryExpression(BinaryExpressionSyntax node)
    {
      this.DefaultVisit(node);
    }

    public virtual void VisitAssignmentExpression(AssignmentExpressionSyntax node)
    {
      this.DefaultVisit(node);
    }

    public virtual void VisitConditionalExpression(ConditionalExpressionSyntax node)
    {
      this.DefaultVisit(node);
    }

    public virtual void VisitThisExpression(ThisExpressionSyntax node)
    {
      this.DefaultVisit(node);
    }

    public virtual void VisitBaseExpression(BaseExpressionSyntax node)
    {
      this.DefaultVisit(node);
    }

    public virtual void VisitLiteralExpression(LiteralExpressionSyntax node)
    {
      this.DefaultVisit(node);
    }

    public virtual void VisitMakeRefExpression(MakeRefExpressionSyntax node)
    {
      this.DefaultVisit(node);
    }

    public virtual void VisitRefTypeExpression(RefTypeExpressionSyntax node)
    {
      this.DefaultVisit(node);
    }

    public virtual void VisitRefValueExpression(RefValueExpressionSyntax node)
    {
      this.DefaultVisit(node);
    }

    public virtual void VisitCheckedExpression(CheckedExpressionSyntax node)
    {
      this.DefaultVisit(node);
    }

    public virtual void VisitDefaultExpression(DefaultExpressionSyntax node)
    {
      this.DefaultVisit(node);
    }

    public virtual void VisitTypeOfExpression(TypeOfExpressionSyntax node)
    {
      this.DefaultVisit(node);
    }

    public virtual void VisitSizeOfExpression(SizeOfExpressionSyntax node)
    {
      this.DefaultVisit(node);
    }

    public virtual void VisitInvocationExpression(InvocationExpressionSyntax node)
    {
      this.DefaultVisit(node);
    }

    public virtual void VisitElementAccessExpression(ElementAccessExpressionSyntax node)
    {
      this.DefaultVisit(node);
    }

    public virtual void VisitArgumentList(ArgumentListSyntax node)
    {
      this.DefaultVisit(node);
    }

    public virtual void VisitBracketedArgumentList(BracketedArgumentListSyntax node)
    {
      this.DefaultVisit(node);
    }

    public virtual void VisitArgument(ArgumentSyntax node)
    {
      this.DefaultVisit(node);
    }

    public virtual void VisitNameColon(NameColonSyntax node)
    {
      this.DefaultVisit(node);
    }

    public virtual void VisitDeclarationExpression(DeclarationExpressionSyntax node)
    {
      this.DefaultVisit(node);
    }

    public virtual void VisitCastExpression(CastExpressionSyntax node)
    {
      this.DefaultVisit(node);
    }

    public virtual void VisitAnonymousMethodExpression(AnonymousMethodExpressionSyntax node)
    {
      this.DefaultVisit(node);
    }

    public virtual void VisitSimpleLambdaExpression(SimpleLambdaExpressionSyntax node)
    {
      this.DefaultVisit(node);
    }

    public virtual void VisitRefExpression(RefExpressionSyntax node)
    {
      this.DefaultVisit(node);
    }

    public virtual void VisitParenthesizedLambdaExpression(ParenthesizedLambdaExpressionSyntax node)
    {
      this.DefaultVisit(node);
    }

    public virtual void VisitInitializerExpression(InitializerExpressionSyntax node)
    {
      this.DefaultVisit(node);
    }

    public virtual void VisitObjectCreationExpression(ObjectCreationExpressionSyntax node)
    {
      this.DefaultVisit(node);
    }

    public virtual void VisitAnonymousObjectMemberDeclarator(AnonymousObjectMemberDeclaratorSyntax node)
    {
      this.DefaultVisit(node);
    }

    public virtual void VisitAnonymousObjectCreationExpression(AnonymousObjectCreationExpressionSyntax node)
    {
      this.DefaultVisit(node);
    }

    public virtual void VisitArrayCreationExpression(ArrayCreationExpressionSyntax node)
    {
      this.DefaultVisit(node);
    }

    public virtual void VisitImplicitArrayCreationExpression(ImplicitArrayCreationExpressionSyntax node)
    {
      this.DefaultVisit(node);
    }

    public virtual void VisitStackAllocArrayCreationExpression(StackAllocArrayCreationExpressionSyntax node)
    {
      this.DefaultVisit(node);
    }

    public virtual void VisitQueryExpression(QueryExpressionSyntax node)
    {
      this.DefaultVisit(node);
    }

    public virtual void VisitQueryBody(QueryBodySyntax node)
    {
      this.DefaultVisit(node);
    }

    public virtual void VisitFromClause(FromClauseSyntax node)
    {
      this.DefaultVisit(node);
    }

    public virtual void VisitLetClause(LetClauseSyntax node)
    {
      this.DefaultVisit(node);
    }

    public virtual void VisitJoinClause(JoinClauseSyntax node)
    {
      this.DefaultVisit(node);
    }

    public virtual void VisitJoinIntoClause(JoinIntoClauseSyntax node)
    {
      this.DefaultVisit(node);
    }

    public virtual void VisitWhereClause(WhereClauseSyntax node)
    {
      this.DefaultVisit(node);
    }

    public virtual void VisitOrderByClause(OrderByClauseSyntax node)
    {
      this.DefaultVisit(node);
    }

    public virtual void VisitOrdering(OrderingSyntax node)
    {
      this.DefaultVisit(node);
    }

    public virtual void VisitSelectClause(SelectClauseSyntax node)
    {
      this.DefaultVisit(node);
    }

    public virtual void VisitGroupClause(GroupClauseSyntax node)
    {
      this.DefaultVisit(node);
    }

    public virtual void VisitQueryContinuation(QueryContinuationSyntax node)
    {
      this.DefaultVisit(node);
    }

    public virtual void VisitOmittedArraySizeExpression(OmittedArraySizeExpressionSyntax node)
    {
      this.DefaultVisit(node);
    }

    public virtual void VisitInterpolatedStringExpression(InterpolatedStringExpressionSyntax node)
    {
      this.DefaultVisit(node);
    }

    public virtual void VisitIsPatternExpression(IsPatternExpressionSyntax node)
    {
      this.DefaultVisit(node);
    }

    public virtual void VisitThrowExpression(ThrowExpressionSyntax node)
    {
      this.DefaultVisit(node);
    }

    public virtual void VisitWhenClause(WhenClauseSyntax node)
    {
      this.DefaultVisit(node);
    }

    public virtual void VisitDeclarationPattern(DeclarationPatternSyntax node)
    {
      this.DefaultVisit(node);
    }

    public virtual void VisitConstantPattern(ConstantPatternSyntax node)
    {
      this.DefaultVisit(node);
    }

    public virtual void VisitInterpolatedStringText(InterpolatedStringTextSyntax node)
    {
      this.DefaultVisit(node);
    }

    public virtual void VisitInterpolation(InterpolationSyntax node)
    {
      this.DefaultVisit(node);
    }

    public virtual void VisitInterpolationAlignmentClause(InterpolationAlignmentClauseSyntax node)
    {
      this.DefaultVisit(node);
    }

    public virtual void VisitInterpolationFormatClause(InterpolationFormatClauseSyntax node)
    {
      this.DefaultVisit(node);
    }

    public virtual void VisitGlobalStatement(GlobalStatementSyntax node)
    {
      this.DefaultVisit(node);
    }

    public virtual void VisitBlock(BlockSyntax node)
    {
      this.DefaultVisit(node);
    }

    public virtual void VisitLocalFunctionStatement(LocalFunctionStatementSyntax node)
    {
      this.DefaultVisit(node);
    }

    public virtual void VisitLocalDeclarationStatement(LocalDeclarationStatementSyntax node)
    {
      this.DefaultVisit(node);
    }

    public virtual void VisitVariableDeclaration(VariableDeclarationSyntax node)
    {
      this.DefaultVisit(node);
    }

    public virtual void VisitVariableDeclarator(VariableDeclaratorSyntax node)
    {
      this.DefaultVisit(node);
    }

    public virtual void VisitEqualsValueClause(EqualsValueClauseSyntax node)
    {
      this.DefaultVisit(node);
    }

    public virtual void VisitSingleVariableDesignation(SingleVariableDesignationSyntax node)
    {
      this.DefaultVisit(node);
    }

    public virtual void VisitDiscardDesignation(DiscardDesignationSyntax node)
    {
      this.DefaultVisit(node);
    }

    public virtual void VisitParenthesizedVariableDesignation(ParenthesizedVariableDesignationSyntax node)
    {
      this.DefaultVisit(node);
    }

    public virtual void VisitExpressionStatement(ExpressionStatementSyntax node)
    {
      this.DefaultVisit(node);
    }

    public virtual void VisitEmptyStatement(EmptyStatementSyntax node)
    {
      this.DefaultVisit(node);
    }

    public virtual void VisitLabeledStatement(LabeledStatementSyntax node)
    {
      this.DefaultVisit(node);
    }

    public virtual void VisitGotoStatement(GotoStatementSyntax node)
    {
      this.DefaultVisit(node);
    }

    public virtual void VisitBreakStatement(BreakStatementSyntax node)
    {
      this.DefaultVisit(node);
    }

    public virtual void VisitContinueStatement(ContinueStatementSyntax node)
    {
      this.DefaultVisit(node);
    }

    public virtual void VisitReturnStatement(ReturnStatementSyntax node)
    {
      this.DefaultVisit(node);
    }

    public virtual void VisitThrowStatement(ThrowStatementSyntax node)
    {
      this.DefaultVisit(node);
    }

    public virtual void VisitYieldStatement(YieldStatementSyntax node)
    {
      this.DefaultVisit(node);
    }

    public virtual void VisitWhileStatement(WhileStatementSyntax node)
    {
      this.DefaultVisit(node);
    }

    public virtual void VisitDoStatement(DoStatementSyntax node)
    {
      this.DefaultVisit(node);
    }

    public virtual void VisitForStatement(ForStatementSyntax node)
    {
      this.DefaultVisit(node);
    }

    public virtual void VisitForEachStatement(ForEachStatementSyntax node)
    {
      this.DefaultVisit(node);
    }

    public virtual void VisitForEachVariableStatement(ForEachVariableStatementSyntax node)
    {
      this.DefaultVisit(node);
    }

    public virtual void VisitUsingStatement(UsingStatementSyntax node)
    {
      this.DefaultVisit(node);
    }

    public virtual void VisitFixedStatement(FixedStatementSyntax node)
    {
      this.DefaultVisit(node);
    }

    public virtual void VisitCheckedStatement(CheckedStatementSyntax node)
    {
      this.DefaultVisit(node);
    }

    public virtual void VisitUnsafeStatement(UnsafeStatementSyntax node)
    {
      this.DefaultVisit(node);
    }

    public virtual void VisitLockStatement(LockStatementSyntax node)
    {
      this.DefaultVisit(node);
    }

    public virtual void VisitIfStatement(IfStatementSyntax node)
    {
      this.DefaultVisit(node);
    }

    public virtual void VisitElseClause(ElseClauseSyntax node)
    {
      this.DefaultVisit(node);
    }

    public virtual void VisitSwitchStatement(SwitchStatementSyntax node)
    {
      this.DefaultVisit(node);
    }

    public virtual void VisitSwitchSection(SwitchSectionSyntax node)
    {
      this.DefaultVisit(node);
    }

    public virtual void VisitCasePatternSwitchLabel(CasePatternSwitchLabelSyntax node)
    {
      this.DefaultVisit(node);
    }

    public virtual void VisitCaseSwitchLabel(CaseSwitchLabelSyntax node)
    {
      this.DefaultVisit(node);
    }

    public virtual void VisitDefaultSwitchLabel(DefaultSwitchLabelSyntax node)
    {
      this.DefaultVisit(node);
    }

    public virtual void VisitTryStatement(TryStatementSyntax node)
    {
      this.DefaultVisit(node);
    }

    public virtual void VisitCatchClause(CatchClauseSyntax node)
    {
      this.DefaultVisit(node);
    }

    public virtual void VisitCatchDeclaration(CatchDeclarationSyntax node)
    {
      this.DefaultVisit(node);
    }

    public virtual void VisitCatchFilterClause(CatchFilterClauseSyntax node)
    {
      this.DefaultVisit(node);
    }

    public virtual void VisitFinallyClause(FinallyClauseSyntax node)
    {
      this.DefaultVisit(node);
    }

    public virtual void VisitCompilationUnit(CompilationUnitSyntax node)
    {
      this.DefaultVisit(node);
    }

    public virtual void VisitExternAliasDirective(ExternAliasDirectiveSyntax node)
    {
      this.DefaultVisit(node);
    }

    public virtual void VisitUsingDirective(UsingDirectiveSyntax node)
    {
      this.DefaultVisit(node);
    }

    public virtual void VisitNamespaceDeclaration(NamespaceDeclarationSyntax node)
    {
      this.DefaultVisit(node);
    }

    public virtual void VisitAttributeList(AttributeListSyntax node)
    {
      this.DefaultVisit(node);
    }

    public virtual void VisitAttributeTargetSpecifier(AttributeTargetSpecifierSyntax node)
    {
      this.DefaultVisit(node);
    }

    public virtual void VisitAttribute(AttributeSyntax node)
    {
      this.DefaultVisit(node);
    }

    public virtual void VisitAttributeArgumentList(AttributeArgumentListSyntax node)
    {
      this.DefaultVisit(node);
    }

    public virtual void VisitAttributeArgument(AttributeArgumentSyntax node)
    {
      this.DefaultVisit(node);
    }

    public virtual void VisitNameEquals(NameEqualsSyntax node)
    {
      this.DefaultVisit(node);
    }

    public virtual void VisitTypeParameterList(TypeParameterListSyntax node)
    {
      this.DefaultVisit(node);
    }

    public virtual void VisitTypeParameter(TypeParameterSyntax node)
    {
      this.DefaultVisit(node);
    }

    public virtual void VisitClassDeclaration(ClassDeclarationSyntax node)
    {
      this.DefaultVisit(node);
    }

    public virtual void VisitStructDeclaration(StructDeclarationSyntax node)
    {
      this.DefaultVisit(node);
    }

    public virtual void VisitInterfaceDeclaration(InterfaceDeclarationSyntax node)
    {
      this.DefaultVisit(node);
    }

    public virtual void VisitEnumDeclaration(EnumDeclarationSyntax node)
    {
      this.DefaultVisit(node);
    }

    public virtual void VisitDelegateDeclaration(DelegateDeclarationSyntax node)
    {
      this.DefaultVisit(node);
    }

    public virtual void VisitEnumMemberDeclaration(EnumMemberDeclarationSyntax node)
    {
      this.DefaultVisit(node);
    }

    public virtual void VisitBaseList(BaseListSyntax node)
    {
      this.DefaultVisit(node);
    }

    public virtual void VisitSimpleBaseType(SimpleBaseTypeSyntax node)
    {
      this.DefaultVisit(node);
    }

    public virtual void VisitTypeParameterConstraintClause(TypeParameterConstraintClauseSyntax node)
    {
      this.DefaultVisit(node);
    }

    public virtual void VisitConstructorConstraint(ConstructorConstraintSyntax node)
    {
      this.DefaultVisit(node);
    }

    public virtual void VisitClassOrStructConstraint(ClassOrStructConstraintSyntax node)
    {
      this.DefaultVisit(node);
    }

    public virtual void VisitTypeConstraint(TypeConstraintSyntax node)
    {
      this.DefaultVisit(node);
    }

    public virtual void VisitFieldDeclaration(FieldDeclarationSyntax node)
    {
      this.DefaultVisit(node);
    }

    public virtual void VisitEventFieldDeclaration(EventFieldDeclarationSyntax node)
    {
      this.DefaultVisit(node);
    }

    public virtual void VisitExplicitInterfaceSpecifier(ExplicitInterfaceSpecifierSyntax node)
    {
      this.DefaultVisit(node);
    }

    public virtual void VisitMethodDeclaration(MethodDeclarationSyntax node)
    {
      this.DefaultVisit(node);
    }

    public virtual void VisitOperatorDeclaration(OperatorDeclarationSyntax node)
    {
      this.DefaultVisit(node);
    }

    public virtual void VisitConversionOperatorDeclaration(ConversionOperatorDeclarationSyntax node)
    {
      this.DefaultVisit(node);
    }

    public virtual void VisitConstructorDeclaration(ConstructorDeclarationSyntax node)
    {
      this.DefaultVisit(node);
    }

    public virtual void VisitConstructorInitializer(ConstructorInitializerSyntax node)
    {
      this.DefaultVisit(node);
    }

    public virtual void VisitDestructorDeclaration(DestructorDeclarationSyntax node)
    {
      this.DefaultVisit(node);
    }

    public virtual void VisitPropertyDeclaration(PropertyDeclarationSyntax node)
    {
      this.DefaultVisit(node);
    }

    public virtual void VisitArrowExpressionClause(ArrowExpressionClauseSyntax node)
    {
      this.DefaultVisit(node);
    }

    public virtual void VisitEventDeclaration(EventDeclarationSyntax node)
    {
      this.DefaultVisit(node);
    }

    public virtual void VisitIndexerDeclaration(IndexerDeclarationSyntax node)
    {
      this.DefaultVisit(node);
    }

    public virtual void VisitAccessorList(AccessorListSyntax node)
    {
      this.DefaultVisit(node);
    }

    public virtual void VisitAccessorDeclaration(AccessorDeclarationSyntax node)
    {
      this.DefaultVisit(node);
    }

    public virtual void VisitParameterList(ParameterListSyntax node)
    {
      this.DefaultVisit(node);
    }

    public virtual void VisitBracketedParameterList(BracketedParameterListSyntax node)
    {
      this.DefaultVisit(node);
    }

    public virtual void VisitParameter(ParameterSyntax node)
    {
      this.DefaultVisit(node);
    }

    public virtual void VisitIncompleteMember(IncompleteMemberSyntax node)
    {
      this.DefaultVisit(node);
    }

    public virtual void VisitSkippedTokensTrivia(SkippedTokensTriviaSyntax node)
    {
      this.DefaultVisit(node);
    }

    public virtual void VisitDocumentationCommentTrivia(DocumentationCommentTriviaSyntax node)
    {
      this.DefaultVisit(node);
    }

    public virtual void VisitTypeCref(TypeCrefSyntax node)
    {
      this.DefaultVisit(node);
    }

    public virtual void VisitQualifiedCref(QualifiedCrefSyntax node)
    {
      this.DefaultVisit(node);
    }

    public virtual void VisitNameMemberCref(NameMemberCrefSyntax node)
    {
      this.DefaultVisit(node);
    }

    public virtual void VisitIndexerMemberCref(IndexerMemberCrefSyntax node)
    {
      this.DefaultVisit(node);
    }

    public virtual void VisitOperatorMemberCref(OperatorMemberCrefSyntax node)
    {
      this.DefaultVisit(node);
    }

    public virtual void VisitConversionOperatorMemberCref(ConversionOperatorMemberCrefSyntax node)
    {
      this.DefaultVisit(node);
    }

    public virtual void VisitCrefParameterList(CrefParameterListSyntax node)
    {
      this.DefaultVisit(node);
    }

    public virtual void VisitCrefBracketedParameterList(CrefBracketedParameterListSyntax node)
    {
      this.DefaultVisit(node);
    }

    public virtual void VisitCrefParameter(CrefParameterSyntax node)
    {
      this.DefaultVisit(node);
    }

    public virtual void VisitXmlElement(XmlElementSyntax node)
    {
      this.DefaultVisit(node);
    }

    public virtual void VisitXmlElementStartTag(XmlElementStartTagSyntax node)
    {
      this.DefaultVisit(node);
    }

    public virtual void VisitXmlElementEndTag(XmlElementEndTagSyntax node)
    {
      this.DefaultVisit(node);
    }

    public virtual void VisitXmlEmptyElement(XmlEmptyElementSyntax node)
    {
      this.DefaultVisit(node);
    }

    public virtual void VisitXmlName(XmlNameSyntax node)
    {
      this.DefaultVisit(node);
    }

    public virtual void VisitXmlPrefix(XmlPrefixSyntax node)
    {
      this.DefaultVisit(node);
    }

    public virtual void VisitXmlTextAttribute(XmlTextAttributeSyntax node)
    {
      this.DefaultVisit(node);
    }

    public virtual void VisitXmlCrefAttribute(XmlCrefAttributeSyntax node)
    {
      this.DefaultVisit(node);
    }

    public virtual void VisitXmlNameAttribute(XmlNameAttributeSyntax node)
    {
      this.DefaultVisit(node);
    }

    public virtual void VisitXmlText(XmlTextSyntax node)
    {
      this.DefaultVisit(node);
    }

    public virtual void VisitXmlCDataSection(XmlCDataSectionSyntax node)
    {
      this.DefaultVisit(node);
    }

    public virtual void VisitXmlProcessingInstruction(XmlProcessingInstructionSyntax node)
    {
      this.DefaultVisit(node);
    }

    public virtual void VisitXmlComment(XmlCommentSyntax node)
    {
      this.DefaultVisit(node);
    }

    public virtual void VisitIfDirectiveTrivia(IfDirectiveTriviaSyntax node)
    {
      this.DefaultVisit(node);
    }

    public virtual void VisitElifDirectiveTrivia(ElifDirectiveTriviaSyntax node)
    {
      this.DefaultVisit(node);
    }

    public virtual void VisitElseDirectiveTrivia(ElseDirectiveTriviaSyntax node)
    {
      this.DefaultVisit(node);
    }

    public virtual void VisitEndIfDirectiveTrivia(EndIfDirectiveTriviaSyntax node)
    {
      this.DefaultVisit(node);
    }

    public virtual void VisitRegionDirectiveTrivia(RegionDirectiveTriviaSyntax node)
    {
      this.DefaultVisit(node);
    }

    public virtual void VisitEndRegionDirectiveTrivia(EndRegionDirectiveTriviaSyntax node)
    {
      this.DefaultVisit(node);
    }

    public virtual void VisitErrorDirectiveTrivia(ErrorDirectiveTriviaSyntax node)
    {
      this.DefaultVisit(node);
    }

    public virtual void VisitWarningDirectiveTrivia(WarningDirectiveTriviaSyntax node)
    {
      this.DefaultVisit(node);
    }

    public virtual void VisitBadDirectiveTrivia(BadDirectiveTriviaSyntax node)
    {
      this.DefaultVisit(node);
    }

    public virtual void VisitDefineDirectiveTrivia(DefineDirectiveTriviaSyntax node)
    {
      this.DefaultVisit(node);
    }

    public virtual void VisitUndefDirectiveTrivia(UndefDirectiveTriviaSyntax node)
    {
      this.DefaultVisit(node);
    }

    public virtual void VisitLineDirectiveTrivia(LineDirectiveTriviaSyntax node)
    {
      this.DefaultVisit(node);
    }

    public virtual void VisitPragmaWarningDirectiveTrivia(PragmaWarningDirectiveTriviaSyntax node)
    {
      this.DefaultVisit(node);
    }

    public virtual void VisitPragmaChecksumDirectiveTrivia(PragmaChecksumDirectiveTriviaSyntax node)
    {
      this.DefaultVisit(node);
    }

    public virtual void VisitReferenceDirectiveTrivia(ReferenceDirectiveTriviaSyntax node)
    {
      this.DefaultVisit(node);
    }

    public virtual void VisitLoadDirectiveTrivia(LoadDirectiveTriviaSyntax node)
    {
      this.DefaultVisit(node);
    }

    public virtual void VisitShebangDirectiveTrivia(ShebangDirectiveTriviaSyntax node)
    {
      this.DefaultVisit(node);
    }
  }

  internal partial class CSharpSyntaxRewriter : CSharpSyntaxVisitor<CSharpSyntaxNode>
  {
    public override CSharpSyntaxNode VisitIdentifierName(IdentifierNameSyntax node)
    {
      var identifier = (SyntaxToken)this.Visit(node.Identifier);
      return node.Update(identifier);
    }

    public override CSharpSyntaxNode VisitQualifiedName(QualifiedNameSyntax node)
    {
      var left = (NameSyntax)this.Visit(node.Left);
      var dotToken = (SyntaxToken)this.Visit(node.DotToken);
      var right = (SimpleNameSyntax)this.Visit(node.Right);
      return node.Update(left, dotToken, right);
    }

    public override CSharpSyntaxNode VisitGenericName(GenericNameSyntax node)
    {
      var identifier = (SyntaxToken)this.Visit(node.Identifier);
      var typeArgumentList = (TypeArgumentListSyntax)this.Visit(node.TypeArgumentList);
      return node.Update(identifier, typeArgumentList);
    }

    public override CSharpSyntaxNode VisitTypeArgumentList(TypeArgumentListSyntax node)
    {
      var lessThanToken = (SyntaxToken)this.Visit(node.LessThanToken);
      var arguments = this.VisitList(node.Arguments);
      var greaterThanToken = (SyntaxToken)this.Visit(node.GreaterThanToken);
      return node.Update(lessThanToken, arguments, greaterThanToken);
    }

    public override CSharpSyntaxNode VisitAliasQualifiedName(AliasQualifiedNameSyntax node)
    {
      var alias = (IdentifierNameSyntax)this.Visit(node.Alias);
      var colonColonToken = (SyntaxToken)this.Visit(node.ColonColonToken);
      var name = (SimpleNameSyntax)this.Visit(node.Name);
      return node.Update(alias, colonColonToken, name);
    }

    public override CSharpSyntaxNode VisitPredefinedType(PredefinedTypeSyntax node)
    {
      var keyword = (SyntaxToken)this.Visit(node.Keyword);
      return node.Update(keyword);
    }

    public override CSharpSyntaxNode VisitArrayType(ArrayTypeSyntax node)
    {
      var elementType = (TypeSyntax)this.Visit(node.ElementType);
      var rankSpecifiers = this.VisitList(node.RankSpecifiers);
      return node.Update(elementType, rankSpecifiers);
    }

    public override CSharpSyntaxNode VisitArrayRankSpecifier(ArrayRankSpecifierSyntax node)
    {
      var openBracketToken = (SyntaxToken)this.Visit(node.OpenBracketToken);
      var sizes = this.VisitList(node.Sizes);
      var closeBracketToken = (SyntaxToken)this.Visit(node.CloseBracketToken);
      return node.Update(openBracketToken, sizes, closeBracketToken);
    }

    public override CSharpSyntaxNode VisitPointerType(PointerTypeSyntax node)
    {
      var elementType = (TypeSyntax)this.Visit(node.ElementType);
      var asteriskToken = (SyntaxToken)this.Visit(node.AsteriskToken);
      return node.Update(elementType, asteriskToken);
    }

    public override CSharpSyntaxNode VisitNullableType(NullableTypeSyntax node)
    {
      var elementType = (TypeSyntax)this.Visit(node.ElementType);
      var questionToken = (SyntaxToken)this.Visit(node.QuestionToken);
      return node.Update(elementType, questionToken);
    }

    public override CSharpSyntaxNode VisitTupleType(TupleTypeSyntax node)
    {
      var openParenToken = (SyntaxToken)this.Visit(node.OpenParenToken);
      var elements = this.VisitList(node.Elements);
      var closeParenToken = (SyntaxToken)this.Visit(node.CloseParenToken);
      return node.Update(openParenToken, elements, closeParenToken);
    }

    public override CSharpSyntaxNode VisitTupleElement(TupleElementSyntax node)
    {
      var type = (TypeSyntax)this.Visit(node.Type);
      var identifier = (SyntaxToken)this.Visit(node.Identifier);
      return node.Update(type, identifier);
    }

    public override CSharpSyntaxNode VisitOmittedTypeArgument(OmittedTypeArgumentSyntax node)
    {
      var omittedTypeArgumentToken = (SyntaxToken)this.Visit(node.OmittedTypeArgumentToken);
      return node.Update(omittedTypeArgumentToken);
    }

    public override CSharpSyntaxNode VisitRefType(RefTypeSyntax node)
    {
      var refKeyword = (SyntaxToken)this.Visit(node.RefKeyword);
      var type = (TypeSyntax)this.Visit(node.Type);
      return node.Update(refKeyword, type);
    }

    public override CSharpSyntaxNode VisitParenthesizedExpression(ParenthesizedExpressionSyntax node)
    {
      var openParenToken = (SyntaxToken)this.Visit(node.OpenParenToken);
      var expression = (ExpressionSyntax)this.Visit(node.Expression);
      var closeParenToken = (SyntaxToken)this.Visit(node.CloseParenToken);
      return node.Update(openParenToken, expression, closeParenToken);
    }

    public override CSharpSyntaxNode VisitTupleExpression(TupleExpressionSyntax node)
    {
      var openParenToken = (SyntaxToken)this.Visit(node.OpenParenToken);
      var arguments = this.VisitList(node.Arguments);
      var closeParenToken = (SyntaxToken)this.Visit(node.CloseParenToken);
      return node.Update(openParenToken, arguments, closeParenToken);
    }

    public override CSharpSyntaxNode VisitPrefixUnaryExpression(PrefixUnaryExpressionSyntax node)
    {
      var operatorToken = (SyntaxToken)this.Visit(node.OperatorToken);
      var operand = (ExpressionSyntax)this.Visit(node.Operand);
      return node.Update(operatorToken, operand);
    }

    public override CSharpSyntaxNode VisitAwaitExpression(AwaitExpressionSyntax node)
    {
      var awaitKeyword = (SyntaxToken)this.Visit(node.AwaitKeyword);
      var expression = (ExpressionSyntax)this.Visit(node.Expression);
      return node.Update(awaitKeyword, expression);
    }

    public override CSharpSyntaxNode VisitPostfixUnaryExpression(PostfixUnaryExpressionSyntax node)
    {
      var operand = (ExpressionSyntax)this.Visit(node.Operand);
      var operatorToken = (SyntaxToken)this.Visit(node.OperatorToken);
      return node.Update(operand, operatorToken);
    }

    public override CSharpSyntaxNode VisitMemberAccessExpression(MemberAccessExpressionSyntax node)
    {
      var expression = (ExpressionSyntax)this.Visit(node.Expression);
      var operatorToken = (SyntaxToken)this.Visit(node.OperatorToken);
      var name = (SimpleNameSyntax)this.Visit(node.Name);
      return node.Update(expression, operatorToken, name);
    }

    public override CSharpSyntaxNode VisitConditionalAccessExpression(ConditionalAccessExpressionSyntax node)
    {
      var expression = (ExpressionSyntax)this.Visit(node.Expression);
      var operatorToken = (SyntaxToken)this.Visit(node.OperatorToken);
      var whenNotNull = (ExpressionSyntax)this.Visit(node.WhenNotNull);
      return node.Update(expression, operatorToken, whenNotNull);
    }

    public override CSharpSyntaxNode VisitMemberBindingExpression(MemberBindingExpressionSyntax node)
    {
      var operatorToken = (SyntaxToken)this.Visit(node.OperatorToken);
      var name = (SimpleNameSyntax)this.Visit(node.Name);
      return node.Update(operatorToken, name);
    }

    public override CSharpSyntaxNode VisitElementBindingExpression(ElementBindingExpressionSyntax node)
    {
      var argumentList = (BracketedArgumentListSyntax)this.Visit(node.ArgumentList);
      return node.Update(argumentList);
    }

    public override CSharpSyntaxNode VisitImplicitElementAccess(ImplicitElementAccessSyntax node)
    {
      var argumentList = (BracketedArgumentListSyntax)this.Visit(node.ArgumentList);
      return node.Update(argumentList);
    }

    public override CSharpSyntaxNode VisitBinaryExpression(BinaryExpressionSyntax node)
    {
      var left = (ExpressionSyntax)this.Visit(node.Left);
      var operatorToken = (SyntaxToken)this.Visit(node.OperatorToken);
      var right = (ExpressionSyntax)this.Visit(node.Right);
      return node.Update(left, operatorToken, right);
    }

    public override CSharpSyntaxNode VisitAssignmentExpression(AssignmentExpressionSyntax node)
    {
      var left = (ExpressionSyntax)this.Visit(node.Left);
      var operatorToken = (SyntaxToken)this.Visit(node.OperatorToken);
      var right = (ExpressionSyntax)this.Visit(node.Right);
      return node.Update(left, operatorToken, right);
    }

    public override CSharpSyntaxNode VisitConditionalExpression(ConditionalExpressionSyntax node)
    {
      var condition = (ExpressionSyntax)this.Visit(node.Condition);
      var questionToken = (SyntaxToken)this.Visit(node.QuestionToken);
      var whenTrue = (ExpressionSyntax)this.Visit(node.WhenTrue);
      var colonToken = (SyntaxToken)this.Visit(node.ColonToken);
      var whenFalse = (ExpressionSyntax)this.Visit(node.WhenFalse);
      return node.Update(condition, questionToken, whenTrue, colonToken, whenFalse);
    }

    public override CSharpSyntaxNode VisitThisExpression(ThisExpressionSyntax node)
    {
      var token = (SyntaxToken)this.Visit(node.Token);
      return node.Update(token);
    }

    public override CSharpSyntaxNode VisitBaseExpression(BaseExpressionSyntax node)
    {
      var token = (SyntaxToken)this.Visit(node.Token);
      return node.Update(token);
    }

    public override CSharpSyntaxNode VisitLiteralExpression(LiteralExpressionSyntax node)
    {
      var token = (SyntaxToken)this.Visit(node.Token);
      return node.Update(token);
    }

    public override CSharpSyntaxNode VisitMakeRefExpression(MakeRefExpressionSyntax node)
    {
      var keyword = (SyntaxToken)this.Visit(node.Keyword);
      var openParenToken = (SyntaxToken)this.Visit(node.OpenParenToken);
      var expression = (ExpressionSyntax)this.Visit(node.Expression);
      var closeParenToken = (SyntaxToken)this.Visit(node.CloseParenToken);
      return node.Update(keyword, openParenToken, expression, closeParenToken);
    }

    public override CSharpSyntaxNode VisitRefTypeExpression(RefTypeExpressionSyntax node)
    {
      var keyword = (SyntaxToken)this.Visit(node.Keyword);
      var openParenToken = (SyntaxToken)this.Visit(node.OpenParenToken);
      var expression = (ExpressionSyntax)this.Visit(node.Expression);
      var closeParenToken = (SyntaxToken)this.Visit(node.CloseParenToken);
      return node.Update(keyword, openParenToken, expression, closeParenToken);
    }

    public override CSharpSyntaxNode VisitRefValueExpression(RefValueExpressionSyntax node)
    {
      var keyword = (SyntaxToken)this.Visit(node.Keyword);
      var openParenToken = (SyntaxToken)this.Visit(node.OpenParenToken);
      var expression = (ExpressionSyntax)this.Visit(node.Expression);
      var comma = (SyntaxToken)this.Visit(node.Comma);
      var type = (TypeSyntax)this.Visit(node.Type);
      var closeParenToken = (SyntaxToken)this.Visit(node.CloseParenToken);
      return node.Update(keyword, openParenToken, expression, comma, type, closeParenToken);
    }

    public override CSharpSyntaxNode VisitCheckedExpression(CheckedExpressionSyntax node)
    {
      var keyword = (SyntaxToken)this.Visit(node.Keyword);
      var openParenToken = (SyntaxToken)this.Visit(node.OpenParenToken);
      var expression = (ExpressionSyntax)this.Visit(node.Expression);
      var closeParenToken = (SyntaxToken)this.Visit(node.CloseParenToken);
      return node.Update(keyword, openParenToken, expression, closeParenToken);
    }

    public override CSharpSyntaxNode VisitDefaultExpression(DefaultExpressionSyntax node)
    {
      var keyword = (SyntaxToken)this.Visit(node.Keyword);
      var openParenToken = (SyntaxToken)this.Visit(node.OpenParenToken);
      var type = (TypeSyntax)this.Visit(node.Type);
      var closeParenToken = (SyntaxToken)this.Visit(node.CloseParenToken);
      return node.Update(keyword, openParenToken, type, closeParenToken);
    }

    public override CSharpSyntaxNode VisitTypeOfExpression(TypeOfExpressionSyntax node)
    {
      var keyword = (SyntaxToken)this.Visit(node.Keyword);
      var openParenToken = (SyntaxToken)this.Visit(node.OpenParenToken);
      var type = (TypeSyntax)this.Visit(node.Type);
      var closeParenToken = (SyntaxToken)this.Visit(node.CloseParenToken);
      return node.Update(keyword, openParenToken, type, closeParenToken);
    }

    public override CSharpSyntaxNode VisitSizeOfExpression(SizeOfExpressionSyntax node)
    {
      var keyword = (SyntaxToken)this.Visit(node.Keyword);
      var openParenToken = (SyntaxToken)this.Visit(node.OpenParenToken);
      var type = (TypeSyntax)this.Visit(node.Type);
      var closeParenToken = (SyntaxToken)this.Visit(node.CloseParenToken);
      return node.Update(keyword, openParenToken, type, closeParenToken);
    }

    public override CSharpSyntaxNode VisitInvocationExpression(InvocationExpressionSyntax node)
    {
      var expression = (ExpressionSyntax)this.Visit(node.Expression);
      var argumentList = (ArgumentListSyntax)this.Visit(node.ArgumentList);
      return node.Update(expression, argumentList);
    }

    public override CSharpSyntaxNode VisitElementAccessExpression(ElementAccessExpressionSyntax node)
    {
      var expression = (ExpressionSyntax)this.Visit(node.Expression);
      var argumentList = (BracketedArgumentListSyntax)this.Visit(node.ArgumentList);
      return node.Update(expression, argumentList);
    }

    public override CSharpSyntaxNode VisitArgumentList(ArgumentListSyntax node)
    {
      var openParenToken = (SyntaxToken)this.Visit(node.OpenParenToken);
      var arguments = this.VisitList(node.Arguments);
      var closeParenToken = (SyntaxToken)this.Visit(node.CloseParenToken);
      return node.Update(openParenToken, arguments, closeParenToken);
    }

    public override CSharpSyntaxNode VisitBracketedArgumentList(BracketedArgumentListSyntax node)
    {
      var openBracketToken = (SyntaxToken)this.Visit(node.OpenBracketToken);
      var arguments = this.VisitList(node.Arguments);
      var closeBracketToken = (SyntaxToken)this.Visit(node.CloseBracketToken);
      return node.Update(openBracketToken, arguments, closeBracketToken);
    }

    public override CSharpSyntaxNode VisitArgument(ArgumentSyntax node)
    {
      var nameColon = (NameColonSyntax)this.Visit(node.NameColon);
      var refOrOutKeyword = (SyntaxToken)this.Visit(node.RefOrOutKeyword);
      var expression = (ExpressionSyntax)this.Visit(node.Expression);
      return node.Update(nameColon, refOrOutKeyword, expression);
    }

    public override CSharpSyntaxNode VisitNameColon(NameColonSyntax node)
    {
      var name = (IdentifierNameSyntax)this.Visit(node.Name);
      var colonToken = (SyntaxToken)this.Visit(node.ColonToken);
      return node.Update(name, colonToken);
    }

    public override CSharpSyntaxNode VisitDeclarationExpression(DeclarationExpressionSyntax node)
    {
      var type = (TypeSyntax)this.Visit(node.Type);
      var designation = (VariableDesignationSyntax)this.Visit(node.Designation);
      return node.Update(type, designation);
    }

    public override CSharpSyntaxNode VisitCastExpression(CastExpressionSyntax node)
    {
      var openParenToken = (SyntaxToken)this.Visit(node.OpenParenToken);
      var type = (TypeSyntax)this.Visit(node.Type);
      var closeParenToken = (SyntaxToken)this.Visit(node.CloseParenToken);
      var expression = (ExpressionSyntax)this.Visit(node.Expression);
      return node.Update(openParenToken, type, closeParenToken, expression);
    }

    public override CSharpSyntaxNode VisitAnonymousMethodExpression(AnonymousMethodExpressionSyntax node)
    {
      var asyncKeyword = (SyntaxToken)this.Visit(node.AsyncKeyword);
      var delegateKeyword = (SyntaxToken)this.Visit(node.DelegateKeyword);
      var parameterList = (ParameterListSyntax)this.Visit(node.ParameterList);
      var body = (CSharpSyntaxNode)this.Visit(node.Body);
      return node.Update(asyncKeyword, delegateKeyword, parameterList, body);
    }

    public override CSharpSyntaxNode VisitSimpleLambdaExpression(SimpleLambdaExpressionSyntax node)
    {
      var asyncKeyword = (SyntaxToken)this.Visit(node.AsyncKeyword);
      var parameter = (ParameterSyntax)this.Visit(node.Parameter);
      var arrowToken = (SyntaxToken)this.Visit(node.ArrowToken);
      var body = (CSharpSyntaxNode)this.Visit(node.Body);
      return node.Update(asyncKeyword, parameter, arrowToken, body);
    }

    public override CSharpSyntaxNode VisitRefExpression(RefExpressionSyntax node)
    {
      var refKeyword = (SyntaxToken)this.Visit(node.RefKeyword);
      var expression = (ExpressionSyntax)this.Visit(node.Expression);
      return node.Update(refKeyword, expression);
    }

    public override CSharpSyntaxNode VisitParenthesizedLambdaExpression(ParenthesizedLambdaExpressionSyntax node)
    {
      var asyncKeyword = (SyntaxToken)this.Visit(node.AsyncKeyword);
      var parameterList = (ParameterListSyntax)this.Visit(node.ParameterList);
      var arrowToken = (SyntaxToken)this.Visit(node.ArrowToken);
      var body = (CSharpSyntaxNode)this.Visit(node.Body);
      return node.Update(asyncKeyword, parameterList, arrowToken, body);
    }

    public override CSharpSyntaxNode VisitInitializerExpression(InitializerExpressionSyntax node)
    {
      var openBraceToken = (SyntaxToken)this.Visit(node.OpenBraceToken);
      var expressions = this.VisitList(node.Expressions);
      var closeBraceToken = (SyntaxToken)this.Visit(node.CloseBraceToken);
      return node.Update(openBraceToken, expressions, closeBraceToken);
    }

    public override CSharpSyntaxNode VisitObjectCreationExpression(ObjectCreationExpressionSyntax node)
    {
      var newKeyword = (SyntaxToken)this.Visit(node.NewKeyword);
      var type = (TypeSyntax)this.Visit(node.Type);
      var argumentList = (ArgumentListSyntax)this.Visit(node.ArgumentList);
      var initializer = (InitializerExpressionSyntax)this.Visit(node.Initializer);
      return node.Update(newKeyword, type, argumentList, initializer);
    }

    public override CSharpSyntaxNode VisitAnonymousObjectMemberDeclarator(AnonymousObjectMemberDeclaratorSyntax node)
    {
      var nameEquals = (NameEqualsSyntax)this.Visit(node.NameEquals);
      var expression = (ExpressionSyntax)this.Visit(node.Expression);
      return node.Update(nameEquals, expression);
    }

    public override CSharpSyntaxNode VisitAnonymousObjectCreationExpression(AnonymousObjectCreationExpressionSyntax node)
    {
      var newKeyword = (SyntaxToken)this.Visit(node.NewKeyword);
      var openBraceToken = (SyntaxToken)this.Visit(node.OpenBraceToken);
      var initializers = this.VisitList(node.Initializers);
      var closeBraceToken = (SyntaxToken)this.Visit(node.CloseBraceToken);
      return node.Update(newKeyword, openBraceToken, initializers, closeBraceToken);
    }

    public override CSharpSyntaxNode VisitArrayCreationExpression(ArrayCreationExpressionSyntax node)
    {
      var newKeyword = (SyntaxToken)this.Visit(node.NewKeyword);
      var type = (ArrayTypeSyntax)this.Visit(node.Type);
      var initializer = (InitializerExpressionSyntax)this.Visit(node.Initializer);
      return node.Update(newKeyword, type, initializer);
    }

    public override CSharpSyntaxNode VisitImplicitArrayCreationExpression(ImplicitArrayCreationExpressionSyntax node)
    {
      var newKeyword = (SyntaxToken)this.Visit(node.NewKeyword);
      var openBracketToken = (SyntaxToken)this.Visit(node.OpenBracketToken);
      var commas = this.VisitList(node.Commas);
      var closeBracketToken = (SyntaxToken)this.Visit(node.CloseBracketToken);
      var initializer = (InitializerExpressionSyntax)this.Visit(node.Initializer);
      return node.Update(newKeyword, openBracketToken, commas, closeBracketToken, initializer);
    }

    public override CSharpSyntaxNode VisitStackAllocArrayCreationExpression(StackAllocArrayCreationExpressionSyntax node)
    {
      var stackAllocKeyword = (SyntaxToken)this.Visit(node.StackAllocKeyword);
      var type = (TypeSyntax)this.Visit(node.Type);
      return node.Update(stackAllocKeyword, type);
    }

    public override CSharpSyntaxNode VisitQueryExpression(QueryExpressionSyntax node)
    {
      var fromClause = (FromClauseSyntax)this.Visit(node.FromClause);
      var body = (QueryBodySyntax)this.Visit(node.Body);
      return node.Update(fromClause, body);
    }

    public override CSharpSyntaxNode VisitQueryBody(QueryBodySyntax node)
    {
      var clauses = this.VisitList(node.Clauses);
      var selectOrGroup = (SelectOrGroupClauseSyntax)this.Visit(node.SelectOrGroup);
      var continuation = (QueryContinuationSyntax)this.Visit(node.Continuation);
      return node.Update(clauses, selectOrGroup, continuation);
    }

    public override CSharpSyntaxNode VisitFromClause(FromClauseSyntax node)
    {
      var fromKeyword = (SyntaxToken)this.Visit(node.FromKeyword);
      var type = (TypeSyntax)this.Visit(node.Type);
      var identifier = (SyntaxToken)this.Visit(node.Identifier);
      var inKeyword = (SyntaxToken)this.Visit(node.InKeyword);
      var expression = (ExpressionSyntax)this.Visit(node.Expression);
      return node.Update(fromKeyword, type, identifier, inKeyword, expression);
    }

    public override CSharpSyntaxNode VisitLetClause(LetClauseSyntax node)
    {
      var letKeyword = (SyntaxToken)this.Visit(node.LetKeyword);
      var identifier = (SyntaxToken)this.Visit(node.Identifier);
      var equalsToken = (SyntaxToken)this.Visit(node.EqualsToken);
      var expression = (ExpressionSyntax)this.Visit(node.Expression);
      return node.Update(letKeyword, identifier, equalsToken, expression);
    }

    public override CSharpSyntaxNode VisitJoinClause(JoinClauseSyntax node)
    {
      var joinKeyword = (SyntaxToken)this.Visit(node.JoinKeyword);
      var type = (TypeSyntax)this.Visit(node.Type);
      var identifier = (SyntaxToken)this.Visit(node.Identifier);
      var inKeyword = (SyntaxToken)this.Visit(node.InKeyword);
      var inExpression = (ExpressionSyntax)this.Visit(node.InExpression);
      var onKeyword = (SyntaxToken)this.Visit(node.OnKeyword);
      var leftExpression = (ExpressionSyntax)this.Visit(node.LeftExpression);
      var equalsKeyword = (SyntaxToken)this.Visit(node.EqualsKeyword);
      var rightExpression = (ExpressionSyntax)this.Visit(node.RightExpression);
      var into = (JoinIntoClauseSyntax)this.Visit(node.Into);
      return node.Update(joinKeyword, type, identifier, inKeyword, inExpression, onKeyword, leftExpression, equalsKeyword, rightExpression, into);
    }

    public override CSharpSyntaxNode VisitJoinIntoClause(JoinIntoClauseSyntax node)
    {
      var intoKeyword = (SyntaxToken)this.Visit(node.IntoKeyword);
      var identifier = (SyntaxToken)this.Visit(node.Identifier);
      return node.Update(intoKeyword, identifier);
    }

    public override CSharpSyntaxNode VisitWhereClause(WhereClauseSyntax node)
    {
      var whereKeyword = (SyntaxToken)this.Visit(node.WhereKeyword);
      var condition = (ExpressionSyntax)this.Visit(node.Condition);
      return node.Update(whereKeyword, condition);
    }

    public override CSharpSyntaxNode VisitOrderByClause(OrderByClauseSyntax node)
    {
      var orderByKeyword = (SyntaxToken)this.Visit(node.OrderByKeyword);
      var orderings = this.VisitList(node.Orderings);
      return node.Update(orderByKeyword, orderings);
    }

    public override CSharpSyntaxNode VisitOrdering(OrderingSyntax node)
    {
      var expression = (ExpressionSyntax)this.Visit(node.Expression);
      var ascendingOrDescendingKeyword = (SyntaxToken)this.Visit(node.AscendingOrDescendingKeyword);
      return node.Update(expression, ascendingOrDescendingKeyword);
    }

    public override CSharpSyntaxNode VisitSelectClause(SelectClauseSyntax node)
    {
      var selectKeyword = (SyntaxToken)this.Visit(node.SelectKeyword);
      var expression = (ExpressionSyntax)this.Visit(node.Expression);
      return node.Update(selectKeyword, expression);
    }

    public override CSharpSyntaxNode VisitGroupClause(GroupClauseSyntax node)
    {
      var groupKeyword = (SyntaxToken)this.Visit(node.GroupKeyword);
      var groupExpression = (ExpressionSyntax)this.Visit(node.GroupExpression);
      var byKeyword = (SyntaxToken)this.Visit(node.ByKeyword);
      var byExpression = (ExpressionSyntax)this.Visit(node.ByExpression);
      return node.Update(groupKeyword, groupExpression, byKeyword, byExpression);
    }

    public override CSharpSyntaxNode VisitQueryContinuation(QueryContinuationSyntax node)
    {
      var intoKeyword = (SyntaxToken)this.Visit(node.IntoKeyword);
      var identifier = (SyntaxToken)this.Visit(node.Identifier);
      var body = (QueryBodySyntax)this.Visit(node.Body);
      return node.Update(intoKeyword, identifier, body);
    }

    public override CSharpSyntaxNode VisitOmittedArraySizeExpression(OmittedArraySizeExpressionSyntax node)
    {
      var omittedArraySizeExpressionToken = (SyntaxToken)this.Visit(node.OmittedArraySizeExpressionToken);
      return node.Update(omittedArraySizeExpressionToken);
    }

    public override CSharpSyntaxNode VisitInterpolatedStringExpression(InterpolatedStringExpressionSyntax node)
    {
      var stringStartToken = (SyntaxToken)this.Visit(node.StringStartToken);
      var contents = this.VisitList(node.Contents);
      var stringEndToken = (SyntaxToken)this.Visit(node.StringEndToken);
      return node.Update(stringStartToken, contents, stringEndToken);
    }

    public override CSharpSyntaxNode VisitIsPatternExpression(IsPatternExpressionSyntax node)
    {
      var expression = (ExpressionSyntax)this.Visit(node.Expression);
      var isKeyword = (SyntaxToken)this.Visit(node.IsKeyword);
      var pattern = (PatternSyntax)this.Visit(node.Pattern);
      return node.Update(expression, isKeyword, pattern);
    }

    public override CSharpSyntaxNode VisitThrowExpression(ThrowExpressionSyntax node)
    {
      var throwKeyword = (SyntaxToken)this.Visit(node.ThrowKeyword);
      var expression = (ExpressionSyntax)this.Visit(node.Expression);
      return node.Update(throwKeyword, expression);
    }

    public override CSharpSyntaxNode VisitWhenClause(WhenClauseSyntax node)
    {
      var whenKeyword = (SyntaxToken)this.Visit(node.WhenKeyword);
      var condition = (ExpressionSyntax)this.Visit(node.Condition);
      return node.Update(whenKeyword, condition);
    }

    public override CSharpSyntaxNode VisitDeclarationPattern(DeclarationPatternSyntax node)
    {
      var type = (TypeSyntax)this.Visit(node.Type);
      var designation = (VariableDesignationSyntax)this.Visit(node.Designation);
      return node.Update(type, designation);
    }

    public override CSharpSyntaxNode VisitConstantPattern(ConstantPatternSyntax node)
    {
      var expression = (ExpressionSyntax)this.Visit(node.Expression);
      return node.Update(expression);
    }

    public override CSharpSyntaxNode VisitInterpolatedStringText(InterpolatedStringTextSyntax node)
    {
      var textToken = (SyntaxToken)this.Visit(node.TextToken);
      return node.Update(textToken);
    }

    public override CSharpSyntaxNode VisitInterpolation(InterpolationSyntax node)
    {
      var openBraceToken = (SyntaxToken)this.Visit(node.OpenBraceToken);
      var expression = (ExpressionSyntax)this.Visit(node.Expression);
      var alignmentClause = (InterpolationAlignmentClauseSyntax)this.Visit(node.AlignmentClause);
      var formatClause = (InterpolationFormatClauseSyntax)this.Visit(node.FormatClause);
      var closeBraceToken = (SyntaxToken)this.Visit(node.CloseBraceToken);
      return node.Update(openBraceToken, expression, alignmentClause, formatClause, closeBraceToken);
    }

    public override CSharpSyntaxNode VisitInterpolationAlignmentClause(InterpolationAlignmentClauseSyntax node)
    {
      var commaToken = (SyntaxToken)this.Visit(node.CommaToken);
      var value = (ExpressionSyntax)this.Visit(node.Value);
      return node.Update(commaToken, value);
    }

    public override CSharpSyntaxNode VisitInterpolationFormatClause(InterpolationFormatClauseSyntax node)
    {
      var colonToken = (SyntaxToken)this.Visit(node.ColonToken);
      var formatStringToken = (SyntaxToken)this.Visit(node.FormatStringToken);
      return node.Update(colonToken, formatStringToken);
    }

    public override CSharpSyntaxNode VisitGlobalStatement(GlobalStatementSyntax node)
    {
      var statement = (StatementSyntax)this.Visit(node.Statement);
      return node.Update(statement);
    }

    public override CSharpSyntaxNode VisitBlock(BlockSyntax node)
    {
      var openBraceToken = (SyntaxToken)this.Visit(node.OpenBraceToken);
      var statements = this.VisitList(node.Statements);
      var closeBraceToken = (SyntaxToken)this.Visit(node.CloseBraceToken);
      return node.Update(openBraceToken, statements, closeBraceToken);
    }

    public override CSharpSyntaxNode VisitLocalFunctionStatement(LocalFunctionStatementSyntax node)
    {
      var modifiers = this.VisitList(node.Modifiers);
      var returnType = (TypeSyntax)this.Visit(node.ReturnType);
      var identifier = (SyntaxToken)this.Visit(node.Identifier);
      var typeParameterList = (TypeParameterListSyntax)this.Visit(node.TypeParameterList);
      var parameterList = (ParameterListSyntax)this.Visit(node.ParameterList);
      var constraintClauses = this.VisitList(node.ConstraintClauses);
      var body = (BlockSyntax)this.Visit(node.Body);
      var expressionBody = (ArrowExpressionClauseSyntax)this.Visit(node.ExpressionBody);
      var semicolonToken = (SyntaxToken)this.Visit(node.SemicolonToken);
      return node.Update(modifiers, returnType, identifier, typeParameterList, parameterList, constraintClauses, body, expressionBody, semicolonToken);
    }

    public override CSharpSyntaxNode VisitLocalDeclarationStatement(LocalDeclarationStatementSyntax node)
    {
      var modifiers = this.VisitList(node.Modifiers);
      var declaration = (VariableDeclarationSyntax)this.Visit(node.Declaration);
      var semicolonToken = (SyntaxToken)this.Visit(node.SemicolonToken);
      return node.Update(modifiers, declaration, semicolonToken);
    }

    public override CSharpSyntaxNode VisitVariableDeclaration(VariableDeclarationSyntax node)
    {
      var type = (TypeSyntax)this.Visit(node.Type);
      var variables = this.VisitList(node.Variables);
      return node.Update(type, variables);
    }

    public override CSharpSyntaxNode VisitVariableDeclarator(VariableDeclaratorSyntax node)
    {
      var identifier = (SyntaxToken)this.Visit(node.Identifier);
      var argumentList = (BracketedArgumentListSyntax)this.Visit(node.ArgumentList);
      var initializer = (EqualsValueClauseSyntax)this.Visit(node.Initializer);
      return node.Update(identifier, argumentList, initializer);
    }

    public override CSharpSyntaxNode VisitEqualsValueClause(EqualsValueClauseSyntax node)
    {
      var equalsToken = (SyntaxToken)this.Visit(node.EqualsToken);
      var value = (ExpressionSyntax)this.Visit(node.Value);
      return node.Update(equalsToken, value);
    }

    public override CSharpSyntaxNode VisitSingleVariableDesignation(SingleVariableDesignationSyntax node)
    {
      var identifier = (SyntaxToken)this.Visit(node.Identifier);
      return node.Update(identifier);
    }

    public override CSharpSyntaxNode VisitDiscardDesignation(DiscardDesignationSyntax node)
    {
      var underscoreToken = (SyntaxToken)this.Visit(node.UnderscoreToken);
      return node.Update(underscoreToken);
    }

    public override CSharpSyntaxNode VisitParenthesizedVariableDesignation(ParenthesizedVariableDesignationSyntax node)
    {
      var openParenToken = (SyntaxToken)this.Visit(node.OpenParenToken);
      var variables = this.VisitList(node.Variables);
      var closeParenToken = (SyntaxToken)this.Visit(node.CloseParenToken);
      return node.Update(openParenToken, variables, closeParenToken);
    }

    public override CSharpSyntaxNode VisitExpressionStatement(ExpressionStatementSyntax node)
    {
      var expression = (ExpressionSyntax)this.Visit(node.Expression);
      var semicolonToken = (SyntaxToken)this.Visit(node.SemicolonToken);
      return node.Update(expression, semicolonToken);
    }

    public override CSharpSyntaxNode VisitEmptyStatement(EmptyStatementSyntax node)
    {
      var semicolonToken = (SyntaxToken)this.Visit(node.SemicolonToken);
      return node.Update(semicolonToken);
    }

    public override CSharpSyntaxNode VisitLabeledStatement(LabeledStatementSyntax node)
    {
      var identifier = (SyntaxToken)this.Visit(node.Identifier);
      var colonToken = (SyntaxToken)this.Visit(node.ColonToken);
      var statement = (StatementSyntax)this.Visit(node.Statement);
      return node.Update(identifier, colonToken, statement);
    }

    public override CSharpSyntaxNode VisitGotoStatement(GotoStatementSyntax node)
    {
      var gotoKeyword = (SyntaxToken)this.Visit(node.GotoKeyword);
      var caseOrDefaultKeyword = (SyntaxToken)this.Visit(node.CaseOrDefaultKeyword);
      var expression = (ExpressionSyntax)this.Visit(node.Expression);
      var semicolonToken = (SyntaxToken)this.Visit(node.SemicolonToken);
      return node.Update(gotoKeyword, caseOrDefaultKeyword, expression, semicolonToken);
    }

    public override CSharpSyntaxNode VisitBreakStatement(BreakStatementSyntax node)
    {
      var breakKeyword = (SyntaxToken)this.Visit(node.BreakKeyword);
      var semicolonToken = (SyntaxToken)this.Visit(node.SemicolonToken);
      return node.Update(breakKeyword, semicolonToken);
    }

    public override CSharpSyntaxNode VisitContinueStatement(ContinueStatementSyntax node)
    {
      var continueKeyword = (SyntaxToken)this.Visit(node.ContinueKeyword);
      var semicolonToken = (SyntaxToken)this.Visit(node.SemicolonToken);
      return node.Update(continueKeyword, semicolonToken);
    }

    public override CSharpSyntaxNode VisitReturnStatement(ReturnStatementSyntax node)
    {
      var returnKeyword = (SyntaxToken)this.Visit(node.ReturnKeyword);
      var expression = (ExpressionSyntax)this.Visit(node.Expression);
      var semicolonToken = (SyntaxToken)this.Visit(node.SemicolonToken);
      return node.Update(returnKeyword, expression, semicolonToken);
    }

    public override CSharpSyntaxNode VisitThrowStatement(ThrowStatementSyntax node)
    {
      var throwKeyword = (SyntaxToken)this.Visit(node.ThrowKeyword);
      var expression = (ExpressionSyntax)this.Visit(node.Expression);
      var semicolonToken = (SyntaxToken)this.Visit(node.SemicolonToken);
      return node.Update(throwKeyword, expression, semicolonToken);
    }

    public override CSharpSyntaxNode VisitYieldStatement(YieldStatementSyntax node)
    {
      var yieldKeyword = (SyntaxToken)this.Visit(node.YieldKeyword);
      var returnOrBreakKeyword = (SyntaxToken)this.Visit(node.ReturnOrBreakKeyword);
      var expression = (ExpressionSyntax)this.Visit(node.Expression);
      var semicolonToken = (SyntaxToken)this.Visit(node.SemicolonToken);
      return node.Update(yieldKeyword, returnOrBreakKeyword, expression, semicolonToken);
    }

    public override CSharpSyntaxNode VisitWhileStatement(WhileStatementSyntax node)
    {
      var whileKeyword = (SyntaxToken)this.Visit(node.WhileKeyword);
      var openParenToken = (SyntaxToken)this.Visit(node.OpenParenToken);
      var condition = (ExpressionSyntax)this.Visit(node.Condition);
      var closeParenToken = (SyntaxToken)this.Visit(node.CloseParenToken);
      var statement = (StatementSyntax)this.Visit(node.Statement);
      return node.Update(whileKeyword, openParenToken, condition, closeParenToken, statement);
    }

    public override CSharpSyntaxNode VisitDoStatement(DoStatementSyntax node)
    {
      var doKeyword = (SyntaxToken)this.Visit(node.DoKeyword);
      var statement = (StatementSyntax)this.Visit(node.Statement);
      var whileKeyword = (SyntaxToken)this.Visit(node.WhileKeyword);
      var openParenToken = (SyntaxToken)this.Visit(node.OpenParenToken);
      var condition = (ExpressionSyntax)this.Visit(node.Condition);
      var closeParenToken = (SyntaxToken)this.Visit(node.CloseParenToken);
      var semicolonToken = (SyntaxToken)this.Visit(node.SemicolonToken);
      return node.Update(doKeyword, statement, whileKeyword, openParenToken, condition, closeParenToken, semicolonToken);
    }

    public override CSharpSyntaxNode VisitForStatement(ForStatementSyntax node)
    {
      var forKeyword = (SyntaxToken)this.Visit(node.ForKeyword);
      var openParenToken = (SyntaxToken)this.Visit(node.OpenParenToken);
      var declaration = (VariableDeclarationSyntax)this.Visit(node.Declaration);
      var initializers = this.VisitList(node.Initializers);
      var firstSemicolonToken = (SyntaxToken)this.Visit(node.FirstSemicolonToken);
      var condition = (ExpressionSyntax)this.Visit(node.Condition);
      var secondSemicolonToken = (SyntaxToken)this.Visit(node.SecondSemicolonToken);
      var incrementors = this.VisitList(node.Incrementors);
      var closeParenToken = (SyntaxToken)this.Visit(node.CloseParenToken);
      var statement = (StatementSyntax)this.Visit(node.Statement);
      return node.Update(forKeyword, openParenToken, declaration, initializers, firstSemicolonToken, condition, secondSemicolonToken, incrementors, closeParenToken, statement);
    }

    public override CSharpSyntaxNode VisitForEachStatement(ForEachStatementSyntax node)
    {
      var forEachKeyword = (SyntaxToken)this.Visit(node.ForEachKeyword);
      var openParenToken = (SyntaxToken)this.Visit(node.OpenParenToken);
      var type = (TypeSyntax)this.Visit(node.Type);
      var identifier = (SyntaxToken)this.Visit(node.Identifier);
      var inKeyword = (SyntaxToken)this.Visit(node.InKeyword);
      var expression = (ExpressionSyntax)this.Visit(node.Expression);
      var closeParenToken = (SyntaxToken)this.Visit(node.CloseParenToken);
      var statement = (StatementSyntax)this.Visit(node.Statement);
      return node.Update(forEachKeyword, openParenToken, type, identifier, inKeyword, expression, closeParenToken, statement);
    }

    public override CSharpSyntaxNode VisitForEachVariableStatement(ForEachVariableStatementSyntax node)
    {
      var forEachKeyword = (SyntaxToken)this.Visit(node.ForEachKeyword);
      var openParenToken = (SyntaxToken)this.Visit(node.OpenParenToken);
      var variable = (ExpressionSyntax)this.Visit(node.Variable);
      var inKeyword = (SyntaxToken)this.Visit(node.InKeyword);
      var expression = (ExpressionSyntax)this.Visit(node.Expression);
      var closeParenToken = (SyntaxToken)this.Visit(node.CloseParenToken);
      var statement = (StatementSyntax)this.Visit(node.Statement);
      return node.Update(forEachKeyword, openParenToken, variable, inKeyword, expression, closeParenToken, statement);
    }

    public override CSharpSyntaxNode VisitUsingStatement(UsingStatementSyntax node)
    {
      var usingKeyword = (SyntaxToken)this.Visit(node.UsingKeyword);
      var openParenToken = (SyntaxToken)this.Visit(node.OpenParenToken);
      var declaration = (VariableDeclarationSyntax)this.Visit(node.Declaration);
      var expression = (ExpressionSyntax)this.Visit(node.Expression);
      var closeParenToken = (SyntaxToken)this.Visit(node.CloseParenToken);
      var statement = (StatementSyntax)this.Visit(node.Statement);
      return node.Update(usingKeyword, openParenToken, declaration, expression, closeParenToken, statement);
    }

    public override CSharpSyntaxNode VisitFixedStatement(FixedStatementSyntax node)
    {
      var fixedKeyword = (SyntaxToken)this.Visit(node.FixedKeyword);
      var openParenToken = (SyntaxToken)this.Visit(node.OpenParenToken);
      var declaration = (VariableDeclarationSyntax)this.Visit(node.Declaration);
      var closeParenToken = (SyntaxToken)this.Visit(node.CloseParenToken);
      var statement = (StatementSyntax)this.Visit(node.Statement);
      return node.Update(fixedKeyword, openParenToken, declaration, closeParenToken, statement);
    }

    public override CSharpSyntaxNode VisitCheckedStatement(CheckedStatementSyntax node)
    {
      var keyword = (SyntaxToken)this.Visit(node.Keyword);
      var block = (BlockSyntax)this.Visit(node.Block);
      return node.Update(keyword, block);
    }

    public override CSharpSyntaxNode VisitUnsafeStatement(UnsafeStatementSyntax node)
    {
      var unsafeKeyword = (SyntaxToken)this.Visit(node.UnsafeKeyword);
      var block = (BlockSyntax)this.Visit(node.Block);
      return node.Update(unsafeKeyword, block);
    }

    public override CSharpSyntaxNode VisitLockStatement(LockStatementSyntax node)
    {
      var lockKeyword = (SyntaxToken)this.Visit(node.LockKeyword);
      var openParenToken = (SyntaxToken)this.Visit(node.OpenParenToken);
      var expression = (ExpressionSyntax)this.Visit(node.Expression);
      var closeParenToken = (SyntaxToken)this.Visit(node.CloseParenToken);
      var statement = (StatementSyntax)this.Visit(node.Statement);
      return node.Update(lockKeyword, openParenToken, expression, closeParenToken, statement);
    }

    public override CSharpSyntaxNode VisitIfStatement(IfStatementSyntax node)
    {
      var ifKeyword = (SyntaxToken)this.Visit(node.IfKeyword);
      var openParenToken = (SyntaxToken)this.Visit(node.OpenParenToken);
      var condition = (ExpressionSyntax)this.Visit(node.Condition);
      var closeParenToken = (SyntaxToken)this.Visit(node.CloseParenToken);
      var statement = (StatementSyntax)this.Visit(node.Statement);
      var @else = (ElseClauseSyntax)this.Visit(node.Else);
      return node.Update(ifKeyword, openParenToken, condition, closeParenToken, statement, @else);
    }

    public override CSharpSyntaxNode VisitElseClause(ElseClauseSyntax node)
    {
      var elseKeyword = (SyntaxToken)this.Visit(node.ElseKeyword);
      var statement = (StatementSyntax)this.Visit(node.Statement);
      return node.Update(elseKeyword, statement);
    }

    public override CSharpSyntaxNode VisitSwitchStatement(SwitchStatementSyntax node)
    {
      var switchKeyword = (SyntaxToken)this.Visit(node.SwitchKeyword);
      var openParenToken = (SyntaxToken)this.Visit(node.OpenParenToken);
      var expression = (ExpressionSyntax)this.Visit(node.Expression);
      var closeParenToken = (SyntaxToken)this.Visit(node.CloseParenToken);
      var openBraceToken = (SyntaxToken)this.Visit(node.OpenBraceToken);
      var sections = this.VisitList(node.Sections);
      var closeBraceToken = (SyntaxToken)this.Visit(node.CloseBraceToken);
      return node.Update(switchKeyword, openParenToken, expression, closeParenToken, openBraceToken, sections, closeBraceToken);
    }

    public override CSharpSyntaxNode VisitSwitchSection(SwitchSectionSyntax node)
    {
      var labels = this.VisitList(node.Labels);
      var statements = this.VisitList(node.Statements);
      return node.Update(labels, statements);
    }

    public override CSharpSyntaxNode VisitCasePatternSwitchLabel(CasePatternSwitchLabelSyntax node)
    {
      var keyword = (SyntaxToken)this.Visit(node.Keyword);
      var pattern = (PatternSyntax)this.Visit(node.Pattern);
      var whenClause = (WhenClauseSyntax)this.Visit(node.WhenClause);
      var colonToken = (SyntaxToken)this.Visit(node.ColonToken);
      return node.Update(keyword, pattern, whenClause, colonToken);
    }

    public override CSharpSyntaxNode VisitCaseSwitchLabel(CaseSwitchLabelSyntax node)
    {
      var keyword = (SyntaxToken)this.Visit(node.Keyword);
      var value = (ExpressionSyntax)this.Visit(node.Value);
      var colonToken = (SyntaxToken)this.Visit(node.ColonToken);
      return node.Update(keyword, value, colonToken);
    }

    public override CSharpSyntaxNode VisitDefaultSwitchLabel(DefaultSwitchLabelSyntax node)
    {
      var keyword = (SyntaxToken)this.Visit(node.Keyword);
      var colonToken = (SyntaxToken)this.Visit(node.ColonToken);
      return node.Update(keyword, colonToken);
    }

    public override CSharpSyntaxNode VisitTryStatement(TryStatementSyntax node)
    {
      var tryKeyword = (SyntaxToken)this.Visit(node.TryKeyword);
      var block = (BlockSyntax)this.Visit(node.Block);
      var catches = this.VisitList(node.Catches);
      var @finally = (FinallyClauseSyntax)this.Visit(node.Finally);
      return node.Update(tryKeyword, block, catches, @finally);
    }

    public override CSharpSyntaxNode VisitCatchClause(CatchClauseSyntax node)
    {
      var catchKeyword = (SyntaxToken)this.Visit(node.CatchKeyword);
      var declaration = (CatchDeclarationSyntax)this.Visit(node.Declaration);
      var filter = (CatchFilterClauseSyntax)this.Visit(node.Filter);
      var block = (BlockSyntax)this.Visit(node.Block);
      return node.Update(catchKeyword, declaration, filter, block);
    }

    public override CSharpSyntaxNode VisitCatchDeclaration(CatchDeclarationSyntax node)
    {
      var openParenToken = (SyntaxToken)this.Visit(node.OpenParenToken);
      var type = (TypeSyntax)this.Visit(node.Type);
      var identifier = (SyntaxToken)this.Visit(node.Identifier);
      var closeParenToken = (SyntaxToken)this.Visit(node.CloseParenToken);
      return node.Update(openParenToken, type, identifier, closeParenToken);
    }

    public override CSharpSyntaxNode VisitCatchFilterClause(CatchFilterClauseSyntax node)
    {
      var whenKeyword = (SyntaxToken)this.Visit(node.WhenKeyword);
      var openParenToken = (SyntaxToken)this.Visit(node.OpenParenToken);
      var filterExpression = (ExpressionSyntax)this.Visit(node.FilterExpression);
      var closeParenToken = (SyntaxToken)this.Visit(node.CloseParenToken);
      return node.Update(whenKeyword, openParenToken, filterExpression, closeParenToken);
    }

    public override CSharpSyntaxNode VisitFinallyClause(FinallyClauseSyntax node)
    {
      var finallyKeyword = (SyntaxToken)this.Visit(node.FinallyKeyword);
      var block = (BlockSyntax)this.Visit(node.Block);
      return node.Update(finallyKeyword, block);
    }

    public override CSharpSyntaxNode VisitCompilationUnit(CompilationUnitSyntax node)
    {
      var externs = this.VisitList(node.Externs);
      var usings = this.VisitList(node.Usings);
      var attributeLists = this.VisitList(node.AttributeLists);
      var members = this.VisitList(node.Members);
      var endOfFileToken = (SyntaxToken)this.Visit(node.EndOfFileToken);
      return node.Update(externs, usings, attributeLists, members, endOfFileToken);
    }

    public override CSharpSyntaxNode VisitExternAliasDirective(ExternAliasDirectiveSyntax node)
    {
      var externKeyword = (SyntaxToken)this.Visit(node.ExternKeyword);
      var aliasKeyword = (SyntaxToken)this.Visit(node.AliasKeyword);
      var identifier = (SyntaxToken)this.Visit(node.Identifier);
      var semicolonToken = (SyntaxToken)this.Visit(node.SemicolonToken);
      return node.Update(externKeyword, aliasKeyword, identifier, semicolonToken);
    }

    public override CSharpSyntaxNode VisitUsingDirective(UsingDirectiveSyntax node)
    {
      var usingKeyword = (SyntaxToken)this.Visit(node.UsingKeyword);
      var staticKeyword = (SyntaxToken)this.Visit(node.StaticKeyword);
      var alias = (NameEqualsSyntax)this.Visit(node.Alias);
      var name = (NameSyntax)this.Visit(node.Name);
      var semicolonToken = (SyntaxToken)this.Visit(node.SemicolonToken);
      return node.Update(usingKeyword, staticKeyword, alias, name, semicolonToken);
    }

    public override CSharpSyntaxNode VisitNamespaceDeclaration(NamespaceDeclarationSyntax node)
    {
      var namespaceKeyword = (SyntaxToken)this.Visit(node.NamespaceKeyword);
      var name = (NameSyntax)this.Visit(node.Name);
      var openBraceToken = (SyntaxToken)this.Visit(node.OpenBraceToken);
      var externs = this.VisitList(node.Externs);
      var usings = this.VisitList(node.Usings);
      var members = this.VisitList(node.Members);
      var closeBraceToken = (SyntaxToken)this.Visit(node.CloseBraceToken);
      var semicolonToken = (SyntaxToken)this.Visit(node.SemicolonToken);
      return node.Update(namespaceKeyword, name, openBraceToken, externs, usings, members, closeBraceToken, semicolonToken);
    }

    public override CSharpSyntaxNode VisitAttributeList(AttributeListSyntax node)
    {
      var openBracketToken = (SyntaxToken)this.Visit(node.OpenBracketToken);
      var target = (AttributeTargetSpecifierSyntax)this.Visit(node.Target);
      var attributes = this.VisitList(node.Attributes);
      var closeBracketToken = (SyntaxToken)this.Visit(node.CloseBracketToken);
      return node.Update(openBracketToken, target, attributes, closeBracketToken);
    }

    public override CSharpSyntaxNode VisitAttributeTargetSpecifier(AttributeTargetSpecifierSyntax node)
    {
      var identifier = (SyntaxToken)this.Visit(node.Identifier);
      var colonToken = (SyntaxToken)this.Visit(node.ColonToken);
      return node.Update(identifier, colonToken);
    }

    public override CSharpSyntaxNode VisitAttribute(AttributeSyntax node)
    {
      var name = (NameSyntax)this.Visit(node.Name);
      var argumentList = (AttributeArgumentListSyntax)this.Visit(node.ArgumentList);
      return node.Update(name, argumentList);
    }

    public override CSharpSyntaxNode VisitAttributeArgumentList(AttributeArgumentListSyntax node)
    {
      var openParenToken = (SyntaxToken)this.Visit(node.OpenParenToken);
      var arguments = this.VisitList(node.Arguments);
      var closeParenToken = (SyntaxToken)this.Visit(node.CloseParenToken);
      return node.Update(openParenToken, arguments, closeParenToken);
    }

    public override CSharpSyntaxNode VisitAttributeArgument(AttributeArgumentSyntax node)
    {
      var nameEquals = (NameEqualsSyntax)this.Visit(node.NameEquals);
      var nameColon = (NameColonSyntax)this.Visit(node.NameColon);
      var expression = (ExpressionSyntax)this.Visit(node.Expression);
      return node.Update(nameEquals, nameColon, expression);
    }

    public override CSharpSyntaxNode VisitNameEquals(NameEqualsSyntax node)
    {
      var name = (IdentifierNameSyntax)this.Visit(node.Name);
      var equalsToken = (SyntaxToken)this.Visit(node.EqualsToken);
      return node.Update(name, equalsToken);
    }

    public override CSharpSyntaxNode VisitTypeParameterList(TypeParameterListSyntax node)
    {
      var lessThanToken = (SyntaxToken)this.Visit(node.LessThanToken);
      var parameters = this.VisitList(node.Parameters);
      var greaterThanToken = (SyntaxToken)this.Visit(node.GreaterThanToken);
      return node.Update(lessThanToken, parameters, greaterThanToken);
    }

    public override CSharpSyntaxNode VisitTypeParameter(TypeParameterSyntax node)
    {
      var attributeLists = this.VisitList(node.AttributeLists);
      var varianceKeyword = (SyntaxToken)this.Visit(node.VarianceKeyword);
      var identifier = (SyntaxToken)this.Visit(node.Identifier);
      return node.Update(attributeLists, varianceKeyword, identifier);
    }

    public override CSharpSyntaxNode VisitClassDeclaration(ClassDeclarationSyntax node)
    {
      var attributeLists = this.VisitList(node.AttributeLists);
      var modifiers = this.VisitList(node.Modifiers);
      var keyword = (SyntaxToken)this.Visit(node.Keyword);
      var identifier = (SyntaxToken)this.Visit(node.Identifier);
      var typeParameterList = (TypeParameterListSyntax)this.Visit(node.TypeParameterList);
      var baseList = (BaseListSyntax)this.Visit(node.BaseList);
      var constraintClauses = this.VisitList(node.ConstraintClauses);
      var openBraceToken = (SyntaxToken)this.Visit(node.OpenBraceToken);
      var members = this.VisitList(node.Members);
      var closeBraceToken = (SyntaxToken)this.Visit(node.CloseBraceToken);
      var semicolonToken = (SyntaxToken)this.Visit(node.SemicolonToken);
      return node.Update(attributeLists, modifiers, keyword, identifier, typeParameterList, baseList, constraintClauses, openBraceToken, members, closeBraceToken, semicolonToken);
    }

    public override CSharpSyntaxNode VisitStructDeclaration(StructDeclarationSyntax node)
    {
      var attributeLists = this.VisitList(node.AttributeLists);
      var modifiers = this.VisitList(node.Modifiers);
      var keyword = (SyntaxToken)this.Visit(node.Keyword);
      var identifier = (SyntaxToken)this.Visit(node.Identifier);
      var typeParameterList = (TypeParameterListSyntax)this.Visit(node.TypeParameterList);
      var baseList = (BaseListSyntax)this.Visit(node.BaseList);
      var constraintClauses = this.VisitList(node.ConstraintClauses);
      var openBraceToken = (SyntaxToken)this.Visit(node.OpenBraceToken);
      var members = this.VisitList(node.Members);
      var closeBraceToken = (SyntaxToken)this.Visit(node.CloseBraceToken);
      var semicolonToken = (SyntaxToken)this.Visit(node.SemicolonToken);
      return node.Update(attributeLists, modifiers, keyword, identifier, typeParameterList, baseList, constraintClauses, openBraceToken, members, closeBraceToken, semicolonToken);
    }

    public override CSharpSyntaxNode VisitInterfaceDeclaration(InterfaceDeclarationSyntax node)
    {
      var attributeLists = this.VisitList(node.AttributeLists);
      var modifiers = this.VisitList(node.Modifiers);
      var keyword = (SyntaxToken)this.Visit(node.Keyword);
      var identifier = (SyntaxToken)this.Visit(node.Identifier);
      var typeParameterList = (TypeParameterListSyntax)this.Visit(node.TypeParameterList);
      var baseList = (BaseListSyntax)this.Visit(node.BaseList);
      var constraintClauses = this.VisitList(node.ConstraintClauses);
      var openBraceToken = (SyntaxToken)this.Visit(node.OpenBraceToken);
      var members = this.VisitList(node.Members);
      var closeBraceToken = (SyntaxToken)this.Visit(node.CloseBraceToken);
      var semicolonToken = (SyntaxToken)this.Visit(node.SemicolonToken);
      return node.Update(attributeLists, modifiers, keyword, identifier, typeParameterList, baseList, constraintClauses, openBraceToken, members, closeBraceToken, semicolonToken);
    }

    public override CSharpSyntaxNode VisitEnumDeclaration(EnumDeclarationSyntax node)
    {
      var attributeLists = this.VisitList(node.AttributeLists);
      var modifiers = this.VisitList(node.Modifiers);
      var enumKeyword = (SyntaxToken)this.Visit(node.EnumKeyword);
      var identifier = (SyntaxToken)this.Visit(node.Identifier);
      var baseList = (BaseListSyntax)this.Visit(node.BaseList);
      var openBraceToken = (SyntaxToken)this.Visit(node.OpenBraceToken);
      var members = this.VisitList(node.Members);
      var closeBraceToken = (SyntaxToken)this.Visit(node.CloseBraceToken);
      var semicolonToken = (SyntaxToken)this.Visit(node.SemicolonToken);
      return node.Update(attributeLists, modifiers, enumKeyword, identifier, baseList, openBraceToken, members, closeBraceToken, semicolonToken);
    }

    public override CSharpSyntaxNode VisitDelegateDeclaration(DelegateDeclarationSyntax node)
    {
      var attributeLists = this.VisitList(node.AttributeLists);
      var modifiers = this.VisitList(node.Modifiers);
      var delegateKeyword = (SyntaxToken)this.Visit(node.DelegateKeyword);
      var returnType = (TypeSyntax)this.Visit(node.ReturnType);
      var identifier = (SyntaxToken)this.Visit(node.Identifier);
      var typeParameterList = (TypeParameterListSyntax)this.Visit(node.TypeParameterList);
      var parameterList = (ParameterListSyntax)this.Visit(node.ParameterList);
      var constraintClauses = this.VisitList(node.ConstraintClauses);
      var semicolonToken = (SyntaxToken)this.Visit(node.SemicolonToken);
      return node.Update(attributeLists, modifiers, delegateKeyword, returnType, identifier, typeParameterList, parameterList, constraintClauses, semicolonToken);
    }

    public override CSharpSyntaxNode VisitEnumMemberDeclaration(EnumMemberDeclarationSyntax node)
    {
      var attributeLists = this.VisitList(node.AttributeLists);
      var identifier = (SyntaxToken)this.Visit(node.Identifier);
      var equalsValue = (EqualsValueClauseSyntax)this.Visit(node.EqualsValue);
      return node.Update(attributeLists, identifier, equalsValue);
    }

    public override CSharpSyntaxNode VisitBaseList(BaseListSyntax node)
    {
      var colonToken = (SyntaxToken)this.Visit(node.ColonToken);
      var types = this.VisitList(node.Types);
      return node.Update(colonToken, types);
    }

    public override CSharpSyntaxNode VisitSimpleBaseType(SimpleBaseTypeSyntax node)
    {
      var type = (TypeSyntax)this.Visit(node.Type);
      return node.Update(type);
    }

    public override CSharpSyntaxNode VisitTypeParameterConstraintClause(TypeParameterConstraintClauseSyntax node)
    {
      var whereKeyword = (SyntaxToken)this.Visit(node.WhereKeyword);
      var name = (IdentifierNameSyntax)this.Visit(node.Name);
      var colonToken = (SyntaxToken)this.Visit(node.ColonToken);
      var constraints = this.VisitList(node.Constraints);
      return node.Update(whereKeyword, name, colonToken, constraints);
    }

    public override CSharpSyntaxNode VisitConstructorConstraint(ConstructorConstraintSyntax node)
    {
      var newKeyword = (SyntaxToken)this.Visit(node.NewKeyword);
      var openParenToken = (SyntaxToken)this.Visit(node.OpenParenToken);
      var closeParenToken = (SyntaxToken)this.Visit(node.CloseParenToken);
      return node.Update(newKeyword, openParenToken, closeParenToken);
    }

    public override CSharpSyntaxNode VisitClassOrStructConstraint(ClassOrStructConstraintSyntax node)
    {
      var classOrStructKeyword = (SyntaxToken)this.Visit(node.ClassOrStructKeyword);
      return node.Update(classOrStructKeyword);
    }

    public override CSharpSyntaxNode VisitTypeConstraint(TypeConstraintSyntax node)
    {
      var type = (TypeSyntax)this.Visit(node.Type);
      return node.Update(type);
    }

    public override CSharpSyntaxNode VisitFieldDeclaration(FieldDeclarationSyntax node)
    {
      var attributeLists = this.VisitList(node.AttributeLists);
      var modifiers = this.VisitList(node.Modifiers);
      var declaration = (VariableDeclarationSyntax)this.Visit(node.Declaration);
      var semicolonToken = (SyntaxToken)this.Visit(node.SemicolonToken);
      return node.Update(attributeLists, modifiers, declaration, semicolonToken);
    }

    public override CSharpSyntaxNode VisitEventFieldDeclaration(EventFieldDeclarationSyntax node)
    {
      var attributeLists = this.VisitList(node.AttributeLists);
      var modifiers = this.VisitList(node.Modifiers);
      var eventKeyword = (SyntaxToken)this.Visit(node.EventKeyword);
      var declaration = (VariableDeclarationSyntax)this.Visit(node.Declaration);
      var semicolonToken = (SyntaxToken)this.Visit(node.SemicolonToken);
      return node.Update(attributeLists, modifiers, eventKeyword, declaration, semicolonToken);
    }

    public override CSharpSyntaxNode VisitExplicitInterfaceSpecifier(ExplicitInterfaceSpecifierSyntax node)
    {
      var name = (NameSyntax)this.Visit(node.Name);
      var dotToken = (SyntaxToken)this.Visit(node.DotToken);
      return node.Update(name, dotToken);
    }

    public override CSharpSyntaxNode VisitMethodDeclaration(MethodDeclarationSyntax node)
    {
      var attributeLists = this.VisitList(node.AttributeLists);
      var modifiers = this.VisitList(node.Modifiers);
      var returnType = (TypeSyntax)this.Visit(node.ReturnType);
      var explicitInterfaceSpecifier = (ExplicitInterfaceSpecifierSyntax)this.Visit(node.ExplicitInterfaceSpecifier);
      var identifier = (SyntaxToken)this.Visit(node.Identifier);
      var typeParameterList = (TypeParameterListSyntax)this.Visit(node.TypeParameterList);
      var parameterList = (ParameterListSyntax)this.Visit(node.ParameterList);
      var constraintClauses = this.VisitList(node.ConstraintClauses);
      var body = (BlockSyntax)this.Visit(node.Body);
      var expressionBody = (ArrowExpressionClauseSyntax)this.Visit(node.ExpressionBody);
      var semicolonToken = (SyntaxToken)this.Visit(node.SemicolonToken);
      return node.Update(attributeLists, modifiers, returnType, explicitInterfaceSpecifier, identifier, typeParameterList, parameterList, constraintClauses, body, expressionBody, semicolonToken);
    }

    public override CSharpSyntaxNode VisitOperatorDeclaration(OperatorDeclarationSyntax node)
    {
      var attributeLists = this.VisitList(node.AttributeLists);
      var modifiers = this.VisitList(node.Modifiers);
      var returnType = (TypeSyntax)this.Visit(node.ReturnType);
      var operatorKeyword = (SyntaxToken)this.Visit(node.OperatorKeyword);
      var operatorToken = (SyntaxToken)this.Visit(node.OperatorToken);
      var parameterList = (ParameterListSyntax)this.Visit(node.ParameterList);
      var body = (BlockSyntax)this.Visit(node.Body);
      var expressionBody = (ArrowExpressionClauseSyntax)this.Visit(node.ExpressionBody);
      var semicolonToken = (SyntaxToken)this.Visit(node.SemicolonToken);
      return node.Update(attributeLists, modifiers, returnType, operatorKeyword, operatorToken, parameterList, body, expressionBody, semicolonToken);
    }

    public override CSharpSyntaxNode VisitConversionOperatorDeclaration(ConversionOperatorDeclarationSyntax node)
    {
      var attributeLists = this.VisitList(node.AttributeLists);
      var modifiers = this.VisitList(node.Modifiers);
      var implicitOrExplicitKeyword = (SyntaxToken)this.Visit(node.ImplicitOrExplicitKeyword);
      var operatorKeyword = (SyntaxToken)this.Visit(node.OperatorKeyword);
      var type = (TypeSyntax)this.Visit(node.Type);
      var parameterList = (ParameterListSyntax)this.Visit(node.ParameterList);
      var body = (BlockSyntax)this.Visit(node.Body);
      var expressionBody = (ArrowExpressionClauseSyntax)this.Visit(node.ExpressionBody);
      var semicolonToken = (SyntaxToken)this.Visit(node.SemicolonToken);
      return node.Update(attributeLists, modifiers, implicitOrExplicitKeyword, operatorKeyword, type, parameterList, body, expressionBody, semicolonToken);
    }

    public override CSharpSyntaxNode VisitConstructorDeclaration(ConstructorDeclarationSyntax node)
    {
      var attributeLists = this.VisitList(node.AttributeLists);
      var modifiers = this.VisitList(node.Modifiers);
      var identifier = (SyntaxToken)this.Visit(node.Identifier);
      var parameterList = (ParameterListSyntax)this.Visit(node.ParameterList);
      var initializer = (ConstructorInitializerSyntax)this.Visit(node.Initializer);
      var body = (BlockSyntax)this.Visit(node.Body);
      var expressionBody = (ArrowExpressionClauseSyntax)this.Visit(node.ExpressionBody);
      var semicolonToken = (SyntaxToken)this.Visit(node.SemicolonToken);
      return node.Update(attributeLists, modifiers, identifier, parameterList, initializer, body, expressionBody, semicolonToken);
    }

    public override CSharpSyntaxNode VisitConstructorInitializer(ConstructorInitializerSyntax node)
    {
      var colonToken = (SyntaxToken)this.Visit(node.ColonToken);
      var thisOrBaseKeyword = (SyntaxToken)this.Visit(node.ThisOrBaseKeyword);
      var argumentList = (ArgumentListSyntax)this.Visit(node.ArgumentList);
      return node.Update(colonToken, thisOrBaseKeyword, argumentList);
    }

    public override CSharpSyntaxNode VisitDestructorDeclaration(DestructorDeclarationSyntax node)
    {
      var attributeLists = this.VisitList(node.AttributeLists);
      var modifiers = this.VisitList(node.Modifiers);
      var tildeToken = (SyntaxToken)this.Visit(node.TildeToken);
      var identifier = (SyntaxToken)this.Visit(node.Identifier);
      var parameterList = (ParameterListSyntax)this.Visit(node.ParameterList);
      var body = (BlockSyntax)this.Visit(node.Body);
      var expressionBody = (ArrowExpressionClauseSyntax)this.Visit(node.ExpressionBody);
      var semicolonToken = (SyntaxToken)this.Visit(node.SemicolonToken);
      return node.Update(attributeLists, modifiers, tildeToken, identifier, parameterList, body, expressionBody, semicolonToken);
    }

    public override CSharpSyntaxNode VisitPropertyDeclaration(PropertyDeclarationSyntax node)
    {
      var attributeLists = this.VisitList(node.AttributeLists);
      var modifiers = this.VisitList(node.Modifiers);
      var type = (TypeSyntax)this.Visit(node.Type);
      var explicitInterfaceSpecifier = (ExplicitInterfaceSpecifierSyntax)this.Visit(node.ExplicitInterfaceSpecifier);
      var identifier = (SyntaxToken)this.Visit(node.Identifier);
      var accessorList = (AccessorListSyntax)this.Visit(node.AccessorList);
      var expressionBody = (ArrowExpressionClauseSyntax)this.Visit(node.ExpressionBody);
      var initializer = (EqualsValueClauseSyntax)this.Visit(node.Initializer);
      var semicolonToken = (SyntaxToken)this.Visit(node.SemicolonToken);
      return node.Update(attributeLists, modifiers, type, explicitInterfaceSpecifier, identifier, accessorList, expressionBody, initializer, semicolonToken);
    }

    public override CSharpSyntaxNode VisitArrowExpressionClause(ArrowExpressionClauseSyntax node)
    {
      var arrowToken = (SyntaxToken)this.Visit(node.ArrowToken);
      var expression = (ExpressionSyntax)this.Visit(node.Expression);
      return node.Update(arrowToken, expression);
    }

    public override CSharpSyntaxNode VisitEventDeclaration(EventDeclarationSyntax node)
    {
      var attributeLists = this.VisitList(node.AttributeLists);
      var modifiers = this.VisitList(node.Modifiers);
      var eventKeyword = (SyntaxToken)this.Visit(node.EventKeyword);
      var type = (TypeSyntax)this.Visit(node.Type);
      var explicitInterfaceSpecifier = (ExplicitInterfaceSpecifierSyntax)this.Visit(node.ExplicitInterfaceSpecifier);
      var identifier = (SyntaxToken)this.Visit(node.Identifier);
      var accessorList = (AccessorListSyntax)this.Visit(node.AccessorList);
      return node.Update(attributeLists, modifiers, eventKeyword, type, explicitInterfaceSpecifier, identifier, accessorList);
    }

    public override CSharpSyntaxNode VisitIndexerDeclaration(IndexerDeclarationSyntax node)
    {
      var attributeLists = this.VisitList(node.AttributeLists);
      var modifiers = this.VisitList(node.Modifiers);
      var type = (TypeSyntax)this.Visit(node.Type);
      var explicitInterfaceSpecifier = (ExplicitInterfaceSpecifierSyntax)this.Visit(node.ExplicitInterfaceSpecifier);
      var thisKeyword = (SyntaxToken)this.Visit(node.ThisKeyword);
      var parameterList = (BracketedParameterListSyntax)this.Visit(node.ParameterList);
      var accessorList = (AccessorListSyntax)this.Visit(node.AccessorList);
      var expressionBody = (ArrowExpressionClauseSyntax)this.Visit(node.ExpressionBody);
      var semicolonToken = (SyntaxToken)this.Visit(node.SemicolonToken);
      return node.Update(attributeLists, modifiers, type, explicitInterfaceSpecifier, thisKeyword, parameterList, accessorList, expressionBody, semicolonToken);
    }

    public override CSharpSyntaxNode VisitAccessorList(AccessorListSyntax node)
    {
      var openBraceToken = (SyntaxToken)this.Visit(node.OpenBraceToken);
      var accessors = this.VisitList(node.Accessors);
      var closeBraceToken = (SyntaxToken)this.Visit(node.CloseBraceToken);
      return node.Update(openBraceToken, accessors, closeBraceToken);
    }

    public override CSharpSyntaxNode VisitAccessorDeclaration(AccessorDeclarationSyntax node)
    {
      var attributeLists = this.VisitList(node.AttributeLists);
      var modifiers = this.VisitList(node.Modifiers);
      var keyword = (SyntaxToken)this.Visit(node.Keyword);
      var body = (BlockSyntax)this.Visit(node.Body);
      var expressionBody = (ArrowExpressionClauseSyntax)this.Visit(node.ExpressionBody);
      var semicolonToken = (SyntaxToken)this.Visit(node.SemicolonToken);
      return node.Update(attributeLists, modifiers, keyword, body, expressionBody, semicolonToken);
    }

    public override CSharpSyntaxNode VisitParameterList(ParameterListSyntax node)
    {
      var openParenToken = (SyntaxToken)this.Visit(node.OpenParenToken);
      var parameters = this.VisitList(node.Parameters);
      var closeParenToken = (SyntaxToken)this.Visit(node.CloseParenToken);
      return node.Update(openParenToken, parameters, closeParenToken);
    }

    public override CSharpSyntaxNode VisitBracketedParameterList(BracketedParameterListSyntax node)
    {
      var openBracketToken = (SyntaxToken)this.Visit(node.OpenBracketToken);
      var parameters = this.VisitList(node.Parameters);
      var closeBracketToken = (SyntaxToken)this.Visit(node.CloseBracketToken);
      return node.Update(openBracketToken, parameters, closeBracketToken);
    }

    public override CSharpSyntaxNode VisitParameter(ParameterSyntax node)
    {
      var attributeLists = this.VisitList(node.AttributeLists);
      var modifiers = this.VisitList(node.Modifiers);
      var type = (TypeSyntax)this.Visit(node.Type);
      var identifier = (SyntaxToken)this.Visit(node.Identifier);
      var @default = (EqualsValueClauseSyntax)this.Visit(node.Default);
      return node.Update(attributeLists, modifiers, type, identifier, @default);
    }

    public override CSharpSyntaxNode VisitIncompleteMember(IncompleteMemberSyntax node)
    {
      var attributeLists = this.VisitList(node.AttributeLists);
      var modifiers = this.VisitList(node.Modifiers);
      var type = (TypeSyntax)this.Visit(node.Type);
      return node.Update(attributeLists, modifiers, type);
    }

    public override CSharpSyntaxNode VisitSkippedTokensTrivia(SkippedTokensTriviaSyntax node)
    {
      var tokens = this.VisitList(node.Tokens);
      return node.Update(tokens);
    }

    public override CSharpSyntaxNode VisitDocumentationCommentTrivia(DocumentationCommentTriviaSyntax node)
    {
      var content = this.VisitList(node.Content);
      var endOfComment = (SyntaxToken)this.Visit(node.EndOfComment);
      return node.Update(content, endOfComment);
    }

    public override CSharpSyntaxNode VisitTypeCref(TypeCrefSyntax node)
    {
      var type = (TypeSyntax)this.Visit(node.Type);
      return node.Update(type);
    }

    public override CSharpSyntaxNode VisitQualifiedCref(QualifiedCrefSyntax node)
    {
      var container = (TypeSyntax)this.Visit(node.Container);
      var dotToken = (SyntaxToken)this.Visit(node.DotToken);
      var member = (MemberCrefSyntax)this.Visit(node.Member);
      return node.Update(container, dotToken, member);
    }

    public override CSharpSyntaxNode VisitNameMemberCref(NameMemberCrefSyntax node)
    {
      var name = (TypeSyntax)this.Visit(node.Name);
      var parameters = (CrefParameterListSyntax)this.Visit(node.Parameters);
      return node.Update(name, parameters);
    }

    public override CSharpSyntaxNode VisitIndexerMemberCref(IndexerMemberCrefSyntax node)
    {
      var thisKeyword = (SyntaxToken)this.Visit(node.ThisKeyword);
      var parameters = (CrefBracketedParameterListSyntax)this.Visit(node.Parameters);
      return node.Update(thisKeyword, parameters);
    }

    public override CSharpSyntaxNode VisitOperatorMemberCref(OperatorMemberCrefSyntax node)
    {
      var operatorKeyword = (SyntaxToken)this.Visit(node.OperatorKeyword);
      var operatorToken = (SyntaxToken)this.Visit(node.OperatorToken);
      var parameters = (CrefParameterListSyntax)this.Visit(node.Parameters);
      return node.Update(operatorKeyword, operatorToken, parameters);
    }

    public override CSharpSyntaxNode VisitConversionOperatorMemberCref(ConversionOperatorMemberCrefSyntax node)
    {
      var implicitOrExplicitKeyword = (SyntaxToken)this.Visit(node.ImplicitOrExplicitKeyword);
      var operatorKeyword = (SyntaxToken)this.Visit(node.OperatorKeyword);
      var type = (TypeSyntax)this.Visit(node.Type);
      var parameters = (CrefParameterListSyntax)this.Visit(node.Parameters);
      return node.Update(implicitOrExplicitKeyword, operatorKeyword, type, parameters);
    }

    public override CSharpSyntaxNode VisitCrefParameterList(CrefParameterListSyntax node)
    {
      var openParenToken = (SyntaxToken)this.Visit(node.OpenParenToken);
      var parameters = this.VisitList(node.Parameters);
      var closeParenToken = (SyntaxToken)this.Visit(node.CloseParenToken);
      return node.Update(openParenToken, parameters, closeParenToken);
    }

    public override CSharpSyntaxNode VisitCrefBracketedParameterList(CrefBracketedParameterListSyntax node)
    {
      var openBracketToken = (SyntaxToken)this.Visit(node.OpenBracketToken);
      var parameters = this.VisitList(node.Parameters);
      var closeBracketToken = (SyntaxToken)this.Visit(node.CloseBracketToken);
      return node.Update(openBracketToken, parameters, closeBracketToken);
    }

    public override CSharpSyntaxNode VisitCrefParameter(CrefParameterSyntax node)
    {
      var refOrOutKeyword = (SyntaxToken)this.Visit(node.RefOrOutKeyword);
      var type = (TypeSyntax)this.Visit(node.Type);
      return node.Update(refOrOutKeyword, type);
    }

    public override CSharpSyntaxNode VisitXmlElement(XmlElementSyntax node)
    {
      var startTag = (XmlElementStartTagSyntax)this.Visit(node.StartTag);
      var content = this.VisitList(node.Content);
      var endTag = (XmlElementEndTagSyntax)this.Visit(node.EndTag);
      return node.Update(startTag, content, endTag);
    }

    public override CSharpSyntaxNode VisitXmlElementStartTag(XmlElementStartTagSyntax node)
    {
      var lessThanToken = (SyntaxToken)this.Visit(node.LessThanToken);
      var name = (XmlNameSyntax)this.Visit(node.Name);
      var attributes = this.VisitList(node.Attributes);
      var greaterThanToken = (SyntaxToken)this.Visit(node.GreaterThanToken);
      return node.Update(lessThanToken, name, attributes, greaterThanToken);
    }

    public override CSharpSyntaxNode VisitXmlElementEndTag(XmlElementEndTagSyntax node)
    {
      var lessThanSlashToken = (SyntaxToken)this.Visit(node.LessThanSlashToken);
      var name = (XmlNameSyntax)this.Visit(node.Name);
      var greaterThanToken = (SyntaxToken)this.Visit(node.GreaterThanToken);
      return node.Update(lessThanSlashToken, name, greaterThanToken);
    }

    public override CSharpSyntaxNode VisitXmlEmptyElement(XmlEmptyElementSyntax node)
    {
      var lessThanToken = (SyntaxToken)this.Visit(node.LessThanToken);
      var name = (XmlNameSyntax)this.Visit(node.Name);
      var attributes = this.VisitList(node.Attributes);
      var slashGreaterThanToken = (SyntaxToken)this.Visit(node.SlashGreaterThanToken);
      return node.Update(lessThanToken, name, attributes, slashGreaterThanToken);
    }

    public override CSharpSyntaxNode VisitXmlName(XmlNameSyntax node)
    {
      var prefix = (XmlPrefixSyntax)this.Visit(node.Prefix);
      var localName = (SyntaxToken)this.Visit(node.LocalName);
      return node.Update(prefix, localName);
    }

    public override CSharpSyntaxNode VisitXmlPrefix(XmlPrefixSyntax node)
    {
      var prefix = (SyntaxToken)this.Visit(node.Prefix);
      var colonToken = (SyntaxToken)this.Visit(node.ColonToken);
      return node.Update(prefix, colonToken);
    }

    public override CSharpSyntaxNode VisitXmlTextAttribute(XmlTextAttributeSyntax node)
    {
      var name = (XmlNameSyntax)this.Visit(node.Name);
      var equalsToken = (SyntaxToken)this.Visit(node.EqualsToken);
      var startQuoteToken = (SyntaxToken)this.Visit(node.StartQuoteToken);
      var textTokens = this.VisitList(node.TextTokens);
      var endQuoteToken = (SyntaxToken)this.Visit(node.EndQuoteToken);
      return node.Update(name, equalsToken, startQuoteToken, textTokens, endQuoteToken);
    }

    public override CSharpSyntaxNode VisitXmlCrefAttribute(XmlCrefAttributeSyntax node)
    {
      var name = (XmlNameSyntax)this.Visit(node.Name);
      var equalsToken = (SyntaxToken)this.Visit(node.EqualsToken);
      var startQuoteToken = (SyntaxToken)this.Visit(node.StartQuoteToken);
      var cref = (CrefSyntax)this.Visit(node.Cref);
      var endQuoteToken = (SyntaxToken)this.Visit(node.EndQuoteToken);
      return node.Update(name, equalsToken, startQuoteToken, cref, endQuoteToken);
    }

    public override CSharpSyntaxNode VisitXmlNameAttribute(XmlNameAttributeSyntax node)
    {
      var name = (XmlNameSyntax)this.Visit(node.Name);
      var equalsToken = (SyntaxToken)this.Visit(node.EqualsToken);
      var startQuoteToken = (SyntaxToken)this.Visit(node.StartQuoteToken);
      var identifier = (IdentifierNameSyntax)this.Visit(node.Identifier);
      var endQuoteToken = (SyntaxToken)this.Visit(node.EndQuoteToken);
      return node.Update(name, equalsToken, startQuoteToken, identifier, endQuoteToken);
    }

    public override CSharpSyntaxNode VisitXmlText(XmlTextSyntax node)
    {
      var textTokens = this.VisitList(node.TextTokens);
      return node.Update(textTokens);
    }

    public override CSharpSyntaxNode VisitXmlCDataSection(XmlCDataSectionSyntax node)
    {
      var startCDataToken = (SyntaxToken)this.Visit(node.StartCDataToken);
      var textTokens = this.VisitList(node.TextTokens);
      var endCDataToken = (SyntaxToken)this.Visit(node.EndCDataToken);
      return node.Update(startCDataToken, textTokens, endCDataToken);
    }

    public override CSharpSyntaxNode VisitXmlProcessingInstruction(XmlProcessingInstructionSyntax node)
    {
      var startProcessingInstructionToken = (SyntaxToken)this.Visit(node.StartProcessingInstructionToken);
      var name = (XmlNameSyntax)this.Visit(node.Name);
      var textTokens = this.VisitList(node.TextTokens);
      var endProcessingInstructionToken = (SyntaxToken)this.Visit(node.EndProcessingInstructionToken);
      return node.Update(startProcessingInstructionToken, name, textTokens, endProcessingInstructionToken);
    }

    public override CSharpSyntaxNode VisitXmlComment(XmlCommentSyntax node)
    {
      var lessThanExclamationMinusMinusToken = (SyntaxToken)this.Visit(node.LessThanExclamationMinusMinusToken);
      var textTokens = this.VisitList(node.TextTokens);
      var minusMinusGreaterThanToken = (SyntaxToken)this.Visit(node.MinusMinusGreaterThanToken);
      return node.Update(lessThanExclamationMinusMinusToken, textTokens, minusMinusGreaterThanToken);
    }

    public override CSharpSyntaxNode VisitIfDirectiveTrivia(IfDirectiveTriviaSyntax node)
    {
      var hashToken = (SyntaxToken)this.Visit(node.HashToken);
      var ifKeyword = (SyntaxToken)this.Visit(node.IfKeyword);
      var condition = (ExpressionSyntax)this.Visit(node.Condition);
      var endOfDirectiveToken = (SyntaxToken)this.Visit(node.EndOfDirectiveToken);
      return node.Update(hashToken, ifKeyword, condition, endOfDirectiveToken, node.IsActive, node.BranchTaken, node.ConditionValue);
    }

    public override CSharpSyntaxNode VisitElifDirectiveTrivia(ElifDirectiveTriviaSyntax node)
    {
      var hashToken = (SyntaxToken)this.Visit(node.HashToken);
      var elifKeyword = (SyntaxToken)this.Visit(node.ElifKeyword);
      var condition = (ExpressionSyntax)this.Visit(node.Condition);
      var endOfDirectiveToken = (SyntaxToken)this.Visit(node.EndOfDirectiveToken);
      return node.Update(hashToken, elifKeyword, condition, endOfDirectiveToken, node.IsActive, node.BranchTaken, node.ConditionValue);
    }

    public override CSharpSyntaxNode VisitElseDirectiveTrivia(ElseDirectiveTriviaSyntax node)
    {
      var hashToken = (SyntaxToken)this.Visit(node.HashToken);
      var elseKeyword = (SyntaxToken)this.Visit(node.ElseKeyword);
      var endOfDirectiveToken = (SyntaxToken)this.Visit(node.EndOfDirectiveToken);
      return node.Update(hashToken, elseKeyword, endOfDirectiveToken, node.IsActive, node.BranchTaken);
    }

    public override CSharpSyntaxNode VisitEndIfDirectiveTrivia(EndIfDirectiveTriviaSyntax node)
    {
      var hashToken = (SyntaxToken)this.Visit(node.HashToken);
      var endIfKeyword = (SyntaxToken)this.Visit(node.EndIfKeyword);
      var endOfDirectiveToken = (SyntaxToken)this.Visit(node.EndOfDirectiveToken);
      return node.Update(hashToken, endIfKeyword, endOfDirectiveToken, node.IsActive);
    }

    public override CSharpSyntaxNode VisitRegionDirectiveTrivia(RegionDirectiveTriviaSyntax node)
    {
      var hashToken = (SyntaxToken)this.Visit(node.HashToken);
      var regionKeyword = (SyntaxToken)this.Visit(node.RegionKeyword);
      var endOfDirectiveToken = (SyntaxToken)this.Visit(node.EndOfDirectiveToken);
      return node.Update(hashToken, regionKeyword, endOfDirectiveToken, node.IsActive);
    }

    public override CSharpSyntaxNode VisitEndRegionDirectiveTrivia(EndRegionDirectiveTriviaSyntax node)
    {
      var hashToken = (SyntaxToken)this.Visit(node.HashToken);
      var endRegionKeyword = (SyntaxToken)this.Visit(node.EndRegionKeyword);
      var endOfDirectiveToken = (SyntaxToken)this.Visit(node.EndOfDirectiveToken);
      return node.Update(hashToken, endRegionKeyword, endOfDirectiveToken, node.IsActive);
    }

    public override CSharpSyntaxNode VisitErrorDirectiveTrivia(ErrorDirectiveTriviaSyntax node)
    {
      var hashToken = (SyntaxToken)this.Visit(node.HashToken);
      var errorKeyword = (SyntaxToken)this.Visit(node.ErrorKeyword);
      var endOfDirectiveToken = (SyntaxToken)this.Visit(node.EndOfDirectiveToken);
      return node.Update(hashToken, errorKeyword, endOfDirectiveToken, node.IsActive);
    }

    public override CSharpSyntaxNode VisitWarningDirectiveTrivia(WarningDirectiveTriviaSyntax node)
    {
      var hashToken = (SyntaxToken)this.Visit(node.HashToken);
      var warningKeyword = (SyntaxToken)this.Visit(node.WarningKeyword);
      var endOfDirectiveToken = (SyntaxToken)this.Visit(node.EndOfDirectiveToken);
      return node.Update(hashToken, warningKeyword, endOfDirectiveToken, node.IsActive);
    }

    public override CSharpSyntaxNode VisitBadDirectiveTrivia(BadDirectiveTriviaSyntax node)
    {
      var hashToken = (SyntaxToken)this.Visit(node.HashToken);
      var identifier = (SyntaxToken)this.Visit(node.Identifier);
      var endOfDirectiveToken = (SyntaxToken)this.Visit(node.EndOfDirectiveToken);
      return node.Update(hashToken, identifier, endOfDirectiveToken, node.IsActive);
    }

    public override CSharpSyntaxNode VisitDefineDirectiveTrivia(DefineDirectiveTriviaSyntax node)
    {
      var hashToken = (SyntaxToken)this.Visit(node.HashToken);
      var defineKeyword = (SyntaxToken)this.Visit(node.DefineKeyword);
      var name = (SyntaxToken)this.Visit(node.Name);
      var endOfDirectiveToken = (SyntaxToken)this.Visit(node.EndOfDirectiveToken);
      return node.Update(hashToken, defineKeyword, name, endOfDirectiveToken, node.IsActive);
    }

    public override CSharpSyntaxNode VisitUndefDirectiveTrivia(UndefDirectiveTriviaSyntax node)
    {
      var hashToken = (SyntaxToken)this.Visit(node.HashToken);
      var undefKeyword = (SyntaxToken)this.Visit(node.UndefKeyword);
      var name = (SyntaxToken)this.Visit(node.Name);
      var endOfDirectiveToken = (SyntaxToken)this.Visit(node.EndOfDirectiveToken);
      return node.Update(hashToken, undefKeyword, name, endOfDirectiveToken, node.IsActive);
    }

    public override CSharpSyntaxNode VisitLineDirectiveTrivia(LineDirectiveTriviaSyntax node)
    {
      var hashToken = (SyntaxToken)this.Visit(node.HashToken);
      var lineKeyword = (SyntaxToken)this.Visit(node.LineKeyword);
      var line = (SyntaxToken)this.Visit(node.Line);
      var file = (SyntaxToken)this.Visit(node.File);
      var endOfDirectiveToken = (SyntaxToken)this.Visit(node.EndOfDirectiveToken);
      return node.Update(hashToken, lineKeyword, line, file, endOfDirectiveToken, node.IsActive);
    }

    public override CSharpSyntaxNode VisitPragmaWarningDirectiveTrivia(PragmaWarningDirectiveTriviaSyntax node)
    {
      var hashToken = (SyntaxToken)this.Visit(node.HashToken);
      var pragmaKeyword = (SyntaxToken)this.Visit(node.PragmaKeyword);
      var warningKeyword = (SyntaxToken)this.Visit(node.WarningKeyword);
      var disableOrRestoreKeyword = (SyntaxToken)this.Visit(node.DisableOrRestoreKeyword);
      var errorCodes = this.VisitList(node.ErrorCodes);
      var endOfDirectiveToken = (SyntaxToken)this.Visit(node.EndOfDirectiveToken);
      return node.Update(hashToken, pragmaKeyword, warningKeyword, disableOrRestoreKeyword, errorCodes, endOfDirectiveToken, node.IsActive);
    }

    public override CSharpSyntaxNode VisitPragmaChecksumDirectiveTrivia(PragmaChecksumDirectiveTriviaSyntax node)
    {
      var hashToken = (SyntaxToken)this.Visit(node.HashToken);
      var pragmaKeyword = (SyntaxToken)this.Visit(node.PragmaKeyword);
      var checksumKeyword = (SyntaxToken)this.Visit(node.ChecksumKeyword);
      var file = (SyntaxToken)this.Visit(node.File);
      var guid = (SyntaxToken)this.Visit(node.Guid);
      var bytes = (SyntaxToken)this.Visit(node.Bytes);
      var endOfDirectiveToken = (SyntaxToken)this.Visit(node.EndOfDirectiveToken);
      return node.Update(hashToken, pragmaKeyword, checksumKeyword, file, guid, bytes, endOfDirectiveToken, node.IsActive);
    }

    public override CSharpSyntaxNode VisitReferenceDirectiveTrivia(ReferenceDirectiveTriviaSyntax node)
    {
      var hashToken = (SyntaxToken)this.Visit(node.HashToken);
      var referenceKeyword = (SyntaxToken)this.Visit(node.ReferenceKeyword);
      var file = (SyntaxToken)this.Visit(node.File);
      var endOfDirectiveToken = (SyntaxToken)this.Visit(node.EndOfDirectiveToken);
      return node.Update(hashToken, referenceKeyword, file, endOfDirectiveToken, node.IsActive);
    }

    public override CSharpSyntaxNode VisitLoadDirectiveTrivia(LoadDirectiveTriviaSyntax node)
    {
      var hashToken = (SyntaxToken)this.Visit(node.HashToken);
      var loadKeyword = (SyntaxToken)this.Visit(node.LoadKeyword);
      var file = (SyntaxToken)this.Visit(node.File);
      var endOfDirectiveToken = (SyntaxToken)this.Visit(node.EndOfDirectiveToken);
      return node.Update(hashToken, loadKeyword, file, endOfDirectiveToken, node.IsActive);
    }

    public override CSharpSyntaxNode VisitShebangDirectiveTrivia(ShebangDirectiveTriviaSyntax node)
    {
      var hashToken = (SyntaxToken)this.Visit(node.HashToken);
      var exclamationToken = (SyntaxToken)this.Visit(node.ExclamationToken);
      var endOfDirectiveToken = (SyntaxToken)this.Visit(node.EndOfDirectiveToken);
      return node.Update(hashToken, exclamationToken, endOfDirectiveToken, node.IsActive);
    }
  }

  internal partial class ContextAwareSyntax
  {
    private SyntaxFactoryContext context;


    public ContextAwareSyntax(SyntaxFactoryContext context)
    {
        this.context = context;
    }
    public IdentifierNameSyntax IdentifierName(SyntaxToken identifier)
    {
#if DEBUG
      if (identifier == null)
        throw new ArgumentNullException(nameof(identifier));
      switch (identifier.Kind)
      {
        case SyntaxKind.IdentifierToken:
        case SyntaxKind.GlobalKeyword:
          break;
        default:
          throw new ArgumentException("identifier");
      }
#endif

      int hash;
      var cached = CSharpSyntaxNodeCache.TryGetNode((int)SyntaxKind.IdentifierName, identifier, this.context, out hash);
      if (cached != null) return (IdentifierNameSyntax)cached;

      var result = new IdentifierNameSyntax(SyntaxKind.IdentifierName, identifier, this.context);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public QualifiedNameSyntax QualifiedName(NameSyntax left, SyntaxToken dotToken, SimpleNameSyntax right)
    {
#if DEBUG
      if (left == null)
        throw new ArgumentNullException(nameof(left));
      if (dotToken == null)
        throw new ArgumentNullException(nameof(dotToken));
      switch (dotToken.Kind)
      {
        case SyntaxKind.DotToken:
          break;
        default:
          throw new ArgumentException("dotToken");
      }
      if (right == null)
        throw new ArgumentNullException(nameof(right));
#endif

      int hash;
      var cached = CSharpSyntaxNodeCache.TryGetNode((int)SyntaxKind.QualifiedName, left, dotToken, right, this.context, out hash);
      if (cached != null) return (QualifiedNameSyntax)cached;

      var result = new QualifiedNameSyntax(SyntaxKind.QualifiedName, left, dotToken, right, this.context);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public GenericNameSyntax GenericName(SyntaxToken identifier, TypeArgumentListSyntax typeArgumentList)
    {
#if DEBUG
      if (identifier == null)
        throw new ArgumentNullException(nameof(identifier));
      switch (identifier.Kind)
      {
        case SyntaxKind.IdentifierToken:
          break;
        default:
          throw new ArgumentException("identifier");
      }
      if (typeArgumentList == null)
        throw new ArgumentNullException(nameof(typeArgumentList));
#endif

      int hash;
      var cached = CSharpSyntaxNodeCache.TryGetNode((int)SyntaxKind.GenericName, identifier, typeArgumentList, this.context, out hash);
      if (cached != null) return (GenericNameSyntax)cached;

      var result = new GenericNameSyntax(SyntaxKind.GenericName, identifier, typeArgumentList, this.context);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public TypeArgumentListSyntax TypeArgumentList(SyntaxToken lessThanToken, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<TypeSyntax> arguments, SyntaxToken greaterThanToken)
    {
#if DEBUG
      if (lessThanToken == null)
        throw new ArgumentNullException(nameof(lessThanToken));
      switch (lessThanToken.Kind)
      {
        case SyntaxKind.LessThanToken:
          break;
        default:
          throw new ArgumentException("lessThanToken");
      }
      if (greaterThanToken == null)
        throw new ArgumentNullException(nameof(greaterThanToken));
      switch (greaterThanToken.Kind)
      {
        case SyntaxKind.GreaterThanToken:
          break;
        default:
          throw new ArgumentException("greaterThanToken");
      }
#endif

      int hash;
      var cached = CSharpSyntaxNodeCache.TryGetNode((int)SyntaxKind.TypeArgumentList, lessThanToken, arguments.Node, greaterThanToken, this.context, out hash);
      if (cached != null) return (TypeArgumentListSyntax)cached;

      var result = new TypeArgumentListSyntax(SyntaxKind.TypeArgumentList, lessThanToken, arguments.Node, greaterThanToken, this.context);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public AliasQualifiedNameSyntax AliasQualifiedName(IdentifierNameSyntax alias, SyntaxToken colonColonToken, SimpleNameSyntax name)
    {
#if DEBUG
      if (alias == null)
        throw new ArgumentNullException(nameof(alias));
      if (colonColonToken == null)
        throw new ArgumentNullException(nameof(colonColonToken));
      switch (colonColonToken.Kind)
      {
        case SyntaxKind.ColonColonToken:
          break;
        default:
          throw new ArgumentException("colonColonToken");
      }
      if (name == null)
        throw new ArgumentNullException(nameof(name));
#endif

      int hash;
      var cached = CSharpSyntaxNodeCache.TryGetNode((int)SyntaxKind.AliasQualifiedName, alias, colonColonToken, name, this.context, out hash);
      if (cached != null) return (AliasQualifiedNameSyntax)cached;

      var result = new AliasQualifiedNameSyntax(SyntaxKind.AliasQualifiedName, alias, colonColonToken, name, this.context);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public PredefinedTypeSyntax PredefinedType(SyntaxToken keyword)
    {
#if DEBUG
      if (keyword == null)
        throw new ArgumentNullException(nameof(keyword));
      switch (keyword.Kind)
      {
        case SyntaxKind.BoolKeyword:
        case SyntaxKind.ByteKeyword:
        case SyntaxKind.SByteKeyword:
        case SyntaxKind.IntKeyword:
        case SyntaxKind.UIntKeyword:
        case SyntaxKind.ShortKeyword:
        case SyntaxKind.UShortKeyword:
        case SyntaxKind.LongKeyword:
        case SyntaxKind.ULongKeyword:
        case SyntaxKind.FloatKeyword:
        case SyntaxKind.DoubleKeyword:
        case SyntaxKind.DecimalKeyword:
        case SyntaxKind.StringKeyword:
        case SyntaxKind.CharKeyword:
        case SyntaxKind.ObjectKeyword:
        case SyntaxKind.VoidKeyword:
          break;
        default:
          throw new ArgumentException("keyword");
      }
#endif

      int hash;
      var cached = CSharpSyntaxNodeCache.TryGetNode((int)SyntaxKind.PredefinedType, keyword, this.context, out hash);
      if (cached != null) return (PredefinedTypeSyntax)cached;

      var result = new PredefinedTypeSyntax(SyntaxKind.PredefinedType, keyword, this.context);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public ArrayTypeSyntax ArrayType(TypeSyntax elementType, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<ArrayRankSpecifierSyntax> rankSpecifiers)
    {
#if DEBUG
      if (elementType == null)
        throw new ArgumentNullException(nameof(elementType));
#endif

      int hash;
      var cached = CSharpSyntaxNodeCache.TryGetNode((int)SyntaxKind.ArrayType, elementType, rankSpecifiers.Node, this.context, out hash);
      if (cached != null) return (ArrayTypeSyntax)cached;

      var result = new ArrayTypeSyntax(SyntaxKind.ArrayType, elementType, rankSpecifiers.Node, this.context);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public ArrayRankSpecifierSyntax ArrayRankSpecifier(SyntaxToken openBracketToken, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<ExpressionSyntax> sizes, SyntaxToken closeBracketToken)
    {
#if DEBUG
      if (openBracketToken == null)
        throw new ArgumentNullException(nameof(openBracketToken));
      switch (openBracketToken.Kind)
      {
        case SyntaxKind.OpenBracketToken:
          break;
        default:
          throw new ArgumentException("openBracketToken");
      }
      if (closeBracketToken == null)
        throw new ArgumentNullException(nameof(closeBracketToken));
      switch (closeBracketToken.Kind)
      {
        case SyntaxKind.CloseBracketToken:
          break;
        default:
          throw new ArgumentException("closeBracketToken");
      }
#endif

      int hash;
      var cached = CSharpSyntaxNodeCache.TryGetNode((int)SyntaxKind.ArrayRankSpecifier, openBracketToken, sizes.Node, closeBracketToken, this.context, out hash);
      if (cached != null) return (ArrayRankSpecifierSyntax)cached;

      var result = new ArrayRankSpecifierSyntax(SyntaxKind.ArrayRankSpecifier, openBracketToken, sizes.Node, closeBracketToken, this.context);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public PointerTypeSyntax PointerType(TypeSyntax elementType, SyntaxToken asteriskToken)
    {
#if DEBUG
      if (elementType == null)
        throw new ArgumentNullException(nameof(elementType));
      if (asteriskToken == null)
        throw new ArgumentNullException(nameof(asteriskToken));
      switch (asteriskToken.Kind)
      {
        case SyntaxKind.AsteriskToken:
          break;
        default:
          throw new ArgumentException("asteriskToken");
      }
#endif

      int hash;
      var cached = CSharpSyntaxNodeCache.TryGetNode((int)SyntaxKind.PointerType, elementType, asteriskToken, this.context, out hash);
      if (cached != null) return (PointerTypeSyntax)cached;

      var result = new PointerTypeSyntax(SyntaxKind.PointerType, elementType, asteriskToken, this.context);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public NullableTypeSyntax NullableType(TypeSyntax elementType, SyntaxToken questionToken)
    {
#if DEBUG
      if (elementType == null)
        throw new ArgumentNullException(nameof(elementType));
      if (questionToken == null)
        throw new ArgumentNullException(nameof(questionToken));
      switch (questionToken.Kind)
      {
        case SyntaxKind.QuestionToken:
          break;
        default:
          throw new ArgumentException("questionToken");
      }
#endif

      int hash;
      var cached = CSharpSyntaxNodeCache.TryGetNode((int)SyntaxKind.NullableType, elementType, questionToken, this.context, out hash);
      if (cached != null) return (NullableTypeSyntax)cached;

      var result = new NullableTypeSyntax(SyntaxKind.NullableType, elementType, questionToken, this.context);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public TupleTypeSyntax TupleType(SyntaxToken openParenToken, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<TupleElementSyntax> elements, SyntaxToken closeParenToken)
    {
#if DEBUG
      if (openParenToken == null)
        throw new ArgumentNullException(nameof(openParenToken));
      switch (openParenToken.Kind)
      {
        case SyntaxKind.OpenParenToken:
          break;
        default:
          throw new ArgumentException("openParenToken");
      }
      if (closeParenToken == null)
        throw new ArgumentNullException(nameof(closeParenToken));
      switch (closeParenToken.Kind)
      {
        case SyntaxKind.CloseParenToken:
          break;
        default:
          throw new ArgumentException("closeParenToken");
      }
#endif

      int hash;
      var cached = CSharpSyntaxNodeCache.TryGetNode((int)SyntaxKind.TupleType, openParenToken, elements.Node, closeParenToken, this.context, out hash);
      if (cached != null) return (TupleTypeSyntax)cached;

      var result = new TupleTypeSyntax(SyntaxKind.TupleType, openParenToken, elements.Node, closeParenToken, this.context);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public TupleElementSyntax TupleElement(TypeSyntax type, SyntaxToken identifier)
    {
#if DEBUG
      if (type == null)
        throw new ArgumentNullException(nameof(type));
      if (identifier != null)
      {
      switch (identifier.Kind)
      {
        case SyntaxKind.IdentifierToken:
        case SyntaxKind.None:
          break;
        default:
          throw new ArgumentException("identifier");
      }
      }
#endif

      int hash;
      var cached = CSharpSyntaxNodeCache.TryGetNode((int)SyntaxKind.TupleElement, type, identifier, this.context, out hash);
      if (cached != null) return (TupleElementSyntax)cached;

      var result = new TupleElementSyntax(SyntaxKind.TupleElement, type, identifier, this.context);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public OmittedTypeArgumentSyntax OmittedTypeArgument(SyntaxToken omittedTypeArgumentToken)
    {
#if DEBUG
      if (omittedTypeArgumentToken == null)
        throw new ArgumentNullException(nameof(omittedTypeArgumentToken));
      switch (omittedTypeArgumentToken.Kind)
      {
        case SyntaxKind.OmittedTypeArgumentToken:
          break;
        default:
          throw new ArgumentException("omittedTypeArgumentToken");
      }
#endif

      int hash;
      var cached = CSharpSyntaxNodeCache.TryGetNode((int)SyntaxKind.OmittedTypeArgument, omittedTypeArgumentToken, this.context, out hash);
      if (cached != null) return (OmittedTypeArgumentSyntax)cached;

      var result = new OmittedTypeArgumentSyntax(SyntaxKind.OmittedTypeArgument, omittedTypeArgumentToken, this.context);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public RefTypeSyntax RefType(SyntaxToken refKeyword, TypeSyntax type)
    {
#if DEBUG
      if (refKeyword == null)
        throw new ArgumentNullException(nameof(refKeyword));
      switch (refKeyword.Kind)
      {
        case SyntaxKind.RefKeyword:
          break;
        default:
          throw new ArgumentException("refKeyword");
      }
      if (type == null)
        throw new ArgumentNullException(nameof(type));
#endif

      int hash;
      var cached = CSharpSyntaxNodeCache.TryGetNode((int)SyntaxKind.RefType, refKeyword, type, this.context, out hash);
      if (cached != null) return (RefTypeSyntax)cached;

      var result = new RefTypeSyntax(SyntaxKind.RefType, refKeyword, type, this.context);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public ParenthesizedExpressionSyntax ParenthesizedExpression(SyntaxToken openParenToken, ExpressionSyntax expression, SyntaxToken closeParenToken)
    {
#if DEBUG
      if (openParenToken == null)
        throw new ArgumentNullException(nameof(openParenToken));
      switch (openParenToken.Kind)
      {
        case SyntaxKind.OpenParenToken:
          break;
        default:
          throw new ArgumentException("openParenToken");
      }
      if (expression == null)
        throw new ArgumentNullException(nameof(expression));
      if (closeParenToken == null)
        throw new ArgumentNullException(nameof(closeParenToken));
      switch (closeParenToken.Kind)
      {
        case SyntaxKind.CloseParenToken:
          break;
        default:
          throw new ArgumentException("closeParenToken");
      }
#endif

      int hash;
      var cached = CSharpSyntaxNodeCache.TryGetNode((int)SyntaxKind.ParenthesizedExpression, openParenToken, expression, closeParenToken, this.context, out hash);
      if (cached != null) return (ParenthesizedExpressionSyntax)cached;

      var result = new ParenthesizedExpressionSyntax(SyntaxKind.ParenthesizedExpression, openParenToken, expression, closeParenToken, this.context);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public TupleExpressionSyntax TupleExpression(SyntaxToken openParenToken, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<ArgumentSyntax> arguments, SyntaxToken closeParenToken)
    {
#if DEBUG
      if (openParenToken == null)
        throw new ArgumentNullException(nameof(openParenToken));
      switch (openParenToken.Kind)
      {
        case SyntaxKind.OpenParenToken:
          break;
        default:
          throw new ArgumentException("openParenToken");
      }
      if (closeParenToken == null)
        throw new ArgumentNullException(nameof(closeParenToken));
      switch (closeParenToken.Kind)
      {
        case SyntaxKind.CloseParenToken:
          break;
        default:
          throw new ArgumentException("closeParenToken");
      }
#endif

      int hash;
      var cached = CSharpSyntaxNodeCache.TryGetNode((int)SyntaxKind.TupleExpression, openParenToken, arguments.Node, closeParenToken, this.context, out hash);
      if (cached != null) return (TupleExpressionSyntax)cached;

      var result = new TupleExpressionSyntax(SyntaxKind.TupleExpression, openParenToken, arguments.Node, closeParenToken, this.context);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public PrefixUnaryExpressionSyntax PrefixUnaryExpression(SyntaxKind kind, SyntaxToken operatorToken, ExpressionSyntax operand)
    {
      switch (kind)
      {
        case SyntaxKind.UnaryPlusExpression:
        case SyntaxKind.UnaryMinusExpression:
        case SyntaxKind.BitwiseNotExpression:
        case SyntaxKind.LogicalNotExpression:
        case SyntaxKind.PreIncrementExpression:
        case SyntaxKind.PreDecrementExpression:
        case SyntaxKind.AddressOfExpression:
        case SyntaxKind.PointerIndirectionExpression:
          break;
        default:
          throw new ArgumentException("kind");
      }
#if DEBUG
      if (operatorToken == null)
        throw new ArgumentNullException(nameof(operatorToken));
      switch (operatorToken.Kind)
      {
        case SyntaxKind.PlusToken:
        case SyntaxKind.MinusToken:
        case SyntaxKind.TildeToken:
        case SyntaxKind.ExclamationToken:
        case SyntaxKind.PlusPlusToken:
        case SyntaxKind.MinusMinusToken:
        case SyntaxKind.AmpersandToken:
        case SyntaxKind.AsteriskToken:
          break;
        default:
          throw new ArgumentException("operatorToken");
      }
      if (operand == null)
        throw new ArgumentNullException(nameof(operand));
#endif

      int hash;
      var cached = CSharpSyntaxNodeCache.TryGetNode((int)kind, operatorToken, operand, this.context, out hash);
      if (cached != null) return (PrefixUnaryExpressionSyntax)cached;

      var result = new PrefixUnaryExpressionSyntax(kind, operatorToken, operand, this.context);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public AwaitExpressionSyntax AwaitExpression(SyntaxToken awaitKeyword, ExpressionSyntax expression)
    {
#if DEBUG
      if (awaitKeyword == null)
        throw new ArgumentNullException(nameof(awaitKeyword));
      switch (awaitKeyword.Kind)
      {
        case SyntaxKind.AwaitKeyword:
          break;
        default:
          throw new ArgumentException("awaitKeyword");
      }
      if (expression == null)
        throw new ArgumentNullException(nameof(expression));
#endif

      int hash;
      var cached = CSharpSyntaxNodeCache.TryGetNode((int)SyntaxKind.AwaitExpression, awaitKeyword, expression, this.context, out hash);
      if (cached != null) return (AwaitExpressionSyntax)cached;

      var result = new AwaitExpressionSyntax(SyntaxKind.AwaitExpression, awaitKeyword, expression, this.context);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public PostfixUnaryExpressionSyntax PostfixUnaryExpression(SyntaxKind kind, ExpressionSyntax operand, SyntaxToken operatorToken)
    {
      switch (kind)
      {
        case SyntaxKind.PostIncrementExpression:
        case SyntaxKind.PostDecrementExpression:
          break;
        default:
          throw new ArgumentException("kind");
      }
#if DEBUG
      if (operand == null)
        throw new ArgumentNullException(nameof(operand));
      if (operatorToken == null)
        throw new ArgumentNullException(nameof(operatorToken));
      switch (operatorToken.Kind)
      {
        case SyntaxKind.PlusPlusToken:
        case SyntaxKind.MinusMinusToken:
          break;
        default:
          throw new ArgumentException("operatorToken");
      }
#endif

      int hash;
      var cached = CSharpSyntaxNodeCache.TryGetNode((int)kind, operand, operatorToken, this.context, out hash);
      if (cached != null) return (PostfixUnaryExpressionSyntax)cached;

      var result = new PostfixUnaryExpressionSyntax(kind, operand, operatorToken, this.context);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public MemberAccessExpressionSyntax MemberAccessExpression(SyntaxKind kind, ExpressionSyntax expression, SyntaxToken operatorToken, SimpleNameSyntax name)
    {
      switch (kind)
      {
        case SyntaxKind.SimpleMemberAccessExpression:
        case SyntaxKind.PointerMemberAccessExpression:
          break;
        default:
          throw new ArgumentException("kind");
      }
#if DEBUG
      if (expression == null)
        throw new ArgumentNullException(nameof(expression));
      if (operatorToken == null)
        throw new ArgumentNullException(nameof(operatorToken));
      switch (operatorToken.Kind)
      {
        case SyntaxKind.DotToken:
        case SyntaxKind.MinusGreaterThanToken:
          break;
        default:
          throw new ArgumentException("operatorToken");
      }
      if (name == null)
        throw new ArgumentNullException(nameof(name));
#endif

      int hash;
      var cached = CSharpSyntaxNodeCache.TryGetNode((int)kind, expression, operatorToken, name, this.context, out hash);
      if (cached != null) return (MemberAccessExpressionSyntax)cached;

      var result = new MemberAccessExpressionSyntax(kind, expression, operatorToken, name, this.context);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public ConditionalAccessExpressionSyntax ConditionalAccessExpression(ExpressionSyntax expression, SyntaxToken operatorToken, ExpressionSyntax whenNotNull)
    {
#if DEBUG
      if (expression == null)
        throw new ArgumentNullException(nameof(expression));
      if (operatorToken == null)
        throw new ArgumentNullException(nameof(operatorToken));
      switch (operatorToken.Kind)
      {
        case SyntaxKind.QuestionToken:
          break;
        default:
          throw new ArgumentException("operatorToken");
      }
      if (whenNotNull == null)
        throw new ArgumentNullException(nameof(whenNotNull));
#endif

      int hash;
      var cached = CSharpSyntaxNodeCache.TryGetNode((int)SyntaxKind.ConditionalAccessExpression, expression, operatorToken, whenNotNull, this.context, out hash);
      if (cached != null) return (ConditionalAccessExpressionSyntax)cached;

      var result = new ConditionalAccessExpressionSyntax(SyntaxKind.ConditionalAccessExpression, expression, operatorToken, whenNotNull, this.context);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public MemberBindingExpressionSyntax MemberBindingExpression(SyntaxToken operatorToken, SimpleNameSyntax name)
    {
#if DEBUG
      if (operatorToken == null)
        throw new ArgumentNullException(nameof(operatorToken));
      switch (operatorToken.Kind)
      {
        case SyntaxKind.DotToken:
          break;
        default:
          throw new ArgumentException("operatorToken");
      }
      if (name == null)
        throw new ArgumentNullException(nameof(name));
#endif

      int hash;
      var cached = CSharpSyntaxNodeCache.TryGetNode((int)SyntaxKind.MemberBindingExpression, operatorToken, name, this.context, out hash);
      if (cached != null) return (MemberBindingExpressionSyntax)cached;

      var result = new MemberBindingExpressionSyntax(SyntaxKind.MemberBindingExpression, operatorToken, name, this.context);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public ElementBindingExpressionSyntax ElementBindingExpression(BracketedArgumentListSyntax argumentList)
    {
#if DEBUG
      if (argumentList == null)
        throw new ArgumentNullException(nameof(argumentList));
#endif

      int hash;
      var cached = CSharpSyntaxNodeCache.TryGetNode((int)SyntaxKind.ElementBindingExpression, argumentList, this.context, out hash);
      if (cached != null) return (ElementBindingExpressionSyntax)cached;

      var result = new ElementBindingExpressionSyntax(SyntaxKind.ElementBindingExpression, argumentList, this.context);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public ImplicitElementAccessSyntax ImplicitElementAccess(BracketedArgumentListSyntax argumentList)
    {
#if DEBUG
      if (argumentList == null)
        throw new ArgumentNullException(nameof(argumentList));
#endif

      int hash;
      var cached = CSharpSyntaxNodeCache.TryGetNode((int)SyntaxKind.ImplicitElementAccess, argumentList, this.context, out hash);
      if (cached != null) return (ImplicitElementAccessSyntax)cached;

      var result = new ImplicitElementAccessSyntax(SyntaxKind.ImplicitElementAccess, argumentList, this.context);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public BinaryExpressionSyntax BinaryExpression(SyntaxKind kind, ExpressionSyntax left, SyntaxToken operatorToken, ExpressionSyntax right)
    {
      switch (kind)
      {
        case SyntaxKind.AddExpression:
        case SyntaxKind.SubtractExpression:
        case SyntaxKind.MultiplyExpression:
        case SyntaxKind.DivideExpression:
        case SyntaxKind.ModuloExpression:
        case SyntaxKind.LeftShiftExpression:
        case SyntaxKind.RightShiftExpression:
        case SyntaxKind.LogicalOrExpression:
        case SyntaxKind.LogicalAndExpression:
        case SyntaxKind.BitwiseOrExpression:
        case SyntaxKind.BitwiseAndExpression:
        case SyntaxKind.ExclusiveOrExpression:
        case SyntaxKind.EqualsExpression:
        case SyntaxKind.NotEqualsExpression:
        case SyntaxKind.LessThanExpression:
        case SyntaxKind.LessThanOrEqualExpression:
        case SyntaxKind.GreaterThanExpression:
        case SyntaxKind.GreaterThanOrEqualExpression:
        case SyntaxKind.IsExpression:
        case SyntaxKind.AsExpression:
        case SyntaxKind.CoalesceExpression:
          break;
        default:
          throw new ArgumentException("kind");
      }
#if DEBUG
      if (left == null)
        throw new ArgumentNullException(nameof(left));
      if (operatorToken == null)
        throw new ArgumentNullException(nameof(operatorToken));
      switch (operatorToken.Kind)
      {
        case SyntaxKind.PlusToken:
        case SyntaxKind.MinusToken:
        case SyntaxKind.AsteriskToken:
        case SyntaxKind.SlashToken:
        case SyntaxKind.PercentToken:
        case SyntaxKind.LessThanLessThanToken:
        case SyntaxKind.GreaterThanGreaterThanToken:
        case SyntaxKind.BarBarToken:
        case SyntaxKind.AmpersandAmpersandToken:
        case SyntaxKind.BarToken:
        case SyntaxKind.AmpersandToken:
        case SyntaxKind.CaretToken:
        case SyntaxKind.EqualsEqualsToken:
        case SyntaxKind.ExclamationEqualsToken:
        case SyntaxKind.LessThanToken:
        case SyntaxKind.LessThanEqualsToken:
        case SyntaxKind.GreaterThanToken:
        case SyntaxKind.GreaterThanEqualsToken:
        case SyntaxKind.IsKeyword:
        case SyntaxKind.AsKeyword:
        case SyntaxKind.QuestionQuestionToken:
          break;
        default:
          throw new ArgumentException("operatorToken");
      }
      if (right == null)
        throw new ArgumentNullException(nameof(right));
#endif

      int hash;
      var cached = CSharpSyntaxNodeCache.TryGetNode((int)kind, left, operatorToken, right, this.context, out hash);
      if (cached != null) return (BinaryExpressionSyntax)cached;

      var result = new BinaryExpressionSyntax(kind, left, operatorToken, right, this.context);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public AssignmentExpressionSyntax AssignmentExpression(SyntaxKind kind, ExpressionSyntax left, SyntaxToken operatorToken, ExpressionSyntax right)
    {
      switch (kind)
      {
        case SyntaxKind.SimpleAssignmentExpression:
        case SyntaxKind.AddAssignmentExpression:
        case SyntaxKind.SubtractAssignmentExpression:
        case SyntaxKind.MultiplyAssignmentExpression:
        case SyntaxKind.DivideAssignmentExpression:
        case SyntaxKind.ModuloAssignmentExpression:
        case SyntaxKind.AndAssignmentExpression:
        case SyntaxKind.ExclusiveOrAssignmentExpression:
        case SyntaxKind.OrAssignmentExpression:
        case SyntaxKind.LeftShiftAssignmentExpression:
        case SyntaxKind.RightShiftAssignmentExpression:
          break;
        default:
          throw new ArgumentException("kind");
      }
#if DEBUG
      if (left == null)
        throw new ArgumentNullException(nameof(left));
      if (operatorToken == null)
        throw new ArgumentNullException(nameof(operatorToken));
      switch (operatorToken.Kind)
      {
        case SyntaxKind.EqualsToken:
        case SyntaxKind.PlusEqualsToken:
        case SyntaxKind.MinusEqualsToken:
        case SyntaxKind.AsteriskEqualsToken:
        case SyntaxKind.SlashEqualsToken:
        case SyntaxKind.PercentEqualsToken:
        case SyntaxKind.AmpersandEqualsToken:
        case SyntaxKind.CaretEqualsToken:
        case SyntaxKind.BarEqualsToken:
        case SyntaxKind.LessThanLessThanEqualsToken:
        case SyntaxKind.GreaterThanGreaterThanEqualsToken:
          break;
        default:
          throw new ArgumentException("operatorToken");
      }
      if (right == null)
        throw new ArgumentNullException(nameof(right));
#endif

      int hash;
      var cached = CSharpSyntaxNodeCache.TryGetNode((int)kind, left, operatorToken, right, this.context, out hash);
      if (cached != null) return (AssignmentExpressionSyntax)cached;

      var result = new AssignmentExpressionSyntax(kind, left, operatorToken, right, this.context);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public ConditionalExpressionSyntax ConditionalExpression(ExpressionSyntax condition, SyntaxToken questionToken, ExpressionSyntax whenTrue, SyntaxToken colonToken, ExpressionSyntax whenFalse)
    {
#if DEBUG
      if (condition == null)
        throw new ArgumentNullException(nameof(condition));
      if (questionToken == null)
        throw new ArgumentNullException(nameof(questionToken));
      switch (questionToken.Kind)
      {
        case SyntaxKind.QuestionToken:
          break;
        default:
          throw new ArgumentException("questionToken");
      }
      if (whenTrue == null)
        throw new ArgumentNullException(nameof(whenTrue));
      if (colonToken == null)
        throw new ArgumentNullException(nameof(colonToken));
      switch (colonToken.Kind)
      {
        case SyntaxKind.ColonToken:
          break;
        default:
          throw new ArgumentException("colonToken");
      }
      if (whenFalse == null)
        throw new ArgumentNullException(nameof(whenFalse));
#endif

      return new ConditionalExpressionSyntax(SyntaxKind.ConditionalExpression, condition, questionToken, whenTrue, colonToken, whenFalse, this.context);
    }

    public ThisExpressionSyntax ThisExpression(SyntaxToken token)
    {
#if DEBUG
      if (token == null)
        throw new ArgumentNullException(nameof(token));
      switch (token.Kind)
      {
        case SyntaxKind.ThisKeyword:
          break;
        default:
          throw new ArgumentException("token");
      }
#endif

      int hash;
      var cached = CSharpSyntaxNodeCache.TryGetNode((int)SyntaxKind.ThisExpression, token, this.context, out hash);
      if (cached != null) return (ThisExpressionSyntax)cached;

      var result = new ThisExpressionSyntax(SyntaxKind.ThisExpression, token, this.context);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public BaseExpressionSyntax BaseExpression(SyntaxToken token)
    {
#if DEBUG
      if (token == null)
        throw new ArgumentNullException(nameof(token));
      switch (token.Kind)
      {
        case SyntaxKind.BaseKeyword:
          break;
        default:
          throw new ArgumentException("token");
      }
#endif

      int hash;
      var cached = CSharpSyntaxNodeCache.TryGetNode((int)SyntaxKind.BaseExpression, token, this.context, out hash);
      if (cached != null) return (BaseExpressionSyntax)cached;

      var result = new BaseExpressionSyntax(SyntaxKind.BaseExpression, token, this.context);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public LiteralExpressionSyntax LiteralExpression(SyntaxKind kind, SyntaxToken token)
    {
      switch (kind)
      {
        case SyntaxKind.ArgListExpression:
        case SyntaxKind.NumericLiteralExpression:
        case SyntaxKind.StringLiteralExpression:
        case SyntaxKind.CharacterLiteralExpression:
        case SyntaxKind.TrueLiteralExpression:
        case SyntaxKind.FalseLiteralExpression:
        case SyntaxKind.NullLiteralExpression:
        case SyntaxKind.DefaultLiteralExpression:
          break;
        default:
          throw new ArgumentException("kind");
      }
#if DEBUG
      if (token == null)
        throw new ArgumentNullException(nameof(token));
      switch (token.Kind)
      {
        case SyntaxKind.ArgListKeyword:
        case SyntaxKind.NumericLiteralToken:
        case SyntaxKind.StringLiteralToken:
        case SyntaxKind.CharacterLiteralToken:
        case SyntaxKind.TrueKeyword:
        case SyntaxKind.FalseKeyword:
        case SyntaxKind.NullKeyword:
        case SyntaxKind.DefaultKeyword:
          break;
        default:
          throw new ArgumentException("token");
      }
#endif

      int hash;
      var cached = CSharpSyntaxNodeCache.TryGetNode((int)kind, token, this.context, out hash);
      if (cached != null) return (LiteralExpressionSyntax)cached;

      var result = new LiteralExpressionSyntax(kind, token, this.context);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public MakeRefExpressionSyntax MakeRefExpression(SyntaxToken keyword, SyntaxToken openParenToken, ExpressionSyntax expression, SyntaxToken closeParenToken)
    {
#if DEBUG
      if (keyword == null)
        throw new ArgumentNullException(nameof(keyword));
      switch (keyword.Kind)
      {
        case SyntaxKind.MakeRefKeyword:
          break;
        default:
          throw new ArgumentException("keyword");
      }
      if (openParenToken == null)
        throw new ArgumentNullException(nameof(openParenToken));
      switch (openParenToken.Kind)
      {
        case SyntaxKind.OpenParenToken:
          break;
        default:
          throw new ArgumentException("openParenToken");
      }
      if (expression == null)
        throw new ArgumentNullException(nameof(expression));
      if (closeParenToken == null)
        throw new ArgumentNullException(nameof(closeParenToken));
      switch (closeParenToken.Kind)
      {
        case SyntaxKind.CloseParenToken:
          break;
        default:
          throw new ArgumentException("closeParenToken");
      }
#endif

      return new MakeRefExpressionSyntax(SyntaxKind.MakeRefExpression, keyword, openParenToken, expression, closeParenToken, this.context);
    }

    public RefTypeExpressionSyntax RefTypeExpression(SyntaxToken keyword, SyntaxToken openParenToken, ExpressionSyntax expression, SyntaxToken closeParenToken)
    {
#if DEBUG
      if (keyword == null)
        throw new ArgumentNullException(nameof(keyword));
      switch (keyword.Kind)
      {
        case SyntaxKind.RefTypeKeyword:
          break;
        default:
          throw new ArgumentException("keyword");
      }
      if (openParenToken == null)
        throw new ArgumentNullException(nameof(openParenToken));
      switch (openParenToken.Kind)
      {
        case SyntaxKind.OpenParenToken:
          break;
        default:
          throw new ArgumentException("openParenToken");
      }
      if (expression == null)
        throw new ArgumentNullException(nameof(expression));
      if (closeParenToken == null)
        throw new ArgumentNullException(nameof(closeParenToken));
      switch (closeParenToken.Kind)
      {
        case SyntaxKind.CloseParenToken:
          break;
        default:
          throw new ArgumentException("closeParenToken");
      }
#endif

      return new RefTypeExpressionSyntax(SyntaxKind.RefTypeExpression, keyword, openParenToken, expression, closeParenToken, this.context);
    }

    public RefValueExpressionSyntax RefValueExpression(SyntaxToken keyword, SyntaxToken openParenToken, ExpressionSyntax expression, SyntaxToken comma, TypeSyntax type, SyntaxToken closeParenToken)
    {
#if DEBUG
      if (keyword == null)
        throw new ArgumentNullException(nameof(keyword));
      switch (keyword.Kind)
      {
        case SyntaxKind.RefValueKeyword:
          break;
        default:
          throw new ArgumentException("keyword");
      }
      if (openParenToken == null)
        throw new ArgumentNullException(nameof(openParenToken));
      switch (openParenToken.Kind)
      {
        case SyntaxKind.OpenParenToken:
          break;
        default:
          throw new ArgumentException("openParenToken");
      }
      if (expression == null)
        throw new ArgumentNullException(nameof(expression));
      if (comma == null)
        throw new ArgumentNullException(nameof(comma));
      switch (comma.Kind)
      {
        case SyntaxKind.CommaToken:
          break;
        default:
          throw new ArgumentException("comma");
      }
      if (type == null)
        throw new ArgumentNullException(nameof(type));
      if (closeParenToken == null)
        throw new ArgumentNullException(nameof(closeParenToken));
      switch (closeParenToken.Kind)
      {
        case SyntaxKind.CloseParenToken:
          break;
        default:
          throw new ArgumentException("closeParenToken");
      }
#endif

      return new RefValueExpressionSyntax(SyntaxKind.RefValueExpression, keyword, openParenToken, expression, comma, type, closeParenToken, this.context);
    }

    public CheckedExpressionSyntax CheckedExpression(SyntaxKind kind, SyntaxToken keyword, SyntaxToken openParenToken, ExpressionSyntax expression, SyntaxToken closeParenToken)
    {
      switch (kind)
      {
        case SyntaxKind.CheckedExpression:
        case SyntaxKind.UncheckedExpression:
          break;
        default:
          throw new ArgumentException("kind");
      }
#if DEBUG
      if (keyword == null)
        throw new ArgumentNullException(nameof(keyword));
      switch (keyword.Kind)
      {
        case SyntaxKind.CheckedKeyword:
        case SyntaxKind.UncheckedKeyword:
          break;
        default:
          throw new ArgumentException("keyword");
      }
      if (openParenToken == null)
        throw new ArgumentNullException(nameof(openParenToken));
      switch (openParenToken.Kind)
      {
        case SyntaxKind.OpenParenToken:
          break;
        default:
          throw new ArgumentException("openParenToken");
      }
      if (expression == null)
        throw new ArgumentNullException(nameof(expression));
      if (closeParenToken == null)
        throw new ArgumentNullException(nameof(closeParenToken));
      switch (closeParenToken.Kind)
      {
        case SyntaxKind.CloseParenToken:
          break;
        default:
          throw new ArgumentException("closeParenToken");
      }
#endif

      return new CheckedExpressionSyntax(kind, keyword, openParenToken, expression, closeParenToken, this.context);
    }

    public DefaultExpressionSyntax DefaultExpression(SyntaxToken keyword, SyntaxToken openParenToken, TypeSyntax type, SyntaxToken closeParenToken)
    {
#if DEBUG
      if (keyword == null)
        throw new ArgumentNullException(nameof(keyword));
      switch (keyword.Kind)
      {
        case SyntaxKind.DefaultKeyword:
          break;
        default:
          throw new ArgumentException("keyword");
      }
      if (openParenToken == null)
        throw new ArgumentNullException(nameof(openParenToken));
      switch (openParenToken.Kind)
      {
        case SyntaxKind.OpenParenToken:
          break;
        default:
          throw new ArgumentException("openParenToken");
      }
      if (type == null)
        throw new ArgumentNullException(nameof(type));
      if (closeParenToken == null)
        throw new ArgumentNullException(nameof(closeParenToken));
      switch (closeParenToken.Kind)
      {
        case SyntaxKind.CloseParenToken:
          break;
        default:
          throw new ArgumentException("closeParenToken");
      }
#endif

      return new DefaultExpressionSyntax(SyntaxKind.DefaultExpression, keyword, openParenToken, type, closeParenToken, this.context);
    }

    public TypeOfExpressionSyntax TypeOfExpression(SyntaxToken keyword, SyntaxToken openParenToken, TypeSyntax type, SyntaxToken closeParenToken)
    {
#if DEBUG
      if (keyword == null)
        throw new ArgumentNullException(nameof(keyword));
      switch (keyword.Kind)
      {
        case SyntaxKind.TypeOfKeyword:
          break;
        default:
          throw new ArgumentException("keyword");
      }
      if (openParenToken == null)
        throw new ArgumentNullException(nameof(openParenToken));
      switch (openParenToken.Kind)
      {
        case SyntaxKind.OpenParenToken:
          break;
        default:
          throw new ArgumentException("openParenToken");
      }
      if (type == null)
        throw new ArgumentNullException(nameof(type));
      if (closeParenToken == null)
        throw new ArgumentNullException(nameof(closeParenToken));
      switch (closeParenToken.Kind)
      {
        case SyntaxKind.CloseParenToken:
          break;
        default:
          throw new ArgumentException("closeParenToken");
      }
#endif

      return new TypeOfExpressionSyntax(SyntaxKind.TypeOfExpression, keyword, openParenToken, type, closeParenToken, this.context);
    }

    public SizeOfExpressionSyntax SizeOfExpression(SyntaxToken keyword, SyntaxToken openParenToken, TypeSyntax type, SyntaxToken closeParenToken)
    {
#if DEBUG
      if (keyword == null)
        throw new ArgumentNullException(nameof(keyword));
      switch (keyword.Kind)
      {
        case SyntaxKind.SizeOfKeyword:
          break;
        default:
          throw new ArgumentException("keyword");
      }
      if (openParenToken == null)
        throw new ArgumentNullException(nameof(openParenToken));
      switch (openParenToken.Kind)
      {
        case SyntaxKind.OpenParenToken:
          break;
        default:
          throw new ArgumentException("openParenToken");
      }
      if (type == null)
        throw new ArgumentNullException(nameof(type));
      if (closeParenToken == null)
        throw new ArgumentNullException(nameof(closeParenToken));
      switch (closeParenToken.Kind)
      {
        case SyntaxKind.CloseParenToken:
          break;
        default:
          throw new ArgumentException("closeParenToken");
      }
#endif

      return new SizeOfExpressionSyntax(SyntaxKind.SizeOfExpression, keyword, openParenToken, type, closeParenToken, this.context);
    }

    public InvocationExpressionSyntax InvocationExpression(ExpressionSyntax expression, ArgumentListSyntax argumentList)
    {
#if DEBUG
      if (expression == null)
        throw new ArgumentNullException(nameof(expression));
      if (argumentList == null)
        throw new ArgumentNullException(nameof(argumentList));
#endif

      int hash;
      var cached = CSharpSyntaxNodeCache.TryGetNode((int)SyntaxKind.InvocationExpression, expression, argumentList, this.context, out hash);
      if (cached != null) return (InvocationExpressionSyntax)cached;

      var result = new InvocationExpressionSyntax(SyntaxKind.InvocationExpression, expression, argumentList, this.context);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public ElementAccessExpressionSyntax ElementAccessExpression(ExpressionSyntax expression, BracketedArgumentListSyntax argumentList)
    {
#if DEBUG
      if (expression == null)
        throw new ArgumentNullException(nameof(expression));
      if (argumentList == null)
        throw new ArgumentNullException(nameof(argumentList));
#endif

      int hash;
      var cached = CSharpSyntaxNodeCache.TryGetNode((int)SyntaxKind.ElementAccessExpression, expression, argumentList, this.context, out hash);
      if (cached != null) return (ElementAccessExpressionSyntax)cached;

      var result = new ElementAccessExpressionSyntax(SyntaxKind.ElementAccessExpression, expression, argumentList, this.context);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public ArgumentListSyntax ArgumentList(SyntaxToken openParenToken, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<ArgumentSyntax> arguments, SyntaxToken closeParenToken)
    {
#if DEBUG
      if (openParenToken == null)
        throw new ArgumentNullException(nameof(openParenToken));
      switch (openParenToken.Kind)
      {
        case SyntaxKind.OpenParenToken:
          break;
        default:
          throw new ArgumentException("openParenToken");
      }
      if (closeParenToken == null)
        throw new ArgumentNullException(nameof(closeParenToken));
      switch (closeParenToken.Kind)
      {
        case SyntaxKind.CloseParenToken:
          break;
        default:
          throw new ArgumentException("closeParenToken");
      }
#endif

      int hash;
      var cached = CSharpSyntaxNodeCache.TryGetNode((int)SyntaxKind.ArgumentList, openParenToken, arguments.Node, closeParenToken, this.context, out hash);
      if (cached != null) return (ArgumentListSyntax)cached;

      var result = new ArgumentListSyntax(SyntaxKind.ArgumentList, openParenToken, arguments.Node, closeParenToken, this.context);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public BracketedArgumentListSyntax BracketedArgumentList(SyntaxToken openBracketToken, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<ArgumentSyntax> arguments, SyntaxToken closeBracketToken)
    {
#if DEBUG
      if (openBracketToken == null)
        throw new ArgumentNullException(nameof(openBracketToken));
      switch (openBracketToken.Kind)
      {
        case SyntaxKind.OpenBracketToken:
          break;
        default:
          throw new ArgumentException("openBracketToken");
      }
      if (closeBracketToken == null)
        throw new ArgumentNullException(nameof(closeBracketToken));
      switch (closeBracketToken.Kind)
      {
        case SyntaxKind.CloseBracketToken:
          break;
        default:
          throw new ArgumentException("closeBracketToken");
      }
#endif

      int hash;
      var cached = CSharpSyntaxNodeCache.TryGetNode((int)SyntaxKind.BracketedArgumentList, openBracketToken, arguments.Node, closeBracketToken, this.context, out hash);
      if (cached != null) return (BracketedArgumentListSyntax)cached;

      var result = new BracketedArgumentListSyntax(SyntaxKind.BracketedArgumentList, openBracketToken, arguments.Node, closeBracketToken, this.context);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public ArgumentSyntax Argument(NameColonSyntax nameColon, SyntaxToken refOrOutKeyword, ExpressionSyntax expression)
    {
#if DEBUG
      if (refOrOutKeyword != null)
      {
      switch (refOrOutKeyword.Kind)
      {
        case SyntaxKind.RefKeyword:
        case SyntaxKind.OutKeyword:
        case SyntaxKind.None:
          break;
        default:
          throw new ArgumentException("refOrOutKeyword");
      }
      }
      if (expression == null)
        throw new ArgumentNullException(nameof(expression));
#endif

      int hash;
      var cached = CSharpSyntaxNodeCache.TryGetNode((int)SyntaxKind.Argument, nameColon, refOrOutKeyword, expression, this.context, out hash);
      if (cached != null) return (ArgumentSyntax)cached;

      var result = new ArgumentSyntax(SyntaxKind.Argument, nameColon, refOrOutKeyword, expression, this.context);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public NameColonSyntax NameColon(IdentifierNameSyntax name, SyntaxToken colonToken)
    {
#if DEBUG
      if (name == null)
        throw new ArgumentNullException(nameof(name));
      if (colonToken == null)
        throw new ArgumentNullException(nameof(colonToken));
      switch (colonToken.Kind)
      {
        case SyntaxKind.ColonToken:
          break;
        default:
          throw new ArgumentException("colonToken");
      }
#endif

      int hash;
      var cached = CSharpSyntaxNodeCache.TryGetNode((int)SyntaxKind.NameColon, name, colonToken, this.context, out hash);
      if (cached != null) return (NameColonSyntax)cached;

      var result = new NameColonSyntax(SyntaxKind.NameColon, name, colonToken, this.context);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public DeclarationExpressionSyntax DeclarationExpression(TypeSyntax type, VariableDesignationSyntax designation)
    {
#if DEBUG
      if (type == null)
        throw new ArgumentNullException(nameof(type));
      if (designation == null)
        throw new ArgumentNullException(nameof(designation));
#endif

      int hash;
      var cached = CSharpSyntaxNodeCache.TryGetNode((int)SyntaxKind.DeclarationExpression, type, designation, this.context, out hash);
      if (cached != null) return (DeclarationExpressionSyntax)cached;

      var result = new DeclarationExpressionSyntax(SyntaxKind.DeclarationExpression, type, designation, this.context);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public CastExpressionSyntax CastExpression(SyntaxToken openParenToken, TypeSyntax type, SyntaxToken closeParenToken, ExpressionSyntax expression)
    {
#if DEBUG
      if (openParenToken == null)
        throw new ArgumentNullException(nameof(openParenToken));
      switch (openParenToken.Kind)
      {
        case SyntaxKind.OpenParenToken:
          break;
        default:
          throw new ArgumentException("openParenToken");
      }
      if (type == null)
        throw new ArgumentNullException(nameof(type));
      if (closeParenToken == null)
        throw new ArgumentNullException(nameof(closeParenToken));
      switch (closeParenToken.Kind)
      {
        case SyntaxKind.CloseParenToken:
          break;
        default:
          throw new ArgumentException("closeParenToken");
      }
      if (expression == null)
        throw new ArgumentNullException(nameof(expression));
#endif

      return new CastExpressionSyntax(SyntaxKind.CastExpression, openParenToken, type, closeParenToken, expression, this.context);
    }

    public AnonymousMethodExpressionSyntax AnonymousMethodExpression(SyntaxToken asyncKeyword, SyntaxToken delegateKeyword, ParameterListSyntax parameterList, CSharpSyntaxNode body)
    {
#if DEBUG
      if (asyncKeyword != null)
      {
      switch (asyncKeyword.Kind)
      {
        case SyntaxKind.AsyncKeyword:
        case SyntaxKind.None:
          break;
        default:
          throw new ArgumentException("asyncKeyword");
      }
      }
      if (delegateKeyword == null)
        throw new ArgumentNullException(nameof(delegateKeyword));
      switch (delegateKeyword.Kind)
      {
        case SyntaxKind.DelegateKeyword:
          break;
        default:
          throw new ArgumentException("delegateKeyword");
      }
      if (body == null)
        throw new ArgumentNullException(nameof(body));
#endif

      return new AnonymousMethodExpressionSyntax(SyntaxKind.AnonymousMethodExpression, asyncKeyword, delegateKeyword, parameterList, body, this.context);
    }

    public SimpleLambdaExpressionSyntax SimpleLambdaExpression(SyntaxToken asyncKeyword, ParameterSyntax parameter, SyntaxToken arrowToken, CSharpSyntaxNode body)
    {
#if DEBUG
      if (asyncKeyword != null)
      {
      switch (asyncKeyword.Kind)
      {
        case SyntaxKind.AsyncKeyword:
        case SyntaxKind.None:
          break;
        default:
          throw new ArgumentException("asyncKeyword");
      }
      }
      if (parameter == null)
        throw new ArgumentNullException(nameof(parameter));
      if (arrowToken == null)
        throw new ArgumentNullException(nameof(arrowToken));
      switch (arrowToken.Kind)
      {
        case SyntaxKind.EqualsGreaterThanToken:
          break;
        default:
          throw new ArgumentException("arrowToken");
      }
      if (body == null)
        throw new ArgumentNullException(nameof(body));
#endif

      return new SimpleLambdaExpressionSyntax(SyntaxKind.SimpleLambdaExpression, asyncKeyword, parameter, arrowToken, body, this.context);
    }

    public RefExpressionSyntax RefExpression(SyntaxToken refKeyword, ExpressionSyntax expression)
    {
#if DEBUG
      if (refKeyword == null)
        throw new ArgumentNullException(nameof(refKeyword));
      switch (refKeyword.Kind)
      {
        case SyntaxKind.RefKeyword:
          break;
        default:
          throw new ArgumentException("refKeyword");
      }
      if (expression == null)
        throw new ArgumentNullException(nameof(expression));
#endif

      int hash;
      var cached = CSharpSyntaxNodeCache.TryGetNode((int)SyntaxKind.RefExpression, refKeyword, expression, this.context, out hash);
      if (cached != null) return (RefExpressionSyntax)cached;

      var result = new RefExpressionSyntax(SyntaxKind.RefExpression, refKeyword, expression, this.context);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public ParenthesizedLambdaExpressionSyntax ParenthesizedLambdaExpression(SyntaxToken asyncKeyword, ParameterListSyntax parameterList, SyntaxToken arrowToken, CSharpSyntaxNode body)
    {
#if DEBUG
      if (asyncKeyword != null)
      {
      switch (asyncKeyword.Kind)
      {
        case SyntaxKind.AsyncKeyword:
        case SyntaxKind.None:
          break;
        default:
          throw new ArgumentException("asyncKeyword");
      }
      }
      if (parameterList == null)
        throw new ArgumentNullException(nameof(parameterList));
      if (arrowToken == null)
        throw new ArgumentNullException(nameof(arrowToken));
      switch (arrowToken.Kind)
      {
        case SyntaxKind.EqualsGreaterThanToken:
          break;
        default:
          throw new ArgumentException("arrowToken");
      }
      if (body == null)
        throw new ArgumentNullException(nameof(body));
#endif

      return new ParenthesizedLambdaExpressionSyntax(SyntaxKind.ParenthesizedLambdaExpression, asyncKeyword, parameterList, arrowToken, body, this.context);
    }

    public InitializerExpressionSyntax InitializerExpression(SyntaxKind kind, SyntaxToken openBraceToken, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<ExpressionSyntax> expressions, SyntaxToken closeBraceToken)
    {
      switch (kind)
      {
        case SyntaxKind.ObjectInitializerExpression:
        case SyntaxKind.CollectionInitializerExpression:
        case SyntaxKind.ArrayInitializerExpression:
        case SyntaxKind.ComplexElementInitializerExpression:
          break;
        default:
          throw new ArgumentException("kind");
      }
#if DEBUG
      if (openBraceToken == null)
        throw new ArgumentNullException(nameof(openBraceToken));
      switch (openBraceToken.Kind)
      {
        case SyntaxKind.OpenBraceToken:
          break;
        default:
          throw new ArgumentException("openBraceToken");
      }
      if (closeBraceToken == null)
        throw new ArgumentNullException(nameof(closeBraceToken));
      switch (closeBraceToken.Kind)
      {
        case SyntaxKind.CloseBraceToken:
          break;
        default:
          throw new ArgumentException("closeBraceToken");
      }
#endif

      int hash;
      var cached = CSharpSyntaxNodeCache.TryGetNode((int)kind, openBraceToken, expressions.Node, closeBraceToken, this.context, out hash);
      if (cached != null) return (InitializerExpressionSyntax)cached;

      var result = new InitializerExpressionSyntax(kind, openBraceToken, expressions.Node, closeBraceToken, this.context);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public ObjectCreationExpressionSyntax ObjectCreationExpression(SyntaxToken newKeyword, TypeSyntax type, ArgumentListSyntax argumentList, InitializerExpressionSyntax initializer)
    {
#if DEBUG
      if (newKeyword == null)
        throw new ArgumentNullException(nameof(newKeyword));
      switch (newKeyword.Kind)
      {
        case SyntaxKind.NewKeyword:
          break;
        default:
          throw new ArgumentException("newKeyword");
      }
      if (type == null)
        throw new ArgumentNullException(nameof(type));
#endif

      return new ObjectCreationExpressionSyntax(SyntaxKind.ObjectCreationExpression, newKeyword, type, argumentList, initializer, this.context);
    }

    public AnonymousObjectMemberDeclaratorSyntax AnonymousObjectMemberDeclarator(NameEqualsSyntax nameEquals, ExpressionSyntax expression)
    {
#if DEBUG
      if (expression == null)
        throw new ArgumentNullException(nameof(expression));
#endif

      int hash;
      var cached = CSharpSyntaxNodeCache.TryGetNode((int)SyntaxKind.AnonymousObjectMemberDeclarator, nameEquals, expression, this.context, out hash);
      if (cached != null) return (AnonymousObjectMemberDeclaratorSyntax)cached;

      var result = new AnonymousObjectMemberDeclaratorSyntax(SyntaxKind.AnonymousObjectMemberDeclarator, nameEquals, expression, this.context);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public AnonymousObjectCreationExpressionSyntax AnonymousObjectCreationExpression(SyntaxToken newKeyword, SyntaxToken openBraceToken, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<AnonymousObjectMemberDeclaratorSyntax> initializers, SyntaxToken closeBraceToken)
    {
#if DEBUG
      if (newKeyword == null)
        throw new ArgumentNullException(nameof(newKeyword));
      switch (newKeyword.Kind)
      {
        case SyntaxKind.NewKeyword:
          break;
        default:
          throw new ArgumentException("newKeyword");
      }
      if (openBraceToken == null)
        throw new ArgumentNullException(nameof(openBraceToken));
      switch (openBraceToken.Kind)
      {
        case SyntaxKind.OpenBraceToken:
          break;
        default:
          throw new ArgumentException("openBraceToken");
      }
      if (closeBraceToken == null)
        throw new ArgumentNullException(nameof(closeBraceToken));
      switch (closeBraceToken.Kind)
      {
        case SyntaxKind.CloseBraceToken:
          break;
        default:
          throw new ArgumentException("closeBraceToken");
      }
#endif

      return new AnonymousObjectCreationExpressionSyntax(SyntaxKind.AnonymousObjectCreationExpression, newKeyword, openBraceToken, initializers.Node, closeBraceToken, this.context);
    }

    public ArrayCreationExpressionSyntax ArrayCreationExpression(SyntaxToken newKeyword, ArrayTypeSyntax type, InitializerExpressionSyntax initializer)
    {
#if DEBUG
      if (newKeyword == null)
        throw new ArgumentNullException(nameof(newKeyword));
      switch (newKeyword.Kind)
      {
        case SyntaxKind.NewKeyword:
          break;
        default:
          throw new ArgumentException("newKeyword");
      }
      if (type == null)
        throw new ArgumentNullException(nameof(type));
#endif

      int hash;
      var cached = CSharpSyntaxNodeCache.TryGetNode((int)SyntaxKind.ArrayCreationExpression, newKeyword, type, initializer, this.context, out hash);
      if (cached != null) return (ArrayCreationExpressionSyntax)cached;

      var result = new ArrayCreationExpressionSyntax(SyntaxKind.ArrayCreationExpression, newKeyword, type, initializer, this.context);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public ImplicitArrayCreationExpressionSyntax ImplicitArrayCreationExpression(SyntaxToken newKeyword, SyntaxToken openBracketToken, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SyntaxToken> commas, SyntaxToken closeBracketToken, InitializerExpressionSyntax initializer)
    {
#if DEBUG
      if (newKeyword == null)
        throw new ArgumentNullException(nameof(newKeyword));
      switch (newKeyword.Kind)
      {
        case SyntaxKind.NewKeyword:
          break;
        default:
          throw new ArgumentException("newKeyword");
      }
      if (openBracketToken == null)
        throw new ArgumentNullException(nameof(openBracketToken));
      switch (openBracketToken.Kind)
      {
        case SyntaxKind.OpenBracketToken:
          break;
        default:
          throw new ArgumentException("openBracketToken");
      }
      if (closeBracketToken == null)
        throw new ArgumentNullException(nameof(closeBracketToken));
      switch (closeBracketToken.Kind)
      {
        case SyntaxKind.CloseBracketToken:
          break;
        default:
          throw new ArgumentException("closeBracketToken");
      }
      if (initializer == null)
        throw new ArgumentNullException(nameof(initializer));
#endif

      return new ImplicitArrayCreationExpressionSyntax(SyntaxKind.ImplicitArrayCreationExpression, newKeyword, openBracketToken, commas.Node, closeBracketToken, initializer, this.context);
    }

    public StackAllocArrayCreationExpressionSyntax StackAllocArrayCreationExpression(SyntaxToken stackAllocKeyword, TypeSyntax type)
    {
#if DEBUG
      if (stackAllocKeyword == null)
        throw new ArgumentNullException(nameof(stackAllocKeyword));
      switch (stackAllocKeyword.Kind)
      {
        case SyntaxKind.StackAllocKeyword:
          break;
        default:
          throw new ArgumentException("stackAllocKeyword");
      }
      if (type == null)
        throw new ArgumentNullException(nameof(type));
#endif

      int hash;
      var cached = CSharpSyntaxNodeCache.TryGetNode((int)SyntaxKind.StackAllocArrayCreationExpression, stackAllocKeyword, type, this.context, out hash);
      if (cached != null) return (StackAllocArrayCreationExpressionSyntax)cached;

      var result = new StackAllocArrayCreationExpressionSyntax(SyntaxKind.StackAllocArrayCreationExpression, stackAllocKeyword, type, this.context);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public QueryExpressionSyntax QueryExpression(FromClauseSyntax fromClause, QueryBodySyntax body)
    {
#if DEBUG
      if (fromClause == null)
        throw new ArgumentNullException(nameof(fromClause));
      if (body == null)
        throw new ArgumentNullException(nameof(body));
#endif

      int hash;
      var cached = CSharpSyntaxNodeCache.TryGetNode((int)SyntaxKind.QueryExpression, fromClause, body, this.context, out hash);
      if (cached != null) return (QueryExpressionSyntax)cached;

      var result = new QueryExpressionSyntax(SyntaxKind.QueryExpression, fromClause, body, this.context);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public QueryBodySyntax QueryBody(Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<QueryClauseSyntax> clauses, SelectOrGroupClauseSyntax selectOrGroup, QueryContinuationSyntax continuation)
    {
#if DEBUG
      if (selectOrGroup == null)
        throw new ArgumentNullException(nameof(selectOrGroup));
#endif

      int hash;
      var cached = CSharpSyntaxNodeCache.TryGetNode((int)SyntaxKind.QueryBody, clauses.Node, selectOrGroup, continuation, this.context, out hash);
      if (cached != null) return (QueryBodySyntax)cached;

      var result = new QueryBodySyntax(SyntaxKind.QueryBody, clauses.Node, selectOrGroup, continuation, this.context);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public FromClauseSyntax FromClause(SyntaxToken fromKeyword, TypeSyntax type, SyntaxToken identifier, SyntaxToken inKeyword, ExpressionSyntax expression)
    {
#if DEBUG
      if (fromKeyword == null)
        throw new ArgumentNullException(nameof(fromKeyword));
      switch (fromKeyword.Kind)
      {
        case SyntaxKind.FromKeyword:
          break;
        default:
          throw new ArgumentException("fromKeyword");
      }
      if (identifier == null)
        throw new ArgumentNullException(nameof(identifier));
      switch (identifier.Kind)
      {
        case SyntaxKind.IdentifierToken:
          break;
        default:
          throw new ArgumentException("identifier");
      }
      if (inKeyword == null)
        throw new ArgumentNullException(nameof(inKeyword));
      switch (inKeyword.Kind)
      {
        case SyntaxKind.InKeyword:
          break;
        default:
          throw new ArgumentException("inKeyword");
      }
      if (expression == null)
        throw new ArgumentNullException(nameof(expression));
#endif

      return new FromClauseSyntax(SyntaxKind.FromClause, fromKeyword, type, identifier, inKeyword, expression, this.context);
    }

    public LetClauseSyntax LetClause(SyntaxToken letKeyword, SyntaxToken identifier, SyntaxToken equalsToken, ExpressionSyntax expression)
    {
#if DEBUG
      if (letKeyword == null)
        throw new ArgumentNullException(nameof(letKeyword));
      switch (letKeyword.Kind)
      {
        case SyntaxKind.LetKeyword:
          break;
        default:
          throw new ArgumentException("letKeyword");
      }
      if (identifier == null)
        throw new ArgumentNullException(nameof(identifier));
      switch (identifier.Kind)
      {
        case SyntaxKind.IdentifierToken:
          break;
        default:
          throw new ArgumentException("identifier");
      }
      if (equalsToken == null)
        throw new ArgumentNullException(nameof(equalsToken));
      switch (equalsToken.Kind)
      {
        case SyntaxKind.EqualsToken:
          break;
        default:
          throw new ArgumentException("equalsToken");
      }
      if (expression == null)
        throw new ArgumentNullException(nameof(expression));
#endif

      return new LetClauseSyntax(SyntaxKind.LetClause, letKeyword, identifier, equalsToken, expression, this.context);
    }

    public JoinClauseSyntax JoinClause(SyntaxToken joinKeyword, TypeSyntax type, SyntaxToken identifier, SyntaxToken inKeyword, ExpressionSyntax inExpression, SyntaxToken onKeyword, ExpressionSyntax leftExpression, SyntaxToken equalsKeyword, ExpressionSyntax rightExpression, JoinIntoClauseSyntax into)
    {
#if DEBUG
      if (joinKeyword == null)
        throw new ArgumentNullException(nameof(joinKeyword));
      switch (joinKeyword.Kind)
      {
        case SyntaxKind.JoinKeyword:
          break;
        default:
          throw new ArgumentException("joinKeyword");
      }
      if (identifier == null)
        throw new ArgumentNullException(nameof(identifier));
      switch (identifier.Kind)
      {
        case SyntaxKind.IdentifierToken:
          break;
        default:
          throw new ArgumentException("identifier");
      }
      if (inKeyword == null)
        throw new ArgumentNullException(nameof(inKeyword));
      switch (inKeyword.Kind)
      {
        case SyntaxKind.InKeyword:
          break;
        default:
          throw new ArgumentException("inKeyword");
      }
      if (inExpression == null)
        throw new ArgumentNullException(nameof(inExpression));
      if (onKeyword == null)
        throw new ArgumentNullException(nameof(onKeyword));
      switch (onKeyword.Kind)
      {
        case SyntaxKind.OnKeyword:
          break;
        default:
          throw new ArgumentException("onKeyword");
      }
      if (leftExpression == null)
        throw new ArgumentNullException(nameof(leftExpression));
      if (equalsKeyword == null)
        throw new ArgumentNullException(nameof(equalsKeyword));
      switch (equalsKeyword.Kind)
      {
        case SyntaxKind.EqualsKeyword:
          break;
        default:
          throw new ArgumentException("equalsKeyword");
      }
      if (rightExpression == null)
        throw new ArgumentNullException(nameof(rightExpression));
#endif

      return new JoinClauseSyntax(SyntaxKind.JoinClause, joinKeyword, type, identifier, inKeyword, inExpression, onKeyword, leftExpression, equalsKeyword, rightExpression, into, this.context);
    }

    public JoinIntoClauseSyntax JoinIntoClause(SyntaxToken intoKeyword, SyntaxToken identifier)
    {
#if DEBUG
      if (intoKeyword == null)
        throw new ArgumentNullException(nameof(intoKeyword));
      switch (intoKeyword.Kind)
      {
        case SyntaxKind.IntoKeyword:
          break;
        default:
          throw new ArgumentException("intoKeyword");
      }
      if (identifier == null)
        throw new ArgumentNullException(nameof(identifier));
      switch (identifier.Kind)
      {
        case SyntaxKind.IdentifierToken:
          break;
        default:
          throw new ArgumentException("identifier");
      }
#endif

      int hash;
      var cached = CSharpSyntaxNodeCache.TryGetNode((int)SyntaxKind.JoinIntoClause, intoKeyword, identifier, this.context, out hash);
      if (cached != null) return (JoinIntoClauseSyntax)cached;

      var result = new JoinIntoClauseSyntax(SyntaxKind.JoinIntoClause, intoKeyword, identifier, this.context);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public WhereClauseSyntax WhereClause(SyntaxToken whereKeyword, ExpressionSyntax condition)
    {
#if DEBUG
      if (whereKeyword == null)
        throw new ArgumentNullException(nameof(whereKeyword));
      switch (whereKeyword.Kind)
      {
        case SyntaxKind.WhereKeyword:
          break;
        default:
          throw new ArgumentException("whereKeyword");
      }
      if (condition == null)
        throw new ArgumentNullException(nameof(condition));
#endif

      int hash;
      var cached = CSharpSyntaxNodeCache.TryGetNode((int)SyntaxKind.WhereClause, whereKeyword, condition, this.context, out hash);
      if (cached != null) return (WhereClauseSyntax)cached;

      var result = new WhereClauseSyntax(SyntaxKind.WhereClause, whereKeyword, condition, this.context);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public OrderByClauseSyntax OrderByClause(SyntaxToken orderByKeyword, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<OrderingSyntax> orderings)
    {
#if DEBUG
      if (orderByKeyword == null)
        throw new ArgumentNullException(nameof(orderByKeyword));
      switch (orderByKeyword.Kind)
      {
        case SyntaxKind.OrderByKeyword:
          break;
        default:
          throw new ArgumentException("orderByKeyword");
      }
#endif

      int hash;
      var cached = CSharpSyntaxNodeCache.TryGetNode((int)SyntaxKind.OrderByClause, orderByKeyword, orderings.Node, this.context, out hash);
      if (cached != null) return (OrderByClauseSyntax)cached;

      var result = new OrderByClauseSyntax(SyntaxKind.OrderByClause, orderByKeyword, orderings.Node, this.context);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public OrderingSyntax Ordering(SyntaxKind kind, ExpressionSyntax expression, SyntaxToken ascendingOrDescendingKeyword)
    {
      switch (kind)
      {
        case SyntaxKind.AscendingOrdering:
        case SyntaxKind.DescendingOrdering:
          break;
        default:
          throw new ArgumentException("kind");
      }
#if DEBUG
      if (expression == null)
        throw new ArgumentNullException(nameof(expression));
      if (ascendingOrDescendingKeyword != null)
      {
      switch (ascendingOrDescendingKeyword.Kind)
      {
        case SyntaxKind.AscendingKeyword:
        case SyntaxKind.DescendingKeyword:
        case SyntaxKind.None:
          break;
        default:
          throw new ArgumentException("ascendingOrDescendingKeyword");
      }
      }
#endif

      int hash;
      var cached = CSharpSyntaxNodeCache.TryGetNode((int)kind, expression, ascendingOrDescendingKeyword, this.context, out hash);
      if (cached != null) return (OrderingSyntax)cached;

      var result = new OrderingSyntax(kind, expression, ascendingOrDescendingKeyword, this.context);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public SelectClauseSyntax SelectClause(SyntaxToken selectKeyword, ExpressionSyntax expression)
    {
#if DEBUG
      if (selectKeyword == null)
        throw new ArgumentNullException(nameof(selectKeyword));
      switch (selectKeyword.Kind)
      {
        case SyntaxKind.SelectKeyword:
          break;
        default:
          throw new ArgumentException("selectKeyword");
      }
      if (expression == null)
        throw new ArgumentNullException(nameof(expression));
#endif

      int hash;
      var cached = CSharpSyntaxNodeCache.TryGetNode((int)SyntaxKind.SelectClause, selectKeyword, expression, this.context, out hash);
      if (cached != null) return (SelectClauseSyntax)cached;

      var result = new SelectClauseSyntax(SyntaxKind.SelectClause, selectKeyword, expression, this.context);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public GroupClauseSyntax GroupClause(SyntaxToken groupKeyword, ExpressionSyntax groupExpression, SyntaxToken byKeyword, ExpressionSyntax byExpression)
    {
#if DEBUG
      if (groupKeyword == null)
        throw new ArgumentNullException(nameof(groupKeyword));
      switch (groupKeyword.Kind)
      {
        case SyntaxKind.GroupKeyword:
          break;
        default:
          throw new ArgumentException("groupKeyword");
      }
      if (groupExpression == null)
        throw new ArgumentNullException(nameof(groupExpression));
      if (byKeyword == null)
        throw new ArgumentNullException(nameof(byKeyword));
      switch (byKeyword.Kind)
      {
        case SyntaxKind.ByKeyword:
          break;
        default:
          throw new ArgumentException("byKeyword");
      }
      if (byExpression == null)
        throw new ArgumentNullException(nameof(byExpression));
#endif

      return new GroupClauseSyntax(SyntaxKind.GroupClause, groupKeyword, groupExpression, byKeyword, byExpression, this.context);
    }

    public QueryContinuationSyntax QueryContinuation(SyntaxToken intoKeyword, SyntaxToken identifier, QueryBodySyntax body)
    {
#if DEBUG
      if (intoKeyword == null)
        throw new ArgumentNullException(nameof(intoKeyword));
      switch (intoKeyword.Kind)
      {
        case SyntaxKind.IntoKeyword:
          break;
        default:
          throw new ArgumentException("intoKeyword");
      }
      if (identifier == null)
        throw new ArgumentNullException(nameof(identifier));
      switch (identifier.Kind)
      {
        case SyntaxKind.IdentifierToken:
          break;
        default:
          throw new ArgumentException("identifier");
      }
      if (body == null)
        throw new ArgumentNullException(nameof(body));
#endif

      int hash;
      var cached = CSharpSyntaxNodeCache.TryGetNode((int)SyntaxKind.QueryContinuation, intoKeyword, identifier, body, this.context, out hash);
      if (cached != null) return (QueryContinuationSyntax)cached;

      var result = new QueryContinuationSyntax(SyntaxKind.QueryContinuation, intoKeyword, identifier, body, this.context);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public OmittedArraySizeExpressionSyntax OmittedArraySizeExpression(SyntaxToken omittedArraySizeExpressionToken)
    {
#if DEBUG
      if (omittedArraySizeExpressionToken == null)
        throw new ArgumentNullException(nameof(omittedArraySizeExpressionToken));
      switch (omittedArraySizeExpressionToken.Kind)
      {
        case SyntaxKind.OmittedArraySizeExpressionToken:
          break;
        default:
          throw new ArgumentException("omittedArraySizeExpressionToken");
      }
#endif

      int hash;
      var cached = CSharpSyntaxNodeCache.TryGetNode((int)SyntaxKind.OmittedArraySizeExpression, omittedArraySizeExpressionToken, this.context, out hash);
      if (cached != null) return (OmittedArraySizeExpressionSyntax)cached;

      var result = new OmittedArraySizeExpressionSyntax(SyntaxKind.OmittedArraySizeExpression, omittedArraySizeExpressionToken, this.context);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public InterpolatedStringExpressionSyntax InterpolatedStringExpression(SyntaxToken stringStartToken, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<InterpolatedStringContentSyntax> contents, SyntaxToken stringEndToken)
    {
#if DEBUG
      if (stringStartToken == null)
        throw new ArgumentNullException(nameof(stringStartToken));
      switch (stringStartToken.Kind)
      {
        case SyntaxKind.InterpolatedStringStartToken:
        case SyntaxKind.InterpolatedVerbatimStringStartToken:
          break;
        default:
          throw new ArgumentException("stringStartToken");
      }
      if (stringEndToken == null)
        throw new ArgumentNullException(nameof(stringEndToken));
      switch (stringEndToken.Kind)
      {
        case SyntaxKind.InterpolatedStringEndToken:
          break;
        default:
          throw new ArgumentException("stringEndToken");
      }
#endif

      int hash;
      var cached = CSharpSyntaxNodeCache.TryGetNode((int)SyntaxKind.InterpolatedStringExpression, stringStartToken, contents.Node, stringEndToken, this.context, out hash);
      if (cached != null) return (InterpolatedStringExpressionSyntax)cached;

      var result = new InterpolatedStringExpressionSyntax(SyntaxKind.InterpolatedStringExpression, stringStartToken, contents.Node, stringEndToken, this.context);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public IsPatternExpressionSyntax IsPatternExpression(ExpressionSyntax expression, SyntaxToken isKeyword, PatternSyntax pattern)
    {
#if DEBUG
      if (expression == null)
        throw new ArgumentNullException(nameof(expression));
      if (isKeyword == null)
        throw new ArgumentNullException(nameof(isKeyword));
      switch (isKeyword.Kind)
      {
        case SyntaxKind.IsKeyword:
          break;
        default:
          throw new ArgumentException("isKeyword");
      }
      if (pattern == null)
        throw new ArgumentNullException(nameof(pattern));
#endif

      int hash;
      var cached = CSharpSyntaxNodeCache.TryGetNode((int)SyntaxKind.IsPatternExpression, expression, isKeyword, pattern, this.context, out hash);
      if (cached != null) return (IsPatternExpressionSyntax)cached;

      var result = new IsPatternExpressionSyntax(SyntaxKind.IsPatternExpression, expression, isKeyword, pattern, this.context);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public ThrowExpressionSyntax ThrowExpression(SyntaxToken throwKeyword, ExpressionSyntax expression)
    {
#if DEBUG
      if (throwKeyword == null)
        throw new ArgumentNullException(nameof(throwKeyword));
      switch (throwKeyword.Kind)
      {
        case SyntaxKind.ThrowKeyword:
          break;
        default:
          throw new ArgumentException("throwKeyword");
      }
      if (expression == null)
        throw new ArgumentNullException(nameof(expression));
#endif

      int hash;
      var cached = CSharpSyntaxNodeCache.TryGetNode((int)SyntaxKind.ThrowExpression, throwKeyword, expression, this.context, out hash);
      if (cached != null) return (ThrowExpressionSyntax)cached;

      var result = new ThrowExpressionSyntax(SyntaxKind.ThrowExpression, throwKeyword, expression, this.context);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public WhenClauseSyntax WhenClause(SyntaxToken whenKeyword, ExpressionSyntax condition)
    {
#if DEBUG
      if (whenKeyword == null)
        throw new ArgumentNullException(nameof(whenKeyword));
      switch (whenKeyword.Kind)
      {
        case SyntaxKind.WhenKeyword:
          break;
        default:
          throw new ArgumentException("whenKeyword");
      }
      if (condition == null)
        throw new ArgumentNullException(nameof(condition));
#endif

      int hash;
      var cached = CSharpSyntaxNodeCache.TryGetNode((int)SyntaxKind.WhenClause, whenKeyword, condition, this.context, out hash);
      if (cached != null) return (WhenClauseSyntax)cached;

      var result = new WhenClauseSyntax(SyntaxKind.WhenClause, whenKeyword, condition, this.context);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public DeclarationPatternSyntax DeclarationPattern(TypeSyntax type, VariableDesignationSyntax designation)
    {
#if DEBUG
      if (type == null)
        throw new ArgumentNullException(nameof(type));
      if (designation == null)
        throw new ArgumentNullException(nameof(designation));
#endif

      int hash;
      var cached = CSharpSyntaxNodeCache.TryGetNode((int)SyntaxKind.DeclarationPattern, type, designation, this.context, out hash);
      if (cached != null) return (DeclarationPatternSyntax)cached;

      var result = new DeclarationPatternSyntax(SyntaxKind.DeclarationPattern, type, designation, this.context);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public ConstantPatternSyntax ConstantPattern(ExpressionSyntax expression)
    {
#if DEBUG
      if (expression == null)
        throw new ArgumentNullException(nameof(expression));
#endif

      int hash;
      var cached = CSharpSyntaxNodeCache.TryGetNode((int)SyntaxKind.ConstantPattern, expression, this.context, out hash);
      if (cached != null) return (ConstantPatternSyntax)cached;

      var result = new ConstantPatternSyntax(SyntaxKind.ConstantPattern, expression, this.context);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public InterpolatedStringTextSyntax InterpolatedStringText(SyntaxToken textToken)
    {
#if DEBUG
      if (textToken == null)
        throw new ArgumentNullException(nameof(textToken));
      switch (textToken.Kind)
      {
        case SyntaxKind.InterpolatedStringTextToken:
          break;
        default:
          throw new ArgumentException("textToken");
      }
#endif

      int hash;
      var cached = CSharpSyntaxNodeCache.TryGetNode((int)SyntaxKind.InterpolatedStringText, textToken, this.context, out hash);
      if (cached != null) return (InterpolatedStringTextSyntax)cached;

      var result = new InterpolatedStringTextSyntax(SyntaxKind.InterpolatedStringText, textToken, this.context);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public InterpolationSyntax Interpolation(SyntaxToken openBraceToken, ExpressionSyntax expression, InterpolationAlignmentClauseSyntax alignmentClause, InterpolationFormatClauseSyntax formatClause, SyntaxToken closeBraceToken)
    {
#if DEBUG
      if (openBraceToken == null)
        throw new ArgumentNullException(nameof(openBraceToken));
      switch (openBraceToken.Kind)
      {
        case SyntaxKind.OpenBraceToken:
          break;
        default:
          throw new ArgumentException("openBraceToken");
      }
      if (expression == null)
        throw new ArgumentNullException(nameof(expression));
      if (closeBraceToken == null)
        throw new ArgumentNullException(nameof(closeBraceToken));
      switch (closeBraceToken.Kind)
      {
        case SyntaxKind.CloseBraceToken:
          break;
        default:
          throw new ArgumentException("closeBraceToken");
      }
#endif

      return new InterpolationSyntax(SyntaxKind.Interpolation, openBraceToken, expression, alignmentClause, formatClause, closeBraceToken, this.context);
    }

    public InterpolationAlignmentClauseSyntax InterpolationAlignmentClause(SyntaxToken commaToken, ExpressionSyntax value)
    {
#if DEBUG
      if (commaToken == null)
        throw new ArgumentNullException(nameof(commaToken));
      if (value == null)
        throw new ArgumentNullException(nameof(value));
#endif

      int hash;
      var cached = CSharpSyntaxNodeCache.TryGetNode((int)SyntaxKind.InterpolationAlignmentClause, commaToken, value, this.context, out hash);
      if (cached != null) return (InterpolationAlignmentClauseSyntax)cached;

      var result = new InterpolationAlignmentClauseSyntax(SyntaxKind.InterpolationAlignmentClause, commaToken, value, this.context);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public InterpolationFormatClauseSyntax InterpolationFormatClause(SyntaxToken colonToken, SyntaxToken formatStringToken)
    {
#if DEBUG
      if (colonToken == null)
        throw new ArgumentNullException(nameof(colonToken));
      if (formatStringToken == null)
        throw new ArgumentNullException(nameof(formatStringToken));
      switch (formatStringToken.Kind)
      {
        case SyntaxKind.InterpolatedStringTextToken:
          break;
        default:
          throw new ArgumentException("formatStringToken");
      }
#endif

      int hash;
      var cached = CSharpSyntaxNodeCache.TryGetNode((int)SyntaxKind.InterpolationFormatClause, colonToken, formatStringToken, this.context, out hash);
      if (cached != null) return (InterpolationFormatClauseSyntax)cached;

      var result = new InterpolationFormatClauseSyntax(SyntaxKind.InterpolationFormatClause, colonToken, formatStringToken, this.context);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public GlobalStatementSyntax GlobalStatement(StatementSyntax statement)
    {
#if DEBUG
      if (statement == null)
        throw new ArgumentNullException(nameof(statement));
#endif

      int hash;
      var cached = CSharpSyntaxNodeCache.TryGetNode((int)SyntaxKind.GlobalStatement, statement, this.context, out hash);
      if (cached != null) return (GlobalStatementSyntax)cached;

      var result = new GlobalStatementSyntax(SyntaxKind.GlobalStatement, statement, this.context);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public BlockSyntax Block(SyntaxToken openBraceToken, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<StatementSyntax> statements, SyntaxToken closeBraceToken)
    {
#if DEBUG
      if (openBraceToken == null)
        throw new ArgumentNullException(nameof(openBraceToken));
      switch (openBraceToken.Kind)
      {
        case SyntaxKind.OpenBraceToken:
          break;
        default:
          throw new ArgumentException("openBraceToken");
      }
      if (closeBraceToken == null)
        throw new ArgumentNullException(nameof(closeBraceToken));
      switch (closeBraceToken.Kind)
      {
        case SyntaxKind.CloseBraceToken:
          break;
        default:
          throw new ArgumentException("closeBraceToken");
      }
#endif

      int hash;
      var cached = CSharpSyntaxNodeCache.TryGetNode((int)SyntaxKind.Block, openBraceToken, statements.Node, closeBraceToken, this.context, out hash);
      if (cached != null) return (BlockSyntax)cached;

      var result = new BlockSyntax(SyntaxKind.Block, openBraceToken, statements.Node, closeBraceToken, this.context);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public LocalFunctionStatementSyntax LocalFunctionStatement(Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SyntaxToken> modifiers, TypeSyntax returnType, SyntaxToken identifier, TypeParameterListSyntax typeParameterList, ParameterListSyntax parameterList, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<TypeParameterConstraintClauseSyntax> constraintClauses, BlockSyntax body, ArrowExpressionClauseSyntax expressionBody, SyntaxToken semicolonToken)
    {
#if DEBUG
      if (returnType == null)
        throw new ArgumentNullException(nameof(returnType));
      if (identifier == null)
        throw new ArgumentNullException(nameof(identifier));
      switch (identifier.Kind)
      {
        case SyntaxKind.IdentifierToken:
          break;
        default:
          throw new ArgumentException("identifier");
      }
      if (parameterList == null)
        throw new ArgumentNullException(nameof(parameterList));
      if (semicolonToken != null)
      {
      switch (semicolonToken.Kind)
      {
        case SyntaxKind.SemicolonToken:
        case SyntaxKind.None:
          break;
        default:
          throw new ArgumentException("semicolonToken");
      }
      }
#endif

      return new LocalFunctionStatementSyntax(SyntaxKind.LocalFunctionStatement, modifiers.Node, returnType, identifier, typeParameterList, parameterList, constraintClauses.Node, body, expressionBody, semicolonToken, this.context);
    }

    public LocalDeclarationStatementSyntax LocalDeclarationStatement(Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SyntaxToken> modifiers, VariableDeclarationSyntax declaration, SyntaxToken semicolonToken)
    {
#if DEBUG
      if (declaration == null)
        throw new ArgumentNullException(nameof(declaration));
      if (semicolonToken == null)
        throw new ArgumentNullException(nameof(semicolonToken));
      switch (semicolonToken.Kind)
      {
        case SyntaxKind.SemicolonToken:
          break;
        default:
          throw new ArgumentException("semicolonToken");
      }
#endif

      int hash;
      var cached = CSharpSyntaxNodeCache.TryGetNode((int)SyntaxKind.LocalDeclarationStatement, modifiers.Node, declaration, semicolonToken, this.context, out hash);
      if (cached != null) return (LocalDeclarationStatementSyntax)cached;

      var result = new LocalDeclarationStatementSyntax(SyntaxKind.LocalDeclarationStatement, modifiers.Node, declaration, semicolonToken, this.context);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public VariableDeclarationSyntax VariableDeclaration(TypeSyntax type, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<VariableDeclaratorSyntax> variables)
    {
#if DEBUG
      if (type == null)
        throw new ArgumentNullException(nameof(type));
#endif

      int hash;
      var cached = CSharpSyntaxNodeCache.TryGetNode((int)SyntaxKind.VariableDeclaration, type, variables.Node, this.context, out hash);
      if (cached != null) return (VariableDeclarationSyntax)cached;

      var result = new VariableDeclarationSyntax(SyntaxKind.VariableDeclaration, type, variables.Node, this.context);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public VariableDeclaratorSyntax VariableDeclarator(SyntaxToken identifier, BracketedArgumentListSyntax argumentList, EqualsValueClauseSyntax initializer)
    {
#if DEBUG
      if (identifier == null)
        throw new ArgumentNullException(nameof(identifier));
      switch (identifier.Kind)
      {
        case SyntaxKind.IdentifierToken:
          break;
        default:
          throw new ArgumentException("identifier");
      }
#endif

      int hash;
      var cached = CSharpSyntaxNodeCache.TryGetNode((int)SyntaxKind.VariableDeclarator, identifier, argumentList, initializer, this.context, out hash);
      if (cached != null) return (VariableDeclaratorSyntax)cached;

      var result = new VariableDeclaratorSyntax(SyntaxKind.VariableDeclarator, identifier, argumentList, initializer, this.context);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public EqualsValueClauseSyntax EqualsValueClause(SyntaxToken equalsToken, ExpressionSyntax value)
    {
#if DEBUG
      if (equalsToken == null)
        throw new ArgumentNullException(nameof(equalsToken));
      switch (equalsToken.Kind)
      {
        case SyntaxKind.EqualsToken:
          break;
        default:
          throw new ArgumentException("equalsToken");
      }
      if (value == null)
        throw new ArgumentNullException(nameof(value));
#endif

      int hash;
      var cached = CSharpSyntaxNodeCache.TryGetNode((int)SyntaxKind.EqualsValueClause, equalsToken, value, this.context, out hash);
      if (cached != null) return (EqualsValueClauseSyntax)cached;

      var result = new EqualsValueClauseSyntax(SyntaxKind.EqualsValueClause, equalsToken, value, this.context);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public SingleVariableDesignationSyntax SingleVariableDesignation(SyntaxToken identifier)
    {
#if DEBUG
      if (identifier == null)
        throw new ArgumentNullException(nameof(identifier));
      switch (identifier.Kind)
      {
        case SyntaxKind.IdentifierToken:
          break;
        default:
          throw new ArgumentException("identifier");
      }
#endif

      int hash;
      var cached = CSharpSyntaxNodeCache.TryGetNode((int)SyntaxKind.SingleVariableDesignation, identifier, this.context, out hash);
      if (cached != null) return (SingleVariableDesignationSyntax)cached;

      var result = new SingleVariableDesignationSyntax(SyntaxKind.SingleVariableDesignation, identifier, this.context);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public DiscardDesignationSyntax DiscardDesignation(SyntaxToken underscoreToken)
    {
#if DEBUG
      if (underscoreToken == null)
        throw new ArgumentNullException(nameof(underscoreToken));
      switch (underscoreToken.Kind)
      {
        case SyntaxKind.UnderscoreToken:
          break;
        default:
          throw new ArgumentException("underscoreToken");
      }
#endif

      int hash;
      var cached = CSharpSyntaxNodeCache.TryGetNode((int)SyntaxKind.DiscardDesignation, underscoreToken, this.context, out hash);
      if (cached != null) return (DiscardDesignationSyntax)cached;

      var result = new DiscardDesignationSyntax(SyntaxKind.DiscardDesignation, underscoreToken, this.context);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public ParenthesizedVariableDesignationSyntax ParenthesizedVariableDesignation(SyntaxToken openParenToken, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<VariableDesignationSyntax> variables, SyntaxToken closeParenToken)
    {
#if DEBUG
      if (openParenToken == null)
        throw new ArgumentNullException(nameof(openParenToken));
      switch (openParenToken.Kind)
      {
        case SyntaxKind.OpenParenToken:
          break;
        default:
          throw new ArgumentException("openParenToken");
      }
      if (closeParenToken == null)
        throw new ArgumentNullException(nameof(closeParenToken));
      switch (closeParenToken.Kind)
      {
        case SyntaxKind.CloseParenToken:
          break;
        default:
          throw new ArgumentException("closeParenToken");
      }
#endif

      int hash;
      var cached = CSharpSyntaxNodeCache.TryGetNode((int)SyntaxKind.ParenthesizedVariableDesignation, openParenToken, variables.Node, closeParenToken, this.context, out hash);
      if (cached != null) return (ParenthesizedVariableDesignationSyntax)cached;

      var result = new ParenthesizedVariableDesignationSyntax(SyntaxKind.ParenthesizedVariableDesignation, openParenToken, variables.Node, closeParenToken, this.context);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public ExpressionStatementSyntax ExpressionStatement(ExpressionSyntax expression, SyntaxToken semicolonToken)
    {
#if DEBUG
      if (expression == null)
        throw new ArgumentNullException(nameof(expression));
      if (semicolonToken == null)
        throw new ArgumentNullException(nameof(semicolonToken));
      switch (semicolonToken.Kind)
      {
        case SyntaxKind.SemicolonToken:
          break;
        default:
          throw new ArgumentException("semicolonToken");
      }
#endif

      int hash;
      var cached = CSharpSyntaxNodeCache.TryGetNode((int)SyntaxKind.ExpressionStatement, expression, semicolonToken, this.context, out hash);
      if (cached != null) return (ExpressionStatementSyntax)cached;

      var result = new ExpressionStatementSyntax(SyntaxKind.ExpressionStatement, expression, semicolonToken, this.context);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public EmptyStatementSyntax EmptyStatement(SyntaxToken semicolonToken)
    {
#if DEBUG
      if (semicolonToken == null)
        throw new ArgumentNullException(nameof(semicolonToken));
      switch (semicolonToken.Kind)
      {
        case SyntaxKind.SemicolonToken:
          break;
        default:
          throw new ArgumentException("semicolonToken");
      }
#endif

      int hash;
      var cached = CSharpSyntaxNodeCache.TryGetNode((int)SyntaxKind.EmptyStatement, semicolonToken, this.context, out hash);
      if (cached != null) return (EmptyStatementSyntax)cached;

      var result = new EmptyStatementSyntax(SyntaxKind.EmptyStatement, semicolonToken, this.context);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public LabeledStatementSyntax LabeledStatement(SyntaxToken identifier, SyntaxToken colonToken, StatementSyntax statement)
    {
#if DEBUG
      if (identifier == null)
        throw new ArgumentNullException(nameof(identifier));
      switch (identifier.Kind)
      {
        case SyntaxKind.IdentifierToken:
          break;
        default:
          throw new ArgumentException("identifier");
      }
      if (colonToken == null)
        throw new ArgumentNullException(nameof(colonToken));
      switch (colonToken.Kind)
      {
        case SyntaxKind.ColonToken:
          break;
        default:
          throw new ArgumentException("colonToken");
      }
      if (statement == null)
        throw new ArgumentNullException(nameof(statement));
#endif

      int hash;
      var cached = CSharpSyntaxNodeCache.TryGetNode((int)SyntaxKind.LabeledStatement, identifier, colonToken, statement, this.context, out hash);
      if (cached != null) return (LabeledStatementSyntax)cached;

      var result = new LabeledStatementSyntax(SyntaxKind.LabeledStatement, identifier, colonToken, statement, this.context);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public GotoStatementSyntax GotoStatement(SyntaxKind kind, SyntaxToken gotoKeyword, SyntaxToken caseOrDefaultKeyword, ExpressionSyntax expression, SyntaxToken semicolonToken)
    {
      switch (kind)
      {
        case SyntaxKind.GotoStatement:
        case SyntaxKind.GotoCaseStatement:
        case SyntaxKind.GotoDefaultStatement:
          break;
        default:
          throw new ArgumentException("kind");
      }
#if DEBUG
      if (gotoKeyword == null)
        throw new ArgumentNullException(nameof(gotoKeyword));
      switch (gotoKeyword.Kind)
      {
        case SyntaxKind.GotoKeyword:
          break;
        default:
          throw new ArgumentException("gotoKeyword");
      }
      if (caseOrDefaultKeyword != null)
      {
      switch (caseOrDefaultKeyword.Kind)
      {
        case SyntaxKind.CaseKeyword:
        case SyntaxKind.DefaultKeyword:
        case SyntaxKind.None:
          break;
        default:
          throw new ArgumentException("caseOrDefaultKeyword");
      }
      }
      if (semicolonToken == null)
        throw new ArgumentNullException(nameof(semicolonToken));
      switch (semicolonToken.Kind)
      {
        case SyntaxKind.SemicolonToken:
          break;
        default:
          throw new ArgumentException("semicolonToken");
      }
#endif

      return new GotoStatementSyntax(kind, gotoKeyword, caseOrDefaultKeyword, expression, semicolonToken, this.context);
    }

    public BreakStatementSyntax BreakStatement(SyntaxToken breakKeyword, SyntaxToken semicolonToken)
    {
#if DEBUG
      if (breakKeyword == null)
        throw new ArgumentNullException(nameof(breakKeyword));
      switch (breakKeyword.Kind)
      {
        case SyntaxKind.BreakKeyword:
          break;
        default:
          throw new ArgumentException("breakKeyword");
      }
      if (semicolonToken == null)
        throw new ArgumentNullException(nameof(semicolonToken));
      switch (semicolonToken.Kind)
      {
        case SyntaxKind.SemicolonToken:
          break;
        default:
          throw new ArgumentException("semicolonToken");
      }
#endif

      int hash;
      var cached = CSharpSyntaxNodeCache.TryGetNode((int)SyntaxKind.BreakStatement, breakKeyword, semicolonToken, this.context, out hash);
      if (cached != null) return (BreakStatementSyntax)cached;

      var result = new BreakStatementSyntax(SyntaxKind.BreakStatement, breakKeyword, semicolonToken, this.context);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public ContinueStatementSyntax ContinueStatement(SyntaxToken continueKeyword, SyntaxToken semicolonToken)
    {
#if DEBUG
      if (continueKeyword == null)
        throw new ArgumentNullException(nameof(continueKeyword));
      switch (continueKeyword.Kind)
      {
        case SyntaxKind.ContinueKeyword:
          break;
        default:
          throw new ArgumentException("continueKeyword");
      }
      if (semicolonToken == null)
        throw new ArgumentNullException(nameof(semicolonToken));
      switch (semicolonToken.Kind)
      {
        case SyntaxKind.SemicolonToken:
          break;
        default:
          throw new ArgumentException("semicolonToken");
      }
#endif

      int hash;
      var cached = CSharpSyntaxNodeCache.TryGetNode((int)SyntaxKind.ContinueStatement, continueKeyword, semicolonToken, this.context, out hash);
      if (cached != null) return (ContinueStatementSyntax)cached;

      var result = new ContinueStatementSyntax(SyntaxKind.ContinueStatement, continueKeyword, semicolonToken, this.context);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public ReturnStatementSyntax ReturnStatement(SyntaxToken returnKeyword, ExpressionSyntax expression, SyntaxToken semicolonToken)
    {
#if DEBUG
      if (returnKeyword == null)
        throw new ArgumentNullException(nameof(returnKeyword));
      switch (returnKeyword.Kind)
      {
        case SyntaxKind.ReturnKeyword:
          break;
        default:
          throw new ArgumentException("returnKeyword");
      }
      if (semicolonToken == null)
        throw new ArgumentNullException(nameof(semicolonToken));
      switch (semicolonToken.Kind)
      {
        case SyntaxKind.SemicolonToken:
          break;
        default:
          throw new ArgumentException("semicolonToken");
      }
#endif

      int hash;
      var cached = CSharpSyntaxNodeCache.TryGetNode((int)SyntaxKind.ReturnStatement, returnKeyword, expression, semicolonToken, this.context, out hash);
      if (cached != null) return (ReturnStatementSyntax)cached;

      var result = new ReturnStatementSyntax(SyntaxKind.ReturnStatement, returnKeyword, expression, semicolonToken, this.context);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public ThrowStatementSyntax ThrowStatement(SyntaxToken throwKeyword, ExpressionSyntax expression, SyntaxToken semicolonToken)
    {
#if DEBUG
      if (throwKeyword == null)
        throw new ArgumentNullException(nameof(throwKeyword));
      switch (throwKeyword.Kind)
      {
        case SyntaxKind.ThrowKeyword:
          break;
        default:
          throw new ArgumentException("throwKeyword");
      }
      if (semicolonToken == null)
        throw new ArgumentNullException(nameof(semicolonToken));
      switch (semicolonToken.Kind)
      {
        case SyntaxKind.SemicolonToken:
          break;
        default:
          throw new ArgumentException("semicolonToken");
      }
#endif

      int hash;
      var cached = CSharpSyntaxNodeCache.TryGetNode((int)SyntaxKind.ThrowStatement, throwKeyword, expression, semicolonToken, this.context, out hash);
      if (cached != null) return (ThrowStatementSyntax)cached;

      var result = new ThrowStatementSyntax(SyntaxKind.ThrowStatement, throwKeyword, expression, semicolonToken, this.context);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public YieldStatementSyntax YieldStatement(SyntaxKind kind, SyntaxToken yieldKeyword, SyntaxToken returnOrBreakKeyword, ExpressionSyntax expression, SyntaxToken semicolonToken)
    {
      switch (kind)
      {
        case SyntaxKind.YieldReturnStatement:
        case SyntaxKind.YieldBreakStatement:
          break;
        default:
          throw new ArgumentException("kind");
      }
#if DEBUG
      if (yieldKeyword == null)
        throw new ArgumentNullException(nameof(yieldKeyword));
      switch (yieldKeyword.Kind)
      {
        case SyntaxKind.YieldKeyword:
          break;
        default:
          throw new ArgumentException("yieldKeyword");
      }
      if (returnOrBreakKeyword == null)
        throw new ArgumentNullException(nameof(returnOrBreakKeyword));
      switch (returnOrBreakKeyword.Kind)
      {
        case SyntaxKind.ReturnKeyword:
        case SyntaxKind.BreakKeyword:
          break;
        default:
          throw new ArgumentException("returnOrBreakKeyword");
      }
      if (semicolonToken == null)
        throw new ArgumentNullException(nameof(semicolonToken));
      switch (semicolonToken.Kind)
      {
        case SyntaxKind.SemicolonToken:
          break;
        default:
          throw new ArgumentException("semicolonToken");
      }
#endif

      return new YieldStatementSyntax(kind, yieldKeyword, returnOrBreakKeyword, expression, semicolonToken, this.context);
    }

    public WhileStatementSyntax WhileStatement(SyntaxToken whileKeyword, SyntaxToken openParenToken, ExpressionSyntax condition, SyntaxToken closeParenToken, StatementSyntax statement)
    {
#if DEBUG
      if (whileKeyword == null)
        throw new ArgumentNullException(nameof(whileKeyword));
      switch (whileKeyword.Kind)
      {
        case SyntaxKind.WhileKeyword:
          break;
        default:
          throw new ArgumentException("whileKeyword");
      }
      if (openParenToken == null)
        throw new ArgumentNullException(nameof(openParenToken));
      switch (openParenToken.Kind)
      {
        case SyntaxKind.OpenParenToken:
          break;
        default:
          throw new ArgumentException("openParenToken");
      }
      if (condition == null)
        throw new ArgumentNullException(nameof(condition));
      if (closeParenToken == null)
        throw new ArgumentNullException(nameof(closeParenToken));
      switch (closeParenToken.Kind)
      {
        case SyntaxKind.CloseParenToken:
          break;
        default:
          throw new ArgumentException("closeParenToken");
      }
      if (statement == null)
        throw new ArgumentNullException(nameof(statement));
#endif

      return new WhileStatementSyntax(SyntaxKind.WhileStatement, whileKeyword, openParenToken, condition, closeParenToken, statement, this.context);
    }

    public DoStatementSyntax DoStatement(SyntaxToken doKeyword, StatementSyntax statement, SyntaxToken whileKeyword, SyntaxToken openParenToken, ExpressionSyntax condition, SyntaxToken closeParenToken, SyntaxToken semicolonToken)
    {
#if DEBUG
      if (doKeyword == null)
        throw new ArgumentNullException(nameof(doKeyword));
      switch (doKeyword.Kind)
      {
        case SyntaxKind.DoKeyword:
          break;
        default:
          throw new ArgumentException("doKeyword");
      }
      if (statement == null)
        throw new ArgumentNullException(nameof(statement));
      if (whileKeyword == null)
        throw new ArgumentNullException(nameof(whileKeyword));
      switch (whileKeyword.Kind)
      {
        case SyntaxKind.WhileKeyword:
          break;
        default:
          throw new ArgumentException("whileKeyword");
      }
      if (openParenToken == null)
        throw new ArgumentNullException(nameof(openParenToken));
      switch (openParenToken.Kind)
      {
        case SyntaxKind.OpenParenToken:
          break;
        default:
          throw new ArgumentException("openParenToken");
      }
      if (condition == null)
        throw new ArgumentNullException(nameof(condition));
      if (closeParenToken == null)
        throw new ArgumentNullException(nameof(closeParenToken));
      switch (closeParenToken.Kind)
      {
        case SyntaxKind.CloseParenToken:
          break;
        default:
          throw new ArgumentException("closeParenToken");
      }
      if (semicolonToken == null)
        throw new ArgumentNullException(nameof(semicolonToken));
      switch (semicolonToken.Kind)
      {
        case SyntaxKind.SemicolonToken:
          break;
        default:
          throw new ArgumentException("semicolonToken");
      }
#endif

      return new DoStatementSyntax(SyntaxKind.DoStatement, doKeyword, statement, whileKeyword, openParenToken, condition, closeParenToken, semicolonToken, this.context);
    }

    public ForStatementSyntax ForStatement(SyntaxToken forKeyword, SyntaxToken openParenToken, VariableDeclarationSyntax declaration, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<ExpressionSyntax> initializers, SyntaxToken firstSemicolonToken, ExpressionSyntax condition, SyntaxToken secondSemicolonToken, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<ExpressionSyntax> incrementors, SyntaxToken closeParenToken, StatementSyntax statement)
    {
#if DEBUG
      if (forKeyword == null)
        throw new ArgumentNullException(nameof(forKeyword));
      switch (forKeyword.Kind)
      {
        case SyntaxKind.ForKeyword:
          break;
        default:
          throw new ArgumentException("forKeyword");
      }
      if (openParenToken == null)
        throw new ArgumentNullException(nameof(openParenToken));
      switch (openParenToken.Kind)
      {
        case SyntaxKind.OpenParenToken:
          break;
        default:
          throw new ArgumentException("openParenToken");
      }
      if (firstSemicolonToken == null)
        throw new ArgumentNullException(nameof(firstSemicolonToken));
      switch (firstSemicolonToken.Kind)
      {
        case SyntaxKind.SemicolonToken:
          break;
        default:
          throw new ArgumentException("firstSemicolonToken");
      }
      if (secondSemicolonToken == null)
        throw new ArgumentNullException(nameof(secondSemicolonToken));
      switch (secondSemicolonToken.Kind)
      {
        case SyntaxKind.SemicolonToken:
          break;
        default:
          throw new ArgumentException("secondSemicolonToken");
      }
      if (closeParenToken == null)
        throw new ArgumentNullException(nameof(closeParenToken));
      switch (closeParenToken.Kind)
      {
        case SyntaxKind.CloseParenToken:
          break;
        default:
          throw new ArgumentException("closeParenToken");
      }
      if (statement == null)
        throw new ArgumentNullException(nameof(statement));
#endif

      return new ForStatementSyntax(SyntaxKind.ForStatement, forKeyword, openParenToken, declaration, initializers.Node, firstSemicolonToken, condition, secondSemicolonToken, incrementors.Node, closeParenToken, statement, this.context);
    }

    public ForEachStatementSyntax ForEachStatement(SyntaxToken forEachKeyword, SyntaxToken openParenToken, TypeSyntax type, SyntaxToken identifier, SyntaxToken inKeyword, ExpressionSyntax expression, SyntaxToken closeParenToken, StatementSyntax statement)
    {
#if DEBUG
      if (forEachKeyword == null)
        throw new ArgumentNullException(nameof(forEachKeyword));
      switch (forEachKeyword.Kind)
      {
        case SyntaxKind.ForEachKeyword:
          break;
        default:
          throw new ArgumentException("forEachKeyword");
      }
      if (openParenToken == null)
        throw new ArgumentNullException(nameof(openParenToken));
      switch (openParenToken.Kind)
      {
        case SyntaxKind.OpenParenToken:
          break;
        default:
          throw new ArgumentException("openParenToken");
      }
      if (type == null)
        throw new ArgumentNullException(nameof(type));
      if (identifier == null)
        throw new ArgumentNullException(nameof(identifier));
      switch (identifier.Kind)
      {
        case SyntaxKind.IdentifierToken:
          break;
        default:
          throw new ArgumentException("identifier");
      }
      if (inKeyword == null)
        throw new ArgumentNullException(nameof(inKeyword));
      switch (inKeyword.Kind)
      {
        case SyntaxKind.InKeyword:
          break;
        default:
          throw new ArgumentException("inKeyword");
      }
      if (expression == null)
        throw new ArgumentNullException(nameof(expression));
      if (closeParenToken == null)
        throw new ArgumentNullException(nameof(closeParenToken));
      switch (closeParenToken.Kind)
      {
        case SyntaxKind.CloseParenToken:
          break;
        default:
          throw new ArgumentException("closeParenToken");
      }
      if (statement == null)
        throw new ArgumentNullException(nameof(statement));
#endif

      return new ForEachStatementSyntax(SyntaxKind.ForEachStatement, forEachKeyword, openParenToken, type, identifier, inKeyword, expression, closeParenToken, statement, this.context);
    }

    public ForEachVariableStatementSyntax ForEachVariableStatement(SyntaxToken forEachKeyword, SyntaxToken openParenToken, ExpressionSyntax variable, SyntaxToken inKeyword, ExpressionSyntax expression, SyntaxToken closeParenToken, StatementSyntax statement)
    {
#if DEBUG
      if (forEachKeyword == null)
        throw new ArgumentNullException(nameof(forEachKeyword));
      switch (forEachKeyword.Kind)
      {
        case SyntaxKind.ForEachKeyword:
          break;
        default:
          throw new ArgumentException("forEachKeyword");
      }
      if (openParenToken == null)
        throw new ArgumentNullException(nameof(openParenToken));
      switch (openParenToken.Kind)
      {
        case SyntaxKind.OpenParenToken:
          break;
        default:
          throw new ArgumentException("openParenToken");
      }
      if (variable == null)
        throw new ArgumentNullException(nameof(variable));
      if (inKeyword == null)
        throw new ArgumentNullException(nameof(inKeyword));
      switch (inKeyword.Kind)
      {
        case SyntaxKind.InKeyword:
          break;
        default:
          throw new ArgumentException("inKeyword");
      }
      if (expression == null)
        throw new ArgumentNullException(nameof(expression));
      if (closeParenToken == null)
        throw new ArgumentNullException(nameof(closeParenToken));
      switch (closeParenToken.Kind)
      {
        case SyntaxKind.CloseParenToken:
          break;
        default:
          throw new ArgumentException("closeParenToken");
      }
      if (statement == null)
        throw new ArgumentNullException(nameof(statement));
#endif

      return new ForEachVariableStatementSyntax(SyntaxKind.ForEachVariableStatement, forEachKeyword, openParenToken, variable, inKeyword, expression, closeParenToken, statement, this.context);
    }

    public UsingStatementSyntax UsingStatement(SyntaxToken usingKeyword, SyntaxToken openParenToken, VariableDeclarationSyntax declaration, ExpressionSyntax expression, SyntaxToken closeParenToken, StatementSyntax statement)
    {
#if DEBUG
      if (usingKeyword == null)
        throw new ArgumentNullException(nameof(usingKeyword));
      switch (usingKeyword.Kind)
      {
        case SyntaxKind.UsingKeyword:
          break;
        default:
          throw new ArgumentException("usingKeyword");
      }
      if (openParenToken == null)
        throw new ArgumentNullException(nameof(openParenToken));
      switch (openParenToken.Kind)
      {
        case SyntaxKind.OpenParenToken:
          break;
        default:
          throw new ArgumentException("openParenToken");
      }
      if (closeParenToken == null)
        throw new ArgumentNullException(nameof(closeParenToken));
      switch (closeParenToken.Kind)
      {
        case SyntaxKind.CloseParenToken:
          break;
        default:
          throw new ArgumentException("closeParenToken");
      }
      if (statement == null)
        throw new ArgumentNullException(nameof(statement));
#endif

      return new UsingStatementSyntax(SyntaxKind.UsingStatement, usingKeyword, openParenToken, declaration, expression, closeParenToken, statement, this.context);
    }

    public FixedStatementSyntax FixedStatement(SyntaxToken fixedKeyword, SyntaxToken openParenToken, VariableDeclarationSyntax declaration, SyntaxToken closeParenToken, StatementSyntax statement)
    {
#if DEBUG
      if (fixedKeyword == null)
        throw new ArgumentNullException(nameof(fixedKeyword));
      switch (fixedKeyword.Kind)
      {
        case SyntaxKind.FixedKeyword:
          break;
        default:
          throw new ArgumentException("fixedKeyword");
      }
      if (openParenToken == null)
        throw new ArgumentNullException(nameof(openParenToken));
      switch (openParenToken.Kind)
      {
        case SyntaxKind.OpenParenToken:
          break;
        default:
          throw new ArgumentException("openParenToken");
      }
      if (declaration == null)
        throw new ArgumentNullException(nameof(declaration));
      if (closeParenToken == null)
        throw new ArgumentNullException(nameof(closeParenToken));
      switch (closeParenToken.Kind)
      {
        case SyntaxKind.CloseParenToken:
          break;
        default:
          throw new ArgumentException("closeParenToken");
      }
      if (statement == null)
        throw new ArgumentNullException(nameof(statement));
#endif

      return new FixedStatementSyntax(SyntaxKind.FixedStatement, fixedKeyword, openParenToken, declaration, closeParenToken, statement, this.context);
    }

    public CheckedStatementSyntax CheckedStatement(SyntaxKind kind, SyntaxToken keyword, BlockSyntax block)
    {
      switch (kind)
      {
        case SyntaxKind.CheckedStatement:
        case SyntaxKind.UncheckedStatement:
          break;
        default:
          throw new ArgumentException("kind");
      }
#if DEBUG
      if (keyword == null)
        throw new ArgumentNullException(nameof(keyword));
      switch (keyword.Kind)
      {
        case SyntaxKind.CheckedKeyword:
        case SyntaxKind.UncheckedKeyword:
          break;
        default:
          throw new ArgumentException("keyword");
      }
      if (block == null)
        throw new ArgumentNullException(nameof(block));
#endif

      int hash;
      var cached = CSharpSyntaxNodeCache.TryGetNode((int)kind, keyword, block, this.context, out hash);
      if (cached != null) return (CheckedStatementSyntax)cached;

      var result = new CheckedStatementSyntax(kind, keyword, block, this.context);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public UnsafeStatementSyntax UnsafeStatement(SyntaxToken unsafeKeyword, BlockSyntax block)
    {
#if DEBUG
      if (unsafeKeyword == null)
        throw new ArgumentNullException(nameof(unsafeKeyword));
      switch (unsafeKeyword.Kind)
      {
        case SyntaxKind.UnsafeKeyword:
          break;
        default:
          throw new ArgumentException("unsafeKeyword");
      }
      if (block == null)
        throw new ArgumentNullException(nameof(block));
#endif

      int hash;
      var cached = CSharpSyntaxNodeCache.TryGetNode((int)SyntaxKind.UnsafeStatement, unsafeKeyword, block, this.context, out hash);
      if (cached != null) return (UnsafeStatementSyntax)cached;

      var result = new UnsafeStatementSyntax(SyntaxKind.UnsafeStatement, unsafeKeyword, block, this.context);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public LockStatementSyntax LockStatement(SyntaxToken lockKeyword, SyntaxToken openParenToken, ExpressionSyntax expression, SyntaxToken closeParenToken, StatementSyntax statement)
    {
#if DEBUG
      if (lockKeyword == null)
        throw new ArgumentNullException(nameof(lockKeyword));
      switch (lockKeyword.Kind)
      {
        case SyntaxKind.LockKeyword:
          break;
        default:
          throw new ArgumentException("lockKeyword");
      }
      if (openParenToken == null)
        throw new ArgumentNullException(nameof(openParenToken));
      switch (openParenToken.Kind)
      {
        case SyntaxKind.OpenParenToken:
          break;
        default:
          throw new ArgumentException("openParenToken");
      }
      if (expression == null)
        throw new ArgumentNullException(nameof(expression));
      if (closeParenToken == null)
        throw new ArgumentNullException(nameof(closeParenToken));
      switch (closeParenToken.Kind)
      {
        case SyntaxKind.CloseParenToken:
          break;
        default:
          throw new ArgumentException("closeParenToken");
      }
      if (statement == null)
        throw new ArgumentNullException(nameof(statement));
#endif

      return new LockStatementSyntax(SyntaxKind.LockStatement, lockKeyword, openParenToken, expression, closeParenToken, statement, this.context);
    }

    public IfStatementSyntax IfStatement(SyntaxToken ifKeyword, SyntaxToken openParenToken, ExpressionSyntax condition, SyntaxToken closeParenToken, StatementSyntax statement, ElseClauseSyntax @else)
    {
#if DEBUG
      if (ifKeyword == null)
        throw new ArgumentNullException(nameof(ifKeyword));
      switch (ifKeyword.Kind)
      {
        case SyntaxKind.IfKeyword:
          break;
        default:
          throw new ArgumentException("ifKeyword");
      }
      if (openParenToken == null)
        throw new ArgumentNullException(nameof(openParenToken));
      switch (openParenToken.Kind)
      {
        case SyntaxKind.OpenParenToken:
          break;
        default:
          throw new ArgumentException("openParenToken");
      }
      if (condition == null)
        throw new ArgumentNullException(nameof(condition));
      if (closeParenToken == null)
        throw new ArgumentNullException(nameof(closeParenToken));
      switch (closeParenToken.Kind)
      {
        case SyntaxKind.CloseParenToken:
          break;
        default:
          throw new ArgumentException("closeParenToken");
      }
      if (statement == null)
        throw new ArgumentNullException(nameof(statement));
#endif

      return new IfStatementSyntax(SyntaxKind.IfStatement, ifKeyword, openParenToken, condition, closeParenToken, statement, @else, this.context);
    }

    public ElseClauseSyntax ElseClause(SyntaxToken elseKeyword, StatementSyntax statement)
    {
#if DEBUG
      if (elseKeyword == null)
        throw new ArgumentNullException(nameof(elseKeyword));
      switch (elseKeyword.Kind)
      {
        case SyntaxKind.ElseKeyword:
          break;
        default:
          throw new ArgumentException("elseKeyword");
      }
      if (statement == null)
        throw new ArgumentNullException(nameof(statement));
#endif

      int hash;
      var cached = CSharpSyntaxNodeCache.TryGetNode((int)SyntaxKind.ElseClause, elseKeyword, statement, this.context, out hash);
      if (cached != null) return (ElseClauseSyntax)cached;

      var result = new ElseClauseSyntax(SyntaxKind.ElseClause, elseKeyword, statement, this.context);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public SwitchStatementSyntax SwitchStatement(SyntaxToken switchKeyword, SyntaxToken openParenToken, ExpressionSyntax expression, SyntaxToken closeParenToken, SyntaxToken openBraceToken, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SwitchSectionSyntax> sections, SyntaxToken closeBraceToken)
    {
#if DEBUG
      if (switchKeyword == null)
        throw new ArgumentNullException(nameof(switchKeyword));
      switch (switchKeyword.Kind)
      {
        case SyntaxKind.SwitchKeyword:
          break;
        default:
          throw new ArgumentException("switchKeyword");
      }
      if (openParenToken == null)
        throw new ArgumentNullException(nameof(openParenToken));
      switch (openParenToken.Kind)
      {
        case SyntaxKind.OpenParenToken:
          break;
        default:
          throw new ArgumentException("openParenToken");
      }
      if (expression == null)
        throw new ArgumentNullException(nameof(expression));
      if (closeParenToken == null)
        throw new ArgumentNullException(nameof(closeParenToken));
      switch (closeParenToken.Kind)
      {
        case SyntaxKind.CloseParenToken:
          break;
        default:
          throw new ArgumentException("closeParenToken");
      }
      if (openBraceToken == null)
        throw new ArgumentNullException(nameof(openBraceToken));
      switch (openBraceToken.Kind)
      {
        case SyntaxKind.OpenBraceToken:
          break;
        default:
          throw new ArgumentException("openBraceToken");
      }
      if (closeBraceToken == null)
        throw new ArgumentNullException(nameof(closeBraceToken));
      switch (closeBraceToken.Kind)
      {
        case SyntaxKind.CloseBraceToken:
          break;
        default:
          throw new ArgumentException("closeBraceToken");
      }
#endif

      return new SwitchStatementSyntax(SyntaxKind.SwitchStatement, switchKeyword, openParenToken, expression, closeParenToken, openBraceToken, sections.Node, closeBraceToken, this.context);
    }

    public SwitchSectionSyntax SwitchSection(Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SwitchLabelSyntax> labels, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<StatementSyntax> statements)
    {
#if DEBUG
#endif

      int hash;
      var cached = CSharpSyntaxNodeCache.TryGetNode((int)SyntaxKind.SwitchSection, labels.Node, statements.Node, this.context, out hash);
      if (cached != null) return (SwitchSectionSyntax)cached;

      var result = new SwitchSectionSyntax(SyntaxKind.SwitchSection, labels.Node, statements.Node, this.context);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public CasePatternSwitchLabelSyntax CasePatternSwitchLabel(SyntaxToken keyword, PatternSyntax pattern, WhenClauseSyntax whenClause, SyntaxToken colonToken)
    {
#if DEBUG
      if (keyword == null)
        throw new ArgumentNullException(nameof(keyword));
      switch (keyword.Kind)
      {
        case SyntaxKind.CaseKeyword:
          break;
        default:
          throw new ArgumentException("keyword");
      }
      if (pattern == null)
        throw new ArgumentNullException(nameof(pattern));
      if (colonToken == null)
        throw new ArgumentNullException(nameof(colonToken));
#endif

      return new CasePatternSwitchLabelSyntax(SyntaxKind.CasePatternSwitchLabel, keyword, pattern, whenClause, colonToken, this.context);
    }

    public CaseSwitchLabelSyntax CaseSwitchLabel(SyntaxToken keyword, ExpressionSyntax value, SyntaxToken colonToken)
    {
#if DEBUG
      if (keyword == null)
        throw new ArgumentNullException(nameof(keyword));
      switch (keyword.Kind)
      {
        case SyntaxKind.CaseKeyword:
          break;
        default:
          throw new ArgumentException("keyword");
      }
      if (value == null)
        throw new ArgumentNullException(nameof(value));
      if (colonToken == null)
        throw new ArgumentNullException(nameof(colonToken));
#endif

      int hash;
      var cached = CSharpSyntaxNodeCache.TryGetNode((int)SyntaxKind.CaseSwitchLabel, keyword, value, colonToken, this.context, out hash);
      if (cached != null) return (CaseSwitchLabelSyntax)cached;

      var result = new CaseSwitchLabelSyntax(SyntaxKind.CaseSwitchLabel, keyword, value, colonToken, this.context);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public DefaultSwitchLabelSyntax DefaultSwitchLabel(SyntaxToken keyword, SyntaxToken colonToken)
    {
#if DEBUG
      if (keyword == null)
        throw new ArgumentNullException(nameof(keyword));
      switch (keyword.Kind)
      {
        case SyntaxKind.DefaultKeyword:
          break;
        default:
          throw new ArgumentException("keyword");
      }
      if (colonToken == null)
        throw new ArgumentNullException(nameof(colonToken));
#endif

      int hash;
      var cached = CSharpSyntaxNodeCache.TryGetNode((int)SyntaxKind.DefaultSwitchLabel, keyword, colonToken, this.context, out hash);
      if (cached != null) return (DefaultSwitchLabelSyntax)cached;

      var result = new DefaultSwitchLabelSyntax(SyntaxKind.DefaultSwitchLabel, keyword, colonToken, this.context);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public TryStatementSyntax TryStatement(SyntaxToken tryKeyword, BlockSyntax block, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<CatchClauseSyntax> catches, FinallyClauseSyntax @finally)
    {
#if DEBUG
      if (tryKeyword == null)
        throw new ArgumentNullException(nameof(tryKeyword));
      switch (tryKeyword.Kind)
      {
        case SyntaxKind.TryKeyword:
          break;
        default:
          throw new ArgumentException("tryKeyword");
      }
      if (block == null)
        throw new ArgumentNullException(nameof(block));
#endif

      return new TryStatementSyntax(SyntaxKind.TryStatement, tryKeyword, block, catches.Node, @finally, this.context);
    }

    public CatchClauseSyntax CatchClause(SyntaxToken catchKeyword, CatchDeclarationSyntax declaration, CatchFilterClauseSyntax filter, BlockSyntax block)
    {
#if DEBUG
      if (catchKeyword == null)
        throw new ArgumentNullException(nameof(catchKeyword));
      switch (catchKeyword.Kind)
      {
        case SyntaxKind.CatchKeyword:
          break;
        default:
          throw new ArgumentException("catchKeyword");
      }
      if (block == null)
        throw new ArgumentNullException(nameof(block));
#endif

      return new CatchClauseSyntax(SyntaxKind.CatchClause, catchKeyword, declaration, filter, block, this.context);
    }

    public CatchDeclarationSyntax CatchDeclaration(SyntaxToken openParenToken, TypeSyntax type, SyntaxToken identifier, SyntaxToken closeParenToken)
    {
#if DEBUG
      if (openParenToken == null)
        throw new ArgumentNullException(nameof(openParenToken));
      switch (openParenToken.Kind)
      {
        case SyntaxKind.OpenParenToken:
          break;
        default:
          throw new ArgumentException("openParenToken");
      }
      if (type == null)
        throw new ArgumentNullException(nameof(type));
      if (identifier != null)
      {
      switch (identifier.Kind)
      {
        case SyntaxKind.IdentifierToken:
        case SyntaxKind.None:
          break;
        default:
          throw new ArgumentException("identifier");
      }
      }
      if (closeParenToken == null)
        throw new ArgumentNullException(nameof(closeParenToken));
      switch (closeParenToken.Kind)
      {
        case SyntaxKind.CloseParenToken:
          break;
        default:
          throw new ArgumentException("closeParenToken");
      }
#endif

      return new CatchDeclarationSyntax(SyntaxKind.CatchDeclaration, openParenToken, type, identifier, closeParenToken, this.context);
    }

    public CatchFilterClauseSyntax CatchFilterClause(SyntaxToken whenKeyword, SyntaxToken openParenToken, ExpressionSyntax filterExpression, SyntaxToken closeParenToken)
    {
#if DEBUG
      if (whenKeyword == null)
        throw new ArgumentNullException(nameof(whenKeyword));
      switch (whenKeyword.Kind)
      {
        case SyntaxKind.WhenKeyword:
          break;
        default:
          throw new ArgumentException("whenKeyword");
      }
      if (openParenToken == null)
        throw new ArgumentNullException(nameof(openParenToken));
      switch (openParenToken.Kind)
      {
        case SyntaxKind.OpenParenToken:
          break;
        default:
          throw new ArgumentException("openParenToken");
      }
      if (filterExpression == null)
        throw new ArgumentNullException(nameof(filterExpression));
      if (closeParenToken == null)
        throw new ArgumentNullException(nameof(closeParenToken));
      switch (closeParenToken.Kind)
      {
        case SyntaxKind.CloseParenToken:
          break;
        default:
          throw new ArgumentException("closeParenToken");
      }
#endif

      return new CatchFilterClauseSyntax(SyntaxKind.CatchFilterClause, whenKeyword, openParenToken, filterExpression, closeParenToken, this.context);
    }

    public FinallyClauseSyntax FinallyClause(SyntaxToken finallyKeyword, BlockSyntax block)
    {
#if DEBUG
      if (finallyKeyword == null)
        throw new ArgumentNullException(nameof(finallyKeyword));
      switch (finallyKeyword.Kind)
      {
        case SyntaxKind.FinallyKeyword:
          break;
        default:
          throw new ArgumentException("finallyKeyword");
      }
      if (block == null)
        throw new ArgumentNullException(nameof(block));
#endif

      int hash;
      var cached = CSharpSyntaxNodeCache.TryGetNode((int)SyntaxKind.FinallyClause, finallyKeyword, block, this.context, out hash);
      if (cached != null) return (FinallyClauseSyntax)cached;

      var result = new FinallyClauseSyntax(SyntaxKind.FinallyClause, finallyKeyword, block, this.context);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public CompilationUnitSyntax CompilationUnit(Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<ExternAliasDirectiveSyntax> externs, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<UsingDirectiveSyntax> usings, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<AttributeListSyntax> attributeLists, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<MemberDeclarationSyntax> members, SyntaxToken endOfFileToken)
    {
#if DEBUG
      if (endOfFileToken == null)
        throw new ArgumentNullException(nameof(endOfFileToken));
      switch (endOfFileToken.Kind)
      {
        case SyntaxKind.EndOfFileToken:
          break;
        default:
          throw new ArgumentException("endOfFileToken");
      }
#endif

      return new CompilationUnitSyntax(SyntaxKind.CompilationUnit, externs.Node, usings.Node, attributeLists.Node, members.Node, endOfFileToken, this.context);
    }

    public ExternAliasDirectiveSyntax ExternAliasDirective(SyntaxToken externKeyword, SyntaxToken aliasKeyword, SyntaxToken identifier, SyntaxToken semicolonToken)
    {
#if DEBUG
      if (externKeyword == null)
        throw new ArgumentNullException(nameof(externKeyword));
      switch (externKeyword.Kind)
      {
        case SyntaxKind.ExternKeyword:
          break;
        default:
          throw new ArgumentException("externKeyword");
      }
      if (aliasKeyword == null)
        throw new ArgumentNullException(nameof(aliasKeyword));
      switch (aliasKeyword.Kind)
      {
        case SyntaxKind.AliasKeyword:
          break;
        default:
          throw new ArgumentException("aliasKeyword");
      }
      if (identifier == null)
        throw new ArgumentNullException(nameof(identifier));
      switch (identifier.Kind)
      {
        case SyntaxKind.IdentifierToken:
          break;
        default:
          throw new ArgumentException("identifier");
      }
      if (semicolonToken == null)
        throw new ArgumentNullException(nameof(semicolonToken));
      switch (semicolonToken.Kind)
      {
        case SyntaxKind.SemicolonToken:
          break;
        default:
          throw new ArgumentException("semicolonToken");
      }
#endif

      return new ExternAliasDirectiveSyntax(SyntaxKind.ExternAliasDirective, externKeyword, aliasKeyword, identifier, semicolonToken, this.context);
    }

    public UsingDirectiveSyntax UsingDirective(SyntaxToken usingKeyword, SyntaxToken staticKeyword, NameEqualsSyntax alias, NameSyntax name, SyntaxToken semicolonToken)
    {
#if DEBUG
      if (usingKeyword == null)
        throw new ArgumentNullException(nameof(usingKeyword));
      switch (usingKeyword.Kind)
      {
        case SyntaxKind.UsingKeyword:
          break;
        default:
          throw new ArgumentException("usingKeyword");
      }
      if (name == null)
        throw new ArgumentNullException(nameof(name));
      if (semicolonToken == null)
        throw new ArgumentNullException(nameof(semicolonToken));
      switch (semicolonToken.Kind)
      {
        case SyntaxKind.SemicolonToken:
          break;
        default:
          throw new ArgumentException("semicolonToken");
      }
#endif

      return new UsingDirectiveSyntax(SyntaxKind.UsingDirective, usingKeyword, staticKeyword, alias, name, semicolonToken, this.context);
    }

    public NamespaceDeclarationSyntax NamespaceDeclaration(SyntaxToken namespaceKeyword, NameSyntax name, SyntaxToken openBraceToken, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<ExternAliasDirectiveSyntax> externs, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<UsingDirectiveSyntax> usings, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<MemberDeclarationSyntax> members, SyntaxToken closeBraceToken, SyntaxToken semicolonToken)
    {
#if DEBUG
      if (namespaceKeyword == null)
        throw new ArgumentNullException(nameof(namespaceKeyword));
      switch (namespaceKeyword.Kind)
      {
        case SyntaxKind.NamespaceKeyword:
          break;
        default:
          throw new ArgumentException("namespaceKeyword");
      }
      if (name == null)
        throw new ArgumentNullException(nameof(name));
      if (openBraceToken == null)
        throw new ArgumentNullException(nameof(openBraceToken));
      switch (openBraceToken.Kind)
      {
        case SyntaxKind.OpenBraceToken:
          break;
        default:
          throw new ArgumentException("openBraceToken");
      }
      if (closeBraceToken == null)
        throw new ArgumentNullException(nameof(closeBraceToken));
      switch (closeBraceToken.Kind)
      {
        case SyntaxKind.CloseBraceToken:
          break;
        default:
          throw new ArgumentException("closeBraceToken");
      }
      if (semicolonToken != null)
      {
      switch (semicolonToken.Kind)
      {
        case SyntaxKind.SemicolonToken:
        case SyntaxKind.None:
          break;
        default:
          throw new ArgumentException("semicolonToken");
      }
      }
#endif

      return new NamespaceDeclarationSyntax(SyntaxKind.NamespaceDeclaration, namespaceKeyword, name, openBraceToken, externs.Node, usings.Node, members.Node, closeBraceToken, semicolonToken, this.context);
    }

    public AttributeListSyntax AttributeList(SyntaxToken openBracketToken, AttributeTargetSpecifierSyntax target, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<AttributeSyntax> attributes, SyntaxToken closeBracketToken)
    {
#if DEBUG
      if (openBracketToken == null)
        throw new ArgumentNullException(nameof(openBracketToken));
      switch (openBracketToken.Kind)
      {
        case SyntaxKind.OpenBracketToken:
          break;
        default:
          throw new ArgumentException("openBracketToken");
      }
      if (closeBracketToken == null)
        throw new ArgumentNullException(nameof(closeBracketToken));
      switch (closeBracketToken.Kind)
      {
        case SyntaxKind.CloseBracketToken:
          break;
        default:
          throw new ArgumentException("closeBracketToken");
      }
#endif

      return new AttributeListSyntax(SyntaxKind.AttributeList, openBracketToken, target, attributes.Node, closeBracketToken, this.context);
    }

    public AttributeTargetSpecifierSyntax AttributeTargetSpecifier(SyntaxToken identifier, SyntaxToken colonToken)
    {
#if DEBUG
      if (identifier == null)
        throw new ArgumentNullException(nameof(identifier));
      if (colonToken == null)
        throw new ArgumentNullException(nameof(colonToken));
      switch (colonToken.Kind)
      {
        case SyntaxKind.ColonToken:
          break;
        default:
          throw new ArgumentException("colonToken");
      }
#endif

      int hash;
      var cached = CSharpSyntaxNodeCache.TryGetNode((int)SyntaxKind.AttributeTargetSpecifier, identifier, colonToken, this.context, out hash);
      if (cached != null) return (AttributeTargetSpecifierSyntax)cached;

      var result = new AttributeTargetSpecifierSyntax(SyntaxKind.AttributeTargetSpecifier, identifier, colonToken, this.context);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public AttributeSyntax Attribute(NameSyntax name, AttributeArgumentListSyntax argumentList)
    {
#if DEBUG
      if (name == null)
        throw new ArgumentNullException(nameof(name));
#endif

      int hash;
      var cached = CSharpSyntaxNodeCache.TryGetNode((int)SyntaxKind.Attribute, name, argumentList, this.context, out hash);
      if (cached != null) return (AttributeSyntax)cached;

      var result = new AttributeSyntax(SyntaxKind.Attribute, name, argumentList, this.context);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public AttributeArgumentListSyntax AttributeArgumentList(SyntaxToken openParenToken, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<AttributeArgumentSyntax> arguments, SyntaxToken closeParenToken)
    {
#if DEBUG
      if (openParenToken == null)
        throw new ArgumentNullException(nameof(openParenToken));
      switch (openParenToken.Kind)
      {
        case SyntaxKind.OpenParenToken:
          break;
        default:
          throw new ArgumentException("openParenToken");
      }
      if (closeParenToken == null)
        throw new ArgumentNullException(nameof(closeParenToken));
      switch (closeParenToken.Kind)
      {
        case SyntaxKind.CloseParenToken:
          break;
        default:
          throw new ArgumentException("closeParenToken");
      }
#endif

      int hash;
      var cached = CSharpSyntaxNodeCache.TryGetNode((int)SyntaxKind.AttributeArgumentList, openParenToken, arguments.Node, closeParenToken, this.context, out hash);
      if (cached != null) return (AttributeArgumentListSyntax)cached;

      var result = new AttributeArgumentListSyntax(SyntaxKind.AttributeArgumentList, openParenToken, arguments.Node, closeParenToken, this.context);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public AttributeArgumentSyntax AttributeArgument(NameEqualsSyntax nameEquals, NameColonSyntax nameColon, ExpressionSyntax expression)
    {
#if DEBUG
      if (expression == null)
        throw new ArgumentNullException(nameof(expression));
#endif

      int hash;
      var cached = CSharpSyntaxNodeCache.TryGetNode((int)SyntaxKind.AttributeArgument, nameEquals, nameColon, expression, this.context, out hash);
      if (cached != null) return (AttributeArgumentSyntax)cached;

      var result = new AttributeArgumentSyntax(SyntaxKind.AttributeArgument, nameEquals, nameColon, expression, this.context);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public NameEqualsSyntax NameEquals(IdentifierNameSyntax name, SyntaxToken equalsToken)
    {
#if DEBUG
      if (name == null)
        throw new ArgumentNullException(nameof(name));
      if (equalsToken == null)
        throw new ArgumentNullException(nameof(equalsToken));
      switch (equalsToken.Kind)
      {
        case SyntaxKind.EqualsToken:
          break;
        default:
          throw new ArgumentException("equalsToken");
      }
#endif

      int hash;
      var cached = CSharpSyntaxNodeCache.TryGetNode((int)SyntaxKind.NameEquals, name, equalsToken, this.context, out hash);
      if (cached != null) return (NameEqualsSyntax)cached;

      var result = new NameEqualsSyntax(SyntaxKind.NameEquals, name, equalsToken, this.context);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public TypeParameterListSyntax TypeParameterList(SyntaxToken lessThanToken, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<TypeParameterSyntax> parameters, SyntaxToken greaterThanToken)
    {
#if DEBUG
      if (lessThanToken == null)
        throw new ArgumentNullException(nameof(lessThanToken));
      switch (lessThanToken.Kind)
      {
        case SyntaxKind.LessThanToken:
          break;
        default:
          throw new ArgumentException("lessThanToken");
      }
      if (greaterThanToken == null)
        throw new ArgumentNullException(nameof(greaterThanToken));
      switch (greaterThanToken.Kind)
      {
        case SyntaxKind.GreaterThanToken:
          break;
        default:
          throw new ArgumentException("greaterThanToken");
      }
#endif

      int hash;
      var cached = CSharpSyntaxNodeCache.TryGetNode((int)SyntaxKind.TypeParameterList, lessThanToken, parameters.Node, greaterThanToken, this.context, out hash);
      if (cached != null) return (TypeParameterListSyntax)cached;

      var result = new TypeParameterListSyntax(SyntaxKind.TypeParameterList, lessThanToken, parameters.Node, greaterThanToken, this.context);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public TypeParameterSyntax TypeParameter(Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<AttributeListSyntax> attributeLists, SyntaxToken varianceKeyword, SyntaxToken identifier)
    {
#if DEBUG
      if (varianceKeyword != null)
      {
      switch (varianceKeyword.Kind)
      {
        case SyntaxKind.InKeyword:
        case SyntaxKind.OutKeyword:
        case SyntaxKind.None:
          break;
        default:
          throw new ArgumentException("varianceKeyword");
      }
      }
      if (identifier == null)
        throw new ArgumentNullException(nameof(identifier));
      switch (identifier.Kind)
      {
        case SyntaxKind.IdentifierToken:
          break;
        default:
          throw new ArgumentException("identifier");
      }
#endif

      int hash;
      var cached = CSharpSyntaxNodeCache.TryGetNode((int)SyntaxKind.TypeParameter, attributeLists.Node, varianceKeyword, identifier, this.context, out hash);
      if (cached != null) return (TypeParameterSyntax)cached;

      var result = new TypeParameterSyntax(SyntaxKind.TypeParameter, attributeLists.Node, varianceKeyword, identifier, this.context);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public ClassDeclarationSyntax ClassDeclaration(Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<AttributeListSyntax> attributeLists, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SyntaxToken> modifiers, SyntaxToken keyword, SyntaxToken identifier, TypeParameterListSyntax typeParameterList, BaseListSyntax baseList, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<TypeParameterConstraintClauseSyntax> constraintClauses, SyntaxToken openBraceToken, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<MemberDeclarationSyntax> members, SyntaxToken closeBraceToken, SyntaxToken semicolonToken)
    {
#if DEBUG
      if (keyword == null)
        throw new ArgumentNullException(nameof(keyword));
      switch (keyword.Kind)
      {
        case SyntaxKind.ClassKeyword:
          break;
        default:
          throw new ArgumentException("keyword");
      }
      if (identifier == null)
        throw new ArgumentNullException(nameof(identifier));
      switch (identifier.Kind)
      {
        case SyntaxKind.IdentifierToken:
          break;
        default:
          throw new ArgumentException("identifier");
      }
      if (openBraceToken == null)
        throw new ArgumentNullException(nameof(openBraceToken));
      switch (openBraceToken.Kind)
      {
        case SyntaxKind.OpenBraceToken:
          break;
        default:
          throw new ArgumentException("openBraceToken");
      }
      if (closeBraceToken == null)
        throw new ArgumentNullException(nameof(closeBraceToken));
      switch (closeBraceToken.Kind)
      {
        case SyntaxKind.CloseBraceToken:
          break;
        default:
          throw new ArgumentException("closeBraceToken");
      }
      if (semicolonToken != null)
      {
      switch (semicolonToken.Kind)
      {
        case SyntaxKind.SemicolonToken:
        case SyntaxKind.None:
          break;
        default:
          throw new ArgumentException("semicolonToken");
      }
      }
#endif

      return new ClassDeclarationSyntax(SyntaxKind.ClassDeclaration, attributeLists.Node, modifiers.Node, keyword, identifier, typeParameterList, baseList, constraintClauses.Node, openBraceToken, members.Node, closeBraceToken, semicolonToken, this.context);
    }

    public StructDeclarationSyntax StructDeclaration(Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<AttributeListSyntax> attributeLists, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SyntaxToken> modifiers, SyntaxToken keyword, SyntaxToken identifier, TypeParameterListSyntax typeParameterList, BaseListSyntax baseList, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<TypeParameterConstraintClauseSyntax> constraintClauses, SyntaxToken openBraceToken, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<MemberDeclarationSyntax> members, SyntaxToken closeBraceToken, SyntaxToken semicolonToken)
    {
#if DEBUG
      if (keyword == null)
        throw new ArgumentNullException(nameof(keyword));
      switch (keyword.Kind)
      {
        case SyntaxKind.StructKeyword:
          break;
        default:
          throw new ArgumentException("keyword");
      }
      if (identifier == null)
        throw new ArgumentNullException(nameof(identifier));
      switch (identifier.Kind)
      {
        case SyntaxKind.IdentifierToken:
          break;
        default:
          throw new ArgumentException("identifier");
      }
      if (openBraceToken == null)
        throw new ArgumentNullException(nameof(openBraceToken));
      switch (openBraceToken.Kind)
      {
        case SyntaxKind.OpenBraceToken:
          break;
        default:
          throw new ArgumentException("openBraceToken");
      }
      if (closeBraceToken == null)
        throw new ArgumentNullException(nameof(closeBraceToken));
      switch (closeBraceToken.Kind)
      {
        case SyntaxKind.CloseBraceToken:
          break;
        default:
          throw new ArgumentException("closeBraceToken");
      }
      if (semicolonToken != null)
      {
      switch (semicolonToken.Kind)
      {
        case SyntaxKind.SemicolonToken:
        case SyntaxKind.None:
          break;
        default:
          throw new ArgumentException("semicolonToken");
      }
      }
#endif

      return new StructDeclarationSyntax(SyntaxKind.StructDeclaration, attributeLists.Node, modifiers.Node, keyword, identifier, typeParameterList, baseList, constraintClauses.Node, openBraceToken, members.Node, closeBraceToken, semicolonToken, this.context);
    }

    public InterfaceDeclarationSyntax InterfaceDeclaration(Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<AttributeListSyntax> attributeLists, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SyntaxToken> modifiers, SyntaxToken keyword, SyntaxToken identifier, TypeParameterListSyntax typeParameterList, BaseListSyntax baseList, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<TypeParameterConstraintClauseSyntax> constraintClauses, SyntaxToken openBraceToken, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<MemberDeclarationSyntax> members, SyntaxToken closeBraceToken, SyntaxToken semicolonToken)
    {
#if DEBUG
      if (keyword == null)
        throw new ArgumentNullException(nameof(keyword));
      switch (keyword.Kind)
      {
        case SyntaxKind.InterfaceKeyword:
          break;
        default:
          throw new ArgumentException("keyword");
      }
      if (identifier == null)
        throw new ArgumentNullException(nameof(identifier));
      switch (identifier.Kind)
      {
        case SyntaxKind.IdentifierToken:
          break;
        default:
          throw new ArgumentException("identifier");
      }
      if (openBraceToken == null)
        throw new ArgumentNullException(nameof(openBraceToken));
      switch (openBraceToken.Kind)
      {
        case SyntaxKind.OpenBraceToken:
          break;
        default:
          throw new ArgumentException("openBraceToken");
      }
      if (closeBraceToken == null)
        throw new ArgumentNullException(nameof(closeBraceToken));
      switch (closeBraceToken.Kind)
      {
        case SyntaxKind.CloseBraceToken:
          break;
        default:
          throw new ArgumentException("closeBraceToken");
      }
      if (semicolonToken != null)
      {
      switch (semicolonToken.Kind)
      {
        case SyntaxKind.SemicolonToken:
        case SyntaxKind.None:
          break;
        default:
          throw new ArgumentException("semicolonToken");
      }
      }
#endif

      return new InterfaceDeclarationSyntax(SyntaxKind.InterfaceDeclaration, attributeLists.Node, modifiers.Node, keyword, identifier, typeParameterList, baseList, constraintClauses.Node, openBraceToken, members.Node, closeBraceToken, semicolonToken, this.context);
    }

    public EnumDeclarationSyntax EnumDeclaration(Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<AttributeListSyntax> attributeLists, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SyntaxToken> modifiers, SyntaxToken enumKeyword, SyntaxToken identifier, BaseListSyntax baseList, SyntaxToken openBraceToken, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<EnumMemberDeclarationSyntax> members, SyntaxToken closeBraceToken, SyntaxToken semicolonToken)
    {
#if DEBUG
      if (enumKeyword == null)
        throw new ArgumentNullException(nameof(enumKeyword));
      switch (enumKeyword.Kind)
      {
        case SyntaxKind.EnumKeyword:
          break;
        default:
          throw new ArgumentException("enumKeyword");
      }
      if (identifier == null)
        throw new ArgumentNullException(nameof(identifier));
      switch (identifier.Kind)
      {
        case SyntaxKind.IdentifierToken:
          break;
        default:
          throw new ArgumentException("identifier");
      }
      if (openBraceToken == null)
        throw new ArgumentNullException(nameof(openBraceToken));
      switch (openBraceToken.Kind)
      {
        case SyntaxKind.OpenBraceToken:
          break;
        default:
          throw new ArgumentException("openBraceToken");
      }
      if (closeBraceToken == null)
        throw new ArgumentNullException(nameof(closeBraceToken));
      switch (closeBraceToken.Kind)
      {
        case SyntaxKind.CloseBraceToken:
          break;
        default:
          throw new ArgumentException("closeBraceToken");
      }
      if (semicolonToken != null)
      {
      switch (semicolonToken.Kind)
      {
        case SyntaxKind.SemicolonToken:
        case SyntaxKind.None:
          break;
        default:
          throw new ArgumentException("semicolonToken");
      }
      }
#endif

      return new EnumDeclarationSyntax(SyntaxKind.EnumDeclaration, attributeLists.Node, modifiers.Node, enumKeyword, identifier, baseList, openBraceToken, members.Node, closeBraceToken, semicolonToken, this.context);
    }

    public DelegateDeclarationSyntax DelegateDeclaration(Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<AttributeListSyntax> attributeLists, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SyntaxToken> modifiers, SyntaxToken delegateKeyword, TypeSyntax returnType, SyntaxToken identifier, TypeParameterListSyntax typeParameterList, ParameterListSyntax parameterList, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<TypeParameterConstraintClauseSyntax> constraintClauses, SyntaxToken semicolonToken)
    {
#if DEBUG
      if (delegateKeyword == null)
        throw new ArgumentNullException(nameof(delegateKeyword));
      switch (delegateKeyword.Kind)
      {
        case SyntaxKind.DelegateKeyword:
          break;
        default:
          throw new ArgumentException("delegateKeyword");
      }
      if (returnType == null)
        throw new ArgumentNullException(nameof(returnType));
      if (identifier == null)
        throw new ArgumentNullException(nameof(identifier));
      switch (identifier.Kind)
      {
        case SyntaxKind.IdentifierToken:
          break;
        default:
          throw new ArgumentException("identifier");
      }
      if (parameterList == null)
        throw new ArgumentNullException(nameof(parameterList));
      if (semicolonToken == null)
        throw new ArgumentNullException(nameof(semicolonToken));
      switch (semicolonToken.Kind)
      {
        case SyntaxKind.SemicolonToken:
          break;
        default:
          throw new ArgumentException("semicolonToken");
      }
#endif

      return new DelegateDeclarationSyntax(SyntaxKind.DelegateDeclaration, attributeLists.Node, modifiers.Node, delegateKeyword, returnType, identifier, typeParameterList, parameterList, constraintClauses.Node, semicolonToken, this.context);
    }

    public EnumMemberDeclarationSyntax EnumMemberDeclaration(Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<AttributeListSyntax> attributeLists, SyntaxToken identifier, EqualsValueClauseSyntax equalsValue)
    {
#if DEBUG
      if (identifier == null)
        throw new ArgumentNullException(nameof(identifier));
      switch (identifier.Kind)
      {
        case SyntaxKind.IdentifierToken:
          break;
        default:
          throw new ArgumentException("identifier");
      }
#endif

      int hash;
      var cached = CSharpSyntaxNodeCache.TryGetNode((int)SyntaxKind.EnumMemberDeclaration, attributeLists.Node, identifier, equalsValue, this.context, out hash);
      if (cached != null) return (EnumMemberDeclarationSyntax)cached;

      var result = new EnumMemberDeclarationSyntax(SyntaxKind.EnumMemberDeclaration, attributeLists.Node, identifier, equalsValue, this.context);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public BaseListSyntax BaseList(SyntaxToken colonToken, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<BaseTypeSyntax> types)
    {
#if DEBUG
      if (colonToken == null)
        throw new ArgumentNullException(nameof(colonToken));
      switch (colonToken.Kind)
      {
        case SyntaxKind.ColonToken:
          break;
        default:
          throw new ArgumentException("colonToken");
      }
#endif

      int hash;
      var cached = CSharpSyntaxNodeCache.TryGetNode((int)SyntaxKind.BaseList, colonToken, types.Node, this.context, out hash);
      if (cached != null) return (BaseListSyntax)cached;

      var result = new BaseListSyntax(SyntaxKind.BaseList, colonToken, types.Node, this.context);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public SimpleBaseTypeSyntax SimpleBaseType(TypeSyntax type)
    {
#if DEBUG
      if (type == null)
        throw new ArgumentNullException(nameof(type));
#endif

      int hash;
      var cached = CSharpSyntaxNodeCache.TryGetNode((int)SyntaxKind.SimpleBaseType, type, this.context, out hash);
      if (cached != null) return (SimpleBaseTypeSyntax)cached;

      var result = new SimpleBaseTypeSyntax(SyntaxKind.SimpleBaseType, type, this.context);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public TypeParameterConstraintClauseSyntax TypeParameterConstraintClause(SyntaxToken whereKeyword, IdentifierNameSyntax name, SyntaxToken colonToken, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<TypeParameterConstraintSyntax> constraints)
    {
#if DEBUG
      if (whereKeyword == null)
        throw new ArgumentNullException(nameof(whereKeyword));
      switch (whereKeyword.Kind)
      {
        case SyntaxKind.WhereKeyword:
          break;
        default:
          throw new ArgumentException("whereKeyword");
      }
      if (name == null)
        throw new ArgumentNullException(nameof(name));
      if (colonToken == null)
        throw new ArgumentNullException(nameof(colonToken));
      switch (colonToken.Kind)
      {
        case SyntaxKind.ColonToken:
          break;
        default:
          throw new ArgumentException("colonToken");
      }
#endif

      return new TypeParameterConstraintClauseSyntax(SyntaxKind.TypeParameterConstraintClause, whereKeyword, name, colonToken, constraints.Node, this.context);
    }

    public ConstructorConstraintSyntax ConstructorConstraint(SyntaxToken newKeyword, SyntaxToken openParenToken, SyntaxToken closeParenToken)
    {
#if DEBUG
      if (newKeyword == null)
        throw new ArgumentNullException(nameof(newKeyword));
      switch (newKeyword.Kind)
      {
        case SyntaxKind.NewKeyword:
          break;
        default:
          throw new ArgumentException("newKeyword");
      }
      if (openParenToken == null)
        throw new ArgumentNullException(nameof(openParenToken));
      switch (openParenToken.Kind)
      {
        case SyntaxKind.OpenParenToken:
          break;
        default:
          throw new ArgumentException("openParenToken");
      }
      if (closeParenToken == null)
        throw new ArgumentNullException(nameof(closeParenToken));
      switch (closeParenToken.Kind)
      {
        case SyntaxKind.CloseParenToken:
          break;
        default:
          throw new ArgumentException("closeParenToken");
      }
#endif

      int hash;
      var cached = CSharpSyntaxNodeCache.TryGetNode((int)SyntaxKind.ConstructorConstraint, newKeyword, openParenToken, closeParenToken, this.context, out hash);
      if (cached != null) return (ConstructorConstraintSyntax)cached;

      var result = new ConstructorConstraintSyntax(SyntaxKind.ConstructorConstraint, newKeyword, openParenToken, closeParenToken, this.context);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public ClassOrStructConstraintSyntax ClassOrStructConstraint(SyntaxKind kind, SyntaxToken classOrStructKeyword)
    {
      switch (kind)
      {
        case SyntaxKind.ClassConstraint:
        case SyntaxKind.StructConstraint:
          break;
        default:
          throw new ArgumentException("kind");
      }
#if DEBUG
      if (classOrStructKeyword == null)
        throw new ArgumentNullException(nameof(classOrStructKeyword));
      switch (classOrStructKeyword.Kind)
      {
        case SyntaxKind.ClassKeyword:
        case SyntaxKind.StructKeyword:
          break;
        default:
          throw new ArgumentException("classOrStructKeyword");
      }
#endif

      int hash;
      var cached = CSharpSyntaxNodeCache.TryGetNode((int)kind, classOrStructKeyword, this.context, out hash);
      if (cached != null) return (ClassOrStructConstraintSyntax)cached;

      var result = new ClassOrStructConstraintSyntax(kind, classOrStructKeyword, this.context);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public TypeConstraintSyntax TypeConstraint(TypeSyntax type)
    {
#if DEBUG
      if (type == null)
        throw new ArgumentNullException(nameof(type));
#endif

      int hash;
      var cached = CSharpSyntaxNodeCache.TryGetNode((int)SyntaxKind.TypeConstraint, type, this.context, out hash);
      if (cached != null) return (TypeConstraintSyntax)cached;

      var result = new TypeConstraintSyntax(SyntaxKind.TypeConstraint, type, this.context);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public FieldDeclarationSyntax FieldDeclaration(Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<AttributeListSyntax> attributeLists, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SyntaxToken> modifiers, VariableDeclarationSyntax declaration, SyntaxToken semicolonToken)
    {
#if DEBUG
      if (declaration == null)
        throw new ArgumentNullException(nameof(declaration));
      if (semicolonToken == null)
        throw new ArgumentNullException(nameof(semicolonToken));
      switch (semicolonToken.Kind)
      {
        case SyntaxKind.SemicolonToken:
          break;
        default:
          throw new ArgumentException("semicolonToken");
      }
#endif

      return new FieldDeclarationSyntax(SyntaxKind.FieldDeclaration, attributeLists.Node, modifiers.Node, declaration, semicolonToken, this.context);
    }

    public EventFieldDeclarationSyntax EventFieldDeclaration(Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<AttributeListSyntax> attributeLists, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SyntaxToken> modifiers, SyntaxToken eventKeyword, VariableDeclarationSyntax declaration, SyntaxToken semicolonToken)
    {
#if DEBUG
      if (eventKeyword == null)
        throw new ArgumentNullException(nameof(eventKeyword));
      switch (eventKeyword.Kind)
      {
        case SyntaxKind.EventKeyword:
          break;
        default:
          throw new ArgumentException("eventKeyword");
      }
      if (declaration == null)
        throw new ArgumentNullException(nameof(declaration));
      if (semicolonToken == null)
        throw new ArgumentNullException(nameof(semicolonToken));
      switch (semicolonToken.Kind)
      {
        case SyntaxKind.SemicolonToken:
          break;
        default:
          throw new ArgumentException("semicolonToken");
      }
#endif

      return new EventFieldDeclarationSyntax(SyntaxKind.EventFieldDeclaration, attributeLists.Node, modifiers.Node, eventKeyword, declaration, semicolonToken, this.context);
    }

    public ExplicitInterfaceSpecifierSyntax ExplicitInterfaceSpecifier(NameSyntax name, SyntaxToken dotToken)
    {
#if DEBUG
      if (name == null)
        throw new ArgumentNullException(nameof(name));
      if (dotToken == null)
        throw new ArgumentNullException(nameof(dotToken));
      switch (dotToken.Kind)
      {
        case SyntaxKind.DotToken:
          break;
        default:
          throw new ArgumentException("dotToken");
      }
#endif

      int hash;
      var cached = CSharpSyntaxNodeCache.TryGetNode((int)SyntaxKind.ExplicitInterfaceSpecifier, name, dotToken, this.context, out hash);
      if (cached != null) return (ExplicitInterfaceSpecifierSyntax)cached;

      var result = new ExplicitInterfaceSpecifierSyntax(SyntaxKind.ExplicitInterfaceSpecifier, name, dotToken, this.context);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public MethodDeclarationSyntax MethodDeclaration(Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<AttributeListSyntax> attributeLists, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SyntaxToken> modifiers, TypeSyntax returnType, ExplicitInterfaceSpecifierSyntax explicitInterfaceSpecifier, SyntaxToken identifier, TypeParameterListSyntax typeParameterList, ParameterListSyntax parameterList, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<TypeParameterConstraintClauseSyntax> constraintClauses, BlockSyntax body, ArrowExpressionClauseSyntax expressionBody, SyntaxToken semicolonToken)
    {
#if DEBUG
      if (returnType == null)
        throw new ArgumentNullException(nameof(returnType));
      if (identifier == null)
        throw new ArgumentNullException(nameof(identifier));
      switch (identifier.Kind)
      {
        case SyntaxKind.IdentifierToken:
          break;
        default:
          throw new ArgumentException("identifier");
      }
      if (parameterList == null)
        throw new ArgumentNullException(nameof(parameterList));
      if (semicolonToken != null)
      {
      switch (semicolonToken.Kind)
      {
        case SyntaxKind.SemicolonToken:
        case SyntaxKind.None:
          break;
        default:
          throw new ArgumentException("semicolonToken");
      }
      }
#endif

      return new MethodDeclarationSyntax(SyntaxKind.MethodDeclaration, attributeLists.Node, modifiers.Node, returnType, explicitInterfaceSpecifier, identifier, typeParameterList, parameterList, constraintClauses.Node, body, expressionBody, semicolonToken, this.context);
    }

    public OperatorDeclarationSyntax OperatorDeclaration(Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<AttributeListSyntax> attributeLists, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SyntaxToken> modifiers, TypeSyntax returnType, SyntaxToken operatorKeyword, SyntaxToken operatorToken, ParameterListSyntax parameterList, BlockSyntax body, ArrowExpressionClauseSyntax expressionBody, SyntaxToken semicolonToken)
    {
#if DEBUG
      if (returnType == null)
        throw new ArgumentNullException(nameof(returnType));
      if (operatorKeyword == null)
        throw new ArgumentNullException(nameof(operatorKeyword));
      switch (operatorKeyword.Kind)
      {
        case SyntaxKind.OperatorKeyword:
          break;
        default:
          throw new ArgumentException("operatorKeyword");
      }
      if (operatorToken == null)
        throw new ArgumentNullException(nameof(operatorToken));
      switch (operatorToken.Kind)
      {
        case SyntaxKind.PlusToken:
        case SyntaxKind.MinusToken:
        case SyntaxKind.ExclamationToken:
        case SyntaxKind.TildeToken:
        case SyntaxKind.PlusPlusToken:
        case SyntaxKind.MinusMinusToken:
        case SyntaxKind.AsteriskToken:
        case SyntaxKind.SlashToken:
        case SyntaxKind.PercentToken:
        case SyntaxKind.LessThanLessThanToken:
        case SyntaxKind.GreaterThanGreaterThanToken:
        case SyntaxKind.BarToken:
        case SyntaxKind.AmpersandToken:
        case SyntaxKind.CaretToken:
        case SyntaxKind.EqualsEqualsToken:
        case SyntaxKind.ExclamationEqualsToken:
        case SyntaxKind.LessThanToken:
        case SyntaxKind.LessThanEqualsToken:
        case SyntaxKind.GreaterThanToken:
        case SyntaxKind.GreaterThanEqualsToken:
        case SyntaxKind.FalseKeyword:
        case SyntaxKind.TrueKeyword:
        case SyntaxKind.IsKeyword:
          break;
        default:
          throw new ArgumentException("operatorToken");
      }
      if (parameterList == null)
        throw new ArgumentNullException(nameof(parameterList));
      if (semicolonToken != null)
      {
      switch (semicolonToken.Kind)
      {
        case SyntaxKind.SemicolonToken:
        case SyntaxKind.None:
          break;
        default:
          throw new ArgumentException("semicolonToken");
      }
      }
#endif

      return new OperatorDeclarationSyntax(SyntaxKind.OperatorDeclaration, attributeLists.Node, modifiers.Node, returnType, operatorKeyword, operatorToken, parameterList, body, expressionBody, semicolonToken, this.context);
    }

    public ConversionOperatorDeclarationSyntax ConversionOperatorDeclaration(Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<AttributeListSyntax> attributeLists, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SyntaxToken> modifiers, SyntaxToken implicitOrExplicitKeyword, SyntaxToken operatorKeyword, TypeSyntax type, ParameterListSyntax parameterList, BlockSyntax body, ArrowExpressionClauseSyntax expressionBody, SyntaxToken semicolonToken)
    {
#if DEBUG
      if (implicitOrExplicitKeyword == null)
        throw new ArgumentNullException(nameof(implicitOrExplicitKeyword));
      switch (implicitOrExplicitKeyword.Kind)
      {
        case SyntaxKind.ImplicitKeyword:
        case SyntaxKind.ExplicitKeyword:
          break;
        default:
          throw new ArgumentException("implicitOrExplicitKeyword");
      }
      if (operatorKeyword == null)
        throw new ArgumentNullException(nameof(operatorKeyword));
      switch (operatorKeyword.Kind)
      {
        case SyntaxKind.OperatorKeyword:
          break;
        default:
          throw new ArgumentException("operatorKeyword");
      }
      if (type == null)
        throw new ArgumentNullException(nameof(type));
      if (parameterList == null)
        throw new ArgumentNullException(nameof(parameterList));
      if (semicolonToken != null)
      {
      switch (semicolonToken.Kind)
      {
        case SyntaxKind.SemicolonToken:
        case SyntaxKind.None:
          break;
        default:
          throw new ArgumentException("semicolonToken");
      }
      }
#endif

      return new ConversionOperatorDeclarationSyntax(SyntaxKind.ConversionOperatorDeclaration, attributeLists.Node, modifiers.Node, implicitOrExplicitKeyword, operatorKeyword, type, parameterList, body, expressionBody, semicolonToken, this.context);
    }

    public ConstructorDeclarationSyntax ConstructorDeclaration(Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<AttributeListSyntax> attributeLists, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SyntaxToken> modifiers, SyntaxToken identifier, ParameterListSyntax parameterList, ConstructorInitializerSyntax initializer, BlockSyntax body, ArrowExpressionClauseSyntax expressionBody, SyntaxToken semicolonToken)
    {
#if DEBUG
      if (identifier == null)
        throw new ArgumentNullException(nameof(identifier));
      switch (identifier.Kind)
      {
        case SyntaxKind.IdentifierToken:
          break;
        default:
          throw new ArgumentException("identifier");
      }
      if (parameterList == null)
        throw new ArgumentNullException(nameof(parameterList));
      if (semicolonToken != null)
      {
      switch (semicolonToken.Kind)
      {
        case SyntaxKind.SemicolonToken:
        case SyntaxKind.None:
          break;
        default:
          throw new ArgumentException("semicolonToken");
      }
      }
#endif

      return new ConstructorDeclarationSyntax(SyntaxKind.ConstructorDeclaration, attributeLists.Node, modifiers.Node, identifier, parameterList, initializer, body, expressionBody, semicolonToken, this.context);
    }

    public ConstructorInitializerSyntax ConstructorInitializer(SyntaxKind kind, SyntaxToken colonToken, SyntaxToken thisOrBaseKeyword, ArgumentListSyntax argumentList)
    {
      switch (kind)
      {
        case SyntaxKind.BaseConstructorInitializer:
        case SyntaxKind.ThisConstructorInitializer:
          break;
        default:
          throw new ArgumentException("kind");
      }
#if DEBUG
      if (colonToken == null)
        throw new ArgumentNullException(nameof(colonToken));
      switch (colonToken.Kind)
      {
        case SyntaxKind.ColonToken:
          break;
        default:
          throw new ArgumentException("colonToken");
      }
      if (thisOrBaseKeyword == null)
        throw new ArgumentNullException(nameof(thisOrBaseKeyword));
      switch (thisOrBaseKeyword.Kind)
      {
        case SyntaxKind.BaseKeyword:
        case SyntaxKind.ThisKeyword:
          break;
        default:
          throw new ArgumentException("thisOrBaseKeyword");
      }
      if (argumentList == null)
        throw new ArgumentNullException(nameof(argumentList));
#endif

      int hash;
      var cached = CSharpSyntaxNodeCache.TryGetNode((int)kind, colonToken, thisOrBaseKeyword, argumentList, this.context, out hash);
      if (cached != null) return (ConstructorInitializerSyntax)cached;

      var result = new ConstructorInitializerSyntax(kind, colonToken, thisOrBaseKeyword, argumentList, this.context);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public DestructorDeclarationSyntax DestructorDeclaration(Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<AttributeListSyntax> attributeLists, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SyntaxToken> modifiers, SyntaxToken tildeToken, SyntaxToken identifier, ParameterListSyntax parameterList, BlockSyntax body, ArrowExpressionClauseSyntax expressionBody, SyntaxToken semicolonToken)
    {
#if DEBUG
      if (tildeToken == null)
        throw new ArgumentNullException(nameof(tildeToken));
      switch (tildeToken.Kind)
      {
        case SyntaxKind.TildeToken:
          break;
        default:
          throw new ArgumentException("tildeToken");
      }
      if (identifier == null)
        throw new ArgumentNullException(nameof(identifier));
      switch (identifier.Kind)
      {
        case SyntaxKind.IdentifierToken:
          break;
        default:
          throw new ArgumentException("identifier");
      }
      if (parameterList == null)
        throw new ArgumentNullException(nameof(parameterList));
      if (semicolonToken != null)
      {
      switch (semicolonToken.Kind)
      {
        case SyntaxKind.SemicolonToken:
        case SyntaxKind.None:
          break;
        default:
          throw new ArgumentException("semicolonToken");
      }
      }
#endif

      return new DestructorDeclarationSyntax(SyntaxKind.DestructorDeclaration, attributeLists.Node, modifiers.Node, tildeToken, identifier, parameterList, body, expressionBody, semicolonToken, this.context);
    }

    public PropertyDeclarationSyntax PropertyDeclaration(Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<AttributeListSyntax> attributeLists, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SyntaxToken> modifiers, TypeSyntax type, ExplicitInterfaceSpecifierSyntax explicitInterfaceSpecifier, SyntaxToken identifier, AccessorListSyntax accessorList, ArrowExpressionClauseSyntax expressionBody, EqualsValueClauseSyntax initializer, SyntaxToken semicolonToken)
    {
#if DEBUG
      if (type == null)
        throw new ArgumentNullException(nameof(type));
      if (identifier == null)
        throw new ArgumentNullException(nameof(identifier));
      switch (identifier.Kind)
      {
        case SyntaxKind.IdentifierToken:
          break;
        default:
          throw new ArgumentException("identifier");
      }
      if (semicolonToken != null)
      {
      switch (semicolonToken.Kind)
      {
        case SyntaxKind.SemicolonToken:
        case SyntaxKind.None:
          break;
        default:
          throw new ArgumentException("semicolonToken");
      }
      }
#endif

      return new PropertyDeclarationSyntax(SyntaxKind.PropertyDeclaration, attributeLists.Node, modifiers.Node, type, explicitInterfaceSpecifier, identifier, accessorList, expressionBody, initializer, semicolonToken, this.context);
    }

    public ArrowExpressionClauseSyntax ArrowExpressionClause(SyntaxToken arrowToken, ExpressionSyntax expression)
    {
#if DEBUG
      if (arrowToken == null)
        throw new ArgumentNullException(nameof(arrowToken));
      switch (arrowToken.Kind)
      {
        case SyntaxKind.EqualsGreaterThanToken:
          break;
        default:
          throw new ArgumentException("arrowToken");
      }
      if (expression == null)
        throw new ArgumentNullException(nameof(expression));
#endif

      int hash;
      var cached = CSharpSyntaxNodeCache.TryGetNode((int)SyntaxKind.ArrowExpressionClause, arrowToken, expression, this.context, out hash);
      if (cached != null) return (ArrowExpressionClauseSyntax)cached;

      var result = new ArrowExpressionClauseSyntax(SyntaxKind.ArrowExpressionClause, arrowToken, expression, this.context);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public EventDeclarationSyntax EventDeclaration(Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<AttributeListSyntax> attributeLists, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SyntaxToken> modifiers, SyntaxToken eventKeyword, TypeSyntax type, ExplicitInterfaceSpecifierSyntax explicitInterfaceSpecifier, SyntaxToken identifier, AccessorListSyntax accessorList)
    {
#if DEBUG
      if (eventKeyword == null)
        throw new ArgumentNullException(nameof(eventKeyword));
      switch (eventKeyword.Kind)
      {
        case SyntaxKind.EventKeyword:
          break;
        default:
          throw new ArgumentException("eventKeyword");
      }
      if (type == null)
        throw new ArgumentNullException(nameof(type));
      if (identifier == null)
        throw new ArgumentNullException(nameof(identifier));
      switch (identifier.Kind)
      {
        case SyntaxKind.IdentifierToken:
          break;
        default:
          throw new ArgumentException("identifier");
      }
      if (accessorList == null)
        throw new ArgumentNullException(nameof(accessorList));
#endif

      return new EventDeclarationSyntax(SyntaxKind.EventDeclaration, attributeLists.Node, modifiers.Node, eventKeyword, type, explicitInterfaceSpecifier, identifier, accessorList, this.context);
    }

    public IndexerDeclarationSyntax IndexerDeclaration(Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<AttributeListSyntax> attributeLists, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SyntaxToken> modifiers, TypeSyntax type, ExplicitInterfaceSpecifierSyntax explicitInterfaceSpecifier, SyntaxToken thisKeyword, BracketedParameterListSyntax parameterList, AccessorListSyntax accessorList, ArrowExpressionClauseSyntax expressionBody, SyntaxToken semicolonToken)
    {
#if DEBUG
      if (type == null)
        throw new ArgumentNullException(nameof(type));
      if (thisKeyword == null)
        throw new ArgumentNullException(nameof(thisKeyword));
      switch (thisKeyword.Kind)
      {
        case SyntaxKind.ThisKeyword:
          break;
        default:
          throw new ArgumentException("thisKeyword");
      }
      if (parameterList == null)
        throw new ArgumentNullException(nameof(parameterList));
      if (semicolonToken != null)
      {
      switch (semicolonToken.Kind)
      {
        case SyntaxKind.SemicolonToken:
        case SyntaxKind.None:
          break;
        default:
          throw new ArgumentException("semicolonToken");
      }
      }
#endif

      return new IndexerDeclarationSyntax(SyntaxKind.IndexerDeclaration, attributeLists.Node, modifiers.Node, type, explicitInterfaceSpecifier, thisKeyword, parameterList, accessorList, expressionBody, semicolonToken, this.context);
    }

    public AccessorListSyntax AccessorList(SyntaxToken openBraceToken, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<AccessorDeclarationSyntax> accessors, SyntaxToken closeBraceToken)
    {
#if DEBUG
      if (openBraceToken == null)
        throw new ArgumentNullException(nameof(openBraceToken));
      switch (openBraceToken.Kind)
      {
        case SyntaxKind.OpenBraceToken:
          break;
        default:
          throw new ArgumentException("openBraceToken");
      }
      if (closeBraceToken == null)
        throw new ArgumentNullException(nameof(closeBraceToken));
      switch (closeBraceToken.Kind)
      {
        case SyntaxKind.CloseBraceToken:
          break;
        default:
          throw new ArgumentException("closeBraceToken");
      }
#endif

      int hash;
      var cached = CSharpSyntaxNodeCache.TryGetNode((int)SyntaxKind.AccessorList, openBraceToken, accessors.Node, closeBraceToken, this.context, out hash);
      if (cached != null) return (AccessorListSyntax)cached;

      var result = new AccessorListSyntax(SyntaxKind.AccessorList, openBraceToken, accessors.Node, closeBraceToken, this.context);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public AccessorDeclarationSyntax AccessorDeclaration(SyntaxKind kind, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<AttributeListSyntax> attributeLists, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SyntaxToken> modifiers, SyntaxToken keyword, BlockSyntax body, ArrowExpressionClauseSyntax expressionBody, SyntaxToken semicolonToken)
    {
      switch (kind)
      {
        case SyntaxKind.GetAccessorDeclaration:
        case SyntaxKind.SetAccessorDeclaration:
        case SyntaxKind.AddAccessorDeclaration:
        case SyntaxKind.RemoveAccessorDeclaration:
        case SyntaxKind.UnknownAccessorDeclaration:
          break;
        default:
          throw new ArgumentException("kind");
      }
#if DEBUG
      if (keyword == null)
        throw new ArgumentNullException(nameof(keyword));
      switch (keyword.Kind)
      {
        case SyntaxKind.GetKeyword:
        case SyntaxKind.SetKeyword:
        case SyntaxKind.AddKeyword:
        case SyntaxKind.RemoveKeyword:
        case SyntaxKind.IdentifierToken:
          break;
        default:
          throw new ArgumentException("keyword");
      }
      if (semicolonToken != null)
      {
      switch (semicolonToken.Kind)
      {
        case SyntaxKind.SemicolonToken:
        case SyntaxKind.None:
          break;
        default:
          throw new ArgumentException("semicolonToken");
      }
      }
#endif

      return new AccessorDeclarationSyntax(kind, attributeLists.Node, modifiers.Node, keyword, body, expressionBody, semicolonToken, this.context);
    }

    public ParameterListSyntax ParameterList(SyntaxToken openParenToken, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<ParameterSyntax> parameters, SyntaxToken closeParenToken)
    {
#if DEBUG
      if (openParenToken == null)
        throw new ArgumentNullException(nameof(openParenToken));
      switch (openParenToken.Kind)
      {
        case SyntaxKind.OpenParenToken:
          break;
        default:
          throw new ArgumentException("openParenToken");
      }
      if (closeParenToken == null)
        throw new ArgumentNullException(nameof(closeParenToken));
      switch (closeParenToken.Kind)
      {
        case SyntaxKind.CloseParenToken:
          break;
        default:
          throw new ArgumentException("closeParenToken");
      }
#endif

      int hash;
      var cached = CSharpSyntaxNodeCache.TryGetNode((int)SyntaxKind.ParameterList, openParenToken, parameters.Node, closeParenToken, this.context, out hash);
      if (cached != null) return (ParameterListSyntax)cached;

      var result = new ParameterListSyntax(SyntaxKind.ParameterList, openParenToken, parameters.Node, closeParenToken, this.context);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public BracketedParameterListSyntax BracketedParameterList(SyntaxToken openBracketToken, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<ParameterSyntax> parameters, SyntaxToken closeBracketToken)
    {
#if DEBUG
      if (openBracketToken == null)
        throw new ArgumentNullException(nameof(openBracketToken));
      switch (openBracketToken.Kind)
      {
        case SyntaxKind.OpenBracketToken:
          break;
        default:
          throw new ArgumentException("openBracketToken");
      }
      if (closeBracketToken == null)
        throw new ArgumentNullException(nameof(closeBracketToken));
      switch (closeBracketToken.Kind)
      {
        case SyntaxKind.CloseBracketToken:
          break;
        default:
          throw new ArgumentException("closeBracketToken");
      }
#endif

      int hash;
      var cached = CSharpSyntaxNodeCache.TryGetNode((int)SyntaxKind.BracketedParameterList, openBracketToken, parameters.Node, closeBracketToken, this.context, out hash);
      if (cached != null) return (BracketedParameterListSyntax)cached;

      var result = new BracketedParameterListSyntax(SyntaxKind.BracketedParameterList, openBracketToken, parameters.Node, closeBracketToken, this.context);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public ParameterSyntax Parameter(Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<AttributeListSyntax> attributeLists, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SyntaxToken> modifiers, TypeSyntax type, SyntaxToken identifier, EqualsValueClauseSyntax @default)
    {
#if DEBUG
      if (identifier == null)
        throw new ArgumentNullException(nameof(identifier));
      switch (identifier.Kind)
      {
        case SyntaxKind.IdentifierToken:
        case SyntaxKind.ArgListKeyword:
          break;
        default:
          throw new ArgumentException("identifier");
      }
#endif

      return new ParameterSyntax(SyntaxKind.Parameter, attributeLists.Node, modifiers.Node, type, identifier, @default, this.context);
    }

    public IncompleteMemberSyntax IncompleteMember(Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<AttributeListSyntax> attributeLists, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SyntaxToken> modifiers, TypeSyntax type)
    {
#if DEBUG
#endif

      return new IncompleteMemberSyntax(SyntaxKind.IncompleteMember, attributeLists.Node, modifiers.Node, type, this.context);
    }

    public SkippedTokensTriviaSyntax SkippedTokensTrivia(Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SyntaxToken> tokens)
    {
#if DEBUG
#endif

      return new SkippedTokensTriviaSyntax(SyntaxKind.SkippedTokensTrivia, tokens.Node, this.context);
    }

    public DocumentationCommentTriviaSyntax DocumentationCommentTrivia(SyntaxKind kind, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<XmlNodeSyntax> content, SyntaxToken endOfComment)
    {
      switch (kind)
      {
        case SyntaxKind.SingleLineDocumentationCommentTrivia:
        case SyntaxKind.MultiLineDocumentationCommentTrivia:
          break;
        default:
          throw new ArgumentException("kind");
      }
#if DEBUG
      if (endOfComment == null)
        throw new ArgumentNullException(nameof(endOfComment));
      switch (endOfComment.Kind)
      {
        case SyntaxKind.EndOfDocumentationCommentToken:
          break;
        default:
          throw new ArgumentException("endOfComment");
      }
#endif

      return new DocumentationCommentTriviaSyntax(kind, content.Node, endOfComment, this.context);
    }

    public TypeCrefSyntax TypeCref(TypeSyntax type)
    {
#if DEBUG
      if (type == null)
        throw new ArgumentNullException(nameof(type));
#endif

      int hash;
      var cached = CSharpSyntaxNodeCache.TryGetNode((int)SyntaxKind.TypeCref, type, this.context, out hash);
      if (cached != null) return (TypeCrefSyntax)cached;

      var result = new TypeCrefSyntax(SyntaxKind.TypeCref, type, this.context);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public QualifiedCrefSyntax QualifiedCref(TypeSyntax container, SyntaxToken dotToken, MemberCrefSyntax member)
    {
#if DEBUG
      if (container == null)
        throw new ArgumentNullException(nameof(container));
      if (dotToken == null)
        throw new ArgumentNullException(nameof(dotToken));
      switch (dotToken.Kind)
      {
        case SyntaxKind.DotToken:
          break;
        default:
          throw new ArgumentException("dotToken");
      }
      if (member == null)
        throw new ArgumentNullException(nameof(member));
#endif

      int hash;
      var cached = CSharpSyntaxNodeCache.TryGetNode((int)SyntaxKind.QualifiedCref, container, dotToken, member, this.context, out hash);
      if (cached != null) return (QualifiedCrefSyntax)cached;

      var result = new QualifiedCrefSyntax(SyntaxKind.QualifiedCref, container, dotToken, member, this.context);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public NameMemberCrefSyntax NameMemberCref(TypeSyntax name, CrefParameterListSyntax parameters)
    {
#if DEBUG
      if (name == null)
        throw new ArgumentNullException(nameof(name));
#endif

      int hash;
      var cached = CSharpSyntaxNodeCache.TryGetNode((int)SyntaxKind.NameMemberCref, name, parameters, this.context, out hash);
      if (cached != null) return (NameMemberCrefSyntax)cached;

      var result = new NameMemberCrefSyntax(SyntaxKind.NameMemberCref, name, parameters, this.context);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public IndexerMemberCrefSyntax IndexerMemberCref(SyntaxToken thisKeyword, CrefBracketedParameterListSyntax parameters)
    {
#if DEBUG
      if (thisKeyword == null)
        throw new ArgumentNullException(nameof(thisKeyword));
      switch (thisKeyword.Kind)
      {
        case SyntaxKind.ThisKeyword:
          break;
        default:
          throw new ArgumentException("thisKeyword");
      }
#endif

      int hash;
      var cached = CSharpSyntaxNodeCache.TryGetNode((int)SyntaxKind.IndexerMemberCref, thisKeyword, parameters, this.context, out hash);
      if (cached != null) return (IndexerMemberCrefSyntax)cached;

      var result = new IndexerMemberCrefSyntax(SyntaxKind.IndexerMemberCref, thisKeyword, parameters, this.context);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public OperatorMemberCrefSyntax OperatorMemberCref(SyntaxToken operatorKeyword, SyntaxToken operatorToken, CrefParameterListSyntax parameters)
    {
#if DEBUG
      if (operatorKeyword == null)
        throw new ArgumentNullException(nameof(operatorKeyword));
      switch (operatorKeyword.Kind)
      {
        case SyntaxKind.OperatorKeyword:
          break;
        default:
          throw new ArgumentException("operatorKeyword");
      }
      if (operatorToken == null)
        throw new ArgumentNullException(nameof(operatorToken));
      switch (operatorToken.Kind)
      {
        case SyntaxKind.PlusToken:
        case SyntaxKind.MinusToken:
        case SyntaxKind.ExclamationToken:
        case SyntaxKind.TildeToken:
        case SyntaxKind.PlusPlusToken:
        case SyntaxKind.MinusMinusToken:
        case SyntaxKind.AsteriskToken:
        case SyntaxKind.SlashToken:
        case SyntaxKind.PercentToken:
        case SyntaxKind.LessThanLessThanToken:
        case SyntaxKind.GreaterThanGreaterThanToken:
        case SyntaxKind.BarToken:
        case SyntaxKind.AmpersandToken:
        case SyntaxKind.CaretToken:
        case SyntaxKind.EqualsEqualsToken:
        case SyntaxKind.ExclamationEqualsToken:
        case SyntaxKind.LessThanToken:
        case SyntaxKind.LessThanEqualsToken:
        case SyntaxKind.GreaterThanToken:
        case SyntaxKind.GreaterThanEqualsToken:
        case SyntaxKind.FalseKeyword:
        case SyntaxKind.TrueKeyword:
          break;
        default:
          throw new ArgumentException("operatorToken");
      }
#endif

      int hash;
      var cached = CSharpSyntaxNodeCache.TryGetNode((int)SyntaxKind.OperatorMemberCref, operatorKeyword, operatorToken, parameters, this.context, out hash);
      if (cached != null) return (OperatorMemberCrefSyntax)cached;

      var result = new OperatorMemberCrefSyntax(SyntaxKind.OperatorMemberCref, operatorKeyword, operatorToken, parameters, this.context);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public ConversionOperatorMemberCrefSyntax ConversionOperatorMemberCref(SyntaxToken implicitOrExplicitKeyword, SyntaxToken operatorKeyword, TypeSyntax type, CrefParameterListSyntax parameters)
    {
#if DEBUG
      if (implicitOrExplicitKeyword == null)
        throw new ArgumentNullException(nameof(implicitOrExplicitKeyword));
      switch (implicitOrExplicitKeyword.Kind)
      {
        case SyntaxKind.ImplicitKeyword:
        case SyntaxKind.ExplicitKeyword:
          break;
        default:
          throw new ArgumentException("implicitOrExplicitKeyword");
      }
      if (operatorKeyword == null)
        throw new ArgumentNullException(nameof(operatorKeyword));
      switch (operatorKeyword.Kind)
      {
        case SyntaxKind.OperatorKeyword:
          break;
        default:
          throw new ArgumentException("operatorKeyword");
      }
      if (type == null)
        throw new ArgumentNullException(nameof(type));
#endif

      return new ConversionOperatorMemberCrefSyntax(SyntaxKind.ConversionOperatorMemberCref, implicitOrExplicitKeyword, operatorKeyword, type, parameters, this.context);
    }

    public CrefParameterListSyntax CrefParameterList(SyntaxToken openParenToken, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<CrefParameterSyntax> parameters, SyntaxToken closeParenToken)
    {
#if DEBUG
      if (openParenToken == null)
        throw new ArgumentNullException(nameof(openParenToken));
      switch (openParenToken.Kind)
      {
        case SyntaxKind.OpenParenToken:
          break;
        default:
          throw new ArgumentException("openParenToken");
      }
      if (closeParenToken == null)
        throw new ArgumentNullException(nameof(closeParenToken));
      switch (closeParenToken.Kind)
      {
        case SyntaxKind.CloseParenToken:
          break;
        default:
          throw new ArgumentException("closeParenToken");
      }
#endif

      int hash;
      var cached = CSharpSyntaxNodeCache.TryGetNode((int)SyntaxKind.CrefParameterList, openParenToken, parameters.Node, closeParenToken, this.context, out hash);
      if (cached != null) return (CrefParameterListSyntax)cached;

      var result = new CrefParameterListSyntax(SyntaxKind.CrefParameterList, openParenToken, parameters.Node, closeParenToken, this.context);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public CrefBracketedParameterListSyntax CrefBracketedParameterList(SyntaxToken openBracketToken, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<CrefParameterSyntax> parameters, SyntaxToken closeBracketToken)
    {
#if DEBUG
      if (openBracketToken == null)
        throw new ArgumentNullException(nameof(openBracketToken));
      switch (openBracketToken.Kind)
      {
        case SyntaxKind.OpenBracketToken:
          break;
        default:
          throw new ArgumentException("openBracketToken");
      }
      if (closeBracketToken == null)
        throw new ArgumentNullException(nameof(closeBracketToken));
      switch (closeBracketToken.Kind)
      {
        case SyntaxKind.CloseBracketToken:
          break;
        default:
          throw new ArgumentException("closeBracketToken");
      }
#endif

      int hash;
      var cached = CSharpSyntaxNodeCache.TryGetNode((int)SyntaxKind.CrefBracketedParameterList, openBracketToken, parameters.Node, closeBracketToken, this.context, out hash);
      if (cached != null) return (CrefBracketedParameterListSyntax)cached;

      var result = new CrefBracketedParameterListSyntax(SyntaxKind.CrefBracketedParameterList, openBracketToken, parameters.Node, closeBracketToken, this.context);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public CrefParameterSyntax CrefParameter(SyntaxToken refOrOutKeyword, TypeSyntax type)
    {
#if DEBUG
      if (refOrOutKeyword != null)
      {
      switch (refOrOutKeyword.Kind)
      {
        case SyntaxKind.RefKeyword:
        case SyntaxKind.OutKeyword:
        case SyntaxKind.None:
          break;
        default:
          throw new ArgumentException("refOrOutKeyword");
      }
      }
      if (type == null)
        throw new ArgumentNullException(nameof(type));
#endif

      int hash;
      var cached = CSharpSyntaxNodeCache.TryGetNode((int)SyntaxKind.CrefParameter, refOrOutKeyword, type, this.context, out hash);
      if (cached != null) return (CrefParameterSyntax)cached;

      var result = new CrefParameterSyntax(SyntaxKind.CrefParameter, refOrOutKeyword, type, this.context);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public XmlElementSyntax XmlElement(XmlElementStartTagSyntax startTag, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<XmlNodeSyntax> content, XmlElementEndTagSyntax endTag)
    {
#if DEBUG
      if (startTag == null)
        throw new ArgumentNullException(nameof(startTag));
      if (endTag == null)
        throw new ArgumentNullException(nameof(endTag));
#endif

      int hash;
      var cached = CSharpSyntaxNodeCache.TryGetNode((int)SyntaxKind.XmlElement, startTag, content.Node, endTag, this.context, out hash);
      if (cached != null) return (XmlElementSyntax)cached;

      var result = new XmlElementSyntax(SyntaxKind.XmlElement, startTag, content.Node, endTag, this.context);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public XmlElementStartTagSyntax XmlElementStartTag(SyntaxToken lessThanToken, XmlNameSyntax name, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<XmlAttributeSyntax> attributes, SyntaxToken greaterThanToken)
    {
#if DEBUG
      if (lessThanToken == null)
        throw new ArgumentNullException(nameof(lessThanToken));
      switch (lessThanToken.Kind)
      {
        case SyntaxKind.LessThanToken:
          break;
        default:
          throw new ArgumentException("lessThanToken");
      }
      if (name == null)
        throw new ArgumentNullException(nameof(name));
      if (greaterThanToken == null)
        throw new ArgumentNullException(nameof(greaterThanToken));
      switch (greaterThanToken.Kind)
      {
        case SyntaxKind.GreaterThanToken:
          break;
        default:
          throw new ArgumentException("greaterThanToken");
      }
#endif

      return new XmlElementStartTagSyntax(SyntaxKind.XmlElementStartTag, lessThanToken, name, attributes.Node, greaterThanToken, this.context);
    }

    public XmlElementEndTagSyntax XmlElementEndTag(SyntaxToken lessThanSlashToken, XmlNameSyntax name, SyntaxToken greaterThanToken)
    {
#if DEBUG
      if (lessThanSlashToken == null)
        throw new ArgumentNullException(nameof(lessThanSlashToken));
      switch (lessThanSlashToken.Kind)
      {
        case SyntaxKind.LessThanSlashToken:
          break;
        default:
          throw new ArgumentException("lessThanSlashToken");
      }
      if (name == null)
        throw new ArgumentNullException(nameof(name));
      if (greaterThanToken == null)
        throw new ArgumentNullException(nameof(greaterThanToken));
      switch (greaterThanToken.Kind)
      {
        case SyntaxKind.GreaterThanToken:
          break;
        default:
          throw new ArgumentException("greaterThanToken");
      }
#endif

      int hash;
      var cached = CSharpSyntaxNodeCache.TryGetNode((int)SyntaxKind.XmlElementEndTag, lessThanSlashToken, name, greaterThanToken, this.context, out hash);
      if (cached != null) return (XmlElementEndTagSyntax)cached;

      var result = new XmlElementEndTagSyntax(SyntaxKind.XmlElementEndTag, lessThanSlashToken, name, greaterThanToken, this.context);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public XmlEmptyElementSyntax XmlEmptyElement(SyntaxToken lessThanToken, XmlNameSyntax name, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<XmlAttributeSyntax> attributes, SyntaxToken slashGreaterThanToken)
    {
#if DEBUG
      if (lessThanToken == null)
        throw new ArgumentNullException(nameof(lessThanToken));
      switch (lessThanToken.Kind)
      {
        case SyntaxKind.LessThanToken:
          break;
        default:
          throw new ArgumentException("lessThanToken");
      }
      if (name == null)
        throw new ArgumentNullException(nameof(name));
      if (slashGreaterThanToken == null)
        throw new ArgumentNullException(nameof(slashGreaterThanToken));
      switch (slashGreaterThanToken.Kind)
      {
        case SyntaxKind.SlashGreaterThanToken:
          break;
        default:
          throw new ArgumentException("slashGreaterThanToken");
      }
#endif

      return new XmlEmptyElementSyntax(SyntaxKind.XmlEmptyElement, lessThanToken, name, attributes.Node, slashGreaterThanToken, this.context);
    }

    public XmlNameSyntax XmlName(XmlPrefixSyntax prefix, SyntaxToken localName)
    {
#if DEBUG
      if (localName == null)
        throw new ArgumentNullException(nameof(localName));
      switch (localName.Kind)
      {
        case SyntaxKind.IdentifierToken:
          break;
        default:
          throw new ArgumentException("localName");
      }
#endif

      int hash;
      var cached = CSharpSyntaxNodeCache.TryGetNode((int)SyntaxKind.XmlName, prefix, localName, this.context, out hash);
      if (cached != null) return (XmlNameSyntax)cached;

      var result = new XmlNameSyntax(SyntaxKind.XmlName, prefix, localName, this.context);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public XmlPrefixSyntax XmlPrefix(SyntaxToken prefix, SyntaxToken colonToken)
    {
#if DEBUG
      if (prefix == null)
        throw new ArgumentNullException(nameof(prefix));
      switch (prefix.Kind)
      {
        case SyntaxKind.IdentifierToken:
          break;
        default:
          throw new ArgumentException("prefix");
      }
      if (colonToken == null)
        throw new ArgumentNullException(nameof(colonToken));
      switch (colonToken.Kind)
      {
        case SyntaxKind.ColonToken:
          break;
        default:
          throw new ArgumentException("colonToken");
      }
#endif

      int hash;
      var cached = CSharpSyntaxNodeCache.TryGetNode((int)SyntaxKind.XmlPrefix, prefix, colonToken, this.context, out hash);
      if (cached != null) return (XmlPrefixSyntax)cached;

      var result = new XmlPrefixSyntax(SyntaxKind.XmlPrefix, prefix, colonToken, this.context);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public XmlTextAttributeSyntax XmlTextAttribute(XmlNameSyntax name, SyntaxToken equalsToken, SyntaxToken startQuoteToken, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SyntaxToken> textTokens, SyntaxToken endQuoteToken)
    {
#if DEBUG
      if (name == null)
        throw new ArgumentNullException(nameof(name));
      if (equalsToken == null)
        throw new ArgumentNullException(nameof(equalsToken));
      switch (equalsToken.Kind)
      {
        case SyntaxKind.EqualsToken:
          break;
        default:
          throw new ArgumentException("equalsToken");
      }
      if (startQuoteToken == null)
        throw new ArgumentNullException(nameof(startQuoteToken));
      switch (startQuoteToken.Kind)
      {
        case SyntaxKind.SingleQuoteToken:
        case SyntaxKind.DoubleQuoteToken:
          break;
        default:
          throw new ArgumentException("startQuoteToken");
      }
      if (endQuoteToken == null)
        throw new ArgumentNullException(nameof(endQuoteToken));
      switch (endQuoteToken.Kind)
      {
        case SyntaxKind.SingleQuoteToken:
        case SyntaxKind.DoubleQuoteToken:
          break;
        default:
          throw new ArgumentException("endQuoteToken");
      }
#endif

      return new XmlTextAttributeSyntax(SyntaxKind.XmlTextAttribute, name, equalsToken, startQuoteToken, textTokens.Node, endQuoteToken, this.context);
    }

    public XmlCrefAttributeSyntax XmlCrefAttribute(XmlNameSyntax name, SyntaxToken equalsToken, SyntaxToken startQuoteToken, CrefSyntax cref, SyntaxToken endQuoteToken)
    {
#if DEBUG
      if (name == null)
        throw new ArgumentNullException(nameof(name));
      if (equalsToken == null)
        throw new ArgumentNullException(nameof(equalsToken));
      switch (equalsToken.Kind)
      {
        case SyntaxKind.EqualsToken:
          break;
        default:
          throw new ArgumentException("equalsToken");
      }
      if (startQuoteToken == null)
        throw new ArgumentNullException(nameof(startQuoteToken));
      switch (startQuoteToken.Kind)
      {
        case SyntaxKind.SingleQuoteToken:
        case SyntaxKind.DoubleQuoteToken:
          break;
        default:
          throw new ArgumentException("startQuoteToken");
      }
      if (cref == null)
        throw new ArgumentNullException(nameof(cref));
      if (endQuoteToken == null)
        throw new ArgumentNullException(nameof(endQuoteToken));
      switch (endQuoteToken.Kind)
      {
        case SyntaxKind.SingleQuoteToken:
        case SyntaxKind.DoubleQuoteToken:
          break;
        default:
          throw new ArgumentException("endQuoteToken");
      }
#endif

      return new XmlCrefAttributeSyntax(SyntaxKind.XmlCrefAttribute, name, equalsToken, startQuoteToken, cref, endQuoteToken, this.context);
    }

    public XmlNameAttributeSyntax XmlNameAttribute(XmlNameSyntax name, SyntaxToken equalsToken, SyntaxToken startQuoteToken, IdentifierNameSyntax identifier, SyntaxToken endQuoteToken)
    {
#if DEBUG
      if (name == null)
        throw new ArgumentNullException(nameof(name));
      if (equalsToken == null)
        throw new ArgumentNullException(nameof(equalsToken));
      switch (equalsToken.Kind)
      {
        case SyntaxKind.EqualsToken:
          break;
        default:
          throw new ArgumentException("equalsToken");
      }
      if (startQuoteToken == null)
        throw new ArgumentNullException(nameof(startQuoteToken));
      switch (startQuoteToken.Kind)
      {
        case SyntaxKind.SingleQuoteToken:
        case SyntaxKind.DoubleQuoteToken:
          break;
        default:
          throw new ArgumentException("startQuoteToken");
      }
      if (identifier == null)
        throw new ArgumentNullException(nameof(identifier));
      if (endQuoteToken == null)
        throw new ArgumentNullException(nameof(endQuoteToken));
      switch (endQuoteToken.Kind)
      {
        case SyntaxKind.SingleQuoteToken:
        case SyntaxKind.DoubleQuoteToken:
          break;
        default:
          throw new ArgumentException("endQuoteToken");
      }
#endif

      return new XmlNameAttributeSyntax(SyntaxKind.XmlNameAttribute, name, equalsToken, startQuoteToken, identifier, endQuoteToken, this.context);
    }

    public XmlTextSyntax XmlText(Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SyntaxToken> textTokens)
    {
#if DEBUG
#endif

      int hash;
      var cached = CSharpSyntaxNodeCache.TryGetNode((int)SyntaxKind.XmlText, textTokens.Node, this.context, out hash);
      if (cached != null) return (XmlTextSyntax)cached;

      var result = new XmlTextSyntax(SyntaxKind.XmlText, textTokens.Node, this.context);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public XmlCDataSectionSyntax XmlCDataSection(SyntaxToken startCDataToken, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SyntaxToken> textTokens, SyntaxToken endCDataToken)
    {
#if DEBUG
      if (startCDataToken == null)
        throw new ArgumentNullException(nameof(startCDataToken));
      switch (startCDataToken.Kind)
      {
        case SyntaxKind.XmlCDataStartToken:
          break;
        default:
          throw new ArgumentException("startCDataToken");
      }
      if (endCDataToken == null)
        throw new ArgumentNullException(nameof(endCDataToken));
      switch (endCDataToken.Kind)
      {
        case SyntaxKind.XmlCDataEndToken:
          break;
        default:
          throw new ArgumentException("endCDataToken");
      }
#endif

      int hash;
      var cached = CSharpSyntaxNodeCache.TryGetNode((int)SyntaxKind.XmlCDataSection, startCDataToken, textTokens.Node, endCDataToken, this.context, out hash);
      if (cached != null) return (XmlCDataSectionSyntax)cached;

      var result = new XmlCDataSectionSyntax(SyntaxKind.XmlCDataSection, startCDataToken, textTokens.Node, endCDataToken, this.context);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public XmlProcessingInstructionSyntax XmlProcessingInstruction(SyntaxToken startProcessingInstructionToken, XmlNameSyntax name, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SyntaxToken> textTokens, SyntaxToken endProcessingInstructionToken)
    {
#if DEBUG
      if (startProcessingInstructionToken == null)
        throw new ArgumentNullException(nameof(startProcessingInstructionToken));
      switch (startProcessingInstructionToken.Kind)
      {
        case SyntaxKind.XmlProcessingInstructionStartToken:
          break;
        default:
          throw new ArgumentException("startProcessingInstructionToken");
      }
      if (name == null)
        throw new ArgumentNullException(nameof(name));
      if (endProcessingInstructionToken == null)
        throw new ArgumentNullException(nameof(endProcessingInstructionToken));
      switch (endProcessingInstructionToken.Kind)
      {
        case SyntaxKind.XmlProcessingInstructionEndToken:
          break;
        default:
          throw new ArgumentException("endProcessingInstructionToken");
      }
#endif

      return new XmlProcessingInstructionSyntax(SyntaxKind.XmlProcessingInstruction, startProcessingInstructionToken, name, textTokens.Node, endProcessingInstructionToken, this.context);
    }

    public XmlCommentSyntax XmlComment(SyntaxToken lessThanExclamationMinusMinusToken, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SyntaxToken> textTokens, SyntaxToken minusMinusGreaterThanToken)
    {
#if DEBUG
      if (lessThanExclamationMinusMinusToken == null)
        throw new ArgumentNullException(nameof(lessThanExclamationMinusMinusToken));
      switch (lessThanExclamationMinusMinusToken.Kind)
      {
        case SyntaxKind.XmlCommentStartToken:
          break;
        default:
          throw new ArgumentException("lessThanExclamationMinusMinusToken");
      }
      if (minusMinusGreaterThanToken == null)
        throw new ArgumentNullException(nameof(minusMinusGreaterThanToken));
      switch (minusMinusGreaterThanToken.Kind)
      {
        case SyntaxKind.XmlCommentEndToken:
          break;
        default:
          throw new ArgumentException("minusMinusGreaterThanToken");
      }
#endif

      int hash;
      var cached = CSharpSyntaxNodeCache.TryGetNode((int)SyntaxKind.XmlComment, lessThanExclamationMinusMinusToken, textTokens.Node, minusMinusGreaterThanToken, this.context, out hash);
      if (cached != null) return (XmlCommentSyntax)cached;

      var result = new XmlCommentSyntax(SyntaxKind.XmlComment, lessThanExclamationMinusMinusToken, textTokens.Node, minusMinusGreaterThanToken, this.context);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public IfDirectiveTriviaSyntax IfDirectiveTrivia(SyntaxToken hashToken, SyntaxToken ifKeyword, ExpressionSyntax condition, SyntaxToken endOfDirectiveToken, bool isActive, bool branchTaken, bool conditionValue)
    {
#if DEBUG
      if (hashToken == null)
        throw new ArgumentNullException(nameof(hashToken));
      switch (hashToken.Kind)
      {
        case SyntaxKind.HashToken:
          break;
        default:
          throw new ArgumentException("hashToken");
      }
      if (ifKeyword == null)
        throw new ArgumentNullException(nameof(ifKeyword));
      switch (ifKeyword.Kind)
      {
        case SyntaxKind.IfKeyword:
          break;
        default:
          throw new ArgumentException("ifKeyword");
      }
      if (condition == null)
        throw new ArgumentNullException(nameof(condition));
      if (endOfDirectiveToken == null)
        throw new ArgumentNullException(nameof(endOfDirectiveToken));
      switch (endOfDirectiveToken.Kind)
      {
        case SyntaxKind.EndOfDirectiveToken:
          break;
        default:
          throw new ArgumentException("endOfDirectiveToken");
      }
#endif

      return new IfDirectiveTriviaSyntax(SyntaxKind.IfDirectiveTrivia, hashToken, ifKeyword, condition, endOfDirectiveToken, isActive, branchTaken, conditionValue, this.context);
    }

    public ElifDirectiveTriviaSyntax ElifDirectiveTrivia(SyntaxToken hashToken, SyntaxToken elifKeyword, ExpressionSyntax condition, SyntaxToken endOfDirectiveToken, bool isActive, bool branchTaken, bool conditionValue)
    {
#if DEBUG
      if (hashToken == null)
        throw new ArgumentNullException(nameof(hashToken));
      switch (hashToken.Kind)
      {
        case SyntaxKind.HashToken:
          break;
        default:
          throw new ArgumentException("hashToken");
      }
      if (elifKeyword == null)
        throw new ArgumentNullException(nameof(elifKeyword));
      switch (elifKeyword.Kind)
      {
        case SyntaxKind.ElifKeyword:
          break;
        default:
          throw new ArgumentException("elifKeyword");
      }
      if (condition == null)
        throw new ArgumentNullException(nameof(condition));
      if (endOfDirectiveToken == null)
        throw new ArgumentNullException(nameof(endOfDirectiveToken));
      switch (endOfDirectiveToken.Kind)
      {
        case SyntaxKind.EndOfDirectiveToken:
          break;
        default:
          throw new ArgumentException("endOfDirectiveToken");
      }
#endif

      return new ElifDirectiveTriviaSyntax(SyntaxKind.ElifDirectiveTrivia, hashToken, elifKeyword, condition, endOfDirectiveToken, isActive, branchTaken, conditionValue, this.context);
    }

    public ElseDirectiveTriviaSyntax ElseDirectiveTrivia(SyntaxToken hashToken, SyntaxToken elseKeyword, SyntaxToken endOfDirectiveToken, bool isActive, bool branchTaken)
    {
#if DEBUG
      if (hashToken == null)
        throw new ArgumentNullException(nameof(hashToken));
      switch (hashToken.Kind)
      {
        case SyntaxKind.HashToken:
          break;
        default:
          throw new ArgumentException("hashToken");
      }
      if (elseKeyword == null)
        throw new ArgumentNullException(nameof(elseKeyword));
      switch (elseKeyword.Kind)
      {
        case SyntaxKind.ElseKeyword:
          break;
        default:
          throw new ArgumentException("elseKeyword");
      }
      if (endOfDirectiveToken == null)
        throw new ArgumentNullException(nameof(endOfDirectiveToken));
      switch (endOfDirectiveToken.Kind)
      {
        case SyntaxKind.EndOfDirectiveToken:
          break;
        default:
          throw new ArgumentException("endOfDirectiveToken");
      }
#endif

      return new ElseDirectiveTriviaSyntax(SyntaxKind.ElseDirectiveTrivia, hashToken, elseKeyword, endOfDirectiveToken, isActive, branchTaken, this.context);
    }

    public EndIfDirectiveTriviaSyntax EndIfDirectiveTrivia(SyntaxToken hashToken, SyntaxToken endIfKeyword, SyntaxToken endOfDirectiveToken, bool isActive)
    {
#if DEBUG
      if (hashToken == null)
        throw new ArgumentNullException(nameof(hashToken));
      switch (hashToken.Kind)
      {
        case SyntaxKind.HashToken:
          break;
        default:
          throw new ArgumentException("hashToken");
      }
      if (endIfKeyword == null)
        throw new ArgumentNullException(nameof(endIfKeyword));
      switch (endIfKeyword.Kind)
      {
        case SyntaxKind.EndIfKeyword:
          break;
        default:
          throw new ArgumentException("endIfKeyword");
      }
      if (endOfDirectiveToken == null)
        throw new ArgumentNullException(nameof(endOfDirectiveToken));
      switch (endOfDirectiveToken.Kind)
      {
        case SyntaxKind.EndOfDirectiveToken:
          break;
        default:
          throw new ArgumentException("endOfDirectiveToken");
      }
#endif

      return new EndIfDirectiveTriviaSyntax(SyntaxKind.EndIfDirectiveTrivia, hashToken, endIfKeyword, endOfDirectiveToken, isActive, this.context);
    }

    public RegionDirectiveTriviaSyntax RegionDirectiveTrivia(SyntaxToken hashToken, SyntaxToken regionKeyword, SyntaxToken endOfDirectiveToken, bool isActive)
    {
#if DEBUG
      if (hashToken == null)
        throw new ArgumentNullException(nameof(hashToken));
      switch (hashToken.Kind)
      {
        case SyntaxKind.HashToken:
          break;
        default:
          throw new ArgumentException("hashToken");
      }
      if (regionKeyword == null)
        throw new ArgumentNullException(nameof(regionKeyword));
      switch (regionKeyword.Kind)
      {
        case SyntaxKind.RegionKeyword:
          break;
        default:
          throw new ArgumentException("regionKeyword");
      }
      if (endOfDirectiveToken == null)
        throw new ArgumentNullException(nameof(endOfDirectiveToken));
      switch (endOfDirectiveToken.Kind)
      {
        case SyntaxKind.EndOfDirectiveToken:
          break;
        default:
          throw new ArgumentException("endOfDirectiveToken");
      }
#endif

      return new RegionDirectiveTriviaSyntax(SyntaxKind.RegionDirectiveTrivia, hashToken, regionKeyword, endOfDirectiveToken, isActive, this.context);
    }

    public EndRegionDirectiveTriviaSyntax EndRegionDirectiveTrivia(SyntaxToken hashToken, SyntaxToken endRegionKeyword, SyntaxToken endOfDirectiveToken, bool isActive)
    {
#if DEBUG
      if (hashToken == null)
        throw new ArgumentNullException(nameof(hashToken));
      switch (hashToken.Kind)
      {
        case SyntaxKind.HashToken:
          break;
        default:
          throw new ArgumentException("hashToken");
      }
      if (endRegionKeyword == null)
        throw new ArgumentNullException(nameof(endRegionKeyword));
      switch (endRegionKeyword.Kind)
      {
        case SyntaxKind.EndRegionKeyword:
          break;
        default:
          throw new ArgumentException("endRegionKeyword");
      }
      if (endOfDirectiveToken == null)
        throw new ArgumentNullException(nameof(endOfDirectiveToken));
      switch (endOfDirectiveToken.Kind)
      {
        case SyntaxKind.EndOfDirectiveToken:
          break;
        default:
          throw new ArgumentException("endOfDirectiveToken");
      }
#endif

      return new EndRegionDirectiveTriviaSyntax(SyntaxKind.EndRegionDirectiveTrivia, hashToken, endRegionKeyword, endOfDirectiveToken, isActive, this.context);
    }

    public ErrorDirectiveTriviaSyntax ErrorDirectiveTrivia(SyntaxToken hashToken, SyntaxToken errorKeyword, SyntaxToken endOfDirectiveToken, bool isActive)
    {
#if DEBUG
      if (hashToken == null)
        throw new ArgumentNullException(nameof(hashToken));
      switch (hashToken.Kind)
      {
        case SyntaxKind.HashToken:
          break;
        default:
          throw new ArgumentException("hashToken");
      }
      if (errorKeyword == null)
        throw new ArgumentNullException(nameof(errorKeyword));
      switch (errorKeyword.Kind)
      {
        case SyntaxKind.ErrorKeyword:
          break;
        default:
          throw new ArgumentException("errorKeyword");
      }
      if (endOfDirectiveToken == null)
        throw new ArgumentNullException(nameof(endOfDirectiveToken));
      switch (endOfDirectiveToken.Kind)
      {
        case SyntaxKind.EndOfDirectiveToken:
          break;
        default:
          throw new ArgumentException("endOfDirectiveToken");
      }
#endif

      return new ErrorDirectiveTriviaSyntax(SyntaxKind.ErrorDirectiveTrivia, hashToken, errorKeyword, endOfDirectiveToken, isActive, this.context);
    }

    public WarningDirectiveTriviaSyntax WarningDirectiveTrivia(SyntaxToken hashToken, SyntaxToken warningKeyword, SyntaxToken endOfDirectiveToken, bool isActive)
    {
#if DEBUG
      if (hashToken == null)
        throw new ArgumentNullException(nameof(hashToken));
      switch (hashToken.Kind)
      {
        case SyntaxKind.HashToken:
          break;
        default:
          throw new ArgumentException("hashToken");
      }
      if (warningKeyword == null)
        throw new ArgumentNullException(nameof(warningKeyword));
      switch (warningKeyword.Kind)
      {
        case SyntaxKind.WarningKeyword:
          break;
        default:
          throw new ArgumentException("warningKeyword");
      }
      if (endOfDirectiveToken == null)
        throw new ArgumentNullException(nameof(endOfDirectiveToken));
      switch (endOfDirectiveToken.Kind)
      {
        case SyntaxKind.EndOfDirectiveToken:
          break;
        default:
          throw new ArgumentException("endOfDirectiveToken");
      }
#endif

      return new WarningDirectiveTriviaSyntax(SyntaxKind.WarningDirectiveTrivia, hashToken, warningKeyword, endOfDirectiveToken, isActive, this.context);
    }

    public BadDirectiveTriviaSyntax BadDirectiveTrivia(SyntaxToken hashToken, SyntaxToken identifier, SyntaxToken endOfDirectiveToken, bool isActive)
    {
#if DEBUG
      if (hashToken == null)
        throw new ArgumentNullException(nameof(hashToken));
      switch (hashToken.Kind)
      {
        case SyntaxKind.HashToken:
          break;
        default:
          throw new ArgumentException("hashToken");
      }
      if (identifier == null)
        throw new ArgumentNullException(nameof(identifier));
      if (endOfDirectiveToken == null)
        throw new ArgumentNullException(nameof(endOfDirectiveToken));
      switch (endOfDirectiveToken.Kind)
      {
        case SyntaxKind.EndOfDirectiveToken:
          break;
        default:
          throw new ArgumentException("endOfDirectiveToken");
      }
#endif

      return new BadDirectiveTriviaSyntax(SyntaxKind.BadDirectiveTrivia, hashToken, identifier, endOfDirectiveToken, isActive, this.context);
    }

    public DefineDirectiveTriviaSyntax DefineDirectiveTrivia(SyntaxToken hashToken, SyntaxToken defineKeyword, SyntaxToken name, SyntaxToken endOfDirectiveToken, bool isActive)
    {
#if DEBUG
      if (hashToken == null)
        throw new ArgumentNullException(nameof(hashToken));
      switch (hashToken.Kind)
      {
        case SyntaxKind.HashToken:
          break;
        default:
          throw new ArgumentException("hashToken");
      }
      if (defineKeyword == null)
        throw new ArgumentNullException(nameof(defineKeyword));
      switch (defineKeyword.Kind)
      {
        case SyntaxKind.DefineKeyword:
          break;
        default:
          throw new ArgumentException("defineKeyword");
      }
      if (name == null)
        throw new ArgumentNullException(nameof(name));
      switch (name.Kind)
      {
        case SyntaxKind.IdentifierToken:
          break;
        default:
          throw new ArgumentException("name");
      }
      if (endOfDirectiveToken == null)
        throw new ArgumentNullException(nameof(endOfDirectiveToken));
      switch (endOfDirectiveToken.Kind)
      {
        case SyntaxKind.EndOfDirectiveToken:
          break;
        default:
          throw new ArgumentException("endOfDirectiveToken");
      }
#endif

      return new DefineDirectiveTriviaSyntax(SyntaxKind.DefineDirectiveTrivia, hashToken, defineKeyword, name, endOfDirectiveToken, isActive, this.context);
    }

    public UndefDirectiveTriviaSyntax UndefDirectiveTrivia(SyntaxToken hashToken, SyntaxToken undefKeyword, SyntaxToken name, SyntaxToken endOfDirectiveToken, bool isActive)
    {
#if DEBUG
      if (hashToken == null)
        throw new ArgumentNullException(nameof(hashToken));
      switch (hashToken.Kind)
      {
        case SyntaxKind.HashToken:
          break;
        default:
          throw new ArgumentException("hashToken");
      }
      if (undefKeyword == null)
        throw new ArgumentNullException(nameof(undefKeyword));
      switch (undefKeyword.Kind)
      {
        case SyntaxKind.UndefKeyword:
          break;
        default:
          throw new ArgumentException("undefKeyword");
      }
      if (name == null)
        throw new ArgumentNullException(nameof(name));
      switch (name.Kind)
      {
        case SyntaxKind.IdentifierToken:
          break;
        default:
          throw new ArgumentException("name");
      }
      if (endOfDirectiveToken == null)
        throw new ArgumentNullException(nameof(endOfDirectiveToken));
      switch (endOfDirectiveToken.Kind)
      {
        case SyntaxKind.EndOfDirectiveToken:
          break;
        default:
          throw new ArgumentException("endOfDirectiveToken");
      }
#endif

      return new UndefDirectiveTriviaSyntax(SyntaxKind.UndefDirectiveTrivia, hashToken, undefKeyword, name, endOfDirectiveToken, isActive, this.context);
    }

    public LineDirectiveTriviaSyntax LineDirectiveTrivia(SyntaxToken hashToken, SyntaxToken lineKeyword, SyntaxToken line, SyntaxToken file, SyntaxToken endOfDirectiveToken, bool isActive)
    {
#if DEBUG
      if (hashToken == null)
        throw new ArgumentNullException(nameof(hashToken));
      switch (hashToken.Kind)
      {
        case SyntaxKind.HashToken:
          break;
        default:
          throw new ArgumentException("hashToken");
      }
      if (lineKeyword == null)
        throw new ArgumentNullException(nameof(lineKeyword));
      switch (lineKeyword.Kind)
      {
        case SyntaxKind.LineKeyword:
          break;
        default:
          throw new ArgumentException("lineKeyword");
      }
      if (line == null)
        throw new ArgumentNullException(nameof(line));
      switch (line.Kind)
      {
        case SyntaxKind.NumericLiteralToken:
        case SyntaxKind.DefaultKeyword:
        case SyntaxKind.HiddenKeyword:
          break;
        default:
          throw new ArgumentException("line");
      }
      if (file != null)
      {
      switch (file.Kind)
      {
        case SyntaxKind.StringLiteralToken:
        case SyntaxKind.None:
          break;
        default:
          throw new ArgumentException("file");
      }
      }
      if (endOfDirectiveToken == null)
        throw new ArgumentNullException(nameof(endOfDirectiveToken));
      switch (endOfDirectiveToken.Kind)
      {
        case SyntaxKind.EndOfDirectiveToken:
          break;
        default:
          throw new ArgumentException("endOfDirectiveToken");
      }
#endif

      return new LineDirectiveTriviaSyntax(SyntaxKind.LineDirectiveTrivia, hashToken, lineKeyword, line, file, endOfDirectiveToken, isActive, this.context);
    }

    public PragmaWarningDirectiveTriviaSyntax PragmaWarningDirectiveTrivia(SyntaxToken hashToken, SyntaxToken pragmaKeyword, SyntaxToken warningKeyword, SyntaxToken disableOrRestoreKeyword, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<ExpressionSyntax> errorCodes, SyntaxToken endOfDirectiveToken, bool isActive)
    {
#if DEBUG
      if (hashToken == null)
        throw new ArgumentNullException(nameof(hashToken));
      switch (hashToken.Kind)
      {
        case SyntaxKind.HashToken:
          break;
        default:
          throw new ArgumentException("hashToken");
      }
      if (pragmaKeyword == null)
        throw new ArgumentNullException(nameof(pragmaKeyword));
      switch (pragmaKeyword.Kind)
      {
        case SyntaxKind.PragmaKeyword:
          break;
        default:
          throw new ArgumentException("pragmaKeyword");
      }
      if (warningKeyword == null)
        throw new ArgumentNullException(nameof(warningKeyword));
      switch (warningKeyword.Kind)
      {
        case SyntaxKind.WarningKeyword:
          break;
        default:
          throw new ArgumentException("warningKeyword");
      }
      if (disableOrRestoreKeyword == null)
        throw new ArgumentNullException(nameof(disableOrRestoreKeyword));
      switch (disableOrRestoreKeyword.Kind)
      {
        case SyntaxKind.DisableKeyword:
        case SyntaxKind.RestoreKeyword:
          break;
        default:
          throw new ArgumentException("disableOrRestoreKeyword");
      }
      if (endOfDirectiveToken == null)
        throw new ArgumentNullException(nameof(endOfDirectiveToken));
      switch (endOfDirectiveToken.Kind)
      {
        case SyntaxKind.EndOfDirectiveToken:
          break;
        default:
          throw new ArgumentException("endOfDirectiveToken");
      }
#endif

      return new PragmaWarningDirectiveTriviaSyntax(SyntaxKind.PragmaWarningDirectiveTrivia, hashToken, pragmaKeyword, warningKeyword, disableOrRestoreKeyword, errorCodes.Node, endOfDirectiveToken, isActive, this.context);
    }

    public PragmaChecksumDirectiveTriviaSyntax PragmaChecksumDirectiveTrivia(SyntaxToken hashToken, SyntaxToken pragmaKeyword, SyntaxToken checksumKeyword, SyntaxToken file, SyntaxToken guid, SyntaxToken bytes, SyntaxToken endOfDirectiveToken, bool isActive)
    {
#if DEBUG
      if (hashToken == null)
        throw new ArgumentNullException(nameof(hashToken));
      switch (hashToken.Kind)
      {
        case SyntaxKind.HashToken:
          break;
        default:
          throw new ArgumentException("hashToken");
      }
      if (pragmaKeyword == null)
        throw new ArgumentNullException(nameof(pragmaKeyword));
      switch (pragmaKeyword.Kind)
      {
        case SyntaxKind.PragmaKeyword:
          break;
        default:
          throw new ArgumentException("pragmaKeyword");
      }
      if (checksumKeyword == null)
        throw new ArgumentNullException(nameof(checksumKeyword));
      switch (checksumKeyword.Kind)
      {
        case SyntaxKind.ChecksumKeyword:
          break;
        default:
          throw new ArgumentException("checksumKeyword");
      }
      if (file == null)
        throw new ArgumentNullException(nameof(file));
      switch (file.Kind)
      {
        case SyntaxKind.StringLiteralToken:
          break;
        default:
          throw new ArgumentException("file");
      }
      if (guid == null)
        throw new ArgumentNullException(nameof(guid));
      switch (guid.Kind)
      {
        case SyntaxKind.StringLiteralToken:
          break;
        default:
          throw new ArgumentException("guid");
      }
      if (bytes == null)
        throw new ArgumentNullException(nameof(bytes));
      switch (bytes.Kind)
      {
        case SyntaxKind.StringLiteralToken:
          break;
        default:
          throw new ArgumentException("bytes");
      }
      if (endOfDirectiveToken == null)
        throw new ArgumentNullException(nameof(endOfDirectiveToken));
      switch (endOfDirectiveToken.Kind)
      {
        case SyntaxKind.EndOfDirectiveToken:
          break;
        default:
          throw new ArgumentException("endOfDirectiveToken");
      }
#endif

      return new PragmaChecksumDirectiveTriviaSyntax(SyntaxKind.PragmaChecksumDirectiveTrivia, hashToken, pragmaKeyword, checksumKeyword, file, guid, bytes, endOfDirectiveToken, isActive, this.context);
    }

    public ReferenceDirectiveTriviaSyntax ReferenceDirectiveTrivia(SyntaxToken hashToken, SyntaxToken referenceKeyword, SyntaxToken file, SyntaxToken endOfDirectiveToken, bool isActive)
    {
#if DEBUG
      if (hashToken == null)
        throw new ArgumentNullException(nameof(hashToken));
      switch (hashToken.Kind)
      {
        case SyntaxKind.HashToken:
          break;
        default:
          throw new ArgumentException("hashToken");
      }
      if (referenceKeyword == null)
        throw new ArgumentNullException(nameof(referenceKeyword));
      switch (referenceKeyword.Kind)
      {
        case SyntaxKind.ReferenceKeyword:
          break;
        default:
          throw new ArgumentException("referenceKeyword");
      }
      if (file == null)
        throw new ArgumentNullException(nameof(file));
      switch (file.Kind)
      {
        case SyntaxKind.StringLiteralToken:
          break;
        default:
          throw new ArgumentException("file");
      }
      if (endOfDirectiveToken == null)
        throw new ArgumentNullException(nameof(endOfDirectiveToken));
      switch (endOfDirectiveToken.Kind)
      {
        case SyntaxKind.EndOfDirectiveToken:
          break;
        default:
          throw new ArgumentException("endOfDirectiveToken");
      }
#endif

      return new ReferenceDirectiveTriviaSyntax(SyntaxKind.ReferenceDirectiveTrivia, hashToken, referenceKeyword, file, endOfDirectiveToken, isActive, this.context);
    }

    public LoadDirectiveTriviaSyntax LoadDirectiveTrivia(SyntaxToken hashToken, SyntaxToken loadKeyword, SyntaxToken file, SyntaxToken endOfDirectiveToken, bool isActive)
    {
#if DEBUG
      if (hashToken == null)
        throw new ArgumentNullException(nameof(hashToken));
      switch (hashToken.Kind)
      {
        case SyntaxKind.HashToken:
          break;
        default:
          throw new ArgumentException("hashToken");
      }
      if (loadKeyword == null)
        throw new ArgumentNullException(nameof(loadKeyword));
      switch (loadKeyword.Kind)
      {
        case SyntaxKind.LoadKeyword:
          break;
        default:
          throw new ArgumentException("loadKeyword");
      }
      if (file == null)
        throw new ArgumentNullException(nameof(file));
      switch (file.Kind)
      {
        case SyntaxKind.StringLiteralToken:
          break;
        default:
          throw new ArgumentException("file");
      }
      if (endOfDirectiveToken == null)
        throw new ArgumentNullException(nameof(endOfDirectiveToken));
      switch (endOfDirectiveToken.Kind)
      {
        case SyntaxKind.EndOfDirectiveToken:
          break;
        default:
          throw new ArgumentException("endOfDirectiveToken");
      }
#endif

      return new LoadDirectiveTriviaSyntax(SyntaxKind.LoadDirectiveTrivia, hashToken, loadKeyword, file, endOfDirectiveToken, isActive, this.context);
    }

    public ShebangDirectiveTriviaSyntax ShebangDirectiveTrivia(SyntaxToken hashToken, SyntaxToken exclamationToken, SyntaxToken endOfDirectiveToken, bool isActive)
    {
#if DEBUG
      if (hashToken == null)
        throw new ArgumentNullException(nameof(hashToken));
      switch (hashToken.Kind)
      {
        case SyntaxKind.HashToken:
          break;
        default:
          throw new ArgumentException("hashToken");
      }
      if (exclamationToken == null)
        throw new ArgumentNullException(nameof(exclamationToken));
      switch (exclamationToken.Kind)
      {
        case SyntaxKind.ExclamationToken:
          break;
        default:
          throw new ArgumentException("exclamationToken");
      }
      if (endOfDirectiveToken == null)
        throw new ArgumentNullException(nameof(endOfDirectiveToken));
      switch (endOfDirectiveToken.Kind)
      {
        case SyntaxKind.EndOfDirectiveToken:
          break;
        default:
          throw new ArgumentException("endOfDirectiveToken");
      }
#endif

      return new ShebangDirectiveTriviaSyntax(SyntaxKind.ShebangDirectiveTrivia, hashToken, exclamationToken, endOfDirectiveToken, isActive, this.context);
    }
  }

  internal static partial class SyntaxFactory
  {
    public static IdentifierNameSyntax IdentifierName(SyntaxToken identifier)
    {
#if DEBUG
      if (identifier == null)
        throw new ArgumentNullException(nameof(identifier));
      switch (identifier.Kind)
      {
        case SyntaxKind.IdentifierToken:
        case SyntaxKind.GlobalKeyword:
          break;
        default:
          throw new ArgumentException("identifier");
      }
#endif

      int hash;
      var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.IdentifierName, identifier, out hash);
      if (cached != null) return (IdentifierNameSyntax)cached;

      var result = new IdentifierNameSyntax(SyntaxKind.IdentifierName, identifier);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public static QualifiedNameSyntax QualifiedName(NameSyntax left, SyntaxToken dotToken, SimpleNameSyntax right)
    {
#if DEBUG
      if (left == null)
        throw new ArgumentNullException(nameof(left));
      if (dotToken == null)
        throw new ArgumentNullException(nameof(dotToken));
      switch (dotToken.Kind)
      {
        case SyntaxKind.DotToken:
          break;
        default:
          throw new ArgumentException("dotToken");
      }
      if (right == null)
        throw new ArgumentNullException(nameof(right));
#endif

      int hash;
      var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.QualifiedName, left, dotToken, right, out hash);
      if (cached != null) return (QualifiedNameSyntax)cached;

      var result = new QualifiedNameSyntax(SyntaxKind.QualifiedName, left, dotToken, right);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public static GenericNameSyntax GenericName(SyntaxToken identifier, TypeArgumentListSyntax typeArgumentList)
    {
#if DEBUG
      if (identifier == null)
        throw new ArgumentNullException(nameof(identifier));
      switch (identifier.Kind)
      {
        case SyntaxKind.IdentifierToken:
          break;
        default:
          throw new ArgumentException("identifier");
      }
      if (typeArgumentList == null)
        throw new ArgumentNullException(nameof(typeArgumentList));
#endif

      int hash;
      var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.GenericName, identifier, typeArgumentList, out hash);
      if (cached != null) return (GenericNameSyntax)cached;

      var result = new GenericNameSyntax(SyntaxKind.GenericName, identifier, typeArgumentList);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public static TypeArgumentListSyntax TypeArgumentList(SyntaxToken lessThanToken, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<TypeSyntax> arguments, SyntaxToken greaterThanToken)
    {
#if DEBUG
      if (lessThanToken == null)
        throw new ArgumentNullException(nameof(lessThanToken));
      switch (lessThanToken.Kind)
      {
        case SyntaxKind.LessThanToken:
          break;
        default:
          throw new ArgumentException("lessThanToken");
      }
      if (greaterThanToken == null)
        throw new ArgumentNullException(nameof(greaterThanToken));
      switch (greaterThanToken.Kind)
      {
        case SyntaxKind.GreaterThanToken:
          break;
        default:
          throw new ArgumentException("greaterThanToken");
      }
#endif

      int hash;
      var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.TypeArgumentList, lessThanToken, arguments.Node, greaterThanToken, out hash);
      if (cached != null) return (TypeArgumentListSyntax)cached;

      var result = new TypeArgumentListSyntax(SyntaxKind.TypeArgumentList, lessThanToken, arguments.Node, greaterThanToken);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public static AliasQualifiedNameSyntax AliasQualifiedName(IdentifierNameSyntax alias, SyntaxToken colonColonToken, SimpleNameSyntax name)
    {
#if DEBUG
      if (alias == null)
        throw new ArgumentNullException(nameof(alias));
      if (colonColonToken == null)
        throw new ArgumentNullException(nameof(colonColonToken));
      switch (colonColonToken.Kind)
      {
        case SyntaxKind.ColonColonToken:
          break;
        default:
          throw new ArgumentException("colonColonToken");
      }
      if (name == null)
        throw new ArgumentNullException(nameof(name));
#endif

      int hash;
      var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.AliasQualifiedName, alias, colonColonToken, name, out hash);
      if (cached != null) return (AliasQualifiedNameSyntax)cached;

      var result = new AliasQualifiedNameSyntax(SyntaxKind.AliasQualifiedName, alias, colonColonToken, name);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public static PredefinedTypeSyntax PredefinedType(SyntaxToken keyword)
    {
#if DEBUG
      if (keyword == null)
        throw new ArgumentNullException(nameof(keyword));
      switch (keyword.Kind)
      {
        case SyntaxKind.BoolKeyword:
        case SyntaxKind.ByteKeyword:
        case SyntaxKind.SByteKeyword:
        case SyntaxKind.IntKeyword:
        case SyntaxKind.UIntKeyword:
        case SyntaxKind.ShortKeyword:
        case SyntaxKind.UShortKeyword:
        case SyntaxKind.LongKeyword:
        case SyntaxKind.ULongKeyword:
        case SyntaxKind.FloatKeyword:
        case SyntaxKind.DoubleKeyword:
        case SyntaxKind.DecimalKeyword:
        case SyntaxKind.StringKeyword:
        case SyntaxKind.CharKeyword:
        case SyntaxKind.ObjectKeyword:
        case SyntaxKind.VoidKeyword:
          break;
        default:
          throw new ArgumentException("keyword");
      }
#endif

      int hash;
      var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.PredefinedType, keyword, out hash);
      if (cached != null) return (PredefinedTypeSyntax)cached;

      var result = new PredefinedTypeSyntax(SyntaxKind.PredefinedType, keyword);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public static ArrayTypeSyntax ArrayType(TypeSyntax elementType, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<ArrayRankSpecifierSyntax> rankSpecifiers)
    {
#if DEBUG
      if (elementType == null)
        throw new ArgumentNullException(nameof(elementType));
#endif

      int hash;
      var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.ArrayType, elementType, rankSpecifiers.Node, out hash);
      if (cached != null) return (ArrayTypeSyntax)cached;

      var result = new ArrayTypeSyntax(SyntaxKind.ArrayType, elementType, rankSpecifiers.Node);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public static ArrayRankSpecifierSyntax ArrayRankSpecifier(SyntaxToken openBracketToken, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<ExpressionSyntax> sizes, SyntaxToken closeBracketToken)
    {
#if DEBUG
      if (openBracketToken == null)
        throw new ArgumentNullException(nameof(openBracketToken));
      switch (openBracketToken.Kind)
      {
        case SyntaxKind.OpenBracketToken:
          break;
        default:
          throw new ArgumentException("openBracketToken");
      }
      if (closeBracketToken == null)
        throw new ArgumentNullException(nameof(closeBracketToken));
      switch (closeBracketToken.Kind)
      {
        case SyntaxKind.CloseBracketToken:
          break;
        default:
          throw new ArgumentException("closeBracketToken");
      }
#endif

      int hash;
      var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.ArrayRankSpecifier, openBracketToken, sizes.Node, closeBracketToken, out hash);
      if (cached != null) return (ArrayRankSpecifierSyntax)cached;

      var result = new ArrayRankSpecifierSyntax(SyntaxKind.ArrayRankSpecifier, openBracketToken, sizes.Node, closeBracketToken);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public static PointerTypeSyntax PointerType(TypeSyntax elementType, SyntaxToken asteriskToken)
    {
#if DEBUG
      if (elementType == null)
        throw new ArgumentNullException(nameof(elementType));
      if (asteriskToken == null)
        throw new ArgumentNullException(nameof(asteriskToken));
      switch (asteriskToken.Kind)
      {
        case SyntaxKind.AsteriskToken:
          break;
        default:
          throw new ArgumentException("asteriskToken");
      }
#endif

      int hash;
      var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.PointerType, elementType, asteriskToken, out hash);
      if (cached != null) return (PointerTypeSyntax)cached;

      var result = new PointerTypeSyntax(SyntaxKind.PointerType, elementType, asteriskToken);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public static NullableTypeSyntax NullableType(TypeSyntax elementType, SyntaxToken questionToken)
    {
#if DEBUG
      if (elementType == null)
        throw new ArgumentNullException(nameof(elementType));
      if (questionToken == null)
        throw new ArgumentNullException(nameof(questionToken));
      switch (questionToken.Kind)
      {
        case SyntaxKind.QuestionToken:
          break;
        default:
          throw new ArgumentException("questionToken");
      }
#endif

      int hash;
      var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.NullableType, elementType, questionToken, out hash);
      if (cached != null) return (NullableTypeSyntax)cached;

      var result = new NullableTypeSyntax(SyntaxKind.NullableType, elementType, questionToken);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public static TupleTypeSyntax TupleType(SyntaxToken openParenToken, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<TupleElementSyntax> elements, SyntaxToken closeParenToken)
    {
#if DEBUG
      if (openParenToken == null)
        throw new ArgumentNullException(nameof(openParenToken));
      switch (openParenToken.Kind)
      {
        case SyntaxKind.OpenParenToken:
          break;
        default:
          throw new ArgumentException("openParenToken");
      }
      if (closeParenToken == null)
        throw new ArgumentNullException(nameof(closeParenToken));
      switch (closeParenToken.Kind)
      {
        case SyntaxKind.CloseParenToken:
          break;
        default:
          throw new ArgumentException("closeParenToken");
      }
#endif

      int hash;
      var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.TupleType, openParenToken, elements.Node, closeParenToken, out hash);
      if (cached != null) return (TupleTypeSyntax)cached;

      var result = new TupleTypeSyntax(SyntaxKind.TupleType, openParenToken, elements.Node, closeParenToken);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public static TupleElementSyntax TupleElement(TypeSyntax type, SyntaxToken identifier)
    {
#if DEBUG
      if (type == null)
        throw new ArgumentNullException(nameof(type));
      if (identifier != null)
      {
      switch (identifier.Kind)
      {
        case SyntaxKind.IdentifierToken:
        case SyntaxKind.None:
          break;
        default:
          throw new ArgumentException("identifier");
      }
      }
#endif

      int hash;
      var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.TupleElement, type, identifier, out hash);
      if (cached != null) return (TupleElementSyntax)cached;

      var result = new TupleElementSyntax(SyntaxKind.TupleElement, type, identifier);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public static OmittedTypeArgumentSyntax OmittedTypeArgument(SyntaxToken omittedTypeArgumentToken)
    {
#if DEBUG
      if (omittedTypeArgumentToken == null)
        throw new ArgumentNullException(nameof(omittedTypeArgumentToken));
      switch (omittedTypeArgumentToken.Kind)
      {
        case SyntaxKind.OmittedTypeArgumentToken:
          break;
        default:
          throw new ArgumentException("omittedTypeArgumentToken");
      }
#endif

      int hash;
      var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.OmittedTypeArgument, omittedTypeArgumentToken, out hash);
      if (cached != null) return (OmittedTypeArgumentSyntax)cached;

      var result = new OmittedTypeArgumentSyntax(SyntaxKind.OmittedTypeArgument, omittedTypeArgumentToken);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public static RefTypeSyntax RefType(SyntaxToken refKeyword, TypeSyntax type)
    {
#if DEBUG
      if (refKeyword == null)
        throw new ArgumentNullException(nameof(refKeyword));
      switch (refKeyword.Kind)
      {
        case SyntaxKind.RefKeyword:
          break;
        default:
          throw new ArgumentException("refKeyword");
      }
      if (type == null)
        throw new ArgumentNullException(nameof(type));
#endif

      int hash;
      var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.RefType, refKeyword, type, out hash);
      if (cached != null) return (RefTypeSyntax)cached;

      var result = new RefTypeSyntax(SyntaxKind.RefType, refKeyword, type);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public static ParenthesizedExpressionSyntax ParenthesizedExpression(SyntaxToken openParenToken, ExpressionSyntax expression, SyntaxToken closeParenToken)
    {
#if DEBUG
      if (openParenToken == null)
        throw new ArgumentNullException(nameof(openParenToken));
      switch (openParenToken.Kind)
      {
        case SyntaxKind.OpenParenToken:
          break;
        default:
          throw new ArgumentException("openParenToken");
      }
      if (expression == null)
        throw new ArgumentNullException(nameof(expression));
      if (closeParenToken == null)
        throw new ArgumentNullException(nameof(closeParenToken));
      switch (closeParenToken.Kind)
      {
        case SyntaxKind.CloseParenToken:
          break;
        default:
          throw new ArgumentException("closeParenToken");
      }
#endif

      int hash;
      var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.ParenthesizedExpression, openParenToken, expression, closeParenToken, out hash);
      if (cached != null) return (ParenthesizedExpressionSyntax)cached;

      var result = new ParenthesizedExpressionSyntax(SyntaxKind.ParenthesizedExpression, openParenToken, expression, closeParenToken);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public static TupleExpressionSyntax TupleExpression(SyntaxToken openParenToken, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<ArgumentSyntax> arguments, SyntaxToken closeParenToken)
    {
#if DEBUG
      if (openParenToken == null)
        throw new ArgumentNullException(nameof(openParenToken));
      switch (openParenToken.Kind)
      {
        case SyntaxKind.OpenParenToken:
          break;
        default:
          throw new ArgumentException("openParenToken");
      }
      if (closeParenToken == null)
        throw new ArgumentNullException(nameof(closeParenToken));
      switch (closeParenToken.Kind)
      {
        case SyntaxKind.CloseParenToken:
          break;
        default:
          throw new ArgumentException("closeParenToken");
      }
#endif

      int hash;
      var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.TupleExpression, openParenToken, arguments.Node, closeParenToken, out hash);
      if (cached != null) return (TupleExpressionSyntax)cached;

      var result = new TupleExpressionSyntax(SyntaxKind.TupleExpression, openParenToken, arguments.Node, closeParenToken);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public static PrefixUnaryExpressionSyntax PrefixUnaryExpression(SyntaxKind kind, SyntaxToken operatorToken, ExpressionSyntax operand)
    {
      switch (kind)
      {
        case SyntaxKind.UnaryPlusExpression:
        case SyntaxKind.UnaryMinusExpression:
        case SyntaxKind.BitwiseNotExpression:
        case SyntaxKind.LogicalNotExpression:
        case SyntaxKind.PreIncrementExpression:
        case SyntaxKind.PreDecrementExpression:
        case SyntaxKind.AddressOfExpression:
        case SyntaxKind.PointerIndirectionExpression:
          break;
        default:
          throw new ArgumentException("kind");
      }
#if DEBUG
      if (operatorToken == null)
        throw new ArgumentNullException(nameof(operatorToken));
      switch (operatorToken.Kind)
      {
        case SyntaxKind.PlusToken:
        case SyntaxKind.MinusToken:
        case SyntaxKind.TildeToken:
        case SyntaxKind.ExclamationToken:
        case SyntaxKind.PlusPlusToken:
        case SyntaxKind.MinusMinusToken:
        case SyntaxKind.AmpersandToken:
        case SyntaxKind.AsteriskToken:
          break;
        default:
          throw new ArgumentException("operatorToken");
      }
      if (operand == null)
        throw new ArgumentNullException(nameof(operand));
#endif

      int hash;
      var cached = SyntaxNodeCache.TryGetNode((int)kind, operatorToken, operand, out hash);
      if (cached != null) return (PrefixUnaryExpressionSyntax)cached;

      var result = new PrefixUnaryExpressionSyntax(kind, operatorToken, operand);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public static AwaitExpressionSyntax AwaitExpression(SyntaxToken awaitKeyword, ExpressionSyntax expression)
    {
#if DEBUG
      if (awaitKeyword == null)
        throw new ArgumentNullException(nameof(awaitKeyword));
      switch (awaitKeyword.Kind)
      {
        case SyntaxKind.AwaitKeyword:
          break;
        default:
          throw new ArgumentException("awaitKeyword");
      }
      if (expression == null)
        throw new ArgumentNullException(nameof(expression));
#endif

      int hash;
      var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.AwaitExpression, awaitKeyword, expression, out hash);
      if (cached != null) return (AwaitExpressionSyntax)cached;

      var result = new AwaitExpressionSyntax(SyntaxKind.AwaitExpression, awaitKeyword, expression);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public static PostfixUnaryExpressionSyntax PostfixUnaryExpression(SyntaxKind kind, ExpressionSyntax operand, SyntaxToken operatorToken)
    {
      switch (kind)
      {
        case SyntaxKind.PostIncrementExpression:
        case SyntaxKind.PostDecrementExpression:
          break;
        default:
          throw new ArgumentException("kind");
      }
#if DEBUG
      if (operand == null)
        throw new ArgumentNullException(nameof(operand));
      if (operatorToken == null)
        throw new ArgumentNullException(nameof(operatorToken));
      switch (operatorToken.Kind)
      {
        case SyntaxKind.PlusPlusToken:
        case SyntaxKind.MinusMinusToken:
          break;
        default:
          throw new ArgumentException("operatorToken");
      }
#endif

      int hash;
      var cached = SyntaxNodeCache.TryGetNode((int)kind, operand, operatorToken, out hash);
      if (cached != null) return (PostfixUnaryExpressionSyntax)cached;

      var result = new PostfixUnaryExpressionSyntax(kind, operand, operatorToken);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public static MemberAccessExpressionSyntax MemberAccessExpression(SyntaxKind kind, ExpressionSyntax expression, SyntaxToken operatorToken, SimpleNameSyntax name)
    {
      switch (kind)
      {
        case SyntaxKind.SimpleMemberAccessExpression:
        case SyntaxKind.PointerMemberAccessExpression:
          break;
        default:
          throw new ArgumentException("kind");
      }
#if DEBUG
      if (expression == null)
        throw new ArgumentNullException(nameof(expression));
      if (operatorToken == null)
        throw new ArgumentNullException(nameof(operatorToken));
      switch (operatorToken.Kind)
      {
        case SyntaxKind.DotToken:
        case SyntaxKind.MinusGreaterThanToken:
          break;
        default:
          throw new ArgumentException("operatorToken");
      }
      if (name == null)
        throw new ArgumentNullException(nameof(name));
#endif

      int hash;
      var cached = SyntaxNodeCache.TryGetNode((int)kind, expression, operatorToken, name, out hash);
      if (cached != null) return (MemberAccessExpressionSyntax)cached;

      var result = new MemberAccessExpressionSyntax(kind, expression, operatorToken, name);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public static ConditionalAccessExpressionSyntax ConditionalAccessExpression(ExpressionSyntax expression, SyntaxToken operatorToken, ExpressionSyntax whenNotNull)
    {
#if DEBUG
      if (expression == null)
        throw new ArgumentNullException(nameof(expression));
      if (operatorToken == null)
        throw new ArgumentNullException(nameof(operatorToken));
      switch (operatorToken.Kind)
      {
        case SyntaxKind.QuestionToken:
          break;
        default:
          throw new ArgumentException("operatorToken");
      }
      if (whenNotNull == null)
        throw new ArgumentNullException(nameof(whenNotNull));
#endif

      int hash;
      var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.ConditionalAccessExpression, expression, operatorToken, whenNotNull, out hash);
      if (cached != null) return (ConditionalAccessExpressionSyntax)cached;

      var result = new ConditionalAccessExpressionSyntax(SyntaxKind.ConditionalAccessExpression, expression, operatorToken, whenNotNull);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public static MemberBindingExpressionSyntax MemberBindingExpression(SyntaxToken operatorToken, SimpleNameSyntax name)
    {
#if DEBUG
      if (operatorToken == null)
        throw new ArgumentNullException(nameof(operatorToken));
      switch (operatorToken.Kind)
      {
        case SyntaxKind.DotToken:
          break;
        default:
          throw new ArgumentException("operatorToken");
      }
      if (name == null)
        throw new ArgumentNullException(nameof(name));
#endif

      int hash;
      var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.MemberBindingExpression, operatorToken, name, out hash);
      if (cached != null) return (MemberBindingExpressionSyntax)cached;

      var result = new MemberBindingExpressionSyntax(SyntaxKind.MemberBindingExpression, operatorToken, name);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public static ElementBindingExpressionSyntax ElementBindingExpression(BracketedArgumentListSyntax argumentList)
    {
#if DEBUG
      if (argumentList == null)
        throw new ArgumentNullException(nameof(argumentList));
#endif

      int hash;
      var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.ElementBindingExpression, argumentList, out hash);
      if (cached != null) return (ElementBindingExpressionSyntax)cached;

      var result = new ElementBindingExpressionSyntax(SyntaxKind.ElementBindingExpression, argumentList);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public static ImplicitElementAccessSyntax ImplicitElementAccess(BracketedArgumentListSyntax argumentList)
    {
#if DEBUG
      if (argumentList == null)
        throw new ArgumentNullException(nameof(argumentList));
#endif

      int hash;
      var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.ImplicitElementAccess, argumentList, out hash);
      if (cached != null) return (ImplicitElementAccessSyntax)cached;

      var result = new ImplicitElementAccessSyntax(SyntaxKind.ImplicitElementAccess, argumentList);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public static BinaryExpressionSyntax BinaryExpression(SyntaxKind kind, ExpressionSyntax left, SyntaxToken operatorToken, ExpressionSyntax right)
    {
      switch (kind)
      {
        case SyntaxKind.AddExpression:
        case SyntaxKind.SubtractExpression:
        case SyntaxKind.MultiplyExpression:
        case SyntaxKind.DivideExpression:
        case SyntaxKind.ModuloExpression:
        case SyntaxKind.LeftShiftExpression:
        case SyntaxKind.RightShiftExpression:
        case SyntaxKind.LogicalOrExpression:
        case SyntaxKind.LogicalAndExpression:
        case SyntaxKind.BitwiseOrExpression:
        case SyntaxKind.BitwiseAndExpression:
        case SyntaxKind.ExclusiveOrExpression:
        case SyntaxKind.EqualsExpression:
        case SyntaxKind.NotEqualsExpression:
        case SyntaxKind.LessThanExpression:
        case SyntaxKind.LessThanOrEqualExpression:
        case SyntaxKind.GreaterThanExpression:
        case SyntaxKind.GreaterThanOrEqualExpression:
        case SyntaxKind.IsExpression:
        case SyntaxKind.AsExpression:
        case SyntaxKind.CoalesceExpression:
          break;
        default:
          throw new ArgumentException("kind");
      }
#if DEBUG
      if (left == null)
        throw new ArgumentNullException(nameof(left));
      if (operatorToken == null)
        throw new ArgumentNullException(nameof(operatorToken));
      switch (operatorToken.Kind)
      {
        case SyntaxKind.PlusToken:
        case SyntaxKind.MinusToken:
        case SyntaxKind.AsteriskToken:
        case SyntaxKind.SlashToken:
        case SyntaxKind.PercentToken:
        case SyntaxKind.LessThanLessThanToken:
        case SyntaxKind.GreaterThanGreaterThanToken:
        case SyntaxKind.BarBarToken:
        case SyntaxKind.AmpersandAmpersandToken:
        case SyntaxKind.BarToken:
        case SyntaxKind.AmpersandToken:
        case SyntaxKind.CaretToken:
        case SyntaxKind.EqualsEqualsToken:
        case SyntaxKind.ExclamationEqualsToken:
        case SyntaxKind.LessThanToken:
        case SyntaxKind.LessThanEqualsToken:
        case SyntaxKind.GreaterThanToken:
        case SyntaxKind.GreaterThanEqualsToken:
        case SyntaxKind.IsKeyword:
        case SyntaxKind.AsKeyword:
        case SyntaxKind.QuestionQuestionToken:
          break;
        default:
          throw new ArgumentException("operatorToken");
      }
      if (right == null)
        throw new ArgumentNullException(nameof(right));
#endif

      int hash;
      var cached = SyntaxNodeCache.TryGetNode((int)kind, left, operatorToken, right, out hash);
      if (cached != null) return (BinaryExpressionSyntax)cached;

      var result = new BinaryExpressionSyntax(kind, left, operatorToken, right);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public static AssignmentExpressionSyntax AssignmentExpression(SyntaxKind kind, ExpressionSyntax left, SyntaxToken operatorToken, ExpressionSyntax right)
    {
      switch (kind)
      {
        case SyntaxKind.SimpleAssignmentExpression:
        case SyntaxKind.AddAssignmentExpression:
        case SyntaxKind.SubtractAssignmentExpression:
        case SyntaxKind.MultiplyAssignmentExpression:
        case SyntaxKind.DivideAssignmentExpression:
        case SyntaxKind.ModuloAssignmentExpression:
        case SyntaxKind.AndAssignmentExpression:
        case SyntaxKind.ExclusiveOrAssignmentExpression:
        case SyntaxKind.OrAssignmentExpression:
        case SyntaxKind.LeftShiftAssignmentExpression:
        case SyntaxKind.RightShiftAssignmentExpression:
          break;
        default:
          throw new ArgumentException("kind");
      }
#if DEBUG
      if (left == null)
        throw new ArgumentNullException(nameof(left));
      if (operatorToken == null)
        throw new ArgumentNullException(nameof(operatorToken));
      switch (operatorToken.Kind)
      {
        case SyntaxKind.EqualsToken:
        case SyntaxKind.PlusEqualsToken:
        case SyntaxKind.MinusEqualsToken:
        case SyntaxKind.AsteriskEqualsToken:
        case SyntaxKind.SlashEqualsToken:
        case SyntaxKind.PercentEqualsToken:
        case SyntaxKind.AmpersandEqualsToken:
        case SyntaxKind.CaretEqualsToken:
        case SyntaxKind.BarEqualsToken:
        case SyntaxKind.LessThanLessThanEqualsToken:
        case SyntaxKind.GreaterThanGreaterThanEqualsToken:
          break;
        default:
          throw new ArgumentException("operatorToken");
      }
      if (right == null)
        throw new ArgumentNullException(nameof(right));
#endif

      int hash;
      var cached = SyntaxNodeCache.TryGetNode((int)kind, left, operatorToken, right, out hash);
      if (cached != null) return (AssignmentExpressionSyntax)cached;

      var result = new AssignmentExpressionSyntax(kind, left, operatorToken, right);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public static ConditionalExpressionSyntax ConditionalExpression(ExpressionSyntax condition, SyntaxToken questionToken, ExpressionSyntax whenTrue, SyntaxToken colonToken, ExpressionSyntax whenFalse)
    {
#if DEBUG
      if (condition == null)
        throw new ArgumentNullException(nameof(condition));
      if (questionToken == null)
        throw new ArgumentNullException(nameof(questionToken));
      switch (questionToken.Kind)
      {
        case SyntaxKind.QuestionToken:
          break;
        default:
          throw new ArgumentException("questionToken");
      }
      if (whenTrue == null)
        throw new ArgumentNullException(nameof(whenTrue));
      if (colonToken == null)
        throw new ArgumentNullException(nameof(colonToken));
      switch (colonToken.Kind)
      {
        case SyntaxKind.ColonToken:
          break;
        default:
          throw new ArgumentException("colonToken");
      }
      if (whenFalse == null)
        throw new ArgumentNullException(nameof(whenFalse));
#endif

      return new ConditionalExpressionSyntax(SyntaxKind.ConditionalExpression, condition, questionToken, whenTrue, colonToken, whenFalse);
    }

    public static ThisExpressionSyntax ThisExpression(SyntaxToken token)
    {
#if DEBUG
      if (token == null)
        throw new ArgumentNullException(nameof(token));
      switch (token.Kind)
      {
        case SyntaxKind.ThisKeyword:
          break;
        default:
          throw new ArgumentException("token");
      }
#endif

      int hash;
      var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.ThisExpression, token, out hash);
      if (cached != null) return (ThisExpressionSyntax)cached;

      var result = new ThisExpressionSyntax(SyntaxKind.ThisExpression, token);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public static BaseExpressionSyntax BaseExpression(SyntaxToken token)
    {
#if DEBUG
      if (token == null)
        throw new ArgumentNullException(nameof(token));
      switch (token.Kind)
      {
        case SyntaxKind.BaseKeyword:
          break;
        default:
          throw new ArgumentException("token");
      }
#endif

      int hash;
      var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.BaseExpression, token, out hash);
      if (cached != null) return (BaseExpressionSyntax)cached;

      var result = new BaseExpressionSyntax(SyntaxKind.BaseExpression, token);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public static LiteralExpressionSyntax LiteralExpression(SyntaxKind kind, SyntaxToken token)
    {
      switch (kind)
      {
        case SyntaxKind.ArgListExpression:
        case SyntaxKind.NumericLiteralExpression:
        case SyntaxKind.StringLiteralExpression:
        case SyntaxKind.CharacterLiteralExpression:
        case SyntaxKind.TrueLiteralExpression:
        case SyntaxKind.FalseLiteralExpression:
        case SyntaxKind.NullLiteralExpression:
        case SyntaxKind.DefaultLiteralExpression:
          break;
        default:
          throw new ArgumentException("kind");
      }
#if DEBUG
      if (token == null)
        throw new ArgumentNullException(nameof(token));
      switch (token.Kind)
      {
        case SyntaxKind.ArgListKeyword:
        case SyntaxKind.NumericLiteralToken:
        case SyntaxKind.StringLiteralToken:
        case SyntaxKind.CharacterLiteralToken:
        case SyntaxKind.TrueKeyword:
        case SyntaxKind.FalseKeyword:
        case SyntaxKind.NullKeyword:
        case SyntaxKind.DefaultKeyword:
          break;
        default:
          throw new ArgumentException("token");
      }
#endif

      int hash;
      var cached = SyntaxNodeCache.TryGetNode((int)kind, token, out hash);
      if (cached != null) return (LiteralExpressionSyntax)cached;

      var result = new LiteralExpressionSyntax(kind, token);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public static MakeRefExpressionSyntax MakeRefExpression(SyntaxToken keyword, SyntaxToken openParenToken, ExpressionSyntax expression, SyntaxToken closeParenToken)
    {
#if DEBUG
      if (keyword == null)
        throw new ArgumentNullException(nameof(keyword));
      switch (keyword.Kind)
      {
        case SyntaxKind.MakeRefKeyword:
          break;
        default:
          throw new ArgumentException("keyword");
      }
      if (openParenToken == null)
        throw new ArgumentNullException(nameof(openParenToken));
      switch (openParenToken.Kind)
      {
        case SyntaxKind.OpenParenToken:
          break;
        default:
          throw new ArgumentException("openParenToken");
      }
      if (expression == null)
        throw new ArgumentNullException(nameof(expression));
      if (closeParenToken == null)
        throw new ArgumentNullException(nameof(closeParenToken));
      switch (closeParenToken.Kind)
      {
        case SyntaxKind.CloseParenToken:
          break;
        default:
          throw new ArgumentException("closeParenToken");
      }
#endif

      return new MakeRefExpressionSyntax(SyntaxKind.MakeRefExpression, keyword, openParenToken, expression, closeParenToken);
    }

    public static RefTypeExpressionSyntax RefTypeExpression(SyntaxToken keyword, SyntaxToken openParenToken, ExpressionSyntax expression, SyntaxToken closeParenToken)
    {
#if DEBUG
      if (keyword == null)
        throw new ArgumentNullException(nameof(keyword));
      switch (keyword.Kind)
      {
        case SyntaxKind.RefTypeKeyword:
          break;
        default:
          throw new ArgumentException("keyword");
      }
      if (openParenToken == null)
        throw new ArgumentNullException(nameof(openParenToken));
      switch (openParenToken.Kind)
      {
        case SyntaxKind.OpenParenToken:
          break;
        default:
          throw new ArgumentException("openParenToken");
      }
      if (expression == null)
        throw new ArgumentNullException(nameof(expression));
      if (closeParenToken == null)
        throw new ArgumentNullException(nameof(closeParenToken));
      switch (closeParenToken.Kind)
      {
        case SyntaxKind.CloseParenToken:
          break;
        default:
          throw new ArgumentException("closeParenToken");
      }
#endif

      return new RefTypeExpressionSyntax(SyntaxKind.RefTypeExpression, keyword, openParenToken, expression, closeParenToken);
    }

    public static RefValueExpressionSyntax RefValueExpression(SyntaxToken keyword, SyntaxToken openParenToken, ExpressionSyntax expression, SyntaxToken comma, TypeSyntax type, SyntaxToken closeParenToken)
    {
#if DEBUG
      if (keyword == null)
        throw new ArgumentNullException(nameof(keyword));
      switch (keyword.Kind)
      {
        case SyntaxKind.RefValueKeyword:
          break;
        default:
          throw new ArgumentException("keyword");
      }
      if (openParenToken == null)
        throw new ArgumentNullException(nameof(openParenToken));
      switch (openParenToken.Kind)
      {
        case SyntaxKind.OpenParenToken:
          break;
        default:
          throw new ArgumentException("openParenToken");
      }
      if (expression == null)
        throw new ArgumentNullException(nameof(expression));
      if (comma == null)
        throw new ArgumentNullException(nameof(comma));
      switch (comma.Kind)
      {
        case SyntaxKind.CommaToken:
          break;
        default:
          throw new ArgumentException("comma");
      }
      if (type == null)
        throw new ArgumentNullException(nameof(type));
      if (closeParenToken == null)
        throw new ArgumentNullException(nameof(closeParenToken));
      switch (closeParenToken.Kind)
      {
        case SyntaxKind.CloseParenToken:
          break;
        default:
          throw new ArgumentException("closeParenToken");
      }
#endif

      return new RefValueExpressionSyntax(SyntaxKind.RefValueExpression, keyword, openParenToken, expression, comma, type, closeParenToken);
    }

    public static CheckedExpressionSyntax CheckedExpression(SyntaxKind kind, SyntaxToken keyword, SyntaxToken openParenToken, ExpressionSyntax expression, SyntaxToken closeParenToken)
    {
      switch (kind)
      {
        case SyntaxKind.CheckedExpression:
        case SyntaxKind.UncheckedExpression:
          break;
        default:
          throw new ArgumentException("kind");
      }
#if DEBUG
      if (keyword == null)
        throw new ArgumentNullException(nameof(keyword));
      switch (keyword.Kind)
      {
        case SyntaxKind.CheckedKeyword:
        case SyntaxKind.UncheckedKeyword:
          break;
        default:
          throw new ArgumentException("keyword");
      }
      if (openParenToken == null)
        throw new ArgumentNullException(nameof(openParenToken));
      switch (openParenToken.Kind)
      {
        case SyntaxKind.OpenParenToken:
          break;
        default:
          throw new ArgumentException("openParenToken");
      }
      if (expression == null)
        throw new ArgumentNullException(nameof(expression));
      if (closeParenToken == null)
        throw new ArgumentNullException(nameof(closeParenToken));
      switch (closeParenToken.Kind)
      {
        case SyntaxKind.CloseParenToken:
          break;
        default:
          throw new ArgumentException("closeParenToken");
      }
#endif

      return new CheckedExpressionSyntax(kind, keyword, openParenToken, expression, closeParenToken);
    }

    public static DefaultExpressionSyntax DefaultExpression(SyntaxToken keyword, SyntaxToken openParenToken, TypeSyntax type, SyntaxToken closeParenToken)
    {
#if DEBUG
      if (keyword == null)
        throw new ArgumentNullException(nameof(keyword));
      switch (keyword.Kind)
      {
        case SyntaxKind.DefaultKeyword:
          break;
        default:
          throw new ArgumentException("keyword");
      }
      if (openParenToken == null)
        throw new ArgumentNullException(nameof(openParenToken));
      switch (openParenToken.Kind)
      {
        case SyntaxKind.OpenParenToken:
          break;
        default:
          throw new ArgumentException("openParenToken");
      }
      if (type == null)
        throw new ArgumentNullException(nameof(type));
      if (closeParenToken == null)
        throw new ArgumentNullException(nameof(closeParenToken));
      switch (closeParenToken.Kind)
      {
        case SyntaxKind.CloseParenToken:
          break;
        default:
          throw new ArgumentException("closeParenToken");
      }
#endif

      return new DefaultExpressionSyntax(SyntaxKind.DefaultExpression, keyword, openParenToken, type, closeParenToken);
    }

    public static TypeOfExpressionSyntax TypeOfExpression(SyntaxToken keyword, SyntaxToken openParenToken, TypeSyntax type, SyntaxToken closeParenToken)
    {
#if DEBUG
      if (keyword == null)
        throw new ArgumentNullException(nameof(keyword));
      switch (keyword.Kind)
      {
        case SyntaxKind.TypeOfKeyword:
          break;
        default:
          throw new ArgumentException("keyword");
      }
      if (openParenToken == null)
        throw new ArgumentNullException(nameof(openParenToken));
      switch (openParenToken.Kind)
      {
        case SyntaxKind.OpenParenToken:
          break;
        default:
          throw new ArgumentException("openParenToken");
      }
      if (type == null)
        throw new ArgumentNullException(nameof(type));
      if (closeParenToken == null)
        throw new ArgumentNullException(nameof(closeParenToken));
      switch (closeParenToken.Kind)
      {
        case SyntaxKind.CloseParenToken:
          break;
        default:
          throw new ArgumentException("closeParenToken");
      }
#endif

      return new TypeOfExpressionSyntax(SyntaxKind.TypeOfExpression, keyword, openParenToken, type, closeParenToken);
    }

    public static SizeOfExpressionSyntax SizeOfExpression(SyntaxToken keyword, SyntaxToken openParenToken, TypeSyntax type, SyntaxToken closeParenToken)
    {
#if DEBUG
      if (keyword == null)
        throw new ArgumentNullException(nameof(keyword));
      switch (keyword.Kind)
      {
        case SyntaxKind.SizeOfKeyword:
          break;
        default:
          throw new ArgumentException("keyword");
      }
      if (openParenToken == null)
        throw new ArgumentNullException(nameof(openParenToken));
      switch (openParenToken.Kind)
      {
        case SyntaxKind.OpenParenToken:
          break;
        default:
          throw new ArgumentException("openParenToken");
      }
      if (type == null)
        throw new ArgumentNullException(nameof(type));
      if (closeParenToken == null)
        throw new ArgumentNullException(nameof(closeParenToken));
      switch (closeParenToken.Kind)
      {
        case SyntaxKind.CloseParenToken:
          break;
        default:
          throw new ArgumentException("closeParenToken");
      }
#endif

      return new SizeOfExpressionSyntax(SyntaxKind.SizeOfExpression, keyword, openParenToken, type, closeParenToken);
    }

    public static InvocationExpressionSyntax InvocationExpression(ExpressionSyntax expression, ArgumentListSyntax argumentList)
    {
#if DEBUG
      if (expression == null)
        throw new ArgumentNullException(nameof(expression));
      if (argumentList == null)
        throw new ArgumentNullException(nameof(argumentList));
#endif

      int hash;
      var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.InvocationExpression, expression, argumentList, out hash);
      if (cached != null) return (InvocationExpressionSyntax)cached;

      var result = new InvocationExpressionSyntax(SyntaxKind.InvocationExpression, expression, argumentList);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public static ElementAccessExpressionSyntax ElementAccessExpression(ExpressionSyntax expression, BracketedArgumentListSyntax argumentList)
    {
#if DEBUG
      if (expression == null)
        throw new ArgumentNullException(nameof(expression));
      if (argumentList == null)
        throw new ArgumentNullException(nameof(argumentList));
#endif

      int hash;
      var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.ElementAccessExpression, expression, argumentList, out hash);
      if (cached != null) return (ElementAccessExpressionSyntax)cached;

      var result = new ElementAccessExpressionSyntax(SyntaxKind.ElementAccessExpression, expression, argumentList);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public static ArgumentListSyntax ArgumentList(SyntaxToken openParenToken, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<ArgumentSyntax> arguments, SyntaxToken closeParenToken)
    {
#if DEBUG
      if (openParenToken == null)
        throw new ArgumentNullException(nameof(openParenToken));
      switch (openParenToken.Kind)
      {
        case SyntaxKind.OpenParenToken:
          break;
        default:
          throw new ArgumentException("openParenToken");
      }
      if (closeParenToken == null)
        throw new ArgumentNullException(nameof(closeParenToken));
      switch (closeParenToken.Kind)
      {
        case SyntaxKind.CloseParenToken:
          break;
        default:
          throw new ArgumentException("closeParenToken");
      }
#endif

      int hash;
      var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.ArgumentList, openParenToken, arguments.Node, closeParenToken, out hash);
      if (cached != null) return (ArgumentListSyntax)cached;

      var result = new ArgumentListSyntax(SyntaxKind.ArgumentList, openParenToken, arguments.Node, closeParenToken);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public static BracketedArgumentListSyntax BracketedArgumentList(SyntaxToken openBracketToken, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<ArgumentSyntax> arguments, SyntaxToken closeBracketToken)
    {
#if DEBUG
      if (openBracketToken == null)
        throw new ArgumentNullException(nameof(openBracketToken));
      switch (openBracketToken.Kind)
      {
        case SyntaxKind.OpenBracketToken:
          break;
        default:
          throw new ArgumentException("openBracketToken");
      }
      if (closeBracketToken == null)
        throw new ArgumentNullException(nameof(closeBracketToken));
      switch (closeBracketToken.Kind)
      {
        case SyntaxKind.CloseBracketToken:
          break;
        default:
          throw new ArgumentException("closeBracketToken");
      }
#endif

      int hash;
      var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.BracketedArgumentList, openBracketToken, arguments.Node, closeBracketToken, out hash);
      if (cached != null) return (BracketedArgumentListSyntax)cached;

      var result = new BracketedArgumentListSyntax(SyntaxKind.BracketedArgumentList, openBracketToken, arguments.Node, closeBracketToken);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public static ArgumentSyntax Argument(NameColonSyntax nameColon, SyntaxToken refOrOutKeyword, ExpressionSyntax expression)
    {
#if DEBUG
      if (refOrOutKeyword != null)
      {
      switch (refOrOutKeyword.Kind)
      {
        case SyntaxKind.RefKeyword:
        case SyntaxKind.OutKeyword:
        case SyntaxKind.None:
          break;
        default:
          throw new ArgumentException("refOrOutKeyword");
      }
      }
      if (expression == null)
        throw new ArgumentNullException(nameof(expression));
#endif

      int hash;
      var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.Argument, nameColon, refOrOutKeyword, expression, out hash);
      if (cached != null) return (ArgumentSyntax)cached;

      var result = new ArgumentSyntax(SyntaxKind.Argument, nameColon, refOrOutKeyword, expression);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public static NameColonSyntax NameColon(IdentifierNameSyntax name, SyntaxToken colonToken)
    {
#if DEBUG
      if (name == null)
        throw new ArgumentNullException(nameof(name));
      if (colonToken == null)
        throw new ArgumentNullException(nameof(colonToken));
      switch (colonToken.Kind)
      {
        case SyntaxKind.ColonToken:
          break;
        default:
          throw new ArgumentException("colonToken");
      }
#endif

      int hash;
      var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.NameColon, name, colonToken, out hash);
      if (cached != null) return (NameColonSyntax)cached;

      var result = new NameColonSyntax(SyntaxKind.NameColon, name, colonToken);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public static DeclarationExpressionSyntax DeclarationExpression(TypeSyntax type, VariableDesignationSyntax designation)
    {
#if DEBUG
      if (type == null)
        throw new ArgumentNullException(nameof(type));
      if (designation == null)
        throw new ArgumentNullException(nameof(designation));
#endif

      int hash;
      var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.DeclarationExpression, type, designation, out hash);
      if (cached != null) return (DeclarationExpressionSyntax)cached;

      var result = new DeclarationExpressionSyntax(SyntaxKind.DeclarationExpression, type, designation);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public static CastExpressionSyntax CastExpression(SyntaxToken openParenToken, TypeSyntax type, SyntaxToken closeParenToken, ExpressionSyntax expression)
    {
#if DEBUG
      if (openParenToken == null)
        throw new ArgumentNullException(nameof(openParenToken));
      switch (openParenToken.Kind)
      {
        case SyntaxKind.OpenParenToken:
          break;
        default:
          throw new ArgumentException("openParenToken");
      }
      if (type == null)
        throw new ArgumentNullException(nameof(type));
      if (closeParenToken == null)
        throw new ArgumentNullException(nameof(closeParenToken));
      switch (closeParenToken.Kind)
      {
        case SyntaxKind.CloseParenToken:
          break;
        default:
          throw new ArgumentException("closeParenToken");
      }
      if (expression == null)
        throw new ArgumentNullException(nameof(expression));
#endif

      return new CastExpressionSyntax(SyntaxKind.CastExpression, openParenToken, type, closeParenToken, expression);
    }

    public static AnonymousMethodExpressionSyntax AnonymousMethodExpression(SyntaxToken asyncKeyword, SyntaxToken delegateKeyword, ParameterListSyntax parameterList, CSharpSyntaxNode body)
    {
#if DEBUG
      if (asyncKeyword != null)
      {
      switch (asyncKeyword.Kind)
      {
        case SyntaxKind.AsyncKeyword:
        case SyntaxKind.None:
          break;
        default:
          throw new ArgumentException("asyncKeyword");
      }
      }
      if (delegateKeyword == null)
        throw new ArgumentNullException(nameof(delegateKeyword));
      switch (delegateKeyword.Kind)
      {
        case SyntaxKind.DelegateKeyword:
          break;
        default:
          throw new ArgumentException("delegateKeyword");
      }
      if (body == null)
        throw new ArgumentNullException(nameof(body));
#endif

      return new AnonymousMethodExpressionSyntax(SyntaxKind.AnonymousMethodExpression, asyncKeyword, delegateKeyword, parameterList, body);
    }

    public static SimpleLambdaExpressionSyntax SimpleLambdaExpression(SyntaxToken asyncKeyword, ParameterSyntax parameter, SyntaxToken arrowToken, CSharpSyntaxNode body)
    {
#if DEBUG
      if (asyncKeyword != null)
      {
      switch (asyncKeyword.Kind)
      {
        case SyntaxKind.AsyncKeyword:
        case SyntaxKind.None:
          break;
        default:
          throw new ArgumentException("asyncKeyword");
      }
      }
      if (parameter == null)
        throw new ArgumentNullException(nameof(parameter));
      if (arrowToken == null)
        throw new ArgumentNullException(nameof(arrowToken));
      switch (arrowToken.Kind)
      {
        case SyntaxKind.EqualsGreaterThanToken:
          break;
        default:
          throw new ArgumentException("arrowToken");
      }
      if (body == null)
        throw new ArgumentNullException(nameof(body));
#endif

      return new SimpleLambdaExpressionSyntax(SyntaxKind.SimpleLambdaExpression, asyncKeyword, parameter, arrowToken, body);
    }

    public static RefExpressionSyntax RefExpression(SyntaxToken refKeyword, ExpressionSyntax expression)
    {
#if DEBUG
      if (refKeyword == null)
        throw new ArgumentNullException(nameof(refKeyword));
      switch (refKeyword.Kind)
      {
        case SyntaxKind.RefKeyword:
          break;
        default:
          throw new ArgumentException("refKeyword");
      }
      if (expression == null)
        throw new ArgumentNullException(nameof(expression));
#endif

      int hash;
      var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.RefExpression, refKeyword, expression, out hash);
      if (cached != null) return (RefExpressionSyntax)cached;

      var result = new RefExpressionSyntax(SyntaxKind.RefExpression, refKeyword, expression);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public static ParenthesizedLambdaExpressionSyntax ParenthesizedLambdaExpression(SyntaxToken asyncKeyword, ParameterListSyntax parameterList, SyntaxToken arrowToken, CSharpSyntaxNode body)
    {
#if DEBUG
      if (asyncKeyword != null)
      {
      switch (asyncKeyword.Kind)
      {
        case SyntaxKind.AsyncKeyword:
        case SyntaxKind.None:
          break;
        default:
          throw new ArgumentException("asyncKeyword");
      }
      }
      if (parameterList == null)
        throw new ArgumentNullException(nameof(parameterList));
      if (arrowToken == null)
        throw new ArgumentNullException(nameof(arrowToken));
      switch (arrowToken.Kind)
      {
        case SyntaxKind.EqualsGreaterThanToken:
          break;
        default:
          throw new ArgumentException("arrowToken");
      }
      if (body == null)
        throw new ArgumentNullException(nameof(body));
#endif

      return new ParenthesizedLambdaExpressionSyntax(SyntaxKind.ParenthesizedLambdaExpression, asyncKeyword, parameterList, arrowToken, body);
    }

    public static InitializerExpressionSyntax InitializerExpression(SyntaxKind kind, SyntaxToken openBraceToken, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<ExpressionSyntax> expressions, SyntaxToken closeBraceToken)
    {
      switch (kind)
      {
        case SyntaxKind.ObjectInitializerExpression:
        case SyntaxKind.CollectionInitializerExpression:
        case SyntaxKind.ArrayInitializerExpression:
        case SyntaxKind.ComplexElementInitializerExpression:
          break;
        default:
          throw new ArgumentException("kind");
      }
#if DEBUG
      if (openBraceToken == null)
        throw new ArgumentNullException(nameof(openBraceToken));
      switch (openBraceToken.Kind)
      {
        case SyntaxKind.OpenBraceToken:
          break;
        default:
          throw new ArgumentException("openBraceToken");
      }
      if (closeBraceToken == null)
        throw new ArgumentNullException(nameof(closeBraceToken));
      switch (closeBraceToken.Kind)
      {
        case SyntaxKind.CloseBraceToken:
          break;
        default:
          throw new ArgumentException("closeBraceToken");
      }
#endif

      int hash;
      var cached = SyntaxNodeCache.TryGetNode((int)kind, openBraceToken, expressions.Node, closeBraceToken, out hash);
      if (cached != null) return (InitializerExpressionSyntax)cached;

      var result = new InitializerExpressionSyntax(kind, openBraceToken, expressions.Node, closeBraceToken);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public static ObjectCreationExpressionSyntax ObjectCreationExpression(SyntaxToken newKeyword, TypeSyntax type, ArgumentListSyntax argumentList, InitializerExpressionSyntax initializer)
    {
#if DEBUG
      if (newKeyword == null)
        throw new ArgumentNullException(nameof(newKeyword));
      switch (newKeyword.Kind)
      {
        case SyntaxKind.NewKeyword:
          break;
        default:
          throw new ArgumentException("newKeyword");
      }
      if (type == null)
        throw new ArgumentNullException(nameof(type));
#endif

      return new ObjectCreationExpressionSyntax(SyntaxKind.ObjectCreationExpression, newKeyword, type, argumentList, initializer);
    }

    public static AnonymousObjectMemberDeclaratorSyntax AnonymousObjectMemberDeclarator(NameEqualsSyntax nameEquals, ExpressionSyntax expression)
    {
#if DEBUG
      if (expression == null)
        throw new ArgumentNullException(nameof(expression));
#endif

      int hash;
      var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.AnonymousObjectMemberDeclarator, nameEquals, expression, out hash);
      if (cached != null) return (AnonymousObjectMemberDeclaratorSyntax)cached;

      var result = new AnonymousObjectMemberDeclaratorSyntax(SyntaxKind.AnonymousObjectMemberDeclarator, nameEquals, expression);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public static AnonymousObjectCreationExpressionSyntax AnonymousObjectCreationExpression(SyntaxToken newKeyword, SyntaxToken openBraceToken, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<AnonymousObjectMemberDeclaratorSyntax> initializers, SyntaxToken closeBraceToken)
    {
#if DEBUG
      if (newKeyword == null)
        throw new ArgumentNullException(nameof(newKeyword));
      switch (newKeyword.Kind)
      {
        case SyntaxKind.NewKeyword:
          break;
        default:
          throw new ArgumentException("newKeyword");
      }
      if (openBraceToken == null)
        throw new ArgumentNullException(nameof(openBraceToken));
      switch (openBraceToken.Kind)
      {
        case SyntaxKind.OpenBraceToken:
          break;
        default:
          throw new ArgumentException("openBraceToken");
      }
      if (closeBraceToken == null)
        throw new ArgumentNullException(nameof(closeBraceToken));
      switch (closeBraceToken.Kind)
      {
        case SyntaxKind.CloseBraceToken:
          break;
        default:
          throw new ArgumentException("closeBraceToken");
      }
#endif

      return new AnonymousObjectCreationExpressionSyntax(SyntaxKind.AnonymousObjectCreationExpression, newKeyword, openBraceToken, initializers.Node, closeBraceToken);
    }

    public static ArrayCreationExpressionSyntax ArrayCreationExpression(SyntaxToken newKeyword, ArrayTypeSyntax type, InitializerExpressionSyntax initializer)
    {
#if DEBUG
      if (newKeyword == null)
        throw new ArgumentNullException(nameof(newKeyword));
      switch (newKeyword.Kind)
      {
        case SyntaxKind.NewKeyword:
          break;
        default:
          throw new ArgumentException("newKeyword");
      }
      if (type == null)
        throw new ArgumentNullException(nameof(type));
#endif

      int hash;
      var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.ArrayCreationExpression, newKeyword, type, initializer, out hash);
      if (cached != null) return (ArrayCreationExpressionSyntax)cached;

      var result = new ArrayCreationExpressionSyntax(SyntaxKind.ArrayCreationExpression, newKeyword, type, initializer);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public static ImplicitArrayCreationExpressionSyntax ImplicitArrayCreationExpression(SyntaxToken newKeyword, SyntaxToken openBracketToken, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SyntaxToken> commas, SyntaxToken closeBracketToken, InitializerExpressionSyntax initializer)
    {
#if DEBUG
      if (newKeyword == null)
        throw new ArgumentNullException(nameof(newKeyword));
      switch (newKeyword.Kind)
      {
        case SyntaxKind.NewKeyword:
          break;
        default:
          throw new ArgumentException("newKeyword");
      }
      if (openBracketToken == null)
        throw new ArgumentNullException(nameof(openBracketToken));
      switch (openBracketToken.Kind)
      {
        case SyntaxKind.OpenBracketToken:
          break;
        default:
          throw new ArgumentException("openBracketToken");
      }
      if (closeBracketToken == null)
        throw new ArgumentNullException(nameof(closeBracketToken));
      switch (closeBracketToken.Kind)
      {
        case SyntaxKind.CloseBracketToken:
          break;
        default:
          throw new ArgumentException("closeBracketToken");
      }
      if (initializer == null)
        throw new ArgumentNullException(nameof(initializer));
#endif

      return new ImplicitArrayCreationExpressionSyntax(SyntaxKind.ImplicitArrayCreationExpression, newKeyword, openBracketToken, commas.Node, closeBracketToken, initializer);
    }

    public static StackAllocArrayCreationExpressionSyntax StackAllocArrayCreationExpression(SyntaxToken stackAllocKeyword, TypeSyntax type)
    {
#if DEBUG
      if (stackAllocKeyword == null)
        throw new ArgumentNullException(nameof(stackAllocKeyword));
      switch (stackAllocKeyword.Kind)
      {
        case SyntaxKind.StackAllocKeyword:
          break;
        default:
          throw new ArgumentException("stackAllocKeyword");
      }
      if (type == null)
        throw new ArgumentNullException(nameof(type));
#endif

      int hash;
      var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.StackAllocArrayCreationExpression, stackAllocKeyword, type, out hash);
      if (cached != null) return (StackAllocArrayCreationExpressionSyntax)cached;

      var result = new StackAllocArrayCreationExpressionSyntax(SyntaxKind.StackAllocArrayCreationExpression, stackAllocKeyword, type);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public static QueryExpressionSyntax QueryExpression(FromClauseSyntax fromClause, QueryBodySyntax body)
    {
#if DEBUG
      if (fromClause == null)
        throw new ArgumentNullException(nameof(fromClause));
      if (body == null)
        throw new ArgumentNullException(nameof(body));
#endif

      int hash;
      var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.QueryExpression, fromClause, body, out hash);
      if (cached != null) return (QueryExpressionSyntax)cached;

      var result = new QueryExpressionSyntax(SyntaxKind.QueryExpression, fromClause, body);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public static QueryBodySyntax QueryBody(Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<QueryClauseSyntax> clauses, SelectOrGroupClauseSyntax selectOrGroup, QueryContinuationSyntax continuation)
    {
#if DEBUG
      if (selectOrGroup == null)
        throw new ArgumentNullException(nameof(selectOrGroup));
#endif

      int hash;
      var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.QueryBody, clauses.Node, selectOrGroup, continuation, out hash);
      if (cached != null) return (QueryBodySyntax)cached;

      var result = new QueryBodySyntax(SyntaxKind.QueryBody, clauses.Node, selectOrGroup, continuation);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public static FromClauseSyntax FromClause(SyntaxToken fromKeyword, TypeSyntax type, SyntaxToken identifier, SyntaxToken inKeyword, ExpressionSyntax expression)
    {
#if DEBUG
      if (fromKeyword == null)
        throw new ArgumentNullException(nameof(fromKeyword));
      switch (fromKeyword.Kind)
      {
        case SyntaxKind.FromKeyword:
          break;
        default:
          throw new ArgumentException("fromKeyword");
      }
      if (identifier == null)
        throw new ArgumentNullException(nameof(identifier));
      switch (identifier.Kind)
      {
        case SyntaxKind.IdentifierToken:
          break;
        default:
          throw new ArgumentException("identifier");
      }
      if (inKeyword == null)
        throw new ArgumentNullException(nameof(inKeyword));
      switch (inKeyword.Kind)
      {
        case SyntaxKind.InKeyword:
          break;
        default:
          throw new ArgumentException("inKeyword");
      }
      if (expression == null)
        throw new ArgumentNullException(nameof(expression));
#endif

      return new FromClauseSyntax(SyntaxKind.FromClause, fromKeyword, type, identifier, inKeyword, expression);
    }

    public static LetClauseSyntax LetClause(SyntaxToken letKeyword, SyntaxToken identifier, SyntaxToken equalsToken, ExpressionSyntax expression)
    {
#if DEBUG
      if (letKeyword == null)
        throw new ArgumentNullException(nameof(letKeyword));
      switch (letKeyword.Kind)
      {
        case SyntaxKind.LetKeyword:
          break;
        default:
          throw new ArgumentException("letKeyword");
      }
      if (identifier == null)
        throw new ArgumentNullException(nameof(identifier));
      switch (identifier.Kind)
      {
        case SyntaxKind.IdentifierToken:
          break;
        default:
          throw new ArgumentException("identifier");
      }
      if (equalsToken == null)
        throw new ArgumentNullException(nameof(equalsToken));
      switch (equalsToken.Kind)
      {
        case SyntaxKind.EqualsToken:
          break;
        default:
          throw new ArgumentException("equalsToken");
      }
      if (expression == null)
        throw new ArgumentNullException(nameof(expression));
#endif

      return new LetClauseSyntax(SyntaxKind.LetClause, letKeyword, identifier, equalsToken, expression);
    }

    public static JoinClauseSyntax JoinClause(SyntaxToken joinKeyword, TypeSyntax type, SyntaxToken identifier, SyntaxToken inKeyword, ExpressionSyntax inExpression, SyntaxToken onKeyword, ExpressionSyntax leftExpression, SyntaxToken equalsKeyword, ExpressionSyntax rightExpression, JoinIntoClauseSyntax into)
    {
#if DEBUG
      if (joinKeyword == null)
        throw new ArgumentNullException(nameof(joinKeyword));
      switch (joinKeyword.Kind)
      {
        case SyntaxKind.JoinKeyword:
          break;
        default:
          throw new ArgumentException("joinKeyword");
      }
      if (identifier == null)
        throw new ArgumentNullException(nameof(identifier));
      switch (identifier.Kind)
      {
        case SyntaxKind.IdentifierToken:
          break;
        default:
          throw new ArgumentException("identifier");
      }
      if (inKeyword == null)
        throw new ArgumentNullException(nameof(inKeyword));
      switch (inKeyword.Kind)
      {
        case SyntaxKind.InKeyword:
          break;
        default:
          throw new ArgumentException("inKeyword");
      }
      if (inExpression == null)
        throw new ArgumentNullException(nameof(inExpression));
      if (onKeyword == null)
        throw new ArgumentNullException(nameof(onKeyword));
      switch (onKeyword.Kind)
      {
        case SyntaxKind.OnKeyword:
          break;
        default:
          throw new ArgumentException("onKeyword");
      }
      if (leftExpression == null)
        throw new ArgumentNullException(nameof(leftExpression));
      if (equalsKeyword == null)
        throw new ArgumentNullException(nameof(equalsKeyword));
      switch (equalsKeyword.Kind)
      {
        case SyntaxKind.EqualsKeyword:
          break;
        default:
          throw new ArgumentException("equalsKeyword");
      }
      if (rightExpression == null)
        throw new ArgumentNullException(nameof(rightExpression));
#endif

      return new JoinClauseSyntax(SyntaxKind.JoinClause, joinKeyword, type, identifier, inKeyword, inExpression, onKeyword, leftExpression, equalsKeyword, rightExpression, into);
    }

    public static JoinIntoClauseSyntax JoinIntoClause(SyntaxToken intoKeyword, SyntaxToken identifier)
    {
#if DEBUG
      if (intoKeyword == null)
        throw new ArgumentNullException(nameof(intoKeyword));
      switch (intoKeyword.Kind)
      {
        case SyntaxKind.IntoKeyword:
          break;
        default:
          throw new ArgumentException("intoKeyword");
      }
      if (identifier == null)
        throw new ArgumentNullException(nameof(identifier));
      switch (identifier.Kind)
      {
        case SyntaxKind.IdentifierToken:
          break;
        default:
          throw new ArgumentException("identifier");
      }
#endif

      int hash;
      var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.JoinIntoClause, intoKeyword, identifier, out hash);
      if (cached != null) return (JoinIntoClauseSyntax)cached;

      var result = new JoinIntoClauseSyntax(SyntaxKind.JoinIntoClause, intoKeyword, identifier);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public static WhereClauseSyntax WhereClause(SyntaxToken whereKeyword, ExpressionSyntax condition)
    {
#if DEBUG
      if (whereKeyword == null)
        throw new ArgumentNullException(nameof(whereKeyword));
      switch (whereKeyword.Kind)
      {
        case SyntaxKind.WhereKeyword:
          break;
        default:
          throw new ArgumentException("whereKeyword");
      }
      if (condition == null)
        throw new ArgumentNullException(nameof(condition));
#endif

      int hash;
      var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.WhereClause, whereKeyword, condition, out hash);
      if (cached != null) return (WhereClauseSyntax)cached;

      var result = new WhereClauseSyntax(SyntaxKind.WhereClause, whereKeyword, condition);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public static OrderByClauseSyntax OrderByClause(SyntaxToken orderByKeyword, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<OrderingSyntax> orderings)
    {
#if DEBUG
      if (orderByKeyword == null)
        throw new ArgumentNullException(nameof(orderByKeyword));
      switch (orderByKeyword.Kind)
      {
        case SyntaxKind.OrderByKeyword:
          break;
        default:
          throw new ArgumentException("orderByKeyword");
      }
#endif

      int hash;
      var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.OrderByClause, orderByKeyword, orderings.Node, out hash);
      if (cached != null) return (OrderByClauseSyntax)cached;

      var result = new OrderByClauseSyntax(SyntaxKind.OrderByClause, orderByKeyword, orderings.Node);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public static OrderingSyntax Ordering(SyntaxKind kind, ExpressionSyntax expression, SyntaxToken ascendingOrDescendingKeyword)
    {
      switch (kind)
      {
        case SyntaxKind.AscendingOrdering:
        case SyntaxKind.DescendingOrdering:
          break;
        default:
          throw new ArgumentException("kind");
      }
#if DEBUG
      if (expression == null)
        throw new ArgumentNullException(nameof(expression));
      if (ascendingOrDescendingKeyword != null)
      {
      switch (ascendingOrDescendingKeyword.Kind)
      {
        case SyntaxKind.AscendingKeyword:
        case SyntaxKind.DescendingKeyword:
        case SyntaxKind.None:
          break;
        default:
          throw new ArgumentException("ascendingOrDescendingKeyword");
      }
      }
#endif

      int hash;
      var cached = SyntaxNodeCache.TryGetNode((int)kind, expression, ascendingOrDescendingKeyword, out hash);
      if (cached != null) return (OrderingSyntax)cached;

      var result = new OrderingSyntax(kind, expression, ascendingOrDescendingKeyword);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public static SelectClauseSyntax SelectClause(SyntaxToken selectKeyword, ExpressionSyntax expression)
    {
#if DEBUG
      if (selectKeyword == null)
        throw new ArgumentNullException(nameof(selectKeyword));
      switch (selectKeyword.Kind)
      {
        case SyntaxKind.SelectKeyword:
          break;
        default:
          throw new ArgumentException("selectKeyword");
      }
      if (expression == null)
        throw new ArgumentNullException(nameof(expression));
#endif

      int hash;
      var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.SelectClause, selectKeyword, expression, out hash);
      if (cached != null) return (SelectClauseSyntax)cached;

      var result = new SelectClauseSyntax(SyntaxKind.SelectClause, selectKeyword, expression);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public static GroupClauseSyntax GroupClause(SyntaxToken groupKeyword, ExpressionSyntax groupExpression, SyntaxToken byKeyword, ExpressionSyntax byExpression)
    {
#if DEBUG
      if (groupKeyword == null)
        throw new ArgumentNullException(nameof(groupKeyword));
      switch (groupKeyword.Kind)
      {
        case SyntaxKind.GroupKeyword:
          break;
        default:
          throw new ArgumentException("groupKeyword");
      }
      if (groupExpression == null)
        throw new ArgumentNullException(nameof(groupExpression));
      if (byKeyword == null)
        throw new ArgumentNullException(nameof(byKeyword));
      switch (byKeyword.Kind)
      {
        case SyntaxKind.ByKeyword:
          break;
        default:
          throw new ArgumentException("byKeyword");
      }
      if (byExpression == null)
        throw new ArgumentNullException(nameof(byExpression));
#endif

      return new GroupClauseSyntax(SyntaxKind.GroupClause, groupKeyword, groupExpression, byKeyword, byExpression);
    }

    public static QueryContinuationSyntax QueryContinuation(SyntaxToken intoKeyword, SyntaxToken identifier, QueryBodySyntax body)
    {
#if DEBUG
      if (intoKeyword == null)
        throw new ArgumentNullException(nameof(intoKeyword));
      switch (intoKeyword.Kind)
      {
        case SyntaxKind.IntoKeyword:
          break;
        default:
          throw new ArgumentException("intoKeyword");
      }
      if (identifier == null)
        throw new ArgumentNullException(nameof(identifier));
      switch (identifier.Kind)
      {
        case SyntaxKind.IdentifierToken:
          break;
        default:
          throw new ArgumentException("identifier");
      }
      if (body == null)
        throw new ArgumentNullException(nameof(body));
#endif

      int hash;
      var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.QueryContinuation, intoKeyword, identifier, body, out hash);
      if (cached != null) return (QueryContinuationSyntax)cached;

      var result = new QueryContinuationSyntax(SyntaxKind.QueryContinuation, intoKeyword, identifier, body);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public static OmittedArraySizeExpressionSyntax OmittedArraySizeExpression(SyntaxToken omittedArraySizeExpressionToken)
    {
#if DEBUG
      if (omittedArraySizeExpressionToken == null)
        throw new ArgumentNullException(nameof(omittedArraySizeExpressionToken));
      switch (omittedArraySizeExpressionToken.Kind)
      {
        case SyntaxKind.OmittedArraySizeExpressionToken:
          break;
        default:
          throw new ArgumentException("omittedArraySizeExpressionToken");
      }
#endif

      int hash;
      var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.OmittedArraySizeExpression, omittedArraySizeExpressionToken, out hash);
      if (cached != null) return (OmittedArraySizeExpressionSyntax)cached;

      var result = new OmittedArraySizeExpressionSyntax(SyntaxKind.OmittedArraySizeExpression, omittedArraySizeExpressionToken);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public static InterpolatedStringExpressionSyntax InterpolatedStringExpression(SyntaxToken stringStartToken, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<InterpolatedStringContentSyntax> contents, SyntaxToken stringEndToken)
    {
#if DEBUG
      if (stringStartToken == null)
        throw new ArgumentNullException(nameof(stringStartToken));
      switch (stringStartToken.Kind)
      {
        case SyntaxKind.InterpolatedStringStartToken:
        case SyntaxKind.InterpolatedVerbatimStringStartToken:
          break;
        default:
          throw new ArgumentException("stringStartToken");
      }
      if (stringEndToken == null)
        throw new ArgumentNullException(nameof(stringEndToken));
      switch (stringEndToken.Kind)
      {
        case SyntaxKind.InterpolatedStringEndToken:
          break;
        default:
          throw new ArgumentException("stringEndToken");
      }
#endif

      int hash;
      var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.InterpolatedStringExpression, stringStartToken, contents.Node, stringEndToken, out hash);
      if (cached != null) return (InterpolatedStringExpressionSyntax)cached;

      var result = new InterpolatedStringExpressionSyntax(SyntaxKind.InterpolatedStringExpression, stringStartToken, contents.Node, stringEndToken);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public static IsPatternExpressionSyntax IsPatternExpression(ExpressionSyntax expression, SyntaxToken isKeyword, PatternSyntax pattern)
    {
#if DEBUG
      if (expression == null)
        throw new ArgumentNullException(nameof(expression));
      if (isKeyword == null)
        throw new ArgumentNullException(nameof(isKeyword));
      switch (isKeyword.Kind)
      {
        case SyntaxKind.IsKeyword:
          break;
        default:
          throw new ArgumentException("isKeyword");
      }
      if (pattern == null)
        throw new ArgumentNullException(nameof(pattern));
#endif

      int hash;
      var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.IsPatternExpression, expression, isKeyword, pattern, out hash);
      if (cached != null) return (IsPatternExpressionSyntax)cached;

      var result = new IsPatternExpressionSyntax(SyntaxKind.IsPatternExpression, expression, isKeyword, pattern);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public static ThrowExpressionSyntax ThrowExpression(SyntaxToken throwKeyword, ExpressionSyntax expression)
    {
#if DEBUG
      if (throwKeyword == null)
        throw new ArgumentNullException(nameof(throwKeyword));
      switch (throwKeyword.Kind)
      {
        case SyntaxKind.ThrowKeyword:
          break;
        default:
          throw new ArgumentException("throwKeyword");
      }
      if (expression == null)
        throw new ArgumentNullException(nameof(expression));
#endif

      int hash;
      var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.ThrowExpression, throwKeyword, expression, out hash);
      if (cached != null) return (ThrowExpressionSyntax)cached;

      var result = new ThrowExpressionSyntax(SyntaxKind.ThrowExpression, throwKeyword, expression);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public static WhenClauseSyntax WhenClause(SyntaxToken whenKeyword, ExpressionSyntax condition)
    {
#if DEBUG
      if (whenKeyword == null)
        throw new ArgumentNullException(nameof(whenKeyword));
      switch (whenKeyword.Kind)
      {
        case SyntaxKind.WhenKeyword:
          break;
        default:
          throw new ArgumentException("whenKeyword");
      }
      if (condition == null)
        throw new ArgumentNullException(nameof(condition));
#endif

      int hash;
      var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.WhenClause, whenKeyword, condition, out hash);
      if (cached != null) return (WhenClauseSyntax)cached;

      var result = new WhenClauseSyntax(SyntaxKind.WhenClause, whenKeyword, condition);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public static DeclarationPatternSyntax DeclarationPattern(TypeSyntax type, VariableDesignationSyntax designation)
    {
#if DEBUG
      if (type == null)
        throw new ArgumentNullException(nameof(type));
      if (designation == null)
        throw new ArgumentNullException(nameof(designation));
#endif

      int hash;
      var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.DeclarationPattern, type, designation, out hash);
      if (cached != null) return (DeclarationPatternSyntax)cached;

      var result = new DeclarationPatternSyntax(SyntaxKind.DeclarationPattern, type, designation);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public static ConstantPatternSyntax ConstantPattern(ExpressionSyntax expression)
    {
#if DEBUG
      if (expression == null)
        throw new ArgumentNullException(nameof(expression));
#endif

      int hash;
      var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.ConstantPattern, expression, out hash);
      if (cached != null) return (ConstantPatternSyntax)cached;

      var result = new ConstantPatternSyntax(SyntaxKind.ConstantPattern, expression);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public static InterpolatedStringTextSyntax InterpolatedStringText(SyntaxToken textToken)
    {
#if DEBUG
      if (textToken == null)
        throw new ArgumentNullException(nameof(textToken));
      switch (textToken.Kind)
      {
        case SyntaxKind.InterpolatedStringTextToken:
          break;
        default:
          throw new ArgumentException("textToken");
      }
#endif

      int hash;
      var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.InterpolatedStringText, textToken, out hash);
      if (cached != null) return (InterpolatedStringTextSyntax)cached;

      var result = new InterpolatedStringTextSyntax(SyntaxKind.InterpolatedStringText, textToken);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public static InterpolationSyntax Interpolation(SyntaxToken openBraceToken, ExpressionSyntax expression, InterpolationAlignmentClauseSyntax alignmentClause, InterpolationFormatClauseSyntax formatClause, SyntaxToken closeBraceToken)
    {
#if DEBUG
      if (openBraceToken == null)
        throw new ArgumentNullException(nameof(openBraceToken));
      switch (openBraceToken.Kind)
      {
        case SyntaxKind.OpenBraceToken:
          break;
        default:
          throw new ArgumentException("openBraceToken");
      }
      if (expression == null)
        throw new ArgumentNullException(nameof(expression));
      if (closeBraceToken == null)
        throw new ArgumentNullException(nameof(closeBraceToken));
      switch (closeBraceToken.Kind)
      {
        case SyntaxKind.CloseBraceToken:
          break;
        default:
          throw new ArgumentException("closeBraceToken");
      }
#endif

      return new InterpolationSyntax(SyntaxKind.Interpolation, openBraceToken, expression, alignmentClause, formatClause, closeBraceToken);
    }

    public static InterpolationAlignmentClauseSyntax InterpolationAlignmentClause(SyntaxToken commaToken, ExpressionSyntax value)
    {
#if DEBUG
      if (commaToken == null)
        throw new ArgumentNullException(nameof(commaToken));
      if (value == null)
        throw new ArgumentNullException(nameof(value));
#endif

      int hash;
      var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.InterpolationAlignmentClause, commaToken, value, out hash);
      if (cached != null) return (InterpolationAlignmentClauseSyntax)cached;

      var result = new InterpolationAlignmentClauseSyntax(SyntaxKind.InterpolationAlignmentClause, commaToken, value);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public static InterpolationFormatClauseSyntax InterpolationFormatClause(SyntaxToken colonToken, SyntaxToken formatStringToken)
    {
#if DEBUG
      if (colonToken == null)
        throw new ArgumentNullException(nameof(colonToken));
      if (formatStringToken == null)
        throw new ArgumentNullException(nameof(formatStringToken));
      switch (formatStringToken.Kind)
      {
        case SyntaxKind.InterpolatedStringTextToken:
          break;
        default:
          throw new ArgumentException("formatStringToken");
      }
#endif

      int hash;
      var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.InterpolationFormatClause, colonToken, formatStringToken, out hash);
      if (cached != null) return (InterpolationFormatClauseSyntax)cached;

      var result = new InterpolationFormatClauseSyntax(SyntaxKind.InterpolationFormatClause, colonToken, formatStringToken);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public static GlobalStatementSyntax GlobalStatement(StatementSyntax statement)
    {
#if DEBUG
      if (statement == null)
        throw new ArgumentNullException(nameof(statement));
#endif

      int hash;
      var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.GlobalStatement, statement, out hash);
      if (cached != null) return (GlobalStatementSyntax)cached;

      var result = new GlobalStatementSyntax(SyntaxKind.GlobalStatement, statement);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public static BlockSyntax Block(SyntaxToken openBraceToken, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<StatementSyntax> statements, SyntaxToken closeBraceToken)
    {
#if DEBUG
      if (openBraceToken == null)
        throw new ArgumentNullException(nameof(openBraceToken));
      switch (openBraceToken.Kind)
      {
        case SyntaxKind.OpenBraceToken:
          break;
        default:
          throw new ArgumentException("openBraceToken");
      }
      if (closeBraceToken == null)
        throw new ArgumentNullException(nameof(closeBraceToken));
      switch (closeBraceToken.Kind)
      {
        case SyntaxKind.CloseBraceToken:
          break;
        default:
          throw new ArgumentException("closeBraceToken");
      }
#endif

      int hash;
      var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.Block, openBraceToken, statements.Node, closeBraceToken, out hash);
      if (cached != null) return (BlockSyntax)cached;

      var result = new BlockSyntax(SyntaxKind.Block, openBraceToken, statements.Node, closeBraceToken);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public static LocalFunctionStatementSyntax LocalFunctionStatement(Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SyntaxToken> modifiers, TypeSyntax returnType, SyntaxToken identifier, TypeParameterListSyntax typeParameterList, ParameterListSyntax parameterList, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<TypeParameterConstraintClauseSyntax> constraintClauses, BlockSyntax body, ArrowExpressionClauseSyntax expressionBody, SyntaxToken semicolonToken)
    {
#if DEBUG
      if (returnType == null)
        throw new ArgumentNullException(nameof(returnType));
      if (identifier == null)
        throw new ArgumentNullException(nameof(identifier));
      switch (identifier.Kind)
      {
        case SyntaxKind.IdentifierToken:
          break;
        default:
          throw new ArgumentException("identifier");
      }
      if (parameterList == null)
        throw new ArgumentNullException(nameof(parameterList));
      if (semicolonToken != null)
      {
      switch (semicolonToken.Kind)
      {
        case SyntaxKind.SemicolonToken:
        case SyntaxKind.None:
          break;
        default:
          throw new ArgumentException("semicolonToken");
      }
      }
#endif

      return new LocalFunctionStatementSyntax(SyntaxKind.LocalFunctionStatement, modifiers.Node, returnType, identifier, typeParameterList, parameterList, constraintClauses.Node, body, expressionBody, semicolonToken);
    }

    public static LocalDeclarationStatementSyntax LocalDeclarationStatement(Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SyntaxToken> modifiers, VariableDeclarationSyntax declaration, SyntaxToken semicolonToken)
    {
#if DEBUG
      if (declaration == null)
        throw new ArgumentNullException(nameof(declaration));
      if (semicolonToken == null)
        throw new ArgumentNullException(nameof(semicolonToken));
      switch (semicolonToken.Kind)
      {
        case SyntaxKind.SemicolonToken:
          break;
        default:
          throw new ArgumentException("semicolonToken");
      }
#endif

      int hash;
      var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.LocalDeclarationStatement, modifiers.Node, declaration, semicolonToken, out hash);
      if (cached != null) return (LocalDeclarationStatementSyntax)cached;

      var result = new LocalDeclarationStatementSyntax(SyntaxKind.LocalDeclarationStatement, modifiers.Node, declaration, semicolonToken);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public static VariableDeclarationSyntax VariableDeclaration(TypeSyntax type, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<VariableDeclaratorSyntax> variables)
    {
#if DEBUG
      if (type == null)
        throw new ArgumentNullException(nameof(type));
#endif

      int hash;
      var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.VariableDeclaration, type, variables.Node, out hash);
      if (cached != null) return (VariableDeclarationSyntax)cached;

      var result = new VariableDeclarationSyntax(SyntaxKind.VariableDeclaration, type, variables.Node);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public static VariableDeclaratorSyntax VariableDeclarator(SyntaxToken identifier, BracketedArgumentListSyntax argumentList, EqualsValueClauseSyntax initializer)
    {
#if DEBUG
      if (identifier == null)
        throw new ArgumentNullException(nameof(identifier));
      switch (identifier.Kind)
      {
        case SyntaxKind.IdentifierToken:
          break;
        default:
          throw new ArgumentException("identifier");
      }
#endif

      int hash;
      var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.VariableDeclarator, identifier, argumentList, initializer, out hash);
      if (cached != null) return (VariableDeclaratorSyntax)cached;

      var result = new VariableDeclaratorSyntax(SyntaxKind.VariableDeclarator, identifier, argumentList, initializer);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public static EqualsValueClauseSyntax EqualsValueClause(SyntaxToken equalsToken, ExpressionSyntax value)
    {
#if DEBUG
      if (equalsToken == null)
        throw new ArgumentNullException(nameof(equalsToken));
      switch (equalsToken.Kind)
      {
        case SyntaxKind.EqualsToken:
          break;
        default:
          throw new ArgumentException("equalsToken");
      }
      if (value == null)
        throw new ArgumentNullException(nameof(value));
#endif

      int hash;
      var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.EqualsValueClause, equalsToken, value, out hash);
      if (cached != null) return (EqualsValueClauseSyntax)cached;

      var result = new EqualsValueClauseSyntax(SyntaxKind.EqualsValueClause, equalsToken, value);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public static SingleVariableDesignationSyntax SingleVariableDesignation(SyntaxToken identifier)
    {
#if DEBUG
      if (identifier == null)
        throw new ArgumentNullException(nameof(identifier));
      switch (identifier.Kind)
      {
        case SyntaxKind.IdentifierToken:
          break;
        default:
          throw new ArgumentException("identifier");
      }
#endif

      int hash;
      var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.SingleVariableDesignation, identifier, out hash);
      if (cached != null) return (SingleVariableDesignationSyntax)cached;

      var result = new SingleVariableDesignationSyntax(SyntaxKind.SingleVariableDesignation, identifier);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public static DiscardDesignationSyntax DiscardDesignation(SyntaxToken underscoreToken)
    {
#if DEBUG
      if (underscoreToken == null)
        throw new ArgumentNullException(nameof(underscoreToken));
      switch (underscoreToken.Kind)
      {
        case SyntaxKind.UnderscoreToken:
          break;
        default:
          throw new ArgumentException("underscoreToken");
      }
#endif

      int hash;
      var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.DiscardDesignation, underscoreToken, out hash);
      if (cached != null) return (DiscardDesignationSyntax)cached;

      var result = new DiscardDesignationSyntax(SyntaxKind.DiscardDesignation, underscoreToken);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public static ParenthesizedVariableDesignationSyntax ParenthesizedVariableDesignation(SyntaxToken openParenToken, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<VariableDesignationSyntax> variables, SyntaxToken closeParenToken)
    {
#if DEBUG
      if (openParenToken == null)
        throw new ArgumentNullException(nameof(openParenToken));
      switch (openParenToken.Kind)
      {
        case SyntaxKind.OpenParenToken:
          break;
        default:
          throw new ArgumentException("openParenToken");
      }
      if (closeParenToken == null)
        throw new ArgumentNullException(nameof(closeParenToken));
      switch (closeParenToken.Kind)
      {
        case SyntaxKind.CloseParenToken:
          break;
        default:
          throw new ArgumentException("closeParenToken");
      }
#endif

      int hash;
      var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.ParenthesizedVariableDesignation, openParenToken, variables.Node, closeParenToken, out hash);
      if (cached != null) return (ParenthesizedVariableDesignationSyntax)cached;

      var result = new ParenthesizedVariableDesignationSyntax(SyntaxKind.ParenthesizedVariableDesignation, openParenToken, variables.Node, closeParenToken);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public static ExpressionStatementSyntax ExpressionStatement(ExpressionSyntax expression, SyntaxToken semicolonToken)
    {
#if DEBUG
      if (expression == null)
        throw new ArgumentNullException(nameof(expression));
      if (semicolonToken == null)
        throw new ArgumentNullException(nameof(semicolonToken));
      switch (semicolonToken.Kind)
      {
        case SyntaxKind.SemicolonToken:
          break;
        default:
          throw new ArgumentException("semicolonToken");
      }
#endif

      int hash;
      var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.ExpressionStatement, expression, semicolonToken, out hash);
      if (cached != null) return (ExpressionStatementSyntax)cached;

      var result = new ExpressionStatementSyntax(SyntaxKind.ExpressionStatement, expression, semicolonToken);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public static EmptyStatementSyntax EmptyStatement(SyntaxToken semicolonToken)
    {
#if DEBUG
      if (semicolonToken == null)
        throw new ArgumentNullException(nameof(semicolonToken));
      switch (semicolonToken.Kind)
      {
        case SyntaxKind.SemicolonToken:
          break;
        default:
          throw new ArgumentException("semicolonToken");
      }
#endif

      int hash;
      var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.EmptyStatement, semicolonToken, out hash);
      if (cached != null) return (EmptyStatementSyntax)cached;

      var result = new EmptyStatementSyntax(SyntaxKind.EmptyStatement, semicolonToken);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public static LabeledStatementSyntax LabeledStatement(SyntaxToken identifier, SyntaxToken colonToken, StatementSyntax statement)
    {
#if DEBUG
      if (identifier == null)
        throw new ArgumentNullException(nameof(identifier));
      switch (identifier.Kind)
      {
        case SyntaxKind.IdentifierToken:
          break;
        default:
          throw new ArgumentException("identifier");
      }
      if (colonToken == null)
        throw new ArgumentNullException(nameof(colonToken));
      switch (colonToken.Kind)
      {
        case SyntaxKind.ColonToken:
          break;
        default:
          throw new ArgumentException("colonToken");
      }
      if (statement == null)
        throw new ArgumentNullException(nameof(statement));
#endif

      int hash;
      var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.LabeledStatement, identifier, colonToken, statement, out hash);
      if (cached != null) return (LabeledStatementSyntax)cached;

      var result = new LabeledStatementSyntax(SyntaxKind.LabeledStatement, identifier, colonToken, statement);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public static GotoStatementSyntax GotoStatement(SyntaxKind kind, SyntaxToken gotoKeyword, SyntaxToken caseOrDefaultKeyword, ExpressionSyntax expression, SyntaxToken semicolonToken)
    {
      switch (kind)
      {
        case SyntaxKind.GotoStatement:
        case SyntaxKind.GotoCaseStatement:
        case SyntaxKind.GotoDefaultStatement:
          break;
        default:
          throw new ArgumentException("kind");
      }
#if DEBUG
      if (gotoKeyword == null)
        throw new ArgumentNullException(nameof(gotoKeyword));
      switch (gotoKeyword.Kind)
      {
        case SyntaxKind.GotoKeyword:
          break;
        default:
          throw new ArgumentException("gotoKeyword");
      }
      if (caseOrDefaultKeyword != null)
      {
      switch (caseOrDefaultKeyword.Kind)
      {
        case SyntaxKind.CaseKeyword:
        case SyntaxKind.DefaultKeyword:
        case SyntaxKind.None:
          break;
        default:
          throw new ArgumentException("caseOrDefaultKeyword");
      }
      }
      if (semicolonToken == null)
        throw new ArgumentNullException(nameof(semicolonToken));
      switch (semicolonToken.Kind)
      {
        case SyntaxKind.SemicolonToken:
          break;
        default:
          throw new ArgumentException("semicolonToken");
      }
#endif

      return new GotoStatementSyntax(kind, gotoKeyword, caseOrDefaultKeyword, expression, semicolonToken);
    }

    public static BreakStatementSyntax BreakStatement(SyntaxToken breakKeyword, SyntaxToken semicolonToken)
    {
#if DEBUG
      if (breakKeyword == null)
        throw new ArgumentNullException(nameof(breakKeyword));
      switch (breakKeyword.Kind)
      {
        case SyntaxKind.BreakKeyword:
          break;
        default:
          throw new ArgumentException("breakKeyword");
      }
      if (semicolonToken == null)
        throw new ArgumentNullException(nameof(semicolonToken));
      switch (semicolonToken.Kind)
      {
        case SyntaxKind.SemicolonToken:
          break;
        default:
          throw new ArgumentException("semicolonToken");
      }
#endif

      int hash;
      var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.BreakStatement, breakKeyword, semicolonToken, out hash);
      if (cached != null) return (BreakStatementSyntax)cached;

      var result = new BreakStatementSyntax(SyntaxKind.BreakStatement, breakKeyword, semicolonToken);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public static ContinueStatementSyntax ContinueStatement(SyntaxToken continueKeyword, SyntaxToken semicolonToken)
    {
#if DEBUG
      if (continueKeyword == null)
        throw new ArgumentNullException(nameof(continueKeyword));
      switch (continueKeyword.Kind)
      {
        case SyntaxKind.ContinueKeyword:
          break;
        default:
          throw new ArgumentException("continueKeyword");
      }
      if (semicolonToken == null)
        throw new ArgumentNullException(nameof(semicolonToken));
      switch (semicolonToken.Kind)
      {
        case SyntaxKind.SemicolonToken:
          break;
        default:
          throw new ArgumentException("semicolonToken");
      }
#endif

      int hash;
      var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.ContinueStatement, continueKeyword, semicolonToken, out hash);
      if (cached != null) return (ContinueStatementSyntax)cached;

      var result = new ContinueStatementSyntax(SyntaxKind.ContinueStatement, continueKeyword, semicolonToken);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public static ReturnStatementSyntax ReturnStatement(SyntaxToken returnKeyword, ExpressionSyntax expression, SyntaxToken semicolonToken)
    {
#if DEBUG
      if (returnKeyword == null)
        throw new ArgumentNullException(nameof(returnKeyword));
      switch (returnKeyword.Kind)
      {
        case SyntaxKind.ReturnKeyword:
          break;
        default:
          throw new ArgumentException("returnKeyword");
      }
      if (semicolonToken == null)
        throw new ArgumentNullException(nameof(semicolonToken));
      switch (semicolonToken.Kind)
      {
        case SyntaxKind.SemicolonToken:
          break;
        default:
          throw new ArgumentException("semicolonToken");
      }
#endif

      int hash;
      var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.ReturnStatement, returnKeyword, expression, semicolonToken, out hash);
      if (cached != null) return (ReturnStatementSyntax)cached;

      var result = new ReturnStatementSyntax(SyntaxKind.ReturnStatement, returnKeyword, expression, semicolonToken);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public static ThrowStatementSyntax ThrowStatement(SyntaxToken throwKeyword, ExpressionSyntax expression, SyntaxToken semicolonToken)
    {
#if DEBUG
      if (throwKeyword == null)
        throw new ArgumentNullException(nameof(throwKeyword));
      switch (throwKeyword.Kind)
      {
        case SyntaxKind.ThrowKeyword:
          break;
        default:
          throw new ArgumentException("throwKeyword");
      }
      if (semicolonToken == null)
        throw new ArgumentNullException(nameof(semicolonToken));
      switch (semicolonToken.Kind)
      {
        case SyntaxKind.SemicolonToken:
          break;
        default:
          throw new ArgumentException("semicolonToken");
      }
#endif

      int hash;
      var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.ThrowStatement, throwKeyword, expression, semicolonToken, out hash);
      if (cached != null) return (ThrowStatementSyntax)cached;

      var result = new ThrowStatementSyntax(SyntaxKind.ThrowStatement, throwKeyword, expression, semicolonToken);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public static YieldStatementSyntax YieldStatement(SyntaxKind kind, SyntaxToken yieldKeyword, SyntaxToken returnOrBreakKeyword, ExpressionSyntax expression, SyntaxToken semicolonToken)
    {
      switch (kind)
      {
        case SyntaxKind.YieldReturnStatement:
        case SyntaxKind.YieldBreakStatement:
          break;
        default:
          throw new ArgumentException("kind");
      }
#if DEBUG
      if (yieldKeyword == null)
        throw new ArgumentNullException(nameof(yieldKeyword));
      switch (yieldKeyword.Kind)
      {
        case SyntaxKind.YieldKeyword:
          break;
        default:
          throw new ArgumentException("yieldKeyword");
      }
      if (returnOrBreakKeyword == null)
        throw new ArgumentNullException(nameof(returnOrBreakKeyword));
      switch (returnOrBreakKeyword.Kind)
      {
        case SyntaxKind.ReturnKeyword:
        case SyntaxKind.BreakKeyword:
          break;
        default:
          throw new ArgumentException("returnOrBreakKeyword");
      }
      if (semicolonToken == null)
        throw new ArgumentNullException(nameof(semicolonToken));
      switch (semicolonToken.Kind)
      {
        case SyntaxKind.SemicolonToken:
          break;
        default:
          throw new ArgumentException("semicolonToken");
      }
#endif

      return new YieldStatementSyntax(kind, yieldKeyword, returnOrBreakKeyword, expression, semicolonToken);
    }

    public static WhileStatementSyntax WhileStatement(SyntaxToken whileKeyword, SyntaxToken openParenToken, ExpressionSyntax condition, SyntaxToken closeParenToken, StatementSyntax statement)
    {
#if DEBUG
      if (whileKeyword == null)
        throw new ArgumentNullException(nameof(whileKeyword));
      switch (whileKeyword.Kind)
      {
        case SyntaxKind.WhileKeyword:
          break;
        default:
          throw new ArgumentException("whileKeyword");
      }
      if (openParenToken == null)
        throw new ArgumentNullException(nameof(openParenToken));
      switch (openParenToken.Kind)
      {
        case SyntaxKind.OpenParenToken:
          break;
        default:
          throw new ArgumentException("openParenToken");
      }
      if (condition == null)
        throw new ArgumentNullException(nameof(condition));
      if (closeParenToken == null)
        throw new ArgumentNullException(nameof(closeParenToken));
      switch (closeParenToken.Kind)
      {
        case SyntaxKind.CloseParenToken:
          break;
        default:
          throw new ArgumentException("closeParenToken");
      }
      if (statement == null)
        throw new ArgumentNullException(nameof(statement));
#endif

      return new WhileStatementSyntax(SyntaxKind.WhileStatement, whileKeyword, openParenToken, condition, closeParenToken, statement);
    }

    public static DoStatementSyntax DoStatement(SyntaxToken doKeyword, StatementSyntax statement, SyntaxToken whileKeyword, SyntaxToken openParenToken, ExpressionSyntax condition, SyntaxToken closeParenToken, SyntaxToken semicolonToken)
    {
#if DEBUG
      if (doKeyword == null)
        throw new ArgumentNullException(nameof(doKeyword));
      switch (doKeyword.Kind)
      {
        case SyntaxKind.DoKeyword:
          break;
        default:
          throw new ArgumentException("doKeyword");
      }
      if (statement == null)
        throw new ArgumentNullException(nameof(statement));
      if (whileKeyword == null)
        throw new ArgumentNullException(nameof(whileKeyword));
      switch (whileKeyword.Kind)
      {
        case SyntaxKind.WhileKeyword:
          break;
        default:
          throw new ArgumentException("whileKeyword");
      }
      if (openParenToken == null)
        throw new ArgumentNullException(nameof(openParenToken));
      switch (openParenToken.Kind)
      {
        case SyntaxKind.OpenParenToken:
          break;
        default:
          throw new ArgumentException("openParenToken");
      }
      if (condition == null)
        throw new ArgumentNullException(nameof(condition));
      if (closeParenToken == null)
        throw new ArgumentNullException(nameof(closeParenToken));
      switch (closeParenToken.Kind)
      {
        case SyntaxKind.CloseParenToken:
          break;
        default:
          throw new ArgumentException("closeParenToken");
      }
      if (semicolonToken == null)
        throw new ArgumentNullException(nameof(semicolonToken));
      switch (semicolonToken.Kind)
      {
        case SyntaxKind.SemicolonToken:
          break;
        default:
          throw new ArgumentException("semicolonToken");
      }
#endif

      return new DoStatementSyntax(SyntaxKind.DoStatement, doKeyword, statement, whileKeyword, openParenToken, condition, closeParenToken, semicolonToken);
    }

    public static ForStatementSyntax ForStatement(SyntaxToken forKeyword, SyntaxToken openParenToken, VariableDeclarationSyntax declaration, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<ExpressionSyntax> initializers, SyntaxToken firstSemicolonToken, ExpressionSyntax condition, SyntaxToken secondSemicolonToken, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<ExpressionSyntax> incrementors, SyntaxToken closeParenToken, StatementSyntax statement)
    {
#if DEBUG
      if (forKeyword == null)
        throw new ArgumentNullException(nameof(forKeyword));
      switch (forKeyword.Kind)
      {
        case SyntaxKind.ForKeyword:
          break;
        default:
          throw new ArgumentException("forKeyword");
      }
      if (openParenToken == null)
        throw new ArgumentNullException(nameof(openParenToken));
      switch (openParenToken.Kind)
      {
        case SyntaxKind.OpenParenToken:
          break;
        default:
          throw new ArgumentException("openParenToken");
      }
      if (firstSemicolonToken == null)
        throw new ArgumentNullException(nameof(firstSemicolonToken));
      switch (firstSemicolonToken.Kind)
      {
        case SyntaxKind.SemicolonToken:
          break;
        default:
          throw new ArgumentException("firstSemicolonToken");
      }
      if (secondSemicolonToken == null)
        throw new ArgumentNullException(nameof(secondSemicolonToken));
      switch (secondSemicolonToken.Kind)
      {
        case SyntaxKind.SemicolonToken:
          break;
        default:
          throw new ArgumentException("secondSemicolonToken");
      }
      if (closeParenToken == null)
        throw new ArgumentNullException(nameof(closeParenToken));
      switch (closeParenToken.Kind)
      {
        case SyntaxKind.CloseParenToken:
          break;
        default:
          throw new ArgumentException("closeParenToken");
      }
      if (statement == null)
        throw new ArgumentNullException(nameof(statement));
#endif

      return new ForStatementSyntax(SyntaxKind.ForStatement, forKeyword, openParenToken, declaration, initializers.Node, firstSemicolonToken, condition, secondSemicolonToken, incrementors.Node, closeParenToken, statement);
    }

    public static ForEachStatementSyntax ForEachStatement(SyntaxToken forEachKeyword, SyntaxToken openParenToken, TypeSyntax type, SyntaxToken identifier, SyntaxToken inKeyword, ExpressionSyntax expression, SyntaxToken closeParenToken, StatementSyntax statement)
    {
#if DEBUG
      if (forEachKeyword == null)
        throw new ArgumentNullException(nameof(forEachKeyword));
      switch (forEachKeyword.Kind)
      {
        case SyntaxKind.ForEachKeyword:
          break;
        default:
          throw new ArgumentException("forEachKeyword");
      }
      if (openParenToken == null)
        throw new ArgumentNullException(nameof(openParenToken));
      switch (openParenToken.Kind)
      {
        case SyntaxKind.OpenParenToken:
          break;
        default:
          throw new ArgumentException("openParenToken");
      }
      if (type == null)
        throw new ArgumentNullException(nameof(type));
      if (identifier == null)
        throw new ArgumentNullException(nameof(identifier));
      switch (identifier.Kind)
      {
        case SyntaxKind.IdentifierToken:
          break;
        default:
          throw new ArgumentException("identifier");
      }
      if (inKeyword == null)
        throw new ArgumentNullException(nameof(inKeyword));
      switch (inKeyword.Kind)
      {
        case SyntaxKind.InKeyword:
          break;
        default:
          throw new ArgumentException("inKeyword");
      }
      if (expression == null)
        throw new ArgumentNullException(nameof(expression));
      if (closeParenToken == null)
        throw new ArgumentNullException(nameof(closeParenToken));
      switch (closeParenToken.Kind)
      {
        case SyntaxKind.CloseParenToken:
          break;
        default:
          throw new ArgumentException("closeParenToken");
      }
      if (statement == null)
        throw new ArgumentNullException(nameof(statement));
#endif

      return new ForEachStatementSyntax(SyntaxKind.ForEachStatement, forEachKeyword, openParenToken, type, identifier, inKeyword, expression, closeParenToken, statement);
    }

    public static ForEachVariableStatementSyntax ForEachVariableStatement(SyntaxToken forEachKeyword, SyntaxToken openParenToken, ExpressionSyntax variable, SyntaxToken inKeyword, ExpressionSyntax expression, SyntaxToken closeParenToken, StatementSyntax statement)
    {
#if DEBUG
      if (forEachKeyword == null)
        throw new ArgumentNullException(nameof(forEachKeyword));
      switch (forEachKeyword.Kind)
      {
        case SyntaxKind.ForEachKeyword:
          break;
        default:
          throw new ArgumentException("forEachKeyword");
      }
      if (openParenToken == null)
        throw new ArgumentNullException(nameof(openParenToken));
      switch (openParenToken.Kind)
      {
        case SyntaxKind.OpenParenToken:
          break;
        default:
          throw new ArgumentException("openParenToken");
      }
      if (variable == null)
        throw new ArgumentNullException(nameof(variable));
      if (inKeyword == null)
        throw new ArgumentNullException(nameof(inKeyword));
      switch (inKeyword.Kind)
      {
        case SyntaxKind.InKeyword:
          break;
        default:
          throw new ArgumentException("inKeyword");
      }
      if (expression == null)
        throw new ArgumentNullException(nameof(expression));
      if (closeParenToken == null)
        throw new ArgumentNullException(nameof(closeParenToken));
      switch (closeParenToken.Kind)
      {
        case SyntaxKind.CloseParenToken:
          break;
        default:
          throw new ArgumentException("closeParenToken");
      }
      if (statement == null)
        throw new ArgumentNullException(nameof(statement));
#endif

      return new ForEachVariableStatementSyntax(SyntaxKind.ForEachVariableStatement, forEachKeyword, openParenToken, variable, inKeyword, expression, closeParenToken, statement);
    }

    public static UsingStatementSyntax UsingStatement(SyntaxToken usingKeyword, SyntaxToken openParenToken, VariableDeclarationSyntax declaration, ExpressionSyntax expression, SyntaxToken closeParenToken, StatementSyntax statement)
    {
#if DEBUG
      if (usingKeyword == null)
        throw new ArgumentNullException(nameof(usingKeyword));
      switch (usingKeyword.Kind)
      {
        case SyntaxKind.UsingKeyword:
          break;
        default:
          throw new ArgumentException("usingKeyword");
      }
      if (openParenToken == null)
        throw new ArgumentNullException(nameof(openParenToken));
      switch (openParenToken.Kind)
      {
        case SyntaxKind.OpenParenToken:
          break;
        default:
          throw new ArgumentException("openParenToken");
      }
      if (closeParenToken == null)
        throw new ArgumentNullException(nameof(closeParenToken));
      switch (closeParenToken.Kind)
      {
        case SyntaxKind.CloseParenToken:
          break;
        default:
          throw new ArgumentException("closeParenToken");
      }
      if (statement == null)
        throw new ArgumentNullException(nameof(statement));
#endif

      return new UsingStatementSyntax(SyntaxKind.UsingStatement, usingKeyword, openParenToken, declaration, expression, closeParenToken, statement);
    }

    public static FixedStatementSyntax FixedStatement(SyntaxToken fixedKeyword, SyntaxToken openParenToken, VariableDeclarationSyntax declaration, SyntaxToken closeParenToken, StatementSyntax statement)
    {
#if DEBUG
      if (fixedKeyword == null)
        throw new ArgumentNullException(nameof(fixedKeyword));
      switch (fixedKeyword.Kind)
      {
        case SyntaxKind.FixedKeyword:
          break;
        default:
          throw new ArgumentException("fixedKeyword");
      }
      if (openParenToken == null)
        throw new ArgumentNullException(nameof(openParenToken));
      switch (openParenToken.Kind)
      {
        case SyntaxKind.OpenParenToken:
          break;
        default:
          throw new ArgumentException("openParenToken");
      }
      if (declaration == null)
        throw new ArgumentNullException(nameof(declaration));
      if (closeParenToken == null)
        throw new ArgumentNullException(nameof(closeParenToken));
      switch (closeParenToken.Kind)
      {
        case SyntaxKind.CloseParenToken:
          break;
        default:
          throw new ArgumentException("closeParenToken");
      }
      if (statement == null)
        throw new ArgumentNullException(nameof(statement));
#endif

      return new FixedStatementSyntax(SyntaxKind.FixedStatement, fixedKeyword, openParenToken, declaration, closeParenToken, statement);
    }

    public static CheckedStatementSyntax CheckedStatement(SyntaxKind kind, SyntaxToken keyword, BlockSyntax block)
    {
      switch (kind)
      {
        case SyntaxKind.CheckedStatement:
        case SyntaxKind.UncheckedStatement:
          break;
        default:
          throw new ArgumentException("kind");
      }
#if DEBUG
      if (keyword == null)
        throw new ArgumentNullException(nameof(keyword));
      switch (keyword.Kind)
      {
        case SyntaxKind.CheckedKeyword:
        case SyntaxKind.UncheckedKeyword:
          break;
        default:
          throw new ArgumentException("keyword");
      }
      if (block == null)
        throw new ArgumentNullException(nameof(block));
#endif

      int hash;
      var cached = SyntaxNodeCache.TryGetNode((int)kind, keyword, block, out hash);
      if (cached != null) return (CheckedStatementSyntax)cached;

      var result = new CheckedStatementSyntax(kind, keyword, block);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public static UnsafeStatementSyntax UnsafeStatement(SyntaxToken unsafeKeyword, BlockSyntax block)
    {
#if DEBUG
      if (unsafeKeyword == null)
        throw new ArgumentNullException(nameof(unsafeKeyword));
      switch (unsafeKeyword.Kind)
      {
        case SyntaxKind.UnsafeKeyword:
          break;
        default:
          throw new ArgumentException("unsafeKeyword");
      }
      if (block == null)
        throw new ArgumentNullException(nameof(block));
#endif

      int hash;
      var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.UnsafeStatement, unsafeKeyword, block, out hash);
      if (cached != null) return (UnsafeStatementSyntax)cached;

      var result = new UnsafeStatementSyntax(SyntaxKind.UnsafeStatement, unsafeKeyword, block);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public static LockStatementSyntax LockStatement(SyntaxToken lockKeyword, SyntaxToken openParenToken, ExpressionSyntax expression, SyntaxToken closeParenToken, StatementSyntax statement)
    {
#if DEBUG
      if (lockKeyword == null)
        throw new ArgumentNullException(nameof(lockKeyword));
      switch (lockKeyword.Kind)
      {
        case SyntaxKind.LockKeyword:
          break;
        default:
          throw new ArgumentException("lockKeyword");
      }
      if (openParenToken == null)
        throw new ArgumentNullException(nameof(openParenToken));
      switch (openParenToken.Kind)
      {
        case SyntaxKind.OpenParenToken:
          break;
        default:
          throw new ArgumentException("openParenToken");
      }
      if (expression == null)
        throw new ArgumentNullException(nameof(expression));
      if (closeParenToken == null)
        throw new ArgumentNullException(nameof(closeParenToken));
      switch (closeParenToken.Kind)
      {
        case SyntaxKind.CloseParenToken:
          break;
        default:
          throw new ArgumentException("closeParenToken");
      }
      if (statement == null)
        throw new ArgumentNullException(nameof(statement));
#endif

      return new LockStatementSyntax(SyntaxKind.LockStatement, lockKeyword, openParenToken, expression, closeParenToken, statement);
    }

    public static IfStatementSyntax IfStatement(SyntaxToken ifKeyword, SyntaxToken openParenToken, ExpressionSyntax condition, SyntaxToken closeParenToken, StatementSyntax statement, ElseClauseSyntax @else)
    {
#if DEBUG
      if (ifKeyword == null)
        throw new ArgumentNullException(nameof(ifKeyword));
      switch (ifKeyword.Kind)
      {
        case SyntaxKind.IfKeyword:
          break;
        default:
          throw new ArgumentException("ifKeyword");
      }
      if (openParenToken == null)
        throw new ArgumentNullException(nameof(openParenToken));
      switch (openParenToken.Kind)
      {
        case SyntaxKind.OpenParenToken:
          break;
        default:
          throw new ArgumentException("openParenToken");
      }
      if (condition == null)
        throw new ArgumentNullException(nameof(condition));
      if (closeParenToken == null)
        throw new ArgumentNullException(nameof(closeParenToken));
      switch (closeParenToken.Kind)
      {
        case SyntaxKind.CloseParenToken:
          break;
        default:
          throw new ArgumentException("closeParenToken");
      }
      if (statement == null)
        throw new ArgumentNullException(nameof(statement));
#endif

      return new IfStatementSyntax(SyntaxKind.IfStatement, ifKeyword, openParenToken, condition, closeParenToken, statement, @else);
    }

    public static ElseClauseSyntax ElseClause(SyntaxToken elseKeyword, StatementSyntax statement)
    {
#if DEBUG
      if (elseKeyword == null)
        throw new ArgumentNullException(nameof(elseKeyword));
      switch (elseKeyword.Kind)
      {
        case SyntaxKind.ElseKeyword:
          break;
        default:
          throw new ArgumentException("elseKeyword");
      }
      if (statement == null)
        throw new ArgumentNullException(nameof(statement));
#endif

      int hash;
      var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.ElseClause, elseKeyword, statement, out hash);
      if (cached != null) return (ElseClauseSyntax)cached;

      var result = new ElseClauseSyntax(SyntaxKind.ElseClause, elseKeyword, statement);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public static SwitchStatementSyntax SwitchStatement(SyntaxToken switchKeyword, SyntaxToken openParenToken, ExpressionSyntax expression, SyntaxToken closeParenToken, SyntaxToken openBraceToken, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SwitchSectionSyntax> sections, SyntaxToken closeBraceToken)
    {
#if DEBUG
      if (switchKeyword == null)
        throw new ArgumentNullException(nameof(switchKeyword));
      switch (switchKeyword.Kind)
      {
        case SyntaxKind.SwitchKeyword:
          break;
        default:
          throw new ArgumentException("switchKeyword");
      }
      if (openParenToken == null)
        throw new ArgumentNullException(nameof(openParenToken));
      switch (openParenToken.Kind)
      {
        case SyntaxKind.OpenParenToken:
          break;
        default:
          throw new ArgumentException("openParenToken");
      }
      if (expression == null)
        throw new ArgumentNullException(nameof(expression));
      if (closeParenToken == null)
        throw new ArgumentNullException(nameof(closeParenToken));
      switch (closeParenToken.Kind)
      {
        case SyntaxKind.CloseParenToken:
          break;
        default:
          throw new ArgumentException("closeParenToken");
      }
      if (openBraceToken == null)
        throw new ArgumentNullException(nameof(openBraceToken));
      switch (openBraceToken.Kind)
      {
        case SyntaxKind.OpenBraceToken:
          break;
        default:
          throw new ArgumentException("openBraceToken");
      }
      if (closeBraceToken == null)
        throw new ArgumentNullException(nameof(closeBraceToken));
      switch (closeBraceToken.Kind)
      {
        case SyntaxKind.CloseBraceToken:
          break;
        default:
          throw new ArgumentException("closeBraceToken");
      }
#endif

      return new SwitchStatementSyntax(SyntaxKind.SwitchStatement, switchKeyword, openParenToken, expression, closeParenToken, openBraceToken, sections.Node, closeBraceToken);
    }

    public static SwitchSectionSyntax SwitchSection(Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SwitchLabelSyntax> labels, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<StatementSyntax> statements)
    {
#if DEBUG
#endif

      int hash;
      var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.SwitchSection, labels.Node, statements.Node, out hash);
      if (cached != null) return (SwitchSectionSyntax)cached;

      var result = new SwitchSectionSyntax(SyntaxKind.SwitchSection, labels.Node, statements.Node);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public static CasePatternSwitchLabelSyntax CasePatternSwitchLabel(SyntaxToken keyword, PatternSyntax pattern, WhenClauseSyntax whenClause, SyntaxToken colonToken)
    {
#if DEBUG
      if (keyword == null)
        throw new ArgumentNullException(nameof(keyword));
      switch (keyword.Kind)
      {
        case SyntaxKind.CaseKeyword:
          break;
        default:
          throw new ArgumentException("keyword");
      }
      if (pattern == null)
        throw new ArgumentNullException(nameof(pattern));
      if (colonToken == null)
        throw new ArgumentNullException(nameof(colonToken));
#endif

      return new CasePatternSwitchLabelSyntax(SyntaxKind.CasePatternSwitchLabel, keyword, pattern, whenClause, colonToken);
    }

    public static CaseSwitchLabelSyntax CaseSwitchLabel(SyntaxToken keyword, ExpressionSyntax value, SyntaxToken colonToken)
    {
#if DEBUG
      if (keyword == null)
        throw new ArgumentNullException(nameof(keyword));
      switch (keyword.Kind)
      {
        case SyntaxKind.CaseKeyword:
          break;
        default:
          throw new ArgumentException("keyword");
      }
      if (value == null)
        throw new ArgumentNullException(nameof(value));
      if (colonToken == null)
        throw new ArgumentNullException(nameof(colonToken));
#endif

      int hash;
      var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.CaseSwitchLabel, keyword, value, colonToken, out hash);
      if (cached != null) return (CaseSwitchLabelSyntax)cached;

      var result = new CaseSwitchLabelSyntax(SyntaxKind.CaseSwitchLabel, keyword, value, colonToken);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public static DefaultSwitchLabelSyntax DefaultSwitchLabel(SyntaxToken keyword, SyntaxToken colonToken)
    {
#if DEBUG
      if (keyword == null)
        throw new ArgumentNullException(nameof(keyword));
      switch (keyword.Kind)
      {
        case SyntaxKind.DefaultKeyword:
          break;
        default:
          throw new ArgumentException("keyword");
      }
      if (colonToken == null)
        throw new ArgumentNullException(nameof(colonToken));
#endif

      int hash;
      var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.DefaultSwitchLabel, keyword, colonToken, out hash);
      if (cached != null) return (DefaultSwitchLabelSyntax)cached;

      var result = new DefaultSwitchLabelSyntax(SyntaxKind.DefaultSwitchLabel, keyword, colonToken);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public static TryStatementSyntax TryStatement(SyntaxToken tryKeyword, BlockSyntax block, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<CatchClauseSyntax> catches, FinallyClauseSyntax @finally)
    {
#if DEBUG
      if (tryKeyword == null)
        throw new ArgumentNullException(nameof(tryKeyword));
      switch (tryKeyword.Kind)
      {
        case SyntaxKind.TryKeyword:
          break;
        default:
          throw new ArgumentException("tryKeyword");
      }
      if (block == null)
        throw new ArgumentNullException(nameof(block));
#endif

      return new TryStatementSyntax(SyntaxKind.TryStatement, tryKeyword, block, catches.Node, @finally);
    }

    public static CatchClauseSyntax CatchClause(SyntaxToken catchKeyword, CatchDeclarationSyntax declaration, CatchFilterClauseSyntax filter, BlockSyntax block)
    {
#if DEBUG
      if (catchKeyword == null)
        throw new ArgumentNullException(nameof(catchKeyword));
      switch (catchKeyword.Kind)
      {
        case SyntaxKind.CatchKeyword:
          break;
        default:
          throw new ArgumentException("catchKeyword");
      }
      if (block == null)
        throw new ArgumentNullException(nameof(block));
#endif

      return new CatchClauseSyntax(SyntaxKind.CatchClause, catchKeyword, declaration, filter, block);
    }

    public static CatchDeclarationSyntax CatchDeclaration(SyntaxToken openParenToken, TypeSyntax type, SyntaxToken identifier, SyntaxToken closeParenToken)
    {
#if DEBUG
      if (openParenToken == null)
        throw new ArgumentNullException(nameof(openParenToken));
      switch (openParenToken.Kind)
      {
        case SyntaxKind.OpenParenToken:
          break;
        default:
          throw new ArgumentException("openParenToken");
      }
      if (type == null)
        throw new ArgumentNullException(nameof(type));
      if (identifier != null)
      {
      switch (identifier.Kind)
      {
        case SyntaxKind.IdentifierToken:
        case SyntaxKind.None:
          break;
        default:
          throw new ArgumentException("identifier");
      }
      }
      if (closeParenToken == null)
        throw new ArgumentNullException(nameof(closeParenToken));
      switch (closeParenToken.Kind)
      {
        case SyntaxKind.CloseParenToken:
          break;
        default:
          throw new ArgumentException("closeParenToken");
      }
#endif

      return new CatchDeclarationSyntax(SyntaxKind.CatchDeclaration, openParenToken, type, identifier, closeParenToken);
    }

    public static CatchFilterClauseSyntax CatchFilterClause(SyntaxToken whenKeyword, SyntaxToken openParenToken, ExpressionSyntax filterExpression, SyntaxToken closeParenToken)
    {
#if DEBUG
      if (whenKeyword == null)
        throw new ArgumentNullException(nameof(whenKeyword));
      switch (whenKeyword.Kind)
      {
        case SyntaxKind.WhenKeyword:
          break;
        default:
          throw new ArgumentException("whenKeyword");
      }
      if (openParenToken == null)
        throw new ArgumentNullException(nameof(openParenToken));
      switch (openParenToken.Kind)
      {
        case SyntaxKind.OpenParenToken:
          break;
        default:
          throw new ArgumentException("openParenToken");
      }
      if (filterExpression == null)
        throw new ArgumentNullException(nameof(filterExpression));
      if (closeParenToken == null)
        throw new ArgumentNullException(nameof(closeParenToken));
      switch (closeParenToken.Kind)
      {
        case SyntaxKind.CloseParenToken:
          break;
        default:
          throw new ArgumentException("closeParenToken");
      }
#endif

      return new CatchFilterClauseSyntax(SyntaxKind.CatchFilterClause, whenKeyword, openParenToken, filterExpression, closeParenToken);
    }

    public static FinallyClauseSyntax FinallyClause(SyntaxToken finallyKeyword, BlockSyntax block)
    {
#if DEBUG
      if (finallyKeyword == null)
        throw new ArgumentNullException(nameof(finallyKeyword));
      switch (finallyKeyword.Kind)
      {
        case SyntaxKind.FinallyKeyword:
          break;
        default:
          throw new ArgumentException("finallyKeyword");
      }
      if (block == null)
        throw new ArgumentNullException(nameof(block));
#endif

      int hash;
      var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.FinallyClause, finallyKeyword, block, out hash);
      if (cached != null) return (FinallyClauseSyntax)cached;

      var result = new FinallyClauseSyntax(SyntaxKind.FinallyClause, finallyKeyword, block);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public static CompilationUnitSyntax CompilationUnit(Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<ExternAliasDirectiveSyntax> externs, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<UsingDirectiveSyntax> usings, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<AttributeListSyntax> attributeLists, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<MemberDeclarationSyntax> members, SyntaxToken endOfFileToken)
    {
#if DEBUG
      if (endOfFileToken == null)
        throw new ArgumentNullException(nameof(endOfFileToken));
      switch (endOfFileToken.Kind)
      {
        case SyntaxKind.EndOfFileToken:
          break;
        default:
          throw new ArgumentException("endOfFileToken");
      }
#endif

      return new CompilationUnitSyntax(SyntaxKind.CompilationUnit, externs.Node, usings.Node, attributeLists.Node, members.Node, endOfFileToken);
    }

    public static ExternAliasDirectiveSyntax ExternAliasDirective(SyntaxToken externKeyword, SyntaxToken aliasKeyword, SyntaxToken identifier, SyntaxToken semicolonToken)
    {
#if DEBUG
      if (externKeyword == null)
        throw new ArgumentNullException(nameof(externKeyword));
      switch (externKeyword.Kind)
      {
        case SyntaxKind.ExternKeyword:
          break;
        default:
          throw new ArgumentException("externKeyword");
      }
      if (aliasKeyword == null)
        throw new ArgumentNullException(nameof(aliasKeyword));
      switch (aliasKeyword.Kind)
      {
        case SyntaxKind.AliasKeyword:
          break;
        default:
          throw new ArgumentException("aliasKeyword");
      }
      if (identifier == null)
        throw new ArgumentNullException(nameof(identifier));
      switch (identifier.Kind)
      {
        case SyntaxKind.IdentifierToken:
          break;
        default:
          throw new ArgumentException("identifier");
      }
      if (semicolonToken == null)
        throw new ArgumentNullException(nameof(semicolonToken));
      switch (semicolonToken.Kind)
      {
        case SyntaxKind.SemicolonToken:
          break;
        default:
          throw new ArgumentException("semicolonToken");
      }
#endif

      return new ExternAliasDirectiveSyntax(SyntaxKind.ExternAliasDirective, externKeyword, aliasKeyword, identifier, semicolonToken);
    }

    public static UsingDirectiveSyntax UsingDirective(SyntaxToken usingKeyword, SyntaxToken staticKeyword, NameEqualsSyntax alias, NameSyntax name, SyntaxToken semicolonToken)
    {
#if DEBUG
      if (usingKeyword == null)
        throw new ArgumentNullException(nameof(usingKeyword));
      switch (usingKeyword.Kind)
      {
        case SyntaxKind.UsingKeyword:
          break;
        default:
          throw new ArgumentException("usingKeyword");
      }
      if (name == null)
        throw new ArgumentNullException(nameof(name));
      if (semicolonToken == null)
        throw new ArgumentNullException(nameof(semicolonToken));
      switch (semicolonToken.Kind)
      {
        case SyntaxKind.SemicolonToken:
          break;
        default:
          throw new ArgumentException("semicolonToken");
      }
#endif

      return new UsingDirectiveSyntax(SyntaxKind.UsingDirective, usingKeyword, staticKeyword, alias, name, semicolonToken);
    }

    public static NamespaceDeclarationSyntax NamespaceDeclaration(SyntaxToken namespaceKeyword, NameSyntax name, SyntaxToken openBraceToken, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<ExternAliasDirectiveSyntax> externs, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<UsingDirectiveSyntax> usings, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<MemberDeclarationSyntax> members, SyntaxToken closeBraceToken, SyntaxToken semicolonToken)
    {
#if DEBUG
      if (namespaceKeyword == null)
        throw new ArgumentNullException(nameof(namespaceKeyword));
      switch (namespaceKeyword.Kind)
      {
        case SyntaxKind.NamespaceKeyword:
          break;
        default:
          throw new ArgumentException("namespaceKeyword");
      }
      if (name == null)
        throw new ArgumentNullException(nameof(name));
      if (openBraceToken == null)
        throw new ArgumentNullException(nameof(openBraceToken));
      switch (openBraceToken.Kind)
      {
        case SyntaxKind.OpenBraceToken:
          break;
        default:
          throw new ArgumentException("openBraceToken");
      }
      if (closeBraceToken == null)
        throw new ArgumentNullException(nameof(closeBraceToken));
      switch (closeBraceToken.Kind)
      {
        case SyntaxKind.CloseBraceToken:
          break;
        default:
          throw new ArgumentException("closeBraceToken");
      }
      if (semicolonToken != null)
      {
      switch (semicolonToken.Kind)
      {
        case SyntaxKind.SemicolonToken:
        case SyntaxKind.None:
          break;
        default:
          throw new ArgumentException("semicolonToken");
      }
      }
#endif

      return new NamespaceDeclarationSyntax(SyntaxKind.NamespaceDeclaration, namespaceKeyword, name, openBraceToken, externs.Node, usings.Node, members.Node, closeBraceToken, semicolonToken);
    }

    public static AttributeListSyntax AttributeList(SyntaxToken openBracketToken, AttributeTargetSpecifierSyntax target, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<AttributeSyntax> attributes, SyntaxToken closeBracketToken)
    {
#if DEBUG
      if (openBracketToken == null)
        throw new ArgumentNullException(nameof(openBracketToken));
      switch (openBracketToken.Kind)
      {
        case SyntaxKind.OpenBracketToken:
          break;
        default:
          throw new ArgumentException("openBracketToken");
      }
      if (closeBracketToken == null)
        throw new ArgumentNullException(nameof(closeBracketToken));
      switch (closeBracketToken.Kind)
      {
        case SyntaxKind.CloseBracketToken:
          break;
        default:
          throw new ArgumentException("closeBracketToken");
      }
#endif

      return new AttributeListSyntax(SyntaxKind.AttributeList, openBracketToken, target, attributes.Node, closeBracketToken);
    }

    public static AttributeTargetSpecifierSyntax AttributeTargetSpecifier(SyntaxToken identifier, SyntaxToken colonToken)
    {
#if DEBUG
      if (identifier == null)
        throw new ArgumentNullException(nameof(identifier));
      if (colonToken == null)
        throw new ArgumentNullException(nameof(colonToken));
      switch (colonToken.Kind)
      {
        case SyntaxKind.ColonToken:
          break;
        default:
          throw new ArgumentException("colonToken");
      }
#endif

      int hash;
      var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.AttributeTargetSpecifier, identifier, colonToken, out hash);
      if (cached != null) return (AttributeTargetSpecifierSyntax)cached;

      var result = new AttributeTargetSpecifierSyntax(SyntaxKind.AttributeTargetSpecifier, identifier, colonToken);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public static AttributeSyntax Attribute(NameSyntax name, AttributeArgumentListSyntax argumentList)
    {
#if DEBUG
      if (name == null)
        throw new ArgumentNullException(nameof(name));
#endif

      int hash;
      var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.Attribute, name, argumentList, out hash);
      if (cached != null) return (AttributeSyntax)cached;

      var result = new AttributeSyntax(SyntaxKind.Attribute, name, argumentList);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public static AttributeArgumentListSyntax AttributeArgumentList(SyntaxToken openParenToken, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<AttributeArgumentSyntax> arguments, SyntaxToken closeParenToken)
    {
#if DEBUG
      if (openParenToken == null)
        throw new ArgumentNullException(nameof(openParenToken));
      switch (openParenToken.Kind)
      {
        case SyntaxKind.OpenParenToken:
          break;
        default:
          throw new ArgumentException("openParenToken");
      }
      if (closeParenToken == null)
        throw new ArgumentNullException(nameof(closeParenToken));
      switch (closeParenToken.Kind)
      {
        case SyntaxKind.CloseParenToken:
          break;
        default:
          throw new ArgumentException("closeParenToken");
      }
#endif

      int hash;
      var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.AttributeArgumentList, openParenToken, arguments.Node, closeParenToken, out hash);
      if (cached != null) return (AttributeArgumentListSyntax)cached;

      var result = new AttributeArgumentListSyntax(SyntaxKind.AttributeArgumentList, openParenToken, arguments.Node, closeParenToken);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public static AttributeArgumentSyntax AttributeArgument(NameEqualsSyntax nameEquals, NameColonSyntax nameColon, ExpressionSyntax expression)
    {
#if DEBUG
      if (expression == null)
        throw new ArgumentNullException(nameof(expression));
#endif

      int hash;
      var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.AttributeArgument, nameEquals, nameColon, expression, out hash);
      if (cached != null) return (AttributeArgumentSyntax)cached;

      var result = new AttributeArgumentSyntax(SyntaxKind.AttributeArgument, nameEquals, nameColon, expression);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public static NameEqualsSyntax NameEquals(IdentifierNameSyntax name, SyntaxToken equalsToken)
    {
#if DEBUG
      if (name == null)
        throw new ArgumentNullException(nameof(name));
      if (equalsToken == null)
        throw new ArgumentNullException(nameof(equalsToken));
      switch (equalsToken.Kind)
      {
        case SyntaxKind.EqualsToken:
          break;
        default:
          throw new ArgumentException("equalsToken");
      }
#endif

      int hash;
      var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.NameEquals, name, equalsToken, out hash);
      if (cached != null) return (NameEqualsSyntax)cached;

      var result = new NameEqualsSyntax(SyntaxKind.NameEquals, name, equalsToken);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public static TypeParameterListSyntax TypeParameterList(SyntaxToken lessThanToken, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<TypeParameterSyntax> parameters, SyntaxToken greaterThanToken)
    {
#if DEBUG
      if (lessThanToken == null)
        throw new ArgumentNullException(nameof(lessThanToken));
      switch (lessThanToken.Kind)
      {
        case SyntaxKind.LessThanToken:
          break;
        default:
          throw new ArgumentException("lessThanToken");
      }
      if (greaterThanToken == null)
        throw new ArgumentNullException(nameof(greaterThanToken));
      switch (greaterThanToken.Kind)
      {
        case SyntaxKind.GreaterThanToken:
          break;
        default:
          throw new ArgumentException("greaterThanToken");
      }
#endif

      int hash;
      var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.TypeParameterList, lessThanToken, parameters.Node, greaterThanToken, out hash);
      if (cached != null) return (TypeParameterListSyntax)cached;

      var result = new TypeParameterListSyntax(SyntaxKind.TypeParameterList, lessThanToken, parameters.Node, greaterThanToken);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public static TypeParameterSyntax TypeParameter(Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<AttributeListSyntax> attributeLists, SyntaxToken varianceKeyword, SyntaxToken identifier)
    {
#if DEBUG
      if (varianceKeyword != null)
      {
      switch (varianceKeyword.Kind)
      {
        case SyntaxKind.InKeyword:
        case SyntaxKind.OutKeyword:
        case SyntaxKind.None:
          break;
        default:
          throw new ArgumentException("varianceKeyword");
      }
      }
      if (identifier == null)
        throw new ArgumentNullException(nameof(identifier));
      switch (identifier.Kind)
      {
        case SyntaxKind.IdentifierToken:
          break;
        default:
          throw new ArgumentException("identifier");
      }
#endif

      int hash;
      var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.TypeParameter, attributeLists.Node, varianceKeyword, identifier, out hash);
      if (cached != null) return (TypeParameterSyntax)cached;

      var result = new TypeParameterSyntax(SyntaxKind.TypeParameter, attributeLists.Node, varianceKeyword, identifier);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public static ClassDeclarationSyntax ClassDeclaration(Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<AttributeListSyntax> attributeLists, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SyntaxToken> modifiers, SyntaxToken keyword, SyntaxToken identifier, TypeParameterListSyntax typeParameterList, BaseListSyntax baseList, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<TypeParameterConstraintClauseSyntax> constraintClauses, SyntaxToken openBraceToken, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<MemberDeclarationSyntax> members, SyntaxToken closeBraceToken, SyntaxToken semicolonToken)
    {
#if DEBUG
      if (keyword == null)
        throw new ArgumentNullException(nameof(keyword));
      switch (keyword.Kind)
      {
        case SyntaxKind.ClassKeyword:
          break;
        default:
          throw new ArgumentException("keyword");
      }
      if (identifier == null)
        throw new ArgumentNullException(nameof(identifier));
      switch (identifier.Kind)
      {
        case SyntaxKind.IdentifierToken:
          break;
        default:
          throw new ArgumentException("identifier");
      }
      if (openBraceToken == null)
        throw new ArgumentNullException(nameof(openBraceToken));
      switch (openBraceToken.Kind)
      {
        case SyntaxKind.OpenBraceToken:
          break;
        default:
          throw new ArgumentException("openBraceToken");
      }
      if (closeBraceToken == null)
        throw new ArgumentNullException(nameof(closeBraceToken));
      switch (closeBraceToken.Kind)
      {
        case SyntaxKind.CloseBraceToken:
          break;
        default:
          throw new ArgumentException("closeBraceToken");
      }
      if (semicolonToken != null)
      {
      switch (semicolonToken.Kind)
      {
        case SyntaxKind.SemicolonToken:
        case SyntaxKind.None:
          break;
        default:
          throw new ArgumentException("semicolonToken");
      }
      }
#endif

      return new ClassDeclarationSyntax(SyntaxKind.ClassDeclaration, attributeLists.Node, modifiers.Node, keyword, identifier, typeParameterList, baseList, constraintClauses.Node, openBraceToken, members.Node, closeBraceToken, semicolonToken);
    }

    public static StructDeclarationSyntax StructDeclaration(Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<AttributeListSyntax> attributeLists, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SyntaxToken> modifiers, SyntaxToken keyword, SyntaxToken identifier, TypeParameterListSyntax typeParameterList, BaseListSyntax baseList, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<TypeParameterConstraintClauseSyntax> constraintClauses, SyntaxToken openBraceToken, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<MemberDeclarationSyntax> members, SyntaxToken closeBraceToken, SyntaxToken semicolonToken)
    {
#if DEBUG
      if (keyword == null)
        throw new ArgumentNullException(nameof(keyword));
      switch (keyword.Kind)
      {
        case SyntaxKind.StructKeyword:
          break;
        default:
          throw new ArgumentException("keyword");
      }
      if (identifier == null)
        throw new ArgumentNullException(nameof(identifier));
      switch (identifier.Kind)
      {
        case SyntaxKind.IdentifierToken:
          break;
        default:
          throw new ArgumentException("identifier");
      }
      if (openBraceToken == null)
        throw new ArgumentNullException(nameof(openBraceToken));
      switch (openBraceToken.Kind)
      {
        case SyntaxKind.OpenBraceToken:
          break;
        default:
          throw new ArgumentException("openBraceToken");
      }
      if (closeBraceToken == null)
        throw new ArgumentNullException(nameof(closeBraceToken));
      switch (closeBraceToken.Kind)
      {
        case SyntaxKind.CloseBraceToken:
          break;
        default:
          throw new ArgumentException("closeBraceToken");
      }
      if (semicolonToken != null)
      {
      switch (semicolonToken.Kind)
      {
        case SyntaxKind.SemicolonToken:
        case SyntaxKind.None:
          break;
        default:
          throw new ArgumentException("semicolonToken");
      }
      }
#endif

      return new StructDeclarationSyntax(SyntaxKind.StructDeclaration, attributeLists.Node, modifiers.Node, keyword, identifier, typeParameterList, baseList, constraintClauses.Node, openBraceToken, members.Node, closeBraceToken, semicolonToken);
    }

    public static InterfaceDeclarationSyntax InterfaceDeclaration(Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<AttributeListSyntax> attributeLists, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SyntaxToken> modifiers, SyntaxToken keyword, SyntaxToken identifier, TypeParameterListSyntax typeParameterList, BaseListSyntax baseList, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<TypeParameterConstraintClauseSyntax> constraintClauses, SyntaxToken openBraceToken, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<MemberDeclarationSyntax> members, SyntaxToken closeBraceToken, SyntaxToken semicolonToken)
    {
#if DEBUG
      if (keyword == null)
        throw new ArgumentNullException(nameof(keyword));
      switch (keyword.Kind)
      {
        case SyntaxKind.InterfaceKeyword:
          break;
        default:
          throw new ArgumentException("keyword");
      }
      if (identifier == null)
        throw new ArgumentNullException(nameof(identifier));
      switch (identifier.Kind)
      {
        case SyntaxKind.IdentifierToken:
          break;
        default:
          throw new ArgumentException("identifier");
      }
      if (openBraceToken == null)
        throw new ArgumentNullException(nameof(openBraceToken));
      switch (openBraceToken.Kind)
      {
        case SyntaxKind.OpenBraceToken:
          break;
        default:
          throw new ArgumentException("openBraceToken");
      }
      if (closeBraceToken == null)
        throw new ArgumentNullException(nameof(closeBraceToken));
      switch (closeBraceToken.Kind)
      {
        case SyntaxKind.CloseBraceToken:
          break;
        default:
          throw new ArgumentException("closeBraceToken");
      }
      if (semicolonToken != null)
      {
      switch (semicolonToken.Kind)
      {
        case SyntaxKind.SemicolonToken:
        case SyntaxKind.None:
          break;
        default:
          throw new ArgumentException("semicolonToken");
      }
      }
#endif

      return new InterfaceDeclarationSyntax(SyntaxKind.InterfaceDeclaration, attributeLists.Node, modifiers.Node, keyword, identifier, typeParameterList, baseList, constraintClauses.Node, openBraceToken, members.Node, closeBraceToken, semicolonToken);
    }

    public static EnumDeclarationSyntax EnumDeclaration(Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<AttributeListSyntax> attributeLists, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SyntaxToken> modifiers, SyntaxToken enumKeyword, SyntaxToken identifier, BaseListSyntax baseList, SyntaxToken openBraceToken, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<EnumMemberDeclarationSyntax> members, SyntaxToken closeBraceToken, SyntaxToken semicolonToken)
    {
#if DEBUG
      if (enumKeyword == null)
        throw new ArgumentNullException(nameof(enumKeyword));
      switch (enumKeyword.Kind)
      {
        case SyntaxKind.EnumKeyword:
          break;
        default:
          throw new ArgumentException("enumKeyword");
      }
      if (identifier == null)
        throw new ArgumentNullException(nameof(identifier));
      switch (identifier.Kind)
      {
        case SyntaxKind.IdentifierToken:
          break;
        default:
          throw new ArgumentException("identifier");
      }
      if (openBraceToken == null)
        throw new ArgumentNullException(nameof(openBraceToken));
      switch (openBraceToken.Kind)
      {
        case SyntaxKind.OpenBraceToken:
          break;
        default:
          throw new ArgumentException("openBraceToken");
      }
      if (closeBraceToken == null)
        throw new ArgumentNullException(nameof(closeBraceToken));
      switch (closeBraceToken.Kind)
      {
        case SyntaxKind.CloseBraceToken:
          break;
        default:
          throw new ArgumentException("closeBraceToken");
      }
      if (semicolonToken != null)
      {
      switch (semicolonToken.Kind)
      {
        case SyntaxKind.SemicolonToken:
        case SyntaxKind.None:
          break;
        default:
          throw new ArgumentException("semicolonToken");
      }
      }
#endif

      return new EnumDeclarationSyntax(SyntaxKind.EnumDeclaration, attributeLists.Node, modifiers.Node, enumKeyword, identifier, baseList, openBraceToken, members.Node, closeBraceToken, semicolonToken);
    }

    public static DelegateDeclarationSyntax DelegateDeclaration(Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<AttributeListSyntax> attributeLists, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SyntaxToken> modifiers, SyntaxToken delegateKeyword, TypeSyntax returnType, SyntaxToken identifier, TypeParameterListSyntax typeParameterList, ParameterListSyntax parameterList, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<TypeParameterConstraintClauseSyntax> constraintClauses, SyntaxToken semicolonToken)
    {
#if DEBUG
      if (delegateKeyword == null)
        throw new ArgumentNullException(nameof(delegateKeyword));
      switch (delegateKeyword.Kind)
      {
        case SyntaxKind.DelegateKeyword:
          break;
        default:
          throw new ArgumentException("delegateKeyword");
      }
      if (returnType == null)
        throw new ArgumentNullException(nameof(returnType));
      if (identifier == null)
        throw new ArgumentNullException(nameof(identifier));
      switch (identifier.Kind)
      {
        case SyntaxKind.IdentifierToken:
          break;
        default:
          throw new ArgumentException("identifier");
      }
      if (parameterList == null)
        throw new ArgumentNullException(nameof(parameterList));
      if (semicolonToken == null)
        throw new ArgumentNullException(nameof(semicolonToken));
      switch (semicolonToken.Kind)
      {
        case SyntaxKind.SemicolonToken:
          break;
        default:
          throw new ArgumentException("semicolonToken");
      }
#endif

      return new DelegateDeclarationSyntax(SyntaxKind.DelegateDeclaration, attributeLists.Node, modifiers.Node, delegateKeyword, returnType, identifier, typeParameterList, parameterList, constraintClauses.Node, semicolonToken);
    }

    public static EnumMemberDeclarationSyntax EnumMemberDeclaration(Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<AttributeListSyntax> attributeLists, SyntaxToken identifier, EqualsValueClauseSyntax equalsValue)
    {
#if DEBUG
      if (identifier == null)
        throw new ArgumentNullException(nameof(identifier));
      switch (identifier.Kind)
      {
        case SyntaxKind.IdentifierToken:
          break;
        default:
          throw new ArgumentException("identifier");
      }
#endif

      int hash;
      var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.EnumMemberDeclaration, attributeLists.Node, identifier, equalsValue, out hash);
      if (cached != null) return (EnumMemberDeclarationSyntax)cached;

      var result = new EnumMemberDeclarationSyntax(SyntaxKind.EnumMemberDeclaration, attributeLists.Node, identifier, equalsValue);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public static BaseListSyntax BaseList(SyntaxToken colonToken, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<BaseTypeSyntax> types)
    {
#if DEBUG
      if (colonToken == null)
        throw new ArgumentNullException(nameof(colonToken));
      switch (colonToken.Kind)
      {
        case SyntaxKind.ColonToken:
          break;
        default:
          throw new ArgumentException("colonToken");
      }
#endif

      int hash;
      var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.BaseList, colonToken, types.Node, out hash);
      if (cached != null) return (BaseListSyntax)cached;

      var result = new BaseListSyntax(SyntaxKind.BaseList, colonToken, types.Node);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public static SimpleBaseTypeSyntax SimpleBaseType(TypeSyntax type)
    {
#if DEBUG
      if (type == null)
        throw new ArgumentNullException(nameof(type));
#endif

      int hash;
      var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.SimpleBaseType, type, out hash);
      if (cached != null) return (SimpleBaseTypeSyntax)cached;

      var result = new SimpleBaseTypeSyntax(SyntaxKind.SimpleBaseType, type);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public static TypeParameterConstraintClauseSyntax TypeParameterConstraintClause(SyntaxToken whereKeyword, IdentifierNameSyntax name, SyntaxToken colonToken, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<TypeParameterConstraintSyntax> constraints)
    {
#if DEBUG
      if (whereKeyword == null)
        throw new ArgumentNullException(nameof(whereKeyword));
      switch (whereKeyword.Kind)
      {
        case SyntaxKind.WhereKeyword:
          break;
        default:
          throw new ArgumentException("whereKeyword");
      }
      if (name == null)
        throw new ArgumentNullException(nameof(name));
      if (colonToken == null)
        throw new ArgumentNullException(nameof(colonToken));
      switch (colonToken.Kind)
      {
        case SyntaxKind.ColonToken:
          break;
        default:
          throw new ArgumentException("colonToken");
      }
#endif

      return new TypeParameterConstraintClauseSyntax(SyntaxKind.TypeParameterConstraintClause, whereKeyword, name, colonToken, constraints.Node);
    }

    public static ConstructorConstraintSyntax ConstructorConstraint(SyntaxToken newKeyword, SyntaxToken openParenToken, SyntaxToken closeParenToken)
    {
#if DEBUG
      if (newKeyword == null)
        throw new ArgumentNullException(nameof(newKeyword));
      switch (newKeyword.Kind)
      {
        case SyntaxKind.NewKeyword:
          break;
        default:
          throw new ArgumentException("newKeyword");
      }
      if (openParenToken == null)
        throw new ArgumentNullException(nameof(openParenToken));
      switch (openParenToken.Kind)
      {
        case SyntaxKind.OpenParenToken:
          break;
        default:
          throw new ArgumentException("openParenToken");
      }
      if (closeParenToken == null)
        throw new ArgumentNullException(nameof(closeParenToken));
      switch (closeParenToken.Kind)
      {
        case SyntaxKind.CloseParenToken:
          break;
        default:
          throw new ArgumentException("closeParenToken");
      }
#endif

      int hash;
      var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.ConstructorConstraint, newKeyword, openParenToken, closeParenToken, out hash);
      if (cached != null) return (ConstructorConstraintSyntax)cached;

      var result = new ConstructorConstraintSyntax(SyntaxKind.ConstructorConstraint, newKeyword, openParenToken, closeParenToken);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public static ClassOrStructConstraintSyntax ClassOrStructConstraint(SyntaxKind kind, SyntaxToken classOrStructKeyword)
    {
      switch (kind)
      {
        case SyntaxKind.ClassConstraint:
        case SyntaxKind.StructConstraint:
          break;
        default:
          throw new ArgumentException("kind");
      }
#if DEBUG
      if (classOrStructKeyword == null)
        throw new ArgumentNullException(nameof(classOrStructKeyword));
      switch (classOrStructKeyword.Kind)
      {
        case SyntaxKind.ClassKeyword:
        case SyntaxKind.StructKeyword:
          break;
        default:
          throw new ArgumentException("classOrStructKeyword");
      }
#endif

      int hash;
      var cached = SyntaxNodeCache.TryGetNode((int)kind, classOrStructKeyword, out hash);
      if (cached != null) return (ClassOrStructConstraintSyntax)cached;

      var result = new ClassOrStructConstraintSyntax(kind, classOrStructKeyword);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public static TypeConstraintSyntax TypeConstraint(TypeSyntax type)
    {
#if DEBUG
      if (type == null)
        throw new ArgumentNullException(nameof(type));
#endif

      int hash;
      var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.TypeConstraint, type, out hash);
      if (cached != null) return (TypeConstraintSyntax)cached;

      var result = new TypeConstraintSyntax(SyntaxKind.TypeConstraint, type);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public static FieldDeclarationSyntax FieldDeclaration(Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<AttributeListSyntax> attributeLists, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SyntaxToken> modifiers, VariableDeclarationSyntax declaration, SyntaxToken semicolonToken)
    {
#if DEBUG
      if (declaration == null)
        throw new ArgumentNullException(nameof(declaration));
      if (semicolonToken == null)
        throw new ArgumentNullException(nameof(semicolonToken));
      switch (semicolonToken.Kind)
      {
        case SyntaxKind.SemicolonToken:
          break;
        default:
          throw new ArgumentException("semicolonToken");
      }
#endif

      return new FieldDeclarationSyntax(SyntaxKind.FieldDeclaration, attributeLists.Node, modifiers.Node, declaration, semicolonToken);
    }

    public static EventFieldDeclarationSyntax EventFieldDeclaration(Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<AttributeListSyntax> attributeLists, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SyntaxToken> modifiers, SyntaxToken eventKeyword, VariableDeclarationSyntax declaration, SyntaxToken semicolonToken)
    {
#if DEBUG
      if (eventKeyword == null)
        throw new ArgumentNullException(nameof(eventKeyword));
      switch (eventKeyword.Kind)
      {
        case SyntaxKind.EventKeyword:
          break;
        default:
          throw new ArgumentException("eventKeyword");
      }
      if (declaration == null)
        throw new ArgumentNullException(nameof(declaration));
      if (semicolonToken == null)
        throw new ArgumentNullException(nameof(semicolonToken));
      switch (semicolonToken.Kind)
      {
        case SyntaxKind.SemicolonToken:
          break;
        default:
          throw new ArgumentException("semicolonToken");
      }
#endif

      return new EventFieldDeclarationSyntax(SyntaxKind.EventFieldDeclaration, attributeLists.Node, modifiers.Node, eventKeyword, declaration, semicolonToken);
    }

    public static ExplicitInterfaceSpecifierSyntax ExplicitInterfaceSpecifier(NameSyntax name, SyntaxToken dotToken)
    {
#if DEBUG
      if (name == null)
        throw new ArgumentNullException(nameof(name));
      if (dotToken == null)
        throw new ArgumentNullException(nameof(dotToken));
      switch (dotToken.Kind)
      {
        case SyntaxKind.DotToken:
          break;
        default:
          throw new ArgumentException("dotToken");
      }
#endif

      int hash;
      var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.ExplicitInterfaceSpecifier, name, dotToken, out hash);
      if (cached != null) return (ExplicitInterfaceSpecifierSyntax)cached;

      var result = new ExplicitInterfaceSpecifierSyntax(SyntaxKind.ExplicitInterfaceSpecifier, name, dotToken);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public static MethodDeclarationSyntax MethodDeclaration(Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<AttributeListSyntax> attributeLists, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SyntaxToken> modifiers, TypeSyntax returnType, ExplicitInterfaceSpecifierSyntax explicitInterfaceSpecifier, SyntaxToken identifier, TypeParameterListSyntax typeParameterList, ParameterListSyntax parameterList, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<TypeParameterConstraintClauseSyntax> constraintClauses, BlockSyntax body, ArrowExpressionClauseSyntax expressionBody, SyntaxToken semicolonToken)
    {
#if DEBUG
      if (returnType == null)
        throw new ArgumentNullException(nameof(returnType));
      if (identifier == null)
        throw new ArgumentNullException(nameof(identifier));
      switch (identifier.Kind)
      {
        case SyntaxKind.IdentifierToken:
          break;
        default:
          throw new ArgumentException("identifier");
      }
      if (parameterList == null)
        throw new ArgumentNullException(nameof(parameterList));
      if (semicolonToken != null)
      {
      switch (semicolonToken.Kind)
      {
        case SyntaxKind.SemicolonToken:
        case SyntaxKind.None:
          break;
        default:
          throw new ArgumentException("semicolonToken");
      }
      }
#endif

      return new MethodDeclarationSyntax(SyntaxKind.MethodDeclaration, attributeLists.Node, modifiers.Node, returnType, explicitInterfaceSpecifier, identifier, typeParameterList, parameterList, constraintClauses.Node, body, expressionBody, semicolonToken);
    }

    public static OperatorDeclarationSyntax OperatorDeclaration(Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<AttributeListSyntax> attributeLists, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SyntaxToken> modifiers, TypeSyntax returnType, SyntaxToken operatorKeyword, SyntaxToken operatorToken, ParameterListSyntax parameterList, BlockSyntax body, ArrowExpressionClauseSyntax expressionBody, SyntaxToken semicolonToken)
    {
#if DEBUG
      if (returnType == null)
        throw new ArgumentNullException(nameof(returnType));
      if (operatorKeyword == null)
        throw new ArgumentNullException(nameof(operatorKeyword));
      switch (operatorKeyword.Kind)
      {
        case SyntaxKind.OperatorKeyword:
          break;
        default:
          throw new ArgumentException("operatorKeyword");
      }
      if (operatorToken == null)
        throw new ArgumentNullException(nameof(operatorToken));
      switch (operatorToken.Kind)
      {
        case SyntaxKind.PlusToken:
        case SyntaxKind.MinusToken:
        case SyntaxKind.ExclamationToken:
        case SyntaxKind.TildeToken:
        case SyntaxKind.PlusPlusToken:
        case SyntaxKind.MinusMinusToken:
        case SyntaxKind.AsteriskToken:
        case SyntaxKind.SlashToken:
        case SyntaxKind.PercentToken:
        case SyntaxKind.LessThanLessThanToken:
        case SyntaxKind.GreaterThanGreaterThanToken:
        case SyntaxKind.BarToken:
        case SyntaxKind.AmpersandToken:
        case SyntaxKind.CaretToken:
        case SyntaxKind.EqualsEqualsToken:
        case SyntaxKind.ExclamationEqualsToken:
        case SyntaxKind.LessThanToken:
        case SyntaxKind.LessThanEqualsToken:
        case SyntaxKind.GreaterThanToken:
        case SyntaxKind.GreaterThanEqualsToken:
        case SyntaxKind.FalseKeyword:
        case SyntaxKind.TrueKeyword:
        case SyntaxKind.IsKeyword:
          break;
        default:
          throw new ArgumentException("operatorToken");
      }
      if (parameterList == null)
        throw new ArgumentNullException(nameof(parameterList));
      if (semicolonToken != null)
      {
      switch (semicolonToken.Kind)
      {
        case SyntaxKind.SemicolonToken:
        case SyntaxKind.None:
          break;
        default:
          throw new ArgumentException("semicolonToken");
      }
      }
#endif

      return new OperatorDeclarationSyntax(SyntaxKind.OperatorDeclaration, attributeLists.Node, modifiers.Node, returnType, operatorKeyword, operatorToken, parameterList, body, expressionBody, semicolonToken);
    }

    public static ConversionOperatorDeclarationSyntax ConversionOperatorDeclaration(Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<AttributeListSyntax> attributeLists, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SyntaxToken> modifiers, SyntaxToken implicitOrExplicitKeyword, SyntaxToken operatorKeyword, TypeSyntax type, ParameterListSyntax parameterList, BlockSyntax body, ArrowExpressionClauseSyntax expressionBody, SyntaxToken semicolonToken)
    {
#if DEBUG
      if (implicitOrExplicitKeyword == null)
        throw new ArgumentNullException(nameof(implicitOrExplicitKeyword));
      switch (implicitOrExplicitKeyword.Kind)
      {
        case SyntaxKind.ImplicitKeyword:
        case SyntaxKind.ExplicitKeyword:
          break;
        default:
          throw new ArgumentException("implicitOrExplicitKeyword");
      }
      if (operatorKeyword == null)
        throw new ArgumentNullException(nameof(operatorKeyword));
      switch (operatorKeyword.Kind)
      {
        case SyntaxKind.OperatorKeyword:
          break;
        default:
          throw new ArgumentException("operatorKeyword");
      }
      if (type == null)
        throw new ArgumentNullException(nameof(type));
      if (parameterList == null)
        throw new ArgumentNullException(nameof(parameterList));
      if (semicolonToken != null)
      {
      switch (semicolonToken.Kind)
      {
        case SyntaxKind.SemicolonToken:
        case SyntaxKind.None:
          break;
        default:
          throw new ArgumentException("semicolonToken");
      }
      }
#endif

      return new ConversionOperatorDeclarationSyntax(SyntaxKind.ConversionOperatorDeclaration, attributeLists.Node, modifiers.Node, implicitOrExplicitKeyword, operatorKeyword, type, parameterList, body, expressionBody, semicolonToken);
    }

    public static ConstructorDeclarationSyntax ConstructorDeclaration(Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<AttributeListSyntax> attributeLists, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SyntaxToken> modifiers, SyntaxToken identifier, ParameterListSyntax parameterList, ConstructorInitializerSyntax initializer, BlockSyntax body, ArrowExpressionClauseSyntax expressionBody, SyntaxToken semicolonToken)
    {
#if DEBUG
      if (identifier == null)
        throw new ArgumentNullException(nameof(identifier));
      switch (identifier.Kind)
      {
        case SyntaxKind.IdentifierToken:
          break;
        default:
          throw new ArgumentException("identifier");
      }
      if (parameterList == null)
        throw new ArgumentNullException(nameof(parameterList));
      if (semicolonToken != null)
      {
      switch (semicolonToken.Kind)
      {
        case SyntaxKind.SemicolonToken:
        case SyntaxKind.None:
          break;
        default:
          throw new ArgumentException("semicolonToken");
      }
      }
#endif

      return new ConstructorDeclarationSyntax(SyntaxKind.ConstructorDeclaration, attributeLists.Node, modifiers.Node, identifier, parameterList, initializer, body, expressionBody, semicolonToken);
    }

    public static ConstructorInitializerSyntax ConstructorInitializer(SyntaxKind kind, SyntaxToken colonToken, SyntaxToken thisOrBaseKeyword, ArgumentListSyntax argumentList)
    {
      switch (kind)
      {
        case SyntaxKind.BaseConstructorInitializer:
        case SyntaxKind.ThisConstructorInitializer:
          break;
        default:
          throw new ArgumentException("kind");
      }
#if DEBUG
      if (colonToken == null)
        throw new ArgumentNullException(nameof(colonToken));
      switch (colonToken.Kind)
      {
        case SyntaxKind.ColonToken:
          break;
        default:
          throw new ArgumentException("colonToken");
      }
      if (thisOrBaseKeyword == null)
        throw new ArgumentNullException(nameof(thisOrBaseKeyword));
      switch (thisOrBaseKeyword.Kind)
      {
        case SyntaxKind.BaseKeyword:
        case SyntaxKind.ThisKeyword:
          break;
        default:
          throw new ArgumentException("thisOrBaseKeyword");
      }
      if (argumentList == null)
        throw new ArgumentNullException(nameof(argumentList));
#endif

      int hash;
      var cached = SyntaxNodeCache.TryGetNode((int)kind, colonToken, thisOrBaseKeyword, argumentList, out hash);
      if (cached != null) return (ConstructorInitializerSyntax)cached;

      var result = new ConstructorInitializerSyntax(kind, colonToken, thisOrBaseKeyword, argumentList);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public static DestructorDeclarationSyntax DestructorDeclaration(Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<AttributeListSyntax> attributeLists, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SyntaxToken> modifiers, SyntaxToken tildeToken, SyntaxToken identifier, ParameterListSyntax parameterList, BlockSyntax body, ArrowExpressionClauseSyntax expressionBody, SyntaxToken semicolonToken)
    {
#if DEBUG
      if (tildeToken == null)
        throw new ArgumentNullException(nameof(tildeToken));
      switch (tildeToken.Kind)
      {
        case SyntaxKind.TildeToken:
          break;
        default:
          throw new ArgumentException("tildeToken");
      }
      if (identifier == null)
        throw new ArgumentNullException(nameof(identifier));
      switch (identifier.Kind)
      {
        case SyntaxKind.IdentifierToken:
          break;
        default:
          throw new ArgumentException("identifier");
      }
      if (parameterList == null)
        throw new ArgumentNullException(nameof(parameterList));
      if (semicolonToken != null)
      {
      switch (semicolonToken.Kind)
      {
        case SyntaxKind.SemicolonToken:
        case SyntaxKind.None:
          break;
        default:
          throw new ArgumentException("semicolonToken");
      }
      }
#endif

      return new DestructorDeclarationSyntax(SyntaxKind.DestructorDeclaration, attributeLists.Node, modifiers.Node, tildeToken, identifier, parameterList, body, expressionBody, semicolonToken);
    }

    public static PropertyDeclarationSyntax PropertyDeclaration(Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<AttributeListSyntax> attributeLists, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SyntaxToken> modifiers, TypeSyntax type, ExplicitInterfaceSpecifierSyntax explicitInterfaceSpecifier, SyntaxToken identifier, AccessorListSyntax accessorList, ArrowExpressionClauseSyntax expressionBody, EqualsValueClauseSyntax initializer, SyntaxToken semicolonToken)
    {
#if DEBUG
      if (type == null)
        throw new ArgumentNullException(nameof(type));
      if (identifier == null)
        throw new ArgumentNullException(nameof(identifier));
      switch (identifier.Kind)
      {
        case SyntaxKind.IdentifierToken:
          break;
        default:
          throw new ArgumentException("identifier");
      }
      if (semicolonToken != null)
      {
      switch (semicolonToken.Kind)
      {
        case SyntaxKind.SemicolonToken:
        case SyntaxKind.None:
          break;
        default:
          throw new ArgumentException("semicolonToken");
      }
      }
#endif

      return new PropertyDeclarationSyntax(SyntaxKind.PropertyDeclaration, attributeLists.Node, modifiers.Node, type, explicitInterfaceSpecifier, identifier, accessorList, expressionBody, initializer, semicolonToken);
    }

    public static ArrowExpressionClauseSyntax ArrowExpressionClause(SyntaxToken arrowToken, ExpressionSyntax expression)
    {
#if DEBUG
      if (arrowToken == null)
        throw new ArgumentNullException(nameof(arrowToken));
      switch (arrowToken.Kind)
      {
        case SyntaxKind.EqualsGreaterThanToken:
          break;
        default:
          throw new ArgumentException("arrowToken");
      }
      if (expression == null)
        throw new ArgumentNullException(nameof(expression));
#endif

      int hash;
      var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.ArrowExpressionClause, arrowToken, expression, out hash);
      if (cached != null) return (ArrowExpressionClauseSyntax)cached;

      var result = new ArrowExpressionClauseSyntax(SyntaxKind.ArrowExpressionClause, arrowToken, expression);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public static EventDeclarationSyntax EventDeclaration(Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<AttributeListSyntax> attributeLists, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SyntaxToken> modifiers, SyntaxToken eventKeyword, TypeSyntax type, ExplicitInterfaceSpecifierSyntax explicitInterfaceSpecifier, SyntaxToken identifier, AccessorListSyntax accessorList)
    {
#if DEBUG
      if (eventKeyword == null)
        throw new ArgumentNullException(nameof(eventKeyword));
      switch (eventKeyword.Kind)
      {
        case SyntaxKind.EventKeyword:
          break;
        default:
          throw new ArgumentException("eventKeyword");
      }
      if (type == null)
        throw new ArgumentNullException(nameof(type));
      if (identifier == null)
        throw new ArgumentNullException(nameof(identifier));
      switch (identifier.Kind)
      {
        case SyntaxKind.IdentifierToken:
          break;
        default:
          throw new ArgumentException("identifier");
      }
      if (accessorList == null)
        throw new ArgumentNullException(nameof(accessorList));
#endif

      return new EventDeclarationSyntax(SyntaxKind.EventDeclaration, attributeLists.Node, modifiers.Node, eventKeyword, type, explicitInterfaceSpecifier, identifier, accessorList);
    }

    public static IndexerDeclarationSyntax IndexerDeclaration(Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<AttributeListSyntax> attributeLists, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SyntaxToken> modifiers, TypeSyntax type, ExplicitInterfaceSpecifierSyntax explicitInterfaceSpecifier, SyntaxToken thisKeyword, BracketedParameterListSyntax parameterList, AccessorListSyntax accessorList, ArrowExpressionClauseSyntax expressionBody, SyntaxToken semicolonToken)
    {
#if DEBUG
      if (type == null)
        throw new ArgumentNullException(nameof(type));
      if (thisKeyword == null)
        throw new ArgumentNullException(nameof(thisKeyword));
      switch (thisKeyword.Kind)
      {
        case SyntaxKind.ThisKeyword:
          break;
        default:
          throw new ArgumentException("thisKeyword");
      }
      if (parameterList == null)
        throw new ArgumentNullException(nameof(parameterList));
      if (semicolonToken != null)
      {
      switch (semicolonToken.Kind)
      {
        case SyntaxKind.SemicolonToken:
        case SyntaxKind.None:
          break;
        default:
          throw new ArgumentException("semicolonToken");
      }
      }
#endif

      return new IndexerDeclarationSyntax(SyntaxKind.IndexerDeclaration, attributeLists.Node, modifiers.Node, type, explicitInterfaceSpecifier, thisKeyword, parameterList, accessorList, expressionBody, semicolonToken);
    }

    public static AccessorListSyntax AccessorList(SyntaxToken openBraceToken, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<AccessorDeclarationSyntax> accessors, SyntaxToken closeBraceToken)
    {
#if DEBUG
      if (openBraceToken == null)
        throw new ArgumentNullException(nameof(openBraceToken));
      switch (openBraceToken.Kind)
      {
        case SyntaxKind.OpenBraceToken:
          break;
        default:
          throw new ArgumentException("openBraceToken");
      }
      if (closeBraceToken == null)
        throw new ArgumentNullException(nameof(closeBraceToken));
      switch (closeBraceToken.Kind)
      {
        case SyntaxKind.CloseBraceToken:
          break;
        default:
          throw new ArgumentException("closeBraceToken");
      }
#endif

      int hash;
      var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.AccessorList, openBraceToken, accessors.Node, closeBraceToken, out hash);
      if (cached != null) return (AccessorListSyntax)cached;

      var result = new AccessorListSyntax(SyntaxKind.AccessorList, openBraceToken, accessors.Node, closeBraceToken);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public static AccessorDeclarationSyntax AccessorDeclaration(SyntaxKind kind, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<AttributeListSyntax> attributeLists, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SyntaxToken> modifiers, SyntaxToken keyword, BlockSyntax body, ArrowExpressionClauseSyntax expressionBody, SyntaxToken semicolonToken)
    {
      switch (kind)
      {
        case SyntaxKind.GetAccessorDeclaration:
        case SyntaxKind.SetAccessorDeclaration:
        case SyntaxKind.AddAccessorDeclaration:
        case SyntaxKind.RemoveAccessorDeclaration:
        case SyntaxKind.UnknownAccessorDeclaration:
          break;
        default:
          throw new ArgumentException("kind");
      }
#if DEBUG
      if (keyword == null)
        throw new ArgumentNullException(nameof(keyword));
      switch (keyword.Kind)
      {
        case SyntaxKind.GetKeyword:
        case SyntaxKind.SetKeyword:
        case SyntaxKind.AddKeyword:
        case SyntaxKind.RemoveKeyword:
        case SyntaxKind.IdentifierToken:
          break;
        default:
          throw new ArgumentException("keyword");
      }
      if (semicolonToken != null)
      {
      switch (semicolonToken.Kind)
      {
        case SyntaxKind.SemicolonToken:
        case SyntaxKind.None:
          break;
        default:
          throw new ArgumentException("semicolonToken");
      }
      }
#endif

      return new AccessorDeclarationSyntax(kind, attributeLists.Node, modifiers.Node, keyword, body, expressionBody, semicolonToken);
    }

    public static ParameterListSyntax ParameterList(SyntaxToken openParenToken, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<ParameterSyntax> parameters, SyntaxToken closeParenToken)
    {
#if DEBUG
      if (openParenToken == null)
        throw new ArgumentNullException(nameof(openParenToken));
      switch (openParenToken.Kind)
      {
        case SyntaxKind.OpenParenToken:
          break;
        default:
          throw new ArgumentException("openParenToken");
      }
      if (closeParenToken == null)
        throw new ArgumentNullException(nameof(closeParenToken));
      switch (closeParenToken.Kind)
      {
        case SyntaxKind.CloseParenToken:
          break;
        default:
          throw new ArgumentException("closeParenToken");
      }
#endif

      int hash;
      var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.ParameterList, openParenToken, parameters.Node, closeParenToken, out hash);
      if (cached != null) return (ParameterListSyntax)cached;

      var result = new ParameterListSyntax(SyntaxKind.ParameterList, openParenToken, parameters.Node, closeParenToken);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public static BracketedParameterListSyntax BracketedParameterList(SyntaxToken openBracketToken, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<ParameterSyntax> parameters, SyntaxToken closeBracketToken)
    {
#if DEBUG
      if (openBracketToken == null)
        throw new ArgumentNullException(nameof(openBracketToken));
      switch (openBracketToken.Kind)
      {
        case SyntaxKind.OpenBracketToken:
          break;
        default:
          throw new ArgumentException("openBracketToken");
      }
      if (closeBracketToken == null)
        throw new ArgumentNullException(nameof(closeBracketToken));
      switch (closeBracketToken.Kind)
      {
        case SyntaxKind.CloseBracketToken:
          break;
        default:
          throw new ArgumentException("closeBracketToken");
      }
#endif

      int hash;
      var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.BracketedParameterList, openBracketToken, parameters.Node, closeBracketToken, out hash);
      if (cached != null) return (BracketedParameterListSyntax)cached;

      var result = new BracketedParameterListSyntax(SyntaxKind.BracketedParameterList, openBracketToken, parameters.Node, closeBracketToken);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public static ParameterSyntax Parameter(Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<AttributeListSyntax> attributeLists, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SyntaxToken> modifiers, TypeSyntax type, SyntaxToken identifier, EqualsValueClauseSyntax @default)
    {
#if DEBUG
      if (identifier == null)
        throw new ArgumentNullException(nameof(identifier));
      switch (identifier.Kind)
      {
        case SyntaxKind.IdentifierToken:
        case SyntaxKind.ArgListKeyword:
          break;
        default:
          throw new ArgumentException("identifier");
      }
#endif

      return new ParameterSyntax(SyntaxKind.Parameter, attributeLists.Node, modifiers.Node, type, identifier, @default);
    }

    public static IncompleteMemberSyntax IncompleteMember(Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<AttributeListSyntax> attributeLists, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SyntaxToken> modifiers, TypeSyntax type)
    {
#if DEBUG
#endif

      return new IncompleteMemberSyntax(SyntaxKind.IncompleteMember, attributeLists.Node, modifiers.Node, type);
    }

    public static SkippedTokensTriviaSyntax SkippedTokensTrivia(Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SyntaxToken> tokens)
    {
#if DEBUG
#endif

      return new SkippedTokensTriviaSyntax(SyntaxKind.SkippedTokensTrivia, tokens.Node);
    }

    public static DocumentationCommentTriviaSyntax DocumentationCommentTrivia(SyntaxKind kind, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<XmlNodeSyntax> content, SyntaxToken endOfComment)
    {
      switch (kind)
      {
        case SyntaxKind.SingleLineDocumentationCommentTrivia:
        case SyntaxKind.MultiLineDocumentationCommentTrivia:
          break;
        default:
          throw new ArgumentException("kind");
      }
#if DEBUG
      if (endOfComment == null)
        throw new ArgumentNullException(nameof(endOfComment));
      switch (endOfComment.Kind)
      {
        case SyntaxKind.EndOfDocumentationCommentToken:
          break;
        default:
          throw new ArgumentException("endOfComment");
      }
#endif

      return new DocumentationCommentTriviaSyntax(kind, content.Node, endOfComment);
    }

    public static TypeCrefSyntax TypeCref(TypeSyntax type)
    {
#if DEBUG
      if (type == null)
        throw new ArgumentNullException(nameof(type));
#endif

      int hash;
      var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.TypeCref, type, out hash);
      if (cached != null) return (TypeCrefSyntax)cached;

      var result = new TypeCrefSyntax(SyntaxKind.TypeCref, type);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public static QualifiedCrefSyntax QualifiedCref(TypeSyntax container, SyntaxToken dotToken, MemberCrefSyntax member)
    {
#if DEBUG
      if (container == null)
        throw new ArgumentNullException(nameof(container));
      if (dotToken == null)
        throw new ArgumentNullException(nameof(dotToken));
      switch (dotToken.Kind)
      {
        case SyntaxKind.DotToken:
          break;
        default:
          throw new ArgumentException("dotToken");
      }
      if (member == null)
        throw new ArgumentNullException(nameof(member));
#endif

      int hash;
      var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.QualifiedCref, container, dotToken, member, out hash);
      if (cached != null) return (QualifiedCrefSyntax)cached;

      var result = new QualifiedCrefSyntax(SyntaxKind.QualifiedCref, container, dotToken, member);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public static NameMemberCrefSyntax NameMemberCref(TypeSyntax name, CrefParameterListSyntax parameters)
    {
#if DEBUG
      if (name == null)
        throw new ArgumentNullException(nameof(name));
#endif

      int hash;
      var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.NameMemberCref, name, parameters, out hash);
      if (cached != null) return (NameMemberCrefSyntax)cached;

      var result = new NameMemberCrefSyntax(SyntaxKind.NameMemberCref, name, parameters);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public static IndexerMemberCrefSyntax IndexerMemberCref(SyntaxToken thisKeyword, CrefBracketedParameterListSyntax parameters)
    {
#if DEBUG
      if (thisKeyword == null)
        throw new ArgumentNullException(nameof(thisKeyword));
      switch (thisKeyword.Kind)
      {
        case SyntaxKind.ThisKeyword:
          break;
        default:
          throw new ArgumentException("thisKeyword");
      }
#endif

      int hash;
      var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.IndexerMemberCref, thisKeyword, parameters, out hash);
      if (cached != null) return (IndexerMemberCrefSyntax)cached;

      var result = new IndexerMemberCrefSyntax(SyntaxKind.IndexerMemberCref, thisKeyword, parameters);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public static OperatorMemberCrefSyntax OperatorMemberCref(SyntaxToken operatorKeyword, SyntaxToken operatorToken, CrefParameterListSyntax parameters)
    {
#if DEBUG
      if (operatorKeyword == null)
        throw new ArgumentNullException(nameof(operatorKeyword));
      switch (operatorKeyword.Kind)
      {
        case SyntaxKind.OperatorKeyword:
          break;
        default:
          throw new ArgumentException("operatorKeyword");
      }
      if (operatorToken == null)
        throw new ArgumentNullException(nameof(operatorToken));
      switch (operatorToken.Kind)
      {
        case SyntaxKind.PlusToken:
        case SyntaxKind.MinusToken:
        case SyntaxKind.ExclamationToken:
        case SyntaxKind.TildeToken:
        case SyntaxKind.PlusPlusToken:
        case SyntaxKind.MinusMinusToken:
        case SyntaxKind.AsteriskToken:
        case SyntaxKind.SlashToken:
        case SyntaxKind.PercentToken:
        case SyntaxKind.LessThanLessThanToken:
        case SyntaxKind.GreaterThanGreaterThanToken:
        case SyntaxKind.BarToken:
        case SyntaxKind.AmpersandToken:
        case SyntaxKind.CaretToken:
        case SyntaxKind.EqualsEqualsToken:
        case SyntaxKind.ExclamationEqualsToken:
        case SyntaxKind.LessThanToken:
        case SyntaxKind.LessThanEqualsToken:
        case SyntaxKind.GreaterThanToken:
        case SyntaxKind.GreaterThanEqualsToken:
        case SyntaxKind.FalseKeyword:
        case SyntaxKind.TrueKeyword:
          break;
        default:
          throw new ArgumentException("operatorToken");
      }
#endif

      int hash;
      var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.OperatorMemberCref, operatorKeyword, operatorToken, parameters, out hash);
      if (cached != null) return (OperatorMemberCrefSyntax)cached;

      var result = new OperatorMemberCrefSyntax(SyntaxKind.OperatorMemberCref, operatorKeyword, operatorToken, parameters);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public static ConversionOperatorMemberCrefSyntax ConversionOperatorMemberCref(SyntaxToken implicitOrExplicitKeyword, SyntaxToken operatorKeyword, TypeSyntax type, CrefParameterListSyntax parameters)
    {
#if DEBUG
      if (implicitOrExplicitKeyword == null)
        throw new ArgumentNullException(nameof(implicitOrExplicitKeyword));
      switch (implicitOrExplicitKeyword.Kind)
      {
        case SyntaxKind.ImplicitKeyword:
        case SyntaxKind.ExplicitKeyword:
          break;
        default:
          throw new ArgumentException("implicitOrExplicitKeyword");
      }
      if (operatorKeyword == null)
        throw new ArgumentNullException(nameof(operatorKeyword));
      switch (operatorKeyword.Kind)
      {
        case SyntaxKind.OperatorKeyword:
          break;
        default:
          throw new ArgumentException("operatorKeyword");
      }
      if (type == null)
        throw new ArgumentNullException(nameof(type));
#endif

      return new ConversionOperatorMemberCrefSyntax(SyntaxKind.ConversionOperatorMemberCref, implicitOrExplicitKeyword, operatorKeyword, type, parameters);
    }

    public static CrefParameterListSyntax CrefParameterList(SyntaxToken openParenToken, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<CrefParameterSyntax> parameters, SyntaxToken closeParenToken)
    {
#if DEBUG
      if (openParenToken == null)
        throw new ArgumentNullException(nameof(openParenToken));
      switch (openParenToken.Kind)
      {
        case SyntaxKind.OpenParenToken:
          break;
        default:
          throw new ArgumentException("openParenToken");
      }
      if (closeParenToken == null)
        throw new ArgumentNullException(nameof(closeParenToken));
      switch (closeParenToken.Kind)
      {
        case SyntaxKind.CloseParenToken:
          break;
        default:
          throw new ArgumentException("closeParenToken");
      }
#endif

      int hash;
      var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.CrefParameterList, openParenToken, parameters.Node, closeParenToken, out hash);
      if (cached != null) return (CrefParameterListSyntax)cached;

      var result = new CrefParameterListSyntax(SyntaxKind.CrefParameterList, openParenToken, parameters.Node, closeParenToken);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public static CrefBracketedParameterListSyntax CrefBracketedParameterList(SyntaxToken openBracketToken, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<CrefParameterSyntax> parameters, SyntaxToken closeBracketToken)
    {
#if DEBUG
      if (openBracketToken == null)
        throw new ArgumentNullException(nameof(openBracketToken));
      switch (openBracketToken.Kind)
      {
        case SyntaxKind.OpenBracketToken:
          break;
        default:
          throw new ArgumentException("openBracketToken");
      }
      if (closeBracketToken == null)
        throw new ArgumentNullException(nameof(closeBracketToken));
      switch (closeBracketToken.Kind)
      {
        case SyntaxKind.CloseBracketToken:
          break;
        default:
          throw new ArgumentException("closeBracketToken");
      }
#endif

      int hash;
      var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.CrefBracketedParameterList, openBracketToken, parameters.Node, closeBracketToken, out hash);
      if (cached != null) return (CrefBracketedParameterListSyntax)cached;

      var result = new CrefBracketedParameterListSyntax(SyntaxKind.CrefBracketedParameterList, openBracketToken, parameters.Node, closeBracketToken);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public static CrefParameterSyntax CrefParameter(SyntaxToken refOrOutKeyword, TypeSyntax type)
    {
#if DEBUG
      if (refOrOutKeyword != null)
      {
      switch (refOrOutKeyword.Kind)
      {
        case SyntaxKind.RefKeyword:
        case SyntaxKind.OutKeyword:
        case SyntaxKind.None:
          break;
        default:
          throw new ArgumentException("refOrOutKeyword");
      }
      }
      if (type == null)
        throw new ArgumentNullException(nameof(type));
#endif

      int hash;
      var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.CrefParameter, refOrOutKeyword, type, out hash);
      if (cached != null) return (CrefParameterSyntax)cached;

      var result = new CrefParameterSyntax(SyntaxKind.CrefParameter, refOrOutKeyword, type);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public static XmlElementSyntax XmlElement(XmlElementStartTagSyntax startTag, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<XmlNodeSyntax> content, XmlElementEndTagSyntax endTag)
    {
#if DEBUG
      if (startTag == null)
        throw new ArgumentNullException(nameof(startTag));
      if (endTag == null)
        throw new ArgumentNullException(nameof(endTag));
#endif

      int hash;
      var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.XmlElement, startTag, content.Node, endTag, out hash);
      if (cached != null) return (XmlElementSyntax)cached;

      var result = new XmlElementSyntax(SyntaxKind.XmlElement, startTag, content.Node, endTag);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public static XmlElementStartTagSyntax XmlElementStartTag(SyntaxToken lessThanToken, XmlNameSyntax name, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<XmlAttributeSyntax> attributes, SyntaxToken greaterThanToken)
    {
#if DEBUG
      if (lessThanToken == null)
        throw new ArgumentNullException(nameof(lessThanToken));
      switch (lessThanToken.Kind)
      {
        case SyntaxKind.LessThanToken:
          break;
        default:
          throw new ArgumentException("lessThanToken");
      }
      if (name == null)
        throw new ArgumentNullException(nameof(name));
      if (greaterThanToken == null)
        throw new ArgumentNullException(nameof(greaterThanToken));
      switch (greaterThanToken.Kind)
      {
        case SyntaxKind.GreaterThanToken:
          break;
        default:
          throw new ArgumentException("greaterThanToken");
      }
#endif

      return new XmlElementStartTagSyntax(SyntaxKind.XmlElementStartTag, lessThanToken, name, attributes.Node, greaterThanToken);
    }

    public static XmlElementEndTagSyntax XmlElementEndTag(SyntaxToken lessThanSlashToken, XmlNameSyntax name, SyntaxToken greaterThanToken)
    {
#if DEBUG
      if (lessThanSlashToken == null)
        throw new ArgumentNullException(nameof(lessThanSlashToken));
      switch (lessThanSlashToken.Kind)
      {
        case SyntaxKind.LessThanSlashToken:
          break;
        default:
          throw new ArgumentException("lessThanSlashToken");
      }
      if (name == null)
        throw new ArgumentNullException(nameof(name));
      if (greaterThanToken == null)
        throw new ArgumentNullException(nameof(greaterThanToken));
      switch (greaterThanToken.Kind)
      {
        case SyntaxKind.GreaterThanToken:
          break;
        default:
          throw new ArgumentException("greaterThanToken");
      }
#endif

      int hash;
      var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.XmlElementEndTag, lessThanSlashToken, name, greaterThanToken, out hash);
      if (cached != null) return (XmlElementEndTagSyntax)cached;

      var result = new XmlElementEndTagSyntax(SyntaxKind.XmlElementEndTag, lessThanSlashToken, name, greaterThanToken);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public static XmlEmptyElementSyntax XmlEmptyElement(SyntaxToken lessThanToken, XmlNameSyntax name, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<XmlAttributeSyntax> attributes, SyntaxToken slashGreaterThanToken)
    {
#if DEBUG
      if (lessThanToken == null)
        throw new ArgumentNullException(nameof(lessThanToken));
      switch (lessThanToken.Kind)
      {
        case SyntaxKind.LessThanToken:
          break;
        default:
          throw new ArgumentException("lessThanToken");
      }
      if (name == null)
        throw new ArgumentNullException(nameof(name));
      if (slashGreaterThanToken == null)
        throw new ArgumentNullException(nameof(slashGreaterThanToken));
      switch (slashGreaterThanToken.Kind)
      {
        case SyntaxKind.SlashGreaterThanToken:
          break;
        default:
          throw new ArgumentException("slashGreaterThanToken");
      }
#endif

      return new XmlEmptyElementSyntax(SyntaxKind.XmlEmptyElement, lessThanToken, name, attributes.Node, slashGreaterThanToken);
    }

    public static XmlNameSyntax XmlName(XmlPrefixSyntax prefix, SyntaxToken localName)
    {
#if DEBUG
      if (localName == null)
        throw new ArgumentNullException(nameof(localName));
      switch (localName.Kind)
      {
        case SyntaxKind.IdentifierToken:
          break;
        default:
          throw new ArgumentException("localName");
      }
#endif

      int hash;
      var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.XmlName, prefix, localName, out hash);
      if (cached != null) return (XmlNameSyntax)cached;

      var result = new XmlNameSyntax(SyntaxKind.XmlName, prefix, localName);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public static XmlPrefixSyntax XmlPrefix(SyntaxToken prefix, SyntaxToken colonToken)
    {
#if DEBUG
      if (prefix == null)
        throw new ArgumentNullException(nameof(prefix));
      switch (prefix.Kind)
      {
        case SyntaxKind.IdentifierToken:
          break;
        default:
          throw new ArgumentException("prefix");
      }
      if (colonToken == null)
        throw new ArgumentNullException(nameof(colonToken));
      switch (colonToken.Kind)
      {
        case SyntaxKind.ColonToken:
          break;
        default:
          throw new ArgumentException("colonToken");
      }
#endif

      int hash;
      var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.XmlPrefix, prefix, colonToken, out hash);
      if (cached != null) return (XmlPrefixSyntax)cached;

      var result = new XmlPrefixSyntax(SyntaxKind.XmlPrefix, prefix, colonToken);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public static XmlTextAttributeSyntax XmlTextAttribute(XmlNameSyntax name, SyntaxToken equalsToken, SyntaxToken startQuoteToken, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SyntaxToken> textTokens, SyntaxToken endQuoteToken)
    {
#if DEBUG
      if (name == null)
        throw new ArgumentNullException(nameof(name));
      if (equalsToken == null)
        throw new ArgumentNullException(nameof(equalsToken));
      switch (equalsToken.Kind)
      {
        case SyntaxKind.EqualsToken:
          break;
        default:
          throw new ArgumentException("equalsToken");
      }
      if (startQuoteToken == null)
        throw new ArgumentNullException(nameof(startQuoteToken));
      switch (startQuoteToken.Kind)
      {
        case SyntaxKind.SingleQuoteToken:
        case SyntaxKind.DoubleQuoteToken:
          break;
        default:
          throw new ArgumentException("startQuoteToken");
      }
      if (endQuoteToken == null)
        throw new ArgumentNullException(nameof(endQuoteToken));
      switch (endQuoteToken.Kind)
      {
        case SyntaxKind.SingleQuoteToken:
        case SyntaxKind.DoubleQuoteToken:
          break;
        default:
          throw new ArgumentException("endQuoteToken");
      }
#endif

      return new XmlTextAttributeSyntax(SyntaxKind.XmlTextAttribute, name, equalsToken, startQuoteToken, textTokens.Node, endQuoteToken);
    }

    public static XmlCrefAttributeSyntax XmlCrefAttribute(XmlNameSyntax name, SyntaxToken equalsToken, SyntaxToken startQuoteToken, CrefSyntax cref, SyntaxToken endQuoteToken)
    {
#if DEBUG
      if (name == null)
        throw new ArgumentNullException(nameof(name));
      if (equalsToken == null)
        throw new ArgumentNullException(nameof(equalsToken));
      switch (equalsToken.Kind)
      {
        case SyntaxKind.EqualsToken:
          break;
        default:
          throw new ArgumentException("equalsToken");
      }
      if (startQuoteToken == null)
        throw new ArgumentNullException(nameof(startQuoteToken));
      switch (startQuoteToken.Kind)
      {
        case SyntaxKind.SingleQuoteToken:
        case SyntaxKind.DoubleQuoteToken:
          break;
        default:
          throw new ArgumentException("startQuoteToken");
      }
      if (cref == null)
        throw new ArgumentNullException(nameof(cref));
      if (endQuoteToken == null)
        throw new ArgumentNullException(nameof(endQuoteToken));
      switch (endQuoteToken.Kind)
      {
        case SyntaxKind.SingleQuoteToken:
        case SyntaxKind.DoubleQuoteToken:
          break;
        default:
          throw new ArgumentException("endQuoteToken");
      }
#endif

      return new XmlCrefAttributeSyntax(SyntaxKind.XmlCrefAttribute, name, equalsToken, startQuoteToken, cref, endQuoteToken);
    }

    public static XmlNameAttributeSyntax XmlNameAttribute(XmlNameSyntax name, SyntaxToken equalsToken, SyntaxToken startQuoteToken, IdentifierNameSyntax identifier, SyntaxToken endQuoteToken)
    {
#if DEBUG
      if (name == null)
        throw new ArgumentNullException(nameof(name));
      if (equalsToken == null)
        throw new ArgumentNullException(nameof(equalsToken));
      switch (equalsToken.Kind)
      {
        case SyntaxKind.EqualsToken:
          break;
        default:
          throw new ArgumentException("equalsToken");
      }
      if (startQuoteToken == null)
        throw new ArgumentNullException(nameof(startQuoteToken));
      switch (startQuoteToken.Kind)
      {
        case SyntaxKind.SingleQuoteToken:
        case SyntaxKind.DoubleQuoteToken:
          break;
        default:
          throw new ArgumentException("startQuoteToken");
      }
      if (identifier == null)
        throw new ArgumentNullException(nameof(identifier));
      if (endQuoteToken == null)
        throw new ArgumentNullException(nameof(endQuoteToken));
      switch (endQuoteToken.Kind)
      {
        case SyntaxKind.SingleQuoteToken:
        case SyntaxKind.DoubleQuoteToken:
          break;
        default:
          throw new ArgumentException("endQuoteToken");
      }
#endif

      return new XmlNameAttributeSyntax(SyntaxKind.XmlNameAttribute, name, equalsToken, startQuoteToken, identifier, endQuoteToken);
    }

    public static XmlTextSyntax XmlText(Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SyntaxToken> textTokens)
    {
#if DEBUG
#endif

      int hash;
      var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.XmlText, textTokens.Node, out hash);
      if (cached != null) return (XmlTextSyntax)cached;

      var result = new XmlTextSyntax(SyntaxKind.XmlText, textTokens.Node);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public static XmlCDataSectionSyntax XmlCDataSection(SyntaxToken startCDataToken, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SyntaxToken> textTokens, SyntaxToken endCDataToken)
    {
#if DEBUG
      if (startCDataToken == null)
        throw new ArgumentNullException(nameof(startCDataToken));
      switch (startCDataToken.Kind)
      {
        case SyntaxKind.XmlCDataStartToken:
          break;
        default:
          throw new ArgumentException("startCDataToken");
      }
      if (endCDataToken == null)
        throw new ArgumentNullException(nameof(endCDataToken));
      switch (endCDataToken.Kind)
      {
        case SyntaxKind.XmlCDataEndToken:
          break;
        default:
          throw new ArgumentException("endCDataToken");
      }
#endif

      int hash;
      var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.XmlCDataSection, startCDataToken, textTokens.Node, endCDataToken, out hash);
      if (cached != null) return (XmlCDataSectionSyntax)cached;

      var result = new XmlCDataSectionSyntax(SyntaxKind.XmlCDataSection, startCDataToken, textTokens.Node, endCDataToken);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public static XmlProcessingInstructionSyntax XmlProcessingInstruction(SyntaxToken startProcessingInstructionToken, XmlNameSyntax name, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SyntaxToken> textTokens, SyntaxToken endProcessingInstructionToken)
    {
#if DEBUG
      if (startProcessingInstructionToken == null)
        throw new ArgumentNullException(nameof(startProcessingInstructionToken));
      switch (startProcessingInstructionToken.Kind)
      {
        case SyntaxKind.XmlProcessingInstructionStartToken:
          break;
        default:
          throw new ArgumentException("startProcessingInstructionToken");
      }
      if (name == null)
        throw new ArgumentNullException(nameof(name));
      if (endProcessingInstructionToken == null)
        throw new ArgumentNullException(nameof(endProcessingInstructionToken));
      switch (endProcessingInstructionToken.Kind)
      {
        case SyntaxKind.XmlProcessingInstructionEndToken:
          break;
        default:
          throw new ArgumentException("endProcessingInstructionToken");
      }
#endif

      return new XmlProcessingInstructionSyntax(SyntaxKind.XmlProcessingInstruction, startProcessingInstructionToken, name, textTokens.Node, endProcessingInstructionToken);
    }

    public static XmlCommentSyntax XmlComment(SyntaxToken lessThanExclamationMinusMinusToken, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList<SyntaxToken> textTokens, SyntaxToken minusMinusGreaterThanToken)
    {
#if DEBUG
      if (lessThanExclamationMinusMinusToken == null)
        throw new ArgumentNullException(nameof(lessThanExclamationMinusMinusToken));
      switch (lessThanExclamationMinusMinusToken.Kind)
      {
        case SyntaxKind.XmlCommentStartToken:
          break;
        default:
          throw new ArgumentException("lessThanExclamationMinusMinusToken");
      }
      if (minusMinusGreaterThanToken == null)
        throw new ArgumentNullException(nameof(minusMinusGreaterThanToken));
      switch (minusMinusGreaterThanToken.Kind)
      {
        case SyntaxKind.XmlCommentEndToken:
          break;
        default:
          throw new ArgumentException("minusMinusGreaterThanToken");
      }
#endif

      int hash;
      var cached = SyntaxNodeCache.TryGetNode((int)SyntaxKind.XmlComment, lessThanExclamationMinusMinusToken, textTokens.Node, minusMinusGreaterThanToken, out hash);
      if (cached != null) return (XmlCommentSyntax)cached;

      var result = new XmlCommentSyntax(SyntaxKind.XmlComment, lessThanExclamationMinusMinusToken, textTokens.Node, minusMinusGreaterThanToken);
      if (hash >= 0)
      {
          SyntaxNodeCache.AddNode(result, hash);
      }

      return result;
    }

    public static IfDirectiveTriviaSyntax IfDirectiveTrivia(SyntaxToken hashToken, SyntaxToken ifKeyword, ExpressionSyntax condition, SyntaxToken endOfDirectiveToken, bool isActive, bool branchTaken, bool conditionValue)
    {
#if DEBUG
      if (hashToken == null)
        throw new ArgumentNullException(nameof(hashToken));
      switch (hashToken.Kind)
      {
        case SyntaxKind.HashToken:
          break;
        default:
          throw new ArgumentException("hashToken");
      }
      if (ifKeyword == null)
        throw new ArgumentNullException(nameof(ifKeyword));
      switch (ifKeyword.Kind)
      {
        case SyntaxKind.IfKeyword:
          break;
        default:
          throw new ArgumentException("ifKeyword");
      }
      if (condition == null)
        throw new ArgumentNullException(nameof(condition));
      if (endOfDirectiveToken == null)
        throw new ArgumentNullException(nameof(endOfDirectiveToken));
      switch (endOfDirectiveToken.Kind)
      {
        case SyntaxKind.EndOfDirectiveToken:
          break;
        default:
          throw new ArgumentException("endOfDirectiveToken");
      }
#endif

      return new IfDirectiveTriviaSyntax(SyntaxKind.IfDirectiveTrivia, hashToken, ifKeyword, condition, endOfDirectiveToken, isActive, branchTaken, conditionValue);
    }

    public static ElifDirectiveTriviaSyntax ElifDirectiveTrivia(SyntaxToken hashToken, SyntaxToken elifKeyword, ExpressionSyntax condition, SyntaxToken endOfDirectiveToken, bool isActive, bool branchTaken, bool conditionValue)
    {
#if DEBUG
      if (hashToken == null)
        throw new ArgumentNullException(nameof(hashToken));
      switch (hashToken.Kind)
      {
        case SyntaxKind.HashToken:
          break;
        default:
          throw new ArgumentException("hashToken");
      }
      if (elifKeyword == null)
        throw new ArgumentNullException(nameof(elifKeyword));
      switch (elifKeyword.Kind)
      {
        case SyntaxKind.ElifKeyword:
          break;
        default:
          throw new ArgumentException("elifKeyword");
      }
      if (condition == null)
        throw new ArgumentNullException(nameof(condition));
      if (endOfDirectiveToken == null)
        throw new ArgumentNullException(nameof(endOfDirectiveToken));
      switch (endOfDirectiveToken.Kind)
      {
        case SyntaxKind.EndOfDirectiveToken:
          break;
        default:
          throw new ArgumentException("endOfDirectiveToken");
      }
#endif

      return new ElifDirectiveTriviaSyntax(SyntaxKind.ElifDirectiveTrivia, hashToken, elifKeyword, condition, endOfDirectiveToken, isActive, branchTaken, conditionValue);
    }

    public static ElseDirectiveTriviaSyntax ElseDirectiveTrivia(SyntaxToken hashToken, SyntaxToken elseKeyword, SyntaxToken endOfDirectiveToken, bool isActive, bool branchTaken)
    {
#if DEBUG
      if (hashToken == null)
        throw new ArgumentNullException(nameof(hashToken));
      switch (hashToken.Kind)
      {
        case SyntaxKind.HashToken:
          break;
        default:
          throw new ArgumentException("hashToken");
      }
      if (elseKeyword == null)
        throw new ArgumentNullException(nameof(elseKeyword));
      switch (elseKeyword.Kind)
      {
        case SyntaxKind.ElseKeyword:
          break;
        default:
          throw new ArgumentException("elseKeyword");
      }
      if (endOfDirectiveToken == null)
        throw new ArgumentNullException(nameof(endOfDirectiveToken));
      switch (endOfDirectiveToken.Kind)
      {
        case SyntaxKind.EndOfDirectiveToken:
          break;
        default:
          throw new ArgumentException("endOfDirectiveToken");
      }
#endif

      return new ElseDirectiveTriviaSyntax(SyntaxKind.ElseDirectiveTrivia, hashToken, elseKeyword, endOfDirectiveToken, isActive, branchTaken);
    }

    public static EndIfDirectiveTriviaSyntax EndIfDirectiveTrivia(SyntaxToken hashToken, SyntaxToken endIfKeyword, SyntaxToken endOfDirectiveToken, bool isActive)
    {
#if DEBUG
      if (hashToken == null)
        throw new ArgumentNullException(nameof(hashToken));
      switch (hashToken.Kind)
      {
        case SyntaxKind.HashToken:
          break;
        default:
          throw new ArgumentException("hashToken");
      }
      if (endIfKeyword == null)
        throw new ArgumentNullException(nameof(endIfKeyword));
      switch (endIfKeyword.Kind)
      {
        case SyntaxKind.EndIfKeyword:
          break;
        default:
          throw new ArgumentException("endIfKeyword");
      }
      if (endOfDirectiveToken == null)
        throw new ArgumentNullException(nameof(endOfDirectiveToken));
      switch (endOfDirectiveToken.Kind)
      {
        case SyntaxKind.EndOfDirectiveToken:
          break;
        default:
          throw new ArgumentException("endOfDirectiveToken");
      }
#endif

      return new EndIfDirectiveTriviaSyntax(SyntaxKind.EndIfDirectiveTrivia, hashToken, endIfKeyword, endOfDirectiveToken, isActive);
    }

    public static RegionDirectiveTriviaSyntax RegionDirectiveTrivia(SyntaxToken hashToken, SyntaxToken regionKeyword, SyntaxToken endOfDirectiveToken, bool isActive)
    {
#if DEBUG
      if (hashToken == null)
        throw new ArgumentNullException(nameof(hashToken));
      switch (hashToken.Kind)
      {
        case SyntaxKind.HashToken:
          break;
        default:
          throw new ArgumentException("hashToken");
      }
      if (regionKeyword == null)
        throw new ArgumentNullException(nameof(regionKeyword));
      switch (regionKeyword.Kind)
      {
        case SyntaxKind.RegionKeyword:
          break;
        default:
          throw new ArgumentException("regionKeyword");
      }
      if (endOfDirectiveToken == null)
        throw new ArgumentNullException(nameof(endOfDirectiveToken));
      switch (endOfDirectiveToken.Kind)
      {
        case SyntaxKind.EndOfDirectiveToken:
          break;
        default:
          throw new ArgumentException("endOfDirectiveToken");
      }
#endif

      return new RegionDirectiveTriviaSyntax(SyntaxKind.RegionDirectiveTrivia, hashToken, regionKeyword, endOfDirectiveToken, isActive);
    }

    public static EndRegionDirectiveTriviaSyntax EndRegionDirectiveTrivia(SyntaxToken hashToken, SyntaxToken endRegionKeyword, SyntaxToken endOfDirectiveToken, bool isActive)
    {
#if DEBUG
      if (hashToken == null)
        throw new ArgumentNullException(nameof(hashToken));
      switch (hashToken.Kind)
      {
        case SyntaxKind.HashToken:
          break;
        default:
          throw new ArgumentException("hashToken");
      }
      if (endRegionKeyword == null)
        throw new ArgumentNullException(nameof(endRegionKeyword));
      switch (endRegionKeyword.Kind)
      {
        case SyntaxKind.EndRegionKeyword:
          break;
        default:
          throw new ArgumentException("endRegionKeyword");
      }
      if (endOfDirectiveToken == null)
        throw new ArgumentNullException(nameof(endOfDirectiveToken));
      switch (endOfDirectiveToken.Kind)
      {
        case SyntaxKind.EndOfDirectiveToken:
          break;
        default:
          throw new ArgumentException("endOfDirectiveToken");
      }
#endif

      return new EndRegionDirectiveTriviaSyntax(SyntaxKind.EndRegionDirectiveTrivia, hashToken, endRegionKeyword, endOfDirectiveToken, isActive);
    }

    public static ErrorDirectiveTriviaSyntax ErrorDirectiveTrivia(SyntaxToken hashToken, SyntaxToken errorKeyword, SyntaxToken endOfDirectiveToken, bool isActive)
    {
#if DEBUG
      if (hashToken == null)
        throw new ArgumentNullException(nameof(hashToken));
      switch (hashToken.Kind)
      {
        case SyntaxKind.HashToken:
          break;
        default:
          throw new ArgumentException("hashToken");
      }
      if (errorKeyword == null)
        throw new ArgumentNullException(nameof(errorKeyword));
      switch (errorKeyword.Kind)
      {
        case SyntaxKind.ErrorKeyword:
          break;
        default:
          throw new ArgumentException("errorKeyword");
      }
      if (endOfDirectiveToken == null)
        throw new ArgumentNullException(nameof(endOfDirectiveToken));
      switch (endOfDirectiveToken.Kind)
      {
        case SyntaxKind.EndOfDirectiveToken:
          break;
        default:
          throw new ArgumentException("endOfDirectiveToken");
      }
#endif

      return new ErrorDirectiveTriviaSyntax(SyntaxKind.ErrorDirectiveTrivia, hashToken, errorKeyword, endOfDirectiveToken, isActive);
    }

    public static WarningDirectiveTriviaSyntax WarningDirectiveTrivia(SyntaxToken hashToken, SyntaxToken warningKeyword, SyntaxToken endOfDirectiveToken, bool isActive)
    {
#if DEBUG
      if (hashToken == null)
        throw new ArgumentNullException(nameof(hashToken));
      switch (hashToken.Kind)
      {
        case SyntaxKind.HashToken:
          break;
        default:
          throw new ArgumentException("hashToken");
      }
      if (warningKeyword == null)
        throw new ArgumentNullException(nameof(warningKeyword));
      switch (warningKeyword.Kind)
      {
        case SyntaxKind.WarningKeyword:
          break;
        default:
          throw new ArgumentException("warningKeyword");
      }
      if (endOfDirectiveToken == null)
        throw new ArgumentNullException(nameof(endOfDirectiveToken));
      switch (endOfDirectiveToken.Kind)
      {
        case SyntaxKind.EndOfDirectiveToken:
          break;
        default:
          throw new ArgumentException("endOfDirectiveToken");
      }
#endif

      return new WarningDirectiveTriviaSyntax(SyntaxKind.WarningDirectiveTrivia, hashToken, warningKeyword, endOfDirectiveToken, isActive);
    }

    public static BadDirectiveTriviaSyntax BadDirectiveTrivia(SyntaxToken hashToken, SyntaxToken identifier, SyntaxToken endOfDirectiveToken, bool isActive)
    {
#if DEBUG
      if (hashToken == null)
        throw new ArgumentNullException(nameof(hashToken));
      switch (hashToken.Kind)
      {
        case SyntaxKind.HashToken:
          break;
        default:
          throw new ArgumentException("hashToken");
      }
      if (identifier == null)
        throw new ArgumentNullException(nameof(identifier));
      if (endOfDirectiveToken == null)
        throw new ArgumentNullException(nameof(endOfDirectiveToken));
      switch (endOfDirectiveToken.Kind)
      {
        case SyntaxKind.EndOfDirectiveToken:
          break;
        default:
          throw new ArgumentException("endOfDirectiveToken");
      }
#endif

      return new BadDirectiveTriviaSyntax(SyntaxKind.BadDirectiveTrivia, hashToken, identifier, endOfDirectiveToken, isActive);
    }

    public static DefineDirectiveTriviaSyntax DefineDirectiveTrivia(SyntaxToken hashToken, SyntaxToken defineKeyword, SyntaxToken name, SyntaxToken endOfDirectiveToken, bool isActive)
    {
#if DEBUG
      if (hashToken == null)
        throw new ArgumentNullException(nameof(hashToken));
      switch (hashToken.Kind)
      {
        case SyntaxKind.HashToken:
          break;
        default:
          throw new ArgumentException("hashToken");
      }
      if (defineKeyword == null)
        throw new ArgumentNullException(nameof(defineKeyword));
      switch (defineKeyword.Kind)
      {
        case SyntaxKind.DefineKeyword:
          break;
        default:
          throw new ArgumentException("defineKeyword");
      }
      if (name == null)
        throw new ArgumentNullException(nameof(name));
      switch (name.Kind)
      {
        case SyntaxKind.IdentifierToken:
          break;
        default:
          throw new ArgumentException("name");
      }
      if (endOfDirectiveToken == null)
        throw new ArgumentNullException(nameof(endOfDirectiveToken));
      switch (endOfDirectiveToken.Kind)
      {
        case SyntaxKind.EndOfDirectiveToken:
          break;
        default:
          throw new ArgumentException("endOfDirectiveToken");
      }
#endif

      return new DefineDirectiveTriviaSyntax(SyntaxKind.DefineDirectiveTrivia, hashToken, defineKeyword, name, endOfDirectiveToken, isActive);
    }

    public static UndefDirectiveTriviaSyntax UndefDirectiveTrivia(SyntaxToken hashToken, SyntaxToken undefKeyword, SyntaxToken name, SyntaxToken endOfDirectiveToken, bool isActive)
    {
#if DEBUG
      if (hashToken == null)
        throw new ArgumentNullException(nameof(hashToken));
      switch (hashToken.Kind)
      {
        case SyntaxKind.HashToken:
          break;
        default:
          throw new ArgumentException("hashToken");
      }
      if (undefKeyword == null)
        throw new ArgumentNullException(nameof(undefKeyword));
      switch (undefKeyword.Kind)
      {
        case SyntaxKind.UndefKeyword:
          break;
        default:
          throw new ArgumentException("undefKeyword");
      }
      if (name == null)
        throw new ArgumentNullException(nameof(name));
      switch (name.Kind)
      {
        case SyntaxKind.IdentifierToken:
          break;
        default:
          throw new ArgumentException("name");
      }
      if (endOfDirectiveToken == null)
        throw new ArgumentNullException(nameof(endOfDirectiveToken));
      switch (endOfDirectiveToken.Kind)
      {
        case SyntaxKind.EndOfDirectiveToken:
          break;
        default:
          throw new ArgumentException("endOfDirectiveToken");
      }
#endif

      return new UndefDirectiveTriviaSyntax(SyntaxKind.UndefDirectiveTrivia, hashToken, undefKeyword, name, endOfDirectiveToken, isActive);
    }

    public static LineDirectiveTriviaSyntax LineDirectiveTrivia(SyntaxToken hashToken, SyntaxToken lineKeyword, SyntaxToken line, SyntaxToken file, SyntaxToken endOfDirectiveToken, bool isActive)
    {
#if DEBUG
      if (hashToken == null)
        throw new ArgumentNullException(nameof(hashToken));
      switch (hashToken.Kind)
      {
        case SyntaxKind.HashToken:
          break;
        default:
          throw new ArgumentException("hashToken");
      }
      if (lineKeyword == null)
        throw new ArgumentNullException(nameof(lineKeyword));
      switch (lineKeyword.Kind)
      {
        case SyntaxKind.LineKeyword:
          break;
        default:
          throw new ArgumentException("lineKeyword");
      }
      if (line == null)
        throw new ArgumentNullException(nameof(line));
      switch (line.Kind)
      {
        case SyntaxKind.NumericLiteralToken:
        case SyntaxKind.DefaultKeyword:
        case SyntaxKind.HiddenKeyword:
          break;
        default:
          throw new ArgumentException("line");
      }
      if (file != null)
      {
      switch (file.Kind)
      {
        case SyntaxKind.StringLiteralToken:
        case SyntaxKind.None:
          break;
        default:
          throw new ArgumentException("file");
      }
      }
      if (endOfDirectiveToken == null)
        throw new ArgumentNullException(nameof(endOfDirectiveToken));
      switch (endOfDirectiveToken.Kind)
      {
        case SyntaxKind.EndOfDirectiveToken:
          break;
        default:
          throw new ArgumentException("endOfDirectiveToken");
      }
#endif

      return new LineDirectiveTriviaSyntax(SyntaxKind.LineDirectiveTrivia, hashToken, lineKeyword, line, file, endOfDirectiveToken, isActive);
    }

    public static PragmaWarningDirectiveTriviaSyntax PragmaWarningDirectiveTrivia(SyntaxToken hashToken, SyntaxToken pragmaKeyword, SyntaxToken warningKeyword, SyntaxToken disableOrRestoreKeyword, Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList<ExpressionSyntax> errorCodes, SyntaxToken endOfDirectiveToken, bool isActive)
    {
#if DEBUG
      if (hashToken == null)
        throw new ArgumentNullException(nameof(hashToken));
      switch (hashToken.Kind)
      {
        case SyntaxKind.HashToken:
          break;
        default:
          throw new ArgumentException("hashToken");
      }
      if (pragmaKeyword == null)
        throw new ArgumentNullException(nameof(pragmaKeyword));
      switch (pragmaKeyword.Kind)
      {
        case SyntaxKind.PragmaKeyword:
          break;
        default:
          throw new ArgumentException("pragmaKeyword");
      }
      if (warningKeyword == null)
        throw new ArgumentNullException(nameof(warningKeyword));
      switch (warningKeyword.Kind)
      {
        case SyntaxKind.WarningKeyword:
          break;
        default:
          throw new ArgumentException("warningKeyword");
      }
      if (disableOrRestoreKeyword == null)
        throw new ArgumentNullException(nameof(disableOrRestoreKeyword));
      switch (disableOrRestoreKeyword.Kind)
      {
        case SyntaxKind.DisableKeyword:
        case SyntaxKind.RestoreKeyword:
          break;
        default:
          throw new ArgumentException("disableOrRestoreKeyword");
      }
      if (endOfDirectiveToken == null)
        throw new ArgumentNullException(nameof(endOfDirectiveToken));
      switch (endOfDirectiveToken.Kind)
      {
        case SyntaxKind.EndOfDirectiveToken:
          break;
        default:
          throw new ArgumentException("endOfDirectiveToken");
      }
#endif

      return new PragmaWarningDirectiveTriviaSyntax(SyntaxKind.PragmaWarningDirectiveTrivia, hashToken, pragmaKeyword, warningKeyword, disableOrRestoreKeyword, errorCodes.Node, endOfDirectiveToken, isActive);
    }

    public static PragmaChecksumDirectiveTriviaSyntax PragmaChecksumDirectiveTrivia(SyntaxToken hashToken, SyntaxToken pragmaKeyword, SyntaxToken checksumKeyword, SyntaxToken file, SyntaxToken guid, SyntaxToken bytes, SyntaxToken endOfDirectiveToken, bool isActive)
    {
#if DEBUG
      if (hashToken == null)
        throw new ArgumentNullException(nameof(hashToken));
      switch (hashToken.Kind)
      {
        case SyntaxKind.HashToken:
          break;
        default:
          throw new ArgumentException("hashToken");
      }
      if (pragmaKeyword == null)
        throw new ArgumentNullException(nameof(pragmaKeyword));
      switch (pragmaKeyword.Kind)
      {
        case SyntaxKind.PragmaKeyword:
          break;
        default:
          throw new ArgumentException("pragmaKeyword");
      }
      if (checksumKeyword == null)
        throw new ArgumentNullException(nameof(checksumKeyword));
      switch (checksumKeyword.Kind)
      {
        case SyntaxKind.ChecksumKeyword:
          break;
        default:
          throw new ArgumentException("checksumKeyword");
      }
      if (file == null)
        throw new ArgumentNullException(nameof(file));
      switch (file.Kind)
      {
        case SyntaxKind.StringLiteralToken:
          break;
        default:
          throw new ArgumentException("file");
      }
      if (guid == null)
        throw new ArgumentNullException(nameof(guid));
      switch (guid.Kind)
      {
        case SyntaxKind.StringLiteralToken:
          break;
        default:
          throw new ArgumentException("guid");
      }
      if (bytes == null)
        throw new ArgumentNullException(nameof(bytes));
      switch (bytes.Kind)
      {
        case SyntaxKind.StringLiteralToken:
          break;
        default:
          throw new ArgumentException("bytes");
      }
      if (endOfDirectiveToken == null)
        throw new ArgumentNullException(nameof(endOfDirectiveToken));
      switch (endOfDirectiveToken.Kind)
      {
        case SyntaxKind.EndOfDirectiveToken:
          break;
        default:
          throw new ArgumentException("endOfDirectiveToken");
      }
#endif

      return new PragmaChecksumDirectiveTriviaSyntax(SyntaxKind.PragmaChecksumDirectiveTrivia, hashToken, pragmaKeyword, checksumKeyword, file, guid, bytes, endOfDirectiveToken, isActive);
    }

    public static ReferenceDirectiveTriviaSyntax ReferenceDirectiveTrivia(SyntaxToken hashToken, SyntaxToken referenceKeyword, SyntaxToken file, SyntaxToken endOfDirectiveToken, bool isActive)
    {
#if DEBUG
      if (hashToken == null)
        throw new ArgumentNullException(nameof(hashToken));
      switch (hashToken.Kind)
      {
        case SyntaxKind.HashToken:
          break;
        default:
          throw new ArgumentException("hashToken");
      }
      if (referenceKeyword == null)
        throw new ArgumentNullException(nameof(referenceKeyword));
      switch (referenceKeyword.Kind)
      {
        case SyntaxKind.ReferenceKeyword:
          break;
        default:
          throw new ArgumentException("referenceKeyword");
      }
      if (file == null)
        throw new ArgumentNullException(nameof(file));
      switch (file.Kind)
      {
        case SyntaxKind.StringLiteralToken:
          break;
        default:
          throw new ArgumentException("file");
      }
      if (endOfDirectiveToken == null)
        throw new ArgumentNullException(nameof(endOfDirectiveToken));
      switch (endOfDirectiveToken.Kind)
      {
        case SyntaxKind.EndOfDirectiveToken:
          break;
        default:
          throw new ArgumentException("endOfDirectiveToken");
      }
#endif

      return new ReferenceDirectiveTriviaSyntax(SyntaxKind.ReferenceDirectiveTrivia, hashToken, referenceKeyword, file, endOfDirectiveToken, isActive);
    }

    public static LoadDirectiveTriviaSyntax LoadDirectiveTrivia(SyntaxToken hashToken, SyntaxToken loadKeyword, SyntaxToken file, SyntaxToken endOfDirectiveToken, bool isActive)
    {
#if DEBUG
      if (hashToken == null)
        throw new ArgumentNullException(nameof(hashToken));
      switch (hashToken.Kind)
      {
        case SyntaxKind.HashToken:
          break;
        default:
          throw new ArgumentException("hashToken");
      }
      if (loadKeyword == null)
        throw new ArgumentNullException(nameof(loadKeyword));
      switch (loadKeyword.Kind)
      {
        case SyntaxKind.LoadKeyword:
          break;
        default:
          throw new ArgumentException("loadKeyword");
      }
      if (file == null)
        throw new ArgumentNullException(nameof(file));
      switch (file.Kind)
      {
        case SyntaxKind.StringLiteralToken:
          break;
        default:
          throw new ArgumentException("file");
      }
      if (endOfDirectiveToken == null)
        throw new ArgumentNullException(nameof(endOfDirectiveToken));
      switch (endOfDirectiveToken.Kind)
      {
        case SyntaxKind.EndOfDirectiveToken:
          break;
        default:
          throw new ArgumentException("endOfDirectiveToken");
      }
#endif

      return new LoadDirectiveTriviaSyntax(SyntaxKind.LoadDirectiveTrivia, hashToken, loadKeyword, file, endOfDirectiveToken, isActive);
    }

    public static ShebangDirectiveTriviaSyntax ShebangDirectiveTrivia(SyntaxToken hashToken, SyntaxToken exclamationToken, SyntaxToken endOfDirectiveToken, bool isActive)
    {
#if DEBUG
      if (hashToken == null)
        throw new ArgumentNullException(nameof(hashToken));
      switch (hashToken.Kind)
      {
        case SyntaxKind.HashToken:
          break;
        default:
          throw new ArgumentException("hashToken");
      }
      if (exclamationToken == null)
        throw new ArgumentNullException(nameof(exclamationToken));
      switch (exclamationToken.Kind)
      {
        case SyntaxKind.ExclamationToken:
          break;
        default:
          throw new ArgumentException("exclamationToken");
      }
      if (endOfDirectiveToken == null)
        throw new ArgumentNullException(nameof(endOfDirectiveToken));
      switch (endOfDirectiveToken.Kind)
      {
        case SyntaxKind.EndOfDirectiveToken:
          break;
        default:
          throw new ArgumentException("endOfDirectiveToken");
      }
#endif

      return new ShebangDirectiveTriviaSyntax(SyntaxKind.ShebangDirectiveTrivia, hashToken, exclamationToken, endOfDirectiveToken, isActive);
    }

    internal static IEnumerable<Type> GetNodeTypes()
    {
        return new Type[] {
           typeof(IdentifierNameSyntax),
           typeof(QualifiedNameSyntax),
           typeof(GenericNameSyntax),
           typeof(TypeArgumentListSyntax),
           typeof(AliasQualifiedNameSyntax),
           typeof(PredefinedTypeSyntax),
           typeof(ArrayTypeSyntax),
           typeof(ArrayRankSpecifierSyntax),
           typeof(PointerTypeSyntax),
           typeof(NullableTypeSyntax),
           typeof(TupleTypeSyntax),
           typeof(TupleElementSyntax),
           typeof(OmittedTypeArgumentSyntax),
           typeof(RefTypeSyntax),
           typeof(ParenthesizedExpressionSyntax),
           typeof(TupleExpressionSyntax),
           typeof(PrefixUnaryExpressionSyntax),
           typeof(AwaitExpressionSyntax),
           typeof(PostfixUnaryExpressionSyntax),
           typeof(MemberAccessExpressionSyntax),
           typeof(ConditionalAccessExpressionSyntax),
           typeof(MemberBindingExpressionSyntax),
           typeof(ElementBindingExpressionSyntax),
           typeof(ImplicitElementAccessSyntax),
           typeof(BinaryExpressionSyntax),
           typeof(AssignmentExpressionSyntax),
           typeof(ConditionalExpressionSyntax),
           typeof(ThisExpressionSyntax),
           typeof(BaseExpressionSyntax),
           typeof(LiteralExpressionSyntax),
           typeof(MakeRefExpressionSyntax),
           typeof(RefTypeExpressionSyntax),
           typeof(RefValueExpressionSyntax),
           typeof(CheckedExpressionSyntax),
           typeof(DefaultExpressionSyntax),
           typeof(TypeOfExpressionSyntax),
           typeof(SizeOfExpressionSyntax),
           typeof(InvocationExpressionSyntax),
           typeof(ElementAccessExpressionSyntax),
           typeof(ArgumentListSyntax),
           typeof(BracketedArgumentListSyntax),
           typeof(ArgumentSyntax),
           typeof(NameColonSyntax),
           typeof(DeclarationExpressionSyntax),
           typeof(CastExpressionSyntax),
           typeof(AnonymousMethodExpressionSyntax),
           typeof(SimpleLambdaExpressionSyntax),
           typeof(RefExpressionSyntax),
           typeof(ParenthesizedLambdaExpressionSyntax),
           typeof(InitializerExpressionSyntax),
           typeof(ObjectCreationExpressionSyntax),
           typeof(AnonymousObjectMemberDeclaratorSyntax),
           typeof(AnonymousObjectCreationExpressionSyntax),
           typeof(ArrayCreationExpressionSyntax),
           typeof(ImplicitArrayCreationExpressionSyntax),
           typeof(StackAllocArrayCreationExpressionSyntax),
           typeof(QueryExpressionSyntax),
           typeof(QueryBodySyntax),
           typeof(FromClauseSyntax),
           typeof(LetClauseSyntax),
           typeof(JoinClauseSyntax),
           typeof(JoinIntoClauseSyntax),
           typeof(WhereClauseSyntax),
           typeof(OrderByClauseSyntax),
           typeof(OrderingSyntax),
           typeof(SelectClauseSyntax),
           typeof(GroupClauseSyntax),
           typeof(QueryContinuationSyntax),
           typeof(OmittedArraySizeExpressionSyntax),
           typeof(InterpolatedStringExpressionSyntax),
           typeof(IsPatternExpressionSyntax),
           typeof(ThrowExpressionSyntax),
           typeof(WhenClauseSyntax),
           typeof(DeclarationPatternSyntax),
           typeof(ConstantPatternSyntax),
           typeof(InterpolatedStringTextSyntax),
           typeof(InterpolationSyntax),
           typeof(InterpolationAlignmentClauseSyntax),
           typeof(InterpolationFormatClauseSyntax),
           typeof(GlobalStatementSyntax),
           typeof(BlockSyntax),
           typeof(LocalFunctionStatementSyntax),
           typeof(LocalDeclarationStatementSyntax),
           typeof(VariableDeclarationSyntax),
           typeof(VariableDeclaratorSyntax),
           typeof(EqualsValueClauseSyntax),
           typeof(SingleVariableDesignationSyntax),
           typeof(DiscardDesignationSyntax),
           typeof(ParenthesizedVariableDesignationSyntax),
           typeof(ExpressionStatementSyntax),
           typeof(EmptyStatementSyntax),
           typeof(LabeledStatementSyntax),
           typeof(GotoStatementSyntax),
           typeof(BreakStatementSyntax),
           typeof(ContinueStatementSyntax),
           typeof(ReturnStatementSyntax),
           typeof(ThrowStatementSyntax),
           typeof(YieldStatementSyntax),
           typeof(WhileStatementSyntax),
           typeof(DoStatementSyntax),
           typeof(ForStatementSyntax),
           typeof(ForEachStatementSyntax),
           typeof(ForEachVariableStatementSyntax),
           typeof(UsingStatementSyntax),
           typeof(FixedStatementSyntax),
           typeof(CheckedStatementSyntax),
           typeof(UnsafeStatementSyntax),
           typeof(LockStatementSyntax),
           typeof(IfStatementSyntax),
           typeof(ElseClauseSyntax),
           typeof(SwitchStatementSyntax),
           typeof(SwitchSectionSyntax),
           typeof(CasePatternSwitchLabelSyntax),
           typeof(CaseSwitchLabelSyntax),
           typeof(DefaultSwitchLabelSyntax),
           typeof(TryStatementSyntax),
           typeof(CatchClauseSyntax),
           typeof(CatchDeclarationSyntax),
           typeof(CatchFilterClauseSyntax),
           typeof(FinallyClauseSyntax),
           typeof(CompilationUnitSyntax),
           typeof(ExternAliasDirectiveSyntax),
           typeof(UsingDirectiveSyntax),
           typeof(NamespaceDeclarationSyntax),
           typeof(AttributeListSyntax),
           typeof(AttributeTargetSpecifierSyntax),
           typeof(AttributeSyntax),
           typeof(AttributeArgumentListSyntax),
           typeof(AttributeArgumentSyntax),
           typeof(NameEqualsSyntax),
           typeof(TypeParameterListSyntax),
           typeof(TypeParameterSyntax),
           typeof(ClassDeclarationSyntax),
           typeof(StructDeclarationSyntax),
           typeof(InterfaceDeclarationSyntax),
           typeof(EnumDeclarationSyntax),
           typeof(DelegateDeclarationSyntax),
           typeof(EnumMemberDeclarationSyntax),
           typeof(BaseListSyntax),
           typeof(SimpleBaseTypeSyntax),
           typeof(TypeParameterConstraintClauseSyntax),
           typeof(ConstructorConstraintSyntax),
           typeof(ClassOrStructConstraintSyntax),
           typeof(TypeConstraintSyntax),
           typeof(FieldDeclarationSyntax),
           typeof(EventFieldDeclarationSyntax),
           typeof(ExplicitInterfaceSpecifierSyntax),
           typeof(MethodDeclarationSyntax),
           typeof(OperatorDeclarationSyntax),
           typeof(ConversionOperatorDeclarationSyntax),
           typeof(ConstructorDeclarationSyntax),
           typeof(ConstructorInitializerSyntax),
           typeof(DestructorDeclarationSyntax),
           typeof(PropertyDeclarationSyntax),
           typeof(ArrowExpressionClauseSyntax),
           typeof(EventDeclarationSyntax),
           typeof(IndexerDeclarationSyntax),
           typeof(AccessorListSyntax),
           typeof(AccessorDeclarationSyntax),
           typeof(ParameterListSyntax),
           typeof(BracketedParameterListSyntax),
           typeof(ParameterSyntax),
           typeof(IncompleteMemberSyntax),
           typeof(SkippedTokensTriviaSyntax),
           typeof(DocumentationCommentTriviaSyntax),
           typeof(TypeCrefSyntax),
           typeof(QualifiedCrefSyntax),
           typeof(NameMemberCrefSyntax),
           typeof(IndexerMemberCrefSyntax),
           typeof(OperatorMemberCrefSyntax),
           typeof(ConversionOperatorMemberCrefSyntax),
           typeof(CrefParameterListSyntax),
           typeof(CrefBracketedParameterListSyntax),
           typeof(CrefParameterSyntax),
           typeof(XmlElementSyntax),
           typeof(XmlElementStartTagSyntax),
           typeof(XmlElementEndTagSyntax),
           typeof(XmlEmptyElementSyntax),
           typeof(XmlNameSyntax),
           typeof(XmlPrefixSyntax),
           typeof(XmlTextAttributeSyntax),
           typeof(XmlCrefAttributeSyntax),
           typeof(XmlNameAttributeSyntax),
           typeof(XmlTextSyntax),
           typeof(XmlCDataSectionSyntax),
           typeof(XmlProcessingInstructionSyntax),
           typeof(XmlCommentSyntax),
           typeof(IfDirectiveTriviaSyntax),
           typeof(ElifDirectiveTriviaSyntax),
           typeof(ElseDirectiveTriviaSyntax),
           typeof(EndIfDirectiveTriviaSyntax),
           typeof(RegionDirectiveTriviaSyntax),
           typeof(EndRegionDirectiveTriviaSyntax),
           typeof(ErrorDirectiveTriviaSyntax),
           typeof(WarningDirectiveTriviaSyntax),
           typeof(BadDirectiveTriviaSyntax),
           typeof(DefineDirectiveTriviaSyntax),
           typeof(UndefDirectiveTriviaSyntax),
           typeof(LineDirectiveTriviaSyntax),
           typeof(PragmaWarningDirectiveTriviaSyntax),
           typeof(PragmaChecksumDirectiveTriviaSyntax),
           typeof(ReferenceDirectiveTriviaSyntax),
           typeof(LoadDirectiveTriviaSyntax),
           typeof(ShebangDirectiveTriviaSyntax)
        };
    }
  }
}
