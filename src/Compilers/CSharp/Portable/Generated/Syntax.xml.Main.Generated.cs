// <auto-generated />

using System;
using System.Collections;
using System.Collections.Generic;
using System.Linq;
using System.Threading;
using Microsoft.CodeAnalysis.Syntax.InternalSyntax;
using Roslyn.Utilities;


namespace Microsoft.CodeAnalysis.CSharp
{
    using Microsoft.CodeAnalysis.CSharp.Syntax;


  public partial class CSharpSyntaxVisitor<TResult>
  {
    /// <summary>Called when the visitor visits a IdentifierNameSyntax node.</summary>
    public virtual TResult VisitIdentifierName(IdentifierNameSyntax node)
    {
      return this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a QualifiedNameSyntax node.</summary>
    public virtual TResult VisitQualifiedName(QualifiedNameSyntax node)
    {
      return this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a GenericNameSyntax node.</summary>
    public virtual TResult VisitGenericName(GenericNameSyntax node)
    {
      return this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a TypeArgumentListSyntax node.</summary>
    public virtual TResult VisitTypeArgumentList(TypeArgumentListSyntax node)
    {
      return this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a AliasQualifiedNameSyntax node.</summary>
    public virtual TResult VisitAliasQualifiedName(AliasQualifiedNameSyntax node)
    {
      return this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a PredefinedTypeSyntax node.</summary>
    public virtual TResult VisitPredefinedType(PredefinedTypeSyntax node)
    {
      return this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a ArrayTypeSyntax node.</summary>
    public virtual TResult VisitArrayType(ArrayTypeSyntax node)
    {
      return this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a ArrayRankSpecifierSyntax node.</summary>
    public virtual TResult VisitArrayRankSpecifier(ArrayRankSpecifierSyntax node)
    {
      return this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a PointerTypeSyntax node.</summary>
    public virtual TResult VisitPointerType(PointerTypeSyntax node)
    {
      return this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a NullableTypeSyntax node.</summary>
    public virtual TResult VisitNullableType(NullableTypeSyntax node)
    {
      return this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a TupleTypeSyntax node.</summary>
    public virtual TResult VisitTupleType(TupleTypeSyntax node)
    {
      return this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a TupleElementSyntax node.</summary>
    public virtual TResult VisitTupleElement(TupleElementSyntax node)
    {
      return this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a OmittedTypeArgumentSyntax node.</summary>
    public virtual TResult VisitOmittedTypeArgument(OmittedTypeArgumentSyntax node)
    {
      return this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a RefTypeSyntax node.</summary>
    public virtual TResult VisitRefType(RefTypeSyntax node)
    {
      return this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a ParenthesizedExpressionSyntax node.</summary>
    public virtual TResult VisitParenthesizedExpression(ParenthesizedExpressionSyntax node)
    {
      return this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a TupleExpressionSyntax node.</summary>
    public virtual TResult VisitTupleExpression(TupleExpressionSyntax node)
    {
      return this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a PrefixUnaryExpressionSyntax node.</summary>
    public virtual TResult VisitPrefixUnaryExpression(PrefixUnaryExpressionSyntax node)
    {
      return this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a AwaitExpressionSyntax node.</summary>
    public virtual TResult VisitAwaitExpression(AwaitExpressionSyntax node)
    {
      return this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a PostfixUnaryExpressionSyntax node.</summary>
    public virtual TResult VisitPostfixUnaryExpression(PostfixUnaryExpressionSyntax node)
    {
      return this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a MemberAccessExpressionSyntax node.</summary>
    public virtual TResult VisitMemberAccessExpression(MemberAccessExpressionSyntax node)
    {
      return this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a ConditionalAccessExpressionSyntax node.</summary>
    public virtual TResult VisitConditionalAccessExpression(ConditionalAccessExpressionSyntax node)
    {
      return this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a MemberBindingExpressionSyntax node.</summary>
    public virtual TResult VisitMemberBindingExpression(MemberBindingExpressionSyntax node)
    {
      return this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a ElementBindingExpressionSyntax node.</summary>
    public virtual TResult VisitElementBindingExpression(ElementBindingExpressionSyntax node)
    {
      return this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a RangeExpressionSyntax node.</summary>
    public virtual TResult VisitRangeExpression(RangeExpressionSyntax node)
    {
      return this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a ImplicitElementAccessSyntax node.</summary>
    public virtual TResult VisitImplicitElementAccess(ImplicitElementAccessSyntax node)
    {
      return this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a BinaryExpressionSyntax node.</summary>
    public virtual TResult VisitBinaryExpression(BinaryExpressionSyntax node)
    {
      return this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a AssignmentExpressionSyntax node.</summary>
    public virtual TResult VisitAssignmentExpression(AssignmentExpressionSyntax node)
    {
      return this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a ConditionalExpressionSyntax node.</summary>
    public virtual TResult VisitConditionalExpression(ConditionalExpressionSyntax node)
    {
      return this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a ThisExpressionSyntax node.</summary>
    public virtual TResult VisitThisExpression(ThisExpressionSyntax node)
    {
      return this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a BaseExpressionSyntax node.</summary>
    public virtual TResult VisitBaseExpression(BaseExpressionSyntax node)
    {
      return this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a LiteralExpressionSyntax node.</summary>
    public virtual TResult VisitLiteralExpression(LiteralExpressionSyntax node)
    {
      return this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a MakeRefExpressionSyntax node.</summary>
    public virtual TResult VisitMakeRefExpression(MakeRefExpressionSyntax node)
    {
      return this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a RefTypeExpressionSyntax node.</summary>
    public virtual TResult VisitRefTypeExpression(RefTypeExpressionSyntax node)
    {
      return this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a RefValueExpressionSyntax node.</summary>
    public virtual TResult VisitRefValueExpression(RefValueExpressionSyntax node)
    {
      return this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a CheckedExpressionSyntax node.</summary>
    public virtual TResult VisitCheckedExpression(CheckedExpressionSyntax node)
    {
      return this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a DefaultExpressionSyntax node.</summary>
    public virtual TResult VisitDefaultExpression(DefaultExpressionSyntax node)
    {
      return this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a TypeOfExpressionSyntax node.</summary>
    public virtual TResult VisitTypeOfExpression(TypeOfExpressionSyntax node)
    {
      return this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a SizeOfExpressionSyntax node.</summary>
    public virtual TResult VisitSizeOfExpression(SizeOfExpressionSyntax node)
    {
      return this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a InvocationExpressionSyntax node.</summary>
    public virtual TResult VisitInvocationExpression(InvocationExpressionSyntax node)
    {
      return this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a ElementAccessExpressionSyntax node.</summary>
    public virtual TResult VisitElementAccessExpression(ElementAccessExpressionSyntax node)
    {
      return this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a ArgumentListSyntax node.</summary>
    public virtual TResult VisitArgumentList(ArgumentListSyntax node)
    {
      return this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a BracketedArgumentListSyntax node.</summary>
    public virtual TResult VisitBracketedArgumentList(BracketedArgumentListSyntax node)
    {
      return this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a ArgumentSyntax node.</summary>
    public virtual TResult VisitArgument(ArgumentSyntax node)
    {
      return this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a NameColonSyntax node.</summary>
    public virtual TResult VisitNameColon(NameColonSyntax node)
    {
      return this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a DeclarationExpressionSyntax node.</summary>
    public virtual TResult VisitDeclarationExpression(DeclarationExpressionSyntax node)
    {
      return this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a CastExpressionSyntax node.</summary>
    public virtual TResult VisitCastExpression(CastExpressionSyntax node)
    {
      return this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a AnonymousMethodExpressionSyntax node.</summary>
    public virtual TResult VisitAnonymousMethodExpression(AnonymousMethodExpressionSyntax node)
    {
      return this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a SimpleLambdaExpressionSyntax node.</summary>
    public virtual TResult VisitSimpleLambdaExpression(SimpleLambdaExpressionSyntax node)
    {
      return this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a RefExpressionSyntax node.</summary>
    public virtual TResult VisitRefExpression(RefExpressionSyntax node)
    {
      return this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a ParenthesizedLambdaExpressionSyntax node.</summary>
    public virtual TResult VisitParenthesizedLambdaExpression(ParenthesizedLambdaExpressionSyntax node)
    {
      return this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a InitializerExpressionSyntax node.</summary>
    public virtual TResult VisitInitializerExpression(InitializerExpressionSyntax node)
    {
      return this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a ObjectCreationExpressionSyntax node.</summary>
    public virtual TResult VisitObjectCreationExpression(ObjectCreationExpressionSyntax node)
    {
      return this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a AnonymousObjectMemberDeclaratorSyntax node.</summary>
    public virtual TResult VisitAnonymousObjectMemberDeclarator(AnonymousObjectMemberDeclaratorSyntax node)
    {
      return this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a AnonymousObjectCreationExpressionSyntax node.</summary>
    public virtual TResult VisitAnonymousObjectCreationExpression(AnonymousObjectCreationExpressionSyntax node)
    {
      return this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a ArrayCreationExpressionSyntax node.</summary>
    public virtual TResult VisitArrayCreationExpression(ArrayCreationExpressionSyntax node)
    {
      return this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a ImplicitArrayCreationExpressionSyntax node.</summary>
    public virtual TResult VisitImplicitArrayCreationExpression(ImplicitArrayCreationExpressionSyntax node)
    {
      return this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a StackAllocArrayCreationExpressionSyntax node.</summary>
    public virtual TResult VisitStackAllocArrayCreationExpression(StackAllocArrayCreationExpressionSyntax node)
    {
      return this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a ImplicitStackAllocArrayCreationExpressionSyntax node.</summary>
    public virtual TResult VisitImplicitStackAllocArrayCreationExpression(ImplicitStackAllocArrayCreationExpressionSyntax node)
    {
      return this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a QueryExpressionSyntax node.</summary>
    public virtual TResult VisitQueryExpression(QueryExpressionSyntax node)
    {
      return this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a QueryBodySyntax node.</summary>
    public virtual TResult VisitQueryBody(QueryBodySyntax node)
    {
      return this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a FromClauseSyntax node.</summary>
    public virtual TResult VisitFromClause(FromClauseSyntax node)
    {
      return this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a LetClauseSyntax node.</summary>
    public virtual TResult VisitLetClause(LetClauseSyntax node)
    {
      return this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a JoinClauseSyntax node.</summary>
    public virtual TResult VisitJoinClause(JoinClauseSyntax node)
    {
      return this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a JoinIntoClauseSyntax node.</summary>
    public virtual TResult VisitJoinIntoClause(JoinIntoClauseSyntax node)
    {
      return this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a WhereClauseSyntax node.</summary>
    public virtual TResult VisitWhereClause(WhereClauseSyntax node)
    {
      return this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a OrderByClauseSyntax node.</summary>
    public virtual TResult VisitOrderByClause(OrderByClauseSyntax node)
    {
      return this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a OrderingSyntax node.</summary>
    public virtual TResult VisitOrdering(OrderingSyntax node)
    {
      return this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a SelectClauseSyntax node.</summary>
    public virtual TResult VisitSelectClause(SelectClauseSyntax node)
    {
      return this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a GroupClauseSyntax node.</summary>
    public virtual TResult VisitGroupClause(GroupClauseSyntax node)
    {
      return this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a QueryContinuationSyntax node.</summary>
    public virtual TResult VisitQueryContinuation(QueryContinuationSyntax node)
    {
      return this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a OmittedArraySizeExpressionSyntax node.</summary>
    public virtual TResult VisitOmittedArraySizeExpression(OmittedArraySizeExpressionSyntax node)
    {
      return this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a InterpolatedStringExpressionSyntax node.</summary>
    public virtual TResult VisitInterpolatedStringExpression(InterpolatedStringExpressionSyntax node)
    {
      return this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a IsPatternExpressionSyntax node.</summary>
    public virtual TResult VisitIsPatternExpression(IsPatternExpressionSyntax node)
    {
      return this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a ThrowExpressionSyntax node.</summary>
    public virtual TResult VisitThrowExpression(ThrowExpressionSyntax node)
    {
      return this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a WhenClauseSyntax node.</summary>
    public virtual TResult VisitWhenClause(WhenClauseSyntax node)
    {
      return this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a DiscardPatternSyntax node.</summary>
    public virtual TResult VisitDiscardPattern(DiscardPatternSyntax node)
    {
      return this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a DeclarationPatternSyntax node.</summary>
    public virtual TResult VisitDeclarationPattern(DeclarationPatternSyntax node)
    {
      return this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a VarPatternSyntax node.</summary>
    public virtual TResult VisitVarPattern(VarPatternSyntax node)
    {
      return this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a RecursivePatternSyntax node.</summary>
    public virtual TResult VisitRecursivePattern(RecursivePatternSyntax node)
    {
      return this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a PositionalPatternClauseSyntax node.</summary>
    public virtual TResult VisitPositionalPatternClause(PositionalPatternClauseSyntax node)
    {
      return this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a PropertyPatternClauseSyntax node.</summary>
    public virtual TResult VisitPropertyPatternClause(PropertyPatternClauseSyntax node)
    {
      return this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a SubpatternSyntax node.</summary>
    public virtual TResult VisitSubpattern(SubpatternSyntax node)
    {
      return this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a ConstantPatternSyntax node.</summary>
    public virtual TResult VisitConstantPattern(ConstantPatternSyntax node)
    {
      return this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a InterpolatedStringTextSyntax node.</summary>
    public virtual TResult VisitInterpolatedStringText(InterpolatedStringTextSyntax node)
    {
      return this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a InterpolationSyntax node.</summary>
    public virtual TResult VisitInterpolation(InterpolationSyntax node)
    {
      return this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a InterpolationAlignmentClauseSyntax node.</summary>
    public virtual TResult VisitInterpolationAlignmentClause(InterpolationAlignmentClauseSyntax node)
    {
      return this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a InterpolationFormatClauseSyntax node.</summary>
    public virtual TResult VisitInterpolationFormatClause(InterpolationFormatClauseSyntax node)
    {
      return this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a GlobalStatementSyntax node.</summary>
    public virtual TResult VisitGlobalStatement(GlobalStatementSyntax node)
    {
      return this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a BlockSyntax node.</summary>
    public virtual TResult VisitBlock(BlockSyntax node)
    {
      return this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a LocalFunctionStatementSyntax node.</summary>
    public virtual TResult VisitLocalFunctionStatement(LocalFunctionStatementSyntax node)
    {
      return this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a LocalDeclarationStatementSyntax node.</summary>
    public virtual TResult VisitLocalDeclarationStatement(LocalDeclarationStatementSyntax node)
    {
      return this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a VariableDeclarationSyntax node.</summary>
    public virtual TResult VisitVariableDeclaration(VariableDeclarationSyntax node)
    {
      return this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a VariableDeclaratorSyntax node.</summary>
    public virtual TResult VisitVariableDeclarator(VariableDeclaratorSyntax node)
    {
      return this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a EqualsValueClauseSyntax node.</summary>
    public virtual TResult VisitEqualsValueClause(EqualsValueClauseSyntax node)
    {
      return this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a SingleVariableDesignationSyntax node.</summary>
    public virtual TResult VisitSingleVariableDesignation(SingleVariableDesignationSyntax node)
    {
      return this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a DiscardDesignationSyntax node.</summary>
    public virtual TResult VisitDiscardDesignation(DiscardDesignationSyntax node)
    {
      return this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a ParenthesizedVariableDesignationSyntax node.</summary>
    public virtual TResult VisitParenthesizedVariableDesignation(ParenthesizedVariableDesignationSyntax node)
    {
      return this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a ExpressionStatementSyntax node.</summary>
    public virtual TResult VisitExpressionStatement(ExpressionStatementSyntax node)
    {
      return this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a EmptyStatementSyntax node.</summary>
    public virtual TResult VisitEmptyStatement(EmptyStatementSyntax node)
    {
      return this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a LabeledStatementSyntax node.</summary>
    public virtual TResult VisitLabeledStatement(LabeledStatementSyntax node)
    {
      return this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a GotoStatementSyntax node.</summary>
    public virtual TResult VisitGotoStatement(GotoStatementSyntax node)
    {
      return this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a BreakStatementSyntax node.</summary>
    public virtual TResult VisitBreakStatement(BreakStatementSyntax node)
    {
      return this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a ContinueStatementSyntax node.</summary>
    public virtual TResult VisitContinueStatement(ContinueStatementSyntax node)
    {
      return this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a ReturnStatementSyntax node.</summary>
    public virtual TResult VisitReturnStatement(ReturnStatementSyntax node)
    {
      return this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a ThrowStatementSyntax node.</summary>
    public virtual TResult VisitThrowStatement(ThrowStatementSyntax node)
    {
      return this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a YieldStatementSyntax node.</summary>
    public virtual TResult VisitYieldStatement(YieldStatementSyntax node)
    {
      return this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a WhileStatementSyntax node.</summary>
    public virtual TResult VisitWhileStatement(WhileStatementSyntax node)
    {
      return this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a DoStatementSyntax node.</summary>
    public virtual TResult VisitDoStatement(DoStatementSyntax node)
    {
      return this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a ForStatementSyntax node.</summary>
    public virtual TResult VisitForStatement(ForStatementSyntax node)
    {
      return this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a ForEachStatementSyntax node.</summary>
    public virtual TResult VisitForEachStatement(ForEachStatementSyntax node)
    {
      return this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a ForEachVariableStatementSyntax node.</summary>
    public virtual TResult VisitForEachVariableStatement(ForEachVariableStatementSyntax node)
    {
      return this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a UsingStatementSyntax node.</summary>
    public virtual TResult VisitUsingStatement(UsingStatementSyntax node)
    {
      return this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a FixedStatementSyntax node.</summary>
    public virtual TResult VisitFixedStatement(FixedStatementSyntax node)
    {
      return this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a CheckedStatementSyntax node.</summary>
    public virtual TResult VisitCheckedStatement(CheckedStatementSyntax node)
    {
      return this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a UnsafeStatementSyntax node.</summary>
    public virtual TResult VisitUnsafeStatement(UnsafeStatementSyntax node)
    {
      return this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a LockStatementSyntax node.</summary>
    public virtual TResult VisitLockStatement(LockStatementSyntax node)
    {
      return this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a IfStatementSyntax node.</summary>
    public virtual TResult VisitIfStatement(IfStatementSyntax node)
    {
      return this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a ElseClauseSyntax node.</summary>
    public virtual TResult VisitElseClause(ElseClauseSyntax node)
    {
      return this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a SwitchStatementSyntax node.</summary>
    public virtual TResult VisitSwitchStatement(SwitchStatementSyntax node)
    {
      return this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a SwitchSectionSyntax node.</summary>
    public virtual TResult VisitSwitchSection(SwitchSectionSyntax node)
    {
      return this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a CasePatternSwitchLabelSyntax node.</summary>
    public virtual TResult VisitCasePatternSwitchLabel(CasePatternSwitchLabelSyntax node)
    {
      return this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a CaseSwitchLabelSyntax node.</summary>
    public virtual TResult VisitCaseSwitchLabel(CaseSwitchLabelSyntax node)
    {
      return this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a DefaultSwitchLabelSyntax node.</summary>
    public virtual TResult VisitDefaultSwitchLabel(DefaultSwitchLabelSyntax node)
    {
      return this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a SwitchExpressionSyntax node.</summary>
    public virtual TResult VisitSwitchExpression(SwitchExpressionSyntax node)
    {
      return this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a SwitchExpressionArmSyntax node.</summary>
    public virtual TResult VisitSwitchExpressionArm(SwitchExpressionArmSyntax node)
    {
      return this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a TryStatementSyntax node.</summary>
    public virtual TResult VisitTryStatement(TryStatementSyntax node)
    {
      return this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a CatchClauseSyntax node.</summary>
    public virtual TResult VisitCatchClause(CatchClauseSyntax node)
    {
      return this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a CatchDeclarationSyntax node.</summary>
    public virtual TResult VisitCatchDeclaration(CatchDeclarationSyntax node)
    {
      return this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a CatchFilterClauseSyntax node.</summary>
    public virtual TResult VisitCatchFilterClause(CatchFilterClauseSyntax node)
    {
      return this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a FinallyClauseSyntax node.</summary>
    public virtual TResult VisitFinallyClause(FinallyClauseSyntax node)
    {
      return this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a CompilationUnitSyntax node.</summary>
    public virtual TResult VisitCompilationUnit(CompilationUnitSyntax node)
    {
      return this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a ExternAliasDirectiveSyntax node.</summary>
    public virtual TResult VisitExternAliasDirective(ExternAliasDirectiveSyntax node)
    {
      return this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a UsingDirectiveSyntax node.</summary>
    public virtual TResult VisitUsingDirective(UsingDirectiveSyntax node)
    {
      return this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a NamespaceDeclarationSyntax node.</summary>
    public virtual TResult VisitNamespaceDeclaration(NamespaceDeclarationSyntax node)
    {
      return this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a AttributeListSyntax node.</summary>
    public virtual TResult VisitAttributeList(AttributeListSyntax node)
    {
      return this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a AttributeTargetSpecifierSyntax node.</summary>
    public virtual TResult VisitAttributeTargetSpecifier(AttributeTargetSpecifierSyntax node)
    {
      return this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a AttributeSyntax node.</summary>
    public virtual TResult VisitAttribute(AttributeSyntax node)
    {
      return this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a AttributeArgumentListSyntax node.</summary>
    public virtual TResult VisitAttributeArgumentList(AttributeArgumentListSyntax node)
    {
      return this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a AttributeArgumentSyntax node.</summary>
    public virtual TResult VisitAttributeArgument(AttributeArgumentSyntax node)
    {
      return this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a NameEqualsSyntax node.</summary>
    public virtual TResult VisitNameEquals(NameEqualsSyntax node)
    {
      return this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a TypeParameterListSyntax node.</summary>
    public virtual TResult VisitTypeParameterList(TypeParameterListSyntax node)
    {
      return this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a TypeParameterSyntax node.</summary>
    public virtual TResult VisitTypeParameter(TypeParameterSyntax node)
    {
      return this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a ClassDeclarationSyntax node.</summary>
    public virtual TResult VisitClassDeclaration(ClassDeclarationSyntax node)
    {
      return this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a StructDeclarationSyntax node.</summary>
    public virtual TResult VisitStructDeclaration(StructDeclarationSyntax node)
    {
      return this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a InterfaceDeclarationSyntax node.</summary>
    public virtual TResult VisitInterfaceDeclaration(InterfaceDeclarationSyntax node)
    {
      return this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a EnumDeclarationSyntax node.</summary>
    public virtual TResult VisitEnumDeclaration(EnumDeclarationSyntax node)
    {
      return this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a DelegateDeclarationSyntax node.</summary>
    public virtual TResult VisitDelegateDeclaration(DelegateDeclarationSyntax node)
    {
      return this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a EnumMemberDeclarationSyntax node.</summary>
    public virtual TResult VisitEnumMemberDeclaration(EnumMemberDeclarationSyntax node)
    {
      return this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a BaseListSyntax node.</summary>
    public virtual TResult VisitBaseList(BaseListSyntax node)
    {
      return this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a SimpleBaseTypeSyntax node.</summary>
    public virtual TResult VisitSimpleBaseType(SimpleBaseTypeSyntax node)
    {
      return this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a TypeParameterConstraintClauseSyntax node.</summary>
    public virtual TResult VisitTypeParameterConstraintClause(TypeParameterConstraintClauseSyntax node)
    {
      return this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a ConstructorConstraintSyntax node.</summary>
    public virtual TResult VisitConstructorConstraint(ConstructorConstraintSyntax node)
    {
      return this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a ClassOrStructConstraintSyntax node.</summary>
    public virtual TResult VisitClassOrStructConstraint(ClassOrStructConstraintSyntax node)
    {
      return this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a TypeConstraintSyntax node.</summary>
    public virtual TResult VisitTypeConstraint(TypeConstraintSyntax node)
    {
      return this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a FieldDeclarationSyntax node.</summary>
    public virtual TResult VisitFieldDeclaration(FieldDeclarationSyntax node)
    {
      return this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a EventFieldDeclarationSyntax node.</summary>
    public virtual TResult VisitEventFieldDeclaration(EventFieldDeclarationSyntax node)
    {
      return this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a ExplicitInterfaceSpecifierSyntax node.</summary>
    public virtual TResult VisitExplicitInterfaceSpecifier(ExplicitInterfaceSpecifierSyntax node)
    {
      return this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a MethodDeclarationSyntax node.</summary>
    public virtual TResult VisitMethodDeclaration(MethodDeclarationSyntax node)
    {
      return this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a OperatorDeclarationSyntax node.</summary>
    public virtual TResult VisitOperatorDeclaration(OperatorDeclarationSyntax node)
    {
      return this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a ConversionOperatorDeclarationSyntax node.</summary>
    public virtual TResult VisitConversionOperatorDeclaration(ConversionOperatorDeclarationSyntax node)
    {
      return this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a ConstructorDeclarationSyntax node.</summary>
    public virtual TResult VisitConstructorDeclaration(ConstructorDeclarationSyntax node)
    {
      return this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a ConstructorInitializerSyntax node.</summary>
    public virtual TResult VisitConstructorInitializer(ConstructorInitializerSyntax node)
    {
      return this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a DestructorDeclarationSyntax node.</summary>
    public virtual TResult VisitDestructorDeclaration(DestructorDeclarationSyntax node)
    {
      return this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a PropertyDeclarationSyntax node.</summary>
    public virtual TResult VisitPropertyDeclaration(PropertyDeclarationSyntax node)
    {
      return this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a ArrowExpressionClauseSyntax node.</summary>
    public virtual TResult VisitArrowExpressionClause(ArrowExpressionClauseSyntax node)
    {
      return this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a EventDeclarationSyntax node.</summary>
    public virtual TResult VisitEventDeclaration(EventDeclarationSyntax node)
    {
      return this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a IndexerDeclarationSyntax node.</summary>
    public virtual TResult VisitIndexerDeclaration(IndexerDeclarationSyntax node)
    {
      return this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a AccessorListSyntax node.</summary>
    public virtual TResult VisitAccessorList(AccessorListSyntax node)
    {
      return this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a AccessorDeclarationSyntax node.</summary>
    public virtual TResult VisitAccessorDeclaration(AccessorDeclarationSyntax node)
    {
      return this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a ParameterListSyntax node.</summary>
    public virtual TResult VisitParameterList(ParameterListSyntax node)
    {
      return this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a BracketedParameterListSyntax node.</summary>
    public virtual TResult VisitBracketedParameterList(BracketedParameterListSyntax node)
    {
      return this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a ParameterSyntax node.</summary>
    public virtual TResult VisitParameter(ParameterSyntax node)
    {
      return this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a IncompleteMemberSyntax node.</summary>
    public virtual TResult VisitIncompleteMember(IncompleteMemberSyntax node)
    {
      return this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a SkippedTokensTriviaSyntax node.</summary>
    public virtual TResult VisitSkippedTokensTrivia(SkippedTokensTriviaSyntax node)
    {
      return this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a DocumentationCommentTriviaSyntax node.</summary>
    public virtual TResult VisitDocumentationCommentTrivia(DocumentationCommentTriviaSyntax node)
    {
      return this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a TypeCrefSyntax node.</summary>
    public virtual TResult VisitTypeCref(TypeCrefSyntax node)
    {
      return this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a QualifiedCrefSyntax node.</summary>
    public virtual TResult VisitQualifiedCref(QualifiedCrefSyntax node)
    {
      return this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a NameMemberCrefSyntax node.</summary>
    public virtual TResult VisitNameMemberCref(NameMemberCrefSyntax node)
    {
      return this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a IndexerMemberCrefSyntax node.</summary>
    public virtual TResult VisitIndexerMemberCref(IndexerMemberCrefSyntax node)
    {
      return this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a OperatorMemberCrefSyntax node.</summary>
    public virtual TResult VisitOperatorMemberCref(OperatorMemberCrefSyntax node)
    {
      return this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a ConversionOperatorMemberCrefSyntax node.</summary>
    public virtual TResult VisitConversionOperatorMemberCref(ConversionOperatorMemberCrefSyntax node)
    {
      return this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a CrefParameterListSyntax node.</summary>
    public virtual TResult VisitCrefParameterList(CrefParameterListSyntax node)
    {
      return this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a CrefBracketedParameterListSyntax node.</summary>
    public virtual TResult VisitCrefBracketedParameterList(CrefBracketedParameterListSyntax node)
    {
      return this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a CrefParameterSyntax node.</summary>
    public virtual TResult VisitCrefParameter(CrefParameterSyntax node)
    {
      return this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a XmlElementSyntax node.</summary>
    public virtual TResult VisitXmlElement(XmlElementSyntax node)
    {
      return this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a XmlElementStartTagSyntax node.</summary>
    public virtual TResult VisitXmlElementStartTag(XmlElementStartTagSyntax node)
    {
      return this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a XmlElementEndTagSyntax node.</summary>
    public virtual TResult VisitXmlElementEndTag(XmlElementEndTagSyntax node)
    {
      return this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a XmlEmptyElementSyntax node.</summary>
    public virtual TResult VisitXmlEmptyElement(XmlEmptyElementSyntax node)
    {
      return this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a XmlNameSyntax node.</summary>
    public virtual TResult VisitXmlName(XmlNameSyntax node)
    {
      return this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a XmlPrefixSyntax node.</summary>
    public virtual TResult VisitXmlPrefix(XmlPrefixSyntax node)
    {
      return this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a XmlTextAttributeSyntax node.</summary>
    public virtual TResult VisitXmlTextAttribute(XmlTextAttributeSyntax node)
    {
      return this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a XmlCrefAttributeSyntax node.</summary>
    public virtual TResult VisitXmlCrefAttribute(XmlCrefAttributeSyntax node)
    {
      return this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a XmlNameAttributeSyntax node.</summary>
    public virtual TResult VisitXmlNameAttribute(XmlNameAttributeSyntax node)
    {
      return this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a XmlTextSyntax node.</summary>
    public virtual TResult VisitXmlText(XmlTextSyntax node)
    {
      return this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a XmlCDataSectionSyntax node.</summary>
    public virtual TResult VisitXmlCDataSection(XmlCDataSectionSyntax node)
    {
      return this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a XmlProcessingInstructionSyntax node.</summary>
    public virtual TResult VisitXmlProcessingInstruction(XmlProcessingInstructionSyntax node)
    {
      return this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a XmlCommentSyntax node.</summary>
    public virtual TResult VisitXmlComment(XmlCommentSyntax node)
    {
      return this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a IfDirectiveTriviaSyntax node.</summary>
    public virtual TResult VisitIfDirectiveTrivia(IfDirectiveTriviaSyntax node)
    {
      return this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a ElifDirectiveTriviaSyntax node.</summary>
    public virtual TResult VisitElifDirectiveTrivia(ElifDirectiveTriviaSyntax node)
    {
      return this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a ElseDirectiveTriviaSyntax node.</summary>
    public virtual TResult VisitElseDirectiveTrivia(ElseDirectiveTriviaSyntax node)
    {
      return this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a EndIfDirectiveTriviaSyntax node.</summary>
    public virtual TResult VisitEndIfDirectiveTrivia(EndIfDirectiveTriviaSyntax node)
    {
      return this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a RegionDirectiveTriviaSyntax node.</summary>
    public virtual TResult VisitRegionDirectiveTrivia(RegionDirectiveTriviaSyntax node)
    {
      return this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a EndRegionDirectiveTriviaSyntax node.</summary>
    public virtual TResult VisitEndRegionDirectiveTrivia(EndRegionDirectiveTriviaSyntax node)
    {
      return this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a ErrorDirectiveTriviaSyntax node.</summary>
    public virtual TResult VisitErrorDirectiveTrivia(ErrorDirectiveTriviaSyntax node)
    {
      return this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a WarningDirectiveTriviaSyntax node.</summary>
    public virtual TResult VisitWarningDirectiveTrivia(WarningDirectiveTriviaSyntax node)
    {
      return this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a BadDirectiveTriviaSyntax node.</summary>
    public virtual TResult VisitBadDirectiveTrivia(BadDirectiveTriviaSyntax node)
    {
      return this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a DefineDirectiveTriviaSyntax node.</summary>
    public virtual TResult VisitDefineDirectiveTrivia(DefineDirectiveTriviaSyntax node)
    {
      return this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a UndefDirectiveTriviaSyntax node.</summary>
    public virtual TResult VisitUndefDirectiveTrivia(UndefDirectiveTriviaSyntax node)
    {
      return this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a LineDirectiveTriviaSyntax node.</summary>
    public virtual TResult VisitLineDirectiveTrivia(LineDirectiveTriviaSyntax node)
    {
      return this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a PragmaWarningDirectiveTriviaSyntax node.</summary>
    public virtual TResult VisitPragmaWarningDirectiveTrivia(PragmaWarningDirectiveTriviaSyntax node)
    {
      return this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a PragmaChecksumDirectiveTriviaSyntax node.</summary>
    public virtual TResult VisitPragmaChecksumDirectiveTrivia(PragmaChecksumDirectiveTriviaSyntax node)
    {
      return this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a ReferenceDirectiveTriviaSyntax node.</summary>
    public virtual TResult VisitReferenceDirectiveTrivia(ReferenceDirectiveTriviaSyntax node)
    {
      return this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a LoadDirectiveTriviaSyntax node.</summary>
    public virtual TResult VisitLoadDirectiveTrivia(LoadDirectiveTriviaSyntax node)
    {
      return this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a ShebangDirectiveTriviaSyntax node.</summary>
    public virtual TResult VisitShebangDirectiveTrivia(ShebangDirectiveTriviaSyntax node)
    {
      return this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a NullableDirectiveTriviaSyntax node.</summary>
    public virtual TResult VisitNullableDirectiveTrivia(NullableDirectiveTriviaSyntax node)
    {
      return this.DefaultVisit(node);
    }
  }

  public partial class CSharpSyntaxVisitor
  {
    /// <summary>Called when the visitor visits a IdentifierNameSyntax node.</summary>
    public virtual void VisitIdentifierName(IdentifierNameSyntax node)
    {
      this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a QualifiedNameSyntax node.</summary>
    public virtual void VisitQualifiedName(QualifiedNameSyntax node)
    {
      this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a GenericNameSyntax node.</summary>
    public virtual void VisitGenericName(GenericNameSyntax node)
    {
      this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a TypeArgumentListSyntax node.</summary>
    public virtual void VisitTypeArgumentList(TypeArgumentListSyntax node)
    {
      this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a AliasQualifiedNameSyntax node.</summary>
    public virtual void VisitAliasQualifiedName(AliasQualifiedNameSyntax node)
    {
      this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a PredefinedTypeSyntax node.</summary>
    public virtual void VisitPredefinedType(PredefinedTypeSyntax node)
    {
      this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a ArrayTypeSyntax node.</summary>
    public virtual void VisitArrayType(ArrayTypeSyntax node)
    {
      this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a ArrayRankSpecifierSyntax node.</summary>
    public virtual void VisitArrayRankSpecifier(ArrayRankSpecifierSyntax node)
    {
      this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a PointerTypeSyntax node.</summary>
    public virtual void VisitPointerType(PointerTypeSyntax node)
    {
      this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a NullableTypeSyntax node.</summary>
    public virtual void VisitNullableType(NullableTypeSyntax node)
    {
      this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a TupleTypeSyntax node.</summary>
    public virtual void VisitTupleType(TupleTypeSyntax node)
    {
      this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a TupleElementSyntax node.</summary>
    public virtual void VisitTupleElement(TupleElementSyntax node)
    {
      this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a OmittedTypeArgumentSyntax node.</summary>
    public virtual void VisitOmittedTypeArgument(OmittedTypeArgumentSyntax node)
    {
      this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a RefTypeSyntax node.</summary>
    public virtual void VisitRefType(RefTypeSyntax node)
    {
      this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a ParenthesizedExpressionSyntax node.</summary>
    public virtual void VisitParenthesizedExpression(ParenthesizedExpressionSyntax node)
    {
      this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a TupleExpressionSyntax node.</summary>
    public virtual void VisitTupleExpression(TupleExpressionSyntax node)
    {
      this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a PrefixUnaryExpressionSyntax node.</summary>
    public virtual void VisitPrefixUnaryExpression(PrefixUnaryExpressionSyntax node)
    {
      this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a AwaitExpressionSyntax node.</summary>
    public virtual void VisitAwaitExpression(AwaitExpressionSyntax node)
    {
      this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a PostfixUnaryExpressionSyntax node.</summary>
    public virtual void VisitPostfixUnaryExpression(PostfixUnaryExpressionSyntax node)
    {
      this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a MemberAccessExpressionSyntax node.</summary>
    public virtual void VisitMemberAccessExpression(MemberAccessExpressionSyntax node)
    {
      this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a ConditionalAccessExpressionSyntax node.</summary>
    public virtual void VisitConditionalAccessExpression(ConditionalAccessExpressionSyntax node)
    {
      this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a MemberBindingExpressionSyntax node.</summary>
    public virtual void VisitMemberBindingExpression(MemberBindingExpressionSyntax node)
    {
      this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a ElementBindingExpressionSyntax node.</summary>
    public virtual void VisitElementBindingExpression(ElementBindingExpressionSyntax node)
    {
      this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a RangeExpressionSyntax node.</summary>
    public virtual void VisitRangeExpression(RangeExpressionSyntax node)
    {
      this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a ImplicitElementAccessSyntax node.</summary>
    public virtual void VisitImplicitElementAccess(ImplicitElementAccessSyntax node)
    {
      this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a BinaryExpressionSyntax node.</summary>
    public virtual void VisitBinaryExpression(BinaryExpressionSyntax node)
    {
      this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a AssignmentExpressionSyntax node.</summary>
    public virtual void VisitAssignmentExpression(AssignmentExpressionSyntax node)
    {
      this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a ConditionalExpressionSyntax node.</summary>
    public virtual void VisitConditionalExpression(ConditionalExpressionSyntax node)
    {
      this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a ThisExpressionSyntax node.</summary>
    public virtual void VisitThisExpression(ThisExpressionSyntax node)
    {
      this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a BaseExpressionSyntax node.</summary>
    public virtual void VisitBaseExpression(BaseExpressionSyntax node)
    {
      this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a LiteralExpressionSyntax node.</summary>
    public virtual void VisitLiteralExpression(LiteralExpressionSyntax node)
    {
      this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a MakeRefExpressionSyntax node.</summary>
    public virtual void VisitMakeRefExpression(MakeRefExpressionSyntax node)
    {
      this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a RefTypeExpressionSyntax node.</summary>
    public virtual void VisitRefTypeExpression(RefTypeExpressionSyntax node)
    {
      this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a RefValueExpressionSyntax node.</summary>
    public virtual void VisitRefValueExpression(RefValueExpressionSyntax node)
    {
      this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a CheckedExpressionSyntax node.</summary>
    public virtual void VisitCheckedExpression(CheckedExpressionSyntax node)
    {
      this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a DefaultExpressionSyntax node.</summary>
    public virtual void VisitDefaultExpression(DefaultExpressionSyntax node)
    {
      this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a TypeOfExpressionSyntax node.</summary>
    public virtual void VisitTypeOfExpression(TypeOfExpressionSyntax node)
    {
      this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a SizeOfExpressionSyntax node.</summary>
    public virtual void VisitSizeOfExpression(SizeOfExpressionSyntax node)
    {
      this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a InvocationExpressionSyntax node.</summary>
    public virtual void VisitInvocationExpression(InvocationExpressionSyntax node)
    {
      this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a ElementAccessExpressionSyntax node.</summary>
    public virtual void VisitElementAccessExpression(ElementAccessExpressionSyntax node)
    {
      this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a ArgumentListSyntax node.</summary>
    public virtual void VisitArgumentList(ArgumentListSyntax node)
    {
      this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a BracketedArgumentListSyntax node.</summary>
    public virtual void VisitBracketedArgumentList(BracketedArgumentListSyntax node)
    {
      this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a ArgumentSyntax node.</summary>
    public virtual void VisitArgument(ArgumentSyntax node)
    {
      this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a NameColonSyntax node.</summary>
    public virtual void VisitNameColon(NameColonSyntax node)
    {
      this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a DeclarationExpressionSyntax node.</summary>
    public virtual void VisitDeclarationExpression(DeclarationExpressionSyntax node)
    {
      this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a CastExpressionSyntax node.</summary>
    public virtual void VisitCastExpression(CastExpressionSyntax node)
    {
      this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a AnonymousMethodExpressionSyntax node.</summary>
    public virtual void VisitAnonymousMethodExpression(AnonymousMethodExpressionSyntax node)
    {
      this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a SimpleLambdaExpressionSyntax node.</summary>
    public virtual void VisitSimpleLambdaExpression(SimpleLambdaExpressionSyntax node)
    {
      this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a RefExpressionSyntax node.</summary>
    public virtual void VisitRefExpression(RefExpressionSyntax node)
    {
      this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a ParenthesizedLambdaExpressionSyntax node.</summary>
    public virtual void VisitParenthesizedLambdaExpression(ParenthesizedLambdaExpressionSyntax node)
    {
      this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a InitializerExpressionSyntax node.</summary>
    public virtual void VisitInitializerExpression(InitializerExpressionSyntax node)
    {
      this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a ObjectCreationExpressionSyntax node.</summary>
    public virtual void VisitObjectCreationExpression(ObjectCreationExpressionSyntax node)
    {
      this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a AnonymousObjectMemberDeclaratorSyntax node.</summary>
    public virtual void VisitAnonymousObjectMemberDeclarator(AnonymousObjectMemberDeclaratorSyntax node)
    {
      this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a AnonymousObjectCreationExpressionSyntax node.</summary>
    public virtual void VisitAnonymousObjectCreationExpression(AnonymousObjectCreationExpressionSyntax node)
    {
      this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a ArrayCreationExpressionSyntax node.</summary>
    public virtual void VisitArrayCreationExpression(ArrayCreationExpressionSyntax node)
    {
      this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a ImplicitArrayCreationExpressionSyntax node.</summary>
    public virtual void VisitImplicitArrayCreationExpression(ImplicitArrayCreationExpressionSyntax node)
    {
      this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a StackAllocArrayCreationExpressionSyntax node.</summary>
    public virtual void VisitStackAllocArrayCreationExpression(StackAllocArrayCreationExpressionSyntax node)
    {
      this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a ImplicitStackAllocArrayCreationExpressionSyntax node.</summary>
    public virtual void VisitImplicitStackAllocArrayCreationExpression(ImplicitStackAllocArrayCreationExpressionSyntax node)
    {
      this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a QueryExpressionSyntax node.</summary>
    public virtual void VisitQueryExpression(QueryExpressionSyntax node)
    {
      this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a QueryBodySyntax node.</summary>
    public virtual void VisitQueryBody(QueryBodySyntax node)
    {
      this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a FromClauseSyntax node.</summary>
    public virtual void VisitFromClause(FromClauseSyntax node)
    {
      this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a LetClauseSyntax node.</summary>
    public virtual void VisitLetClause(LetClauseSyntax node)
    {
      this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a JoinClauseSyntax node.</summary>
    public virtual void VisitJoinClause(JoinClauseSyntax node)
    {
      this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a JoinIntoClauseSyntax node.</summary>
    public virtual void VisitJoinIntoClause(JoinIntoClauseSyntax node)
    {
      this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a WhereClauseSyntax node.</summary>
    public virtual void VisitWhereClause(WhereClauseSyntax node)
    {
      this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a OrderByClauseSyntax node.</summary>
    public virtual void VisitOrderByClause(OrderByClauseSyntax node)
    {
      this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a OrderingSyntax node.</summary>
    public virtual void VisitOrdering(OrderingSyntax node)
    {
      this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a SelectClauseSyntax node.</summary>
    public virtual void VisitSelectClause(SelectClauseSyntax node)
    {
      this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a GroupClauseSyntax node.</summary>
    public virtual void VisitGroupClause(GroupClauseSyntax node)
    {
      this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a QueryContinuationSyntax node.</summary>
    public virtual void VisitQueryContinuation(QueryContinuationSyntax node)
    {
      this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a OmittedArraySizeExpressionSyntax node.</summary>
    public virtual void VisitOmittedArraySizeExpression(OmittedArraySizeExpressionSyntax node)
    {
      this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a InterpolatedStringExpressionSyntax node.</summary>
    public virtual void VisitInterpolatedStringExpression(InterpolatedStringExpressionSyntax node)
    {
      this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a IsPatternExpressionSyntax node.</summary>
    public virtual void VisitIsPatternExpression(IsPatternExpressionSyntax node)
    {
      this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a ThrowExpressionSyntax node.</summary>
    public virtual void VisitThrowExpression(ThrowExpressionSyntax node)
    {
      this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a WhenClauseSyntax node.</summary>
    public virtual void VisitWhenClause(WhenClauseSyntax node)
    {
      this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a DiscardPatternSyntax node.</summary>
    public virtual void VisitDiscardPattern(DiscardPatternSyntax node)
    {
      this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a DeclarationPatternSyntax node.</summary>
    public virtual void VisitDeclarationPattern(DeclarationPatternSyntax node)
    {
      this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a VarPatternSyntax node.</summary>
    public virtual void VisitVarPattern(VarPatternSyntax node)
    {
      this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a RecursivePatternSyntax node.</summary>
    public virtual void VisitRecursivePattern(RecursivePatternSyntax node)
    {
      this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a PositionalPatternClauseSyntax node.</summary>
    public virtual void VisitPositionalPatternClause(PositionalPatternClauseSyntax node)
    {
      this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a PropertyPatternClauseSyntax node.</summary>
    public virtual void VisitPropertyPatternClause(PropertyPatternClauseSyntax node)
    {
      this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a SubpatternSyntax node.</summary>
    public virtual void VisitSubpattern(SubpatternSyntax node)
    {
      this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a ConstantPatternSyntax node.</summary>
    public virtual void VisitConstantPattern(ConstantPatternSyntax node)
    {
      this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a InterpolatedStringTextSyntax node.</summary>
    public virtual void VisitInterpolatedStringText(InterpolatedStringTextSyntax node)
    {
      this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a InterpolationSyntax node.</summary>
    public virtual void VisitInterpolation(InterpolationSyntax node)
    {
      this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a InterpolationAlignmentClauseSyntax node.</summary>
    public virtual void VisitInterpolationAlignmentClause(InterpolationAlignmentClauseSyntax node)
    {
      this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a InterpolationFormatClauseSyntax node.</summary>
    public virtual void VisitInterpolationFormatClause(InterpolationFormatClauseSyntax node)
    {
      this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a GlobalStatementSyntax node.</summary>
    public virtual void VisitGlobalStatement(GlobalStatementSyntax node)
    {
      this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a BlockSyntax node.</summary>
    public virtual void VisitBlock(BlockSyntax node)
    {
      this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a LocalFunctionStatementSyntax node.</summary>
    public virtual void VisitLocalFunctionStatement(LocalFunctionStatementSyntax node)
    {
      this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a LocalDeclarationStatementSyntax node.</summary>
    public virtual void VisitLocalDeclarationStatement(LocalDeclarationStatementSyntax node)
    {
      this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a VariableDeclarationSyntax node.</summary>
    public virtual void VisitVariableDeclaration(VariableDeclarationSyntax node)
    {
      this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a VariableDeclaratorSyntax node.</summary>
    public virtual void VisitVariableDeclarator(VariableDeclaratorSyntax node)
    {
      this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a EqualsValueClauseSyntax node.</summary>
    public virtual void VisitEqualsValueClause(EqualsValueClauseSyntax node)
    {
      this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a SingleVariableDesignationSyntax node.</summary>
    public virtual void VisitSingleVariableDesignation(SingleVariableDesignationSyntax node)
    {
      this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a DiscardDesignationSyntax node.</summary>
    public virtual void VisitDiscardDesignation(DiscardDesignationSyntax node)
    {
      this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a ParenthesizedVariableDesignationSyntax node.</summary>
    public virtual void VisitParenthesizedVariableDesignation(ParenthesizedVariableDesignationSyntax node)
    {
      this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a ExpressionStatementSyntax node.</summary>
    public virtual void VisitExpressionStatement(ExpressionStatementSyntax node)
    {
      this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a EmptyStatementSyntax node.</summary>
    public virtual void VisitEmptyStatement(EmptyStatementSyntax node)
    {
      this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a LabeledStatementSyntax node.</summary>
    public virtual void VisitLabeledStatement(LabeledStatementSyntax node)
    {
      this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a GotoStatementSyntax node.</summary>
    public virtual void VisitGotoStatement(GotoStatementSyntax node)
    {
      this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a BreakStatementSyntax node.</summary>
    public virtual void VisitBreakStatement(BreakStatementSyntax node)
    {
      this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a ContinueStatementSyntax node.</summary>
    public virtual void VisitContinueStatement(ContinueStatementSyntax node)
    {
      this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a ReturnStatementSyntax node.</summary>
    public virtual void VisitReturnStatement(ReturnStatementSyntax node)
    {
      this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a ThrowStatementSyntax node.</summary>
    public virtual void VisitThrowStatement(ThrowStatementSyntax node)
    {
      this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a YieldStatementSyntax node.</summary>
    public virtual void VisitYieldStatement(YieldStatementSyntax node)
    {
      this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a WhileStatementSyntax node.</summary>
    public virtual void VisitWhileStatement(WhileStatementSyntax node)
    {
      this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a DoStatementSyntax node.</summary>
    public virtual void VisitDoStatement(DoStatementSyntax node)
    {
      this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a ForStatementSyntax node.</summary>
    public virtual void VisitForStatement(ForStatementSyntax node)
    {
      this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a ForEachStatementSyntax node.</summary>
    public virtual void VisitForEachStatement(ForEachStatementSyntax node)
    {
      this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a ForEachVariableStatementSyntax node.</summary>
    public virtual void VisitForEachVariableStatement(ForEachVariableStatementSyntax node)
    {
      this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a UsingStatementSyntax node.</summary>
    public virtual void VisitUsingStatement(UsingStatementSyntax node)
    {
      this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a FixedStatementSyntax node.</summary>
    public virtual void VisitFixedStatement(FixedStatementSyntax node)
    {
      this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a CheckedStatementSyntax node.</summary>
    public virtual void VisitCheckedStatement(CheckedStatementSyntax node)
    {
      this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a UnsafeStatementSyntax node.</summary>
    public virtual void VisitUnsafeStatement(UnsafeStatementSyntax node)
    {
      this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a LockStatementSyntax node.</summary>
    public virtual void VisitLockStatement(LockStatementSyntax node)
    {
      this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a IfStatementSyntax node.</summary>
    public virtual void VisitIfStatement(IfStatementSyntax node)
    {
      this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a ElseClauseSyntax node.</summary>
    public virtual void VisitElseClause(ElseClauseSyntax node)
    {
      this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a SwitchStatementSyntax node.</summary>
    public virtual void VisitSwitchStatement(SwitchStatementSyntax node)
    {
      this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a SwitchSectionSyntax node.</summary>
    public virtual void VisitSwitchSection(SwitchSectionSyntax node)
    {
      this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a CasePatternSwitchLabelSyntax node.</summary>
    public virtual void VisitCasePatternSwitchLabel(CasePatternSwitchLabelSyntax node)
    {
      this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a CaseSwitchLabelSyntax node.</summary>
    public virtual void VisitCaseSwitchLabel(CaseSwitchLabelSyntax node)
    {
      this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a DefaultSwitchLabelSyntax node.</summary>
    public virtual void VisitDefaultSwitchLabel(DefaultSwitchLabelSyntax node)
    {
      this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a SwitchExpressionSyntax node.</summary>
    public virtual void VisitSwitchExpression(SwitchExpressionSyntax node)
    {
      this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a SwitchExpressionArmSyntax node.</summary>
    public virtual void VisitSwitchExpressionArm(SwitchExpressionArmSyntax node)
    {
      this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a TryStatementSyntax node.</summary>
    public virtual void VisitTryStatement(TryStatementSyntax node)
    {
      this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a CatchClauseSyntax node.</summary>
    public virtual void VisitCatchClause(CatchClauseSyntax node)
    {
      this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a CatchDeclarationSyntax node.</summary>
    public virtual void VisitCatchDeclaration(CatchDeclarationSyntax node)
    {
      this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a CatchFilterClauseSyntax node.</summary>
    public virtual void VisitCatchFilterClause(CatchFilterClauseSyntax node)
    {
      this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a FinallyClauseSyntax node.</summary>
    public virtual void VisitFinallyClause(FinallyClauseSyntax node)
    {
      this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a CompilationUnitSyntax node.</summary>
    public virtual void VisitCompilationUnit(CompilationUnitSyntax node)
    {
      this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a ExternAliasDirectiveSyntax node.</summary>
    public virtual void VisitExternAliasDirective(ExternAliasDirectiveSyntax node)
    {
      this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a UsingDirectiveSyntax node.</summary>
    public virtual void VisitUsingDirective(UsingDirectiveSyntax node)
    {
      this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a NamespaceDeclarationSyntax node.</summary>
    public virtual void VisitNamespaceDeclaration(NamespaceDeclarationSyntax node)
    {
      this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a AttributeListSyntax node.</summary>
    public virtual void VisitAttributeList(AttributeListSyntax node)
    {
      this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a AttributeTargetSpecifierSyntax node.</summary>
    public virtual void VisitAttributeTargetSpecifier(AttributeTargetSpecifierSyntax node)
    {
      this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a AttributeSyntax node.</summary>
    public virtual void VisitAttribute(AttributeSyntax node)
    {
      this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a AttributeArgumentListSyntax node.</summary>
    public virtual void VisitAttributeArgumentList(AttributeArgumentListSyntax node)
    {
      this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a AttributeArgumentSyntax node.</summary>
    public virtual void VisitAttributeArgument(AttributeArgumentSyntax node)
    {
      this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a NameEqualsSyntax node.</summary>
    public virtual void VisitNameEquals(NameEqualsSyntax node)
    {
      this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a TypeParameterListSyntax node.</summary>
    public virtual void VisitTypeParameterList(TypeParameterListSyntax node)
    {
      this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a TypeParameterSyntax node.</summary>
    public virtual void VisitTypeParameter(TypeParameterSyntax node)
    {
      this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a ClassDeclarationSyntax node.</summary>
    public virtual void VisitClassDeclaration(ClassDeclarationSyntax node)
    {
      this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a StructDeclarationSyntax node.</summary>
    public virtual void VisitStructDeclaration(StructDeclarationSyntax node)
    {
      this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a InterfaceDeclarationSyntax node.</summary>
    public virtual void VisitInterfaceDeclaration(InterfaceDeclarationSyntax node)
    {
      this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a EnumDeclarationSyntax node.</summary>
    public virtual void VisitEnumDeclaration(EnumDeclarationSyntax node)
    {
      this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a DelegateDeclarationSyntax node.</summary>
    public virtual void VisitDelegateDeclaration(DelegateDeclarationSyntax node)
    {
      this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a EnumMemberDeclarationSyntax node.</summary>
    public virtual void VisitEnumMemberDeclaration(EnumMemberDeclarationSyntax node)
    {
      this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a BaseListSyntax node.</summary>
    public virtual void VisitBaseList(BaseListSyntax node)
    {
      this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a SimpleBaseTypeSyntax node.</summary>
    public virtual void VisitSimpleBaseType(SimpleBaseTypeSyntax node)
    {
      this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a TypeParameterConstraintClauseSyntax node.</summary>
    public virtual void VisitTypeParameterConstraintClause(TypeParameterConstraintClauseSyntax node)
    {
      this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a ConstructorConstraintSyntax node.</summary>
    public virtual void VisitConstructorConstraint(ConstructorConstraintSyntax node)
    {
      this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a ClassOrStructConstraintSyntax node.</summary>
    public virtual void VisitClassOrStructConstraint(ClassOrStructConstraintSyntax node)
    {
      this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a TypeConstraintSyntax node.</summary>
    public virtual void VisitTypeConstraint(TypeConstraintSyntax node)
    {
      this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a FieldDeclarationSyntax node.</summary>
    public virtual void VisitFieldDeclaration(FieldDeclarationSyntax node)
    {
      this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a EventFieldDeclarationSyntax node.</summary>
    public virtual void VisitEventFieldDeclaration(EventFieldDeclarationSyntax node)
    {
      this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a ExplicitInterfaceSpecifierSyntax node.</summary>
    public virtual void VisitExplicitInterfaceSpecifier(ExplicitInterfaceSpecifierSyntax node)
    {
      this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a MethodDeclarationSyntax node.</summary>
    public virtual void VisitMethodDeclaration(MethodDeclarationSyntax node)
    {
      this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a OperatorDeclarationSyntax node.</summary>
    public virtual void VisitOperatorDeclaration(OperatorDeclarationSyntax node)
    {
      this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a ConversionOperatorDeclarationSyntax node.</summary>
    public virtual void VisitConversionOperatorDeclaration(ConversionOperatorDeclarationSyntax node)
    {
      this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a ConstructorDeclarationSyntax node.</summary>
    public virtual void VisitConstructorDeclaration(ConstructorDeclarationSyntax node)
    {
      this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a ConstructorInitializerSyntax node.</summary>
    public virtual void VisitConstructorInitializer(ConstructorInitializerSyntax node)
    {
      this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a DestructorDeclarationSyntax node.</summary>
    public virtual void VisitDestructorDeclaration(DestructorDeclarationSyntax node)
    {
      this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a PropertyDeclarationSyntax node.</summary>
    public virtual void VisitPropertyDeclaration(PropertyDeclarationSyntax node)
    {
      this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a ArrowExpressionClauseSyntax node.</summary>
    public virtual void VisitArrowExpressionClause(ArrowExpressionClauseSyntax node)
    {
      this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a EventDeclarationSyntax node.</summary>
    public virtual void VisitEventDeclaration(EventDeclarationSyntax node)
    {
      this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a IndexerDeclarationSyntax node.</summary>
    public virtual void VisitIndexerDeclaration(IndexerDeclarationSyntax node)
    {
      this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a AccessorListSyntax node.</summary>
    public virtual void VisitAccessorList(AccessorListSyntax node)
    {
      this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a AccessorDeclarationSyntax node.</summary>
    public virtual void VisitAccessorDeclaration(AccessorDeclarationSyntax node)
    {
      this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a ParameterListSyntax node.</summary>
    public virtual void VisitParameterList(ParameterListSyntax node)
    {
      this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a BracketedParameterListSyntax node.</summary>
    public virtual void VisitBracketedParameterList(BracketedParameterListSyntax node)
    {
      this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a ParameterSyntax node.</summary>
    public virtual void VisitParameter(ParameterSyntax node)
    {
      this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a IncompleteMemberSyntax node.</summary>
    public virtual void VisitIncompleteMember(IncompleteMemberSyntax node)
    {
      this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a SkippedTokensTriviaSyntax node.</summary>
    public virtual void VisitSkippedTokensTrivia(SkippedTokensTriviaSyntax node)
    {
      this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a DocumentationCommentTriviaSyntax node.</summary>
    public virtual void VisitDocumentationCommentTrivia(DocumentationCommentTriviaSyntax node)
    {
      this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a TypeCrefSyntax node.</summary>
    public virtual void VisitTypeCref(TypeCrefSyntax node)
    {
      this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a QualifiedCrefSyntax node.</summary>
    public virtual void VisitQualifiedCref(QualifiedCrefSyntax node)
    {
      this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a NameMemberCrefSyntax node.</summary>
    public virtual void VisitNameMemberCref(NameMemberCrefSyntax node)
    {
      this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a IndexerMemberCrefSyntax node.</summary>
    public virtual void VisitIndexerMemberCref(IndexerMemberCrefSyntax node)
    {
      this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a OperatorMemberCrefSyntax node.</summary>
    public virtual void VisitOperatorMemberCref(OperatorMemberCrefSyntax node)
    {
      this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a ConversionOperatorMemberCrefSyntax node.</summary>
    public virtual void VisitConversionOperatorMemberCref(ConversionOperatorMemberCrefSyntax node)
    {
      this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a CrefParameterListSyntax node.</summary>
    public virtual void VisitCrefParameterList(CrefParameterListSyntax node)
    {
      this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a CrefBracketedParameterListSyntax node.</summary>
    public virtual void VisitCrefBracketedParameterList(CrefBracketedParameterListSyntax node)
    {
      this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a CrefParameterSyntax node.</summary>
    public virtual void VisitCrefParameter(CrefParameterSyntax node)
    {
      this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a XmlElementSyntax node.</summary>
    public virtual void VisitXmlElement(XmlElementSyntax node)
    {
      this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a XmlElementStartTagSyntax node.</summary>
    public virtual void VisitXmlElementStartTag(XmlElementStartTagSyntax node)
    {
      this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a XmlElementEndTagSyntax node.</summary>
    public virtual void VisitXmlElementEndTag(XmlElementEndTagSyntax node)
    {
      this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a XmlEmptyElementSyntax node.</summary>
    public virtual void VisitXmlEmptyElement(XmlEmptyElementSyntax node)
    {
      this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a XmlNameSyntax node.</summary>
    public virtual void VisitXmlName(XmlNameSyntax node)
    {
      this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a XmlPrefixSyntax node.</summary>
    public virtual void VisitXmlPrefix(XmlPrefixSyntax node)
    {
      this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a XmlTextAttributeSyntax node.</summary>
    public virtual void VisitXmlTextAttribute(XmlTextAttributeSyntax node)
    {
      this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a XmlCrefAttributeSyntax node.</summary>
    public virtual void VisitXmlCrefAttribute(XmlCrefAttributeSyntax node)
    {
      this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a XmlNameAttributeSyntax node.</summary>
    public virtual void VisitXmlNameAttribute(XmlNameAttributeSyntax node)
    {
      this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a XmlTextSyntax node.</summary>
    public virtual void VisitXmlText(XmlTextSyntax node)
    {
      this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a XmlCDataSectionSyntax node.</summary>
    public virtual void VisitXmlCDataSection(XmlCDataSectionSyntax node)
    {
      this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a XmlProcessingInstructionSyntax node.</summary>
    public virtual void VisitXmlProcessingInstruction(XmlProcessingInstructionSyntax node)
    {
      this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a XmlCommentSyntax node.</summary>
    public virtual void VisitXmlComment(XmlCommentSyntax node)
    {
      this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a IfDirectiveTriviaSyntax node.</summary>
    public virtual void VisitIfDirectiveTrivia(IfDirectiveTriviaSyntax node)
    {
      this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a ElifDirectiveTriviaSyntax node.</summary>
    public virtual void VisitElifDirectiveTrivia(ElifDirectiveTriviaSyntax node)
    {
      this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a ElseDirectiveTriviaSyntax node.</summary>
    public virtual void VisitElseDirectiveTrivia(ElseDirectiveTriviaSyntax node)
    {
      this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a EndIfDirectiveTriviaSyntax node.</summary>
    public virtual void VisitEndIfDirectiveTrivia(EndIfDirectiveTriviaSyntax node)
    {
      this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a RegionDirectiveTriviaSyntax node.</summary>
    public virtual void VisitRegionDirectiveTrivia(RegionDirectiveTriviaSyntax node)
    {
      this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a EndRegionDirectiveTriviaSyntax node.</summary>
    public virtual void VisitEndRegionDirectiveTrivia(EndRegionDirectiveTriviaSyntax node)
    {
      this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a ErrorDirectiveTriviaSyntax node.</summary>
    public virtual void VisitErrorDirectiveTrivia(ErrorDirectiveTriviaSyntax node)
    {
      this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a WarningDirectiveTriviaSyntax node.</summary>
    public virtual void VisitWarningDirectiveTrivia(WarningDirectiveTriviaSyntax node)
    {
      this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a BadDirectiveTriviaSyntax node.</summary>
    public virtual void VisitBadDirectiveTrivia(BadDirectiveTriviaSyntax node)
    {
      this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a DefineDirectiveTriviaSyntax node.</summary>
    public virtual void VisitDefineDirectiveTrivia(DefineDirectiveTriviaSyntax node)
    {
      this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a UndefDirectiveTriviaSyntax node.</summary>
    public virtual void VisitUndefDirectiveTrivia(UndefDirectiveTriviaSyntax node)
    {
      this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a LineDirectiveTriviaSyntax node.</summary>
    public virtual void VisitLineDirectiveTrivia(LineDirectiveTriviaSyntax node)
    {
      this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a PragmaWarningDirectiveTriviaSyntax node.</summary>
    public virtual void VisitPragmaWarningDirectiveTrivia(PragmaWarningDirectiveTriviaSyntax node)
    {
      this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a PragmaChecksumDirectiveTriviaSyntax node.</summary>
    public virtual void VisitPragmaChecksumDirectiveTrivia(PragmaChecksumDirectiveTriviaSyntax node)
    {
      this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a ReferenceDirectiveTriviaSyntax node.</summary>
    public virtual void VisitReferenceDirectiveTrivia(ReferenceDirectiveTriviaSyntax node)
    {
      this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a LoadDirectiveTriviaSyntax node.</summary>
    public virtual void VisitLoadDirectiveTrivia(LoadDirectiveTriviaSyntax node)
    {
      this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a ShebangDirectiveTriviaSyntax node.</summary>
    public virtual void VisitShebangDirectiveTrivia(ShebangDirectiveTriviaSyntax node)
    {
      this.DefaultVisit(node);
    }

    /// <summary>Called when the visitor visits a NullableDirectiveTriviaSyntax node.</summary>
    public virtual void VisitNullableDirectiveTrivia(NullableDirectiveTriviaSyntax node)
    {
      this.DefaultVisit(node);
    }
  }

  public partial class CSharpSyntaxRewriter : CSharpSyntaxVisitor<SyntaxNode>
  {
    public override SyntaxNode VisitIdentifierName(IdentifierNameSyntax node)
    {
      var identifier = this.VisitToken(node.Identifier);
      return node.Update(identifier);
    }

    public override SyntaxNode VisitQualifiedName(QualifiedNameSyntax node)
    {
      var left = (NameSyntax)this.Visit(node.Left);
      var dotToken = this.VisitToken(node.DotToken);
      var right = (SimpleNameSyntax)this.Visit(node.Right);
      return node.Update(left, dotToken, right);
    }

    public override SyntaxNode VisitGenericName(GenericNameSyntax node)
    {
      var identifier = this.VisitToken(node.Identifier);
      var typeArgumentList = (TypeArgumentListSyntax)this.Visit(node.TypeArgumentList);
      return node.Update(identifier, typeArgumentList);
    }

    public override SyntaxNode VisitTypeArgumentList(TypeArgumentListSyntax node)
    {
      var lessThanToken = this.VisitToken(node.LessThanToken);
      var arguments = this.VisitList(node.Arguments);
      var greaterThanToken = this.VisitToken(node.GreaterThanToken);
      return node.Update(lessThanToken, arguments, greaterThanToken);
    }

    public override SyntaxNode VisitAliasQualifiedName(AliasQualifiedNameSyntax node)
    {
      var alias = (IdentifierNameSyntax)this.Visit(node.Alias);
      var colonColonToken = this.VisitToken(node.ColonColonToken);
      var name = (SimpleNameSyntax)this.Visit(node.Name);
      return node.Update(alias, colonColonToken, name);
    }

    public override SyntaxNode VisitPredefinedType(PredefinedTypeSyntax node)
    {
      var keyword = this.VisitToken(node.Keyword);
      return node.Update(keyword);
    }

    public override SyntaxNode VisitArrayType(ArrayTypeSyntax node)
    {
      var elementType = (TypeSyntax)this.Visit(node.ElementType);
      var rankSpecifiers = this.VisitList(node.RankSpecifiers);
      return node.Update(elementType, rankSpecifiers);
    }

    public override SyntaxNode VisitArrayRankSpecifier(ArrayRankSpecifierSyntax node)
    {
      var openBracketToken = this.VisitToken(node.OpenBracketToken);
      var sizes = this.VisitList(node.Sizes);
      var closeBracketToken = this.VisitToken(node.CloseBracketToken);
      return node.Update(openBracketToken, sizes, closeBracketToken);
    }

    public override SyntaxNode VisitPointerType(PointerTypeSyntax node)
    {
      var elementType = (TypeSyntax)this.Visit(node.ElementType);
      var asteriskToken = this.VisitToken(node.AsteriskToken);
      return node.Update(elementType, asteriskToken);
    }

    public override SyntaxNode VisitNullableType(NullableTypeSyntax node)
    {
      var elementType = (TypeSyntax)this.Visit(node.ElementType);
      var questionToken = this.VisitToken(node.QuestionToken);
      return node.Update(elementType, questionToken);
    }

    public override SyntaxNode VisitTupleType(TupleTypeSyntax node)
    {
      var openParenToken = this.VisitToken(node.OpenParenToken);
      var elements = this.VisitList(node.Elements);
      var closeParenToken = this.VisitToken(node.CloseParenToken);
      return node.Update(openParenToken, elements, closeParenToken);
    }

    public override SyntaxNode VisitTupleElement(TupleElementSyntax node)
    {
      var type = (TypeSyntax)this.Visit(node.Type);
      var identifier = this.VisitToken(node.Identifier);
      return node.Update(type, identifier);
    }

    public override SyntaxNode VisitOmittedTypeArgument(OmittedTypeArgumentSyntax node)
    {
      var omittedTypeArgumentToken = this.VisitToken(node.OmittedTypeArgumentToken);
      return node.Update(omittedTypeArgumentToken);
    }

    public override SyntaxNode VisitRefType(RefTypeSyntax node)
    {
      var refKeyword = this.VisitToken(node.RefKeyword);
      var readOnlyKeyword = this.VisitToken(node.ReadOnlyKeyword);
      var type = (TypeSyntax)this.Visit(node.Type);
      return node.Update(refKeyword, readOnlyKeyword, type);
    }

    public override SyntaxNode VisitParenthesizedExpression(ParenthesizedExpressionSyntax node)
    {
      var openParenToken = this.VisitToken(node.OpenParenToken);
      var expression = (ExpressionSyntax)this.Visit(node.Expression);
      var closeParenToken = this.VisitToken(node.CloseParenToken);
      return node.Update(openParenToken, expression, closeParenToken);
    }

    public override SyntaxNode VisitTupleExpression(TupleExpressionSyntax node)
    {
      var openParenToken = this.VisitToken(node.OpenParenToken);
      var arguments = this.VisitList(node.Arguments);
      var closeParenToken = this.VisitToken(node.CloseParenToken);
      return node.Update(openParenToken, arguments, closeParenToken);
    }

    public override SyntaxNode VisitPrefixUnaryExpression(PrefixUnaryExpressionSyntax node)
    {
      var operatorToken = this.VisitToken(node.OperatorToken);
      var operand = (ExpressionSyntax)this.Visit(node.Operand);
      return node.Update(operatorToken, operand);
    }

    public override SyntaxNode VisitAwaitExpression(AwaitExpressionSyntax node)
    {
      var awaitKeyword = this.VisitToken(node.AwaitKeyword);
      var expression = (ExpressionSyntax)this.Visit(node.Expression);
      return node.Update(awaitKeyword, expression);
    }

    public override SyntaxNode VisitPostfixUnaryExpression(PostfixUnaryExpressionSyntax node)
    {
      var operand = (ExpressionSyntax)this.Visit(node.Operand);
      var operatorToken = this.VisitToken(node.OperatorToken);
      return node.Update(operand, operatorToken);
    }

    public override SyntaxNode VisitMemberAccessExpression(MemberAccessExpressionSyntax node)
    {
      var expression = (ExpressionSyntax)this.Visit(node.Expression);
      var operatorToken = this.VisitToken(node.OperatorToken);
      var name = (SimpleNameSyntax)this.Visit(node.Name);
      return node.Update(expression, operatorToken, name);
    }

    public override SyntaxNode VisitConditionalAccessExpression(ConditionalAccessExpressionSyntax node)
    {
      var expression = (ExpressionSyntax)this.Visit(node.Expression);
      var operatorToken = this.VisitToken(node.OperatorToken);
      var whenNotNull = (ExpressionSyntax)this.Visit(node.WhenNotNull);
      return node.Update(expression, operatorToken, whenNotNull);
    }

    public override SyntaxNode VisitMemberBindingExpression(MemberBindingExpressionSyntax node)
    {
      var operatorToken = this.VisitToken(node.OperatorToken);
      var name = (SimpleNameSyntax)this.Visit(node.Name);
      return node.Update(operatorToken, name);
    }

    public override SyntaxNode VisitElementBindingExpression(ElementBindingExpressionSyntax node)
    {
      var argumentList = (BracketedArgumentListSyntax)this.Visit(node.ArgumentList);
      return node.Update(argumentList);
    }

    public override SyntaxNode VisitRangeExpression(RangeExpressionSyntax node)
    {
      var leftOperand = (ExpressionSyntax)this.Visit(node.LeftOperand);
      var operatorToken = this.VisitToken(node.OperatorToken);
      var rightOperand = (ExpressionSyntax)this.Visit(node.RightOperand);
      return node.Update(leftOperand, operatorToken, rightOperand);
    }

    public override SyntaxNode VisitImplicitElementAccess(ImplicitElementAccessSyntax node)
    {
      var argumentList = (BracketedArgumentListSyntax)this.Visit(node.ArgumentList);
      return node.Update(argumentList);
    }

    public override SyntaxNode VisitBinaryExpression(BinaryExpressionSyntax node)
    {
      var left = (ExpressionSyntax)this.Visit(node.Left);
      var operatorToken = this.VisitToken(node.OperatorToken);
      var right = (ExpressionSyntax)this.Visit(node.Right);
      return node.Update(left, operatorToken, right);
    }

    public override SyntaxNode VisitAssignmentExpression(AssignmentExpressionSyntax node)
    {
      var left = (ExpressionSyntax)this.Visit(node.Left);
      var operatorToken = this.VisitToken(node.OperatorToken);
      var right = (ExpressionSyntax)this.Visit(node.Right);
      return node.Update(left, operatorToken, right);
    }

    public override SyntaxNode VisitConditionalExpression(ConditionalExpressionSyntax node)
    {
      var condition = (ExpressionSyntax)this.Visit(node.Condition);
      var questionToken = this.VisitToken(node.QuestionToken);
      var whenTrue = (ExpressionSyntax)this.Visit(node.WhenTrue);
      var colonToken = this.VisitToken(node.ColonToken);
      var whenFalse = (ExpressionSyntax)this.Visit(node.WhenFalse);
      return node.Update(condition, questionToken, whenTrue, colonToken, whenFalse);
    }

    public override SyntaxNode VisitThisExpression(ThisExpressionSyntax node)
    {
      var token = this.VisitToken(node.Token);
      return node.Update(token);
    }

    public override SyntaxNode VisitBaseExpression(BaseExpressionSyntax node)
    {
      var token = this.VisitToken(node.Token);
      return node.Update(token);
    }

    public override SyntaxNode VisitLiteralExpression(LiteralExpressionSyntax node)
    {
      var token = this.VisitToken(node.Token);
      return node.Update(token);
    }

    public override SyntaxNode VisitMakeRefExpression(MakeRefExpressionSyntax node)
    {
      var keyword = this.VisitToken(node.Keyword);
      var openParenToken = this.VisitToken(node.OpenParenToken);
      var expression = (ExpressionSyntax)this.Visit(node.Expression);
      var closeParenToken = this.VisitToken(node.CloseParenToken);
      return node.Update(keyword, openParenToken, expression, closeParenToken);
    }

    public override SyntaxNode VisitRefTypeExpression(RefTypeExpressionSyntax node)
    {
      var keyword = this.VisitToken(node.Keyword);
      var openParenToken = this.VisitToken(node.OpenParenToken);
      var expression = (ExpressionSyntax)this.Visit(node.Expression);
      var closeParenToken = this.VisitToken(node.CloseParenToken);
      return node.Update(keyword, openParenToken, expression, closeParenToken);
    }

    public override SyntaxNode VisitRefValueExpression(RefValueExpressionSyntax node)
    {
      var keyword = this.VisitToken(node.Keyword);
      var openParenToken = this.VisitToken(node.OpenParenToken);
      var expression = (ExpressionSyntax)this.Visit(node.Expression);
      var comma = this.VisitToken(node.Comma);
      var type = (TypeSyntax)this.Visit(node.Type);
      var closeParenToken = this.VisitToken(node.CloseParenToken);
      return node.Update(keyword, openParenToken, expression, comma, type, closeParenToken);
    }

    public override SyntaxNode VisitCheckedExpression(CheckedExpressionSyntax node)
    {
      var keyword = this.VisitToken(node.Keyword);
      var openParenToken = this.VisitToken(node.OpenParenToken);
      var expression = (ExpressionSyntax)this.Visit(node.Expression);
      var closeParenToken = this.VisitToken(node.CloseParenToken);
      return node.Update(keyword, openParenToken, expression, closeParenToken);
    }

    public override SyntaxNode VisitDefaultExpression(DefaultExpressionSyntax node)
    {
      var keyword = this.VisitToken(node.Keyword);
      var openParenToken = this.VisitToken(node.OpenParenToken);
      var type = (TypeSyntax)this.Visit(node.Type);
      var closeParenToken = this.VisitToken(node.CloseParenToken);
      return node.Update(keyword, openParenToken, type, closeParenToken);
    }

    public override SyntaxNode VisitTypeOfExpression(TypeOfExpressionSyntax node)
    {
      var keyword = this.VisitToken(node.Keyword);
      var openParenToken = this.VisitToken(node.OpenParenToken);
      var type = (TypeSyntax)this.Visit(node.Type);
      var closeParenToken = this.VisitToken(node.CloseParenToken);
      return node.Update(keyword, openParenToken, type, closeParenToken);
    }

    public override SyntaxNode VisitSizeOfExpression(SizeOfExpressionSyntax node)
    {
      var keyword = this.VisitToken(node.Keyword);
      var openParenToken = this.VisitToken(node.OpenParenToken);
      var type = (TypeSyntax)this.Visit(node.Type);
      var closeParenToken = this.VisitToken(node.CloseParenToken);
      return node.Update(keyword, openParenToken, type, closeParenToken);
    }

    public override SyntaxNode VisitInvocationExpression(InvocationExpressionSyntax node)
    {
      var expression = (ExpressionSyntax)this.Visit(node.Expression);
      var argumentList = (ArgumentListSyntax)this.Visit(node.ArgumentList);
      return node.Update(expression, argumentList);
    }

    public override SyntaxNode VisitElementAccessExpression(ElementAccessExpressionSyntax node)
    {
      var expression = (ExpressionSyntax)this.Visit(node.Expression);
      var argumentList = (BracketedArgumentListSyntax)this.Visit(node.ArgumentList);
      return node.Update(expression, argumentList);
    }

    public override SyntaxNode VisitArgumentList(ArgumentListSyntax node)
    {
      var openParenToken = this.VisitToken(node.OpenParenToken);
      var arguments = this.VisitList(node.Arguments);
      var closeParenToken = this.VisitToken(node.CloseParenToken);
      return node.Update(openParenToken, arguments, closeParenToken);
    }

    public override SyntaxNode VisitBracketedArgumentList(BracketedArgumentListSyntax node)
    {
      var openBracketToken = this.VisitToken(node.OpenBracketToken);
      var arguments = this.VisitList(node.Arguments);
      var closeBracketToken = this.VisitToken(node.CloseBracketToken);
      return node.Update(openBracketToken, arguments, closeBracketToken);
    }

    public override SyntaxNode VisitArgument(ArgumentSyntax node)
    {
      var nameColon = (NameColonSyntax)this.Visit(node.NameColon);
      var refKindKeyword = this.VisitToken(node.RefKindKeyword);
      var expression = (ExpressionSyntax)this.Visit(node.Expression);
      return node.Update(nameColon, refKindKeyword, expression);
    }

    public override SyntaxNode VisitNameColon(NameColonSyntax node)
    {
      var name = (IdentifierNameSyntax)this.Visit(node.Name);
      var colonToken = this.VisitToken(node.ColonToken);
      return node.Update(name, colonToken);
    }

    public override SyntaxNode VisitDeclarationExpression(DeclarationExpressionSyntax node)
    {
      var type = (TypeSyntax)this.Visit(node.Type);
      var designation = (VariableDesignationSyntax)this.Visit(node.Designation);
      return node.Update(type, designation);
    }

    public override SyntaxNode VisitCastExpression(CastExpressionSyntax node)
    {
      var openParenToken = this.VisitToken(node.OpenParenToken);
      var type = (TypeSyntax)this.Visit(node.Type);
      var closeParenToken = this.VisitToken(node.CloseParenToken);
      var expression = (ExpressionSyntax)this.Visit(node.Expression);
      return node.Update(openParenToken, type, closeParenToken, expression);
    }

    public override SyntaxNode VisitAnonymousMethodExpression(AnonymousMethodExpressionSyntax node)
    {
      var asyncKeyword = this.VisitToken(node.AsyncKeyword);
      var delegateKeyword = this.VisitToken(node.DelegateKeyword);
      var parameterList = (ParameterListSyntax)this.Visit(node.ParameterList);
      var body = (CSharpSyntaxNode)this.Visit(node.Body);
      return node.Update(asyncKeyword, delegateKeyword, parameterList, body);
    }

    public override SyntaxNode VisitSimpleLambdaExpression(SimpleLambdaExpressionSyntax node)
    {
      var asyncKeyword = this.VisitToken(node.AsyncKeyword);
      var parameter = (ParameterSyntax)this.Visit(node.Parameter);
      var arrowToken = this.VisitToken(node.ArrowToken);
      var body = (CSharpSyntaxNode)this.Visit(node.Body);
      return node.Update(asyncKeyword, parameter, arrowToken, body);
    }

    public override SyntaxNode VisitRefExpression(RefExpressionSyntax node)
    {
      var refKeyword = this.VisitToken(node.RefKeyword);
      var expression = (ExpressionSyntax)this.Visit(node.Expression);
      return node.Update(refKeyword, expression);
    }

    public override SyntaxNode VisitParenthesizedLambdaExpression(ParenthesizedLambdaExpressionSyntax node)
    {
      var asyncKeyword = this.VisitToken(node.AsyncKeyword);
      var parameterList = (ParameterListSyntax)this.Visit(node.ParameterList);
      var arrowToken = this.VisitToken(node.ArrowToken);
      var body = (CSharpSyntaxNode)this.Visit(node.Body);
      return node.Update(asyncKeyword, parameterList, arrowToken, body);
    }

    public override SyntaxNode VisitInitializerExpression(InitializerExpressionSyntax node)
    {
      var openBraceToken = this.VisitToken(node.OpenBraceToken);
      var expressions = this.VisitList(node.Expressions);
      var closeBraceToken = this.VisitToken(node.CloseBraceToken);
      return node.Update(openBraceToken, expressions, closeBraceToken);
    }

    public override SyntaxNode VisitObjectCreationExpression(ObjectCreationExpressionSyntax node)
    {
      var newKeyword = this.VisitToken(node.NewKeyword);
      var type = (TypeSyntax)this.Visit(node.Type);
      var argumentList = (ArgumentListSyntax)this.Visit(node.ArgumentList);
      var initializer = (InitializerExpressionSyntax)this.Visit(node.Initializer);
      return node.Update(newKeyword, type, argumentList, initializer);
    }

    public override SyntaxNode VisitAnonymousObjectMemberDeclarator(AnonymousObjectMemberDeclaratorSyntax node)
    {
      var nameEquals = (NameEqualsSyntax)this.Visit(node.NameEquals);
      var expression = (ExpressionSyntax)this.Visit(node.Expression);
      return node.Update(nameEquals, expression);
    }

    public override SyntaxNode VisitAnonymousObjectCreationExpression(AnonymousObjectCreationExpressionSyntax node)
    {
      var newKeyword = this.VisitToken(node.NewKeyword);
      var openBraceToken = this.VisitToken(node.OpenBraceToken);
      var initializers = this.VisitList(node.Initializers);
      var closeBraceToken = this.VisitToken(node.CloseBraceToken);
      return node.Update(newKeyword, openBraceToken, initializers, closeBraceToken);
    }

    public override SyntaxNode VisitArrayCreationExpression(ArrayCreationExpressionSyntax node)
    {
      var newKeyword = this.VisitToken(node.NewKeyword);
      var type = (ArrayTypeSyntax)this.Visit(node.Type);
      var initializer = (InitializerExpressionSyntax)this.Visit(node.Initializer);
      return node.Update(newKeyword, type, initializer);
    }

    public override SyntaxNode VisitImplicitArrayCreationExpression(ImplicitArrayCreationExpressionSyntax node)
    {
      var newKeyword = this.VisitToken(node.NewKeyword);
      var openBracketToken = this.VisitToken(node.OpenBracketToken);
      var commas = this.VisitList(node.Commas);
      var closeBracketToken = this.VisitToken(node.CloseBracketToken);
      var initializer = (InitializerExpressionSyntax)this.Visit(node.Initializer);
      return node.Update(newKeyword, openBracketToken, commas, closeBracketToken, initializer);
    }

    public override SyntaxNode VisitStackAllocArrayCreationExpression(StackAllocArrayCreationExpressionSyntax node)
    {
      var stackAllocKeyword = this.VisitToken(node.StackAllocKeyword);
      var type = (TypeSyntax)this.Visit(node.Type);
      var initializer = (InitializerExpressionSyntax)this.Visit(node.Initializer);
      return node.Update(stackAllocKeyword, type, initializer);
    }

    public override SyntaxNode VisitImplicitStackAllocArrayCreationExpression(ImplicitStackAllocArrayCreationExpressionSyntax node)
    {
      var stackAllocKeyword = this.VisitToken(node.StackAllocKeyword);
      var openBracketToken = this.VisitToken(node.OpenBracketToken);
      var closeBracketToken = this.VisitToken(node.CloseBracketToken);
      var initializer = (InitializerExpressionSyntax)this.Visit(node.Initializer);
      return node.Update(stackAllocKeyword, openBracketToken, closeBracketToken, initializer);
    }

    public override SyntaxNode VisitQueryExpression(QueryExpressionSyntax node)
    {
      var fromClause = (FromClauseSyntax)this.Visit(node.FromClause);
      var body = (QueryBodySyntax)this.Visit(node.Body);
      return node.Update(fromClause, body);
    }

    public override SyntaxNode VisitQueryBody(QueryBodySyntax node)
    {
      var clauses = this.VisitList(node.Clauses);
      var selectOrGroup = (SelectOrGroupClauseSyntax)this.Visit(node.SelectOrGroup);
      var continuation = (QueryContinuationSyntax)this.Visit(node.Continuation);
      return node.Update(clauses, selectOrGroup, continuation);
    }

    public override SyntaxNode VisitFromClause(FromClauseSyntax node)
    {
      var fromKeyword = this.VisitToken(node.FromKeyword);
      var type = (TypeSyntax)this.Visit(node.Type);
      var identifier = this.VisitToken(node.Identifier);
      var inKeyword = this.VisitToken(node.InKeyword);
      var expression = (ExpressionSyntax)this.Visit(node.Expression);
      return node.Update(fromKeyword, type, identifier, inKeyword, expression);
    }

    public override SyntaxNode VisitLetClause(LetClauseSyntax node)
    {
      var letKeyword = this.VisitToken(node.LetKeyword);
      var identifier = this.VisitToken(node.Identifier);
      var equalsToken = this.VisitToken(node.EqualsToken);
      var expression = (ExpressionSyntax)this.Visit(node.Expression);
      return node.Update(letKeyword, identifier, equalsToken, expression);
    }

    public override SyntaxNode VisitJoinClause(JoinClauseSyntax node)
    {
      var joinKeyword = this.VisitToken(node.JoinKeyword);
      var type = (TypeSyntax)this.Visit(node.Type);
      var identifier = this.VisitToken(node.Identifier);
      var inKeyword = this.VisitToken(node.InKeyword);
      var inExpression = (ExpressionSyntax)this.Visit(node.InExpression);
      var onKeyword = this.VisitToken(node.OnKeyword);
      var leftExpression = (ExpressionSyntax)this.Visit(node.LeftExpression);
      var equalsKeyword = this.VisitToken(node.EqualsKeyword);
      var rightExpression = (ExpressionSyntax)this.Visit(node.RightExpression);
      var into = (JoinIntoClauseSyntax)this.Visit(node.Into);
      return node.Update(joinKeyword, type, identifier, inKeyword, inExpression, onKeyword, leftExpression, equalsKeyword, rightExpression, into);
    }

    public override SyntaxNode VisitJoinIntoClause(JoinIntoClauseSyntax node)
    {
      var intoKeyword = this.VisitToken(node.IntoKeyword);
      var identifier = this.VisitToken(node.Identifier);
      return node.Update(intoKeyword, identifier);
    }

    public override SyntaxNode VisitWhereClause(WhereClauseSyntax node)
    {
      var whereKeyword = this.VisitToken(node.WhereKeyword);
      var condition = (ExpressionSyntax)this.Visit(node.Condition);
      return node.Update(whereKeyword, condition);
    }

    public override SyntaxNode VisitOrderByClause(OrderByClauseSyntax node)
    {
      var orderByKeyword = this.VisitToken(node.OrderByKeyword);
      var orderings = this.VisitList(node.Orderings);
      return node.Update(orderByKeyword, orderings);
    }

    public override SyntaxNode VisitOrdering(OrderingSyntax node)
    {
      var expression = (ExpressionSyntax)this.Visit(node.Expression);
      var ascendingOrDescendingKeyword = this.VisitToken(node.AscendingOrDescendingKeyword);
      return node.Update(expression, ascendingOrDescendingKeyword);
    }

    public override SyntaxNode VisitSelectClause(SelectClauseSyntax node)
    {
      var selectKeyword = this.VisitToken(node.SelectKeyword);
      var expression = (ExpressionSyntax)this.Visit(node.Expression);
      return node.Update(selectKeyword, expression);
    }

    public override SyntaxNode VisitGroupClause(GroupClauseSyntax node)
    {
      var groupKeyword = this.VisitToken(node.GroupKeyword);
      var groupExpression = (ExpressionSyntax)this.Visit(node.GroupExpression);
      var byKeyword = this.VisitToken(node.ByKeyword);
      var byExpression = (ExpressionSyntax)this.Visit(node.ByExpression);
      return node.Update(groupKeyword, groupExpression, byKeyword, byExpression);
    }

    public override SyntaxNode VisitQueryContinuation(QueryContinuationSyntax node)
    {
      var intoKeyword = this.VisitToken(node.IntoKeyword);
      var identifier = this.VisitToken(node.Identifier);
      var body = (QueryBodySyntax)this.Visit(node.Body);
      return node.Update(intoKeyword, identifier, body);
    }

    public override SyntaxNode VisitOmittedArraySizeExpression(OmittedArraySizeExpressionSyntax node)
    {
      var omittedArraySizeExpressionToken = this.VisitToken(node.OmittedArraySizeExpressionToken);
      return node.Update(omittedArraySizeExpressionToken);
    }

    public override SyntaxNode VisitInterpolatedStringExpression(InterpolatedStringExpressionSyntax node)
    {
      var stringStartToken = this.VisitToken(node.StringStartToken);
      var contents = this.VisitList(node.Contents);
      var stringEndToken = this.VisitToken(node.StringEndToken);
      return node.Update(stringStartToken, contents, stringEndToken);
    }

    public override SyntaxNode VisitIsPatternExpression(IsPatternExpressionSyntax node)
    {
      var expression = (ExpressionSyntax)this.Visit(node.Expression);
      var isKeyword = this.VisitToken(node.IsKeyword);
      var pattern = (PatternSyntax)this.Visit(node.Pattern);
      return node.Update(expression, isKeyword, pattern);
    }

    public override SyntaxNode VisitThrowExpression(ThrowExpressionSyntax node)
    {
      var throwKeyword = this.VisitToken(node.ThrowKeyword);
      var expression = (ExpressionSyntax)this.Visit(node.Expression);
      return node.Update(throwKeyword, expression);
    }

    public override SyntaxNode VisitWhenClause(WhenClauseSyntax node)
    {
      var whenKeyword = this.VisitToken(node.WhenKeyword);
      var condition = (ExpressionSyntax)this.Visit(node.Condition);
      return node.Update(whenKeyword, condition);
    }

    public override SyntaxNode VisitDiscardPattern(DiscardPatternSyntax node)
    {
      var underscoreToken = this.VisitToken(node.UnderscoreToken);
      return node.Update(underscoreToken);
    }

    public override SyntaxNode VisitDeclarationPattern(DeclarationPatternSyntax node)
    {
      var type = (TypeSyntax)this.Visit(node.Type);
      var designation = (VariableDesignationSyntax)this.Visit(node.Designation);
      return node.Update(type, designation);
    }

    public override SyntaxNode VisitVarPattern(VarPatternSyntax node)
    {
      var varKeyword = this.VisitToken(node.VarKeyword);
      var designation = (VariableDesignationSyntax)this.Visit(node.Designation);
      return node.Update(varKeyword, designation);
    }

    public override SyntaxNode VisitRecursivePattern(RecursivePatternSyntax node)
    {
      var type = (TypeSyntax)this.Visit(node.Type);
      var positionalPatternClause = (PositionalPatternClauseSyntax)this.Visit(node.PositionalPatternClause);
      var propertyPatternClause = (PropertyPatternClauseSyntax)this.Visit(node.PropertyPatternClause);
      var designation = (VariableDesignationSyntax)this.Visit(node.Designation);
      return node.Update(type, positionalPatternClause, propertyPatternClause, designation);
    }

    public override SyntaxNode VisitPositionalPatternClause(PositionalPatternClauseSyntax node)
    {
      var openParenToken = this.VisitToken(node.OpenParenToken);
      var subpatterns = this.VisitList(node.Subpatterns);
      var closeParenToken = this.VisitToken(node.CloseParenToken);
      return node.Update(openParenToken, subpatterns, closeParenToken);
    }

    public override SyntaxNode VisitPropertyPatternClause(PropertyPatternClauseSyntax node)
    {
      var openBraceToken = this.VisitToken(node.OpenBraceToken);
      var subpatterns = this.VisitList(node.Subpatterns);
      var closeBraceToken = this.VisitToken(node.CloseBraceToken);
      return node.Update(openBraceToken, subpatterns, closeBraceToken);
    }

    public override SyntaxNode VisitSubpattern(SubpatternSyntax node)
    {
      var nameColon = (NameColonSyntax)this.Visit(node.NameColon);
      var pattern = (PatternSyntax)this.Visit(node.Pattern);
      return node.Update(nameColon, pattern);
    }

    public override SyntaxNode VisitConstantPattern(ConstantPatternSyntax node)
    {
      var expression = (ExpressionSyntax)this.Visit(node.Expression);
      return node.Update(expression);
    }

    public override SyntaxNode VisitInterpolatedStringText(InterpolatedStringTextSyntax node)
    {
      var textToken = this.VisitToken(node.TextToken);
      return node.Update(textToken);
    }

    public override SyntaxNode VisitInterpolation(InterpolationSyntax node)
    {
      var openBraceToken = this.VisitToken(node.OpenBraceToken);
      var expression = (ExpressionSyntax)this.Visit(node.Expression);
      var alignmentClause = (InterpolationAlignmentClauseSyntax)this.Visit(node.AlignmentClause);
      var formatClause = (InterpolationFormatClauseSyntax)this.Visit(node.FormatClause);
      var closeBraceToken = this.VisitToken(node.CloseBraceToken);
      return node.Update(openBraceToken, expression, alignmentClause, formatClause, closeBraceToken);
    }

    public override SyntaxNode VisitInterpolationAlignmentClause(InterpolationAlignmentClauseSyntax node)
    {
      var commaToken = this.VisitToken(node.CommaToken);
      var value = (ExpressionSyntax)this.Visit(node.Value);
      return node.Update(commaToken, value);
    }

    public override SyntaxNode VisitInterpolationFormatClause(InterpolationFormatClauseSyntax node)
    {
      var colonToken = this.VisitToken(node.ColonToken);
      var formatStringToken = this.VisitToken(node.FormatStringToken);
      return node.Update(colonToken, formatStringToken);
    }

    public override SyntaxNode VisitGlobalStatement(GlobalStatementSyntax node)
    {
      var attributeLists = this.VisitList(node.AttributeLists);
      var modifiers = this.VisitList(node.Modifiers);
      var statement = (StatementSyntax)this.Visit(node.Statement);
      return node.Update(attributeLists, modifiers, statement);
    }

    public override SyntaxNode VisitBlock(BlockSyntax node)
    {
      var openBraceToken = this.VisitToken(node.OpenBraceToken);
      var statements = this.VisitList(node.Statements);
      var closeBraceToken = this.VisitToken(node.CloseBraceToken);
      return node.Update(openBraceToken, statements, closeBraceToken);
    }

    public override SyntaxNode VisitLocalFunctionStatement(LocalFunctionStatementSyntax node)
    {
      var modifiers = this.VisitList(node.Modifiers);
      var returnType = (TypeSyntax)this.Visit(node.ReturnType);
      var identifier = this.VisitToken(node.Identifier);
      var typeParameterList = (TypeParameterListSyntax)this.Visit(node.TypeParameterList);
      var parameterList = (ParameterListSyntax)this.Visit(node.ParameterList);
      var constraintClauses = this.VisitList(node.ConstraintClauses);
      var body = (BlockSyntax)this.Visit(node.Body);
      var expressionBody = (ArrowExpressionClauseSyntax)this.Visit(node.ExpressionBody);
      var semicolonToken = this.VisitToken(node.SemicolonToken);
      return node.Update(modifiers, returnType, identifier, typeParameterList, parameterList, constraintClauses, body, expressionBody, semicolonToken);
    }

    public override SyntaxNode VisitLocalDeclarationStatement(LocalDeclarationStatementSyntax node)
    {
      var awaitKeyword = this.VisitToken(node.AwaitKeyword);
      var usingKeyword = this.VisitToken(node.UsingKeyword);
      var modifiers = this.VisitList(node.Modifiers);
      var declaration = (VariableDeclarationSyntax)this.Visit(node.Declaration);
      var semicolonToken = this.VisitToken(node.SemicolonToken);
      return node.Update(awaitKeyword, usingKeyword, modifiers, declaration, semicolonToken);
    }

    public override SyntaxNode VisitVariableDeclaration(VariableDeclarationSyntax node)
    {
      var type = (TypeSyntax)this.Visit(node.Type);
      var variables = this.VisitList(node.Variables);
      return node.Update(type, variables);
    }

    public override SyntaxNode VisitVariableDeclarator(VariableDeclaratorSyntax node)
    {
      var identifier = this.VisitToken(node.Identifier);
      var argumentList = (BracketedArgumentListSyntax)this.Visit(node.ArgumentList);
      var initializer = (EqualsValueClauseSyntax)this.Visit(node.Initializer);
      return node.Update(identifier, argumentList, initializer);
    }

    public override SyntaxNode VisitEqualsValueClause(EqualsValueClauseSyntax node)
    {
      var equalsToken = this.VisitToken(node.EqualsToken);
      var value = (ExpressionSyntax)this.Visit(node.Value);
      return node.Update(equalsToken, value);
    }

    public override SyntaxNode VisitSingleVariableDesignation(SingleVariableDesignationSyntax node)
    {
      var identifier = this.VisitToken(node.Identifier);
      return node.Update(identifier);
    }

    public override SyntaxNode VisitDiscardDesignation(DiscardDesignationSyntax node)
    {
      var underscoreToken = this.VisitToken(node.UnderscoreToken);
      return node.Update(underscoreToken);
    }

    public override SyntaxNode VisitParenthesizedVariableDesignation(ParenthesizedVariableDesignationSyntax node)
    {
      var openParenToken = this.VisitToken(node.OpenParenToken);
      var variables = this.VisitList(node.Variables);
      var closeParenToken = this.VisitToken(node.CloseParenToken);
      return node.Update(openParenToken, variables, closeParenToken);
    }

    public override SyntaxNode VisitExpressionStatement(ExpressionStatementSyntax node)
    {
      var expression = (ExpressionSyntax)this.Visit(node.Expression);
      var semicolonToken = this.VisitToken(node.SemicolonToken);
      return node.Update(expression, semicolonToken);
    }

    public override SyntaxNode VisitEmptyStatement(EmptyStatementSyntax node)
    {
      var semicolonToken = this.VisitToken(node.SemicolonToken);
      return node.Update(semicolonToken);
    }

    public override SyntaxNode VisitLabeledStatement(LabeledStatementSyntax node)
    {
      var identifier = this.VisitToken(node.Identifier);
      var colonToken = this.VisitToken(node.ColonToken);
      var statement = (StatementSyntax)this.Visit(node.Statement);
      return node.Update(identifier, colonToken, statement);
    }

    public override SyntaxNode VisitGotoStatement(GotoStatementSyntax node)
    {
      var gotoKeyword = this.VisitToken(node.GotoKeyword);
      var caseOrDefaultKeyword = this.VisitToken(node.CaseOrDefaultKeyword);
      var expression = (ExpressionSyntax)this.Visit(node.Expression);
      var semicolonToken = this.VisitToken(node.SemicolonToken);
      return node.Update(gotoKeyword, caseOrDefaultKeyword, expression, semicolonToken);
    }

    public override SyntaxNode VisitBreakStatement(BreakStatementSyntax node)
    {
      var breakKeyword = this.VisitToken(node.BreakKeyword);
      var semicolonToken = this.VisitToken(node.SemicolonToken);
      return node.Update(breakKeyword, semicolonToken);
    }

    public override SyntaxNode VisitContinueStatement(ContinueStatementSyntax node)
    {
      var continueKeyword = this.VisitToken(node.ContinueKeyword);
      var semicolonToken = this.VisitToken(node.SemicolonToken);
      return node.Update(continueKeyword, semicolonToken);
    }

    public override SyntaxNode VisitReturnStatement(ReturnStatementSyntax node)
    {
      var returnKeyword = this.VisitToken(node.ReturnKeyword);
      var expression = (ExpressionSyntax)this.Visit(node.Expression);
      var semicolonToken = this.VisitToken(node.SemicolonToken);
      return node.Update(returnKeyword, expression, semicolonToken);
    }

    public override SyntaxNode VisitThrowStatement(ThrowStatementSyntax node)
    {
      var throwKeyword = this.VisitToken(node.ThrowKeyword);
      var expression = (ExpressionSyntax)this.Visit(node.Expression);
      var semicolonToken = this.VisitToken(node.SemicolonToken);
      return node.Update(throwKeyword, expression, semicolonToken);
    }

    public override SyntaxNode VisitYieldStatement(YieldStatementSyntax node)
    {
      var yieldKeyword = this.VisitToken(node.YieldKeyword);
      var returnOrBreakKeyword = this.VisitToken(node.ReturnOrBreakKeyword);
      var expression = (ExpressionSyntax)this.Visit(node.Expression);
      var semicolonToken = this.VisitToken(node.SemicolonToken);
      return node.Update(yieldKeyword, returnOrBreakKeyword, expression, semicolonToken);
    }

    public override SyntaxNode VisitWhileStatement(WhileStatementSyntax node)
    {
      var whileKeyword = this.VisitToken(node.WhileKeyword);
      var openParenToken = this.VisitToken(node.OpenParenToken);
      var condition = (ExpressionSyntax)this.Visit(node.Condition);
      var closeParenToken = this.VisitToken(node.CloseParenToken);
      var statement = (StatementSyntax)this.Visit(node.Statement);
      return node.Update(whileKeyword, openParenToken, condition, closeParenToken, statement);
    }

    public override SyntaxNode VisitDoStatement(DoStatementSyntax node)
    {
      var doKeyword = this.VisitToken(node.DoKeyword);
      var statement = (StatementSyntax)this.Visit(node.Statement);
      var whileKeyword = this.VisitToken(node.WhileKeyword);
      var openParenToken = this.VisitToken(node.OpenParenToken);
      var condition = (ExpressionSyntax)this.Visit(node.Condition);
      var closeParenToken = this.VisitToken(node.CloseParenToken);
      var semicolonToken = this.VisitToken(node.SemicolonToken);
      return node.Update(doKeyword, statement, whileKeyword, openParenToken, condition, closeParenToken, semicolonToken);
    }

    public override SyntaxNode VisitForStatement(ForStatementSyntax node)
    {
      var forKeyword = this.VisitToken(node.ForKeyword);
      var openParenToken = this.VisitToken(node.OpenParenToken);
      var declaration = (VariableDeclarationSyntax)this.Visit(node.Declaration);
      var initializers = this.VisitList(node.Initializers);
      var firstSemicolonToken = this.VisitToken(node.FirstSemicolonToken);
      var condition = (ExpressionSyntax)this.Visit(node.Condition);
      var secondSemicolonToken = this.VisitToken(node.SecondSemicolonToken);
      var incrementors = this.VisitList(node.Incrementors);
      var closeParenToken = this.VisitToken(node.CloseParenToken);
      var statement = (StatementSyntax)this.Visit(node.Statement);
      return node.Update(forKeyword, openParenToken, declaration, initializers, firstSemicolonToken, condition, secondSemicolonToken, incrementors, closeParenToken, statement);
    }

    public override SyntaxNode VisitForEachStatement(ForEachStatementSyntax node)
    {
      var awaitKeyword = this.VisitToken(node.AwaitKeyword);
      var forEachKeyword = this.VisitToken(node.ForEachKeyword);
      var openParenToken = this.VisitToken(node.OpenParenToken);
      var type = (TypeSyntax)this.Visit(node.Type);
      var identifier = this.VisitToken(node.Identifier);
      var inKeyword = this.VisitToken(node.InKeyword);
      var expression = (ExpressionSyntax)this.Visit(node.Expression);
      var closeParenToken = this.VisitToken(node.CloseParenToken);
      var statement = (StatementSyntax)this.Visit(node.Statement);
      return node.Update(awaitKeyword, forEachKeyword, openParenToken, type, identifier, inKeyword, expression, closeParenToken, statement);
    }

    public override SyntaxNode VisitForEachVariableStatement(ForEachVariableStatementSyntax node)
    {
      var awaitKeyword = this.VisitToken(node.AwaitKeyword);
      var forEachKeyword = this.VisitToken(node.ForEachKeyword);
      var openParenToken = this.VisitToken(node.OpenParenToken);
      var variable = (ExpressionSyntax)this.Visit(node.Variable);
      var inKeyword = this.VisitToken(node.InKeyword);
      var expression = (ExpressionSyntax)this.Visit(node.Expression);
      var closeParenToken = this.VisitToken(node.CloseParenToken);
      var statement = (StatementSyntax)this.Visit(node.Statement);
      return node.Update(awaitKeyword, forEachKeyword, openParenToken, variable, inKeyword, expression, closeParenToken, statement);
    }

    public override SyntaxNode VisitUsingStatement(UsingStatementSyntax node)
    {
      var awaitKeyword = this.VisitToken(node.AwaitKeyword);
      var usingKeyword = this.VisitToken(node.UsingKeyword);
      var openParenToken = this.VisitToken(node.OpenParenToken);
      var declaration = (VariableDeclarationSyntax)this.Visit(node.Declaration);
      var expression = (ExpressionSyntax)this.Visit(node.Expression);
      var closeParenToken = this.VisitToken(node.CloseParenToken);
      var statement = (StatementSyntax)this.Visit(node.Statement);
      return node.Update(awaitKeyword, usingKeyword, openParenToken, declaration, expression, closeParenToken, statement);
    }

    public override SyntaxNode VisitFixedStatement(FixedStatementSyntax node)
    {
      var fixedKeyword = this.VisitToken(node.FixedKeyword);
      var openParenToken = this.VisitToken(node.OpenParenToken);
      var declaration = (VariableDeclarationSyntax)this.Visit(node.Declaration);
      var closeParenToken = this.VisitToken(node.CloseParenToken);
      var statement = (StatementSyntax)this.Visit(node.Statement);
      return node.Update(fixedKeyword, openParenToken, declaration, closeParenToken, statement);
    }

    public override SyntaxNode VisitCheckedStatement(CheckedStatementSyntax node)
    {
      var keyword = this.VisitToken(node.Keyword);
      var block = (BlockSyntax)this.Visit(node.Block);
      return node.Update(keyword, block);
    }

    public override SyntaxNode VisitUnsafeStatement(UnsafeStatementSyntax node)
    {
      var unsafeKeyword = this.VisitToken(node.UnsafeKeyword);
      var block = (BlockSyntax)this.Visit(node.Block);
      return node.Update(unsafeKeyword, block);
    }

    public override SyntaxNode VisitLockStatement(LockStatementSyntax node)
    {
      var lockKeyword = this.VisitToken(node.LockKeyword);
      var openParenToken = this.VisitToken(node.OpenParenToken);
      var expression = (ExpressionSyntax)this.Visit(node.Expression);
      var closeParenToken = this.VisitToken(node.CloseParenToken);
      var statement = (StatementSyntax)this.Visit(node.Statement);
      return node.Update(lockKeyword, openParenToken, expression, closeParenToken, statement);
    }

    public override SyntaxNode VisitIfStatement(IfStatementSyntax node)
    {
      var ifKeyword = this.VisitToken(node.IfKeyword);
      var openParenToken = this.VisitToken(node.OpenParenToken);
      var condition = (ExpressionSyntax)this.Visit(node.Condition);
      var closeParenToken = this.VisitToken(node.CloseParenToken);
      var statement = (StatementSyntax)this.Visit(node.Statement);
      var @else = (ElseClauseSyntax)this.Visit(node.Else);
      return node.Update(ifKeyword, openParenToken, condition, closeParenToken, statement, @else);
    }

    public override SyntaxNode VisitElseClause(ElseClauseSyntax node)
    {
      var elseKeyword = this.VisitToken(node.ElseKeyword);
      var statement = (StatementSyntax)this.Visit(node.Statement);
      return node.Update(elseKeyword, statement);
    }

    public override SyntaxNode VisitSwitchStatement(SwitchStatementSyntax node)
    {
      var switchKeyword = this.VisitToken(node.SwitchKeyword);
      var openParenToken = this.VisitToken(node.OpenParenToken);
      var expression = (ExpressionSyntax)this.Visit(node.Expression);
      var closeParenToken = this.VisitToken(node.CloseParenToken);
      var openBraceToken = this.VisitToken(node.OpenBraceToken);
      var sections = this.VisitList(node.Sections);
      var closeBraceToken = this.VisitToken(node.CloseBraceToken);
      return node.Update(switchKeyword, openParenToken, expression, closeParenToken, openBraceToken, sections, closeBraceToken);
    }

    public override SyntaxNode VisitSwitchSection(SwitchSectionSyntax node)
    {
      var labels = this.VisitList(node.Labels);
      var statements = this.VisitList(node.Statements);
      return node.Update(labels, statements);
    }

    public override SyntaxNode VisitCasePatternSwitchLabel(CasePatternSwitchLabelSyntax node)
    {
      var keyword = this.VisitToken(node.Keyword);
      var pattern = (PatternSyntax)this.Visit(node.Pattern);
      var whenClause = (WhenClauseSyntax)this.Visit(node.WhenClause);
      var colonToken = this.VisitToken(node.ColonToken);
      return node.Update(keyword, pattern, whenClause, colonToken);
    }

    public override SyntaxNode VisitCaseSwitchLabel(CaseSwitchLabelSyntax node)
    {
      var keyword = this.VisitToken(node.Keyword);
      var value = (ExpressionSyntax)this.Visit(node.Value);
      var colonToken = this.VisitToken(node.ColonToken);
      return node.Update(keyword, value, colonToken);
    }

    public override SyntaxNode VisitDefaultSwitchLabel(DefaultSwitchLabelSyntax node)
    {
      var keyword = this.VisitToken(node.Keyword);
      var colonToken = this.VisitToken(node.ColonToken);
      return node.Update(keyword, colonToken);
    }

    public override SyntaxNode VisitSwitchExpression(SwitchExpressionSyntax node)
    {
      var governingExpression = (ExpressionSyntax)this.Visit(node.GoverningExpression);
      var switchKeyword = this.VisitToken(node.SwitchKeyword);
      var openBraceToken = this.VisitToken(node.OpenBraceToken);
      var arms = this.VisitList(node.Arms);
      var closeBraceToken = this.VisitToken(node.CloseBraceToken);
      return node.Update(governingExpression, switchKeyword, openBraceToken, arms, closeBraceToken);
    }

    public override SyntaxNode VisitSwitchExpressionArm(SwitchExpressionArmSyntax node)
    {
      var pattern = (PatternSyntax)this.Visit(node.Pattern);
      var whenClause = (WhenClauseSyntax)this.Visit(node.WhenClause);
      var equalsGreaterThanToken = this.VisitToken(node.EqualsGreaterThanToken);
      var expression = (ExpressionSyntax)this.Visit(node.Expression);
      return node.Update(pattern, whenClause, equalsGreaterThanToken, expression);
    }

    public override SyntaxNode VisitTryStatement(TryStatementSyntax node)
    {
      var tryKeyword = this.VisitToken(node.TryKeyword);
      var block = (BlockSyntax)this.Visit(node.Block);
      var catches = this.VisitList(node.Catches);
      var @finally = (FinallyClauseSyntax)this.Visit(node.Finally);
      return node.Update(tryKeyword, block, catches, @finally);
    }

    public override SyntaxNode VisitCatchClause(CatchClauseSyntax node)
    {
      var catchKeyword = this.VisitToken(node.CatchKeyword);
      var declaration = (CatchDeclarationSyntax)this.Visit(node.Declaration);
      var filter = (CatchFilterClauseSyntax)this.Visit(node.Filter);
      var block = (BlockSyntax)this.Visit(node.Block);
      return node.Update(catchKeyword, declaration, filter, block);
    }

    public override SyntaxNode VisitCatchDeclaration(CatchDeclarationSyntax node)
    {
      var openParenToken = this.VisitToken(node.OpenParenToken);
      var type = (TypeSyntax)this.Visit(node.Type);
      var identifier = this.VisitToken(node.Identifier);
      var closeParenToken = this.VisitToken(node.CloseParenToken);
      return node.Update(openParenToken, type, identifier, closeParenToken);
    }

    public override SyntaxNode VisitCatchFilterClause(CatchFilterClauseSyntax node)
    {
      var whenKeyword = this.VisitToken(node.WhenKeyword);
      var openParenToken = this.VisitToken(node.OpenParenToken);
      var filterExpression = (ExpressionSyntax)this.Visit(node.FilterExpression);
      var closeParenToken = this.VisitToken(node.CloseParenToken);
      return node.Update(whenKeyword, openParenToken, filterExpression, closeParenToken);
    }

    public override SyntaxNode VisitFinallyClause(FinallyClauseSyntax node)
    {
      var finallyKeyword = this.VisitToken(node.FinallyKeyword);
      var block = (BlockSyntax)this.Visit(node.Block);
      return node.Update(finallyKeyword, block);
    }

    public override SyntaxNode VisitCompilationUnit(CompilationUnitSyntax node)
    {
      var externs = this.VisitList(node.Externs);
      var usings = this.VisitList(node.Usings);
      var attributeLists = this.VisitList(node.AttributeLists);
      var members = this.VisitList(node.Members);
      var endOfFileToken = this.VisitToken(node.EndOfFileToken);
      return node.Update(externs, usings, attributeLists, members, endOfFileToken);
    }

    public override SyntaxNode VisitExternAliasDirective(ExternAliasDirectiveSyntax node)
    {
      var externKeyword = this.VisitToken(node.ExternKeyword);
      var aliasKeyword = this.VisitToken(node.AliasKeyword);
      var identifier = this.VisitToken(node.Identifier);
      var semicolonToken = this.VisitToken(node.SemicolonToken);
      return node.Update(externKeyword, aliasKeyword, identifier, semicolonToken);
    }

    public override SyntaxNode VisitUsingDirective(UsingDirectiveSyntax node)
    {
      var usingKeyword = this.VisitToken(node.UsingKeyword);
      var staticKeyword = this.VisitToken(node.StaticKeyword);
      var alias = (NameEqualsSyntax)this.Visit(node.Alias);
      var name = (NameSyntax)this.Visit(node.Name);
      var semicolonToken = this.VisitToken(node.SemicolonToken);
      return node.Update(usingKeyword, staticKeyword, alias, name, semicolonToken);
    }

    public override SyntaxNode VisitNamespaceDeclaration(NamespaceDeclarationSyntax node)
    {
      var attributeLists = this.VisitList(node.AttributeLists);
      var modifiers = this.VisitList(node.Modifiers);
      var namespaceKeyword = this.VisitToken(node.NamespaceKeyword);
      var name = (NameSyntax)this.Visit(node.Name);
      var openBraceToken = this.VisitToken(node.OpenBraceToken);
      var externs = this.VisitList(node.Externs);
      var usings = this.VisitList(node.Usings);
      var members = this.VisitList(node.Members);
      var closeBraceToken = this.VisitToken(node.CloseBraceToken);
      var semicolonToken = this.VisitToken(node.SemicolonToken);
      return node.Update(attributeLists, modifiers, namespaceKeyword, name, openBraceToken, externs, usings, members, closeBraceToken, semicolonToken);
    }

    public override SyntaxNode VisitAttributeList(AttributeListSyntax node)
    {
      var openBracketToken = this.VisitToken(node.OpenBracketToken);
      var target = (AttributeTargetSpecifierSyntax)this.Visit(node.Target);
      var attributes = this.VisitList(node.Attributes);
      var closeBracketToken = this.VisitToken(node.CloseBracketToken);
      return node.Update(openBracketToken, target, attributes, closeBracketToken);
    }

    public override SyntaxNode VisitAttributeTargetSpecifier(AttributeTargetSpecifierSyntax node)
    {
      var identifier = this.VisitToken(node.Identifier);
      var colonToken = this.VisitToken(node.ColonToken);
      return node.Update(identifier, colonToken);
    }

    public override SyntaxNode VisitAttribute(AttributeSyntax node)
    {
      var name = (NameSyntax)this.Visit(node.Name);
      var argumentList = (AttributeArgumentListSyntax)this.Visit(node.ArgumentList);
      return node.Update(name, argumentList);
    }

    public override SyntaxNode VisitAttributeArgumentList(AttributeArgumentListSyntax node)
    {
      var openParenToken = this.VisitToken(node.OpenParenToken);
      var arguments = this.VisitList(node.Arguments);
      var closeParenToken = this.VisitToken(node.CloseParenToken);
      return node.Update(openParenToken, arguments, closeParenToken);
    }

    public override SyntaxNode VisitAttributeArgument(AttributeArgumentSyntax node)
    {
      var nameEquals = (NameEqualsSyntax)this.Visit(node.NameEquals);
      var nameColon = (NameColonSyntax)this.Visit(node.NameColon);
      var expression = (ExpressionSyntax)this.Visit(node.Expression);
      return node.Update(nameEquals, nameColon, expression);
    }

    public override SyntaxNode VisitNameEquals(NameEqualsSyntax node)
    {
      var name = (IdentifierNameSyntax)this.Visit(node.Name);
      var equalsToken = this.VisitToken(node.EqualsToken);
      return node.Update(name, equalsToken);
    }

    public override SyntaxNode VisitTypeParameterList(TypeParameterListSyntax node)
    {
      var lessThanToken = this.VisitToken(node.LessThanToken);
      var parameters = this.VisitList(node.Parameters);
      var greaterThanToken = this.VisitToken(node.GreaterThanToken);
      return node.Update(lessThanToken, parameters, greaterThanToken);
    }

    public override SyntaxNode VisitTypeParameter(TypeParameterSyntax node)
    {
      var attributeLists = this.VisitList(node.AttributeLists);
      var varianceKeyword = this.VisitToken(node.VarianceKeyword);
      var identifier = this.VisitToken(node.Identifier);
      return node.Update(attributeLists, varianceKeyword, identifier);
    }

    public override SyntaxNode VisitClassDeclaration(ClassDeclarationSyntax node)
    {
      var attributeLists = this.VisitList(node.AttributeLists);
      var modifiers = this.VisitList(node.Modifiers);
      var keyword = this.VisitToken(node.Keyword);
      var identifier = this.VisitToken(node.Identifier);
      var typeParameterList = (TypeParameterListSyntax)this.Visit(node.TypeParameterList);
      var baseList = (BaseListSyntax)this.Visit(node.BaseList);
      var constraintClauses = this.VisitList(node.ConstraintClauses);
      var openBraceToken = this.VisitToken(node.OpenBraceToken);
      var members = this.VisitList(node.Members);
      var closeBraceToken = this.VisitToken(node.CloseBraceToken);
      var semicolonToken = this.VisitToken(node.SemicolonToken);
      return node.Update(attributeLists, modifiers, keyword, identifier, typeParameterList, baseList, constraintClauses, openBraceToken, members, closeBraceToken, semicolonToken);
    }

    public override SyntaxNode VisitStructDeclaration(StructDeclarationSyntax node)
    {
      var attributeLists = this.VisitList(node.AttributeLists);
      var modifiers = this.VisitList(node.Modifiers);
      var keyword = this.VisitToken(node.Keyword);
      var identifier = this.VisitToken(node.Identifier);
      var typeParameterList = (TypeParameterListSyntax)this.Visit(node.TypeParameterList);
      var baseList = (BaseListSyntax)this.Visit(node.BaseList);
      var constraintClauses = this.VisitList(node.ConstraintClauses);
      var openBraceToken = this.VisitToken(node.OpenBraceToken);
      var members = this.VisitList(node.Members);
      var closeBraceToken = this.VisitToken(node.CloseBraceToken);
      var semicolonToken = this.VisitToken(node.SemicolonToken);
      return node.Update(attributeLists, modifiers, keyword, identifier, typeParameterList, baseList, constraintClauses, openBraceToken, members, closeBraceToken, semicolonToken);
    }

    public override SyntaxNode VisitInterfaceDeclaration(InterfaceDeclarationSyntax node)
    {
      var attributeLists = this.VisitList(node.AttributeLists);
      var modifiers = this.VisitList(node.Modifiers);
      var keyword = this.VisitToken(node.Keyword);
      var identifier = this.VisitToken(node.Identifier);
      var typeParameterList = (TypeParameterListSyntax)this.Visit(node.TypeParameterList);
      var baseList = (BaseListSyntax)this.Visit(node.BaseList);
      var constraintClauses = this.VisitList(node.ConstraintClauses);
      var openBraceToken = this.VisitToken(node.OpenBraceToken);
      var members = this.VisitList(node.Members);
      var closeBraceToken = this.VisitToken(node.CloseBraceToken);
      var semicolonToken = this.VisitToken(node.SemicolonToken);
      return node.Update(attributeLists, modifiers, keyword, identifier, typeParameterList, baseList, constraintClauses, openBraceToken, members, closeBraceToken, semicolonToken);
    }

    public override SyntaxNode VisitEnumDeclaration(EnumDeclarationSyntax node)
    {
      var attributeLists = this.VisitList(node.AttributeLists);
      var modifiers = this.VisitList(node.Modifiers);
      var enumKeyword = this.VisitToken(node.EnumKeyword);
      var identifier = this.VisitToken(node.Identifier);
      var baseList = (BaseListSyntax)this.Visit(node.BaseList);
      var openBraceToken = this.VisitToken(node.OpenBraceToken);
      var members = this.VisitList(node.Members);
      var closeBraceToken = this.VisitToken(node.CloseBraceToken);
      var semicolonToken = this.VisitToken(node.SemicolonToken);
      return node.Update(attributeLists, modifiers, enumKeyword, identifier, baseList, openBraceToken, members, closeBraceToken, semicolonToken);
    }

    public override SyntaxNode VisitDelegateDeclaration(DelegateDeclarationSyntax node)
    {
      var attributeLists = this.VisitList(node.AttributeLists);
      var modifiers = this.VisitList(node.Modifiers);
      var delegateKeyword = this.VisitToken(node.DelegateKeyword);
      var returnType = (TypeSyntax)this.Visit(node.ReturnType);
      var identifier = this.VisitToken(node.Identifier);
      var typeParameterList = (TypeParameterListSyntax)this.Visit(node.TypeParameterList);
      var parameterList = (ParameterListSyntax)this.Visit(node.ParameterList);
      var constraintClauses = this.VisitList(node.ConstraintClauses);
      var semicolonToken = this.VisitToken(node.SemicolonToken);
      return node.Update(attributeLists, modifiers, delegateKeyword, returnType, identifier, typeParameterList, parameterList, constraintClauses, semicolonToken);
    }

    public override SyntaxNode VisitEnumMemberDeclaration(EnumMemberDeclarationSyntax node)
    {
      var attributeLists = this.VisitList(node.AttributeLists);
      var modifiers = this.VisitList(node.Modifiers);
      var identifier = this.VisitToken(node.Identifier);
      var equalsValue = (EqualsValueClauseSyntax)this.Visit(node.EqualsValue);
      return node.Update(attributeLists, modifiers, identifier, equalsValue);
    }

    public override SyntaxNode VisitBaseList(BaseListSyntax node)
    {
      var colonToken = this.VisitToken(node.ColonToken);
      var types = this.VisitList(node.Types);
      return node.Update(colonToken, types);
    }

    public override SyntaxNode VisitSimpleBaseType(SimpleBaseTypeSyntax node)
    {
      var type = (TypeSyntax)this.Visit(node.Type);
      return node.Update(type);
    }

    public override SyntaxNode VisitTypeParameterConstraintClause(TypeParameterConstraintClauseSyntax node)
    {
      var whereKeyword = this.VisitToken(node.WhereKeyword);
      var name = (IdentifierNameSyntax)this.Visit(node.Name);
      var colonToken = this.VisitToken(node.ColonToken);
      var constraints = this.VisitList(node.Constraints);
      return node.Update(whereKeyword, name, colonToken, constraints);
    }

    public override SyntaxNode VisitConstructorConstraint(ConstructorConstraintSyntax node)
    {
      var newKeyword = this.VisitToken(node.NewKeyword);
      var openParenToken = this.VisitToken(node.OpenParenToken);
      var closeParenToken = this.VisitToken(node.CloseParenToken);
      return node.Update(newKeyword, openParenToken, closeParenToken);
    }

    public override SyntaxNode VisitClassOrStructConstraint(ClassOrStructConstraintSyntax node)
    {
      var classOrStructKeyword = this.VisitToken(node.ClassOrStructKeyword);
      var questionToken = this.VisitToken(node.QuestionToken);
      return node.Update(classOrStructKeyword, questionToken);
    }

    public override SyntaxNode VisitTypeConstraint(TypeConstraintSyntax node)
    {
      var type = (TypeSyntax)this.Visit(node.Type);
      return node.Update(type);
    }

    public override SyntaxNode VisitFieldDeclaration(FieldDeclarationSyntax node)
    {
      var attributeLists = this.VisitList(node.AttributeLists);
      var modifiers = this.VisitList(node.Modifiers);
      var declaration = (VariableDeclarationSyntax)this.Visit(node.Declaration);
      var semicolonToken = this.VisitToken(node.SemicolonToken);
      return node.Update(attributeLists, modifiers, declaration, semicolonToken);
    }

    public override SyntaxNode VisitEventFieldDeclaration(EventFieldDeclarationSyntax node)
    {
      var attributeLists = this.VisitList(node.AttributeLists);
      var modifiers = this.VisitList(node.Modifiers);
      var eventKeyword = this.VisitToken(node.EventKeyword);
      var declaration = (VariableDeclarationSyntax)this.Visit(node.Declaration);
      var semicolonToken = this.VisitToken(node.SemicolonToken);
      return node.Update(attributeLists, modifiers, eventKeyword, declaration, semicolonToken);
    }

    public override SyntaxNode VisitExplicitInterfaceSpecifier(ExplicitInterfaceSpecifierSyntax node)
    {
      var name = (NameSyntax)this.Visit(node.Name);
      var dotToken = this.VisitToken(node.DotToken);
      return node.Update(name, dotToken);
    }

    public override SyntaxNode VisitMethodDeclaration(MethodDeclarationSyntax node)
    {
      var attributeLists = this.VisitList(node.AttributeLists);
      var modifiers = this.VisitList(node.Modifiers);
      var returnType = (TypeSyntax)this.Visit(node.ReturnType);
      var explicitInterfaceSpecifier = (ExplicitInterfaceSpecifierSyntax)this.Visit(node.ExplicitInterfaceSpecifier);
      var identifier = this.VisitToken(node.Identifier);
      var typeParameterList = (TypeParameterListSyntax)this.Visit(node.TypeParameterList);
      var parameterList = (ParameterListSyntax)this.Visit(node.ParameterList);
      var constraintClauses = this.VisitList(node.ConstraintClauses);
      var body = (BlockSyntax)this.Visit(node.Body);
      var expressionBody = (ArrowExpressionClauseSyntax)this.Visit(node.ExpressionBody);
      var semicolonToken = this.VisitToken(node.SemicolonToken);
      return node.Update(attributeLists, modifiers, returnType, explicitInterfaceSpecifier, identifier, typeParameterList, parameterList, constraintClauses, body, expressionBody, semicolonToken);
    }

    public override SyntaxNode VisitOperatorDeclaration(OperatorDeclarationSyntax node)
    {
      var attributeLists = this.VisitList(node.AttributeLists);
      var modifiers = this.VisitList(node.Modifiers);
      var returnType = (TypeSyntax)this.Visit(node.ReturnType);
      var operatorKeyword = this.VisitToken(node.OperatorKeyword);
      var operatorToken = this.VisitToken(node.OperatorToken);
      var parameterList = (ParameterListSyntax)this.Visit(node.ParameterList);
      var body = (BlockSyntax)this.Visit(node.Body);
      var expressionBody = (ArrowExpressionClauseSyntax)this.Visit(node.ExpressionBody);
      var semicolonToken = this.VisitToken(node.SemicolonToken);
      return node.Update(attributeLists, modifiers, returnType, operatorKeyword, operatorToken, parameterList, body, expressionBody, semicolonToken);
    }

    public override SyntaxNode VisitConversionOperatorDeclaration(ConversionOperatorDeclarationSyntax node)
    {
      var attributeLists = this.VisitList(node.AttributeLists);
      var modifiers = this.VisitList(node.Modifiers);
      var implicitOrExplicitKeyword = this.VisitToken(node.ImplicitOrExplicitKeyword);
      var operatorKeyword = this.VisitToken(node.OperatorKeyword);
      var type = (TypeSyntax)this.Visit(node.Type);
      var parameterList = (ParameterListSyntax)this.Visit(node.ParameterList);
      var body = (BlockSyntax)this.Visit(node.Body);
      var expressionBody = (ArrowExpressionClauseSyntax)this.Visit(node.ExpressionBody);
      var semicolonToken = this.VisitToken(node.SemicolonToken);
      return node.Update(attributeLists, modifiers, implicitOrExplicitKeyword, operatorKeyword, type, parameterList, body, expressionBody, semicolonToken);
    }

    public override SyntaxNode VisitConstructorDeclaration(ConstructorDeclarationSyntax node)
    {
      var attributeLists = this.VisitList(node.AttributeLists);
      var modifiers = this.VisitList(node.Modifiers);
      var identifier = this.VisitToken(node.Identifier);
      var parameterList = (ParameterListSyntax)this.Visit(node.ParameterList);
      var initializer = (ConstructorInitializerSyntax)this.Visit(node.Initializer);
      var body = (BlockSyntax)this.Visit(node.Body);
      var expressionBody = (ArrowExpressionClauseSyntax)this.Visit(node.ExpressionBody);
      var semicolonToken = this.VisitToken(node.SemicolonToken);
      return node.Update(attributeLists, modifiers, identifier, parameterList, initializer, body, expressionBody, semicolonToken);
    }

    public override SyntaxNode VisitConstructorInitializer(ConstructorInitializerSyntax node)
    {
      var colonToken = this.VisitToken(node.ColonToken);
      var thisOrBaseKeyword = this.VisitToken(node.ThisOrBaseKeyword);
      var argumentList = (ArgumentListSyntax)this.Visit(node.ArgumentList);
      return node.Update(colonToken, thisOrBaseKeyword, argumentList);
    }

    public override SyntaxNode VisitDestructorDeclaration(DestructorDeclarationSyntax node)
    {
      var attributeLists = this.VisitList(node.AttributeLists);
      var modifiers = this.VisitList(node.Modifiers);
      var tildeToken = this.VisitToken(node.TildeToken);
      var identifier = this.VisitToken(node.Identifier);
      var parameterList = (ParameterListSyntax)this.Visit(node.ParameterList);
      var body = (BlockSyntax)this.Visit(node.Body);
      var expressionBody = (ArrowExpressionClauseSyntax)this.Visit(node.ExpressionBody);
      var semicolonToken = this.VisitToken(node.SemicolonToken);
      return node.Update(attributeLists, modifiers, tildeToken, identifier, parameterList, body, expressionBody, semicolonToken);
    }

    public override SyntaxNode VisitPropertyDeclaration(PropertyDeclarationSyntax node)
    {
      var attributeLists = this.VisitList(node.AttributeLists);
      var modifiers = this.VisitList(node.Modifiers);
      var type = (TypeSyntax)this.Visit(node.Type);
      var explicitInterfaceSpecifier = (ExplicitInterfaceSpecifierSyntax)this.Visit(node.ExplicitInterfaceSpecifier);
      var identifier = this.VisitToken(node.Identifier);
      var accessorList = (AccessorListSyntax)this.Visit(node.AccessorList);
      var expressionBody = (ArrowExpressionClauseSyntax)this.Visit(node.ExpressionBody);
      var initializer = (EqualsValueClauseSyntax)this.Visit(node.Initializer);
      var semicolonToken = this.VisitToken(node.SemicolonToken);
      return node.Update(attributeLists, modifiers, type, explicitInterfaceSpecifier, identifier, accessorList, expressionBody, initializer, semicolonToken);
    }

    public override SyntaxNode VisitArrowExpressionClause(ArrowExpressionClauseSyntax node)
    {
      var arrowToken = this.VisitToken(node.ArrowToken);
      var expression = (ExpressionSyntax)this.Visit(node.Expression);
      return node.Update(arrowToken, expression);
    }

    public override SyntaxNode VisitEventDeclaration(EventDeclarationSyntax node)
    {
      var attributeLists = this.VisitList(node.AttributeLists);
      var modifiers = this.VisitList(node.Modifiers);
      var eventKeyword = this.VisitToken(node.EventKeyword);
      var type = (TypeSyntax)this.Visit(node.Type);
      var explicitInterfaceSpecifier = (ExplicitInterfaceSpecifierSyntax)this.Visit(node.ExplicitInterfaceSpecifier);
      var identifier = this.VisitToken(node.Identifier);
      var accessorList = (AccessorListSyntax)this.Visit(node.AccessorList);
      var semicolonToken = this.VisitToken(node.SemicolonToken);
      return node.Update(attributeLists, modifiers, eventKeyword, type, explicitInterfaceSpecifier, identifier, accessorList, semicolonToken);
    }

    public override SyntaxNode VisitIndexerDeclaration(IndexerDeclarationSyntax node)
    {
      var attributeLists = this.VisitList(node.AttributeLists);
      var modifiers = this.VisitList(node.Modifiers);
      var type = (TypeSyntax)this.Visit(node.Type);
      var explicitInterfaceSpecifier = (ExplicitInterfaceSpecifierSyntax)this.Visit(node.ExplicitInterfaceSpecifier);
      var thisKeyword = this.VisitToken(node.ThisKeyword);
      var parameterList = (BracketedParameterListSyntax)this.Visit(node.ParameterList);
      var accessorList = (AccessorListSyntax)this.Visit(node.AccessorList);
      var expressionBody = (ArrowExpressionClauseSyntax)this.Visit(node.ExpressionBody);
      var semicolonToken = this.VisitToken(node.SemicolonToken);
      return node.Update(attributeLists, modifiers, type, explicitInterfaceSpecifier, thisKeyword, parameterList, accessorList, expressionBody, semicolonToken);
    }

    public override SyntaxNode VisitAccessorList(AccessorListSyntax node)
    {
      var openBraceToken = this.VisitToken(node.OpenBraceToken);
      var accessors = this.VisitList(node.Accessors);
      var closeBraceToken = this.VisitToken(node.CloseBraceToken);
      return node.Update(openBraceToken, accessors, closeBraceToken);
    }

    public override SyntaxNode VisitAccessorDeclaration(AccessorDeclarationSyntax node)
    {
      var attributeLists = this.VisitList(node.AttributeLists);
      var modifiers = this.VisitList(node.Modifiers);
      var keyword = this.VisitToken(node.Keyword);
      var body = (BlockSyntax)this.Visit(node.Body);
      var expressionBody = (ArrowExpressionClauseSyntax)this.Visit(node.ExpressionBody);
      var semicolonToken = this.VisitToken(node.SemicolonToken);
      return node.Update(attributeLists, modifiers, keyword, body, expressionBody, semicolonToken);
    }

    public override SyntaxNode VisitParameterList(ParameterListSyntax node)
    {
      var openParenToken = this.VisitToken(node.OpenParenToken);
      var parameters = this.VisitList(node.Parameters);
      var closeParenToken = this.VisitToken(node.CloseParenToken);
      return node.Update(openParenToken, parameters, closeParenToken);
    }

    public override SyntaxNode VisitBracketedParameterList(BracketedParameterListSyntax node)
    {
      var openBracketToken = this.VisitToken(node.OpenBracketToken);
      var parameters = this.VisitList(node.Parameters);
      var closeBracketToken = this.VisitToken(node.CloseBracketToken);
      return node.Update(openBracketToken, parameters, closeBracketToken);
    }

    public override SyntaxNode VisitParameter(ParameterSyntax node)
    {
      var attributeLists = this.VisitList(node.AttributeLists);
      var modifiers = this.VisitList(node.Modifiers);
      var type = (TypeSyntax)this.Visit(node.Type);
      var identifier = this.VisitToken(node.Identifier);
      var exclamationToken = this.VisitToken(node.ExclamationToken);
      var @default = (EqualsValueClauseSyntax)this.Visit(node.Default);
      return node.Update(attributeLists, modifiers, type, identifier, exclamationToken, @default);
    }

    public override SyntaxNode VisitIncompleteMember(IncompleteMemberSyntax node)
    {
      var attributeLists = this.VisitList(node.AttributeLists);
      var modifiers = this.VisitList(node.Modifiers);
      var type = (TypeSyntax)this.Visit(node.Type);
      return node.Update(attributeLists, modifiers, type);
    }

    public override SyntaxNode VisitSkippedTokensTrivia(SkippedTokensTriviaSyntax node)
    {
      var tokens = this.VisitList(node.Tokens);
      return node.Update(tokens);
    }

    public override SyntaxNode VisitDocumentationCommentTrivia(DocumentationCommentTriviaSyntax node)
    {
      var content = this.VisitList(node.Content);
      var endOfComment = this.VisitToken(node.EndOfComment);
      return node.Update(content, endOfComment);
    }

    public override SyntaxNode VisitTypeCref(TypeCrefSyntax node)
    {
      var type = (TypeSyntax)this.Visit(node.Type);
      return node.Update(type);
    }

    public override SyntaxNode VisitQualifiedCref(QualifiedCrefSyntax node)
    {
      var container = (TypeSyntax)this.Visit(node.Container);
      var dotToken = this.VisitToken(node.DotToken);
      var member = (MemberCrefSyntax)this.Visit(node.Member);
      return node.Update(container, dotToken, member);
    }

    public override SyntaxNode VisitNameMemberCref(NameMemberCrefSyntax node)
    {
      var name = (TypeSyntax)this.Visit(node.Name);
      var parameters = (CrefParameterListSyntax)this.Visit(node.Parameters);
      return node.Update(name, parameters);
    }

    public override SyntaxNode VisitIndexerMemberCref(IndexerMemberCrefSyntax node)
    {
      var thisKeyword = this.VisitToken(node.ThisKeyword);
      var parameters = (CrefBracketedParameterListSyntax)this.Visit(node.Parameters);
      return node.Update(thisKeyword, parameters);
    }

    public override SyntaxNode VisitOperatorMemberCref(OperatorMemberCrefSyntax node)
    {
      var operatorKeyword = this.VisitToken(node.OperatorKeyword);
      var operatorToken = this.VisitToken(node.OperatorToken);
      var parameters = (CrefParameterListSyntax)this.Visit(node.Parameters);
      return node.Update(operatorKeyword, operatorToken, parameters);
    }

    public override SyntaxNode VisitConversionOperatorMemberCref(ConversionOperatorMemberCrefSyntax node)
    {
      var implicitOrExplicitKeyword = this.VisitToken(node.ImplicitOrExplicitKeyword);
      var operatorKeyword = this.VisitToken(node.OperatorKeyword);
      var type = (TypeSyntax)this.Visit(node.Type);
      var parameters = (CrefParameterListSyntax)this.Visit(node.Parameters);
      return node.Update(implicitOrExplicitKeyword, operatorKeyword, type, parameters);
    }

    public override SyntaxNode VisitCrefParameterList(CrefParameterListSyntax node)
    {
      var openParenToken = this.VisitToken(node.OpenParenToken);
      var parameters = this.VisitList(node.Parameters);
      var closeParenToken = this.VisitToken(node.CloseParenToken);
      return node.Update(openParenToken, parameters, closeParenToken);
    }

    public override SyntaxNode VisitCrefBracketedParameterList(CrefBracketedParameterListSyntax node)
    {
      var openBracketToken = this.VisitToken(node.OpenBracketToken);
      var parameters = this.VisitList(node.Parameters);
      var closeBracketToken = this.VisitToken(node.CloseBracketToken);
      return node.Update(openBracketToken, parameters, closeBracketToken);
    }

    public override SyntaxNode VisitCrefParameter(CrefParameterSyntax node)
    {
      var refKindKeyword = this.VisitToken(node.RefKindKeyword);
      var type = (TypeSyntax)this.Visit(node.Type);
      return node.Update(refKindKeyword, type);
    }

    public override SyntaxNode VisitXmlElement(XmlElementSyntax node)
    {
      var startTag = (XmlElementStartTagSyntax)this.Visit(node.StartTag);
      var content = this.VisitList(node.Content);
      var endTag = (XmlElementEndTagSyntax)this.Visit(node.EndTag);
      return node.Update(startTag, content, endTag);
    }

    public override SyntaxNode VisitXmlElementStartTag(XmlElementStartTagSyntax node)
    {
      var lessThanToken = this.VisitToken(node.LessThanToken);
      var name = (XmlNameSyntax)this.Visit(node.Name);
      var attributes = this.VisitList(node.Attributes);
      var greaterThanToken = this.VisitToken(node.GreaterThanToken);
      return node.Update(lessThanToken, name, attributes, greaterThanToken);
    }

    public override SyntaxNode VisitXmlElementEndTag(XmlElementEndTagSyntax node)
    {
      var lessThanSlashToken = this.VisitToken(node.LessThanSlashToken);
      var name = (XmlNameSyntax)this.Visit(node.Name);
      var greaterThanToken = this.VisitToken(node.GreaterThanToken);
      return node.Update(lessThanSlashToken, name, greaterThanToken);
    }

    public override SyntaxNode VisitXmlEmptyElement(XmlEmptyElementSyntax node)
    {
      var lessThanToken = this.VisitToken(node.LessThanToken);
      var name = (XmlNameSyntax)this.Visit(node.Name);
      var attributes = this.VisitList(node.Attributes);
      var slashGreaterThanToken = this.VisitToken(node.SlashGreaterThanToken);
      return node.Update(lessThanToken, name, attributes, slashGreaterThanToken);
    }

    public override SyntaxNode VisitXmlName(XmlNameSyntax node)
    {
      var prefix = (XmlPrefixSyntax)this.Visit(node.Prefix);
      var localName = this.VisitToken(node.LocalName);
      return node.Update(prefix, localName);
    }

    public override SyntaxNode VisitXmlPrefix(XmlPrefixSyntax node)
    {
      var prefix = this.VisitToken(node.Prefix);
      var colonToken = this.VisitToken(node.ColonToken);
      return node.Update(prefix, colonToken);
    }

    public override SyntaxNode VisitXmlTextAttribute(XmlTextAttributeSyntax node)
    {
      var name = (XmlNameSyntax)this.Visit(node.Name);
      var equalsToken = this.VisitToken(node.EqualsToken);
      var startQuoteToken = this.VisitToken(node.StartQuoteToken);
      var textTokens = this.VisitList(node.TextTokens);
      var endQuoteToken = this.VisitToken(node.EndQuoteToken);
      return node.Update(name, equalsToken, startQuoteToken, textTokens, endQuoteToken);
    }

    public override SyntaxNode VisitXmlCrefAttribute(XmlCrefAttributeSyntax node)
    {
      var name = (XmlNameSyntax)this.Visit(node.Name);
      var equalsToken = this.VisitToken(node.EqualsToken);
      var startQuoteToken = this.VisitToken(node.StartQuoteToken);
      var cref = (CrefSyntax)this.Visit(node.Cref);
      var endQuoteToken = this.VisitToken(node.EndQuoteToken);
      return node.Update(name, equalsToken, startQuoteToken, cref, endQuoteToken);
    }

    public override SyntaxNode VisitXmlNameAttribute(XmlNameAttributeSyntax node)
    {
      var name = (XmlNameSyntax)this.Visit(node.Name);
      var equalsToken = this.VisitToken(node.EqualsToken);
      var startQuoteToken = this.VisitToken(node.StartQuoteToken);
      var identifier = (IdentifierNameSyntax)this.Visit(node.Identifier);
      var endQuoteToken = this.VisitToken(node.EndQuoteToken);
      return node.Update(name, equalsToken, startQuoteToken, identifier, endQuoteToken);
    }

    public override SyntaxNode VisitXmlText(XmlTextSyntax node)
    {
      var textTokens = this.VisitList(node.TextTokens);
      return node.Update(textTokens);
    }

    public override SyntaxNode VisitXmlCDataSection(XmlCDataSectionSyntax node)
    {
      var startCDataToken = this.VisitToken(node.StartCDataToken);
      var textTokens = this.VisitList(node.TextTokens);
      var endCDataToken = this.VisitToken(node.EndCDataToken);
      return node.Update(startCDataToken, textTokens, endCDataToken);
    }

    public override SyntaxNode VisitXmlProcessingInstruction(XmlProcessingInstructionSyntax node)
    {
      var startProcessingInstructionToken = this.VisitToken(node.StartProcessingInstructionToken);
      var name = (XmlNameSyntax)this.Visit(node.Name);
      var textTokens = this.VisitList(node.TextTokens);
      var endProcessingInstructionToken = this.VisitToken(node.EndProcessingInstructionToken);
      return node.Update(startProcessingInstructionToken, name, textTokens, endProcessingInstructionToken);
    }

    public override SyntaxNode VisitXmlComment(XmlCommentSyntax node)
    {
      var lessThanExclamationMinusMinusToken = this.VisitToken(node.LessThanExclamationMinusMinusToken);
      var textTokens = this.VisitList(node.TextTokens);
      var minusMinusGreaterThanToken = this.VisitToken(node.MinusMinusGreaterThanToken);
      return node.Update(lessThanExclamationMinusMinusToken, textTokens, minusMinusGreaterThanToken);
    }

    public override SyntaxNode VisitIfDirectiveTrivia(IfDirectiveTriviaSyntax node)
    {
      var hashToken = this.VisitToken(node.HashToken);
      var ifKeyword = this.VisitToken(node.IfKeyword);
      var condition = (ExpressionSyntax)this.Visit(node.Condition);
      var endOfDirectiveToken = this.VisitToken(node.EndOfDirectiveToken);
      return node.Update(hashToken, ifKeyword, condition, endOfDirectiveToken, node.IsActive, node.BranchTaken, node.ConditionValue);
    }

    public override SyntaxNode VisitElifDirectiveTrivia(ElifDirectiveTriviaSyntax node)
    {
      var hashToken = this.VisitToken(node.HashToken);
      var elifKeyword = this.VisitToken(node.ElifKeyword);
      var condition = (ExpressionSyntax)this.Visit(node.Condition);
      var endOfDirectiveToken = this.VisitToken(node.EndOfDirectiveToken);
      return node.Update(hashToken, elifKeyword, condition, endOfDirectiveToken, node.IsActive, node.BranchTaken, node.ConditionValue);
    }

    public override SyntaxNode VisitElseDirectiveTrivia(ElseDirectiveTriviaSyntax node)
    {
      var hashToken = this.VisitToken(node.HashToken);
      var elseKeyword = this.VisitToken(node.ElseKeyword);
      var endOfDirectiveToken = this.VisitToken(node.EndOfDirectiveToken);
      return node.Update(hashToken, elseKeyword, endOfDirectiveToken, node.IsActive, node.BranchTaken);
    }

    public override SyntaxNode VisitEndIfDirectiveTrivia(EndIfDirectiveTriviaSyntax node)
    {
      var hashToken = this.VisitToken(node.HashToken);
      var endIfKeyword = this.VisitToken(node.EndIfKeyword);
      var endOfDirectiveToken = this.VisitToken(node.EndOfDirectiveToken);
      return node.Update(hashToken, endIfKeyword, endOfDirectiveToken, node.IsActive);
    }

    public override SyntaxNode VisitRegionDirectiveTrivia(RegionDirectiveTriviaSyntax node)
    {
      var hashToken = this.VisitToken(node.HashToken);
      var regionKeyword = this.VisitToken(node.RegionKeyword);
      var endOfDirectiveToken = this.VisitToken(node.EndOfDirectiveToken);
      return node.Update(hashToken, regionKeyword, endOfDirectiveToken, node.IsActive);
    }

    public override SyntaxNode VisitEndRegionDirectiveTrivia(EndRegionDirectiveTriviaSyntax node)
    {
      var hashToken = this.VisitToken(node.HashToken);
      var endRegionKeyword = this.VisitToken(node.EndRegionKeyword);
      var endOfDirectiveToken = this.VisitToken(node.EndOfDirectiveToken);
      return node.Update(hashToken, endRegionKeyword, endOfDirectiveToken, node.IsActive);
    }

    public override SyntaxNode VisitErrorDirectiveTrivia(ErrorDirectiveTriviaSyntax node)
    {
      var hashToken = this.VisitToken(node.HashToken);
      var errorKeyword = this.VisitToken(node.ErrorKeyword);
      var endOfDirectiveToken = this.VisitToken(node.EndOfDirectiveToken);
      return node.Update(hashToken, errorKeyword, endOfDirectiveToken, node.IsActive);
    }

    public override SyntaxNode VisitWarningDirectiveTrivia(WarningDirectiveTriviaSyntax node)
    {
      var hashToken = this.VisitToken(node.HashToken);
      var warningKeyword = this.VisitToken(node.WarningKeyword);
      var endOfDirectiveToken = this.VisitToken(node.EndOfDirectiveToken);
      return node.Update(hashToken, warningKeyword, endOfDirectiveToken, node.IsActive);
    }

    public override SyntaxNode VisitBadDirectiveTrivia(BadDirectiveTriviaSyntax node)
    {
      var hashToken = this.VisitToken(node.HashToken);
      var identifier = this.VisitToken(node.Identifier);
      var endOfDirectiveToken = this.VisitToken(node.EndOfDirectiveToken);
      return node.Update(hashToken, identifier, endOfDirectiveToken, node.IsActive);
    }

    public override SyntaxNode VisitDefineDirectiveTrivia(DefineDirectiveTriviaSyntax node)
    {
      var hashToken = this.VisitToken(node.HashToken);
      var defineKeyword = this.VisitToken(node.DefineKeyword);
      var name = this.VisitToken(node.Name);
      var endOfDirectiveToken = this.VisitToken(node.EndOfDirectiveToken);
      return node.Update(hashToken, defineKeyword, name, endOfDirectiveToken, node.IsActive);
    }

    public override SyntaxNode VisitUndefDirectiveTrivia(UndefDirectiveTriviaSyntax node)
    {
      var hashToken = this.VisitToken(node.HashToken);
      var undefKeyword = this.VisitToken(node.UndefKeyword);
      var name = this.VisitToken(node.Name);
      var endOfDirectiveToken = this.VisitToken(node.EndOfDirectiveToken);
      return node.Update(hashToken, undefKeyword, name, endOfDirectiveToken, node.IsActive);
    }

    public override SyntaxNode VisitLineDirectiveTrivia(LineDirectiveTriviaSyntax node)
    {
      var hashToken = this.VisitToken(node.HashToken);
      var lineKeyword = this.VisitToken(node.LineKeyword);
      var line = this.VisitToken(node.Line);
      var file = this.VisitToken(node.File);
      var endOfDirectiveToken = this.VisitToken(node.EndOfDirectiveToken);
      return node.Update(hashToken, lineKeyword, line, file, endOfDirectiveToken, node.IsActive);
    }

    public override SyntaxNode VisitPragmaWarningDirectiveTrivia(PragmaWarningDirectiveTriviaSyntax node)
    {
      var hashToken = this.VisitToken(node.HashToken);
      var pragmaKeyword = this.VisitToken(node.PragmaKeyword);
      var warningKeyword = this.VisitToken(node.WarningKeyword);
      var disableOrRestoreKeyword = this.VisitToken(node.DisableOrRestoreKeyword);
      var errorCodes = this.VisitList(node.ErrorCodes);
      var endOfDirectiveToken = this.VisitToken(node.EndOfDirectiveToken);
      return node.Update(hashToken, pragmaKeyword, warningKeyword, disableOrRestoreKeyword, errorCodes, endOfDirectiveToken, node.IsActive);
    }

    public override SyntaxNode VisitPragmaChecksumDirectiveTrivia(PragmaChecksumDirectiveTriviaSyntax node)
    {
      var hashToken = this.VisitToken(node.HashToken);
      var pragmaKeyword = this.VisitToken(node.PragmaKeyword);
      var checksumKeyword = this.VisitToken(node.ChecksumKeyword);
      var file = this.VisitToken(node.File);
      var guid = this.VisitToken(node.Guid);
      var bytes = this.VisitToken(node.Bytes);
      var endOfDirectiveToken = this.VisitToken(node.EndOfDirectiveToken);
      return node.Update(hashToken, pragmaKeyword, checksumKeyword, file, guid, bytes, endOfDirectiveToken, node.IsActive);
    }

    public override SyntaxNode VisitReferenceDirectiveTrivia(ReferenceDirectiveTriviaSyntax node)
    {
      var hashToken = this.VisitToken(node.HashToken);
      var referenceKeyword = this.VisitToken(node.ReferenceKeyword);
      var file = this.VisitToken(node.File);
      var endOfDirectiveToken = this.VisitToken(node.EndOfDirectiveToken);
      return node.Update(hashToken, referenceKeyword, file, endOfDirectiveToken, node.IsActive);
    }

    public override SyntaxNode VisitLoadDirectiveTrivia(LoadDirectiveTriviaSyntax node)
    {
      var hashToken = this.VisitToken(node.HashToken);
      var loadKeyword = this.VisitToken(node.LoadKeyword);
      var file = this.VisitToken(node.File);
      var endOfDirectiveToken = this.VisitToken(node.EndOfDirectiveToken);
      return node.Update(hashToken, loadKeyword, file, endOfDirectiveToken, node.IsActive);
    }

    public override SyntaxNode VisitShebangDirectiveTrivia(ShebangDirectiveTriviaSyntax node)
    {
      var hashToken = this.VisitToken(node.HashToken);
      var exclamationToken = this.VisitToken(node.ExclamationToken);
      var endOfDirectiveToken = this.VisitToken(node.EndOfDirectiveToken);
      return node.Update(hashToken, exclamationToken, endOfDirectiveToken, node.IsActive);
    }

    public override SyntaxNode VisitNullableDirectiveTrivia(NullableDirectiveTriviaSyntax node)
    {
      var hashToken = this.VisitToken(node.HashToken);
      var nullableKeyword = this.VisitToken(node.NullableKeyword);
      var settingToken = this.VisitToken(node.SettingToken);
      var targetToken = this.VisitToken(node.TargetToken);
      var endOfDirectiveToken = this.VisitToken(node.EndOfDirectiveToken);
      return node.Update(hashToken, nullableKeyword, settingToken, targetToken, endOfDirectiveToken, node.IsActive);
    }
  }

  public static partial class SyntaxFactory
  {
    /// <summary>Creates a new IdentifierNameSyntax instance.</summary>
    public static IdentifierNameSyntax IdentifierName(SyntaxToken identifier)
    {
      switch (identifier.Kind())
      {
        case SyntaxKind.IdentifierToken:
        case SyntaxKind.GlobalKeyword:
          break;
        default:
          throw new ArgumentException(nameof(identifier));
      }
      return (IdentifierNameSyntax)Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SyntaxFactory.IdentifierName((Syntax.InternalSyntax.SyntaxToken)identifier.Node).CreateRed();
    }


    /// <summary>Creates a new QualifiedNameSyntax instance.</summary>
    public static QualifiedNameSyntax QualifiedName(NameSyntax left, SyntaxToken dotToken, SimpleNameSyntax right)
    {
      if (left == null)
        throw new ArgumentNullException(nameof(left));
      switch (dotToken.Kind())
      {
        case SyntaxKind.DotToken:
          break;
        default:
          throw new ArgumentException(nameof(dotToken));
      }
      if (right == null)
        throw new ArgumentNullException(nameof(right));
      return (QualifiedNameSyntax)Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SyntaxFactory.QualifiedName(left == null ? null : (Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.NameSyntax)left.Green, (Syntax.InternalSyntax.SyntaxToken)dotToken.Node, right == null ? null : (Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SimpleNameSyntax)right.Green).CreateRed();
    }


    /// <summary>Creates a new QualifiedNameSyntax instance.</summary>
    public static QualifiedNameSyntax QualifiedName(NameSyntax left, SimpleNameSyntax right)
    {
      return SyntaxFactory.QualifiedName(left, SyntaxFactory.Token(SyntaxKind.DotToken), right);
    }

    /// <summary>Creates a new GenericNameSyntax instance.</summary>
    public static GenericNameSyntax GenericName(SyntaxToken identifier, TypeArgumentListSyntax typeArgumentList)
    {
      switch (identifier.Kind())
      {
        case SyntaxKind.IdentifierToken:
          break;
        default:
          throw new ArgumentException(nameof(identifier));
      }
      if (typeArgumentList == null)
        throw new ArgumentNullException(nameof(typeArgumentList));
      return (GenericNameSyntax)Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SyntaxFactory.GenericName((Syntax.InternalSyntax.SyntaxToken)identifier.Node, typeArgumentList == null ? null : (Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.TypeArgumentListSyntax)typeArgumentList.Green).CreateRed();
    }


    /// <summary>Creates a new GenericNameSyntax instance.</summary>
    public static GenericNameSyntax GenericName(SyntaxToken identifier)
    {
      return SyntaxFactory.GenericName(identifier, SyntaxFactory.TypeArgumentList());
    }

    /// <summary>Creates a new GenericNameSyntax instance.</summary>
    public static GenericNameSyntax GenericName(string identifier)
    {
      return SyntaxFactory.GenericName(SyntaxFactory.Identifier(identifier), SyntaxFactory.TypeArgumentList());
    }

    /// <summary>Creates a new TypeArgumentListSyntax instance.</summary>
    public static TypeArgumentListSyntax TypeArgumentList(SyntaxToken lessThanToken, SeparatedSyntaxList<TypeSyntax> arguments, SyntaxToken greaterThanToken)
    {
      switch (lessThanToken.Kind())
      {
        case SyntaxKind.LessThanToken:
          break;
        default:
          throw new ArgumentException(nameof(lessThanToken));
      }
      switch (greaterThanToken.Kind())
      {
        case SyntaxKind.GreaterThanToken:
          break;
        default:
          throw new ArgumentException(nameof(greaterThanToken));
      }
      return (TypeArgumentListSyntax)Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SyntaxFactory.TypeArgumentList((Syntax.InternalSyntax.SyntaxToken)lessThanToken.Node, arguments.Node.ToGreenSeparatedList<Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.TypeSyntax>(), (Syntax.InternalSyntax.SyntaxToken)greaterThanToken.Node).CreateRed();
    }


    /// <summary>Creates a new TypeArgumentListSyntax instance.</summary>
    public static TypeArgumentListSyntax TypeArgumentList(SeparatedSyntaxList<TypeSyntax> arguments = default(SeparatedSyntaxList<TypeSyntax>))
    {
      return SyntaxFactory.TypeArgumentList(SyntaxFactory.Token(SyntaxKind.LessThanToken), arguments, SyntaxFactory.Token(SyntaxKind.GreaterThanToken));
    }

    /// <summary>Creates a new AliasQualifiedNameSyntax instance.</summary>
    public static AliasQualifiedNameSyntax AliasQualifiedName(IdentifierNameSyntax alias, SyntaxToken colonColonToken, SimpleNameSyntax name)
    {
      if (alias == null)
        throw new ArgumentNullException(nameof(alias));
      switch (colonColonToken.Kind())
      {
        case SyntaxKind.ColonColonToken:
          break;
        default:
          throw new ArgumentException(nameof(colonColonToken));
      }
      if (name == null)
        throw new ArgumentNullException(nameof(name));
      return (AliasQualifiedNameSyntax)Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SyntaxFactory.AliasQualifiedName(alias == null ? null : (Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.IdentifierNameSyntax)alias.Green, (Syntax.InternalSyntax.SyntaxToken)colonColonToken.Node, name == null ? null : (Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SimpleNameSyntax)name.Green).CreateRed();
    }


    /// <summary>Creates a new AliasQualifiedNameSyntax instance.</summary>
    public static AliasQualifiedNameSyntax AliasQualifiedName(IdentifierNameSyntax alias, SimpleNameSyntax name)
    {
      return SyntaxFactory.AliasQualifiedName(alias, SyntaxFactory.Token(SyntaxKind.ColonColonToken), name);
    }

    /// <summary>Creates a new AliasQualifiedNameSyntax instance.</summary>
    public static AliasQualifiedNameSyntax AliasQualifiedName(string alias, SimpleNameSyntax name)
    {
      return SyntaxFactory.AliasQualifiedName(SyntaxFactory.IdentifierName(alias), SyntaxFactory.Token(SyntaxKind.ColonColonToken), name);
    }

    /// <summary>Creates a new PredefinedTypeSyntax instance.</summary>
    public static PredefinedTypeSyntax PredefinedType(SyntaxToken keyword)
    {
      switch (keyword.Kind())
      {
        case SyntaxKind.BoolKeyword:
        case SyntaxKind.ByteKeyword:
        case SyntaxKind.SByteKeyword:
        case SyntaxKind.IntKeyword:
        case SyntaxKind.UIntKeyword:
        case SyntaxKind.ShortKeyword:
        case SyntaxKind.UShortKeyword:
        case SyntaxKind.LongKeyword:
        case SyntaxKind.ULongKeyword:
        case SyntaxKind.FloatKeyword:
        case SyntaxKind.DoubleKeyword:
        case SyntaxKind.DecimalKeyword:
        case SyntaxKind.StringKeyword:
        case SyntaxKind.CharKeyword:
        case SyntaxKind.ObjectKeyword:
        case SyntaxKind.VoidKeyword:
          break;
        default:
          throw new ArgumentException(nameof(keyword));
      }
      return (PredefinedTypeSyntax)Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SyntaxFactory.PredefinedType((Syntax.InternalSyntax.SyntaxToken)keyword.Node).CreateRed();
    }


    /// <summary>Creates a new ArrayTypeSyntax instance.</summary>
    public static ArrayTypeSyntax ArrayType(TypeSyntax elementType, SyntaxList<ArrayRankSpecifierSyntax> rankSpecifiers)
    {
      if (elementType == null)
        throw new ArgumentNullException(nameof(elementType));
      return (ArrayTypeSyntax)Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SyntaxFactory.ArrayType(elementType == null ? null : (Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.TypeSyntax)elementType.Green, rankSpecifiers.Node.ToGreenList<Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.ArrayRankSpecifierSyntax>()).CreateRed();
    }


    /// <summary>Creates a new ArrayTypeSyntax instance.</summary>
    public static ArrayTypeSyntax ArrayType(TypeSyntax elementType)
    {
      return SyntaxFactory.ArrayType(elementType, default(SyntaxList<ArrayRankSpecifierSyntax>));
    }

    /// <summary>Creates a new ArrayRankSpecifierSyntax instance.</summary>
    public static ArrayRankSpecifierSyntax ArrayRankSpecifier(SyntaxToken openBracketToken, SeparatedSyntaxList<ExpressionSyntax> sizes, SyntaxToken closeBracketToken)
    {
      switch (openBracketToken.Kind())
      {
        case SyntaxKind.OpenBracketToken:
          break;
        default:
          throw new ArgumentException(nameof(openBracketToken));
      }
      switch (closeBracketToken.Kind())
      {
        case SyntaxKind.CloseBracketToken:
          break;
        default:
          throw new ArgumentException(nameof(closeBracketToken));
      }
      return (ArrayRankSpecifierSyntax)Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SyntaxFactory.ArrayRankSpecifier((Syntax.InternalSyntax.SyntaxToken)openBracketToken.Node, sizes.Node.ToGreenSeparatedList<Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.ExpressionSyntax>(), (Syntax.InternalSyntax.SyntaxToken)closeBracketToken.Node).CreateRed();
    }


    /// <summary>Creates a new ArrayRankSpecifierSyntax instance.</summary>
    public static ArrayRankSpecifierSyntax ArrayRankSpecifier(SeparatedSyntaxList<ExpressionSyntax> sizes = default(SeparatedSyntaxList<ExpressionSyntax>))
    {
      return SyntaxFactory.ArrayRankSpecifier(SyntaxFactory.Token(SyntaxKind.OpenBracketToken), sizes, SyntaxFactory.Token(SyntaxKind.CloseBracketToken));
    }

    /// <summary>Creates a new PointerTypeSyntax instance.</summary>
    public static PointerTypeSyntax PointerType(TypeSyntax elementType, SyntaxToken asteriskToken)
    {
      if (elementType == null)
        throw new ArgumentNullException(nameof(elementType));
      switch (asteriskToken.Kind())
      {
        case SyntaxKind.AsteriskToken:
          break;
        default:
          throw new ArgumentException(nameof(asteriskToken));
      }
      return (PointerTypeSyntax)Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SyntaxFactory.PointerType(elementType == null ? null : (Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.TypeSyntax)elementType.Green, (Syntax.InternalSyntax.SyntaxToken)asteriskToken.Node).CreateRed();
    }


    /// <summary>Creates a new PointerTypeSyntax instance.</summary>
    public static PointerTypeSyntax PointerType(TypeSyntax elementType)
    {
      return SyntaxFactory.PointerType(elementType, SyntaxFactory.Token(SyntaxKind.AsteriskToken));
    }

    /// <summary>Creates a new NullableTypeSyntax instance.</summary>
    public static NullableTypeSyntax NullableType(TypeSyntax elementType, SyntaxToken questionToken)
    {
      if (elementType == null)
        throw new ArgumentNullException(nameof(elementType));
      switch (questionToken.Kind())
      {
        case SyntaxKind.QuestionToken:
          break;
        default:
          throw new ArgumentException(nameof(questionToken));
      }
      return (NullableTypeSyntax)Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SyntaxFactory.NullableType(elementType == null ? null : (Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.TypeSyntax)elementType.Green, (Syntax.InternalSyntax.SyntaxToken)questionToken.Node).CreateRed();
    }


    /// <summary>Creates a new NullableTypeSyntax instance.</summary>
    public static NullableTypeSyntax NullableType(TypeSyntax elementType)
    {
      return SyntaxFactory.NullableType(elementType, SyntaxFactory.Token(SyntaxKind.QuestionToken));
    }

    /// <summary>Creates a new TupleTypeSyntax instance.</summary>
    public static TupleTypeSyntax TupleType(SyntaxToken openParenToken, SeparatedSyntaxList<TupleElementSyntax> elements, SyntaxToken closeParenToken)
    {
      switch (openParenToken.Kind())
      {
        case SyntaxKind.OpenParenToken:
          break;
        default:
          throw new ArgumentException(nameof(openParenToken));
      }
      switch (closeParenToken.Kind())
      {
        case SyntaxKind.CloseParenToken:
          break;
        default:
          throw new ArgumentException(nameof(closeParenToken));
      }
      return (TupleTypeSyntax)Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SyntaxFactory.TupleType((Syntax.InternalSyntax.SyntaxToken)openParenToken.Node, elements.Node.ToGreenSeparatedList<Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.TupleElementSyntax>(), (Syntax.InternalSyntax.SyntaxToken)closeParenToken.Node).CreateRed();
    }


    /// <summary>Creates a new TupleTypeSyntax instance.</summary>
    public static TupleTypeSyntax TupleType(SeparatedSyntaxList<TupleElementSyntax> elements = default(SeparatedSyntaxList<TupleElementSyntax>))
    {
      return SyntaxFactory.TupleType(SyntaxFactory.Token(SyntaxKind.OpenParenToken), elements, SyntaxFactory.Token(SyntaxKind.CloseParenToken));
    }

    /// <summary>Creates a new TupleElementSyntax instance.</summary>
    public static TupleElementSyntax TupleElement(TypeSyntax type, SyntaxToken identifier)
    {
      if (type == null)
        throw new ArgumentNullException(nameof(type));
      switch (identifier.Kind())
      {
        case SyntaxKind.IdentifierToken:
        case SyntaxKind.None:
          break;
        default:
          throw new ArgumentException(nameof(identifier));
      }
      return (TupleElementSyntax)Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SyntaxFactory.TupleElement(type == null ? null : (Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.TypeSyntax)type.Green, (Syntax.InternalSyntax.SyntaxToken)identifier.Node).CreateRed();
    }


    /// <summary>Creates a new TupleElementSyntax instance.</summary>
    public static TupleElementSyntax TupleElement(TypeSyntax type)
    {
      return SyntaxFactory.TupleElement(type, default(SyntaxToken));
    }

    /// <summary>Creates a new OmittedTypeArgumentSyntax instance.</summary>
    public static OmittedTypeArgumentSyntax OmittedTypeArgument(SyntaxToken omittedTypeArgumentToken)
    {
      switch (omittedTypeArgumentToken.Kind())
      {
        case SyntaxKind.OmittedTypeArgumentToken:
          break;
        default:
          throw new ArgumentException(nameof(omittedTypeArgumentToken));
      }
      return (OmittedTypeArgumentSyntax)Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SyntaxFactory.OmittedTypeArgument((Syntax.InternalSyntax.SyntaxToken)omittedTypeArgumentToken.Node).CreateRed();
    }


    /// <summary>Creates a new OmittedTypeArgumentSyntax instance.</summary>
    public static OmittedTypeArgumentSyntax OmittedTypeArgument()
    {
      return SyntaxFactory.OmittedTypeArgument(SyntaxFactory.Token(SyntaxKind.OmittedTypeArgumentToken));
    }

    /// <summary>Creates a new RefTypeSyntax instance.</summary>
    public static RefTypeSyntax RefType(SyntaxToken refKeyword, SyntaxToken readOnlyKeyword, TypeSyntax type)
    {
      switch (refKeyword.Kind())
      {
        case SyntaxKind.RefKeyword:
          break;
        default:
          throw new ArgumentException(nameof(refKeyword));
      }
      switch (readOnlyKeyword.Kind())
      {
        case SyntaxKind.ReadOnlyKeyword:
        case SyntaxKind.None:
          break;
        default:
          throw new ArgumentException(nameof(readOnlyKeyword));
      }
      if (type == null)
        throw new ArgumentNullException(nameof(type));
      return (RefTypeSyntax)Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SyntaxFactory.RefType((Syntax.InternalSyntax.SyntaxToken)refKeyword.Node, (Syntax.InternalSyntax.SyntaxToken)readOnlyKeyword.Node, type == null ? null : (Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.TypeSyntax)type.Green).CreateRed();
    }


    /// <summary>Creates a new RefTypeSyntax instance.</summary>
    public static RefTypeSyntax RefType(TypeSyntax type)
    {
      return SyntaxFactory.RefType(SyntaxFactory.Token(SyntaxKind.RefKeyword), default(SyntaxToken), type);
    }

    /// <summary>Creates a new ParenthesizedExpressionSyntax instance.</summary>
    public static ParenthesizedExpressionSyntax ParenthesizedExpression(SyntaxToken openParenToken, ExpressionSyntax expression, SyntaxToken closeParenToken)
    {
      switch (openParenToken.Kind())
      {
        case SyntaxKind.OpenParenToken:
          break;
        default:
          throw new ArgumentException(nameof(openParenToken));
      }
      if (expression == null)
        throw new ArgumentNullException(nameof(expression));
      switch (closeParenToken.Kind())
      {
        case SyntaxKind.CloseParenToken:
          break;
        default:
          throw new ArgumentException(nameof(closeParenToken));
      }
      return (ParenthesizedExpressionSyntax)Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SyntaxFactory.ParenthesizedExpression((Syntax.InternalSyntax.SyntaxToken)openParenToken.Node, expression == null ? null : (Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.ExpressionSyntax)expression.Green, (Syntax.InternalSyntax.SyntaxToken)closeParenToken.Node).CreateRed();
    }


    /// <summary>Creates a new ParenthesizedExpressionSyntax instance.</summary>
    public static ParenthesizedExpressionSyntax ParenthesizedExpression(ExpressionSyntax expression)
    {
      return SyntaxFactory.ParenthesizedExpression(SyntaxFactory.Token(SyntaxKind.OpenParenToken), expression, SyntaxFactory.Token(SyntaxKind.CloseParenToken));
    }

    /// <summary>Creates a new TupleExpressionSyntax instance.</summary>
    public static TupleExpressionSyntax TupleExpression(SyntaxToken openParenToken, SeparatedSyntaxList<ArgumentSyntax> arguments, SyntaxToken closeParenToken)
    {
      switch (openParenToken.Kind())
      {
        case SyntaxKind.OpenParenToken:
          break;
        default:
          throw new ArgumentException(nameof(openParenToken));
      }
      switch (closeParenToken.Kind())
      {
        case SyntaxKind.CloseParenToken:
          break;
        default:
          throw new ArgumentException(nameof(closeParenToken));
      }
      return (TupleExpressionSyntax)Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SyntaxFactory.TupleExpression((Syntax.InternalSyntax.SyntaxToken)openParenToken.Node, arguments.Node.ToGreenSeparatedList<Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.ArgumentSyntax>(), (Syntax.InternalSyntax.SyntaxToken)closeParenToken.Node).CreateRed();
    }


    /// <summary>Creates a new TupleExpressionSyntax instance.</summary>
    public static TupleExpressionSyntax TupleExpression(SeparatedSyntaxList<ArgumentSyntax> arguments = default(SeparatedSyntaxList<ArgumentSyntax>))
    {
      return SyntaxFactory.TupleExpression(SyntaxFactory.Token(SyntaxKind.OpenParenToken), arguments, SyntaxFactory.Token(SyntaxKind.CloseParenToken));
    }

    /// <summary>Creates a new PrefixUnaryExpressionSyntax instance.</summary>
    public static PrefixUnaryExpressionSyntax PrefixUnaryExpression(SyntaxKind kind, SyntaxToken operatorToken, ExpressionSyntax operand)
    {
      switch (kind)
      {
        case SyntaxKind.UnaryPlusExpression:
        case SyntaxKind.UnaryMinusExpression:
        case SyntaxKind.BitwiseNotExpression:
        case SyntaxKind.LogicalNotExpression:
        case SyntaxKind.PreIncrementExpression:
        case SyntaxKind.PreDecrementExpression:
        case SyntaxKind.AddressOfExpression:
        case SyntaxKind.PointerIndirectionExpression:
        case SyntaxKind.IndexExpression:
          break;
        default:
          throw new ArgumentException(nameof(kind));
      }
      switch (operatorToken.Kind())
      {
        case SyntaxKind.PlusToken:
        case SyntaxKind.MinusToken:
        case SyntaxKind.TildeToken:
        case SyntaxKind.ExclamationToken:
        case SyntaxKind.PlusPlusToken:
        case SyntaxKind.MinusMinusToken:
        case SyntaxKind.AmpersandToken:
        case SyntaxKind.AsteriskToken:
        case SyntaxKind.CaretToken:
          break;
        default:
          throw new ArgumentException(nameof(operatorToken));
      }
      if (operand == null)
        throw new ArgumentNullException(nameof(operand));
      return (PrefixUnaryExpressionSyntax)Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SyntaxFactory.PrefixUnaryExpression(kind, (Syntax.InternalSyntax.SyntaxToken)operatorToken.Node, operand == null ? null : (Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.ExpressionSyntax)operand.Green).CreateRed();
    }


    /// <summary>Creates a new PrefixUnaryExpressionSyntax instance.</summary>
    public static PrefixUnaryExpressionSyntax PrefixUnaryExpression(SyntaxKind kind, ExpressionSyntax operand)
    {
      return SyntaxFactory.PrefixUnaryExpression(kind, SyntaxFactory.Token(GetPrefixUnaryExpressionOperatorTokenKind(kind)), operand);
    }

    private static SyntaxKind GetPrefixUnaryExpressionOperatorTokenKind(SyntaxKind kind)
    {
      switch (kind)
      {
        case SyntaxKind.UnaryPlusExpression:
          return SyntaxKind.PlusToken;
        case SyntaxKind.UnaryMinusExpression:
          return SyntaxKind.MinusToken;
        case SyntaxKind.BitwiseNotExpression:
          return SyntaxKind.TildeToken;
        case SyntaxKind.LogicalNotExpression:
          return SyntaxKind.ExclamationToken;
        case SyntaxKind.PreIncrementExpression:
          return SyntaxKind.PlusPlusToken;
        case SyntaxKind.PreDecrementExpression:
          return SyntaxKind.MinusMinusToken;
        case SyntaxKind.AddressOfExpression:
          return SyntaxKind.AmpersandToken;
        case SyntaxKind.PointerIndirectionExpression:
          return SyntaxKind.AsteriskToken;
        case SyntaxKind.IndexExpression:
          return SyntaxKind.CaretToken;
        default:
          throw new ArgumentOutOfRangeException();
      }
    }

    /// <summary>Creates a new AwaitExpressionSyntax instance.</summary>
    public static AwaitExpressionSyntax AwaitExpression(SyntaxToken awaitKeyword, ExpressionSyntax expression)
    {
      switch (awaitKeyword.Kind())
      {
        case SyntaxKind.AwaitKeyword:
          break;
        default:
          throw new ArgumentException(nameof(awaitKeyword));
      }
      if (expression == null)
        throw new ArgumentNullException(nameof(expression));
      return (AwaitExpressionSyntax)Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SyntaxFactory.AwaitExpression((Syntax.InternalSyntax.SyntaxToken)awaitKeyword.Node, expression == null ? null : (Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.ExpressionSyntax)expression.Green).CreateRed();
    }


    /// <summary>Creates a new AwaitExpressionSyntax instance.</summary>
    public static AwaitExpressionSyntax AwaitExpression(ExpressionSyntax expression)
    {
      return SyntaxFactory.AwaitExpression(SyntaxFactory.Token(SyntaxKind.AwaitKeyword), expression);
    }

    /// <summary>Creates a new PostfixUnaryExpressionSyntax instance.</summary>
    public static PostfixUnaryExpressionSyntax PostfixUnaryExpression(SyntaxKind kind, ExpressionSyntax operand, SyntaxToken operatorToken)
    {
      switch (kind)
      {
        case SyntaxKind.PostIncrementExpression:
        case SyntaxKind.PostDecrementExpression:
        case SyntaxKind.SuppressNullableWarningExpression:
          break;
        default:
          throw new ArgumentException(nameof(kind));
      }
      if (operand == null)
        throw new ArgumentNullException(nameof(operand));
      switch (operatorToken.Kind())
      {
        case SyntaxKind.PlusPlusToken:
        case SyntaxKind.MinusMinusToken:
        case SyntaxKind.ExclamationToken:
          break;
        default:
          throw new ArgumentException(nameof(operatorToken));
      }
      return (PostfixUnaryExpressionSyntax)Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SyntaxFactory.PostfixUnaryExpression(kind, operand == null ? null : (Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.ExpressionSyntax)operand.Green, (Syntax.InternalSyntax.SyntaxToken)operatorToken.Node).CreateRed();
    }


    /// <summary>Creates a new PostfixUnaryExpressionSyntax instance.</summary>
    public static PostfixUnaryExpressionSyntax PostfixUnaryExpression(SyntaxKind kind, ExpressionSyntax operand)
    {
      return SyntaxFactory.PostfixUnaryExpression(kind, operand, SyntaxFactory.Token(GetPostfixUnaryExpressionOperatorTokenKind(kind)));
    }

    private static SyntaxKind GetPostfixUnaryExpressionOperatorTokenKind(SyntaxKind kind)
    {
      switch (kind)
      {
        case SyntaxKind.PostIncrementExpression:
          return SyntaxKind.PlusPlusToken;
        case SyntaxKind.PostDecrementExpression:
          return SyntaxKind.MinusMinusToken;
        case SyntaxKind.SuppressNullableWarningExpression:
          return SyntaxKind.ExclamationToken;
        default:
          throw new ArgumentOutOfRangeException();
      }
    }

    /// <summary>Creates a new MemberAccessExpressionSyntax instance.</summary>
    public static MemberAccessExpressionSyntax MemberAccessExpression(SyntaxKind kind, ExpressionSyntax expression, SyntaxToken operatorToken, SimpleNameSyntax name)
    {
      switch (kind)
      {
        case SyntaxKind.SimpleMemberAccessExpression:
        case SyntaxKind.PointerMemberAccessExpression:
          break;
        default:
          throw new ArgumentException(nameof(kind));
      }
      if (expression == null)
        throw new ArgumentNullException(nameof(expression));
      switch (operatorToken.Kind())
      {
        case SyntaxKind.DotToken:
        case SyntaxKind.MinusGreaterThanToken:
          break;
        default:
          throw new ArgumentException(nameof(operatorToken));
      }
      if (name == null)
        throw new ArgumentNullException(nameof(name));
      return (MemberAccessExpressionSyntax)Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SyntaxFactory.MemberAccessExpression(kind, expression == null ? null : (Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.ExpressionSyntax)expression.Green, (Syntax.InternalSyntax.SyntaxToken)operatorToken.Node, name == null ? null : (Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SimpleNameSyntax)name.Green).CreateRed();
    }


    /// <summary>Creates a new MemberAccessExpressionSyntax instance.</summary>
    public static MemberAccessExpressionSyntax MemberAccessExpression(SyntaxKind kind, ExpressionSyntax expression, SimpleNameSyntax name)
    {
      return SyntaxFactory.MemberAccessExpression(kind, expression, SyntaxFactory.Token(GetMemberAccessExpressionOperatorTokenKind(kind)), name);
    }

    private static SyntaxKind GetMemberAccessExpressionOperatorTokenKind(SyntaxKind kind)
    {
      switch (kind)
      {
        case SyntaxKind.SimpleMemberAccessExpression:
          return SyntaxKind.DotToken;
        case SyntaxKind.PointerMemberAccessExpression:
          return SyntaxKind.MinusGreaterThanToken;
        default:
          throw new ArgumentOutOfRangeException();
      }
    }

    /// <summary>Creates a new ConditionalAccessExpressionSyntax instance.</summary>
    public static ConditionalAccessExpressionSyntax ConditionalAccessExpression(ExpressionSyntax expression, SyntaxToken operatorToken, ExpressionSyntax whenNotNull)
    {
      if (expression == null)
        throw new ArgumentNullException(nameof(expression));
      switch (operatorToken.Kind())
      {
        case SyntaxKind.QuestionToken:
          break;
        default:
          throw new ArgumentException(nameof(operatorToken));
      }
      if (whenNotNull == null)
        throw new ArgumentNullException(nameof(whenNotNull));
      return (ConditionalAccessExpressionSyntax)Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SyntaxFactory.ConditionalAccessExpression(expression == null ? null : (Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.ExpressionSyntax)expression.Green, (Syntax.InternalSyntax.SyntaxToken)operatorToken.Node, whenNotNull == null ? null : (Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.ExpressionSyntax)whenNotNull.Green).CreateRed();
    }


    /// <summary>Creates a new ConditionalAccessExpressionSyntax instance.</summary>
    public static ConditionalAccessExpressionSyntax ConditionalAccessExpression(ExpressionSyntax expression, ExpressionSyntax whenNotNull)
    {
      return SyntaxFactory.ConditionalAccessExpression(expression, SyntaxFactory.Token(SyntaxKind.QuestionToken), whenNotNull);
    }

    /// <summary>Creates a new MemberBindingExpressionSyntax instance.</summary>
    public static MemberBindingExpressionSyntax MemberBindingExpression(SyntaxToken operatorToken, SimpleNameSyntax name)
    {
      switch (operatorToken.Kind())
      {
        case SyntaxKind.DotToken:
          break;
        default:
          throw new ArgumentException(nameof(operatorToken));
      }
      if (name == null)
        throw new ArgumentNullException(nameof(name));
      return (MemberBindingExpressionSyntax)Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SyntaxFactory.MemberBindingExpression((Syntax.InternalSyntax.SyntaxToken)operatorToken.Node, name == null ? null : (Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SimpleNameSyntax)name.Green).CreateRed();
    }


    /// <summary>Creates a new MemberBindingExpressionSyntax instance.</summary>
    public static MemberBindingExpressionSyntax MemberBindingExpression(SimpleNameSyntax name)
    {
      return SyntaxFactory.MemberBindingExpression(SyntaxFactory.Token(SyntaxKind.DotToken), name);
    }

    /// <summary>Creates a new ElementBindingExpressionSyntax instance.</summary>
    public static ElementBindingExpressionSyntax ElementBindingExpression(BracketedArgumentListSyntax argumentList)
    {
      if (argumentList == null)
        throw new ArgumentNullException(nameof(argumentList));
      return (ElementBindingExpressionSyntax)Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SyntaxFactory.ElementBindingExpression(argumentList == null ? null : (Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.BracketedArgumentListSyntax)argumentList.Green).CreateRed();
    }


    /// <summary>Creates a new ElementBindingExpressionSyntax instance.</summary>
    public static ElementBindingExpressionSyntax ElementBindingExpression()
    {
      return SyntaxFactory.ElementBindingExpression(SyntaxFactory.BracketedArgumentList());
    }

    /// <summary>Creates a new RangeExpressionSyntax instance.</summary>
    public static RangeExpressionSyntax RangeExpression(ExpressionSyntax leftOperand, SyntaxToken operatorToken, ExpressionSyntax rightOperand)
    {
      switch (operatorToken.Kind())
      {
        case SyntaxKind.DotDotToken:
          break;
        default:
          throw new ArgumentException(nameof(operatorToken));
      }
      return (RangeExpressionSyntax)Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SyntaxFactory.RangeExpression(leftOperand == null ? null : (Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.ExpressionSyntax)leftOperand.Green, (Syntax.InternalSyntax.SyntaxToken)operatorToken.Node, rightOperand == null ? null : (Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.ExpressionSyntax)rightOperand.Green).CreateRed();
    }


    /// <summary>Creates a new RangeExpressionSyntax instance.</summary>
    public static RangeExpressionSyntax RangeExpression(ExpressionSyntax leftOperand, ExpressionSyntax rightOperand)
    {
      return SyntaxFactory.RangeExpression(leftOperand, SyntaxFactory.Token(SyntaxKind.DotDotToken), rightOperand);
    }

    /// <summary>Creates a new RangeExpressionSyntax instance.</summary>
    public static RangeExpressionSyntax RangeExpression()
    {
      return SyntaxFactory.RangeExpression(default(ExpressionSyntax), SyntaxFactory.Token(SyntaxKind.DotDotToken), default(ExpressionSyntax));
    }

    /// <summary>Creates a new ImplicitElementAccessSyntax instance.</summary>
    public static ImplicitElementAccessSyntax ImplicitElementAccess(BracketedArgumentListSyntax argumentList)
    {
      if (argumentList == null)
        throw new ArgumentNullException(nameof(argumentList));
      return (ImplicitElementAccessSyntax)Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SyntaxFactory.ImplicitElementAccess(argumentList == null ? null : (Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.BracketedArgumentListSyntax)argumentList.Green).CreateRed();
    }


    /// <summary>Creates a new ImplicitElementAccessSyntax instance.</summary>
    public static ImplicitElementAccessSyntax ImplicitElementAccess()
    {
      return SyntaxFactory.ImplicitElementAccess(SyntaxFactory.BracketedArgumentList());
    }

    /// <summary>Creates a new BinaryExpressionSyntax instance.</summary>
    public static BinaryExpressionSyntax BinaryExpression(SyntaxKind kind, ExpressionSyntax left, SyntaxToken operatorToken, ExpressionSyntax right)
    {
      switch (kind)
      {
        case SyntaxKind.AddExpression:
        case SyntaxKind.SubtractExpression:
        case SyntaxKind.MultiplyExpression:
        case SyntaxKind.DivideExpression:
        case SyntaxKind.ModuloExpression:
        case SyntaxKind.LeftShiftExpression:
        case SyntaxKind.RightShiftExpression:
        case SyntaxKind.LogicalOrExpression:
        case SyntaxKind.LogicalAndExpression:
        case SyntaxKind.BitwiseOrExpression:
        case SyntaxKind.BitwiseAndExpression:
        case SyntaxKind.ExclusiveOrExpression:
        case SyntaxKind.EqualsExpression:
        case SyntaxKind.NotEqualsExpression:
        case SyntaxKind.LessThanExpression:
        case SyntaxKind.LessThanOrEqualExpression:
        case SyntaxKind.GreaterThanExpression:
        case SyntaxKind.GreaterThanOrEqualExpression:
        case SyntaxKind.IsExpression:
        case SyntaxKind.AsExpression:
        case SyntaxKind.CoalesceExpression:
          break;
        default:
          throw new ArgumentException(nameof(kind));
      }
      if (left == null)
        throw new ArgumentNullException(nameof(left));
      switch (operatorToken.Kind())
      {
        case SyntaxKind.PlusToken:
        case SyntaxKind.MinusToken:
        case SyntaxKind.AsteriskToken:
        case SyntaxKind.SlashToken:
        case SyntaxKind.PercentToken:
        case SyntaxKind.LessThanLessThanToken:
        case SyntaxKind.GreaterThanGreaterThanToken:
        case SyntaxKind.BarBarToken:
        case SyntaxKind.AmpersandAmpersandToken:
        case SyntaxKind.BarToken:
        case SyntaxKind.AmpersandToken:
        case SyntaxKind.CaretToken:
        case SyntaxKind.EqualsEqualsToken:
        case SyntaxKind.ExclamationEqualsToken:
        case SyntaxKind.LessThanToken:
        case SyntaxKind.LessThanEqualsToken:
        case SyntaxKind.GreaterThanToken:
        case SyntaxKind.GreaterThanEqualsToken:
        case SyntaxKind.IsKeyword:
        case SyntaxKind.AsKeyword:
        case SyntaxKind.QuestionQuestionToken:
          break;
        default:
          throw new ArgumentException(nameof(operatorToken));
      }
      if (right == null)
        throw new ArgumentNullException(nameof(right));
      return (BinaryExpressionSyntax)Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SyntaxFactory.BinaryExpression(kind, left == null ? null : (Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.ExpressionSyntax)left.Green, (Syntax.InternalSyntax.SyntaxToken)operatorToken.Node, right == null ? null : (Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.ExpressionSyntax)right.Green).CreateRed();
    }


    /// <summary>Creates a new BinaryExpressionSyntax instance.</summary>
    public static BinaryExpressionSyntax BinaryExpression(SyntaxKind kind, ExpressionSyntax left, ExpressionSyntax right)
    {
      return SyntaxFactory.BinaryExpression(kind, left, SyntaxFactory.Token(GetBinaryExpressionOperatorTokenKind(kind)), right);
    }

    private static SyntaxKind GetBinaryExpressionOperatorTokenKind(SyntaxKind kind)
    {
      switch (kind)
      {
        case SyntaxKind.AddExpression:
          return SyntaxKind.PlusToken;
        case SyntaxKind.SubtractExpression:
          return SyntaxKind.MinusToken;
        case SyntaxKind.MultiplyExpression:
          return SyntaxKind.AsteriskToken;
        case SyntaxKind.DivideExpression:
          return SyntaxKind.SlashToken;
        case SyntaxKind.ModuloExpression:
          return SyntaxKind.PercentToken;
        case SyntaxKind.LeftShiftExpression:
          return SyntaxKind.LessThanLessThanToken;
        case SyntaxKind.RightShiftExpression:
          return SyntaxKind.GreaterThanGreaterThanToken;
        case SyntaxKind.LogicalOrExpression:
          return SyntaxKind.BarBarToken;
        case SyntaxKind.LogicalAndExpression:
          return SyntaxKind.AmpersandAmpersandToken;
        case SyntaxKind.BitwiseOrExpression:
          return SyntaxKind.BarToken;
        case SyntaxKind.BitwiseAndExpression:
          return SyntaxKind.AmpersandToken;
        case SyntaxKind.ExclusiveOrExpression:
          return SyntaxKind.CaretToken;
        case SyntaxKind.EqualsExpression:
          return SyntaxKind.EqualsEqualsToken;
        case SyntaxKind.NotEqualsExpression:
          return SyntaxKind.ExclamationEqualsToken;
        case SyntaxKind.LessThanExpression:
          return SyntaxKind.LessThanToken;
        case SyntaxKind.LessThanOrEqualExpression:
          return SyntaxKind.LessThanEqualsToken;
        case SyntaxKind.GreaterThanExpression:
          return SyntaxKind.GreaterThanToken;
        case SyntaxKind.GreaterThanOrEqualExpression:
          return SyntaxKind.GreaterThanEqualsToken;
        case SyntaxKind.IsExpression:
          return SyntaxKind.IsKeyword;
        case SyntaxKind.AsExpression:
          return SyntaxKind.AsKeyword;
        case SyntaxKind.CoalesceExpression:
          return SyntaxKind.QuestionQuestionToken;
        default:
          throw new ArgumentOutOfRangeException();
      }
    }

    /// <summary>Creates a new AssignmentExpressionSyntax instance.</summary>
    public static AssignmentExpressionSyntax AssignmentExpression(SyntaxKind kind, ExpressionSyntax left, SyntaxToken operatorToken, ExpressionSyntax right)
    {
      switch (kind)
      {
        case SyntaxKind.SimpleAssignmentExpression:
        case SyntaxKind.AddAssignmentExpression:
        case SyntaxKind.SubtractAssignmentExpression:
        case SyntaxKind.MultiplyAssignmentExpression:
        case SyntaxKind.DivideAssignmentExpression:
        case SyntaxKind.ModuloAssignmentExpression:
        case SyntaxKind.AndAssignmentExpression:
        case SyntaxKind.ExclusiveOrAssignmentExpression:
        case SyntaxKind.OrAssignmentExpression:
        case SyntaxKind.LeftShiftAssignmentExpression:
        case SyntaxKind.RightShiftAssignmentExpression:
        case SyntaxKind.CoalesceAssignmentExpression:
          break;
        default:
          throw new ArgumentException(nameof(kind));
      }
      if (left == null)
        throw new ArgumentNullException(nameof(left));
      switch (operatorToken.Kind())
      {
        case SyntaxKind.EqualsToken:
        case SyntaxKind.PlusEqualsToken:
        case SyntaxKind.MinusEqualsToken:
        case SyntaxKind.AsteriskEqualsToken:
        case SyntaxKind.SlashEqualsToken:
        case SyntaxKind.PercentEqualsToken:
        case SyntaxKind.AmpersandEqualsToken:
        case SyntaxKind.CaretEqualsToken:
        case SyntaxKind.BarEqualsToken:
        case SyntaxKind.LessThanLessThanEqualsToken:
        case SyntaxKind.GreaterThanGreaterThanEqualsToken:
        case SyntaxKind.QuestionQuestionEqualsToken:
          break;
        default:
          throw new ArgumentException(nameof(operatorToken));
      }
      if (right == null)
        throw new ArgumentNullException(nameof(right));
      return (AssignmentExpressionSyntax)Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SyntaxFactory.AssignmentExpression(kind, left == null ? null : (Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.ExpressionSyntax)left.Green, (Syntax.InternalSyntax.SyntaxToken)operatorToken.Node, right == null ? null : (Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.ExpressionSyntax)right.Green).CreateRed();
    }


    /// <summary>Creates a new AssignmentExpressionSyntax instance.</summary>
    public static AssignmentExpressionSyntax AssignmentExpression(SyntaxKind kind, ExpressionSyntax left, ExpressionSyntax right)
    {
      return SyntaxFactory.AssignmentExpression(kind, left, SyntaxFactory.Token(GetAssignmentExpressionOperatorTokenKind(kind)), right);
    }

    private static SyntaxKind GetAssignmentExpressionOperatorTokenKind(SyntaxKind kind)
    {
      switch (kind)
      {
        case SyntaxKind.SimpleAssignmentExpression:
          return SyntaxKind.EqualsToken;
        case SyntaxKind.AddAssignmentExpression:
          return SyntaxKind.PlusEqualsToken;
        case SyntaxKind.SubtractAssignmentExpression:
          return SyntaxKind.MinusEqualsToken;
        case SyntaxKind.MultiplyAssignmentExpression:
          return SyntaxKind.AsteriskEqualsToken;
        case SyntaxKind.DivideAssignmentExpression:
          return SyntaxKind.SlashEqualsToken;
        case SyntaxKind.ModuloAssignmentExpression:
          return SyntaxKind.PercentEqualsToken;
        case SyntaxKind.AndAssignmentExpression:
          return SyntaxKind.AmpersandEqualsToken;
        case SyntaxKind.ExclusiveOrAssignmentExpression:
          return SyntaxKind.CaretEqualsToken;
        case SyntaxKind.OrAssignmentExpression:
          return SyntaxKind.BarEqualsToken;
        case SyntaxKind.LeftShiftAssignmentExpression:
          return SyntaxKind.LessThanLessThanEqualsToken;
        case SyntaxKind.RightShiftAssignmentExpression:
          return SyntaxKind.GreaterThanGreaterThanEqualsToken;
        case SyntaxKind.CoalesceAssignmentExpression:
          return SyntaxKind.QuestionQuestionEqualsToken;
        default:
          throw new ArgumentOutOfRangeException();
      }
    }

    /// <summary>Creates a new ConditionalExpressionSyntax instance.</summary>
    public static ConditionalExpressionSyntax ConditionalExpression(ExpressionSyntax condition, SyntaxToken questionToken, ExpressionSyntax whenTrue, SyntaxToken colonToken, ExpressionSyntax whenFalse)
    {
      if (condition == null)
        throw new ArgumentNullException(nameof(condition));
      switch (questionToken.Kind())
      {
        case SyntaxKind.QuestionToken:
          break;
        default:
          throw new ArgumentException(nameof(questionToken));
      }
      if (whenTrue == null)
        throw new ArgumentNullException(nameof(whenTrue));
      switch (colonToken.Kind())
      {
        case SyntaxKind.ColonToken:
          break;
        default:
          throw new ArgumentException(nameof(colonToken));
      }
      if (whenFalse == null)
        throw new ArgumentNullException(nameof(whenFalse));
      return (ConditionalExpressionSyntax)Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SyntaxFactory.ConditionalExpression(condition == null ? null : (Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.ExpressionSyntax)condition.Green, (Syntax.InternalSyntax.SyntaxToken)questionToken.Node, whenTrue == null ? null : (Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.ExpressionSyntax)whenTrue.Green, (Syntax.InternalSyntax.SyntaxToken)colonToken.Node, whenFalse == null ? null : (Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.ExpressionSyntax)whenFalse.Green).CreateRed();
    }


    /// <summary>Creates a new ConditionalExpressionSyntax instance.</summary>
    public static ConditionalExpressionSyntax ConditionalExpression(ExpressionSyntax condition, ExpressionSyntax whenTrue, ExpressionSyntax whenFalse)
    {
      return SyntaxFactory.ConditionalExpression(condition, SyntaxFactory.Token(SyntaxKind.QuestionToken), whenTrue, SyntaxFactory.Token(SyntaxKind.ColonToken), whenFalse);
    }

    /// <summary>Creates a new ThisExpressionSyntax instance.</summary>
    public static ThisExpressionSyntax ThisExpression(SyntaxToken token)
    {
      switch (token.Kind())
      {
        case SyntaxKind.ThisKeyword:
          break;
        default:
          throw new ArgumentException(nameof(token));
      }
      return (ThisExpressionSyntax)Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SyntaxFactory.ThisExpression((Syntax.InternalSyntax.SyntaxToken)token.Node).CreateRed();
    }


    /// <summary>Creates a new ThisExpressionSyntax instance.</summary>
    public static ThisExpressionSyntax ThisExpression()
    {
      return SyntaxFactory.ThisExpression(SyntaxFactory.Token(SyntaxKind.ThisKeyword));
    }

    /// <summary>Creates a new BaseExpressionSyntax instance.</summary>
    public static BaseExpressionSyntax BaseExpression(SyntaxToken token)
    {
      switch (token.Kind())
      {
        case SyntaxKind.BaseKeyword:
          break;
        default:
          throw new ArgumentException(nameof(token));
      }
      return (BaseExpressionSyntax)Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SyntaxFactory.BaseExpression((Syntax.InternalSyntax.SyntaxToken)token.Node).CreateRed();
    }


    /// <summary>Creates a new BaseExpressionSyntax instance.</summary>
    public static BaseExpressionSyntax BaseExpression()
    {
      return SyntaxFactory.BaseExpression(SyntaxFactory.Token(SyntaxKind.BaseKeyword));
    }

    /// <summary>Creates a new LiteralExpressionSyntax instance.</summary>
    public static LiteralExpressionSyntax LiteralExpression(SyntaxKind kind, SyntaxToken token)
    {
      switch (kind)
      {
        case SyntaxKind.ArgListExpression:
        case SyntaxKind.NumericLiteralExpression:
        case SyntaxKind.StringLiteralExpression:
        case SyntaxKind.CharacterLiteralExpression:
        case SyntaxKind.TrueLiteralExpression:
        case SyntaxKind.FalseLiteralExpression:
        case SyntaxKind.NullLiteralExpression:
        case SyntaxKind.DefaultLiteralExpression:
          break;
        default:
          throw new ArgumentException(nameof(kind));
      }
      switch (token.Kind())
      {
        case SyntaxKind.ArgListKeyword:
        case SyntaxKind.NumericLiteralToken:
        case SyntaxKind.StringLiteralToken:
        case SyntaxKind.CharacterLiteralToken:
        case SyntaxKind.TrueKeyword:
        case SyntaxKind.FalseKeyword:
        case SyntaxKind.NullKeyword:
        case SyntaxKind.DefaultKeyword:
          break;
        default:
          throw new ArgumentException(nameof(token));
      }
      return (LiteralExpressionSyntax)Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SyntaxFactory.LiteralExpression(kind, (Syntax.InternalSyntax.SyntaxToken)token.Node).CreateRed();
    }


    /// <summary>Creates a new LiteralExpressionSyntax instance.</summary>
    public static LiteralExpressionSyntax LiteralExpression(SyntaxKind kind)
    {
      return SyntaxFactory.LiteralExpression(kind, SyntaxFactory.Token(GetLiteralExpressionTokenKind(kind)));
    }

    private static SyntaxKind GetLiteralExpressionTokenKind(SyntaxKind kind)
    {
      switch (kind)
      {
        case SyntaxKind.ArgListExpression:
          return SyntaxKind.ArgListKeyword;
        case SyntaxKind.NumericLiteralExpression:
          return SyntaxKind.NumericLiteralToken;
        case SyntaxKind.StringLiteralExpression:
          return SyntaxKind.StringLiteralToken;
        case SyntaxKind.CharacterLiteralExpression:
          return SyntaxKind.CharacterLiteralToken;
        case SyntaxKind.TrueLiteralExpression:
          return SyntaxKind.TrueKeyword;
        case SyntaxKind.FalseLiteralExpression:
          return SyntaxKind.FalseKeyword;
        case SyntaxKind.NullLiteralExpression:
          return SyntaxKind.NullKeyword;
        case SyntaxKind.DefaultLiteralExpression:
          return SyntaxKind.DefaultKeyword;
        default:
          throw new ArgumentOutOfRangeException();
      }
    }

    /// <summary>Creates a new MakeRefExpressionSyntax instance.</summary>
    public static MakeRefExpressionSyntax MakeRefExpression(SyntaxToken keyword, SyntaxToken openParenToken, ExpressionSyntax expression, SyntaxToken closeParenToken)
    {
      switch (keyword.Kind())
      {
        case SyntaxKind.MakeRefKeyword:
          break;
        default:
          throw new ArgumentException(nameof(keyword));
      }
      switch (openParenToken.Kind())
      {
        case SyntaxKind.OpenParenToken:
          break;
        default:
          throw new ArgumentException(nameof(openParenToken));
      }
      if (expression == null)
        throw new ArgumentNullException(nameof(expression));
      switch (closeParenToken.Kind())
      {
        case SyntaxKind.CloseParenToken:
          break;
        default:
          throw new ArgumentException(nameof(closeParenToken));
      }
      return (MakeRefExpressionSyntax)Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SyntaxFactory.MakeRefExpression((Syntax.InternalSyntax.SyntaxToken)keyword.Node, (Syntax.InternalSyntax.SyntaxToken)openParenToken.Node, expression == null ? null : (Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.ExpressionSyntax)expression.Green, (Syntax.InternalSyntax.SyntaxToken)closeParenToken.Node).CreateRed();
    }


    /// <summary>Creates a new MakeRefExpressionSyntax instance.</summary>
    public static MakeRefExpressionSyntax MakeRefExpression(ExpressionSyntax expression)
    {
      return SyntaxFactory.MakeRefExpression(SyntaxFactory.Token(SyntaxKind.MakeRefKeyword), SyntaxFactory.Token(SyntaxKind.OpenParenToken), expression, SyntaxFactory.Token(SyntaxKind.CloseParenToken));
    }

    /// <summary>Creates a new RefTypeExpressionSyntax instance.</summary>
    public static RefTypeExpressionSyntax RefTypeExpression(SyntaxToken keyword, SyntaxToken openParenToken, ExpressionSyntax expression, SyntaxToken closeParenToken)
    {
      switch (keyword.Kind())
      {
        case SyntaxKind.RefTypeKeyword:
          break;
        default:
          throw new ArgumentException(nameof(keyword));
      }
      switch (openParenToken.Kind())
      {
        case SyntaxKind.OpenParenToken:
          break;
        default:
          throw new ArgumentException(nameof(openParenToken));
      }
      if (expression == null)
        throw new ArgumentNullException(nameof(expression));
      switch (closeParenToken.Kind())
      {
        case SyntaxKind.CloseParenToken:
          break;
        default:
          throw new ArgumentException(nameof(closeParenToken));
      }
      return (RefTypeExpressionSyntax)Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SyntaxFactory.RefTypeExpression((Syntax.InternalSyntax.SyntaxToken)keyword.Node, (Syntax.InternalSyntax.SyntaxToken)openParenToken.Node, expression == null ? null : (Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.ExpressionSyntax)expression.Green, (Syntax.InternalSyntax.SyntaxToken)closeParenToken.Node).CreateRed();
    }


    /// <summary>Creates a new RefTypeExpressionSyntax instance.</summary>
    public static RefTypeExpressionSyntax RefTypeExpression(ExpressionSyntax expression)
    {
      return SyntaxFactory.RefTypeExpression(SyntaxFactory.Token(SyntaxKind.RefTypeKeyword), SyntaxFactory.Token(SyntaxKind.OpenParenToken), expression, SyntaxFactory.Token(SyntaxKind.CloseParenToken));
    }

    /// <summary>Creates a new RefValueExpressionSyntax instance.</summary>
    public static RefValueExpressionSyntax RefValueExpression(SyntaxToken keyword, SyntaxToken openParenToken, ExpressionSyntax expression, SyntaxToken comma, TypeSyntax type, SyntaxToken closeParenToken)
    {
      switch (keyword.Kind())
      {
        case SyntaxKind.RefValueKeyword:
          break;
        default:
          throw new ArgumentException(nameof(keyword));
      }
      switch (openParenToken.Kind())
      {
        case SyntaxKind.OpenParenToken:
          break;
        default:
          throw new ArgumentException(nameof(openParenToken));
      }
      if (expression == null)
        throw new ArgumentNullException(nameof(expression));
      switch (comma.Kind())
      {
        case SyntaxKind.CommaToken:
          break;
        default:
          throw new ArgumentException(nameof(comma));
      }
      if (type == null)
        throw new ArgumentNullException(nameof(type));
      switch (closeParenToken.Kind())
      {
        case SyntaxKind.CloseParenToken:
          break;
        default:
          throw new ArgumentException(nameof(closeParenToken));
      }
      return (RefValueExpressionSyntax)Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SyntaxFactory.RefValueExpression((Syntax.InternalSyntax.SyntaxToken)keyword.Node, (Syntax.InternalSyntax.SyntaxToken)openParenToken.Node, expression == null ? null : (Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.ExpressionSyntax)expression.Green, (Syntax.InternalSyntax.SyntaxToken)comma.Node, type == null ? null : (Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.TypeSyntax)type.Green, (Syntax.InternalSyntax.SyntaxToken)closeParenToken.Node).CreateRed();
    }


    /// <summary>Creates a new RefValueExpressionSyntax instance.</summary>
    public static RefValueExpressionSyntax RefValueExpression(ExpressionSyntax expression, TypeSyntax type)
    {
      return SyntaxFactory.RefValueExpression(SyntaxFactory.Token(SyntaxKind.RefValueKeyword), SyntaxFactory.Token(SyntaxKind.OpenParenToken), expression, SyntaxFactory.Token(SyntaxKind.CommaToken), type, SyntaxFactory.Token(SyntaxKind.CloseParenToken));
    }

    /// <summary>Creates a new CheckedExpressionSyntax instance.</summary>
    public static CheckedExpressionSyntax CheckedExpression(SyntaxKind kind, SyntaxToken keyword, SyntaxToken openParenToken, ExpressionSyntax expression, SyntaxToken closeParenToken)
    {
      switch (kind)
      {
        case SyntaxKind.CheckedExpression:
        case SyntaxKind.UncheckedExpression:
          break;
        default:
          throw new ArgumentException(nameof(kind));
      }
      switch (keyword.Kind())
      {
        case SyntaxKind.CheckedKeyword:
        case SyntaxKind.UncheckedKeyword:
          break;
        default:
          throw new ArgumentException(nameof(keyword));
      }
      switch (openParenToken.Kind())
      {
        case SyntaxKind.OpenParenToken:
          break;
        default:
          throw new ArgumentException(nameof(openParenToken));
      }
      if (expression == null)
        throw new ArgumentNullException(nameof(expression));
      switch (closeParenToken.Kind())
      {
        case SyntaxKind.CloseParenToken:
          break;
        default:
          throw new ArgumentException(nameof(closeParenToken));
      }
      return (CheckedExpressionSyntax)Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SyntaxFactory.CheckedExpression(kind, (Syntax.InternalSyntax.SyntaxToken)keyword.Node, (Syntax.InternalSyntax.SyntaxToken)openParenToken.Node, expression == null ? null : (Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.ExpressionSyntax)expression.Green, (Syntax.InternalSyntax.SyntaxToken)closeParenToken.Node).CreateRed();
    }


    /// <summary>Creates a new CheckedExpressionSyntax instance.</summary>
    public static CheckedExpressionSyntax CheckedExpression(SyntaxKind kind, ExpressionSyntax expression)
    {
      return SyntaxFactory.CheckedExpression(kind, SyntaxFactory.Token(GetCheckedExpressionKeywordKind(kind)), SyntaxFactory.Token(SyntaxKind.OpenParenToken), expression, SyntaxFactory.Token(SyntaxKind.CloseParenToken));
    }

    private static SyntaxKind GetCheckedExpressionKeywordKind(SyntaxKind kind)
    {
      switch (kind)
      {
        case SyntaxKind.CheckedExpression:
          return SyntaxKind.CheckedKeyword;
        case SyntaxKind.UncheckedExpression:
          return SyntaxKind.UncheckedKeyword;
        default:
          throw new ArgumentOutOfRangeException();
      }
    }

    /// <summary>Creates a new DefaultExpressionSyntax instance.</summary>
    public static DefaultExpressionSyntax DefaultExpression(SyntaxToken keyword, SyntaxToken openParenToken, TypeSyntax type, SyntaxToken closeParenToken)
    {
      switch (keyword.Kind())
      {
        case SyntaxKind.DefaultKeyword:
          break;
        default:
          throw new ArgumentException(nameof(keyword));
      }
      switch (openParenToken.Kind())
      {
        case SyntaxKind.OpenParenToken:
          break;
        default:
          throw new ArgumentException(nameof(openParenToken));
      }
      if (type == null)
        throw new ArgumentNullException(nameof(type));
      switch (closeParenToken.Kind())
      {
        case SyntaxKind.CloseParenToken:
          break;
        default:
          throw new ArgumentException(nameof(closeParenToken));
      }
      return (DefaultExpressionSyntax)Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SyntaxFactory.DefaultExpression((Syntax.InternalSyntax.SyntaxToken)keyword.Node, (Syntax.InternalSyntax.SyntaxToken)openParenToken.Node, type == null ? null : (Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.TypeSyntax)type.Green, (Syntax.InternalSyntax.SyntaxToken)closeParenToken.Node).CreateRed();
    }


    /// <summary>Creates a new DefaultExpressionSyntax instance.</summary>
    public static DefaultExpressionSyntax DefaultExpression(TypeSyntax type)
    {
      return SyntaxFactory.DefaultExpression(SyntaxFactory.Token(SyntaxKind.DefaultKeyword), SyntaxFactory.Token(SyntaxKind.OpenParenToken), type, SyntaxFactory.Token(SyntaxKind.CloseParenToken));
    }

    /// <summary>Creates a new TypeOfExpressionSyntax instance.</summary>
    public static TypeOfExpressionSyntax TypeOfExpression(SyntaxToken keyword, SyntaxToken openParenToken, TypeSyntax type, SyntaxToken closeParenToken)
    {
      switch (keyword.Kind())
      {
        case SyntaxKind.TypeOfKeyword:
          break;
        default:
          throw new ArgumentException(nameof(keyword));
      }
      switch (openParenToken.Kind())
      {
        case SyntaxKind.OpenParenToken:
          break;
        default:
          throw new ArgumentException(nameof(openParenToken));
      }
      if (type == null)
        throw new ArgumentNullException(nameof(type));
      switch (closeParenToken.Kind())
      {
        case SyntaxKind.CloseParenToken:
          break;
        default:
          throw new ArgumentException(nameof(closeParenToken));
      }
      return (TypeOfExpressionSyntax)Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SyntaxFactory.TypeOfExpression((Syntax.InternalSyntax.SyntaxToken)keyword.Node, (Syntax.InternalSyntax.SyntaxToken)openParenToken.Node, type == null ? null : (Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.TypeSyntax)type.Green, (Syntax.InternalSyntax.SyntaxToken)closeParenToken.Node).CreateRed();
    }


    /// <summary>Creates a new TypeOfExpressionSyntax instance.</summary>
    public static TypeOfExpressionSyntax TypeOfExpression(TypeSyntax type)
    {
      return SyntaxFactory.TypeOfExpression(SyntaxFactory.Token(SyntaxKind.TypeOfKeyword), SyntaxFactory.Token(SyntaxKind.OpenParenToken), type, SyntaxFactory.Token(SyntaxKind.CloseParenToken));
    }

    /// <summary>Creates a new SizeOfExpressionSyntax instance.</summary>
    public static SizeOfExpressionSyntax SizeOfExpression(SyntaxToken keyword, SyntaxToken openParenToken, TypeSyntax type, SyntaxToken closeParenToken)
    {
      switch (keyword.Kind())
      {
        case SyntaxKind.SizeOfKeyword:
          break;
        default:
          throw new ArgumentException(nameof(keyword));
      }
      switch (openParenToken.Kind())
      {
        case SyntaxKind.OpenParenToken:
          break;
        default:
          throw new ArgumentException(nameof(openParenToken));
      }
      if (type == null)
        throw new ArgumentNullException(nameof(type));
      switch (closeParenToken.Kind())
      {
        case SyntaxKind.CloseParenToken:
          break;
        default:
          throw new ArgumentException(nameof(closeParenToken));
      }
      return (SizeOfExpressionSyntax)Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SyntaxFactory.SizeOfExpression((Syntax.InternalSyntax.SyntaxToken)keyword.Node, (Syntax.InternalSyntax.SyntaxToken)openParenToken.Node, type == null ? null : (Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.TypeSyntax)type.Green, (Syntax.InternalSyntax.SyntaxToken)closeParenToken.Node).CreateRed();
    }


    /// <summary>Creates a new SizeOfExpressionSyntax instance.</summary>
    public static SizeOfExpressionSyntax SizeOfExpression(TypeSyntax type)
    {
      return SyntaxFactory.SizeOfExpression(SyntaxFactory.Token(SyntaxKind.SizeOfKeyword), SyntaxFactory.Token(SyntaxKind.OpenParenToken), type, SyntaxFactory.Token(SyntaxKind.CloseParenToken));
    }

    /// <summary>Creates a new InvocationExpressionSyntax instance.</summary>
    public static InvocationExpressionSyntax InvocationExpression(ExpressionSyntax expression, ArgumentListSyntax argumentList)
    {
      if (expression == null)
        throw new ArgumentNullException(nameof(expression));
      if (argumentList == null)
        throw new ArgumentNullException(nameof(argumentList));
      return (InvocationExpressionSyntax)Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SyntaxFactory.InvocationExpression(expression == null ? null : (Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.ExpressionSyntax)expression.Green, argumentList == null ? null : (Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.ArgumentListSyntax)argumentList.Green).CreateRed();
    }


    /// <summary>Creates a new InvocationExpressionSyntax instance.</summary>
    public static InvocationExpressionSyntax InvocationExpression(ExpressionSyntax expression)
    {
      return SyntaxFactory.InvocationExpression(expression, SyntaxFactory.ArgumentList());
    }

    /// <summary>Creates a new ElementAccessExpressionSyntax instance.</summary>
    public static ElementAccessExpressionSyntax ElementAccessExpression(ExpressionSyntax expression, BracketedArgumentListSyntax argumentList)
    {
      if (expression == null)
        throw new ArgumentNullException(nameof(expression));
      if (argumentList == null)
        throw new ArgumentNullException(nameof(argumentList));
      return (ElementAccessExpressionSyntax)Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SyntaxFactory.ElementAccessExpression(expression == null ? null : (Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.ExpressionSyntax)expression.Green, argumentList == null ? null : (Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.BracketedArgumentListSyntax)argumentList.Green).CreateRed();
    }


    /// <summary>Creates a new ElementAccessExpressionSyntax instance.</summary>
    public static ElementAccessExpressionSyntax ElementAccessExpression(ExpressionSyntax expression)
    {
      return SyntaxFactory.ElementAccessExpression(expression, SyntaxFactory.BracketedArgumentList());
    }

    /// <summary>Creates a new ArgumentListSyntax instance.</summary>
    public static ArgumentListSyntax ArgumentList(SyntaxToken openParenToken, SeparatedSyntaxList<ArgumentSyntax> arguments, SyntaxToken closeParenToken)
    {
      switch (openParenToken.Kind())
      {
        case SyntaxKind.OpenParenToken:
          break;
        default:
          throw new ArgumentException(nameof(openParenToken));
      }
      switch (closeParenToken.Kind())
      {
        case SyntaxKind.CloseParenToken:
          break;
        default:
          throw new ArgumentException(nameof(closeParenToken));
      }
      return (ArgumentListSyntax)Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SyntaxFactory.ArgumentList((Syntax.InternalSyntax.SyntaxToken)openParenToken.Node, arguments.Node.ToGreenSeparatedList<Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.ArgumentSyntax>(), (Syntax.InternalSyntax.SyntaxToken)closeParenToken.Node).CreateRed();
    }


    /// <summary>Creates a new ArgumentListSyntax instance.</summary>
    public static ArgumentListSyntax ArgumentList(SeparatedSyntaxList<ArgumentSyntax> arguments = default(SeparatedSyntaxList<ArgumentSyntax>))
    {
      return SyntaxFactory.ArgumentList(SyntaxFactory.Token(SyntaxKind.OpenParenToken), arguments, SyntaxFactory.Token(SyntaxKind.CloseParenToken));
    }

    /// <summary>Creates a new BracketedArgumentListSyntax instance.</summary>
    public static BracketedArgumentListSyntax BracketedArgumentList(SyntaxToken openBracketToken, SeparatedSyntaxList<ArgumentSyntax> arguments, SyntaxToken closeBracketToken)
    {
      switch (openBracketToken.Kind())
      {
        case SyntaxKind.OpenBracketToken:
          break;
        default:
          throw new ArgumentException(nameof(openBracketToken));
      }
      switch (closeBracketToken.Kind())
      {
        case SyntaxKind.CloseBracketToken:
          break;
        default:
          throw new ArgumentException(nameof(closeBracketToken));
      }
      return (BracketedArgumentListSyntax)Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SyntaxFactory.BracketedArgumentList((Syntax.InternalSyntax.SyntaxToken)openBracketToken.Node, arguments.Node.ToGreenSeparatedList<Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.ArgumentSyntax>(), (Syntax.InternalSyntax.SyntaxToken)closeBracketToken.Node).CreateRed();
    }


    /// <summary>Creates a new BracketedArgumentListSyntax instance.</summary>
    public static BracketedArgumentListSyntax BracketedArgumentList(SeparatedSyntaxList<ArgumentSyntax> arguments = default(SeparatedSyntaxList<ArgumentSyntax>))
    {
      return SyntaxFactory.BracketedArgumentList(SyntaxFactory.Token(SyntaxKind.OpenBracketToken), arguments, SyntaxFactory.Token(SyntaxKind.CloseBracketToken));
    }

    /// <summary>Creates a new ArgumentSyntax instance.</summary>
    public static ArgumentSyntax Argument(NameColonSyntax nameColon, SyntaxToken refKindKeyword, ExpressionSyntax expression)
    {
      switch (refKindKeyword.Kind())
      {
        case SyntaxKind.RefKeyword:
        case SyntaxKind.OutKeyword:
        case SyntaxKind.InKeyword:
        case SyntaxKind.None:
          break;
        default:
          throw new ArgumentException(nameof(refKindKeyword));
      }
      if (expression == null)
        throw new ArgumentNullException(nameof(expression));
      return (ArgumentSyntax)Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SyntaxFactory.Argument(nameColon == null ? null : (Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.NameColonSyntax)nameColon.Green, (Syntax.InternalSyntax.SyntaxToken)refKindKeyword.Node, expression == null ? null : (Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.ExpressionSyntax)expression.Green).CreateRed();
    }


    /// <summary>Creates a new ArgumentSyntax instance.</summary>
    public static ArgumentSyntax Argument(ExpressionSyntax expression)
    {
      return SyntaxFactory.Argument(default(NameColonSyntax), default(SyntaxToken), expression);
    }

    /// <summary>Creates a new NameColonSyntax instance.</summary>
    public static NameColonSyntax NameColon(IdentifierNameSyntax name, SyntaxToken colonToken)
    {
      if (name == null)
        throw new ArgumentNullException(nameof(name));
      switch (colonToken.Kind())
      {
        case SyntaxKind.ColonToken:
          break;
        default:
          throw new ArgumentException(nameof(colonToken));
      }
      return (NameColonSyntax)Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SyntaxFactory.NameColon(name == null ? null : (Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.IdentifierNameSyntax)name.Green, (Syntax.InternalSyntax.SyntaxToken)colonToken.Node).CreateRed();
    }


    /// <summary>Creates a new NameColonSyntax instance.</summary>
    public static NameColonSyntax NameColon(IdentifierNameSyntax name)
    {
      return SyntaxFactory.NameColon(name, SyntaxFactory.Token(SyntaxKind.ColonToken));
    }

    /// <summary>Creates a new NameColonSyntax instance.</summary>
    public static NameColonSyntax NameColon(string name)
    {
      return SyntaxFactory.NameColon(SyntaxFactory.IdentifierName(name), SyntaxFactory.Token(SyntaxKind.ColonToken));
    }

    /// <summary>Creates a new DeclarationExpressionSyntax instance.</summary>
    public static DeclarationExpressionSyntax DeclarationExpression(TypeSyntax type, VariableDesignationSyntax designation)
    {
      if (type == null)
        throw new ArgumentNullException(nameof(type));
      if (designation == null)
        throw new ArgumentNullException(nameof(designation));
      return (DeclarationExpressionSyntax)Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SyntaxFactory.DeclarationExpression(type == null ? null : (Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.TypeSyntax)type.Green, designation == null ? null : (Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.VariableDesignationSyntax)designation.Green).CreateRed();
    }


    /// <summary>Creates a new CastExpressionSyntax instance.</summary>
    public static CastExpressionSyntax CastExpression(SyntaxToken openParenToken, TypeSyntax type, SyntaxToken closeParenToken, ExpressionSyntax expression)
    {
      switch (openParenToken.Kind())
      {
        case SyntaxKind.OpenParenToken:
          break;
        default:
          throw new ArgumentException(nameof(openParenToken));
      }
      if (type == null)
        throw new ArgumentNullException(nameof(type));
      switch (closeParenToken.Kind())
      {
        case SyntaxKind.CloseParenToken:
          break;
        default:
          throw new ArgumentException(nameof(closeParenToken));
      }
      if (expression == null)
        throw new ArgumentNullException(nameof(expression));
      return (CastExpressionSyntax)Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SyntaxFactory.CastExpression((Syntax.InternalSyntax.SyntaxToken)openParenToken.Node, type == null ? null : (Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.TypeSyntax)type.Green, (Syntax.InternalSyntax.SyntaxToken)closeParenToken.Node, expression == null ? null : (Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.ExpressionSyntax)expression.Green).CreateRed();
    }


    /// <summary>Creates a new CastExpressionSyntax instance.</summary>
    public static CastExpressionSyntax CastExpression(TypeSyntax type, ExpressionSyntax expression)
    {
      return SyntaxFactory.CastExpression(SyntaxFactory.Token(SyntaxKind.OpenParenToken), type, SyntaxFactory.Token(SyntaxKind.CloseParenToken), expression);
    }

    /// <summary>Creates a new AnonymousMethodExpressionSyntax instance.</summary>
    public static AnonymousMethodExpressionSyntax AnonymousMethodExpression(SyntaxToken asyncKeyword, SyntaxToken delegateKeyword, ParameterListSyntax parameterList, CSharpSyntaxNode body)
    {
      switch (asyncKeyword.Kind())
      {
        case SyntaxKind.AsyncKeyword:
        case SyntaxKind.None:
          break;
        default:
          throw new ArgumentException(nameof(asyncKeyword));
      }
      switch (delegateKeyword.Kind())
      {
        case SyntaxKind.DelegateKeyword:
          break;
        default:
          throw new ArgumentException(nameof(delegateKeyword));
      }
      if (body == null)
        throw new ArgumentNullException(nameof(body));
      return (AnonymousMethodExpressionSyntax)Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SyntaxFactory.AnonymousMethodExpression((Syntax.InternalSyntax.SyntaxToken)asyncKeyword.Node, (Syntax.InternalSyntax.SyntaxToken)delegateKeyword.Node, parameterList == null ? null : (Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.ParameterListSyntax)parameterList.Green, body == null ? null : (Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CSharpSyntaxNode)body.Green).CreateRed();
    }


    /// <summary>Creates a new AnonymousMethodExpressionSyntax instance.</summary>
    public static AnonymousMethodExpressionSyntax AnonymousMethodExpression(ParameterListSyntax parameterList, CSharpSyntaxNode body)
    {
      return SyntaxFactory.AnonymousMethodExpression(default(SyntaxToken), SyntaxFactory.Token(SyntaxKind.DelegateKeyword), parameterList, body);
    }

    /// <summary>Creates a new AnonymousMethodExpressionSyntax instance.</summary>
    public static AnonymousMethodExpressionSyntax AnonymousMethodExpression(CSharpSyntaxNode body)
    {
      return SyntaxFactory.AnonymousMethodExpression(default(SyntaxToken), SyntaxFactory.Token(SyntaxKind.DelegateKeyword), default(ParameterListSyntax), body);
    }

    /// <summary>Creates a new SimpleLambdaExpressionSyntax instance.</summary>
    public static SimpleLambdaExpressionSyntax SimpleLambdaExpression(SyntaxToken asyncKeyword, ParameterSyntax parameter, SyntaxToken arrowToken, CSharpSyntaxNode body)
    {
      switch (asyncKeyword.Kind())
      {
        case SyntaxKind.AsyncKeyword:
        case SyntaxKind.None:
          break;
        default:
          throw new ArgumentException(nameof(asyncKeyword));
      }
      if (parameter == null)
        throw new ArgumentNullException(nameof(parameter));
      switch (arrowToken.Kind())
      {
        case SyntaxKind.EqualsGreaterThanToken:
          break;
        default:
          throw new ArgumentException(nameof(arrowToken));
      }
      if (body == null)
        throw new ArgumentNullException(nameof(body));
      return (SimpleLambdaExpressionSyntax)Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SyntaxFactory.SimpleLambdaExpression((Syntax.InternalSyntax.SyntaxToken)asyncKeyword.Node, parameter == null ? null : (Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.ParameterSyntax)parameter.Green, (Syntax.InternalSyntax.SyntaxToken)arrowToken.Node, body == null ? null : (Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CSharpSyntaxNode)body.Green).CreateRed();
    }


    /// <summary>Creates a new SimpleLambdaExpressionSyntax instance.</summary>
    public static SimpleLambdaExpressionSyntax SimpleLambdaExpression(ParameterSyntax parameter, CSharpSyntaxNode body)
    {
      return SyntaxFactory.SimpleLambdaExpression(default(SyntaxToken), parameter, SyntaxFactory.Token(SyntaxKind.EqualsGreaterThanToken), body);
    }

    /// <summary>Creates a new RefExpressionSyntax instance.</summary>
    public static RefExpressionSyntax RefExpression(SyntaxToken refKeyword, ExpressionSyntax expression)
    {
      switch (refKeyword.Kind())
      {
        case SyntaxKind.RefKeyword:
          break;
        default:
          throw new ArgumentException(nameof(refKeyword));
      }
      if (expression == null)
        throw new ArgumentNullException(nameof(expression));
      return (RefExpressionSyntax)Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SyntaxFactory.RefExpression((Syntax.InternalSyntax.SyntaxToken)refKeyword.Node, expression == null ? null : (Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.ExpressionSyntax)expression.Green).CreateRed();
    }


    /// <summary>Creates a new RefExpressionSyntax instance.</summary>
    public static RefExpressionSyntax RefExpression(ExpressionSyntax expression)
    {
      return SyntaxFactory.RefExpression(SyntaxFactory.Token(SyntaxKind.RefKeyword), expression);
    }

    /// <summary>Creates a new ParenthesizedLambdaExpressionSyntax instance.</summary>
    public static ParenthesizedLambdaExpressionSyntax ParenthesizedLambdaExpression(SyntaxToken asyncKeyword, ParameterListSyntax parameterList, SyntaxToken arrowToken, CSharpSyntaxNode body)
    {
      switch (asyncKeyword.Kind())
      {
        case SyntaxKind.AsyncKeyword:
        case SyntaxKind.None:
          break;
        default:
          throw new ArgumentException(nameof(asyncKeyword));
      }
      if (parameterList == null)
        throw new ArgumentNullException(nameof(parameterList));
      switch (arrowToken.Kind())
      {
        case SyntaxKind.EqualsGreaterThanToken:
          break;
        default:
          throw new ArgumentException(nameof(arrowToken));
      }
      if (body == null)
        throw new ArgumentNullException(nameof(body));
      return (ParenthesizedLambdaExpressionSyntax)Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SyntaxFactory.ParenthesizedLambdaExpression((Syntax.InternalSyntax.SyntaxToken)asyncKeyword.Node, parameterList == null ? null : (Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.ParameterListSyntax)parameterList.Green, (Syntax.InternalSyntax.SyntaxToken)arrowToken.Node, body == null ? null : (Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CSharpSyntaxNode)body.Green).CreateRed();
    }


    /// <summary>Creates a new ParenthesizedLambdaExpressionSyntax instance.</summary>
    public static ParenthesizedLambdaExpressionSyntax ParenthesizedLambdaExpression(ParameterListSyntax parameterList, CSharpSyntaxNode body)
    {
      return SyntaxFactory.ParenthesizedLambdaExpression(default(SyntaxToken), parameterList, SyntaxFactory.Token(SyntaxKind.EqualsGreaterThanToken), body);
    }

    /// <summary>Creates a new ParenthesizedLambdaExpressionSyntax instance.</summary>
    public static ParenthesizedLambdaExpressionSyntax ParenthesizedLambdaExpression(CSharpSyntaxNode body)
    {
      return SyntaxFactory.ParenthesizedLambdaExpression(default(SyntaxToken), SyntaxFactory.ParameterList(), SyntaxFactory.Token(SyntaxKind.EqualsGreaterThanToken), body);
    }

    /// <summary>Creates a new InitializerExpressionSyntax instance.</summary>
    public static InitializerExpressionSyntax InitializerExpression(SyntaxKind kind, SyntaxToken openBraceToken, SeparatedSyntaxList<ExpressionSyntax> expressions, SyntaxToken closeBraceToken)
    {
      switch (kind)
      {
        case SyntaxKind.ObjectInitializerExpression:
        case SyntaxKind.CollectionInitializerExpression:
        case SyntaxKind.ArrayInitializerExpression:
        case SyntaxKind.ComplexElementInitializerExpression:
          break;
        default:
          throw new ArgumentException(nameof(kind));
      }
      switch (openBraceToken.Kind())
      {
        case SyntaxKind.OpenBraceToken:
          break;
        default:
          throw new ArgumentException(nameof(openBraceToken));
      }
      switch (closeBraceToken.Kind())
      {
        case SyntaxKind.CloseBraceToken:
          break;
        default:
          throw new ArgumentException(nameof(closeBraceToken));
      }
      return (InitializerExpressionSyntax)Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SyntaxFactory.InitializerExpression(kind, (Syntax.InternalSyntax.SyntaxToken)openBraceToken.Node, expressions.Node.ToGreenSeparatedList<Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.ExpressionSyntax>(), (Syntax.InternalSyntax.SyntaxToken)closeBraceToken.Node).CreateRed();
    }


    /// <summary>Creates a new InitializerExpressionSyntax instance.</summary>
    public static InitializerExpressionSyntax InitializerExpression(SyntaxKind kind, SeparatedSyntaxList<ExpressionSyntax> expressions = default(SeparatedSyntaxList<ExpressionSyntax>))
    {
      return SyntaxFactory.InitializerExpression(kind, SyntaxFactory.Token(SyntaxKind.OpenBraceToken), expressions, SyntaxFactory.Token(SyntaxKind.CloseBraceToken));
    }

    /// <summary>Creates a new ObjectCreationExpressionSyntax instance.</summary>
    public static ObjectCreationExpressionSyntax ObjectCreationExpression(SyntaxToken newKeyword, TypeSyntax type, ArgumentListSyntax argumentList, InitializerExpressionSyntax initializer)
    {
      switch (newKeyword.Kind())
      {
        case SyntaxKind.NewKeyword:
          break;
        default:
          throw new ArgumentException(nameof(newKeyword));
      }
      if (type == null)
        throw new ArgumentNullException(nameof(type));
      return (ObjectCreationExpressionSyntax)Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SyntaxFactory.ObjectCreationExpression((Syntax.InternalSyntax.SyntaxToken)newKeyword.Node, type == null ? null : (Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.TypeSyntax)type.Green, argumentList == null ? null : (Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.ArgumentListSyntax)argumentList.Green, initializer == null ? null : (Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.InitializerExpressionSyntax)initializer.Green).CreateRed();
    }


    /// <summary>Creates a new ObjectCreationExpressionSyntax instance.</summary>
    public static ObjectCreationExpressionSyntax ObjectCreationExpression(TypeSyntax type, ArgumentListSyntax argumentList, InitializerExpressionSyntax initializer)
    {
      return SyntaxFactory.ObjectCreationExpression(SyntaxFactory.Token(SyntaxKind.NewKeyword), type, argumentList, initializer);
    }

    /// <summary>Creates a new ObjectCreationExpressionSyntax instance.</summary>
    public static ObjectCreationExpressionSyntax ObjectCreationExpression(TypeSyntax type)
    {
      return SyntaxFactory.ObjectCreationExpression(SyntaxFactory.Token(SyntaxKind.NewKeyword), type, default(ArgumentListSyntax), default(InitializerExpressionSyntax));
    }

    /// <summary>Creates a new AnonymousObjectMemberDeclaratorSyntax instance.</summary>
    public static AnonymousObjectMemberDeclaratorSyntax AnonymousObjectMemberDeclarator(NameEqualsSyntax nameEquals, ExpressionSyntax expression)
    {
      if (expression == null)
        throw new ArgumentNullException(nameof(expression));
      return (AnonymousObjectMemberDeclaratorSyntax)Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SyntaxFactory.AnonymousObjectMemberDeclarator(nameEquals == null ? null : (Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.NameEqualsSyntax)nameEquals.Green, expression == null ? null : (Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.ExpressionSyntax)expression.Green).CreateRed();
    }


    /// <summary>Creates a new AnonymousObjectMemberDeclaratorSyntax instance.</summary>
    public static AnonymousObjectMemberDeclaratorSyntax AnonymousObjectMemberDeclarator(ExpressionSyntax expression)
    {
      return SyntaxFactory.AnonymousObjectMemberDeclarator(default(NameEqualsSyntax), expression);
    }

    /// <summary>Creates a new AnonymousObjectCreationExpressionSyntax instance.</summary>
    public static AnonymousObjectCreationExpressionSyntax AnonymousObjectCreationExpression(SyntaxToken newKeyword, SyntaxToken openBraceToken, SeparatedSyntaxList<AnonymousObjectMemberDeclaratorSyntax> initializers, SyntaxToken closeBraceToken)
    {
      switch (newKeyword.Kind())
      {
        case SyntaxKind.NewKeyword:
          break;
        default:
          throw new ArgumentException(nameof(newKeyword));
      }
      switch (openBraceToken.Kind())
      {
        case SyntaxKind.OpenBraceToken:
          break;
        default:
          throw new ArgumentException(nameof(openBraceToken));
      }
      switch (closeBraceToken.Kind())
      {
        case SyntaxKind.CloseBraceToken:
          break;
        default:
          throw new ArgumentException(nameof(closeBraceToken));
      }
      return (AnonymousObjectCreationExpressionSyntax)Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SyntaxFactory.AnonymousObjectCreationExpression((Syntax.InternalSyntax.SyntaxToken)newKeyword.Node, (Syntax.InternalSyntax.SyntaxToken)openBraceToken.Node, initializers.Node.ToGreenSeparatedList<Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.AnonymousObjectMemberDeclaratorSyntax>(), (Syntax.InternalSyntax.SyntaxToken)closeBraceToken.Node).CreateRed();
    }


    /// <summary>Creates a new AnonymousObjectCreationExpressionSyntax instance.</summary>
    public static AnonymousObjectCreationExpressionSyntax AnonymousObjectCreationExpression(SeparatedSyntaxList<AnonymousObjectMemberDeclaratorSyntax> initializers = default(SeparatedSyntaxList<AnonymousObjectMemberDeclaratorSyntax>))
    {
      return SyntaxFactory.AnonymousObjectCreationExpression(SyntaxFactory.Token(SyntaxKind.NewKeyword), SyntaxFactory.Token(SyntaxKind.OpenBraceToken), initializers, SyntaxFactory.Token(SyntaxKind.CloseBraceToken));
    }

    /// <summary>Creates a new ArrayCreationExpressionSyntax instance.</summary>
    public static ArrayCreationExpressionSyntax ArrayCreationExpression(SyntaxToken newKeyword, ArrayTypeSyntax type, InitializerExpressionSyntax initializer)
    {
      switch (newKeyword.Kind())
      {
        case SyntaxKind.NewKeyword:
          break;
        default:
          throw new ArgumentException(nameof(newKeyword));
      }
      if (type == null)
        throw new ArgumentNullException(nameof(type));
      return (ArrayCreationExpressionSyntax)Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SyntaxFactory.ArrayCreationExpression((Syntax.InternalSyntax.SyntaxToken)newKeyword.Node, type == null ? null : (Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.ArrayTypeSyntax)type.Green, initializer == null ? null : (Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.InitializerExpressionSyntax)initializer.Green).CreateRed();
    }


    /// <summary>Creates a new ArrayCreationExpressionSyntax instance.</summary>
    public static ArrayCreationExpressionSyntax ArrayCreationExpression(ArrayTypeSyntax type, InitializerExpressionSyntax initializer)
    {
      return SyntaxFactory.ArrayCreationExpression(SyntaxFactory.Token(SyntaxKind.NewKeyword), type, initializer);
    }

    /// <summary>Creates a new ArrayCreationExpressionSyntax instance.</summary>
    public static ArrayCreationExpressionSyntax ArrayCreationExpression(ArrayTypeSyntax type)
    {
      return SyntaxFactory.ArrayCreationExpression(SyntaxFactory.Token(SyntaxKind.NewKeyword), type, default(InitializerExpressionSyntax));
    }

    /// <summary>Creates a new ImplicitArrayCreationExpressionSyntax instance.</summary>
    public static ImplicitArrayCreationExpressionSyntax ImplicitArrayCreationExpression(SyntaxToken newKeyword, SyntaxToken openBracketToken, SyntaxTokenList commas, SyntaxToken closeBracketToken, InitializerExpressionSyntax initializer)
    {
      switch (newKeyword.Kind())
      {
        case SyntaxKind.NewKeyword:
          break;
        default:
          throw new ArgumentException(nameof(newKeyword));
      }
      switch (openBracketToken.Kind())
      {
        case SyntaxKind.OpenBracketToken:
          break;
        default:
          throw new ArgumentException(nameof(openBracketToken));
      }
      switch (closeBracketToken.Kind())
      {
        case SyntaxKind.CloseBracketToken:
          break;
        default:
          throw new ArgumentException(nameof(closeBracketToken));
      }
      if (initializer == null)
        throw new ArgumentNullException(nameof(initializer));
      return (ImplicitArrayCreationExpressionSyntax)Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SyntaxFactory.ImplicitArrayCreationExpression((Syntax.InternalSyntax.SyntaxToken)newKeyword.Node, (Syntax.InternalSyntax.SyntaxToken)openBracketToken.Node, commas.Node.ToGreenList<Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SyntaxToken>(), (Syntax.InternalSyntax.SyntaxToken)closeBracketToken.Node, initializer == null ? null : (Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.InitializerExpressionSyntax)initializer.Green).CreateRed();
    }


    /// <summary>Creates a new ImplicitArrayCreationExpressionSyntax instance.</summary>
    public static ImplicitArrayCreationExpressionSyntax ImplicitArrayCreationExpression(SyntaxTokenList commas, InitializerExpressionSyntax initializer)
    {
      return SyntaxFactory.ImplicitArrayCreationExpression(SyntaxFactory.Token(SyntaxKind.NewKeyword), SyntaxFactory.Token(SyntaxKind.OpenBracketToken), commas, SyntaxFactory.Token(SyntaxKind.CloseBracketToken), initializer);
    }

    /// <summary>Creates a new ImplicitArrayCreationExpressionSyntax instance.</summary>
    public static ImplicitArrayCreationExpressionSyntax ImplicitArrayCreationExpression(InitializerExpressionSyntax initializer)
    {
      return SyntaxFactory.ImplicitArrayCreationExpression(SyntaxFactory.Token(SyntaxKind.NewKeyword), SyntaxFactory.Token(SyntaxKind.OpenBracketToken), default(SyntaxTokenList), SyntaxFactory.Token(SyntaxKind.CloseBracketToken), initializer);
    }

    /// <summary>Creates a new StackAllocArrayCreationExpressionSyntax instance.</summary>
    public static StackAllocArrayCreationExpressionSyntax StackAllocArrayCreationExpression(SyntaxToken stackAllocKeyword, TypeSyntax type, InitializerExpressionSyntax initializer)
    {
      switch (stackAllocKeyword.Kind())
      {
        case SyntaxKind.StackAllocKeyword:
          break;
        default:
          throw new ArgumentException(nameof(stackAllocKeyword));
      }
      if (type == null)
        throw new ArgumentNullException(nameof(type));
      return (StackAllocArrayCreationExpressionSyntax)Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SyntaxFactory.StackAllocArrayCreationExpression((Syntax.InternalSyntax.SyntaxToken)stackAllocKeyword.Node, type == null ? null : (Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.TypeSyntax)type.Green, initializer == null ? null : (Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.InitializerExpressionSyntax)initializer.Green).CreateRed();
    }


    /// <summary>Creates a new StackAllocArrayCreationExpressionSyntax instance.</summary>
    public static StackAllocArrayCreationExpressionSyntax StackAllocArrayCreationExpression(TypeSyntax type, InitializerExpressionSyntax initializer)
    {
      return SyntaxFactory.StackAllocArrayCreationExpression(SyntaxFactory.Token(SyntaxKind.StackAllocKeyword), type, initializer);
    }

    /// <summary>Creates a new StackAllocArrayCreationExpressionSyntax instance.</summary>
    public static StackAllocArrayCreationExpressionSyntax StackAllocArrayCreationExpression(TypeSyntax type)
    {
      return SyntaxFactory.StackAllocArrayCreationExpression(SyntaxFactory.Token(SyntaxKind.StackAllocKeyword), type, default(InitializerExpressionSyntax));
    }

    /// <summary>Creates a new ImplicitStackAllocArrayCreationExpressionSyntax instance.</summary>
    public static ImplicitStackAllocArrayCreationExpressionSyntax ImplicitStackAllocArrayCreationExpression(SyntaxToken stackAllocKeyword, SyntaxToken openBracketToken, SyntaxToken closeBracketToken, InitializerExpressionSyntax initializer)
    {
      switch (stackAllocKeyword.Kind())
      {
        case SyntaxKind.StackAllocKeyword:
          break;
        default:
          throw new ArgumentException(nameof(stackAllocKeyword));
      }
      switch (openBracketToken.Kind())
      {
        case SyntaxKind.OpenBracketToken:
          break;
        default:
          throw new ArgumentException(nameof(openBracketToken));
      }
      switch (closeBracketToken.Kind())
      {
        case SyntaxKind.CloseBracketToken:
          break;
        default:
          throw new ArgumentException(nameof(closeBracketToken));
      }
      if (initializer == null)
        throw new ArgumentNullException(nameof(initializer));
      return (ImplicitStackAllocArrayCreationExpressionSyntax)Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SyntaxFactory.ImplicitStackAllocArrayCreationExpression((Syntax.InternalSyntax.SyntaxToken)stackAllocKeyword.Node, (Syntax.InternalSyntax.SyntaxToken)openBracketToken.Node, (Syntax.InternalSyntax.SyntaxToken)closeBracketToken.Node, initializer == null ? null : (Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.InitializerExpressionSyntax)initializer.Green).CreateRed();
    }


    /// <summary>Creates a new ImplicitStackAllocArrayCreationExpressionSyntax instance.</summary>
    public static ImplicitStackAllocArrayCreationExpressionSyntax ImplicitStackAllocArrayCreationExpression(InitializerExpressionSyntax initializer)
    {
      return SyntaxFactory.ImplicitStackAllocArrayCreationExpression(SyntaxFactory.Token(SyntaxKind.StackAllocKeyword), SyntaxFactory.Token(SyntaxKind.OpenBracketToken), SyntaxFactory.Token(SyntaxKind.CloseBracketToken), initializer);
    }

    /// <summary>Creates a new QueryExpressionSyntax instance.</summary>
    public static QueryExpressionSyntax QueryExpression(FromClauseSyntax fromClause, QueryBodySyntax body)
    {
      if (fromClause == null)
        throw new ArgumentNullException(nameof(fromClause));
      if (body == null)
        throw new ArgumentNullException(nameof(body));
      return (QueryExpressionSyntax)Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SyntaxFactory.QueryExpression(fromClause == null ? null : (Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.FromClauseSyntax)fromClause.Green, body == null ? null : (Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.QueryBodySyntax)body.Green).CreateRed();
    }


    /// <summary>Creates a new QueryBodySyntax instance.</summary>
    public static QueryBodySyntax QueryBody(SyntaxList<QueryClauseSyntax> clauses, SelectOrGroupClauseSyntax selectOrGroup, QueryContinuationSyntax continuation)
    {
      if (selectOrGroup == null)
        throw new ArgumentNullException(nameof(selectOrGroup));
      return (QueryBodySyntax)Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SyntaxFactory.QueryBody(clauses.Node.ToGreenList<Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.QueryClauseSyntax>(), selectOrGroup == null ? null : (Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SelectOrGroupClauseSyntax)selectOrGroup.Green, continuation == null ? null : (Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.QueryContinuationSyntax)continuation.Green).CreateRed();
    }


    /// <summary>Creates a new QueryBodySyntax instance.</summary>
    public static QueryBodySyntax QueryBody(SelectOrGroupClauseSyntax selectOrGroup)
    {
      return SyntaxFactory.QueryBody(default(SyntaxList<QueryClauseSyntax>), selectOrGroup, default(QueryContinuationSyntax));
    }

    /// <summary>Creates a new FromClauseSyntax instance.</summary>
    public static FromClauseSyntax FromClause(SyntaxToken fromKeyword, TypeSyntax type, SyntaxToken identifier, SyntaxToken inKeyword, ExpressionSyntax expression)
    {
      switch (fromKeyword.Kind())
      {
        case SyntaxKind.FromKeyword:
          break;
        default:
          throw new ArgumentException(nameof(fromKeyword));
      }
      switch (identifier.Kind())
      {
        case SyntaxKind.IdentifierToken:
          break;
        default:
          throw new ArgumentException(nameof(identifier));
      }
      switch (inKeyword.Kind())
      {
        case SyntaxKind.InKeyword:
          break;
        default:
          throw new ArgumentException(nameof(inKeyword));
      }
      if (expression == null)
        throw new ArgumentNullException(nameof(expression));
      return (FromClauseSyntax)Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SyntaxFactory.FromClause((Syntax.InternalSyntax.SyntaxToken)fromKeyword.Node, type == null ? null : (Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.TypeSyntax)type.Green, (Syntax.InternalSyntax.SyntaxToken)identifier.Node, (Syntax.InternalSyntax.SyntaxToken)inKeyword.Node, expression == null ? null : (Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.ExpressionSyntax)expression.Green).CreateRed();
    }


    /// <summary>Creates a new FromClauseSyntax instance.</summary>
    public static FromClauseSyntax FromClause(TypeSyntax type, SyntaxToken identifier, ExpressionSyntax expression)
    {
      return SyntaxFactory.FromClause(SyntaxFactory.Token(SyntaxKind.FromKeyword), type, identifier, SyntaxFactory.Token(SyntaxKind.InKeyword), expression);
    }

    /// <summary>Creates a new FromClauseSyntax instance.</summary>
    public static FromClauseSyntax FromClause(SyntaxToken identifier, ExpressionSyntax expression)
    {
      return SyntaxFactory.FromClause(SyntaxFactory.Token(SyntaxKind.FromKeyword), default(TypeSyntax), identifier, SyntaxFactory.Token(SyntaxKind.InKeyword), expression);
    }

    /// <summary>Creates a new FromClauseSyntax instance.</summary>
    public static FromClauseSyntax FromClause(string identifier, ExpressionSyntax expression)
    {
      return SyntaxFactory.FromClause(SyntaxFactory.Token(SyntaxKind.FromKeyword), default(TypeSyntax), SyntaxFactory.Identifier(identifier), SyntaxFactory.Token(SyntaxKind.InKeyword), expression);
    }

    /// <summary>Creates a new LetClauseSyntax instance.</summary>
    public static LetClauseSyntax LetClause(SyntaxToken letKeyword, SyntaxToken identifier, SyntaxToken equalsToken, ExpressionSyntax expression)
    {
      switch (letKeyword.Kind())
      {
        case SyntaxKind.LetKeyword:
          break;
        default:
          throw new ArgumentException(nameof(letKeyword));
      }
      switch (identifier.Kind())
      {
        case SyntaxKind.IdentifierToken:
          break;
        default:
          throw new ArgumentException(nameof(identifier));
      }
      switch (equalsToken.Kind())
      {
        case SyntaxKind.EqualsToken:
          break;
        default:
          throw new ArgumentException(nameof(equalsToken));
      }
      if (expression == null)
        throw new ArgumentNullException(nameof(expression));
      return (LetClauseSyntax)Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SyntaxFactory.LetClause((Syntax.InternalSyntax.SyntaxToken)letKeyword.Node, (Syntax.InternalSyntax.SyntaxToken)identifier.Node, (Syntax.InternalSyntax.SyntaxToken)equalsToken.Node, expression == null ? null : (Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.ExpressionSyntax)expression.Green).CreateRed();
    }


    /// <summary>Creates a new LetClauseSyntax instance.</summary>
    public static LetClauseSyntax LetClause(SyntaxToken identifier, ExpressionSyntax expression)
    {
      return SyntaxFactory.LetClause(SyntaxFactory.Token(SyntaxKind.LetKeyword), identifier, SyntaxFactory.Token(SyntaxKind.EqualsToken), expression);
    }

    /// <summary>Creates a new LetClauseSyntax instance.</summary>
    public static LetClauseSyntax LetClause(string identifier, ExpressionSyntax expression)
    {
      return SyntaxFactory.LetClause(SyntaxFactory.Token(SyntaxKind.LetKeyword), SyntaxFactory.Identifier(identifier), SyntaxFactory.Token(SyntaxKind.EqualsToken), expression);
    }

    /// <summary>Creates a new JoinClauseSyntax instance.</summary>
    public static JoinClauseSyntax JoinClause(SyntaxToken joinKeyword, TypeSyntax type, SyntaxToken identifier, SyntaxToken inKeyword, ExpressionSyntax inExpression, SyntaxToken onKeyword, ExpressionSyntax leftExpression, SyntaxToken equalsKeyword, ExpressionSyntax rightExpression, JoinIntoClauseSyntax into)
    {
      switch (joinKeyword.Kind())
      {
        case SyntaxKind.JoinKeyword:
          break;
        default:
          throw new ArgumentException(nameof(joinKeyword));
      }
      switch (identifier.Kind())
      {
        case SyntaxKind.IdentifierToken:
          break;
        default:
          throw new ArgumentException(nameof(identifier));
      }
      switch (inKeyword.Kind())
      {
        case SyntaxKind.InKeyword:
          break;
        default:
          throw new ArgumentException(nameof(inKeyword));
      }
      if (inExpression == null)
        throw new ArgumentNullException(nameof(inExpression));
      switch (onKeyword.Kind())
      {
        case SyntaxKind.OnKeyword:
          break;
        default:
          throw new ArgumentException(nameof(onKeyword));
      }
      if (leftExpression == null)
        throw new ArgumentNullException(nameof(leftExpression));
      switch (equalsKeyword.Kind())
      {
        case SyntaxKind.EqualsKeyword:
          break;
        default:
          throw new ArgumentException(nameof(equalsKeyword));
      }
      if (rightExpression == null)
        throw new ArgumentNullException(nameof(rightExpression));
      return (JoinClauseSyntax)Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SyntaxFactory.JoinClause((Syntax.InternalSyntax.SyntaxToken)joinKeyword.Node, type == null ? null : (Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.TypeSyntax)type.Green, (Syntax.InternalSyntax.SyntaxToken)identifier.Node, (Syntax.InternalSyntax.SyntaxToken)inKeyword.Node, inExpression == null ? null : (Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.ExpressionSyntax)inExpression.Green, (Syntax.InternalSyntax.SyntaxToken)onKeyword.Node, leftExpression == null ? null : (Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.ExpressionSyntax)leftExpression.Green, (Syntax.InternalSyntax.SyntaxToken)equalsKeyword.Node, rightExpression == null ? null : (Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.ExpressionSyntax)rightExpression.Green, into == null ? null : (Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.JoinIntoClauseSyntax)into.Green).CreateRed();
    }


    /// <summary>Creates a new JoinClauseSyntax instance.</summary>
    public static JoinClauseSyntax JoinClause(TypeSyntax type, SyntaxToken identifier, ExpressionSyntax inExpression, ExpressionSyntax leftExpression, ExpressionSyntax rightExpression, JoinIntoClauseSyntax into)
    {
      return SyntaxFactory.JoinClause(SyntaxFactory.Token(SyntaxKind.JoinKeyword), type, identifier, SyntaxFactory.Token(SyntaxKind.InKeyword), inExpression, SyntaxFactory.Token(SyntaxKind.OnKeyword), leftExpression, SyntaxFactory.Token(SyntaxKind.EqualsKeyword), rightExpression, into);
    }

    /// <summary>Creates a new JoinClauseSyntax instance.</summary>
    public static JoinClauseSyntax JoinClause(SyntaxToken identifier, ExpressionSyntax inExpression, ExpressionSyntax leftExpression, ExpressionSyntax rightExpression)
    {
      return SyntaxFactory.JoinClause(SyntaxFactory.Token(SyntaxKind.JoinKeyword), default(TypeSyntax), identifier, SyntaxFactory.Token(SyntaxKind.InKeyword), inExpression, SyntaxFactory.Token(SyntaxKind.OnKeyword), leftExpression, SyntaxFactory.Token(SyntaxKind.EqualsKeyword), rightExpression, default(JoinIntoClauseSyntax));
    }

    /// <summary>Creates a new JoinClauseSyntax instance.</summary>
    public static JoinClauseSyntax JoinClause(string identifier, ExpressionSyntax inExpression, ExpressionSyntax leftExpression, ExpressionSyntax rightExpression)
    {
      return SyntaxFactory.JoinClause(SyntaxFactory.Token(SyntaxKind.JoinKeyword), default(TypeSyntax), SyntaxFactory.Identifier(identifier), SyntaxFactory.Token(SyntaxKind.InKeyword), inExpression, SyntaxFactory.Token(SyntaxKind.OnKeyword), leftExpression, SyntaxFactory.Token(SyntaxKind.EqualsKeyword), rightExpression, default(JoinIntoClauseSyntax));
    }

    /// <summary>Creates a new JoinIntoClauseSyntax instance.</summary>
    public static JoinIntoClauseSyntax JoinIntoClause(SyntaxToken intoKeyword, SyntaxToken identifier)
    {
      switch (intoKeyword.Kind())
      {
        case SyntaxKind.IntoKeyword:
          break;
        default:
          throw new ArgumentException(nameof(intoKeyword));
      }
      switch (identifier.Kind())
      {
        case SyntaxKind.IdentifierToken:
          break;
        default:
          throw new ArgumentException(nameof(identifier));
      }
      return (JoinIntoClauseSyntax)Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SyntaxFactory.JoinIntoClause((Syntax.InternalSyntax.SyntaxToken)intoKeyword.Node, (Syntax.InternalSyntax.SyntaxToken)identifier.Node).CreateRed();
    }


    /// <summary>Creates a new JoinIntoClauseSyntax instance.</summary>
    public static JoinIntoClauseSyntax JoinIntoClause(SyntaxToken identifier)
    {
      return SyntaxFactory.JoinIntoClause(SyntaxFactory.Token(SyntaxKind.IntoKeyword), identifier);
    }

    /// <summary>Creates a new JoinIntoClauseSyntax instance.</summary>
    public static JoinIntoClauseSyntax JoinIntoClause(string identifier)
    {
      return SyntaxFactory.JoinIntoClause(SyntaxFactory.Token(SyntaxKind.IntoKeyword), SyntaxFactory.Identifier(identifier));
    }

    /// <summary>Creates a new WhereClauseSyntax instance.</summary>
    public static WhereClauseSyntax WhereClause(SyntaxToken whereKeyword, ExpressionSyntax condition)
    {
      switch (whereKeyword.Kind())
      {
        case SyntaxKind.WhereKeyword:
          break;
        default:
          throw new ArgumentException(nameof(whereKeyword));
      }
      if (condition == null)
        throw new ArgumentNullException(nameof(condition));
      return (WhereClauseSyntax)Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SyntaxFactory.WhereClause((Syntax.InternalSyntax.SyntaxToken)whereKeyword.Node, condition == null ? null : (Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.ExpressionSyntax)condition.Green).CreateRed();
    }


    /// <summary>Creates a new WhereClauseSyntax instance.</summary>
    public static WhereClauseSyntax WhereClause(ExpressionSyntax condition)
    {
      return SyntaxFactory.WhereClause(SyntaxFactory.Token(SyntaxKind.WhereKeyword), condition);
    }

    /// <summary>Creates a new OrderByClauseSyntax instance.</summary>
    public static OrderByClauseSyntax OrderByClause(SyntaxToken orderByKeyword, SeparatedSyntaxList<OrderingSyntax> orderings)
    {
      switch (orderByKeyword.Kind())
      {
        case SyntaxKind.OrderByKeyword:
          break;
        default:
          throw new ArgumentException(nameof(orderByKeyword));
      }
      return (OrderByClauseSyntax)Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SyntaxFactory.OrderByClause((Syntax.InternalSyntax.SyntaxToken)orderByKeyword.Node, orderings.Node.ToGreenSeparatedList<Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.OrderingSyntax>()).CreateRed();
    }


    /// <summary>Creates a new OrderByClauseSyntax instance.</summary>
    public static OrderByClauseSyntax OrderByClause(SeparatedSyntaxList<OrderingSyntax> orderings = default(SeparatedSyntaxList<OrderingSyntax>))
    {
      return SyntaxFactory.OrderByClause(SyntaxFactory.Token(SyntaxKind.OrderByKeyword), orderings);
    }

    /// <summary>Creates a new OrderingSyntax instance.</summary>
    public static OrderingSyntax Ordering(SyntaxKind kind, ExpressionSyntax expression, SyntaxToken ascendingOrDescendingKeyword)
    {
      switch (kind)
      {
        case SyntaxKind.AscendingOrdering:
        case SyntaxKind.DescendingOrdering:
          break;
        default:
          throw new ArgumentException(nameof(kind));
      }
      if (expression == null)
        throw new ArgumentNullException(nameof(expression));
      switch (ascendingOrDescendingKeyword.Kind())
      {
        case SyntaxKind.AscendingKeyword:
        case SyntaxKind.DescendingKeyword:
        case SyntaxKind.None:
          break;
        default:
          throw new ArgumentException(nameof(ascendingOrDescendingKeyword));
      }
      return (OrderingSyntax)Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SyntaxFactory.Ordering(kind, expression == null ? null : (Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.ExpressionSyntax)expression.Green, (Syntax.InternalSyntax.SyntaxToken)ascendingOrDescendingKeyword.Node).CreateRed();
    }


    /// <summary>Creates a new OrderingSyntax instance.</summary>
    public static OrderingSyntax Ordering(SyntaxKind kind, ExpressionSyntax expression)
    {
      return SyntaxFactory.Ordering(kind, expression, default(SyntaxToken));
    }

    private static SyntaxKind GetOrderingAscendingOrDescendingKeywordKind(SyntaxKind kind)
    {
      switch (kind)
      {
        case SyntaxKind.AscendingOrdering:
          return SyntaxKind.AscendingKeyword;
        case SyntaxKind.DescendingOrdering:
          return SyntaxKind.DescendingKeyword;
        default:
          throw new ArgumentOutOfRangeException();
      }
    }

    /// <summary>Creates a new SelectClauseSyntax instance.</summary>
    public static SelectClauseSyntax SelectClause(SyntaxToken selectKeyword, ExpressionSyntax expression)
    {
      switch (selectKeyword.Kind())
      {
        case SyntaxKind.SelectKeyword:
          break;
        default:
          throw new ArgumentException(nameof(selectKeyword));
      }
      if (expression == null)
        throw new ArgumentNullException(nameof(expression));
      return (SelectClauseSyntax)Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SyntaxFactory.SelectClause((Syntax.InternalSyntax.SyntaxToken)selectKeyword.Node, expression == null ? null : (Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.ExpressionSyntax)expression.Green).CreateRed();
    }


    /// <summary>Creates a new SelectClauseSyntax instance.</summary>
    public static SelectClauseSyntax SelectClause(ExpressionSyntax expression)
    {
      return SyntaxFactory.SelectClause(SyntaxFactory.Token(SyntaxKind.SelectKeyword), expression);
    }

    /// <summary>Creates a new GroupClauseSyntax instance.</summary>
    public static GroupClauseSyntax GroupClause(SyntaxToken groupKeyword, ExpressionSyntax groupExpression, SyntaxToken byKeyword, ExpressionSyntax byExpression)
    {
      switch (groupKeyword.Kind())
      {
        case SyntaxKind.GroupKeyword:
          break;
        default:
          throw new ArgumentException(nameof(groupKeyword));
      }
      if (groupExpression == null)
        throw new ArgumentNullException(nameof(groupExpression));
      switch (byKeyword.Kind())
      {
        case SyntaxKind.ByKeyword:
          break;
        default:
          throw new ArgumentException(nameof(byKeyword));
      }
      if (byExpression == null)
        throw new ArgumentNullException(nameof(byExpression));
      return (GroupClauseSyntax)Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SyntaxFactory.GroupClause((Syntax.InternalSyntax.SyntaxToken)groupKeyword.Node, groupExpression == null ? null : (Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.ExpressionSyntax)groupExpression.Green, (Syntax.InternalSyntax.SyntaxToken)byKeyword.Node, byExpression == null ? null : (Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.ExpressionSyntax)byExpression.Green).CreateRed();
    }


    /// <summary>Creates a new GroupClauseSyntax instance.</summary>
    public static GroupClauseSyntax GroupClause(ExpressionSyntax groupExpression, ExpressionSyntax byExpression)
    {
      return SyntaxFactory.GroupClause(SyntaxFactory.Token(SyntaxKind.GroupKeyword), groupExpression, SyntaxFactory.Token(SyntaxKind.ByKeyword), byExpression);
    }

    /// <summary>Creates a new QueryContinuationSyntax instance.</summary>
    public static QueryContinuationSyntax QueryContinuation(SyntaxToken intoKeyword, SyntaxToken identifier, QueryBodySyntax body)
    {
      switch (intoKeyword.Kind())
      {
        case SyntaxKind.IntoKeyword:
          break;
        default:
          throw new ArgumentException(nameof(intoKeyword));
      }
      switch (identifier.Kind())
      {
        case SyntaxKind.IdentifierToken:
          break;
        default:
          throw new ArgumentException(nameof(identifier));
      }
      if (body == null)
        throw new ArgumentNullException(nameof(body));
      return (QueryContinuationSyntax)Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SyntaxFactory.QueryContinuation((Syntax.InternalSyntax.SyntaxToken)intoKeyword.Node, (Syntax.InternalSyntax.SyntaxToken)identifier.Node, body == null ? null : (Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.QueryBodySyntax)body.Green).CreateRed();
    }


    /// <summary>Creates a new QueryContinuationSyntax instance.</summary>
    public static QueryContinuationSyntax QueryContinuation(SyntaxToken identifier, QueryBodySyntax body)
    {
      return SyntaxFactory.QueryContinuation(SyntaxFactory.Token(SyntaxKind.IntoKeyword), identifier, body);
    }

    /// <summary>Creates a new QueryContinuationSyntax instance.</summary>
    public static QueryContinuationSyntax QueryContinuation(string identifier, QueryBodySyntax body)
    {
      return SyntaxFactory.QueryContinuation(SyntaxFactory.Token(SyntaxKind.IntoKeyword), SyntaxFactory.Identifier(identifier), body);
    }

    /// <summary>Creates a new OmittedArraySizeExpressionSyntax instance.</summary>
    public static OmittedArraySizeExpressionSyntax OmittedArraySizeExpression(SyntaxToken omittedArraySizeExpressionToken)
    {
      switch (omittedArraySizeExpressionToken.Kind())
      {
        case SyntaxKind.OmittedArraySizeExpressionToken:
          break;
        default:
          throw new ArgumentException(nameof(omittedArraySizeExpressionToken));
      }
      return (OmittedArraySizeExpressionSyntax)Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SyntaxFactory.OmittedArraySizeExpression((Syntax.InternalSyntax.SyntaxToken)omittedArraySizeExpressionToken.Node).CreateRed();
    }


    /// <summary>Creates a new OmittedArraySizeExpressionSyntax instance.</summary>
    public static OmittedArraySizeExpressionSyntax OmittedArraySizeExpression()
    {
      return SyntaxFactory.OmittedArraySizeExpression(SyntaxFactory.Token(SyntaxKind.OmittedArraySizeExpressionToken));
    }

    /// <summary>Creates a new InterpolatedStringExpressionSyntax instance.</summary>
    public static InterpolatedStringExpressionSyntax InterpolatedStringExpression(SyntaxToken stringStartToken, SyntaxList<InterpolatedStringContentSyntax> contents, SyntaxToken stringEndToken)
    {
      switch (stringStartToken.Kind())
      {
        case SyntaxKind.InterpolatedStringStartToken:
        case SyntaxKind.InterpolatedVerbatimStringStartToken:
          break;
        default:
          throw new ArgumentException(nameof(stringStartToken));
      }
      switch (stringEndToken.Kind())
      {
        case SyntaxKind.InterpolatedStringEndToken:
          break;
        default:
          throw new ArgumentException(nameof(stringEndToken));
      }
      return (InterpolatedStringExpressionSyntax)Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SyntaxFactory.InterpolatedStringExpression((Syntax.InternalSyntax.SyntaxToken)stringStartToken.Node, contents.Node.ToGreenList<Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.InterpolatedStringContentSyntax>(), (Syntax.InternalSyntax.SyntaxToken)stringEndToken.Node).CreateRed();
    }


    /// <summary>Creates a new InterpolatedStringExpressionSyntax instance.</summary>
    public static InterpolatedStringExpressionSyntax InterpolatedStringExpression(SyntaxToken stringStartToken, SyntaxList<InterpolatedStringContentSyntax> contents)
    {
      return SyntaxFactory.InterpolatedStringExpression(stringStartToken, contents, SyntaxFactory.Token(SyntaxKind.InterpolatedStringEndToken));
    }

    /// <summary>Creates a new InterpolatedStringExpressionSyntax instance.</summary>
    public static InterpolatedStringExpressionSyntax InterpolatedStringExpression(SyntaxToken stringStartToken)
    {
      return SyntaxFactory.InterpolatedStringExpression(stringStartToken, default(SyntaxList<InterpolatedStringContentSyntax>), SyntaxFactory.Token(SyntaxKind.InterpolatedStringEndToken));
    }

    /// <summary>Creates a new IsPatternExpressionSyntax instance.</summary>
    public static IsPatternExpressionSyntax IsPatternExpression(ExpressionSyntax expression, SyntaxToken isKeyword, PatternSyntax pattern)
    {
      if (expression == null)
        throw new ArgumentNullException(nameof(expression));
      switch (isKeyword.Kind())
      {
        case SyntaxKind.IsKeyword:
          break;
        default:
          throw new ArgumentException(nameof(isKeyword));
      }
      if (pattern == null)
        throw new ArgumentNullException(nameof(pattern));
      return (IsPatternExpressionSyntax)Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SyntaxFactory.IsPatternExpression(expression == null ? null : (Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.ExpressionSyntax)expression.Green, (Syntax.InternalSyntax.SyntaxToken)isKeyword.Node, pattern == null ? null : (Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.PatternSyntax)pattern.Green).CreateRed();
    }


    /// <summary>Creates a new IsPatternExpressionSyntax instance.</summary>
    public static IsPatternExpressionSyntax IsPatternExpression(ExpressionSyntax expression, PatternSyntax pattern)
    {
      return SyntaxFactory.IsPatternExpression(expression, SyntaxFactory.Token(SyntaxKind.IsKeyword), pattern);
    }

    /// <summary>Creates a new ThrowExpressionSyntax instance.</summary>
    public static ThrowExpressionSyntax ThrowExpression(SyntaxToken throwKeyword, ExpressionSyntax expression)
    {
      switch (throwKeyword.Kind())
      {
        case SyntaxKind.ThrowKeyword:
          break;
        default:
          throw new ArgumentException(nameof(throwKeyword));
      }
      if (expression == null)
        throw new ArgumentNullException(nameof(expression));
      return (ThrowExpressionSyntax)Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SyntaxFactory.ThrowExpression((Syntax.InternalSyntax.SyntaxToken)throwKeyword.Node, expression == null ? null : (Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.ExpressionSyntax)expression.Green).CreateRed();
    }


    /// <summary>Creates a new ThrowExpressionSyntax instance.</summary>
    public static ThrowExpressionSyntax ThrowExpression(ExpressionSyntax expression)
    {
      return SyntaxFactory.ThrowExpression(SyntaxFactory.Token(SyntaxKind.ThrowKeyword), expression);
    }

    /// <summary>Creates a new WhenClauseSyntax instance.</summary>
    public static WhenClauseSyntax WhenClause(SyntaxToken whenKeyword, ExpressionSyntax condition)
    {
      switch (whenKeyword.Kind())
      {
        case SyntaxKind.WhenKeyword:
          break;
        default:
          throw new ArgumentException(nameof(whenKeyword));
      }
      if (condition == null)
        throw new ArgumentNullException(nameof(condition));
      return (WhenClauseSyntax)Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SyntaxFactory.WhenClause((Syntax.InternalSyntax.SyntaxToken)whenKeyword.Node, condition == null ? null : (Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.ExpressionSyntax)condition.Green).CreateRed();
    }


    /// <summary>Creates a new WhenClauseSyntax instance.</summary>
    public static WhenClauseSyntax WhenClause(ExpressionSyntax condition)
    {
      return SyntaxFactory.WhenClause(SyntaxFactory.Token(SyntaxKind.WhenKeyword), condition);
    }

    /// <summary>Creates a new DiscardPatternSyntax instance.</summary>
    public static DiscardPatternSyntax DiscardPattern(SyntaxToken underscoreToken)
    {
      switch (underscoreToken.Kind())
      {
        case SyntaxKind.UnderscoreToken:
          break;
        default:
          throw new ArgumentException(nameof(underscoreToken));
      }
      return (DiscardPatternSyntax)Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SyntaxFactory.DiscardPattern((Syntax.InternalSyntax.SyntaxToken)underscoreToken.Node).CreateRed();
    }


    /// <summary>Creates a new DiscardPatternSyntax instance.</summary>
    public static DiscardPatternSyntax DiscardPattern()
    {
      return SyntaxFactory.DiscardPattern(SyntaxFactory.Token(SyntaxKind.UnderscoreToken));
    }

    /// <summary>Creates a new DeclarationPatternSyntax instance.</summary>
    public static DeclarationPatternSyntax DeclarationPattern(TypeSyntax type, VariableDesignationSyntax designation)
    {
      if (type == null)
        throw new ArgumentNullException(nameof(type));
      if (designation == null)
        throw new ArgumentNullException(nameof(designation));
      return (DeclarationPatternSyntax)Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SyntaxFactory.DeclarationPattern(type == null ? null : (Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.TypeSyntax)type.Green, designation == null ? null : (Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.VariableDesignationSyntax)designation.Green).CreateRed();
    }


    /// <summary>Creates a new VarPatternSyntax instance.</summary>
    public static VarPatternSyntax VarPattern(SyntaxToken varKeyword, VariableDesignationSyntax designation)
    {
      switch (varKeyword.Kind())
      {
        case SyntaxKind.VarKeyword:
          break;
        default:
          throw new ArgumentException(nameof(varKeyword));
      }
      if (designation == null)
        throw new ArgumentNullException(nameof(designation));
      return (VarPatternSyntax)Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SyntaxFactory.VarPattern((Syntax.InternalSyntax.SyntaxToken)varKeyword.Node, designation == null ? null : (Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.VariableDesignationSyntax)designation.Green).CreateRed();
    }


    /// <summary>Creates a new VarPatternSyntax instance.</summary>
    public static VarPatternSyntax VarPattern(VariableDesignationSyntax designation)
    {
      return SyntaxFactory.VarPattern(SyntaxFactory.Token(SyntaxKind.VarKeyword), designation);
    }

    /// <summary>Creates a new RecursivePatternSyntax instance.</summary>
    public static RecursivePatternSyntax RecursivePattern(TypeSyntax type, PositionalPatternClauseSyntax positionalPatternClause, PropertyPatternClauseSyntax propertyPatternClause, VariableDesignationSyntax designation)
    {
      return (RecursivePatternSyntax)Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SyntaxFactory.RecursivePattern(type == null ? null : (Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.TypeSyntax)type.Green, positionalPatternClause == null ? null : (Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.PositionalPatternClauseSyntax)positionalPatternClause.Green, propertyPatternClause == null ? null : (Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.PropertyPatternClauseSyntax)propertyPatternClause.Green, designation == null ? null : (Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.VariableDesignationSyntax)designation.Green).CreateRed();
    }


    /// <summary>Creates a new RecursivePatternSyntax instance.</summary>
    public static RecursivePatternSyntax RecursivePattern()
    {
      return SyntaxFactory.RecursivePattern(default(TypeSyntax), default(PositionalPatternClauseSyntax), default(PropertyPatternClauseSyntax), default(VariableDesignationSyntax));
    }

    /// <summary>Creates a new PositionalPatternClauseSyntax instance.</summary>
    public static PositionalPatternClauseSyntax PositionalPatternClause(SyntaxToken openParenToken, SeparatedSyntaxList<SubpatternSyntax> subpatterns, SyntaxToken closeParenToken)
    {
      switch (openParenToken.Kind())
      {
        case SyntaxKind.OpenParenToken:
          break;
        default:
          throw new ArgumentException(nameof(openParenToken));
      }
      switch (closeParenToken.Kind())
      {
        case SyntaxKind.CloseParenToken:
          break;
        default:
          throw new ArgumentException(nameof(closeParenToken));
      }
      return (PositionalPatternClauseSyntax)Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SyntaxFactory.PositionalPatternClause((Syntax.InternalSyntax.SyntaxToken)openParenToken.Node, subpatterns.Node.ToGreenSeparatedList<Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SubpatternSyntax>(), (Syntax.InternalSyntax.SyntaxToken)closeParenToken.Node).CreateRed();
    }


    /// <summary>Creates a new PositionalPatternClauseSyntax instance.</summary>
    public static PositionalPatternClauseSyntax PositionalPatternClause(SeparatedSyntaxList<SubpatternSyntax> subpatterns = default(SeparatedSyntaxList<SubpatternSyntax>))
    {
      return SyntaxFactory.PositionalPatternClause(SyntaxFactory.Token(SyntaxKind.OpenParenToken), subpatterns, SyntaxFactory.Token(SyntaxKind.CloseParenToken));
    }

    /// <summary>Creates a new PropertyPatternClauseSyntax instance.</summary>
    public static PropertyPatternClauseSyntax PropertyPatternClause(SyntaxToken openBraceToken, SeparatedSyntaxList<SubpatternSyntax> subpatterns, SyntaxToken closeBraceToken)
    {
      switch (openBraceToken.Kind())
      {
        case SyntaxKind.OpenBraceToken:
          break;
        default:
          throw new ArgumentException(nameof(openBraceToken));
      }
      switch (closeBraceToken.Kind())
      {
        case SyntaxKind.CloseBraceToken:
          break;
        default:
          throw new ArgumentException(nameof(closeBraceToken));
      }
      return (PropertyPatternClauseSyntax)Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SyntaxFactory.PropertyPatternClause((Syntax.InternalSyntax.SyntaxToken)openBraceToken.Node, subpatterns.Node.ToGreenSeparatedList<Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SubpatternSyntax>(), (Syntax.InternalSyntax.SyntaxToken)closeBraceToken.Node).CreateRed();
    }


    /// <summary>Creates a new PropertyPatternClauseSyntax instance.</summary>
    public static PropertyPatternClauseSyntax PropertyPatternClause(SeparatedSyntaxList<SubpatternSyntax> subpatterns = default(SeparatedSyntaxList<SubpatternSyntax>))
    {
      return SyntaxFactory.PropertyPatternClause(SyntaxFactory.Token(SyntaxKind.OpenBraceToken), subpatterns, SyntaxFactory.Token(SyntaxKind.CloseBraceToken));
    }

    /// <summary>Creates a new SubpatternSyntax instance.</summary>
    public static SubpatternSyntax Subpattern(NameColonSyntax nameColon, PatternSyntax pattern)
    {
      if (pattern == null)
        throw new ArgumentNullException(nameof(pattern));
      return (SubpatternSyntax)Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SyntaxFactory.Subpattern(nameColon == null ? null : (Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.NameColonSyntax)nameColon.Green, pattern == null ? null : (Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.PatternSyntax)pattern.Green).CreateRed();
    }


    /// <summary>Creates a new SubpatternSyntax instance.</summary>
    public static SubpatternSyntax Subpattern(PatternSyntax pattern)
    {
      return SyntaxFactory.Subpattern(default(NameColonSyntax), pattern);
    }

    /// <summary>Creates a new ConstantPatternSyntax instance.</summary>
    public static ConstantPatternSyntax ConstantPattern(ExpressionSyntax expression)
    {
      if (expression == null)
        throw new ArgumentNullException(nameof(expression));
      return (ConstantPatternSyntax)Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SyntaxFactory.ConstantPattern(expression == null ? null : (Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.ExpressionSyntax)expression.Green).CreateRed();
    }


    /// <summary>Creates a new InterpolatedStringTextSyntax instance.</summary>
    public static InterpolatedStringTextSyntax InterpolatedStringText(SyntaxToken textToken)
    {
      switch (textToken.Kind())
      {
        case SyntaxKind.InterpolatedStringTextToken:
          break;
        default:
          throw new ArgumentException(nameof(textToken));
      }
      return (InterpolatedStringTextSyntax)Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SyntaxFactory.InterpolatedStringText((Syntax.InternalSyntax.SyntaxToken)textToken.Node).CreateRed();
    }


    /// <summary>Creates a new InterpolatedStringTextSyntax instance.</summary>
    public static InterpolatedStringTextSyntax InterpolatedStringText()
    {
      return SyntaxFactory.InterpolatedStringText(SyntaxFactory.Token(SyntaxKind.InterpolatedStringTextToken));
    }

    /// <summary>Creates a new InterpolationSyntax instance.</summary>
    public static InterpolationSyntax Interpolation(SyntaxToken openBraceToken, ExpressionSyntax expression, InterpolationAlignmentClauseSyntax alignmentClause, InterpolationFormatClauseSyntax formatClause, SyntaxToken closeBraceToken)
    {
      switch (openBraceToken.Kind())
      {
        case SyntaxKind.OpenBraceToken:
          break;
        default:
          throw new ArgumentException(nameof(openBraceToken));
      }
      if (expression == null)
        throw new ArgumentNullException(nameof(expression));
      switch (closeBraceToken.Kind())
      {
        case SyntaxKind.CloseBraceToken:
          break;
        default:
          throw new ArgumentException(nameof(closeBraceToken));
      }
      return (InterpolationSyntax)Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SyntaxFactory.Interpolation((Syntax.InternalSyntax.SyntaxToken)openBraceToken.Node, expression == null ? null : (Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.ExpressionSyntax)expression.Green, alignmentClause == null ? null : (Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.InterpolationAlignmentClauseSyntax)alignmentClause.Green, formatClause == null ? null : (Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.InterpolationFormatClauseSyntax)formatClause.Green, (Syntax.InternalSyntax.SyntaxToken)closeBraceToken.Node).CreateRed();
    }


    /// <summary>Creates a new InterpolationSyntax instance.</summary>
    public static InterpolationSyntax Interpolation(ExpressionSyntax expression, InterpolationAlignmentClauseSyntax alignmentClause, InterpolationFormatClauseSyntax formatClause)
    {
      return SyntaxFactory.Interpolation(SyntaxFactory.Token(SyntaxKind.OpenBraceToken), expression, alignmentClause, formatClause, SyntaxFactory.Token(SyntaxKind.CloseBraceToken));
    }

    /// <summary>Creates a new InterpolationSyntax instance.</summary>
    public static InterpolationSyntax Interpolation(ExpressionSyntax expression)
    {
      return SyntaxFactory.Interpolation(SyntaxFactory.Token(SyntaxKind.OpenBraceToken), expression, default(InterpolationAlignmentClauseSyntax), default(InterpolationFormatClauseSyntax), SyntaxFactory.Token(SyntaxKind.CloseBraceToken));
    }

    /// <summary>Creates a new InterpolationAlignmentClauseSyntax instance.</summary>
    public static InterpolationAlignmentClauseSyntax InterpolationAlignmentClause(SyntaxToken commaToken, ExpressionSyntax value)
    {
      if (value == null)
        throw new ArgumentNullException(nameof(value));
      return (InterpolationAlignmentClauseSyntax)Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SyntaxFactory.InterpolationAlignmentClause((Syntax.InternalSyntax.SyntaxToken)commaToken.Node, value == null ? null : (Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.ExpressionSyntax)value.Green).CreateRed();
    }


    /// <summary>Creates a new InterpolationFormatClauseSyntax instance.</summary>
    public static InterpolationFormatClauseSyntax InterpolationFormatClause(SyntaxToken colonToken, SyntaxToken formatStringToken)
    {
      switch (formatStringToken.Kind())
      {
        case SyntaxKind.InterpolatedStringTextToken:
          break;
        default:
          throw new ArgumentException(nameof(formatStringToken));
      }
      return (InterpolationFormatClauseSyntax)Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SyntaxFactory.InterpolationFormatClause((Syntax.InternalSyntax.SyntaxToken)colonToken.Node, (Syntax.InternalSyntax.SyntaxToken)formatStringToken.Node).CreateRed();
    }


    /// <summary>Creates a new InterpolationFormatClauseSyntax instance.</summary>
    public static InterpolationFormatClauseSyntax InterpolationFormatClause(SyntaxToken colonToken)
    {
      return SyntaxFactory.InterpolationFormatClause(colonToken, SyntaxFactory.Token(SyntaxKind.InterpolatedStringTextToken));
    }

    /// <summary>Creates a new GlobalStatementSyntax instance.</summary>
    public static GlobalStatementSyntax GlobalStatement(SyntaxList<AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, StatementSyntax statement)
    {
      if (statement == null)
        throw new ArgumentNullException(nameof(statement));
      return (GlobalStatementSyntax)Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SyntaxFactory.GlobalStatement(attributeLists.Node.ToGreenList<Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.AttributeListSyntax>(), modifiers.Node.ToGreenList<Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SyntaxToken>(), statement == null ? null : (Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.StatementSyntax)statement.Green).CreateRed();
    }


    /// <summary>Creates a new GlobalStatementSyntax instance.</summary>
    public static GlobalStatementSyntax GlobalStatement(StatementSyntax statement)
    {
      return SyntaxFactory.GlobalStatement(default(SyntaxList<AttributeListSyntax>), default(SyntaxTokenList), statement);
    }

    /// <summary>Creates a new BlockSyntax instance.</summary>
    public static BlockSyntax Block(SyntaxToken openBraceToken, SyntaxList<StatementSyntax> statements, SyntaxToken closeBraceToken)
    {
      switch (openBraceToken.Kind())
      {
        case SyntaxKind.OpenBraceToken:
          break;
        default:
          throw new ArgumentException(nameof(openBraceToken));
      }
      switch (closeBraceToken.Kind())
      {
        case SyntaxKind.CloseBraceToken:
          break;
        default:
          throw new ArgumentException(nameof(closeBraceToken));
      }
      return (BlockSyntax)Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SyntaxFactory.Block((Syntax.InternalSyntax.SyntaxToken)openBraceToken.Node, statements.Node.ToGreenList<Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.StatementSyntax>(), (Syntax.InternalSyntax.SyntaxToken)closeBraceToken.Node).CreateRed();
    }


    /// <summary>Creates a new BlockSyntax instance.</summary>
    public static BlockSyntax Block(SyntaxList<StatementSyntax> statements = default(SyntaxList<StatementSyntax>))
    {
      return SyntaxFactory.Block(SyntaxFactory.Token(SyntaxKind.OpenBraceToken), statements, SyntaxFactory.Token(SyntaxKind.CloseBraceToken));
    }

    /// <summary>Creates a new LocalFunctionStatementSyntax instance.</summary>
    public static LocalFunctionStatementSyntax LocalFunctionStatement(SyntaxTokenList modifiers, TypeSyntax returnType, SyntaxToken identifier, TypeParameterListSyntax typeParameterList, ParameterListSyntax parameterList, SyntaxList<TypeParameterConstraintClauseSyntax> constraintClauses, BlockSyntax body, ArrowExpressionClauseSyntax expressionBody, SyntaxToken semicolonToken)
    {
      if (returnType == null)
        throw new ArgumentNullException(nameof(returnType));
      switch (identifier.Kind())
      {
        case SyntaxKind.IdentifierToken:
          break;
        default:
          throw new ArgumentException(nameof(identifier));
      }
      if (parameterList == null)
        throw new ArgumentNullException(nameof(parameterList));
      switch (semicolonToken.Kind())
      {
        case SyntaxKind.SemicolonToken:
        case SyntaxKind.None:
          break;
        default:
          throw new ArgumentException(nameof(semicolonToken));
      }
      return (LocalFunctionStatementSyntax)Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SyntaxFactory.LocalFunctionStatement(modifiers.Node.ToGreenList<Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SyntaxToken>(), returnType == null ? null : (Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.TypeSyntax)returnType.Green, (Syntax.InternalSyntax.SyntaxToken)identifier.Node, typeParameterList == null ? null : (Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.TypeParameterListSyntax)typeParameterList.Green, parameterList == null ? null : (Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.ParameterListSyntax)parameterList.Green, constraintClauses.Node.ToGreenList<Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.TypeParameterConstraintClauseSyntax>(), body == null ? null : (Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.BlockSyntax)body.Green, expressionBody == null ? null : (Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.ArrowExpressionClauseSyntax)expressionBody.Green, (Syntax.InternalSyntax.SyntaxToken)semicolonToken.Node).CreateRed();
    }


    /// <summary>Creates a new LocalFunctionStatementSyntax instance.</summary>
    public static LocalFunctionStatementSyntax LocalFunctionStatement(SyntaxTokenList modifiers, TypeSyntax returnType, SyntaxToken identifier, TypeParameterListSyntax typeParameterList, ParameterListSyntax parameterList, SyntaxList<TypeParameterConstraintClauseSyntax> constraintClauses, BlockSyntax body, ArrowExpressionClauseSyntax expressionBody)
    {
      return SyntaxFactory.LocalFunctionStatement(modifiers, returnType, identifier, typeParameterList, parameterList, constraintClauses, body, expressionBody, default(SyntaxToken));
    }

    /// <summary>Creates a new LocalFunctionStatementSyntax instance.</summary>
    public static LocalFunctionStatementSyntax LocalFunctionStatement(TypeSyntax returnType, SyntaxToken identifier)
    {
      return SyntaxFactory.LocalFunctionStatement(default(SyntaxTokenList), returnType, identifier, default(TypeParameterListSyntax), SyntaxFactory.ParameterList(), default(SyntaxList<TypeParameterConstraintClauseSyntax>), default(BlockSyntax), default(ArrowExpressionClauseSyntax), default(SyntaxToken));
    }

    /// <summary>Creates a new LocalFunctionStatementSyntax instance.</summary>
    public static LocalFunctionStatementSyntax LocalFunctionStatement(TypeSyntax returnType, string identifier)
    {
      return SyntaxFactory.LocalFunctionStatement(default(SyntaxTokenList), returnType, SyntaxFactory.Identifier(identifier), default(TypeParameterListSyntax), SyntaxFactory.ParameterList(), default(SyntaxList<TypeParameterConstraintClauseSyntax>), default(BlockSyntax), default(ArrowExpressionClauseSyntax), default(SyntaxToken));
    }

    /// <summary>Creates a new LocalDeclarationStatementSyntax instance.</summary>
    public static LocalDeclarationStatementSyntax LocalDeclarationStatement(SyntaxToken awaitKeyword, SyntaxToken usingKeyword, SyntaxTokenList modifiers, VariableDeclarationSyntax declaration, SyntaxToken semicolonToken)
    {
      switch (awaitKeyword.Kind())
      {
        case SyntaxKind.AwaitKeyword:
        case SyntaxKind.None:
          break;
        default:
          throw new ArgumentException(nameof(awaitKeyword));
      }
      switch (usingKeyword.Kind())
      {
        case SyntaxKind.UsingKeyword:
        case SyntaxKind.None:
          break;
        default:
          throw new ArgumentException(nameof(usingKeyword));
      }
      if (declaration == null)
        throw new ArgumentNullException(nameof(declaration));
      switch (semicolonToken.Kind())
      {
        case SyntaxKind.SemicolonToken:
          break;
        default:
          throw new ArgumentException(nameof(semicolonToken));
      }
      return (LocalDeclarationStatementSyntax)Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SyntaxFactory.LocalDeclarationStatement((Syntax.InternalSyntax.SyntaxToken)awaitKeyword.Node, (Syntax.InternalSyntax.SyntaxToken)usingKeyword.Node, modifiers.Node.ToGreenList<Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SyntaxToken>(), declaration == null ? null : (Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.VariableDeclarationSyntax)declaration.Green, (Syntax.InternalSyntax.SyntaxToken)semicolonToken.Node).CreateRed();
    }


    /// <summary>Creates a new LocalDeclarationStatementSyntax instance.</summary>
    public static LocalDeclarationStatementSyntax LocalDeclarationStatement(SyntaxTokenList modifiers, VariableDeclarationSyntax declaration)
    {
      return SyntaxFactory.LocalDeclarationStatement(default(SyntaxToken), default(SyntaxToken), modifiers, declaration, SyntaxFactory.Token(SyntaxKind.SemicolonToken));
    }

    /// <summary>Creates a new LocalDeclarationStatementSyntax instance.</summary>
    public static LocalDeclarationStatementSyntax LocalDeclarationStatement(VariableDeclarationSyntax declaration)
    {
      return SyntaxFactory.LocalDeclarationStatement(default(SyntaxToken), default(SyntaxToken), default(SyntaxTokenList), declaration, SyntaxFactory.Token(SyntaxKind.SemicolonToken));
    }

    /// <summary>Creates a new VariableDeclarationSyntax instance.</summary>
    public static VariableDeclarationSyntax VariableDeclaration(TypeSyntax type, SeparatedSyntaxList<VariableDeclaratorSyntax> variables)
    {
      if (type == null)
        throw new ArgumentNullException(nameof(type));
      return (VariableDeclarationSyntax)Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SyntaxFactory.VariableDeclaration(type == null ? null : (Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.TypeSyntax)type.Green, variables.Node.ToGreenSeparatedList<Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.VariableDeclaratorSyntax>()).CreateRed();
    }


    /// <summary>Creates a new VariableDeclarationSyntax instance.</summary>
    public static VariableDeclarationSyntax VariableDeclaration(TypeSyntax type)
    {
      return SyntaxFactory.VariableDeclaration(type, default(SeparatedSyntaxList<VariableDeclaratorSyntax>));
    }

    /// <summary>Creates a new VariableDeclaratorSyntax instance.</summary>
    public static VariableDeclaratorSyntax VariableDeclarator(SyntaxToken identifier, BracketedArgumentListSyntax argumentList, EqualsValueClauseSyntax initializer)
    {
      switch (identifier.Kind())
      {
        case SyntaxKind.IdentifierToken:
          break;
        default:
          throw new ArgumentException(nameof(identifier));
      }
      return (VariableDeclaratorSyntax)Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SyntaxFactory.VariableDeclarator((Syntax.InternalSyntax.SyntaxToken)identifier.Node, argumentList == null ? null : (Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.BracketedArgumentListSyntax)argumentList.Green, initializer == null ? null : (Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.EqualsValueClauseSyntax)initializer.Green).CreateRed();
    }


    /// <summary>Creates a new VariableDeclaratorSyntax instance.</summary>
    public static VariableDeclaratorSyntax VariableDeclarator(SyntaxToken identifier)
    {
      return SyntaxFactory.VariableDeclarator(identifier, default(BracketedArgumentListSyntax), default(EqualsValueClauseSyntax));
    }

    /// <summary>Creates a new VariableDeclaratorSyntax instance.</summary>
    public static VariableDeclaratorSyntax VariableDeclarator(string identifier)
    {
      return SyntaxFactory.VariableDeclarator(SyntaxFactory.Identifier(identifier), default(BracketedArgumentListSyntax), default(EqualsValueClauseSyntax));
    }

    /// <summary>Creates a new EqualsValueClauseSyntax instance.</summary>
    public static EqualsValueClauseSyntax EqualsValueClause(SyntaxToken equalsToken, ExpressionSyntax value)
    {
      switch (equalsToken.Kind())
      {
        case SyntaxKind.EqualsToken:
          break;
        default:
          throw new ArgumentException(nameof(equalsToken));
      }
      if (value == null)
        throw new ArgumentNullException(nameof(value));
      return (EqualsValueClauseSyntax)Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SyntaxFactory.EqualsValueClause((Syntax.InternalSyntax.SyntaxToken)equalsToken.Node, value == null ? null : (Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.ExpressionSyntax)value.Green).CreateRed();
    }


    /// <summary>Creates a new EqualsValueClauseSyntax instance.</summary>
    public static EqualsValueClauseSyntax EqualsValueClause(ExpressionSyntax value)
    {
      return SyntaxFactory.EqualsValueClause(SyntaxFactory.Token(SyntaxKind.EqualsToken), value);
    }

    /// <summary>Creates a new SingleVariableDesignationSyntax instance.</summary>
    public static SingleVariableDesignationSyntax SingleVariableDesignation(SyntaxToken identifier)
    {
      switch (identifier.Kind())
      {
        case SyntaxKind.IdentifierToken:
          break;
        default:
          throw new ArgumentException(nameof(identifier));
      }
      return (SingleVariableDesignationSyntax)Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SyntaxFactory.SingleVariableDesignation((Syntax.InternalSyntax.SyntaxToken)identifier.Node).CreateRed();
    }


    /// <summary>Creates a new DiscardDesignationSyntax instance.</summary>
    public static DiscardDesignationSyntax DiscardDesignation(SyntaxToken underscoreToken)
    {
      switch (underscoreToken.Kind())
      {
        case SyntaxKind.UnderscoreToken:
          break;
        default:
          throw new ArgumentException(nameof(underscoreToken));
      }
      return (DiscardDesignationSyntax)Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SyntaxFactory.DiscardDesignation((Syntax.InternalSyntax.SyntaxToken)underscoreToken.Node).CreateRed();
    }


    /// <summary>Creates a new DiscardDesignationSyntax instance.</summary>
    public static DiscardDesignationSyntax DiscardDesignation()
    {
      return SyntaxFactory.DiscardDesignation(SyntaxFactory.Token(SyntaxKind.UnderscoreToken));
    }

    /// <summary>Creates a new ParenthesizedVariableDesignationSyntax instance.</summary>
    public static ParenthesizedVariableDesignationSyntax ParenthesizedVariableDesignation(SyntaxToken openParenToken, SeparatedSyntaxList<VariableDesignationSyntax> variables, SyntaxToken closeParenToken)
    {
      switch (openParenToken.Kind())
      {
        case SyntaxKind.OpenParenToken:
          break;
        default:
          throw new ArgumentException(nameof(openParenToken));
      }
      switch (closeParenToken.Kind())
      {
        case SyntaxKind.CloseParenToken:
          break;
        default:
          throw new ArgumentException(nameof(closeParenToken));
      }
      return (ParenthesizedVariableDesignationSyntax)Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SyntaxFactory.ParenthesizedVariableDesignation((Syntax.InternalSyntax.SyntaxToken)openParenToken.Node, variables.Node.ToGreenSeparatedList<Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.VariableDesignationSyntax>(), (Syntax.InternalSyntax.SyntaxToken)closeParenToken.Node).CreateRed();
    }


    /// <summary>Creates a new ParenthesizedVariableDesignationSyntax instance.</summary>
    public static ParenthesizedVariableDesignationSyntax ParenthesizedVariableDesignation(SeparatedSyntaxList<VariableDesignationSyntax> variables = default(SeparatedSyntaxList<VariableDesignationSyntax>))
    {
      return SyntaxFactory.ParenthesizedVariableDesignation(SyntaxFactory.Token(SyntaxKind.OpenParenToken), variables, SyntaxFactory.Token(SyntaxKind.CloseParenToken));
    }

    /// <summary>Creates a new ExpressionStatementSyntax instance.</summary>
    public static ExpressionStatementSyntax ExpressionStatement(ExpressionSyntax expression, SyntaxToken semicolonToken)
    {
      if (expression == null)
        throw new ArgumentNullException(nameof(expression));
      switch (semicolonToken.Kind())
      {
        case SyntaxKind.SemicolonToken:
          break;
        default:
          throw new ArgumentException(nameof(semicolonToken));
      }
      return (ExpressionStatementSyntax)Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SyntaxFactory.ExpressionStatement(expression == null ? null : (Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.ExpressionSyntax)expression.Green, (Syntax.InternalSyntax.SyntaxToken)semicolonToken.Node).CreateRed();
    }


    /// <summary>Creates a new ExpressionStatementSyntax instance.</summary>
    public static ExpressionStatementSyntax ExpressionStatement(ExpressionSyntax expression)
    {
      return SyntaxFactory.ExpressionStatement(expression, SyntaxFactory.Token(SyntaxKind.SemicolonToken));
    }

    /// <summary>Creates a new EmptyStatementSyntax instance.</summary>
    public static EmptyStatementSyntax EmptyStatement(SyntaxToken semicolonToken)
    {
      switch (semicolonToken.Kind())
      {
        case SyntaxKind.SemicolonToken:
          break;
        default:
          throw new ArgumentException(nameof(semicolonToken));
      }
      return (EmptyStatementSyntax)Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SyntaxFactory.EmptyStatement((Syntax.InternalSyntax.SyntaxToken)semicolonToken.Node).CreateRed();
    }


    /// <summary>Creates a new EmptyStatementSyntax instance.</summary>
    public static EmptyStatementSyntax EmptyStatement()
    {
      return SyntaxFactory.EmptyStatement(SyntaxFactory.Token(SyntaxKind.SemicolonToken));
    }

    /// <summary>Creates a new LabeledStatementSyntax instance.</summary>
    public static LabeledStatementSyntax LabeledStatement(SyntaxToken identifier, SyntaxToken colonToken, StatementSyntax statement)
    {
      switch (identifier.Kind())
      {
        case SyntaxKind.IdentifierToken:
          break;
        default:
          throw new ArgumentException(nameof(identifier));
      }
      switch (colonToken.Kind())
      {
        case SyntaxKind.ColonToken:
          break;
        default:
          throw new ArgumentException(nameof(colonToken));
      }
      if (statement == null)
        throw new ArgumentNullException(nameof(statement));
      return (LabeledStatementSyntax)Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SyntaxFactory.LabeledStatement((Syntax.InternalSyntax.SyntaxToken)identifier.Node, (Syntax.InternalSyntax.SyntaxToken)colonToken.Node, statement == null ? null : (Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.StatementSyntax)statement.Green).CreateRed();
    }


    /// <summary>Creates a new LabeledStatementSyntax instance.</summary>
    public static LabeledStatementSyntax LabeledStatement(SyntaxToken identifier, StatementSyntax statement)
    {
      return SyntaxFactory.LabeledStatement(identifier, SyntaxFactory.Token(SyntaxKind.ColonToken), statement);
    }

    /// <summary>Creates a new LabeledStatementSyntax instance.</summary>
    public static LabeledStatementSyntax LabeledStatement(string identifier, StatementSyntax statement)
    {
      return SyntaxFactory.LabeledStatement(SyntaxFactory.Identifier(identifier), SyntaxFactory.Token(SyntaxKind.ColonToken), statement);
    }

    /// <summary>Creates a new GotoStatementSyntax instance.</summary>
    public static GotoStatementSyntax GotoStatement(SyntaxKind kind, SyntaxToken gotoKeyword, SyntaxToken caseOrDefaultKeyword, ExpressionSyntax expression, SyntaxToken semicolonToken)
    {
      switch (kind)
      {
        case SyntaxKind.GotoStatement:
        case SyntaxKind.GotoCaseStatement:
        case SyntaxKind.GotoDefaultStatement:
          break;
        default:
          throw new ArgumentException(nameof(kind));
      }
      switch (gotoKeyword.Kind())
      {
        case SyntaxKind.GotoKeyword:
          break;
        default:
          throw new ArgumentException(nameof(gotoKeyword));
      }
      switch (caseOrDefaultKeyword.Kind())
      {
        case SyntaxKind.CaseKeyword:
        case SyntaxKind.DefaultKeyword:
        case SyntaxKind.None:
          break;
        default:
          throw new ArgumentException(nameof(caseOrDefaultKeyword));
      }
      switch (semicolonToken.Kind())
      {
        case SyntaxKind.SemicolonToken:
          break;
        default:
          throw new ArgumentException(nameof(semicolonToken));
      }
      return (GotoStatementSyntax)Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SyntaxFactory.GotoStatement(kind, (Syntax.InternalSyntax.SyntaxToken)gotoKeyword.Node, (Syntax.InternalSyntax.SyntaxToken)caseOrDefaultKeyword.Node, expression == null ? null : (Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.ExpressionSyntax)expression.Green, (Syntax.InternalSyntax.SyntaxToken)semicolonToken.Node).CreateRed();
    }


    /// <summary>Creates a new GotoStatementSyntax instance.</summary>
    public static GotoStatementSyntax GotoStatement(SyntaxKind kind, SyntaxToken caseOrDefaultKeyword, ExpressionSyntax expression)
    {
      return SyntaxFactory.GotoStatement(kind, SyntaxFactory.Token(SyntaxKind.GotoKeyword), caseOrDefaultKeyword, expression, SyntaxFactory.Token(SyntaxKind.SemicolonToken));
    }

    /// <summary>Creates a new GotoStatementSyntax instance.</summary>
    public static GotoStatementSyntax GotoStatement(SyntaxKind kind, ExpressionSyntax expression = default(ExpressionSyntax))
    {
      return SyntaxFactory.GotoStatement(kind, SyntaxFactory.Token(SyntaxKind.GotoKeyword), default(SyntaxToken), expression, SyntaxFactory.Token(SyntaxKind.SemicolonToken));
    }

    /// <summary>Creates a new BreakStatementSyntax instance.</summary>
    public static BreakStatementSyntax BreakStatement(SyntaxToken breakKeyword, SyntaxToken semicolonToken)
    {
      switch (breakKeyword.Kind())
      {
        case SyntaxKind.BreakKeyword:
          break;
        default:
          throw new ArgumentException(nameof(breakKeyword));
      }
      switch (semicolonToken.Kind())
      {
        case SyntaxKind.SemicolonToken:
          break;
        default:
          throw new ArgumentException(nameof(semicolonToken));
      }
      return (BreakStatementSyntax)Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SyntaxFactory.BreakStatement((Syntax.InternalSyntax.SyntaxToken)breakKeyword.Node, (Syntax.InternalSyntax.SyntaxToken)semicolonToken.Node).CreateRed();
    }


    /// <summary>Creates a new BreakStatementSyntax instance.</summary>
    public static BreakStatementSyntax BreakStatement()
    {
      return SyntaxFactory.BreakStatement(SyntaxFactory.Token(SyntaxKind.BreakKeyword), SyntaxFactory.Token(SyntaxKind.SemicolonToken));
    }

    /// <summary>Creates a new ContinueStatementSyntax instance.</summary>
    public static ContinueStatementSyntax ContinueStatement(SyntaxToken continueKeyword, SyntaxToken semicolonToken)
    {
      switch (continueKeyword.Kind())
      {
        case SyntaxKind.ContinueKeyword:
          break;
        default:
          throw new ArgumentException(nameof(continueKeyword));
      }
      switch (semicolonToken.Kind())
      {
        case SyntaxKind.SemicolonToken:
          break;
        default:
          throw new ArgumentException(nameof(semicolonToken));
      }
      return (ContinueStatementSyntax)Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SyntaxFactory.ContinueStatement((Syntax.InternalSyntax.SyntaxToken)continueKeyword.Node, (Syntax.InternalSyntax.SyntaxToken)semicolonToken.Node).CreateRed();
    }


    /// <summary>Creates a new ContinueStatementSyntax instance.</summary>
    public static ContinueStatementSyntax ContinueStatement()
    {
      return SyntaxFactory.ContinueStatement(SyntaxFactory.Token(SyntaxKind.ContinueKeyword), SyntaxFactory.Token(SyntaxKind.SemicolonToken));
    }

    /// <summary>Creates a new ReturnStatementSyntax instance.</summary>
    public static ReturnStatementSyntax ReturnStatement(SyntaxToken returnKeyword, ExpressionSyntax expression, SyntaxToken semicolonToken)
    {
      switch (returnKeyword.Kind())
      {
        case SyntaxKind.ReturnKeyword:
          break;
        default:
          throw new ArgumentException(nameof(returnKeyword));
      }
      switch (semicolonToken.Kind())
      {
        case SyntaxKind.SemicolonToken:
          break;
        default:
          throw new ArgumentException(nameof(semicolonToken));
      }
      return (ReturnStatementSyntax)Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SyntaxFactory.ReturnStatement((Syntax.InternalSyntax.SyntaxToken)returnKeyword.Node, expression == null ? null : (Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.ExpressionSyntax)expression.Green, (Syntax.InternalSyntax.SyntaxToken)semicolonToken.Node).CreateRed();
    }


    /// <summary>Creates a new ReturnStatementSyntax instance.</summary>
    public static ReturnStatementSyntax ReturnStatement(ExpressionSyntax expression = default(ExpressionSyntax))
    {
      return SyntaxFactory.ReturnStatement(SyntaxFactory.Token(SyntaxKind.ReturnKeyword), expression, SyntaxFactory.Token(SyntaxKind.SemicolonToken));
    }

    /// <summary>Creates a new ThrowStatementSyntax instance.</summary>
    public static ThrowStatementSyntax ThrowStatement(SyntaxToken throwKeyword, ExpressionSyntax expression, SyntaxToken semicolonToken)
    {
      switch (throwKeyword.Kind())
      {
        case SyntaxKind.ThrowKeyword:
          break;
        default:
          throw new ArgumentException(nameof(throwKeyword));
      }
      switch (semicolonToken.Kind())
      {
        case SyntaxKind.SemicolonToken:
          break;
        default:
          throw new ArgumentException(nameof(semicolonToken));
      }
      return (ThrowStatementSyntax)Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SyntaxFactory.ThrowStatement((Syntax.InternalSyntax.SyntaxToken)throwKeyword.Node, expression == null ? null : (Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.ExpressionSyntax)expression.Green, (Syntax.InternalSyntax.SyntaxToken)semicolonToken.Node).CreateRed();
    }


    /// <summary>Creates a new ThrowStatementSyntax instance.</summary>
    public static ThrowStatementSyntax ThrowStatement(ExpressionSyntax expression = default(ExpressionSyntax))
    {
      return SyntaxFactory.ThrowStatement(SyntaxFactory.Token(SyntaxKind.ThrowKeyword), expression, SyntaxFactory.Token(SyntaxKind.SemicolonToken));
    }

    /// <summary>Creates a new YieldStatementSyntax instance.</summary>
    public static YieldStatementSyntax YieldStatement(SyntaxKind kind, SyntaxToken yieldKeyword, SyntaxToken returnOrBreakKeyword, ExpressionSyntax expression, SyntaxToken semicolonToken)
    {
      switch (kind)
      {
        case SyntaxKind.YieldReturnStatement:
        case SyntaxKind.YieldBreakStatement:
          break;
        default:
          throw new ArgumentException(nameof(kind));
      }
      switch (yieldKeyword.Kind())
      {
        case SyntaxKind.YieldKeyword:
          break;
        default:
          throw new ArgumentException(nameof(yieldKeyword));
      }
      switch (returnOrBreakKeyword.Kind())
      {
        case SyntaxKind.ReturnKeyword:
        case SyntaxKind.BreakKeyword:
          break;
        default:
          throw new ArgumentException(nameof(returnOrBreakKeyword));
      }
      switch (semicolonToken.Kind())
      {
        case SyntaxKind.SemicolonToken:
          break;
        default:
          throw new ArgumentException(nameof(semicolonToken));
      }
      return (YieldStatementSyntax)Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SyntaxFactory.YieldStatement(kind, (Syntax.InternalSyntax.SyntaxToken)yieldKeyword.Node, (Syntax.InternalSyntax.SyntaxToken)returnOrBreakKeyword.Node, expression == null ? null : (Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.ExpressionSyntax)expression.Green, (Syntax.InternalSyntax.SyntaxToken)semicolonToken.Node).CreateRed();
    }


    /// <summary>Creates a new YieldStatementSyntax instance.</summary>
    public static YieldStatementSyntax YieldStatement(SyntaxKind kind, ExpressionSyntax expression = default(ExpressionSyntax))
    {
      return SyntaxFactory.YieldStatement(kind, SyntaxFactory.Token(SyntaxKind.YieldKeyword), SyntaxFactory.Token(GetYieldStatementReturnOrBreakKeywordKind(kind)), expression, SyntaxFactory.Token(SyntaxKind.SemicolonToken));
    }

    private static SyntaxKind GetYieldStatementReturnOrBreakKeywordKind(SyntaxKind kind)
    {
      switch (kind)
      {
        case SyntaxKind.YieldReturnStatement:
          return SyntaxKind.ReturnKeyword;
        case SyntaxKind.YieldBreakStatement:
          return SyntaxKind.BreakKeyword;
        default:
          throw new ArgumentOutOfRangeException();
      }
    }

    /// <summary>Creates a new WhileStatementSyntax instance.</summary>
    public static WhileStatementSyntax WhileStatement(SyntaxToken whileKeyword, SyntaxToken openParenToken, ExpressionSyntax condition, SyntaxToken closeParenToken, StatementSyntax statement)
    {
      switch (whileKeyword.Kind())
      {
        case SyntaxKind.WhileKeyword:
          break;
        default:
          throw new ArgumentException(nameof(whileKeyword));
      }
      switch (openParenToken.Kind())
      {
        case SyntaxKind.OpenParenToken:
          break;
        default:
          throw new ArgumentException(nameof(openParenToken));
      }
      if (condition == null)
        throw new ArgumentNullException(nameof(condition));
      switch (closeParenToken.Kind())
      {
        case SyntaxKind.CloseParenToken:
          break;
        default:
          throw new ArgumentException(nameof(closeParenToken));
      }
      if (statement == null)
        throw new ArgumentNullException(nameof(statement));
      return (WhileStatementSyntax)Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SyntaxFactory.WhileStatement((Syntax.InternalSyntax.SyntaxToken)whileKeyword.Node, (Syntax.InternalSyntax.SyntaxToken)openParenToken.Node, condition == null ? null : (Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.ExpressionSyntax)condition.Green, (Syntax.InternalSyntax.SyntaxToken)closeParenToken.Node, statement == null ? null : (Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.StatementSyntax)statement.Green).CreateRed();
    }


    /// <summary>Creates a new WhileStatementSyntax instance.</summary>
    public static WhileStatementSyntax WhileStatement(ExpressionSyntax condition, StatementSyntax statement)
    {
      return SyntaxFactory.WhileStatement(SyntaxFactory.Token(SyntaxKind.WhileKeyword), SyntaxFactory.Token(SyntaxKind.OpenParenToken), condition, SyntaxFactory.Token(SyntaxKind.CloseParenToken), statement);
    }

    /// <summary>Creates a new DoStatementSyntax instance.</summary>
    public static DoStatementSyntax DoStatement(SyntaxToken doKeyword, StatementSyntax statement, SyntaxToken whileKeyword, SyntaxToken openParenToken, ExpressionSyntax condition, SyntaxToken closeParenToken, SyntaxToken semicolonToken)
    {
      switch (doKeyword.Kind())
      {
        case SyntaxKind.DoKeyword:
          break;
        default:
          throw new ArgumentException(nameof(doKeyword));
      }
      if (statement == null)
        throw new ArgumentNullException(nameof(statement));
      switch (whileKeyword.Kind())
      {
        case SyntaxKind.WhileKeyword:
          break;
        default:
          throw new ArgumentException(nameof(whileKeyword));
      }
      switch (openParenToken.Kind())
      {
        case SyntaxKind.OpenParenToken:
          break;
        default:
          throw new ArgumentException(nameof(openParenToken));
      }
      if (condition == null)
        throw new ArgumentNullException(nameof(condition));
      switch (closeParenToken.Kind())
      {
        case SyntaxKind.CloseParenToken:
          break;
        default:
          throw new ArgumentException(nameof(closeParenToken));
      }
      switch (semicolonToken.Kind())
      {
        case SyntaxKind.SemicolonToken:
          break;
        default:
          throw new ArgumentException(nameof(semicolonToken));
      }
      return (DoStatementSyntax)Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SyntaxFactory.DoStatement((Syntax.InternalSyntax.SyntaxToken)doKeyword.Node, statement == null ? null : (Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.StatementSyntax)statement.Green, (Syntax.InternalSyntax.SyntaxToken)whileKeyword.Node, (Syntax.InternalSyntax.SyntaxToken)openParenToken.Node, condition == null ? null : (Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.ExpressionSyntax)condition.Green, (Syntax.InternalSyntax.SyntaxToken)closeParenToken.Node, (Syntax.InternalSyntax.SyntaxToken)semicolonToken.Node).CreateRed();
    }


    /// <summary>Creates a new DoStatementSyntax instance.</summary>
    public static DoStatementSyntax DoStatement(StatementSyntax statement, ExpressionSyntax condition)
    {
      return SyntaxFactory.DoStatement(SyntaxFactory.Token(SyntaxKind.DoKeyword), statement, SyntaxFactory.Token(SyntaxKind.WhileKeyword), SyntaxFactory.Token(SyntaxKind.OpenParenToken), condition, SyntaxFactory.Token(SyntaxKind.CloseParenToken), SyntaxFactory.Token(SyntaxKind.SemicolonToken));
    }

    /// <summary>Creates a new ForStatementSyntax instance.</summary>
    public static ForStatementSyntax ForStatement(SyntaxToken forKeyword, SyntaxToken openParenToken, VariableDeclarationSyntax declaration, SeparatedSyntaxList<ExpressionSyntax> initializers, SyntaxToken firstSemicolonToken, ExpressionSyntax condition, SyntaxToken secondSemicolonToken, SeparatedSyntaxList<ExpressionSyntax> incrementors, SyntaxToken closeParenToken, StatementSyntax statement)
    {
      switch (forKeyword.Kind())
      {
        case SyntaxKind.ForKeyword:
          break;
        default:
          throw new ArgumentException(nameof(forKeyword));
      }
      switch (openParenToken.Kind())
      {
        case SyntaxKind.OpenParenToken:
          break;
        default:
          throw new ArgumentException(nameof(openParenToken));
      }
      switch (firstSemicolonToken.Kind())
      {
        case SyntaxKind.SemicolonToken:
          break;
        default:
          throw new ArgumentException(nameof(firstSemicolonToken));
      }
      switch (secondSemicolonToken.Kind())
      {
        case SyntaxKind.SemicolonToken:
          break;
        default:
          throw new ArgumentException(nameof(secondSemicolonToken));
      }
      switch (closeParenToken.Kind())
      {
        case SyntaxKind.CloseParenToken:
          break;
        default:
          throw new ArgumentException(nameof(closeParenToken));
      }
      if (statement == null)
        throw new ArgumentNullException(nameof(statement));
      return (ForStatementSyntax)Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SyntaxFactory.ForStatement((Syntax.InternalSyntax.SyntaxToken)forKeyword.Node, (Syntax.InternalSyntax.SyntaxToken)openParenToken.Node, declaration == null ? null : (Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.VariableDeclarationSyntax)declaration.Green, initializers.Node.ToGreenSeparatedList<Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.ExpressionSyntax>(), (Syntax.InternalSyntax.SyntaxToken)firstSemicolonToken.Node, condition == null ? null : (Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.ExpressionSyntax)condition.Green, (Syntax.InternalSyntax.SyntaxToken)secondSemicolonToken.Node, incrementors.Node.ToGreenSeparatedList<Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.ExpressionSyntax>(), (Syntax.InternalSyntax.SyntaxToken)closeParenToken.Node, statement == null ? null : (Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.StatementSyntax)statement.Green).CreateRed();
    }


    /// <summary>Creates a new ForStatementSyntax instance.</summary>
    public static ForStatementSyntax ForStatement(VariableDeclarationSyntax declaration, SeparatedSyntaxList<ExpressionSyntax> initializers, ExpressionSyntax condition, SeparatedSyntaxList<ExpressionSyntax> incrementors, StatementSyntax statement)
    {
      return SyntaxFactory.ForStatement(SyntaxFactory.Token(SyntaxKind.ForKeyword), SyntaxFactory.Token(SyntaxKind.OpenParenToken), declaration, initializers, SyntaxFactory.Token(SyntaxKind.SemicolonToken), condition, SyntaxFactory.Token(SyntaxKind.SemicolonToken), incrementors, SyntaxFactory.Token(SyntaxKind.CloseParenToken), statement);
    }

    /// <summary>Creates a new ForStatementSyntax instance.</summary>
    public static ForStatementSyntax ForStatement(StatementSyntax statement)
    {
      return SyntaxFactory.ForStatement(SyntaxFactory.Token(SyntaxKind.ForKeyword), SyntaxFactory.Token(SyntaxKind.OpenParenToken), default(VariableDeclarationSyntax), default(SeparatedSyntaxList<ExpressionSyntax>), SyntaxFactory.Token(SyntaxKind.SemicolonToken), default(ExpressionSyntax), SyntaxFactory.Token(SyntaxKind.SemicolonToken), default(SeparatedSyntaxList<ExpressionSyntax>), SyntaxFactory.Token(SyntaxKind.CloseParenToken), statement);
    }

    /// <summary>Creates a new ForEachStatementSyntax instance.</summary>
    public static ForEachStatementSyntax ForEachStatement(SyntaxToken awaitKeyword, SyntaxToken forEachKeyword, SyntaxToken openParenToken, TypeSyntax type, SyntaxToken identifier, SyntaxToken inKeyword, ExpressionSyntax expression, SyntaxToken closeParenToken, StatementSyntax statement)
    {
      switch (awaitKeyword.Kind())
      {
        case SyntaxKind.AwaitKeyword:
        case SyntaxKind.None:
          break;
        default:
          throw new ArgumentException(nameof(awaitKeyword));
      }
      switch (forEachKeyword.Kind())
      {
        case SyntaxKind.ForEachKeyword:
          break;
        default:
          throw new ArgumentException(nameof(forEachKeyword));
      }
      switch (openParenToken.Kind())
      {
        case SyntaxKind.OpenParenToken:
          break;
        default:
          throw new ArgumentException(nameof(openParenToken));
      }
      if (type == null)
        throw new ArgumentNullException(nameof(type));
      switch (identifier.Kind())
      {
        case SyntaxKind.IdentifierToken:
          break;
        default:
          throw new ArgumentException(nameof(identifier));
      }
      switch (inKeyword.Kind())
      {
        case SyntaxKind.InKeyword:
          break;
        default:
          throw new ArgumentException(nameof(inKeyword));
      }
      if (expression == null)
        throw new ArgumentNullException(nameof(expression));
      switch (closeParenToken.Kind())
      {
        case SyntaxKind.CloseParenToken:
          break;
        default:
          throw new ArgumentException(nameof(closeParenToken));
      }
      if (statement == null)
        throw new ArgumentNullException(nameof(statement));
      return (ForEachStatementSyntax)Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SyntaxFactory.ForEachStatement((Syntax.InternalSyntax.SyntaxToken)awaitKeyword.Node, (Syntax.InternalSyntax.SyntaxToken)forEachKeyword.Node, (Syntax.InternalSyntax.SyntaxToken)openParenToken.Node, type == null ? null : (Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.TypeSyntax)type.Green, (Syntax.InternalSyntax.SyntaxToken)identifier.Node, (Syntax.InternalSyntax.SyntaxToken)inKeyword.Node, expression == null ? null : (Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.ExpressionSyntax)expression.Green, (Syntax.InternalSyntax.SyntaxToken)closeParenToken.Node, statement == null ? null : (Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.StatementSyntax)statement.Green).CreateRed();
    }


    /// <summary>Creates a new ForEachStatementSyntax instance.</summary>
    public static ForEachStatementSyntax ForEachStatement(TypeSyntax type, SyntaxToken identifier, ExpressionSyntax expression, StatementSyntax statement)
    {
      return SyntaxFactory.ForEachStatement(default(SyntaxToken), SyntaxFactory.Token(SyntaxKind.ForEachKeyword), SyntaxFactory.Token(SyntaxKind.OpenParenToken), type, identifier, SyntaxFactory.Token(SyntaxKind.InKeyword), expression, SyntaxFactory.Token(SyntaxKind.CloseParenToken), statement);
    }

    /// <summary>Creates a new ForEachStatementSyntax instance.</summary>
    public static ForEachStatementSyntax ForEachStatement(TypeSyntax type, string identifier, ExpressionSyntax expression, StatementSyntax statement)
    {
      return SyntaxFactory.ForEachStatement(default(SyntaxToken), SyntaxFactory.Token(SyntaxKind.ForEachKeyword), SyntaxFactory.Token(SyntaxKind.OpenParenToken), type, SyntaxFactory.Identifier(identifier), SyntaxFactory.Token(SyntaxKind.InKeyword), expression, SyntaxFactory.Token(SyntaxKind.CloseParenToken), statement);
    }

    /// <summary>Creates a new ForEachVariableStatementSyntax instance.</summary>
    public static ForEachVariableStatementSyntax ForEachVariableStatement(SyntaxToken awaitKeyword, SyntaxToken forEachKeyword, SyntaxToken openParenToken, ExpressionSyntax variable, SyntaxToken inKeyword, ExpressionSyntax expression, SyntaxToken closeParenToken, StatementSyntax statement)
    {
      switch (awaitKeyword.Kind())
      {
        case SyntaxKind.AwaitKeyword:
        case SyntaxKind.None:
          break;
        default:
          throw new ArgumentException(nameof(awaitKeyword));
      }
      switch (forEachKeyword.Kind())
      {
        case SyntaxKind.ForEachKeyword:
          break;
        default:
          throw new ArgumentException(nameof(forEachKeyword));
      }
      switch (openParenToken.Kind())
      {
        case SyntaxKind.OpenParenToken:
          break;
        default:
          throw new ArgumentException(nameof(openParenToken));
      }
      if (variable == null)
        throw new ArgumentNullException(nameof(variable));
      switch (inKeyword.Kind())
      {
        case SyntaxKind.InKeyword:
          break;
        default:
          throw new ArgumentException(nameof(inKeyword));
      }
      if (expression == null)
        throw new ArgumentNullException(nameof(expression));
      switch (closeParenToken.Kind())
      {
        case SyntaxKind.CloseParenToken:
          break;
        default:
          throw new ArgumentException(nameof(closeParenToken));
      }
      if (statement == null)
        throw new ArgumentNullException(nameof(statement));
      return (ForEachVariableStatementSyntax)Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SyntaxFactory.ForEachVariableStatement((Syntax.InternalSyntax.SyntaxToken)awaitKeyword.Node, (Syntax.InternalSyntax.SyntaxToken)forEachKeyword.Node, (Syntax.InternalSyntax.SyntaxToken)openParenToken.Node, variable == null ? null : (Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.ExpressionSyntax)variable.Green, (Syntax.InternalSyntax.SyntaxToken)inKeyword.Node, expression == null ? null : (Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.ExpressionSyntax)expression.Green, (Syntax.InternalSyntax.SyntaxToken)closeParenToken.Node, statement == null ? null : (Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.StatementSyntax)statement.Green).CreateRed();
    }


    /// <summary>Creates a new ForEachVariableStatementSyntax instance.</summary>
    public static ForEachVariableStatementSyntax ForEachVariableStatement(ExpressionSyntax variable, ExpressionSyntax expression, StatementSyntax statement)
    {
      return SyntaxFactory.ForEachVariableStatement(default(SyntaxToken), SyntaxFactory.Token(SyntaxKind.ForEachKeyword), SyntaxFactory.Token(SyntaxKind.OpenParenToken), variable, SyntaxFactory.Token(SyntaxKind.InKeyword), expression, SyntaxFactory.Token(SyntaxKind.CloseParenToken), statement);
    }

    /// <summary>Creates a new UsingStatementSyntax instance.</summary>
    public static UsingStatementSyntax UsingStatement(SyntaxToken awaitKeyword, SyntaxToken usingKeyword, SyntaxToken openParenToken, VariableDeclarationSyntax declaration, ExpressionSyntax expression, SyntaxToken closeParenToken, StatementSyntax statement)
    {
      switch (awaitKeyword.Kind())
      {
        case SyntaxKind.AwaitKeyword:
        case SyntaxKind.None:
          break;
        default:
          throw new ArgumentException(nameof(awaitKeyword));
      }
      switch (usingKeyword.Kind())
      {
        case SyntaxKind.UsingKeyword:
          break;
        default:
          throw new ArgumentException(nameof(usingKeyword));
      }
      switch (openParenToken.Kind())
      {
        case SyntaxKind.OpenParenToken:
          break;
        default:
          throw new ArgumentException(nameof(openParenToken));
      }
      switch (closeParenToken.Kind())
      {
        case SyntaxKind.CloseParenToken:
          break;
        default:
          throw new ArgumentException(nameof(closeParenToken));
      }
      if (statement == null)
        throw new ArgumentNullException(nameof(statement));
      return (UsingStatementSyntax)Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SyntaxFactory.UsingStatement((Syntax.InternalSyntax.SyntaxToken)awaitKeyword.Node, (Syntax.InternalSyntax.SyntaxToken)usingKeyword.Node, (Syntax.InternalSyntax.SyntaxToken)openParenToken.Node, declaration == null ? null : (Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.VariableDeclarationSyntax)declaration.Green, expression == null ? null : (Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.ExpressionSyntax)expression.Green, (Syntax.InternalSyntax.SyntaxToken)closeParenToken.Node, statement == null ? null : (Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.StatementSyntax)statement.Green).CreateRed();
    }


    /// <summary>Creates a new UsingStatementSyntax instance.</summary>
    public static UsingStatementSyntax UsingStatement(VariableDeclarationSyntax declaration, ExpressionSyntax expression, StatementSyntax statement)
    {
      return SyntaxFactory.UsingStatement(default(SyntaxToken), SyntaxFactory.Token(SyntaxKind.UsingKeyword), SyntaxFactory.Token(SyntaxKind.OpenParenToken), declaration, expression, SyntaxFactory.Token(SyntaxKind.CloseParenToken), statement);
    }

    /// <summary>Creates a new UsingStatementSyntax instance.</summary>
    public static UsingStatementSyntax UsingStatement(StatementSyntax statement)
    {
      return SyntaxFactory.UsingStatement(default(SyntaxToken), SyntaxFactory.Token(SyntaxKind.UsingKeyword), SyntaxFactory.Token(SyntaxKind.OpenParenToken), default(VariableDeclarationSyntax), default(ExpressionSyntax), SyntaxFactory.Token(SyntaxKind.CloseParenToken), statement);
    }

    /// <summary>Creates a new FixedStatementSyntax instance.</summary>
    public static FixedStatementSyntax FixedStatement(SyntaxToken fixedKeyword, SyntaxToken openParenToken, VariableDeclarationSyntax declaration, SyntaxToken closeParenToken, StatementSyntax statement)
    {
      switch (fixedKeyword.Kind())
      {
        case SyntaxKind.FixedKeyword:
          break;
        default:
          throw new ArgumentException(nameof(fixedKeyword));
      }
      switch (openParenToken.Kind())
      {
        case SyntaxKind.OpenParenToken:
          break;
        default:
          throw new ArgumentException(nameof(openParenToken));
      }
      if (declaration == null)
        throw new ArgumentNullException(nameof(declaration));
      switch (closeParenToken.Kind())
      {
        case SyntaxKind.CloseParenToken:
          break;
        default:
          throw new ArgumentException(nameof(closeParenToken));
      }
      if (statement == null)
        throw new ArgumentNullException(nameof(statement));
      return (FixedStatementSyntax)Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SyntaxFactory.FixedStatement((Syntax.InternalSyntax.SyntaxToken)fixedKeyword.Node, (Syntax.InternalSyntax.SyntaxToken)openParenToken.Node, declaration == null ? null : (Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.VariableDeclarationSyntax)declaration.Green, (Syntax.InternalSyntax.SyntaxToken)closeParenToken.Node, statement == null ? null : (Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.StatementSyntax)statement.Green).CreateRed();
    }


    /// <summary>Creates a new FixedStatementSyntax instance.</summary>
    public static FixedStatementSyntax FixedStatement(VariableDeclarationSyntax declaration, StatementSyntax statement)
    {
      return SyntaxFactory.FixedStatement(SyntaxFactory.Token(SyntaxKind.FixedKeyword), SyntaxFactory.Token(SyntaxKind.OpenParenToken), declaration, SyntaxFactory.Token(SyntaxKind.CloseParenToken), statement);
    }

    /// <summary>Creates a new CheckedStatementSyntax instance.</summary>
    public static CheckedStatementSyntax CheckedStatement(SyntaxKind kind, SyntaxToken keyword, BlockSyntax block)
    {
      switch (kind)
      {
        case SyntaxKind.CheckedStatement:
        case SyntaxKind.UncheckedStatement:
          break;
        default:
          throw new ArgumentException(nameof(kind));
      }
      switch (keyword.Kind())
      {
        case SyntaxKind.CheckedKeyword:
        case SyntaxKind.UncheckedKeyword:
          break;
        default:
          throw new ArgumentException(nameof(keyword));
      }
      if (block == null)
        throw new ArgumentNullException(nameof(block));
      return (CheckedStatementSyntax)Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SyntaxFactory.CheckedStatement(kind, (Syntax.InternalSyntax.SyntaxToken)keyword.Node, block == null ? null : (Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.BlockSyntax)block.Green).CreateRed();
    }


    /// <summary>Creates a new CheckedStatementSyntax instance.</summary>
    public static CheckedStatementSyntax CheckedStatement(SyntaxKind kind, BlockSyntax block = default(BlockSyntax))
    {
      return SyntaxFactory.CheckedStatement(kind, SyntaxFactory.Token(GetCheckedStatementKeywordKind(kind)), block ?? SyntaxFactory.Block());
    }

    private static SyntaxKind GetCheckedStatementKeywordKind(SyntaxKind kind)
    {
      switch (kind)
      {
        case SyntaxKind.CheckedStatement:
          return SyntaxKind.CheckedKeyword;
        case SyntaxKind.UncheckedStatement:
          return SyntaxKind.UncheckedKeyword;
        default:
          throw new ArgumentOutOfRangeException();
      }
    }

    /// <summary>Creates a new UnsafeStatementSyntax instance.</summary>
    public static UnsafeStatementSyntax UnsafeStatement(SyntaxToken unsafeKeyword, BlockSyntax block)
    {
      switch (unsafeKeyword.Kind())
      {
        case SyntaxKind.UnsafeKeyword:
          break;
        default:
          throw new ArgumentException(nameof(unsafeKeyword));
      }
      if (block == null)
        throw new ArgumentNullException(nameof(block));
      return (UnsafeStatementSyntax)Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SyntaxFactory.UnsafeStatement((Syntax.InternalSyntax.SyntaxToken)unsafeKeyword.Node, block == null ? null : (Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.BlockSyntax)block.Green).CreateRed();
    }


    /// <summary>Creates a new UnsafeStatementSyntax instance.</summary>
    public static UnsafeStatementSyntax UnsafeStatement(BlockSyntax block = default(BlockSyntax))
    {
      return SyntaxFactory.UnsafeStatement(SyntaxFactory.Token(SyntaxKind.UnsafeKeyword), block ?? SyntaxFactory.Block());
    }

    /// <summary>Creates a new LockStatementSyntax instance.</summary>
    public static LockStatementSyntax LockStatement(SyntaxToken lockKeyword, SyntaxToken openParenToken, ExpressionSyntax expression, SyntaxToken closeParenToken, StatementSyntax statement)
    {
      switch (lockKeyword.Kind())
      {
        case SyntaxKind.LockKeyword:
          break;
        default:
          throw new ArgumentException(nameof(lockKeyword));
      }
      switch (openParenToken.Kind())
      {
        case SyntaxKind.OpenParenToken:
          break;
        default:
          throw new ArgumentException(nameof(openParenToken));
      }
      if (expression == null)
        throw new ArgumentNullException(nameof(expression));
      switch (closeParenToken.Kind())
      {
        case SyntaxKind.CloseParenToken:
          break;
        default:
          throw new ArgumentException(nameof(closeParenToken));
      }
      if (statement == null)
        throw new ArgumentNullException(nameof(statement));
      return (LockStatementSyntax)Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SyntaxFactory.LockStatement((Syntax.InternalSyntax.SyntaxToken)lockKeyword.Node, (Syntax.InternalSyntax.SyntaxToken)openParenToken.Node, expression == null ? null : (Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.ExpressionSyntax)expression.Green, (Syntax.InternalSyntax.SyntaxToken)closeParenToken.Node, statement == null ? null : (Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.StatementSyntax)statement.Green).CreateRed();
    }


    /// <summary>Creates a new LockStatementSyntax instance.</summary>
    public static LockStatementSyntax LockStatement(ExpressionSyntax expression, StatementSyntax statement)
    {
      return SyntaxFactory.LockStatement(SyntaxFactory.Token(SyntaxKind.LockKeyword), SyntaxFactory.Token(SyntaxKind.OpenParenToken), expression, SyntaxFactory.Token(SyntaxKind.CloseParenToken), statement);
    }

    /// <summary>Creates a new IfStatementSyntax instance.</summary>
    public static IfStatementSyntax IfStatement(SyntaxToken ifKeyword, SyntaxToken openParenToken, ExpressionSyntax condition, SyntaxToken closeParenToken, StatementSyntax statement, ElseClauseSyntax @else)
    {
      switch (ifKeyword.Kind())
      {
        case SyntaxKind.IfKeyword:
          break;
        default:
          throw new ArgumentException(nameof(ifKeyword));
      }
      switch (openParenToken.Kind())
      {
        case SyntaxKind.OpenParenToken:
          break;
        default:
          throw new ArgumentException(nameof(openParenToken));
      }
      if (condition == null)
        throw new ArgumentNullException(nameof(condition));
      switch (closeParenToken.Kind())
      {
        case SyntaxKind.CloseParenToken:
          break;
        default:
          throw new ArgumentException(nameof(closeParenToken));
      }
      if (statement == null)
        throw new ArgumentNullException(nameof(statement));
      return (IfStatementSyntax)Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SyntaxFactory.IfStatement((Syntax.InternalSyntax.SyntaxToken)ifKeyword.Node, (Syntax.InternalSyntax.SyntaxToken)openParenToken.Node, condition == null ? null : (Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.ExpressionSyntax)condition.Green, (Syntax.InternalSyntax.SyntaxToken)closeParenToken.Node, statement == null ? null : (Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.StatementSyntax)statement.Green, @else == null ? null : (Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.ElseClauseSyntax)@else.Green).CreateRed();
    }


    /// <summary>Creates a new IfStatementSyntax instance.</summary>
    public static IfStatementSyntax IfStatement(ExpressionSyntax condition, StatementSyntax statement, ElseClauseSyntax @else)
    {
      return SyntaxFactory.IfStatement(SyntaxFactory.Token(SyntaxKind.IfKeyword), SyntaxFactory.Token(SyntaxKind.OpenParenToken), condition, SyntaxFactory.Token(SyntaxKind.CloseParenToken), statement, @else);
    }

    /// <summary>Creates a new IfStatementSyntax instance.</summary>
    public static IfStatementSyntax IfStatement(ExpressionSyntax condition, StatementSyntax statement)
    {
      return SyntaxFactory.IfStatement(SyntaxFactory.Token(SyntaxKind.IfKeyword), SyntaxFactory.Token(SyntaxKind.OpenParenToken), condition, SyntaxFactory.Token(SyntaxKind.CloseParenToken), statement, default(ElseClauseSyntax));
    }

    /// <summary>Creates a new ElseClauseSyntax instance.</summary>
    public static ElseClauseSyntax ElseClause(SyntaxToken elseKeyword, StatementSyntax statement)
    {
      switch (elseKeyword.Kind())
      {
        case SyntaxKind.ElseKeyword:
          break;
        default:
          throw new ArgumentException(nameof(elseKeyword));
      }
      if (statement == null)
        throw new ArgumentNullException(nameof(statement));
      return (ElseClauseSyntax)Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SyntaxFactory.ElseClause((Syntax.InternalSyntax.SyntaxToken)elseKeyword.Node, statement == null ? null : (Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.StatementSyntax)statement.Green).CreateRed();
    }


    /// <summary>Creates a new ElseClauseSyntax instance.</summary>
    public static ElseClauseSyntax ElseClause(StatementSyntax statement)
    {
      return SyntaxFactory.ElseClause(SyntaxFactory.Token(SyntaxKind.ElseKeyword), statement);
    }

    /// <summary>Creates a new SwitchStatementSyntax instance.</summary>
    public static SwitchStatementSyntax SwitchStatement(SyntaxToken switchKeyword, SyntaxToken openParenToken, ExpressionSyntax expression, SyntaxToken closeParenToken, SyntaxToken openBraceToken, SyntaxList<SwitchSectionSyntax> sections, SyntaxToken closeBraceToken)
    {
      switch (switchKeyword.Kind())
      {
        case SyntaxKind.SwitchKeyword:
          break;
        default:
          throw new ArgumentException(nameof(switchKeyword));
      }
      switch (openParenToken.Kind())
      {
        case SyntaxKind.OpenParenToken:
        case SyntaxKind.None:
          break;
        default:
          throw new ArgumentException(nameof(openParenToken));
      }
      if (expression == null)
        throw new ArgumentNullException(nameof(expression));
      switch (closeParenToken.Kind())
      {
        case SyntaxKind.CloseParenToken:
        case SyntaxKind.None:
          break;
        default:
          throw new ArgumentException(nameof(closeParenToken));
      }
      switch (openBraceToken.Kind())
      {
        case SyntaxKind.OpenBraceToken:
          break;
        default:
          throw new ArgumentException(nameof(openBraceToken));
      }
      switch (closeBraceToken.Kind())
      {
        case SyntaxKind.CloseBraceToken:
          break;
        default:
          throw new ArgumentException(nameof(closeBraceToken));
      }
      return (SwitchStatementSyntax)Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SyntaxFactory.SwitchStatement((Syntax.InternalSyntax.SyntaxToken)switchKeyword.Node, (Syntax.InternalSyntax.SyntaxToken)openParenToken.Node, expression == null ? null : (Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.ExpressionSyntax)expression.Green, (Syntax.InternalSyntax.SyntaxToken)closeParenToken.Node, (Syntax.InternalSyntax.SyntaxToken)openBraceToken.Node, sections.Node.ToGreenList<Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SwitchSectionSyntax>(), (Syntax.InternalSyntax.SyntaxToken)closeBraceToken.Node).CreateRed();
    }


    /// <summary>Creates a new SwitchSectionSyntax instance.</summary>
    public static SwitchSectionSyntax SwitchSection(SyntaxList<SwitchLabelSyntax> labels, SyntaxList<StatementSyntax> statements)
    {
      return (SwitchSectionSyntax)Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SyntaxFactory.SwitchSection(labels.Node.ToGreenList<Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SwitchLabelSyntax>(), statements.Node.ToGreenList<Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.StatementSyntax>()).CreateRed();
    }


    /// <summary>Creates a new SwitchSectionSyntax instance.</summary>
    public static SwitchSectionSyntax SwitchSection()
    {
      return SyntaxFactory.SwitchSection(default(SyntaxList<SwitchLabelSyntax>), default(SyntaxList<StatementSyntax>));
    }

    /// <summary>Creates a new CasePatternSwitchLabelSyntax instance.</summary>
    public static CasePatternSwitchLabelSyntax CasePatternSwitchLabel(SyntaxToken keyword, PatternSyntax pattern, WhenClauseSyntax whenClause, SyntaxToken colonToken)
    {
      switch (keyword.Kind())
      {
        case SyntaxKind.CaseKeyword:
          break;
        default:
          throw new ArgumentException(nameof(keyword));
      }
      if (pattern == null)
        throw new ArgumentNullException(nameof(pattern));
      return (CasePatternSwitchLabelSyntax)Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SyntaxFactory.CasePatternSwitchLabel((Syntax.InternalSyntax.SyntaxToken)keyword.Node, pattern == null ? null : (Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.PatternSyntax)pattern.Green, whenClause == null ? null : (Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.WhenClauseSyntax)whenClause.Green, (Syntax.InternalSyntax.SyntaxToken)colonToken.Node).CreateRed();
    }


    /// <summary>Creates a new CasePatternSwitchLabelSyntax instance.</summary>
    public static CasePatternSwitchLabelSyntax CasePatternSwitchLabel(PatternSyntax pattern, WhenClauseSyntax whenClause, SyntaxToken colonToken)
    {
      return SyntaxFactory.CasePatternSwitchLabel(SyntaxFactory.Token(SyntaxKind.CaseKeyword), pattern, whenClause, colonToken);
    }

    /// <summary>Creates a new CasePatternSwitchLabelSyntax instance.</summary>
    public static CasePatternSwitchLabelSyntax CasePatternSwitchLabel(PatternSyntax pattern, SyntaxToken colonToken)
    {
      return SyntaxFactory.CasePatternSwitchLabel(SyntaxFactory.Token(SyntaxKind.CaseKeyword), pattern, default(WhenClauseSyntax), colonToken);
    }

    /// <summary>Creates a new CaseSwitchLabelSyntax instance.</summary>
    public static CaseSwitchLabelSyntax CaseSwitchLabel(SyntaxToken keyword, ExpressionSyntax value, SyntaxToken colonToken)
    {
      switch (keyword.Kind())
      {
        case SyntaxKind.CaseKeyword:
          break;
        default:
          throw new ArgumentException(nameof(keyword));
      }
      if (value == null)
        throw new ArgumentNullException(nameof(value));
      return (CaseSwitchLabelSyntax)Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SyntaxFactory.CaseSwitchLabel((Syntax.InternalSyntax.SyntaxToken)keyword.Node, value == null ? null : (Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.ExpressionSyntax)value.Green, (Syntax.InternalSyntax.SyntaxToken)colonToken.Node).CreateRed();
    }


    /// <summary>Creates a new CaseSwitchLabelSyntax instance.</summary>
    public static CaseSwitchLabelSyntax CaseSwitchLabel(ExpressionSyntax value, SyntaxToken colonToken)
    {
      return SyntaxFactory.CaseSwitchLabel(SyntaxFactory.Token(SyntaxKind.CaseKeyword), value, colonToken);
    }

    /// <summary>Creates a new DefaultSwitchLabelSyntax instance.</summary>
    public static DefaultSwitchLabelSyntax DefaultSwitchLabel(SyntaxToken keyword, SyntaxToken colonToken)
    {
      switch (keyword.Kind())
      {
        case SyntaxKind.DefaultKeyword:
          break;
        default:
          throw new ArgumentException(nameof(keyword));
      }
      return (DefaultSwitchLabelSyntax)Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SyntaxFactory.DefaultSwitchLabel((Syntax.InternalSyntax.SyntaxToken)keyword.Node, (Syntax.InternalSyntax.SyntaxToken)colonToken.Node).CreateRed();
    }


    /// <summary>Creates a new DefaultSwitchLabelSyntax instance.</summary>
    public static DefaultSwitchLabelSyntax DefaultSwitchLabel(SyntaxToken colonToken)
    {
      return SyntaxFactory.DefaultSwitchLabel(SyntaxFactory.Token(SyntaxKind.DefaultKeyword), colonToken);
    }

    /// <summary>Creates a new SwitchExpressionSyntax instance.</summary>
    public static SwitchExpressionSyntax SwitchExpression(ExpressionSyntax governingExpression, SyntaxToken switchKeyword, SyntaxToken openBraceToken, SeparatedSyntaxList<SwitchExpressionArmSyntax> arms, SyntaxToken closeBraceToken)
    {
      if (governingExpression == null)
        throw new ArgumentNullException(nameof(governingExpression));
      switch (switchKeyword.Kind())
      {
        case SyntaxKind.SwitchKeyword:
          break;
        default:
          throw new ArgumentException(nameof(switchKeyword));
      }
      switch (openBraceToken.Kind())
      {
        case SyntaxKind.OpenBraceToken:
          break;
        default:
          throw new ArgumentException(nameof(openBraceToken));
      }
      switch (closeBraceToken.Kind())
      {
        case SyntaxKind.CloseBraceToken:
          break;
        default:
          throw new ArgumentException(nameof(closeBraceToken));
      }
      return (SwitchExpressionSyntax)Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SyntaxFactory.SwitchExpression(governingExpression == null ? null : (Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.ExpressionSyntax)governingExpression.Green, (Syntax.InternalSyntax.SyntaxToken)switchKeyword.Node, (Syntax.InternalSyntax.SyntaxToken)openBraceToken.Node, arms.Node.ToGreenSeparatedList<Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SwitchExpressionArmSyntax>(), (Syntax.InternalSyntax.SyntaxToken)closeBraceToken.Node).CreateRed();
    }


    /// <summary>Creates a new SwitchExpressionSyntax instance.</summary>
    public static SwitchExpressionSyntax SwitchExpression(ExpressionSyntax governingExpression, SeparatedSyntaxList<SwitchExpressionArmSyntax> arms)
    {
      return SyntaxFactory.SwitchExpression(governingExpression, SyntaxFactory.Token(SyntaxKind.SwitchKeyword), SyntaxFactory.Token(SyntaxKind.OpenBraceToken), arms, SyntaxFactory.Token(SyntaxKind.CloseBraceToken));
    }

    /// <summary>Creates a new SwitchExpressionSyntax instance.</summary>
    public static SwitchExpressionSyntax SwitchExpression(ExpressionSyntax governingExpression)
    {
      return SyntaxFactory.SwitchExpression(governingExpression, SyntaxFactory.Token(SyntaxKind.SwitchKeyword), SyntaxFactory.Token(SyntaxKind.OpenBraceToken), default(SeparatedSyntaxList<SwitchExpressionArmSyntax>), SyntaxFactory.Token(SyntaxKind.CloseBraceToken));
    }

    /// <summary>Creates a new SwitchExpressionArmSyntax instance.</summary>
    public static SwitchExpressionArmSyntax SwitchExpressionArm(PatternSyntax pattern, WhenClauseSyntax whenClause, SyntaxToken equalsGreaterThanToken, ExpressionSyntax expression)
    {
      if (pattern == null)
        throw new ArgumentNullException(nameof(pattern));
      switch (equalsGreaterThanToken.Kind())
      {
        case SyntaxKind.EqualsGreaterThanToken:
          break;
        default:
          throw new ArgumentException(nameof(equalsGreaterThanToken));
      }
      if (expression == null)
        throw new ArgumentNullException(nameof(expression));
      return (SwitchExpressionArmSyntax)Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SyntaxFactory.SwitchExpressionArm(pattern == null ? null : (Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.PatternSyntax)pattern.Green, whenClause == null ? null : (Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.WhenClauseSyntax)whenClause.Green, (Syntax.InternalSyntax.SyntaxToken)equalsGreaterThanToken.Node, expression == null ? null : (Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.ExpressionSyntax)expression.Green).CreateRed();
    }


    /// <summary>Creates a new SwitchExpressionArmSyntax instance.</summary>
    public static SwitchExpressionArmSyntax SwitchExpressionArm(PatternSyntax pattern, WhenClauseSyntax whenClause, ExpressionSyntax expression)
    {
      return SyntaxFactory.SwitchExpressionArm(pattern, whenClause, SyntaxFactory.Token(SyntaxKind.EqualsGreaterThanToken), expression);
    }

    /// <summary>Creates a new SwitchExpressionArmSyntax instance.</summary>
    public static SwitchExpressionArmSyntax SwitchExpressionArm(PatternSyntax pattern, ExpressionSyntax expression)
    {
      return SyntaxFactory.SwitchExpressionArm(pattern, default(WhenClauseSyntax), SyntaxFactory.Token(SyntaxKind.EqualsGreaterThanToken), expression);
    }

    /// <summary>Creates a new TryStatementSyntax instance.</summary>
    public static TryStatementSyntax TryStatement(SyntaxToken tryKeyword, BlockSyntax block, SyntaxList<CatchClauseSyntax> catches, FinallyClauseSyntax @finally)
    {
      switch (tryKeyword.Kind())
      {
        case SyntaxKind.TryKeyword:
          break;
        default:
          throw new ArgumentException(nameof(tryKeyword));
      }
      if (block == null)
        throw new ArgumentNullException(nameof(block));
      return (TryStatementSyntax)Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SyntaxFactory.TryStatement((Syntax.InternalSyntax.SyntaxToken)tryKeyword.Node, block == null ? null : (Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.BlockSyntax)block.Green, catches.Node.ToGreenList<Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CatchClauseSyntax>(), @finally == null ? null : (Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.FinallyClauseSyntax)@finally.Green).CreateRed();
    }


    /// <summary>Creates a new TryStatementSyntax instance.</summary>
    public static TryStatementSyntax TryStatement(BlockSyntax block, SyntaxList<CatchClauseSyntax> catches, FinallyClauseSyntax @finally)
    {
      return SyntaxFactory.TryStatement(SyntaxFactory.Token(SyntaxKind.TryKeyword), block, catches, @finally);
    }

    /// <summary>Creates a new TryStatementSyntax instance.</summary>
    public static TryStatementSyntax TryStatement(SyntaxList<CatchClauseSyntax> catches = default(SyntaxList<CatchClauseSyntax>))
    {
      return SyntaxFactory.TryStatement(SyntaxFactory.Token(SyntaxKind.TryKeyword), SyntaxFactory.Block(), catches, default(FinallyClauseSyntax));
    }

    /// <summary>Creates a new CatchClauseSyntax instance.</summary>
    public static CatchClauseSyntax CatchClause(SyntaxToken catchKeyword, CatchDeclarationSyntax declaration, CatchFilterClauseSyntax filter, BlockSyntax block)
    {
      switch (catchKeyword.Kind())
      {
        case SyntaxKind.CatchKeyword:
          break;
        default:
          throw new ArgumentException(nameof(catchKeyword));
      }
      if (block == null)
        throw new ArgumentNullException(nameof(block));
      return (CatchClauseSyntax)Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SyntaxFactory.CatchClause((Syntax.InternalSyntax.SyntaxToken)catchKeyword.Node, declaration == null ? null : (Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CatchDeclarationSyntax)declaration.Green, filter == null ? null : (Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CatchFilterClauseSyntax)filter.Green, block == null ? null : (Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.BlockSyntax)block.Green).CreateRed();
    }


    /// <summary>Creates a new CatchClauseSyntax instance.</summary>
    public static CatchClauseSyntax CatchClause(CatchDeclarationSyntax declaration, CatchFilterClauseSyntax filter, BlockSyntax block)
    {
      return SyntaxFactory.CatchClause(SyntaxFactory.Token(SyntaxKind.CatchKeyword), declaration, filter, block);
    }

    /// <summary>Creates a new CatchClauseSyntax instance.</summary>
    public static CatchClauseSyntax CatchClause()
    {
      return SyntaxFactory.CatchClause(SyntaxFactory.Token(SyntaxKind.CatchKeyword), default(CatchDeclarationSyntax), default(CatchFilterClauseSyntax), SyntaxFactory.Block());
    }

    /// <summary>Creates a new CatchDeclarationSyntax instance.</summary>
    public static CatchDeclarationSyntax CatchDeclaration(SyntaxToken openParenToken, TypeSyntax type, SyntaxToken identifier, SyntaxToken closeParenToken)
    {
      switch (openParenToken.Kind())
      {
        case SyntaxKind.OpenParenToken:
          break;
        default:
          throw new ArgumentException(nameof(openParenToken));
      }
      if (type == null)
        throw new ArgumentNullException(nameof(type));
      switch (identifier.Kind())
      {
        case SyntaxKind.IdentifierToken:
        case SyntaxKind.None:
          break;
        default:
          throw new ArgumentException(nameof(identifier));
      }
      switch (closeParenToken.Kind())
      {
        case SyntaxKind.CloseParenToken:
          break;
        default:
          throw new ArgumentException(nameof(closeParenToken));
      }
      return (CatchDeclarationSyntax)Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SyntaxFactory.CatchDeclaration((Syntax.InternalSyntax.SyntaxToken)openParenToken.Node, type == null ? null : (Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.TypeSyntax)type.Green, (Syntax.InternalSyntax.SyntaxToken)identifier.Node, (Syntax.InternalSyntax.SyntaxToken)closeParenToken.Node).CreateRed();
    }


    /// <summary>Creates a new CatchDeclarationSyntax instance.</summary>
    public static CatchDeclarationSyntax CatchDeclaration(TypeSyntax type, SyntaxToken identifier)
    {
      return SyntaxFactory.CatchDeclaration(SyntaxFactory.Token(SyntaxKind.OpenParenToken), type, identifier, SyntaxFactory.Token(SyntaxKind.CloseParenToken));
    }

    /// <summary>Creates a new CatchDeclarationSyntax instance.</summary>
    public static CatchDeclarationSyntax CatchDeclaration(TypeSyntax type)
    {
      return SyntaxFactory.CatchDeclaration(SyntaxFactory.Token(SyntaxKind.OpenParenToken), type, default(SyntaxToken), SyntaxFactory.Token(SyntaxKind.CloseParenToken));
    }

    /// <summary>Creates a new CatchFilterClauseSyntax instance.</summary>
    public static CatchFilterClauseSyntax CatchFilterClause(SyntaxToken whenKeyword, SyntaxToken openParenToken, ExpressionSyntax filterExpression, SyntaxToken closeParenToken)
    {
      switch (whenKeyword.Kind())
      {
        case SyntaxKind.WhenKeyword:
          break;
        default:
          throw new ArgumentException(nameof(whenKeyword));
      }
      switch (openParenToken.Kind())
      {
        case SyntaxKind.OpenParenToken:
          break;
        default:
          throw new ArgumentException(nameof(openParenToken));
      }
      if (filterExpression == null)
        throw new ArgumentNullException(nameof(filterExpression));
      switch (closeParenToken.Kind())
      {
        case SyntaxKind.CloseParenToken:
          break;
        default:
          throw new ArgumentException(nameof(closeParenToken));
      }
      return (CatchFilterClauseSyntax)Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SyntaxFactory.CatchFilterClause((Syntax.InternalSyntax.SyntaxToken)whenKeyword.Node, (Syntax.InternalSyntax.SyntaxToken)openParenToken.Node, filterExpression == null ? null : (Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.ExpressionSyntax)filterExpression.Green, (Syntax.InternalSyntax.SyntaxToken)closeParenToken.Node).CreateRed();
    }


    /// <summary>Creates a new CatchFilterClauseSyntax instance.</summary>
    public static CatchFilterClauseSyntax CatchFilterClause(ExpressionSyntax filterExpression)
    {
      return SyntaxFactory.CatchFilterClause(SyntaxFactory.Token(SyntaxKind.WhenKeyword), SyntaxFactory.Token(SyntaxKind.OpenParenToken), filterExpression, SyntaxFactory.Token(SyntaxKind.CloseParenToken));
    }

    /// <summary>Creates a new FinallyClauseSyntax instance.</summary>
    public static FinallyClauseSyntax FinallyClause(SyntaxToken finallyKeyword, BlockSyntax block)
    {
      switch (finallyKeyword.Kind())
      {
        case SyntaxKind.FinallyKeyword:
          break;
        default:
          throw new ArgumentException(nameof(finallyKeyword));
      }
      if (block == null)
        throw new ArgumentNullException(nameof(block));
      return (FinallyClauseSyntax)Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SyntaxFactory.FinallyClause((Syntax.InternalSyntax.SyntaxToken)finallyKeyword.Node, block == null ? null : (Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.BlockSyntax)block.Green).CreateRed();
    }


    /// <summary>Creates a new FinallyClauseSyntax instance.</summary>
    public static FinallyClauseSyntax FinallyClause(BlockSyntax block = default(BlockSyntax))
    {
      return SyntaxFactory.FinallyClause(SyntaxFactory.Token(SyntaxKind.FinallyKeyword), block ?? SyntaxFactory.Block());
    }

    /// <summary>Creates a new CompilationUnitSyntax instance.</summary>
    public static CompilationUnitSyntax CompilationUnit(SyntaxList<ExternAliasDirectiveSyntax> externs, SyntaxList<UsingDirectiveSyntax> usings, SyntaxList<AttributeListSyntax> attributeLists, SyntaxList<MemberDeclarationSyntax> members, SyntaxToken endOfFileToken)
    {
      switch (endOfFileToken.Kind())
      {
        case SyntaxKind.EndOfFileToken:
          break;
        default:
          throw new ArgumentException(nameof(endOfFileToken));
      }
      return (CompilationUnitSyntax)Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SyntaxFactory.CompilationUnit(externs.Node.ToGreenList<Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.ExternAliasDirectiveSyntax>(), usings.Node.ToGreenList<Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.UsingDirectiveSyntax>(), attributeLists.Node.ToGreenList<Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.AttributeListSyntax>(), members.Node.ToGreenList<Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.MemberDeclarationSyntax>(), (Syntax.InternalSyntax.SyntaxToken)endOfFileToken.Node).CreateRed();
    }


    /// <summary>Creates a new CompilationUnitSyntax instance.</summary>
    public static CompilationUnitSyntax CompilationUnit(SyntaxList<ExternAliasDirectiveSyntax> externs, SyntaxList<UsingDirectiveSyntax> usings, SyntaxList<AttributeListSyntax> attributeLists, SyntaxList<MemberDeclarationSyntax> members)
    {
      return SyntaxFactory.CompilationUnit(externs, usings, attributeLists, members, SyntaxFactory.Token(SyntaxKind.EndOfFileToken));
    }

    /// <summary>Creates a new CompilationUnitSyntax instance.</summary>
    public static CompilationUnitSyntax CompilationUnit()
    {
      return SyntaxFactory.CompilationUnit(default(SyntaxList<ExternAliasDirectiveSyntax>), default(SyntaxList<UsingDirectiveSyntax>), default(SyntaxList<AttributeListSyntax>), default(SyntaxList<MemberDeclarationSyntax>), SyntaxFactory.Token(SyntaxKind.EndOfFileToken));
    }

    /// <summary>Creates a new ExternAliasDirectiveSyntax instance.</summary>
    public static ExternAliasDirectiveSyntax ExternAliasDirective(SyntaxToken externKeyword, SyntaxToken aliasKeyword, SyntaxToken identifier, SyntaxToken semicolonToken)
    {
      switch (externKeyword.Kind())
      {
        case SyntaxKind.ExternKeyword:
          break;
        default:
          throw new ArgumentException(nameof(externKeyword));
      }
      switch (aliasKeyword.Kind())
      {
        case SyntaxKind.AliasKeyword:
          break;
        default:
          throw new ArgumentException(nameof(aliasKeyword));
      }
      switch (identifier.Kind())
      {
        case SyntaxKind.IdentifierToken:
          break;
        default:
          throw new ArgumentException(nameof(identifier));
      }
      switch (semicolonToken.Kind())
      {
        case SyntaxKind.SemicolonToken:
          break;
        default:
          throw new ArgumentException(nameof(semicolonToken));
      }
      return (ExternAliasDirectiveSyntax)Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SyntaxFactory.ExternAliasDirective((Syntax.InternalSyntax.SyntaxToken)externKeyword.Node, (Syntax.InternalSyntax.SyntaxToken)aliasKeyword.Node, (Syntax.InternalSyntax.SyntaxToken)identifier.Node, (Syntax.InternalSyntax.SyntaxToken)semicolonToken.Node).CreateRed();
    }


    /// <summary>Creates a new ExternAliasDirectiveSyntax instance.</summary>
    public static ExternAliasDirectiveSyntax ExternAliasDirective(SyntaxToken identifier)
    {
      return SyntaxFactory.ExternAliasDirective(SyntaxFactory.Token(SyntaxKind.ExternKeyword), SyntaxFactory.Token(SyntaxKind.AliasKeyword), identifier, SyntaxFactory.Token(SyntaxKind.SemicolonToken));
    }

    /// <summary>Creates a new ExternAliasDirectiveSyntax instance.</summary>
    public static ExternAliasDirectiveSyntax ExternAliasDirective(string identifier)
    {
      return SyntaxFactory.ExternAliasDirective(SyntaxFactory.Token(SyntaxKind.ExternKeyword), SyntaxFactory.Token(SyntaxKind.AliasKeyword), SyntaxFactory.Identifier(identifier), SyntaxFactory.Token(SyntaxKind.SemicolonToken));
    }

    /// <summary>Creates a new UsingDirectiveSyntax instance.</summary>
    public static UsingDirectiveSyntax UsingDirective(SyntaxToken usingKeyword, SyntaxToken staticKeyword, NameEqualsSyntax alias, NameSyntax name, SyntaxToken semicolonToken)
    {
      switch (usingKeyword.Kind())
      {
        case SyntaxKind.UsingKeyword:
          break;
        default:
          throw new ArgumentException(nameof(usingKeyword));
      }
      if (name == null)
        throw new ArgumentNullException(nameof(name));
      switch (semicolonToken.Kind())
      {
        case SyntaxKind.SemicolonToken:
          break;
        default:
          throw new ArgumentException(nameof(semicolonToken));
      }
      return (UsingDirectiveSyntax)Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SyntaxFactory.UsingDirective((Syntax.InternalSyntax.SyntaxToken)usingKeyword.Node, (Syntax.InternalSyntax.SyntaxToken)staticKeyword.Node, alias == null ? null : (Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.NameEqualsSyntax)alias.Green, name == null ? null : (Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.NameSyntax)name.Green, (Syntax.InternalSyntax.SyntaxToken)semicolonToken.Node).CreateRed();
    }


    /// <summary>Creates a new UsingDirectiveSyntax instance.</summary>
    public static UsingDirectiveSyntax UsingDirective(SyntaxToken staticKeyword, NameEqualsSyntax alias, NameSyntax name)
    {
      return SyntaxFactory.UsingDirective(SyntaxFactory.Token(SyntaxKind.UsingKeyword), staticKeyword, alias, name, SyntaxFactory.Token(SyntaxKind.SemicolonToken));
    }

    /// <summary>Creates a new UsingDirectiveSyntax instance.</summary>
    public static UsingDirectiveSyntax UsingDirective(NameSyntax name)
    {
      return SyntaxFactory.UsingDirective(SyntaxFactory.Token(SyntaxKind.UsingKeyword), default(SyntaxToken), default(NameEqualsSyntax), name, SyntaxFactory.Token(SyntaxKind.SemicolonToken));
    }

    /// <summary>Creates a new NamespaceDeclarationSyntax instance.</summary>
    public static NamespaceDeclarationSyntax NamespaceDeclaration(SyntaxList<AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, SyntaxToken namespaceKeyword, NameSyntax name, SyntaxToken openBraceToken, SyntaxList<ExternAliasDirectiveSyntax> externs, SyntaxList<UsingDirectiveSyntax> usings, SyntaxList<MemberDeclarationSyntax> members, SyntaxToken closeBraceToken, SyntaxToken semicolonToken)
    {
      switch (namespaceKeyword.Kind())
      {
        case SyntaxKind.NamespaceKeyword:
          break;
        default:
          throw new ArgumentException(nameof(namespaceKeyword));
      }
      if (name == null)
        throw new ArgumentNullException(nameof(name));
      switch (openBraceToken.Kind())
      {
        case SyntaxKind.OpenBraceToken:
          break;
        default:
          throw new ArgumentException(nameof(openBraceToken));
      }
      switch (closeBraceToken.Kind())
      {
        case SyntaxKind.CloseBraceToken:
          break;
        default:
          throw new ArgumentException(nameof(closeBraceToken));
      }
      switch (semicolonToken.Kind())
      {
        case SyntaxKind.SemicolonToken:
        case SyntaxKind.None:
          break;
        default:
          throw new ArgumentException(nameof(semicolonToken));
      }
      return (NamespaceDeclarationSyntax)Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SyntaxFactory.NamespaceDeclaration(attributeLists.Node.ToGreenList<Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.AttributeListSyntax>(), modifiers.Node.ToGreenList<Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SyntaxToken>(), (Syntax.InternalSyntax.SyntaxToken)namespaceKeyword.Node, name == null ? null : (Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.NameSyntax)name.Green, (Syntax.InternalSyntax.SyntaxToken)openBraceToken.Node, externs.Node.ToGreenList<Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.ExternAliasDirectiveSyntax>(), usings.Node.ToGreenList<Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.UsingDirectiveSyntax>(), members.Node.ToGreenList<Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.MemberDeclarationSyntax>(), (Syntax.InternalSyntax.SyntaxToken)closeBraceToken.Node, (Syntax.InternalSyntax.SyntaxToken)semicolonToken.Node).CreateRed();
    }


    /// <summary>Creates a new NamespaceDeclarationSyntax instance.</summary>
    public static NamespaceDeclarationSyntax NamespaceDeclaration(SyntaxList<AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, NameSyntax name, SyntaxList<ExternAliasDirectiveSyntax> externs, SyntaxList<UsingDirectiveSyntax> usings, SyntaxList<MemberDeclarationSyntax> members)
    {
      return SyntaxFactory.NamespaceDeclaration(attributeLists, modifiers, SyntaxFactory.Token(SyntaxKind.NamespaceKeyword), name, SyntaxFactory.Token(SyntaxKind.OpenBraceToken), externs, usings, members, SyntaxFactory.Token(SyntaxKind.CloseBraceToken), default(SyntaxToken));
    }

    /// <summary>Creates a new NamespaceDeclarationSyntax instance.</summary>
    public static NamespaceDeclarationSyntax NamespaceDeclaration(NameSyntax name)
    {
      return SyntaxFactory.NamespaceDeclaration(default(SyntaxList<AttributeListSyntax>), default(SyntaxTokenList), SyntaxFactory.Token(SyntaxKind.NamespaceKeyword), name, SyntaxFactory.Token(SyntaxKind.OpenBraceToken), default(SyntaxList<ExternAliasDirectiveSyntax>), default(SyntaxList<UsingDirectiveSyntax>), default(SyntaxList<MemberDeclarationSyntax>), SyntaxFactory.Token(SyntaxKind.CloseBraceToken), default(SyntaxToken));
    }

    /// <summary>Creates a new AttributeListSyntax instance.</summary>
    public static AttributeListSyntax AttributeList(SyntaxToken openBracketToken, AttributeTargetSpecifierSyntax target, SeparatedSyntaxList<AttributeSyntax> attributes, SyntaxToken closeBracketToken)
    {
      switch (openBracketToken.Kind())
      {
        case SyntaxKind.OpenBracketToken:
          break;
        default:
          throw new ArgumentException(nameof(openBracketToken));
      }
      switch (closeBracketToken.Kind())
      {
        case SyntaxKind.CloseBracketToken:
          break;
        default:
          throw new ArgumentException(nameof(closeBracketToken));
      }
      return (AttributeListSyntax)Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SyntaxFactory.AttributeList((Syntax.InternalSyntax.SyntaxToken)openBracketToken.Node, target == null ? null : (Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.AttributeTargetSpecifierSyntax)target.Green, attributes.Node.ToGreenSeparatedList<Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.AttributeSyntax>(), (Syntax.InternalSyntax.SyntaxToken)closeBracketToken.Node).CreateRed();
    }


    /// <summary>Creates a new AttributeListSyntax instance.</summary>
    public static AttributeListSyntax AttributeList(AttributeTargetSpecifierSyntax target, SeparatedSyntaxList<AttributeSyntax> attributes)
    {
      return SyntaxFactory.AttributeList(SyntaxFactory.Token(SyntaxKind.OpenBracketToken), target, attributes, SyntaxFactory.Token(SyntaxKind.CloseBracketToken));
    }

    /// <summary>Creates a new AttributeListSyntax instance.</summary>
    public static AttributeListSyntax AttributeList(SeparatedSyntaxList<AttributeSyntax> attributes = default(SeparatedSyntaxList<AttributeSyntax>))
    {
      return SyntaxFactory.AttributeList(SyntaxFactory.Token(SyntaxKind.OpenBracketToken), default(AttributeTargetSpecifierSyntax), attributes, SyntaxFactory.Token(SyntaxKind.CloseBracketToken));
    }

    /// <summary>Creates a new AttributeTargetSpecifierSyntax instance.</summary>
    public static AttributeTargetSpecifierSyntax AttributeTargetSpecifier(SyntaxToken identifier, SyntaxToken colonToken)
    {
      switch (colonToken.Kind())
      {
        case SyntaxKind.ColonToken:
          break;
        default:
          throw new ArgumentException(nameof(colonToken));
      }
      return (AttributeTargetSpecifierSyntax)Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SyntaxFactory.AttributeTargetSpecifier((Syntax.InternalSyntax.SyntaxToken)identifier.Node, (Syntax.InternalSyntax.SyntaxToken)colonToken.Node).CreateRed();
    }


    /// <summary>Creates a new AttributeTargetSpecifierSyntax instance.</summary>
    public static AttributeTargetSpecifierSyntax AttributeTargetSpecifier(SyntaxToken identifier)
    {
      return SyntaxFactory.AttributeTargetSpecifier(identifier, SyntaxFactory.Token(SyntaxKind.ColonToken));
    }

    /// <summary>Creates a new AttributeSyntax instance.</summary>
    public static AttributeSyntax Attribute(NameSyntax name, AttributeArgumentListSyntax argumentList)
    {
      if (name == null)
        throw new ArgumentNullException(nameof(name));
      return (AttributeSyntax)Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SyntaxFactory.Attribute(name == null ? null : (Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.NameSyntax)name.Green, argumentList == null ? null : (Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.AttributeArgumentListSyntax)argumentList.Green).CreateRed();
    }


    /// <summary>Creates a new AttributeSyntax instance.</summary>
    public static AttributeSyntax Attribute(NameSyntax name)
    {
      return SyntaxFactory.Attribute(name, default(AttributeArgumentListSyntax));
    }

    /// <summary>Creates a new AttributeArgumentListSyntax instance.</summary>
    public static AttributeArgumentListSyntax AttributeArgumentList(SyntaxToken openParenToken, SeparatedSyntaxList<AttributeArgumentSyntax> arguments, SyntaxToken closeParenToken)
    {
      switch (openParenToken.Kind())
      {
        case SyntaxKind.OpenParenToken:
          break;
        default:
          throw new ArgumentException(nameof(openParenToken));
      }
      switch (closeParenToken.Kind())
      {
        case SyntaxKind.CloseParenToken:
          break;
        default:
          throw new ArgumentException(nameof(closeParenToken));
      }
      return (AttributeArgumentListSyntax)Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SyntaxFactory.AttributeArgumentList((Syntax.InternalSyntax.SyntaxToken)openParenToken.Node, arguments.Node.ToGreenSeparatedList<Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.AttributeArgumentSyntax>(), (Syntax.InternalSyntax.SyntaxToken)closeParenToken.Node).CreateRed();
    }


    /// <summary>Creates a new AttributeArgumentListSyntax instance.</summary>
    public static AttributeArgumentListSyntax AttributeArgumentList(SeparatedSyntaxList<AttributeArgumentSyntax> arguments = default(SeparatedSyntaxList<AttributeArgumentSyntax>))
    {
      return SyntaxFactory.AttributeArgumentList(SyntaxFactory.Token(SyntaxKind.OpenParenToken), arguments, SyntaxFactory.Token(SyntaxKind.CloseParenToken));
    }

    /// <summary>Creates a new AttributeArgumentSyntax instance.</summary>
    public static AttributeArgumentSyntax AttributeArgument(NameEqualsSyntax nameEquals, NameColonSyntax nameColon, ExpressionSyntax expression)
    {
      if (expression == null)
        throw new ArgumentNullException(nameof(expression));
      return (AttributeArgumentSyntax)Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SyntaxFactory.AttributeArgument(nameEquals == null ? null : (Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.NameEqualsSyntax)nameEquals.Green, nameColon == null ? null : (Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.NameColonSyntax)nameColon.Green, expression == null ? null : (Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.ExpressionSyntax)expression.Green).CreateRed();
    }


    /// <summary>Creates a new AttributeArgumentSyntax instance.</summary>
    public static AttributeArgumentSyntax AttributeArgument(ExpressionSyntax expression)
    {
      return SyntaxFactory.AttributeArgument(default(NameEqualsSyntax), default(NameColonSyntax), expression);
    }

    /// <summary>Creates a new NameEqualsSyntax instance.</summary>
    public static NameEqualsSyntax NameEquals(IdentifierNameSyntax name, SyntaxToken equalsToken)
    {
      if (name == null)
        throw new ArgumentNullException(nameof(name));
      switch (equalsToken.Kind())
      {
        case SyntaxKind.EqualsToken:
          break;
        default:
          throw new ArgumentException(nameof(equalsToken));
      }
      return (NameEqualsSyntax)Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SyntaxFactory.NameEquals(name == null ? null : (Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.IdentifierNameSyntax)name.Green, (Syntax.InternalSyntax.SyntaxToken)equalsToken.Node).CreateRed();
    }


    /// <summary>Creates a new NameEqualsSyntax instance.</summary>
    public static NameEqualsSyntax NameEquals(IdentifierNameSyntax name)
    {
      return SyntaxFactory.NameEquals(name, SyntaxFactory.Token(SyntaxKind.EqualsToken));
    }

    /// <summary>Creates a new NameEqualsSyntax instance.</summary>
    public static NameEqualsSyntax NameEquals(string name)
    {
      return SyntaxFactory.NameEquals(SyntaxFactory.IdentifierName(name), SyntaxFactory.Token(SyntaxKind.EqualsToken));
    }

    /// <summary>Creates a new TypeParameterListSyntax instance.</summary>
    public static TypeParameterListSyntax TypeParameterList(SyntaxToken lessThanToken, SeparatedSyntaxList<TypeParameterSyntax> parameters, SyntaxToken greaterThanToken)
    {
      switch (lessThanToken.Kind())
      {
        case SyntaxKind.LessThanToken:
          break;
        default:
          throw new ArgumentException(nameof(lessThanToken));
      }
      switch (greaterThanToken.Kind())
      {
        case SyntaxKind.GreaterThanToken:
          break;
        default:
          throw new ArgumentException(nameof(greaterThanToken));
      }
      return (TypeParameterListSyntax)Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SyntaxFactory.TypeParameterList((Syntax.InternalSyntax.SyntaxToken)lessThanToken.Node, parameters.Node.ToGreenSeparatedList<Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.TypeParameterSyntax>(), (Syntax.InternalSyntax.SyntaxToken)greaterThanToken.Node).CreateRed();
    }


    /// <summary>Creates a new TypeParameterListSyntax instance.</summary>
    public static TypeParameterListSyntax TypeParameterList(SeparatedSyntaxList<TypeParameterSyntax> parameters = default(SeparatedSyntaxList<TypeParameterSyntax>))
    {
      return SyntaxFactory.TypeParameterList(SyntaxFactory.Token(SyntaxKind.LessThanToken), parameters, SyntaxFactory.Token(SyntaxKind.GreaterThanToken));
    }

    /// <summary>Creates a new TypeParameterSyntax instance.</summary>
    public static TypeParameterSyntax TypeParameter(SyntaxList<AttributeListSyntax> attributeLists, SyntaxToken varianceKeyword, SyntaxToken identifier)
    {
      switch (varianceKeyword.Kind())
      {
        case SyntaxKind.InKeyword:
        case SyntaxKind.OutKeyword:
        case SyntaxKind.None:
          break;
        default:
          throw new ArgumentException(nameof(varianceKeyword));
      }
      switch (identifier.Kind())
      {
        case SyntaxKind.IdentifierToken:
          break;
        default:
          throw new ArgumentException(nameof(identifier));
      }
      return (TypeParameterSyntax)Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SyntaxFactory.TypeParameter(attributeLists.Node.ToGreenList<Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.AttributeListSyntax>(), (Syntax.InternalSyntax.SyntaxToken)varianceKeyword.Node, (Syntax.InternalSyntax.SyntaxToken)identifier.Node).CreateRed();
    }


    /// <summary>Creates a new TypeParameterSyntax instance.</summary>
    public static TypeParameterSyntax TypeParameter(SyntaxToken identifier)
    {
      return SyntaxFactory.TypeParameter(default(SyntaxList<AttributeListSyntax>), default(SyntaxToken), identifier);
    }

    /// <summary>Creates a new TypeParameterSyntax instance.</summary>
    public static TypeParameterSyntax TypeParameter(string identifier)
    {
      return SyntaxFactory.TypeParameter(default(SyntaxList<AttributeListSyntax>), default(SyntaxToken), SyntaxFactory.Identifier(identifier));
    }

    /// <summary>Creates a new ClassDeclarationSyntax instance.</summary>
    public static ClassDeclarationSyntax ClassDeclaration(SyntaxList<AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, SyntaxToken keyword, SyntaxToken identifier, TypeParameterListSyntax typeParameterList, BaseListSyntax baseList, SyntaxList<TypeParameterConstraintClauseSyntax> constraintClauses, SyntaxToken openBraceToken, SyntaxList<MemberDeclarationSyntax> members, SyntaxToken closeBraceToken, SyntaxToken semicolonToken)
    {
      switch (keyword.Kind())
      {
        case SyntaxKind.ClassKeyword:
          break;
        default:
          throw new ArgumentException(nameof(keyword));
      }
      switch (identifier.Kind())
      {
        case SyntaxKind.IdentifierToken:
          break;
        default:
          throw new ArgumentException(nameof(identifier));
      }
      switch (openBraceToken.Kind())
      {
        case SyntaxKind.OpenBraceToken:
          break;
        default:
          throw new ArgumentException(nameof(openBraceToken));
      }
      switch (closeBraceToken.Kind())
      {
        case SyntaxKind.CloseBraceToken:
          break;
        default:
          throw new ArgumentException(nameof(closeBraceToken));
      }
      switch (semicolonToken.Kind())
      {
        case SyntaxKind.SemicolonToken:
        case SyntaxKind.None:
          break;
        default:
          throw new ArgumentException(nameof(semicolonToken));
      }
      return (ClassDeclarationSyntax)Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SyntaxFactory.ClassDeclaration(attributeLists.Node.ToGreenList<Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.AttributeListSyntax>(), modifiers.Node.ToGreenList<Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SyntaxToken>(), (Syntax.InternalSyntax.SyntaxToken)keyword.Node, (Syntax.InternalSyntax.SyntaxToken)identifier.Node, typeParameterList == null ? null : (Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.TypeParameterListSyntax)typeParameterList.Green, baseList == null ? null : (Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.BaseListSyntax)baseList.Green, constraintClauses.Node.ToGreenList<Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.TypeParameterConstraintClauseSyntax>(), (Syntax.InternalSyntax.SyntaxToken)openBraceToken.Node, members.Node.ToGreenList<Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.MemberDeclarationSyntax>(), (Syntax.InternalSyntax.SyntaxToken)closeBraceToken.Node, (Syntax.InternalSyntax.SyntaxToken)semicolonToken.Node).CreateRed();
    }


    /// <summary>Creates a new ClassDeclarationSyntax instance.</summary>
    public static ClassDeclarationSyntax ClassDeclaration(SyntaxList<AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, SyntaxToken identifier, TypeParameterListSyntax typeParameterList, BaseListSyntax baseList, SyntaxList<TypeParameterConstraintClauseSyntax> constraintClauses, SyntaxList<MemberDeclarationSyntax> members)
    {
      return SyntaxFactory.ClassDeclaration(attributeLists, modifiers, SyntaxFactory.Token(SyntaxKind.ClassKeyword), identifier, typeParameterList, baseList, constraintClauses, SyntaxFactory.Token(SyntaxKind.OpenBraceToken), members, SyntaxFactory.Token(SyntaxKind.CloseBraceToken), default(SyntaxToken));
    }

    /// <summary>Creates a new ClassDeclarationSyntax instance.</summary>
    public static ClassDeclarationSyntax ClassDeclaration(SyntaxToken identifier)
    {
      return SyntaxFactory.ClassDeclaration(default(SyntaxList<AttributeListSyntax>), default(SyntaxTokenList), SyntaxFactory.Token(SyntaxKind.ClassKeyword), identifier, default(TypeParameterListSyntax), default(BaseListSyntax), default(SyntaxList<TypeParameterConstraintClauseSyntax>), SyntaxFactory.Token(SyntaxKind.OpenBraceToken), default(SyntaxList<MemberDeclarationSyntax>), SyntaxFactory.Token(SyntaxKind.CloseBraceToken), default(SyntaxToken));
    }

    /// <summary>Creates a new ClassDeclarationSyntax instance.</summary>
    public static ClassDeclarationSyntax ClassDeclaration(string identifier)
    {
      return SyntaxFactory.ClassDeclaration(default(SyntaxList<AttributeListSyntax>), default(SyntaxTokenList), SyntaxFactory.Token(SyntaxKind.ClassKeyword), SyntaxFactory.Identifier(identifier), default(TypeParameterListSyntax), default(BaseListSyntax), default(SyntaxList<TypeParameterConstraintClauseSyntax>), SyntaxFactory.Token(SyntaxKind.OpenBraceToken), default(SyntaxList<MemberDeclarationSyntax>), SyntaxFactory.Token(SyntaxKind.CloseBraceToken), default(SyntaxToken));
    }

    /// <summary>Creates a new StructDeclarationSyntax instance.</summary>
    public static StructDeclarationSyntax StructDeclaration(SyntaxList<AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, SyntaxToken keyword, SyntaxToken identifier, TypeParameterListSyntax typeParameterList, BaseListSyntax baseList, SyntaxList<TypeParameterConstraintClauseSyntax> constraintClauses, SyntaxToken openBraceToken, SyntaxList<MemberDeclarationSyntax> members, SyntaxToken closeBraceToken, SyntaxToken semicolonToken)
    {
      switch (keyword.Kind())
      {
        case SyntaxKind.StructKeyword:
          break;
        default:
          throw new ArgumentException(nameof(keyword));
      }
      switch (identifier.Kind())
      {
        case SyntaxKind.IdentifierToken:
          break;
        default:
          throw new ArgumentException(nameof(identifier));
      }
      switch (openBraceToken.Kind())
      {
        case SyntaxKind.OpenBraceToken:
          break;
        default:
          throw new ArgumentException(nameof(openBraceToken));
      }
      switch (closeBraceToken.Kind())
      {
        case SyntaxKind.CloseBraceToken:
          break;
        default:
          throw new ArgumentException(nameof(closeBraceToken));
      }
      switch (semicolonToken.Kind())
      {
        case SyntaxKind.SemicolonToken:
        case SyntaxKind.None:
          break;
        default:
          throw new ArgumentException(nameof(semicolonToken));
      }
      return (StructDeclarationSyntax)Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SyntaxFactory.StructDeclaration(attributeLists.Node.ToGreenList<Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.AttributeListSyntax>(), modifiers.Node.ToGreenList<Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SyntaxToken>(), (Syntax.InternalSyntax.SyntaxToken)keyword.Node, (Syntax.InternalSyntax.SyntaxToken)identifier.Node, typeParameterList == null ? null : (Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.TypeParameterListSyntax)typeParameterList.Green, baseList == null ? null : (Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.BaseListSyntax)baseList.Green, constraintClauses.Node.ToGreenList<Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.TypeParameterConstraintClauseSyntax>(), (Syntax.InternalSyntax.SyntaxToken)openBraceToken.Node, members.Node.ToGreenList<Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.MemberDeclarationSyntax>(), (Syntax.InternalSyntax.SyntaxToken)closeBraceToken.Node, (Syntax.InternalSyntax.SyntaxToken)semicolonToken.Node).CreateRed();
    }


    /// <summary>Creates a new StructDeclarationSyntax instance.</summary>
    public static StructDeclarationSyntax StructDeclaration(SyntaxList<AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, SyntaxToken identifier, TypeParameterListSyntax typeParameterList, BaseListSyntax baseList, SyntaxList<TypeParameterConstraintClauseSyntax> constraintClauses, SyntaxList<MemberDeclarationSyntax> members)
    {
      return SyntaxFactory.StructDeclaration(attributeLists, modifiers, SyntaxFactory.Token(SyntaxKind.StructKeyword), identifier, typeParameterList, baseList, constraintClauses, SyntaxFactory.Token(SyntaxKind.OpenBraceToken), members, SyntaxFactory.Token(SyntaxKind.CloseBraceToken), default(SyntaxToken));
    }

    /// <summary>Creates a new StructDeclarationSyntax instance.</summary>
    public static StructDeclarationSyntax StructDeclaration(SyntaxToken identifier)
    {
      return SyntaxFactory.StructDeclaration(default(SyntaxList<AttributeListSyntax>), default(SyntaxTokenList), SyntaxFactory.Token(SyntaxKind.StructKeyword), identifier, default(TypeParameterListSyntax), default(BaseListSyntax), default(SyntaxList<TypeParameterConstraintClauseSyntax>), SyntaxFactory.Token(SyntaxKind.OpenBraceToken), default(SyntaxList<MemberDeclarationSyntax>), SyntaxFactory.Token(SyntaxKind.CloseBraceToken), default(SyntaxToken));
    }

    /// <summary>Creates a new StructDeclarationSyntax instance.</summary>
    public static StructDeclarationSyntax StructDeclaration(string identifier)
    {
      return SyntaxFactory.StructDeclaration(default(SyntaxList<AttributeListSyntax>), default(SyntaxTokenList), SyntaxFactory.Token(SyntaxKind.StructKeyword), SyntaxFactory.Identifier(identifier), default(TypeParameterListSyntax), default(BaseListSyntax), default(SyntaxList<TypeParameterConstraintClauseSyntax>), SyntaxFactory.Token(SyntaxKind.OpenBraceToken), default(SyntaxList<MemberDeclarationSyntax>), SyntaxFactory.Token(SyntaxKind.CloseBraceToken), default(SyntaxToken));
    }

    /// <summary>Creates a new InterfaceDeclarationSyntax instance.</summary>
    public static InterfaceDeclarationSyntax InterfaceDeclaration(SyntaxList<AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, SyntaxToken keyword, SyntaxToken identifier, TypeParameterListSyntax typeParameterList, BaseListSyntax baseList, SyntaxList<TypeParameterConstraintClauseSyntax> constraintClauses, SyntaxToken openBraceToken, SyntaxList<MemberDeclarationSyntax> members, SyntaxToken closeBraceToken, SyntaxToken semicolonToken)
    {
      switch (keyword.Kind())
      {
        case SyntaxKind.InterfaceKeyword:
          break;
        default:
          throw new ArgumentException(nameof(keyword));
      }
      switch (identifier.Kind())
      {
        case SyntaxKind.IdentifierToken:
          break;
        default:
          throw new ArgumentException(nameof(identifier));
      }
      switch (openBraceToken.Kind())
      {
        case SyntaxKind.OpenBraceToken:
          break;
        default:
          throw new ArgumentException(nameof(openBraceToken));
      }
      switch (closeBraceToken.Kind())
      {
        case SyntaxKind.CloseBraceToken:
          break;
        default:
          throw new ArgumentException(nameof(closeBraceToken));
      }
      switch (semicolonToken.Kind())
      {
        case SyntaxKind.SemicolonToken:
        case SyntaxKind.None:
          break;
        default:
          throw new ArgumentException(nameof(semicolonToken));
      }
      return (InterfaceDeclarationSyntax)Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SyntaxFactory.InterfaceDeclaration(attributeLists.Node.ToGreenList<Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.AttributeListSyntax>(), modifiers.Node.ToGreenList<Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SyntaxToken>(), (Syntax.InternalSyntax.SyntaxToken)keyword.Node, (Syntax.InternalSyntax.SyntaxToken)identifier.Node, typeParameterList == null ? null : (Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.TypeParameterListSyntax)typeParameterList.Green, baseList == null ? null : (Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.BaseListSyntax)baseList.Green, constraintClauses.Node.ToGreenList<Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.TypeParameterConstraintClauseSyntax>(), (Syntax.InternalSyntax.SyntaxToken)openBraceToken.Node, members.Node.ToGreenList<Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.MemberDeclarationSyntax>(), (Syntax.InternalSyntax.SyntaxToken)closeBraceToken.Node, (Syntax.InternalSyntax.SyntaxToken)semicolonToken.Node).CreateRed();
    }


    /// <summary>Creates a new InterfaceDeclarationSyntax instance.</summary>
    public static InterfaceDeclarationSyntax InterfaceDeclaration(SyntaxList<AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, SyntaxToken identifier, TypeParameterListSyntax typeParameterList, BaseListSyntax baseList, SyntaxList<TypeParameterConstraintClauseSyntax> constraintClauses, SyntaxList<MemberDeclarationSyntax> members)
    {
      return SyntaxFactory.InterfaceDeclaration(attributeLists, modifiers, SyntaxFactory.Token(SyntaxKind.InterfaceKeyword), identifier, typeParameterList, baseList, constraintClauses, SyntaxFactory.Token(SyntaxKind.OpenBraceToken), members, SyntaxFactory.Token(SyntaxKind.CloseBraceToken), default(SyntaxToken));
    }

    /// <summary>Creates a new InterfaceDeclarationSyntax instance.</summary>
    public static InterfaceDeclarationSyntax InterfaceDeclaration(SyntaxToken identifier)
    {
      return SyntaxFactory.InterfaceDeclaration(default(SyntaxList<AttributeListSyntax>), default(SyntaxTokenList), SyntaxFactory.Token(SyntaxKind.InterfaceKeyword), identifier, default(TypeParameterListSyntax), default(BaseListSyntax), default(SyntaxList<TypeParameterConstraintClauseSyntax>), SyntaxFactory.Token(SyntaxKind.OpenBraceToken), default(SyntaxList<MemberDeclarationSyntax>), SyntaxFactory.Token(SyntaxKind.CloseBraceToken), default(SyntaxToken));
    }

    /// <summary>Creates a new InterfaceDeclarationSyntax instance.</summary>
    public static InterfaceDeclarationSyntax InterfaceDeclaration(string identifier)
    {
      return SyntaxFactory.InterfaceDeclaration(default(SyntaxList<AttributeListSyntax>), default(SyntaxTokenList), SyntaxFactory.Token(SyntaxKind.InterfaceKeyword), SyntaxFactory.Identifier(identifier), default(TypeParameterListSyntax), default(BaseListSyntax), default(SyntaxList<TypeParameterConstraintClauseSyntax>), SyntaxFactory.Token(SyntaxKind.OpenBraceToken), default(SyntaxList<MemberDeclarationSyntax>), SyntaxFactory.Token(SyntaxKind.CloseBraceToken), default(SyntaxToken));
    }

    /// <summary>Creates a new EnumDeclarationSyntax instance.</summary>
    public static EnumDeclarationSyntax EnumDeclaration(SyntaxList<AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, SyntaxToken enumKeyword, SyntaxToken identifier, BaseListSyntax baseList, SyntaxToken openBraceToken, SeparatedSyntaxList<EnumMemberDeclarationSyntax> members, SyntaxToken closeBraceToken, SyntaxToken semicolonToken)
    {
      switch (enumKeyword.Kind())
      {
        case SyntaxKind.EnumKeyword:
          break;
        default:
          throw new ArgumentException(nameof(enumKeyword));
      }
      switch (identifier.Kind())
      {
        case SyntaxKind.IdentifierToken:
          break;
        default:
          throw new ArgumentException(nameof(identifier));
      }
      switch (openBraceToken.Kind())
      {
        case SyntaxKind.OpenBraceToken:
          break;
        default:
          throw new ArgumentException(nameof(openBraceToken));
      }
      switch (closeBraceToken.Kind())
      {
        case SyntaxKind.CloseBraceToken:
          break;
        default:
          throw new ArgumentException(nameof(closeBraceToken));
      }
      switch (semicolonToken.Kind())
      {
        case SyntaxKind.SemicolonToken:
        case SyntaxKind.None:
          break;
        default:
          throw new ArgumentException(nameof(semicolonToken));
      }
      return (EnumDeclarationSyntax)Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SyntaxFactory.EnumDeclaration(attributeLists.Node.ToGreenList<Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.AttributeListSyntax>(), modifiers.Node.ToGreenList<Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SyntaxToken>(), (Syntax.InternalSyntax.SyntaxToken)enumKeyword.Node, (Syntax.InternalSyntax.SyntaxToken)identifier.Node, baseList == null ? null : (Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.BaseListSyntax)baseList.Green, (Syntax.InternalSyntax.SyntaxToken)openBraceToken.Node, members.Node.ToGreenSeparatedList<Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.EnumMemberDeclarationSyntax>(), (Syntax.InternalSyntax.SyntaxToken)closeBraceToken.Node, (Syntax.InternalSyntax.SyntaxToken)semicolonToken.Node).CreateRed();
    }


    /// <summary>Creates a new EnumDeclarationSyntax instance.</summary>
    public static EnumDeclarationSyntax EnumDeclaration(SyntaxList<AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, SyntaxToken identifier, BaseListSyntax baseList, SeparatedSyntaxList<EnumMemberDeclarationSyntax> members)
    {
      return SyntaxFactory.EnumDeclaration(attributeLists, modifiers, SyntaxFactory.Token(SyntaxKind.EnumKeyword), identifier, baseList, SyntaxFactory.Token(SyntaxKind.OpenBraceToken), members, SyntaxFactory.Token(SyntaxKind.CloseBraceToken), default(SyntaxToken));
    }

    /// <summary>Creates a new EnumDeclarationSyntax instance.</summary>
    public static EnumDeclarationSyntax EnumDeclaration(SyntaxToken identifier)
    {
      return SyntaxFactory.EnumDeclaration(default(SyntaxList<AttributeListSyntax>), default(SyntaxTokenList), SyntaxFactory.Token(SyntaxKind.EnumKeyword), identifier, default(BaseListSyntax), SyntaxFactory.Token(SyntaxKind.OpenBraceToken), default(SeparatedSyntaxList<EnumMemberDeclarationSyntax>), SyntaxFactory.Token(SyntaxKind.CloseBraceToken), default(SyntaxToken));
    }

    /// <summary>Creates a new EnumDeclarationSyntax instance.</summary>
    public static EnumDeclarationSyntax EnumDeclaration(string identifier)
    {
      return SyntaxFactory.EnumDeclaration(default(SyntaxList<AttributeListSyntax>), default(SyntaxTokenList), SyntaxFactory.Token(SyntaxKind.EnumKeyword), SyntaxFactory.Identifier(identifier), default(BaseListSyntax), SyntaxFactory.Token(SyntaxKind.OpenBraceToken), default(SeparatedSyntaxList<EnumMemberDeclarationSyntax>), SyntaxFactory.Token(SyntaxKind.CloseBraceToken), default(SyntaxToken));
    }

    /// <summary>Creates a new DelegateDeclarationSyntax instance.</summary>
    public static DelegateDeclarationSyntax DelegateDeclaration(SyntaxList<AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, SyntaxToken delegateKeyword, TypeSyntax returnType, SyntaxToken identifier, TypeParameterListSyntax typeParameterList, ParameterListSyntax parameterList, SyntaxList<TypeParameterConstraintClauseSyntax> constraintClauses, SyntaxToken semicolonToken)
    {
      switch (delegateKeyword.Kind())
      {
        case SyntaxKind.DelegateKeyword:
          break;
        default:
          throw new ArgumentException(nameof(delegateKeyword));
      }
      if (returnType == null)
        throw new ArgumentNullException(nameof(returnType));
      switch (identifier.Kind())
      {
        case SyntaxKind.IdentifierToken:
          break;
        default:
          throw new ArgumentException(nameof(identifier));
      }
      if (parameterList == null)
        throw new ArgumentNullException(nameof(parameterList));
      switch (semicolonToken.Kind())
      {
        case SyntaxKind.SemicolonToken:
          break;
        default:
          throw new ArgumentException(nameof(semicolonToken));
      }
      return (DelegateDeclarationSyntax)Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SyntaxFactory.DelegateDeclaration(attributeLists.Node.ToGreenList<Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.AttributeListSyntax>(), modifiers.Node.ToGreenList<Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SyntaxToken>(), (Syntax.InternalSyntax.SyntaxToken)delegateKeyword.Node, returnType == null ? null : (Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.TypeSyntax)returnType.Green, (Syntax.InternalSyntax.SyntaxToken)identifier.Node, typeParameterList == null ? null : (Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.TypeParameterListSyntax)typeParameterList.Green, parameterList == null ? null : (Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.ParameterListSyntax)parameterList.Green, constraintClauses.Node.ToGreenList<Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.TypeParameterConstraintClauseSyntax>(), (Syntax.InternalSyntax.SyntaxToken)semicolonToken.Node).CreateRed();
    }


    /// <summary>Creates a new DelegateDeclarationSyntax instance.</summary>
    public static DelegateDeclarationSyntax DelegateDeclaration(SyntaxList<AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, TypeSyntax returnType, SyntaxToken identifier, TypeParameterListSyntax typeParameterList, ParameterListSyntax parameterList, SyntaxList<TypeParameterConstraintClauseSyntax> constraintClauses)
    {
      return SyntaxFactory.DelegateDeclaration(attributeLists, modifiers, SyntaxFactory.Token(SyntaxKind.DelegateKeyword), returnType, identifier, typeParameterList, parameterList, constraintClauses, SyntaxFactory.Token(SyntaxKind.SemicolonToken));
    }

    /// <summary>Creates a new DelegateDeclarationSyntax instance.</summary>
    public static DelegateDeclarationSyntax DelegateDeclaration(TypeSyntax returnType, SyntaxToken identifier)
    {
      return SyntaxFactory.DelegateDeclaration(default(SyntaxList<AttributeListSyntax>), default(SyntaxTokenList), SyntaxFactory.Token(SyntaxKind.DelegateKeyword), returnType, identifier, default(TypeParameterListSyntax), SyntaxFactory.ParameterList(), default(SyntaxList<TypeParameterConstraintClauseSyntax>), SyntaxFactory.Token(SyntaxKind.SemicolonToken));
    }

    /// <summary>Creates a new DelegateDeclarationSyntax instance.</summary>
    public static DelegateDeclarationSyntax DelegateDeclaration(TypeSyntax returnType, string identifier)
    {
      return SyntaxFactory.DelegateDeclaration(default(SyntaxList<AttributeListSyntax>), default(SyntaxTokenList), SyntaxFactory.Token(SyntaxKind.DelegateKeyword), returnType, SyntaxFactory.Identifier(identifier), default(TypeParameterListSyntax), SyntaxFactory.ParameterList(), default(SyntaxList<TypeParameterConstraintClauseSyntax>), SyntaxFactory.Token(SyntaxKind.SemicolonToken));
    }

    /// <summary>Creates a new EnumMemberDeclarationSyntax instance.</summary>
    public static EnumMemberDeclarationSyntax EnumMemberDeclaration(SyntaxList<AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, SyntaxToken identifier, EqualsValueClauseSyntax equalsValue)
    {
      switch (identifier.Kind())
      {
        case SyntaxKind.IdentifierToken:
          break;
        default:
          throw new ArgumentException(nameof(identifier));
      }
      return (EnumMemberDeclarationSyntax)Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SyntaxFactory.EnumMemberDeclaration(attributeLists.Node.ToGreenList<Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.AttributeListSyntax>(), modifiers.Node.ToGreenList<Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SyntaxToken>(), (Syntax.InternalSyntax.SyntaxToken)identifier.Node, equalsValue == null ? null : (Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.EqualsValueClauseSyntax)equalsValue.Green).CreateRed();
    }


    /// <summary>Creates a new EnumMemberDeclarationSyntax instance.</summary>
    public static EnumMemberDeclarationSyntax EnumMemberDeclaration(SyntaxToken identifier)
    {
      return SyntaxFactory.EnumMemberDeclaration(default(SyntaxList<AttributeListSyntax>), default(SyntaxTokenList), identifier, default(EqualsValueClauseSyntax));
    }

    /// <summary>Creates a new EnumMemberDeclarationSyntax instance.</summary>
    public static EnumMemberDeclarationSyntax EnumMemberDeclaration(string identifier)
    {
      return SyntaxFactory.EnumMemberDeclaration(default(SyntaxList<AttributeListSyntax>), default(SyntaxTokenList), SyntaxFactory.Identifier(identifier), default(EqualsValueClauseSyntax));
    }

    /// <summary>Creates a new BaseListSyntax instance.</summary>
    public static BaseListSyntax BaseList(SyntaxToken colonToken, SeparatedSyntaxList<BaseTypeSyntax> types)
    {
      switch (colonToken.Kind())
      {
        case SyntaxKind.ColonToken:
          break;
        default:
          throw new ArgumentException(nameof(colonToken));
      }
      return (BaseListSyntax)Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SyntaxFactory.BaseList((Syntax.InternalSyntax.SyntaxToken)colonToken.Node, types.Node.ToGreenSeparatedList<Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.BaseTypeSyntax>()).CreateRed();
    }


    /// <summary>Creates a new BaseListSyntax instance.</summary>
    public static BaseListSyntax BaseList(SeparatedSyntaxList<BaseTypeSyntax> types = default(SeparatedSyntaxList<BaseTypeSyntax>))
    {
      return SyntaxFactory.BaseList(SyntaxFactory.Token(SyntaxKind.ColonToken), types);
    }

    /// <summary>Creates a new SimpleBaseTypeSyntax instance.</summary>
    public static SimpleBaseTypeSyntax SimpleBaseType(TypeSyntax type)
    {
      if (type == null)
        throw new ArgumentNullException(nameof(type));
      return (SimpleBaseTypeSyntax)Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SyntaxFactory.SimpleBaseType(type == null ? null : (Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.TypeSyntax)type.Green).CreateRed();
    }


    /// <summary>Creates a new TypeParameterConstraintClauseSyntax instance.</summary>
    public static TypeParameterConstraintClauseSyntax TypeParameterConstraintClause(SyntaxToken whereKeyword, IdentifierNameSyntax name, SyntaxToken colonToken, SeparatedSyntaxList<TypeParameterConstraintSyntax> constraints)
    {
      switch (whereKeyword.Kind())
      {
        case SyntaxKind.WhereKeyword:
          break;
        default:
          throw new ArgumentException(nameof(whereKeyword));
      }
      if (name == null)
        throw new ArgumentNullException(nameof(name));
      switch (colonToken.Kind())
      {
        case SyntaxKind.ColonToken:
          break;
        default:
          throw new ArgumentException(nameof(colonToken));
      }
      return (TypeParameterConstraintClauseSyntax)Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SyntaxFactory.TypeParameterConstraintClause((Syntax.InternalSyntax.SyntaxToken)whereKeyword.Node, name == null ? null : (Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.IdentifierNameSyntax)name.Green, (Syntax.InternalSyntax.SyntaxToken)colonToken.Node, constraints.Node.ToGreenSeparatedList<Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.TypeParameterConstraintSyntax>()).CreateRed();
    }


    /// <summary>Creates a new TypeParameterConstraintClauseSyntax instance.</summary>
    public static TypeParameterConstraintClauseSyntax TypeParameterConstraintClause(IdentifierNameSyntax name, SeparatedSyntaxList<TypeParameterConstraintSyntax> constraints)
    {
      return SyntaxFactory.TypeParameterConstraintClause(SyntaxFactory.Token(SyntaxKind.WhereKeyword), name, SyntaxFactory.Token(SyntaxKind.ColonToken), constraints);
    }

    /// <summary>Creates a new TypeParameterConstraintClauseSyntax instance.</summary>
    public static TypeParameterConstraintClauseSyntax TypeParameterConstraintClause(IdentifierNameSyntax name)
    {
      return SyntaxFactory.TypeParameterConstraintClause(SyntaxFactory.Token(SyntaxKind.WhereKeyword), name, SyntaxFactory.Token(SyntaxKind.ColonToken), default(SeparatedSyntaxList<TypeParameterConstraintSyntax>));
    }

    /// <summary>Creates a new TypeParameterConstraintClauseSyntax instance.</summary>
    public static TypeParameterConstraintClauseSyntax TypeParameterConstraintClause(string name)
    {
      return SyntaxFactory.TypeParameterConstraintClause(SyntaxFactory.Token(SyntaxKind.WhereKeyword), SyntaxFactory.IdentifierName(name), SyntaxFactory.Token(SyntaxKind.ColonToken), default(SeparatedSyntaxList<TypeParameterConstraintSyntax>));
    }

    /// <summary>Creates a new ConstructorConstraintSyntax instance.</summary>
    public static ConstructorConstraintSyntax ConstructorConstraint(SyntaxToken newKeyword, SyntaxToken openParenToken, SyntaxToken closeParenToken)
    {
      switch (newKeyword.Kind())
      {
        case SyntaxKind.NewKeyword:
          break;
        default:
          throw new ArgumentException(nameof(newKeyword));
      }
      switch (openParenToken.Kind())
      {
        case SyntaxKind.OpenParenToken:
          break;
        default:
          throw new ArgumentException(nameof(openParenToken));
      }
      switch (closeParenToken.Kind())
      {
        case SyntaxKind.CloseParenToken:
          break;
        default:
          throw new ArgumentException(nameof(closeParenToken));
      }
      return (ConstructorConstraintSyntax)Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SyntaxFactory.ConstructorConstraint((Syntax.InternalSyntax.SyntaxToken)newKeyword.Node, (Syntax.InternalSyntax.SyntaxToken)openParenToken.Node, (Syntax.InternalSyntax.SyntaxToken)closeParenToken.Node).CreateRed();
    }


    /// <summary>Creates a new ConstructorConstraintSyntax instance.</summary>
    public static ConstructorConstraintSyntax ConstructorConstraint()
    {
      return SyntaxFactory.ConstructorConstraint(SyntaxFactory.Token(SyntaxKind.NewKeyword), SyntaxFactory.Token(SyntaxKind.OpenParenToken), SyntaxFactory.Token(SyntaxKind.CloseParenToken));
    }

    /// <summary>Creates a new ClassOrStructConstraintSyntax instance.</summary>
    public static ClassOrStructConstraintSyntax ClassOrStructConstraint(SyntaxKind kind, SyntaxToken classOrStructKeyword, SyntaxToken questionToken)
    {
      switch (kind)
      {
        case SyntaxKind.ClassConstraint:
        case SyntaxKind.StructConstraint:
          break;
        default:
          throw new ArgumentException(nameof(kind));
      }
      switch (classOrStructKeyword.Kind())
      {
        case SyntaxKind.ClassKeyword:
        case SyntaxKind.StructKeyword:
          break;
        default:
          throw new ArgumentException(nameof(classOrStructKeyword));
      }
      switch (questionToken.Kind())
      {
        case SyntaxKind.QuestionToken:
        case SyntaxKind.None:
          break;
        default:
          throw new ArgumentException(nameof(questionToken));
      }
      return (ClassOrStructConstraintSyntax)Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SyntaxFactory.ClassOrStructConstraint(kind, (Syntax.InternalSyntax.SyntaxToken)classOrStructKeyword.Node, (Syntax.InternalSyntax.SyntaxToken)questionToken.Node).CreateRed();
    }


    /// <summary>Creates a new ClassOrStructConstraintSyntax instance.</summary>
    public static ClassOrStructConstraintSyntax ClassOrStructConstraint(SyntaxKind kind)
    {
      return SyntaxFactory.ClassOrStructConstraint(kind, SyntaxFactory.Token(GetClassOrStructConstraintClassOrStructKeywordKind(kind)), default(SyntaxToken));
    }

    private static SyntaxKind GetClassOrStructConstraintClassOrStructKeywordKind(SyntaxKind kind)
    {
      switch (kind)
      {
        case SyntaxKind.ClassConstraint:
          return SyntaxKind.ClassKeyword;
        case SyntaxKind.StructConstraint:
          return SyntaxKind.StructKeyword;
        default:
          throw new ArgumentOutOfRangeException();
      }
    }

    /// <summary>Creates a new TypeConstraintSyntax instance.</summary>
    public static TypeConstraintSyntax TypeConstraint(TypeSyntax type)
    {
      if (type == null)
        throw new ArgumentNullException(nameof(type));
      return (TypeConstraintSyntax)Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SyntaxFactory.TypeConstraint(type == null ? null : (Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.TypeSyntax)type.Green).CreateRed();
    }


    /// <summary>Creates a new FieldDeclarationSyntax instance.</summary>
    public static FieldDeclarationSyntax FieldDeclaration(SyntaxList<AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, VariableDeclarationSyntax declaration, SyntaxToken semicolonToken)
    {
      if (declaration == null)
        throw new ArgumentNullException(nameof(declaration));
      switch (semicolonToken.Kind())
      {
        case SyntaxKind.SemicolonToken:
          break;
        default:
          throw new ArgumentException(nameof(semicolonToken));
      }
      return (FieldDeclarationSyntax)Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SyntaxFactory.FieldDeclaration(attributeLists.Node.ToGreenList<Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.AttributeListSyntax>(), modifiers.Node.ToGreenList<Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SyntaxToken>(), declaration == null ? null : (Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.VariableDeclarationSyntax)declaration.Green, (Syntax.InternalSyntax.SyntaxToken)semicolonToken.Node).CreateRed();
    }


    /// <summary>Creates a new FieldDeclarationSyntax instance.</summary>
    public static FieldDeclarationSyntax FieldDeclaration(SyntaxList<AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, VariableDeclarationSyntax declaration)
    {
      return SyntaxFactory.FieldDeclaration(attributeLists, modifiers, declaration, SyntaxFactory.Token(SyntaxKind.SemicolonToken));
    }

    /// <summary>Creates a new FieldDeclarationSyntax instance.</summary>
    public static FieldDeclarationSyntax FieldDeclaration(VariableDeclarationSyntax declaration)
    {
      return SyntaxFactory.FieldDeclaration(default(SyntaxList<AttributeListSyntax>), default(SyntaxTokenList), declaration, SyntaxFactory.Token(SyntaxKind.SemicolonToken));
    }

    /// <summary>Creates a new EventFieldDeclarationSyntax instance.</summary>
    public static EventFieldDeclarationSyntax EventFieldDeclaration(SyntaxList<AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, SyntaxToken eventKeyword, VariableDeclarationSyntax declaration, SyntaxToken semicolonToken)
    {
      switch (eventKeyword.Kind())
      {
        case SyntaxKind.EventKeyword:
          break;
        default:
          throw new ArgumentException(nameof(eventKeyword));
      }
      if (declaration == null)
        throw new ArgumentNullException(nameof(declaration));
      switch (semicolonToken.Kind())
      {
        case SyntaxKind.SemicolonToken:
          break;
        default:
          throw new ArgumentException(nameof(semicolonToken));
      }
      return (EventFieldDeclarationSyntax)Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SyntaxFactory.EventFieldDeclaration(attributeLists.Node.ToGreenList<Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.AttributeListSyntax>(), modifiers.Node.ToGreenList<Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SyntaxToken>(), (Syntax.InternalSyntax.SyntaxToken)eventKeyword.Node, declaration == null ? null : (Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.VariableDeclarationSyntax)declaration.Green, (Syntax.InternalSyntax.SyntaxToken)semicolonToken.Node).CreateRed();
    }


    /// <summary>Creates a new EventFieldDeclarationSyntax instance.</summary>
    public static EventFieldDeclarationSyntax EventFieldDeclaration(SyntaxList<AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, VariableDeclarationSyntax declaration)
    {
      return SyntaxFactory.EventFieldDeclaration(attributeLists, modifiers, SyntaxFactory.Token(SyntaxKind.EventKeyword), declaration, SyntaxFactory.Token(SyntaxKind.SemicolonToken));
    }

    /// <summary>Creates a new EventFieldDeclarationSyntax instance.</summary>
    public static EventFieldDeclarationSyntax EventFieldDeclaration(VariableDeclarationSyntax declaration)
    {
      return SyntaxFactory.EventFieldDeclaration(default(SyntaxList<AttributeListSyntax>), default(SyntaxTokenList), SyntaxFactory.Token(SyntaxKind.EventKeyword), declaration, SyntaxFactory.Token(SyntaxKind.SemicolonToken));
    }

    /// <summary>Creates a new ExplicitInterfaceSpecifierSyntax instance.</summary>
    public static ExplicitInterfaceSpecifierSyntax ExplicitInterfaceSpecifier(NameSyntax name, SyntaxToken dotToken)
    {
      if (name == null)
        throw new ArgumentNullException(nameof(name));
      switch (dotToken.Kind())
      {
        case SyntaxKind.DotToken:
          break;
        default:
          throw new ArgumentException(nameof(dotToken));
      }
      return (ExplicitInterfaceSpecifierSyntax)Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SyntaxFactory.ExplicitInterfaceSpecifier(name == null ? null : (Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.NameSyntax)name.Green, (Syntax.InternalSyntax.SyntaxToken)dotToken.Node).CreateRed();
    }


    /// <summary>Creates a new ExplicitInterfaceSpecifierSyntax instance.</summary>
    public static ExplicitInterfaceSpecifierSyntax ExplicitInterfaceSpecifier(NameSyntax name)
    {
      return SyntaxFactory.ExplicitInterfaceSpecifier(name, SyntaxFactory.Token(SyntaxKind.DotToken));
    }

    /// <summary>Creates a new MethodDeclarationSyntax instance.</summary>
    public static MethodDeclarationSyntax MethodDeclaration(SyntaxList<AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, TypeSyntax returnType, ExplicitInterfaceSpecifierSyntax explicitInterfaceSpecifier, SyntaxToken identifier, TypeParameterListSyntax typeParameterList, ParameterListSyntax parameterList, SyntaxList<TypeParameterConstraintClauseSyntax> constraintClauses, BlockSyntax body, ArrowExpressionClauseSyntax expressionBody, SyntaxToken semicolonToken)
    {
      if (returnType == null)
        throw new ArgumentNullException(nameof(returnType));
      switch (identifier.Kind())
      {
        case SyntaxKind.IdentifierToken:
          break;
        default:
          throw new ArgumentException(nameof(identifier));
      }
      if (parameterList == null)
        throw new ArgumentNullException(nameof(parameterList));
      switch (semicolonToken.Kind())
      {
        case SyntaxKind.SemicolonToken:
        case SyntaxKind.None:
          break;
        default:
          throw new ArgumentException(nameof(semicolonToken));
      }
      return (MethodDeclarationSyntax)Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SyntaxFactory.MethodDeclaration(attributeLists.Node.ToGreenList<Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.AttributeListSyntax>(), modifiers.Node.ToGreenList<Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SyntaxToken>(), returnType == null ? null : (Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.TypeSyntax)returnType.Green, explicitInterfaceSpecifier == null ? null : (Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.ExplicitInterfaceSpecifierSyntax)explicitInterfaceSpecifier.Green, (Syntax.InternalSyntax.SyntaxToken)identifier.Node, typeParameterList == null ? null : (Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.TypeParameterListSyntax)typeParameterList.Green, parameterList == null ? null : (Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.ParameterListSyntax)parameterList.Green, constraintClauses.Node.ToGreenList<Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.TypeParameterConstraintClauseSyntax>(), body == null ? null : (Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.BlockSyntax)body.Green, expressionBody == null ? null : (Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.ArrowExpressionClauseSyntax)expressionBody.Green, (Syntax.InternalSyntax.SyntaxToken)semicolonToken.Node).CreateRed();
    }


    /// <summary>Creates a new MethodDeclarationSyntax instance.</summary>
    public static MethodDeclarationSyntax MethodDeclaration(SyntaxList<AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, TypeSyntax returnType, ExplicitInterfaceSpecifierSyntax explicitInterfaceSpecifier, SyntaxToken identifier, TypeParameterListSyntax typeParameterList, ParameterListSyntax parameterList, SyntaxList<TypeParameterConstraintClauseSyntax> constraintClauses, BlockSyntax body, ArrowExpressionClauseSyntax expressionBody)
    {
      return SyntaxFactory.MethodDeclaration(attributeLists, modifiers, returnType, explicitInterfaceSpecifier, identifier, typeParameterList, parameterList, constraintClauses, body, expressionBody, default(SyntaxToken));
    }

    /// <summary>Creates a new MethodDeclarationSyntax instance.</summary>
    public static MethodDeclarationSyntax MethodDeclaration(TypeSyntax returnType, SyntaxToken identifier)
    {
      return SyntaxFactory.MethodDeclaration(default(SyntaxList<AttributeListSyntax>), default(SyntaxTokenList), returnType, default(ExplicitInterfaceSpecifierSyntax), identifier, default(TypeParameterListSyntax), SyntaxFactory.ParameterList(), default(SyntaxList<TypeParameterConstraintClauseSyntax>), default(BlockSyntax), default(ArrowExpressionClauseSyntax), default(SyntaxToken));
    }

    /// <summary>Creates a new MethodDeclarationSyntax instance.</summary>
    public static MethodDeclarationSyntax MethodDeclaration(TypeSyntax returnType, string identifier)
    {
      return SyntaxFactory.MethodDeclaration(default(SyntaxList<AttributeListSyntax>), default(SyntaxTokenList), returnType, default(ExplicitInterfaceSpecifierSyntax), SyntaxFactory.Identifier(identifier), default(TypeParameterListSyntax), SyntaxFactory.ParameterList(), default(SyntaxList<TypeParameterConstraintClauseSyntax>), default(BlockSyntax), default(ArrowExpressionClauseSyntax), default(SyntaxToken));
    }

    /// <summary>Creates a new OperatorDeclarationSyntax instance.</summary>
    public static OperatorDeclarationSyntax OperatorDeclaration(SyntaxList<AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, TypeSyntax returnType, SyntaxToken operatorKeyword, SyntaxToken operatorToken, ParameterListSyntax parameterList, BlockSyntax body, ArrowExpressionClauseSyntax expressionBody, SyntaxToken semicolonToken)
    {
      if (returnType == null)
        throw new ArgumentNullException(nameof(returnType));
      switch (operatorKeyword.Kind())
      {
        case SyntaxKind.OperatorKeyword:
          break;
        default:
          throw new ArgumentException(nameof(operatorKeyword));
      }
      switch (operatorToken.Kind())
      {
        case SyntaxKind.PlusToken:
        case SyntaxKind.MinusToken:
        case SyntaxKind.ExclamationToken:
        case SyntaxKind.TildeToken:
        case SyntaxKind.PlusPlusToken:
        case SyntaxKind.MinusMinusToken:
        case SyntaxKind.AsteriskToken:
        case SyntaxKind.SlashToken:
        case SyntaxKind.PercentToken:
        case SyntaxKind.LessThanLessThanToken:
        case SyntaxKind.GreaterThanGreaterThanToken:
        case SyntaxKind.BarToken:
        case SyntaxKind.AmpersandToken:
        case SyntaxKind.CaretToken:
        case SyntaxKind.EqualsEqualsToken:
        case SyntaxKind.ExclamationEqualsToken:
        case SyntaxKind.LessThanToken:
        case SyntaxKind.LessThanEqualsToken:
        case SyntaxKind.GreaterThanToken:
        case SyntaxKind.GreaterThanEqualsToken:
        case SyntaxKind.FalseKeyword:
        case SyntaxKind.TrueKeyword:
        case SyntaxKind.IsKeyword:
          break;
        default:
          throw new ArgumentException(nameof(operatorToken));
      }
      if (parameterList == null)
        throw new ArgumentNullException(nameof(parameterList));
      switch (semicolonToken.Kind())
      {
        case SyntaxKind.SemicolonToken:
        case SyntaxKind.None:
          break;
        default:
          throw new ArgumentException(nameof(semicolonToken));
      }
      return (OperatorDeclarationSyntax)Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SyntaxFactory.OperatorDeclaration(attributeLists.Node.ToGreenList<Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.AttributeListSyntax>(), modifiers.Node.ToGreenList<Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SyntaxToken>(), returnType == null ? null : (Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.TypeSyntax)returnType.Green, (Syntax.InternalSyntax.SyntaxToken)operatorKeyword.Node, (Syntax.InternalSyntax.SyntaxToken)operatorToken.Node, parameterList == null ? null : (Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.ParameterListSyntax)parameterList.Green, body == null ? null : (Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.BlockSyntax)body.Green, expressionBody == null ? null : (Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.ArrowExpressionClauseSyntax)expressionBody.Green, (Syntax.InternalSyntax.SyntaxToken)semicolonToken.Node).CreateRed();
    }


    /// <summary>Creates a new OperatorDeclarationSyntax instance.</summary>
    public static OperatorDeclarationSyntax OperatorDeclaration(SyntaxList<AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, TypeSyntax returnType, SyntaxToken operatorToken, ParameterListSyntax parameterList, BlockSyntax body, ArrowExpressionClauseSyntax expressionBody)
    {
      return SyntaxFactory.OperatorDeclaration(attributeLists, modifiers, returnType, SyntaxFactory.Token(SyntaxKind.OperatorKeyword), operatorToken, parameterList, body, expressionBody, default(SyntaxToken));
    }

    /// <summary>Creates a new OperatorDeclarationSyntax instance.</summary>
    public static OperatorDeclarationSyntax OperatorDeclaration(TypeSyntax returnType, SyntaxToken operatorToken)
    {
      return SyntaxFactory.OperatorDeclaration(default(SyntaxList<AttributeListSyntax>), default(SyntaxTokenList), returnType, SyntaxFactory.Token(SyntaxKind.OperatorKeyword), operatorToken, SyntaxFactory.ParameterList(), default(BlockSyntax), default(ArrowExpressionClauseSyntax), default(SyntaxToken));
    }

    /// <summary>Creates a new ConversionOperatorDeclarationSyntax instance.</summary>
    public static ConversionOperatorDeclarationSyntax ConversionOperatorDeclaration(SyntaxList<AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, SyntaxToken implicitOrExplicitKeyword, SyntaxToken operatorKeyword, TypeSyntax type, ParameterListSyntax parameterList, BlockSyntax body, ArrowExpressionClauseSyntax expressionBody, SyntaxToken semicolonToken)
    {
      switch (implicitOrExplicitKeyword.Kind())
      {
        case SyntaxKind.ImplicitKeyword:
        case SyntaxKind.ExplicitKeyword:
          break;
        default:
          throw new ArgumentException(nameof(implicitOrExplicitKeyword));
      }
      switch (operatorKeyword.Kind())
      {
        case SyntaxKind.OperatorKeyword:
          break;
        default:
          throw new ArgumentException(nameof(operatorKeyword));
      }
      if (type == null)
        throw new ArgumentNullException(nameof(type));
      if (parameterList == null)
        throw new ArgumentNullException(nameof(parameterList));
      switch (semicolonToken.Kind())
      {
        case SyntaxKind.SemicolonToken:
        case SyntaxKind.None:
          break;
        default:
          throw new ArgumentException(nameof(semicolonToken));
      }
      return (ConversionOperatorDeclarationSyntax)Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SyntaxFactory.ConversionOperatorDeclaration(attributeLists.Node.ToGreenList<Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.AttributeListSyntax>(), modifiers.Node.ToGreenList<Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SyntaxToken>(), (Syntax.InternalSyntax.SyntaxToken)implicitOrExplicitKeyword.Node, (Syntax.InternalSyntax.SyntaxToken)operatorKeyword.Node, type == null ? null : (Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.TypeSyntax)type.Green, parameterList == null ? null : (Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.ParameterListSyntax)parameterList.Green, body == null ? null : (Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.BlockSyntax)body.Green, expressionBody == null ? null : (Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.ArrowExpressionClauseSyntax)expressionBody.Green, (Syntax.InternalSyntax.SyntaxToken)semicolonToken.Node).CreateRed();
    }


    /// <summary>Creates a new ConversionOperatorDeclarationSyntax instance.</summary>
    public static ConversionOperatorDeclarationSyntax ConversionOperatorDeclaration(SyntaxList<AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, SyntaxToken implicitOrExplicitKeyword, TypeSyntax type, ParameterListSyntax parameterList, BlockSyntax body, ArrowExpressionClauseSyntax expressionBody)
    {
      return SyntaxFactory.ConversionOperatorDeclaration(attributeLists, modifiers, implicitOrExplicitKeyword, SyntaxFactory.Token(SyntaxKind.OperatorKeyword), type, parameterList, body, expressionBody, default(SyntaxToken));
    }

    /// <summary>Creates a new ConversionOperatorDeclarationSyntax instance.</summary>
    public static ConversionOperatorDeclarationSyntax ConversionOperatorDeclaration(SyntaxToken implicitOrExplicitKeyword, TypeSyntax type)
    {
      return SyntaxFactory.ConversionOperatorDeclaration(default(SyntaxList<AttributeListSyntax>), default(SyntaxTokenList), implicitOrExplicitKeyword, SyntaxFactory.Token(SyntaxKind.OperatorKeyword), type, SyntaxFactory.ParameterList(), default(BlockSyntax), default(ArrowExpressionClauseSyntax), default(SyntaxToken));
    }

    /// <summary>Creates a new ConstructorDeclarationSyntax instance.</summary>
    public static ConstructorDeclarationSyntax ConstructorDeclaration(SyntaxList<AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, SyntaxToken identifier, ParameterListSyntax parameterList, ConstructorInitializerSyntax initializer, BlockSyntax body, ArrowExpressionClauseSyntax expressionBody, SyntaxToken semicolonToken)
    {
      switch (identifier.Kind())
      {
        case SyntaxKind.IdentifierToken:
          break;
        default:
          throw new ArgumentException(nameof(identifier));
      }
      if (parameterList == null)
        throw new ArgumentNullException(nameof(parameterList));
      switch (semicolonToken.Kind())
      {
        case SyntaxKind.SemicolonToken:
        case SyntaxKind.None:
          break;
        default:
          throw new ArgumentException(nameof(semicolonToken));
      }
      return (ConstructorDeclarationSyntax)Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SyntaxFactory.ConstructorDeclaration(attributeLists.Node.ToGreenList<Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.AttributeListSyntax>(), modifiers.Node.ToGreenList<Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SyntaxToken>(), (Syntax.InternalSyntax.SyntaxToken)identifier.Node, parameterList == null ? null : (Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.ParameterListSyntax)parameterList.Green, initializer == null ? null : (Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.ConstructorInitializerSyntax)initializer.Green, body == null ? null : (Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.BlockSyntax)body.Green, expressionBody == null ? null : (Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.ArrowExpressionClauseSyntax)expressionBody.Green, (Syntax.InternalSyntax.SyntaxToken)semicolonToken.Node).CreateRed();
    }


    /// <summary>Creates a new ConstructorDeclarationSyntax instance.</summary>
    public static ConstructorDeclarationSyntax ConstructorDeclaration(SyntaxList<AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, SyntaxToken identifier, ParameterListSyntax parameterList, ConstructorInitializerSyntax initializer, BlockSyntax body, ArrowExpressionClauseSyntax expressionBody)
    {
      return SyntaxFactory.ConstructorDeclaration(attributeLists, modifiers, identifier, parameterList, initializer, body, expressionBody, default(SyntaxToken));
    }

    /// <summary>Creates a new ConstructorDeclarationSyntax instance.</summary>
    public static ConstructorDeclarationSyntax ConstructorDeclaration(SyntaxToken identifier)
    {
      return SyntaxFactory.ConstructorDeclaration(default(SyntaxList<AttributeListSyntax>), default(SyntaxTokenList), identifier, SyntaxFactory.ParameterList(), default(ConstructorInitializerSyntax), default(BlockSyntax), default(ArrowExpressionClauseSyntax), default(SyntaxToken));
    }

    /// <summary>Creates a new ConstructorDeclarationSyntax instance.</summary>
    public static ConstructorDeclarationSyntax ConstructorDeclaration(string identifier)
    {
      return SyntaxFactory.ConstructorDeclaration(default(SyntaxList<AttributeListSyntax>), default(SyntaxTokenList), SyntaxFactory.Identifier(identifier), SyntaxFactory.ParameterList(), default(ConstructorInitializerSyntax), default(BlockSyntax), default(ArrowExpressionClauseSyntax), default(SyntaxToken));
    }

    /// <summary>Creates a new ConstructorInitializerSyntax instance.</summary>
    public static ConstructorInitializerSyntax ConstructorInitializer(SyntaxKind kind, SyntaxToken colonToken, SyntaxToken thisOrBaseKeyword, ArgumentListSyntax argumentList)
    {
      switch (kind)
      {
        case SyntaxKind.BaseConstructorInitializer:
        case SyntaxKind.ThisConstructorInitializer:
          break;
        default:
          throw new ArgumentException(nameof(kind));
      }
      switch (colonToken.Kind())
      {
        case SyntaxKind.ColonToken:
          break;
        default:
          throw new ArgumentException(nameof(colonToken));
      }
      switch (thisOrBaseKeyword.Kind())
      {
        case SyntaxKind.BaseKeyword:
        case SyntaxKind.ThisKeyword:
          break;
        default:
          throw new ArgumentException(nameof(thisOrBaseKeyword));
      }
      if (argumentList == null)
        throw new ArgumentNullException(nameof(argumentList));
      return (ConstructorInitializerSyntax)Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SyntaxFactory.ConstructorInitializer(kind, (Syntax.InternalSyntax.SyntaxToken)colonToken.Node, (Syntax.InternalSyntax.SyntaxToken)thisOrBaseKeyword.Node, argumentList == null ? null : (Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.ArgumentListSyntax)argumentList.Green).CreateRed();
    }


    /// <summary>Creates a new ConstructorInitializerSyntax instance.</summary>
    public static ConstructorInitializerSyntax ConstructorInitializer(SyntaxKind kind, ArgumentListSyntax argumentList = default(ArgumentListSyntax))
    {
      return SyntaxFactory.ConstructorInitializer(kind, SyntaxFactory.Token(SyntaxKind.ColonToken), SyntaxFactory.Token(GetConstructorInitializerThisOrBaseKeywordKind(kind)), argumentList ?? SyntaxFactory.ArgumentList());
    }

    private static SyntaxKind GetConstructorInitializerThisOrBaseKeywordKind(SyntaxKind kind)
    {
      switch (kind)
      {
        case SyntaxKind.BaseConstructorInitializer:
          return SyntaxKind.BaseKeyword;
        case SyntaxKind.ThisConstructorInitializer:
          return SyntaxKind.ThisKeyword;
        default:
          throw new ArgumentOutOfRangeException();
      }
    }

    /// <summary>Creates a new DestructorDeclarationSyntax instance.</summary>
    public static DestructorDeclarationSyntax DestructorDeclaration(SyntaxList<AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, SyntaxToken tildeToken, SyntaxToken identifier, ParameterListSyntax parameterList, BlockSyntax body, ArrowExpressionClauseSyntax expressionBody, SyntaxToken semicolonToken)
    {
      switch (tildeToken.Kind())
      {
        case SyntaxKind.TildeToken:
          break;
        default:
          throw new ArgumentException(nameof(tildeToken));
      }
      switch (identifier.Kind())
      {
        case SyntaxKind.IdentifierToken:
          break;
        default:
          throw new ArgumentException(nameof(identifier));
      }
      if (parameterList == null)
        throw new ArgumentNullException(nameof(parameterList));
      switch (semicolonToken.Kind())
      {
        case SyntaxKind.SemicolonToken:
        case SyntaxKind.None:
          break;
        default:
          throw new ArgumentException(nameof(semicolonToken));
      }
      return (DestructorDeclarationSyntax)Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SyntaxFactory.DestructorDeclaration(attributeLists.Node.ToGreenList<Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.AttributeListSyntax>(), modifiers.Node.ToGreenList<Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SyntaxToken>(), (Syntax.InternalSyntax.SyntaxToken)tildeToken.Node, (Syntax.InternalSyntax.SyntaxToken)identifier.Node, parameterList == null ? null : (Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.ParameterListSyntax)parameterList.Green, body == null ? null : (Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.BlockSyntax)body.Green, expressionBody == null ? null : (Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.ArrowExpressionClauseSyntax)expressionBody.Green, (Syntax.InternalSyntax.SyntaxToken)semicolonToken.Node).CreateRed();
    }


    /// <summary>Creates a new DestructorDeclarationSyntax instance.</summary>
    public static DestructorDeclarationSyntax DestructorDeclaration(SyntaxList<AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, SyntaxToken identifier, ParameterListSyntax parameterList, BlockSyntax body, ArrowExpressionClauseSyntax expressionBody)
    {
      return SyntaxFactory.DestructorDeclaration(attributeLists, modifiers, SyntaxFactory.Token(SyntaxKind.TildeToken), identifier, parameterList, body, expressionBody, default(SyntaxToken));
    }

    /// <summary>Creates a new DestructorDeclarationSyntax instance.</summary>
    public static DestructorDeclarationSyntax DestructorDeclaration(SyntaxToken identifier)
    {
      return SyntaxFactory.DestructorDeclaration(default(SyntaxList<AttributeListSyntax>), default(SyntaxTokenList), SyntaxFactory.Token(SyntaxKind.TildeToken), identifier, SyntaxFactory.ParameterList(), default(BlockSyntax), default(ArrowExpressionClauseSyntax), default(SyntaxToken));
    }

    /// <summary>Creates a new DestructorDeclarationSyntax instance.</summary>
    public static DestructorDeclarationSyntax DestructorDeclaration(string identifier)
    {
      return SyntaxFactory.DestructorDeclaration(default(SyntaxList<AttributeListSyntax>), default(SyntaxTokenList), SyntaxFactory.Token(SyntaxKind.TildeToken), SyntaxFactory.Identifier(identifier), SyntaxFactory.ParameterList(), default(BlockSyntax), default(ArrowExpressionClauseSyntax), default(SyntaxToken));
    }

    /// <summary>Creates a new PropertyDeclarationSyntax instance.</summary>
    public static PropertyDeclarationSyntax PropertyDeclaration(SyntaxList<AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, TypeSyntax type, ExplicitInterfaceSpecifierSyntax explicitInterfaceSpecifier, SyntaxToken identifier, AccessorListSyntax accessorList, ArrowExpressionClauseSyntax expressionBody, EqualsValueClauseSyntax initializer, SyntaxToken semicolonToken)
    {
      if (type == null)
        throw new ArgumentNullException(nameof(type));
      switch (identifier.Kind())
      {
        case SyntaxKind.IdentifierToken:
          break;
        default:
          throw new ArgumentException(nameof(identifier));
      }
      switch (semicolonToken.Kind())
      {
        case SyntaxKind.SemicolonToken:
        case SyntaxKind.None:
          break;
        default:
          throw new ArgumentException(nameof(semicolonToken));
      }
      return (PropertyDeclarationSyntax)Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SyntaxFactory.PropertyDeclaration(attributeLists.Node.ToGreenList<Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.AttributeListSyntax>(), modifiers.Node.ToGreenList<Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SyntaxToken>(), type == null ? null : (Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.TypeSyntax)type.Green, explicitInterfaceSpecifier == null ? null : (Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.ExplicitInterfaceSpecifierSyntax)explicitInterfaceSpecifier.Green, (Syntax.InternalSyntax.SyntaxToken)identifier.Node, accessorList == null ? null : (Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.AccessorListSyntax)accessorList.Green, expressionBody == null ? null : (Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.ArrowExpressionClauseSyntax)expressionBody.Green, initializer == null ? null : (Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.EqualsValueClauseSyntax)initializer.Green, (Syntax.InternalSyntax.SyntaxToken)semicolonToken.Node).CreateRed();
    }


    /// <summary>Creates a new PropertyDeclarationSyntax instance.</summary>
    public static PropertyDeclarationSyntax PropertyDeclaration(SyntaxList<AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, TypeSyntax type, ExplicitInterfaceSpecifierSyntax explicitInterfaceSpecifier, SyntaxToken identifier, AccessorListSyntax accessorList, ArrowExpressionClauseSyntax expressionBody, EqualsValueClauseSyntax initializer)
    {
      return SyntaxFactory.PropertyDeclaration(attributeLists, modifiers, type, explicitInterfaceSpecifier, identifier, accessorList, expressionBody, initializer, default(SyntaxToken));
    }

    /// <summary>Creates a new PropertyDeclarationSyntax instance.</summary>
    public static PropertyDeclarationSyntax PropertyDeclaration(TypeSyntax type, SyntaxToken identifier)
    {
      return SyntaxFactory.PropertyDeclaration(default(SyntaxList<AttributeListSyntax>), default(SyntaxTokenList), type, default(ExplicitInterfaceSpecifierSyntax), identifier, default(AccessorListSyntax), default(ArrowExpressionClauseSyntax), default(EqualsValueClauseSyntax), default(SyntaxToken));
    }

    /// <summary>Creates a new PropertyDeclarationSyntax instance.</summary>
    public static PropertyDeclarationSyntax PropertyDeclaration(TypeSyntax type, string identifier)
    {
      return SyntaxFactory.PropertyDeclaration(default(SyntaxList<AttributeListSyntax>), default(SyntaxTokenList), type, default(ExplicitInterfaceSpecifierSyntax), SyntaxFactory.Identifier(identifier), default(AccessorListSyntax), default(ArrowExpressionClauseSyntax), default(EqualsValueClauseSyntax), default(SyntaxToken));
    }

    /// <summary>Creates a new ArrowExpressionClauseSyntax instance.</summary>
    public static ArrowExpressionClauseSyntax ArrowExpressionClause(SyntaxToken arrowToken, ExpressionSyntax expression)
    {
      switch (arrowToken.Kind())
      {
        case SyntaxKind.EqualsGreaterThanToken:
          break;
        default:
          throw new ArgumentException(nameof(arrowToken));
      }
      if (expression == null)
        throw new ArgumentNullException(nameof(expression));
      return (ArrowExpressionClauseSyntax)Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SyntaxFactory.ArrowExpressionClause((Syntax.InternalSyntax.SyntaxToken)arrowToken.Node, expression == null ? null : (Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.ExpressionSyntax)expression.Green).CreateRed();
    }


    /// <summary>Creates a new ArrowExpressionClauseSyntax instance.</summary>
    public static ArrowExpressionClauseSyntax ArrowExpressionClause(ExpressionSyntax expression)
    {
      return SyntaxFactory.ArrowExpressionClause(SyntaxFactory.Token(SyntaxKind.EqualsGreaterThanToken), expression);
    }

    /// <summary>Creates a new EventDeclarationSyntax instance.</summary>
    public static EventDeclarationSyntax EventDeclaration(SyntaxList<AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, SyntaxToken eventKeyword, TypeSyntax type, ExplicitInterfaceSpecifierSyntax explicitInterfaceSpecifier, SyntaxToken identifier, AccessorListSyntax accessorList, SyntaxToken semicolonToken)
    {
      switch (eventKeyword.Kind())
      {
        case SyntaxKind.EventKeyword:
          break;
        default:
          throw new ArgumentException(nameof(eventKeyword));
      }
      if (type == null)
        throw new ArgumentNullException(nameof(type));
      switch (identifier.Kind())
      {
        case SyntaxKind.IdentifierToken:
          break;
        default:
          throw new ArgumentException(nameof(identifier));
      }
      switch (semicolonToken.Kind())
      {
        case SyntaxKind.SemicolonToken:
        case SyntaxKind.None:
          break;
        default:
          throw new ArgumentException(nameof(semicolonToken));
      }
      return (EventDeclarationSyntax)Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SyntaxFactory.EventDeclaration(attributeLists.Node.ToGreenList<Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.AttributeListSyntax>(), modifiers.Node.ToGreenList<Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SyntaxToken>(), (Syntax.InternalSyntax.SyntaxToken)eventKeyword.Node, type == null ? null : (Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.TypeSyntax)type.Green, explicitInterfaceSpecifier == null ? null : (Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.ExplicitInterfaceSpecifierSyntax)explicitInterfaceSpecifier.Green, (Syntax.InternalSyntax.SyntaxToken)identifier.Node, accessorList == null ? null : (Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.AccessorListSyntax)accessorList.Green, (Syntax.InternalSyntax.SyntaxToken)semicolonToken.Node).CreateRed();
    }


    /// <summary>Creates a new EventDeclarationSyntax instance.</summary>
    public static EventDeclarationSyntax EventDeclaration(SyntaxList<AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, TypeSyntax type, ExplicitInterfaceSpecifierSyntax explicitInterfaceSpecifier, SyntaxToken identifier, AccessorListSyntax accessorList)
    {
      return SyntaxFactory.EventDeclaration(attributeLists, modifiers, SyntaxFactory.Token(SyntaxKind.EventKeyword), type, explicitInterfaceSpecifier, identifier, accessorList, default(SyntaxToken));
    }

    /// <summary>Creates a new EventDeclarationSyntax instance.</summary>
    public static EventDeclarationSyntax EventDeclaration(TypeSyntax type, SyntaxToken identifier)
    {
      return SyntaxFactory.EventDeclaration(default(SyntaxList<AttributeListSyntax>), default(SyntaxTokenList), SyntaxFactory.Token(SyntaxKind.EventKeyword), type, default(ExplicitInterfaceSpecifierSyntax), identifier, default(AccessorListSyntax), default(SyntaxToken));
    }

    /// <summary>Creates a new EventDeclarationSyntax instance.</summary>
    public static EventDeclarationSyntax EventDeclaration(TypeSyntax type, string identifier)
    {
      return SyntaxFactory.EventDeclaration(default(SyntaxList<AttributeListSyntax>), default(SyntaxTokenList), SyntaxFactory.Token(SyntaxKind.EventKeyword), type, default(ExplicitInterfaceSpecifierSyntax), SyntaxFactory.Identifier(identifier), default(AccessorListSyntax), default(SyntaxToken));
    }

    /// <summary>Creates a new IndexerDeclarationSyntax instance.</summary>
    public static IndexerDeclarationSyntax IndexerDeclaration(SyntaxList<AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, TypeSyntax type, ExplicitInterfaceSpecifierSyntax explicitInterfaceSpecifier, SyntaxToken thisKeyword, BracketedParameterListSyntax parameterList, AccessorListSyntax accessorList, ArrowExpressionClauseSyntax expressionBody, SyntaxToken semicolonToken)
    {
      if (type == null)
        throw new ArgumentNullException(nameof(type));
      switch (thisKeyword.Kind())
      {
        case SyntaxKind.ThisKeyword:
          break;
        default:
          throw new ArgumentException(nameof(thisKeyword));
      }
      if (parameterList == null)
        throw new ArgumentNullException(nameof(parameterList));
      switch (semicolonToken.Kind())
      {
        case SyntaxKind.SemicolonToken:
        case SyntaxKind.None:
          break;
        default:
          throw new ArgumentException(nameof(semicolonToken));
      }
      return (IndexerDeclarationSyntax)Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SyntaxFactory.IndexerDeclaration(attributeLists.Node.ToGreenList<Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.AttributeListSyntax>(), modifiers.Node.ToGreenList<Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SyntaxToken>(), type == null ? null : (Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.TypeSyntax)type.Green, explicitInterfaceSpecifier == null ? null : (Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.ExplicitInterfaceSpecifierSyntax)explicitInterfaceSpecifier.Green, (Syntax.InternalSyntax.SyntaxToken)thisKeyword.Node, parameterList == null ? null : (Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.BracketedParameterListSyntax)parameterList.Green, accessorList == null ? null : (Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.AccessorListSyntax)accessorList.Green, expressionBody == null ? null : (Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.ArrowExpressionClauseSyntax)expressionBody.Green, (Syntax.InternalSyntax.SyntaxToken)semicolonToken.Node).CreateRed();
    }


    /// <summary>Creates a new IndexerDeclarationSyntax instance.</summary>
    public static IndexerDeclarationSyntax IndexerDeclaration(SyntaxList<AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, TypeSyntax type, ExplicitInterfaceSpecifierSyntax explicitInterfaceSpecifier, BracketedParameterListSyntax parameterList, AccessorListSyntax accessorList, ArrowExpressionClauseSyntax expressionBody)
    {
      return SyntaxFactory.IndexerDeclaration(attributeLists, modifiers, type, explicitInterfaceSpecifier, SyntaxFactory.Token(SyntaxKind.ThisKeyword), parameterList, accessorList, expressionBody, default(SyntaxToken));
    }

    /// <summary>Creates a new IndexerDeclarationSyntax instance.</summary>
    public static IndexerDeclarationSyntax IndexerDeclaration(TypeSyntax type)
    {
      return SyntaxFactory.IndexerDeclaration(default(SyntaxList<AttributeListSyntax>), default(SyntaxTokenList), type, default(ExplicitInterfaceSpecifierSyntax), SyntaxFactory.Token(SyntaxKind.ThisKeyword), SyntaxFactory.BracketedParameterList(), default(AccessorListSyntax), default(ArrowExpressionClauseSyntax), default(SyntaxToken));
    }

    /// <summary>Creates a new AccessorListSyntax instance.</summary>
    public static AccessorListSyntax AccessorList(SyntaxToken openBraceToken, SyntaxList<AccessorDeclarationSyntax> accessors, SyntaxToken closeBraceToken)
    {
      switch (openBraceToken.Kind())
      {
        case SyntaxKind.OpenBraceToken:
          break;
        default:
          throw new ArgumentException(nameof(openBraceToken));
      }
      switch (closeBraceToken.Kind())
      {
        case SyntaxKind.CloseBraceToken:
          break;
        default:
          throw new ArgumentException(nameof(closeBraceToken));
      }
      return (AccessorListSyntax)Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SyntaxFactory.AccessorList((Syntax.InternalSyntax.SyntaxToken)openBraceToken.Node, accessors.Node.ToGreenList<Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.AccessorDeclarationSyntax>(), (Syntax.InternalSyntax.SyntaxToken)closeBraceToken.Node).CreateRed();
    }


    /// <summary>Creates a new AccessorListSyntax instance.</summary>
    public static AccessorListSyntax AccessorList(SyntaxList<AccessorDeclarationSyntax> accessors = default(SyntaxList<AccessorDeclarationSyntax>))
    {
      return SyntaxFactory.AccessorList(SyntaxFactory.Token(SyntaxKind.OpenBraceToken), accessors, SyntaxFactory.Token(SyntaxKind.CloseBraceToken));
    }

    /// <summary>Creates a new AccessorDeclarationSyntax instance.</summary>
    public static AccessorDeclarationSyntax AccessorDeclaration(SyntaxKind kind, SyntaxList<AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, SyntaxToken keyword, BlockSyntax body, ArrowExpressionClauseSyntax expressionBody, SyntaxToken semicolonToken)
    {
      switch (kind)
      {
        case SyntaxKind.GetAccessorDeclaration:
        case SyntaxKind.SetAccessorDeclaration:
        case SyntaxKind.AddAccessorDeclaration:
        case SyntaxKind.RemoveAccessorDeclaration:
        case SyntaxKind.UnknownAccessorDeclaration:
          break;
        default:
          throw new ArgumentException(nameof(kind));
      }
      switch (keyword.Kind())
      {
        case SyntaxKind.GetKeyword:
        case SyntaxKind.SetKeyword:
        case SyntaxKind.AddKeyword:
        case SyntaxKind.RemoveKeyword:
        case SyntaxKind.IdentifierToken:
          break;
        default:
          throw new ArgumentException(nameof(keyword));
      }
      switch (semicolonToken.Kind())
      {
        case SyntaxKind.SemicolonToken:
        case SyntaxKind.None:
          break;
        default:
          throw new ArgumentException(nameof(semicolonToken));
      }
      return (AccessorDeclarationSyntax)Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SyntaxFactory.AccessorDeclaration(kind, attributeLists.Node.ToGreenList<Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.AttributeListSyntax>(), modifiers.Node.ToGreenList<Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SyntaxToken>(), (Syntax.InternalSyntax.SyntaxToken)keyword.Node, body == null ? null : (Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.BlockSyntax)body.Green, expressionBody == null ? null : (Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.ArrowExpressionClauseSyntax)expressionBody.Green, (Syntax.InternalSyntax.SyntaxToken)semicolonToken.Node).CreateRed();
    }


    /// <summary>Creates a new AccessorDeclarationSyntax instance.</summary>
    public static AccessorDeclarationSyntax AccessorDeclaration(SyntaxKind kind, SyntaxList<AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, BlockSyntax body, ArrowExpressionClauseSyntax expressionBody)
    {
      return SyntaxFactory.AccessorDeclaration(kind, attributeLists, modifiers, SyntaxFactory.Token(GetAccessorDeclarationKeywordKind(kind)), body, expressionBody, default(SyntaxToken));
    }

    /// <summary>Creates a new AccessorDeclarationSyntax instance.</summary>
    public static AccessorDeclarationSyntax AccessorDeclaration(SyntaxKind kind)
    {
      return SyntaxFactory.AccessorDeclaration(kind, default(SyntaxList<AttributeListSyntax>), default(SyntaxTokenList), SyntaxFactory.Token(GetAccessorDeclarationKeywordKind(kind)), default(BlockSyntax), default(ArrowExpressionClauseSyntax), default(SyntaxToken));
    }

    private static SyntaxKind GetAccessorDeclarationKeywordKind(SyntaxKind kind)
    {
      switch (kind)
      {
        case SyntaxKind.GetAccessorDeclaration:
          return SyntaxKind.GetKeyword;
        case SyntaxKind.SetAccessorDeclaration:
          return SyntaxKind.SetKeyword;
        case SyntaxKind.AddAccessorDeclaration:
          return SyntaxKind.AddKeyword;
        case SyntaxKind.RemoveAccessorDeclaration:
          return SyntaxKind.RemoveKeyword;
        case SyntaxKind.UnknownAccessorDeclaration:
          return SyntaxKind.IdentifierToken;
        default:
          throw new ArgumentOutOfRangeException();
      }
    }

    /// <summary>Creates a new ParameterListSyntax instance.</summary>
    public static ParameterListSyntax ParameterList(SyntaxToken openParenToken, SeparatedSyntaxList<ParameterSyntax> parameters, SyntaxToken closeParenToken)
    {
      switch (openParenToken.Kind())
      {
        case SyntaxKind.OpenParenToken:
          break;
        default:
          throw new ArgumentException(nameof(openParenToken));
      }
      switch (closeParenToken.Kind())
      {
        case SyntaxKind.CloseParenToken:
          break;
        default:
          throw new ArgumentException(nameof(closeParenToken));
      }
      return (ParameterListSyntax)Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SyntaxFactory.ParameterList((Syntax.InternalSyntax.SyntaxToken)openParenToken.Node, parameters.Node.ToGreenSeparatedList<Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.ParameterSyntax>(), (Syntax.InternalSyntax.SyntaxToken)closeParenToken.Node).CreateRed();
    }


    /// <summary>Creates a new ParameterListSyntax instance.</summary>
    public static ParameterListSyntax ParameterList(SeparatedSyntaxList<ParameterSyntax> parameters = default(SeparatedSyntaxList<ParameterSyntax>))
    {
      return SyntaxFactory.ParameterList(SyntaxFactory.Token(SyntaxKind.OpenParenToken), parameters, SyntaxFactory.Token(SyntaxKind.CloseParenToken));
    }

    /// <summary>Creates a new BracketedParameterListSyntax instance.</summary>
    public static BracketedParameterListSyntax BracketedParameterList(SyntaxToken openBracketToken, SeparatedSyntaxList<ParameterSyntax> parameters, SyntaxToken closeBracketToken)
    {
      switch (openBracketToken.Kind())
      {
        case SyntaxKind.OpenBracketToken:
          break;
        default:
          throw new ArgumentException(nameof(openBracketToken));
      }
      switch (closeBracketToken.Kind())
      {
        case SyntaxKind.CloseBracketToken:
          break;
        default:
          throw new ArgumentException(nameof(closeBracketToken));
      }
      return (BracketedParameterListSyntax)Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SyntaxFactory.BracketedParameterList((Syntax.InternalSyntax.SyntaxToken)openBracketToken.Node, parameters.Node.ToGreenSeparatedList<Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.ParameterSyntax>(), (Syntax.InternalSyntax.SyntaxToken)closeBracketToken.Node).CreateRed();
    }


    /// <summary>Creates a new BracketedParameterListSyntax instance.</summary>
    public static BracketedParameterListSyntax BracketedParameterList(SeparatedSyntaxList<ParameterSyntax> parameters = default(SeparatedSyntaxList<ParameterSyntax>))
    {
      return SyntaxFactory.BracketedParameterList(SyntaxFactory.Token(SyntaxKind.OpenBracketToken), parameters, SyntaxFactory.Token(SyntaxKind.CloseBracketToken));
    }

    /// <summary>Creates a new ParameterSyntax instance.</summary>
    public static ParameterSyntax Parameter(SyntaxList<AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, TypeSyntax type, SyntaxToken identifier, SyntaxToken exclamationToken, EqualsValueClauseSyntax @default)
    {
      switch (identifier.Kind())
      {
        case SyntaxKind.IdentifierToken:
        case SyntaxKind.ArgListKeyword:
          break;
        default:
          throw new ArgumentException(nameof(identifier));
      }
      switch (exclamationToken.Kind())
      {
        case SyntaxKind.ExclamationToken:
        case SyntaxKind.None:
          break;
        default:
          throw new ArgumentException(nameof(exclamationToken));
      }
      return (ParameterSyntax)Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SyntaxFactory.Parameter(attributeLists.Node.ToGreenList<Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.AttributeListSyntax>(), modifiers.Node.ToGreenList<Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SyntaxToken>(), type == null ? null : (Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.TypeSyntax)type.Green, (Syntax.InternalSyntax.SyntaxToken)identifier.Node, (Syntax.InternalSyntax.SyntaxToken)exclamationToken.Node, @default == null ? null : (Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.EqualsValueClauseSyntax)@default.Green).CreateRed();
    }


    /// <summary>Creates a new ParameterSyntax instance.</summary>
    public static ParameterSyntax Parameter(SyntaxList<AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, TypeSyntax type, SyntaxToken identifier, EqualsValueClauseSyntax @default)
    {
      return SyntaxFactory.Parameter(attributeLists, modifiers, type, identifier, default(SyntaxToken), @default);
    }

    /// <summary>Creates a new ParameterSyntax instance.</summary>
    public static ParameterSyntax Parameter(SyntaxToken identifier)
    {
      return SyntaxFactory.Parameter(default(SyntaxList<AttributeListSyntax>), default(SyntaxTokenList), default(TypeSyntax), identifier, default(SyntaxToken), default(EqualsValueClauseSyntax));
    }

    /// <summary>Creates a new IncompleteMemberSyntax instance.</summary>
    public static IncompleteMemberSyntax IncompleteMember(SyntaxList<AttributeListSyntax> attributeLists, SyntaxTokenList modifiers, TypeSyntax type)
    {
      return (IncompleteMemberSyntax)Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SyntaxFactory.IncompleteMember(attributeLists.Node.ToGreenList<Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.AttributeListSyntax>(), modifiers.Node.ToGreenList<Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SyntaxToken>(), type == null ? null : (Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.TypeSyntax)type.Green).CreateRed();
    }


    /// <summary>Creates a new IncompleteMemberSyntax instance.</summary>
    public static IncompleteMemberSyntax IncompleteMember(TypeSyntax type = default(TypeSyntax))
    {
      return SyntaxFactory.IncompleteMember(default(SyntaxList<AttributeListSyntax>), default(SyntaxTokenList), type);
    }

    /// <summary>Creates a new SkippedTokensTriviaSyntax instance.</summary>
    public static SkippedTokensTriviaSyntax SkippedTokensTrivia(SyntaxTokenList tokens)
    {
      return (SkippedTokensTriviaSyntax)Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SyntaxFactory.SkippedTokensTrivia(tokens.Node.ToGreenList<Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SyntaxToken>()).CreateRed();
    }


    /// <summary>Creates a new SkippedTokensTriviaSyntax instance.</summary>
    public static SkippedTokensTriviaSyntax SkippedTokensTrivia()
    {
      return SyntaxFactory.SkippedTokensTrivia(default(SyntaxTokenList));
    }

    /// <summary>Creates a new DocumentationCommentTriviaSyntax instance.</summary>
    public static DocumentationCommentTriviaSyntax DocumentationCommentTrivia(SyntaxKind kind, SyntaxList<XmlNodeSyntax> content, SyntaxToken endOfComment)
    {
      switch (kind)
      {
        case SyntaxKind.SingleLineDocumentationCommentTrivia:
        case SyntaxKind.MultiLineDocumentationCommentTrivia:
          break;
        default:
          throw new ArgumentException(nameof(kind));
      }
      switch (endOfComment.Kind())
      {
        case SyntaxKind.EndOfDocumentationCommentToken:
          break;
        default:
          throw new ArgumentException(nameof(endOfComment));
      }
      return (DocumentationCommentTriviaSyntax)Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SyntaxFactory.DocumentationCommentTrivia(kind, content.Node.ToGreenList<Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.XmlNodeSyntax>(), (Syntax.InternalSyntax.SyntaxToken)endOfComment.Node).CreateRed();
    }


    /// <summary>Creates a new DocumentationCommentTriviaSyntax instance.</summary>
    public static DocumentationCommentTriviaSyntax DocumentationCommentTrivia(SyntaxKind kind, SyntaxList<XmlNodeSyntax> content = default(SyntaxList<XmlNodeSyntax>))
    {
      return SyntaxFactory.DocumentationCommentTrivia(kind, content, SyntaxFactory.Token(SyntaxKind.EndOfDocumentationCommentToken));
    }

    /// <summary>Creates a new TypeCrefSyntax instance.</summary>
    public static TypeCrefSyntax TypeCref(TypeSyntax type)
    {
      if (type == null)
        throw new ArgumentNullException(nameof(type));
      return (TypeCrefSyntax)Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SyntaxFactory.TypeCref(type == null ? null : (Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.TypeSyntax)type.Green).CreateRed();
    }


    /// <summary>Creates a new QualifiedCrefSyntax instance.</summary>
    public static QualifiedCrefSyntax QualifiedCref(TypeSyntax container, SyntaxToken dotToken, MemberCrefSyntax member)
    {
      if (container == null)
        throw new ArgumentNullException(nameof(container));
      switch (dotToken.Kind())
      {
        case SyntaxKind.DotToken:
          break;
        default:
          throw new ArgumentException(nameof(dotToken));
      }
      if (member == null)
        throw new ArgumentNullException(nameof(member));
      return (QualifiedCrefSyntax)Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SyntaxFactory.QualifiedCref(container == null ? null : (Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.TypeSyntax)container.Green, (Syntax.InternalSyntax.SyntaxToken)dotToken.Node, member == null ? null : (Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.MemberCrefSyntax)member.Green).CreateRed();
    }


    /// <summary>Creates a new QualifiedCrefSyntax instance.</summary>
    public static QualifiedCrefSyntax QualifiedCref(TypeSyntax container, MemberCrefSyntax member)
    {
      return SyntaxFactory.QualifiedCref(container, SyntaxFactory.Token(SyntaxKind.DotToken), member);
    }

    /// <summary>Creates a new NameMemberCrefSyntax instance.</summary>
    public static NameMemberCrefSyntax NameMemberCref(TypeSyntax name, CrefParameterListSyntax parameters)
    {
      if (name == null)
        throw new ArgumentNullException(nameof(name));
      return (NameMemberCrefSyntax)Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SyntaxFactory.NameMemberCref(name == null ? null : (Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.TypeSyntax)name.Green, parameters == null ? null : (Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CrefParameterListSyntax)parameters.Green).CreateRed();
    }


    /// <summary>Creates a new NameMemberCrefSyntax instance.</summary>
    public static NameMemberCrefSyntax NameMemberCref(TypeSyntax name)
    {
      return SyntaxFactory.NameMemberCref(name, default(CrefParameterListSyntax));
    }

    /// <summary>Creates a new IndexerMemberCrefSyntax instance.</summary>
    public static IndexerMemberCrefSyntax IndexerMemberCref(SyntaxToken thisKeyword, CrefBracketedParameterListSyntax parameters)
    {
      switch (thisKeyword.Kind())
      {
        case SyntaxKind.ThisKeyword:
          break;
        default:
          throw new ArgumentException(nameof(thisKeyword));
      }
      return (IndexerMemberCrefSyntax)Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SyntaxFactory.IndexerMemberCref((Syntax.InternalSyntax.SyntaxToken)thisKeyword.Node, parameters == null ? null : (Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CrefBracketedParameterListSyntax)parameters.Green).CreateRed();
    }


    /// <summary>Creates a new IndexerMemberCrefSyntax instance.</summary>
    public static IndexerMemberCrefSyntax IndexerMemberCref(CrefBracketedParameterListSyntax parameters = default(CrefBracketedParameterListSyntax))
    {
      return SyntaxFactory.IndexerMemberCref(SyntaxFactory.Token(SyntaxKind.ThisKeyword), parameters);
    }

    /// <summary>Creates a new OperatorMemberCrefSyntax instance.</summary>
    public static OperatorMemberCrefSyntax OperatorMemberCref(SyntaxToken operatorKeyword, SyntaxToken operatorToken, CrefParameterListSyntax parameters)
    {
      switch (operatorKeyword.Kind())
      {
        case SyntaxKind.OperatorKeyword:
          break;
        default:
          throw new ArgumentException(nameof(operatorKeyword));
      }
      switch (operatorToken.Kind())
      {
        case SyntaxKind.PlusToken:
        case SyntaxKind.MinusToken:
        case SyntaxKind.ExclamationToken:
        case SyntaxKind.TildeToken:
        case SyntaxKind.PlusPlusToken:
        case SyntaxKind.MinusMinusToken:
        case SyntaxKind.AsteriskToken:
        case SyntaxKind.SlashToken:
        case SyntaxKind.PercentToken:
        case SyntaxKind.LessThanLessThanToken:
        case SyntaxKind.GreaterThanGreaterThanToken:
        case SyntaxKind.BarToken:
        case SyntaxKind.AmpersandToken:
        case SyntaxKind.CaretToken:
        case SyntaxKind.EqualsEqualsToken:
        case SyntaxKind.ExclamationEqualsToken:
        case SyntaxKind.LessThanToken:
        case SyntaxKind.LessThanEqualsToken:
        case SyntaxKind.GreaterThanToken:
        case SyntaxKind.GreaterThanEqualsToken:
        case SyntaxKind.FalseKeyword:
        case SyntaxKind.TrueKeyword:
          break;
        default:
          throw new ArgumentException(nameof(operatorToken));
      }
      return (OperatorMemberCrefSyntax)Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SyntaxFactory.OperatorMemberCref((Syntax.InternalSyntax.SyntaxToken)operatorKeyword.Node, (Syntax.InternalSyntax.SyntaxToken)operatorToken.Node, parameters == null ? null : (Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CrefParameterListSyntax)parameters.Green).CreateRed();
    }


    /// <summary>Creates a new OperatorMemberCrefSyntax instance.</summary>
    public static OperatorMemberCrefSyntax OperatorMemberCref(SyntaxToken operatorToken, CrefParameterListSyntax parameters)
    {
      return SyntaxFactory.OperatorMemberCref(SyntaxFactory.Token(SyntaxKind.OperatorKeyword), operatorToken, parameters);
    }

    /// <summary>Creates a new OperatorMemberCrefSyntax instance.</summary>
    public static OperatorMemberCrefSyntax OperatorMemberCref(SyntaxToken operatorToken)
    {
      return SyntaxFactory.OperatorMemberCref(SyntaxFactory.Token(SyntaxKind.OperatorKeyword), operatorToken, default(CrefParameterListSyntax));
    }

    /// <summary>Creates a new ConversionOperatorMemberCrefSyntax instance.</summary>
    public static ConversionOperatorMemberCrefSyntax ConversionOperatorMemberCref(SyntaxToken implicitOrExplicitKeyword, SyntaxToken operatorKeyword, TypeSyntax type, CrefParameterListSyntax parameters)
    {
      switch (implicitOrExplicitKeyword.Kind())
      {
        case SyntaxKind.ImplicitKeyword:
        case SyntaxKind.ExplicitKeyword:
          break;
        default:
          throw new ArgumentException(nameof(implicitOrExplicitKeyword));
      }
      switch (operatorKeyword.Kind())
      {
        case SyntaxKind.OperatorKeyword:
          break;
        default:
          throw new ArgumentException(nameof(operatorKeyword));
      }
      if (type == null)
        throw new ArgumentNullException(nameof(type));
      return (ConversionOperatorMemberCrefSyntax)Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SyntaxFactory.ConversionOperatorMemberCref((Syntax.InternalSyntax.SyntaxToken)implicitOrExplicitKeyword.Node, (Syntax.InternalSyntax.SyntaxToken)operatorKeyword.Node, type == null ? null : (Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.TypeSyntax)type.Green, parameters == null ? null : (Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CrefParameterListSyntax)parameters.Green).CreateRed();
    }


    /// <summary>Creates a new ConversionOperatorMemberCrefSyntax instance.</summary>
    public static ConversionOperatorMemberCrefSyntax ConversionOperatorMemberCref(SyntaxToken implicitOrExplicitKeyword, TypeSyntax type, CrefParameterListSyntax parameters)
    {
      return SyntaxFactory.ConversionOperatorMemberCref(implicitOrExplicitKeyword, SyntaxFactory.Token(SyntaxKind.OperatorKeyword), type, parameters);
    }

    /// <summary>Creates a new ConversionOperatorMemberCrefSyntax instance.</summary>
    public static ConversionOperatorMemberCrefSyntax ConversionOperatorMemberCref(SyntaxToken implicitOrExplicitKeyword, TypeSyntax type)
    {
      return SyntaxFactory.ConversionOperatorMemberCref(implicitOrExplicitKeyword, SyntaxFactory.Token(SyntaxKind.OperatorKeyword), type, default(CrefParameterListSyntax));
    }

    /// <summary>Creates a new CrefParameterListSyntax instance.</summary>
    public static CrefParameterListSyntax CrefParameterList(SyntaxToken openParenToken, SeparatedSyntaxList<CrefParameterSyntax> parameters, SyntaxToken closeParenToken)
    {
      switch (openParenToken.Kind())
      {
        case SyntaxKind.OpenParenToken:
          break;
        default:
          throw new ArgumentException(nameof(openParenToken));
      }
      switch (closeParenToken.Kind())
      {
        case SyntaxKind.CloseParenToken:
          break;
        default:
          throw new ArgumentException(nameof(closeParenToken));
      }
      return (CrefParameterListSyntax)Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SyntaxFactory.CrefParameterList((Syntax.InternalSyntax.SyntaxToken)openParenToken.Node, parameters.Node.ToGreenSeparatedList<Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CrefParameterSyntax>(), (Syntax.InternalSyntax.SyntaxToken)closeParenToken.Node).CreateRed();
    }


    /// <summary>Creates a new CrefParameterListSyntax instance.</summary>
    public static CrefParameterListSyntax CrefParameterList(SeparatedSyntaxList<CrefParameterSyntax> parameters = default(SeparatedSyntaxList<CrefParameterSyntax>))
    {
      return SyntaxFactory.CrefParameterList(SyntaxFactory.Token(SyntaxKind.OpenParenToken), parameters, SyntaxFactory.Token(SyntaxKind.CloseParenToken));
    }

    /// <summary>Creates a new CrefBracketedParameterListSyntax instance.</summary>
    public static CrefBracketedParameterListSyntax CrefBracketedParameterList(SyntaxToken openBracketToken, SeparatedSyntaxList<CrefParameterSyntax> parameters, SyntaxToken closeBracketToken)
    {
      switch (openBracketToken.Kind())
      {
        case SyntaxKind.OpenBracketToken:
          break;
        default:
          throw new ArgumentException(nameof(openBracketToken));
      }
      switch (closeBracketToken.Kind())
      {
        case SyntaxKind.CloseBracketToken:
          break;
        default:
          throw new ArgumentException(nameof(closeBracketToken));
      }
      return (CrefBracketedParameterListSyntax)Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SyntaxFactory.CrefBracketedParameterList((Syntax.InternalSyntax.SyntaxToken)openBracketToken.Node, parameters.Node.ToGreenSeparatedList<Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CrefParameterSyntax>(), (Syntax.InternalSyntax.SyntaxToken)closeBracketToken.Node).CreateRed();
    }


    /// <summary>Creates a new CrefBracketedParameterListSyntax instance.</summary>
    public static CrefBracketedParameterListSyntax CrefBracketedParameterList(SeparatedSyntaxList<CrefParameterSyntax> parameters = default(SeparatedSyntaxList<CrefParameterSyntax>))
    {
      return SyntaxFactory.CrefBracketedParameterList(SyntaxFactory.Token(SyntaxKind.OpenBracketToken), parameters, SyntaxFactory.Token(SyntaxKind.CloseBracketToken));
    }

    /// <summary>Creates a new CrefParameterSyntax instance.</summary>
    public static CrefParameterSyntax CrefParameter(SyntaxToken refKindKeyword, TypeSyntax type)
    {
      switch (refKindKeyword.Kind())
      {
        case SyntaxKind.RefKeyword:
        case SyntaxKind.OutKeyword:
        case SyntaxKind.InKeyword:
        case SyntaxKind.None:
          break;
        default:
          throw new ArgumentException(nameof(refKindKeyword));
      }
      if (type == null)
        throw new ArgumentNullException(nameof(type));
      return (CrefParameterSyntax)Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SyntaxFactory.CrefParameter((Syntax.InternalSyntax.SyntaxToken)refKindKeyword.Node, type == null ? null : (Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.TypeSyntax)type.Green).CreateRed();
    }


    /// <summary>Creates a new CrefParameterSyntax instance.</summary>
    public static CrefParameterSyntax CrefParameter(TypeSyntax type)
    {
      return SyntaxFactory.CrefParameter(default(SyntaxToken), type);
    }

    /// <summary>Creates a new XmlElementSyntax instance.</summary>
    public static XmlElementSyntax XmlElement(XmlElementStartTagSyntax startTag, SyntaxList<XmlNodeSyntax> content, XmlElementEndTagSyntax endTag)
    {
      if (startTag == null)
        throw new ArgumentNullException(nameof(startTag));
      if (endTag == null)
        throw new ArgumentNullException(nameof(endTag));
      return (XmlElementSyntax)Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SyntaxFactory.XmlElement(startTag == null ? null : (Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.XmlElementStartTagSyntax)startTag.Green, content.Node.ToGreenList<Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.XmlNodeSyntax>(), endTag == null ? null : (Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.XmlElementEndTagSyntax)endTag.Green).CreateRed();
    }


    /// <summary>Creates a new XmlElementSyntax instance.</summary>
    public static XmlElementSyntax XmlElement(XmlElementStartTagSyntax startTag, XmlElementEndTagSyntax endTag)
    {
      return SyntaxFactory.XmlElement(startTag, default(SyntaxList<XmlNodeSyntax>), endTag);
    }

    /// <summary>Creates a new XmlElementStartTagSyntax instance.</summary>
    public static XmlElementStartTagSyntax XmlElementStartTag(SyntaxToken lessThanToken, XmlNameSyntax name, SyntaxList<XmlAttributeSyntax> attributes, SyntaxToken greaterThanToken)
    {
      switch (lessThanToken.Kind())
      {
        case SyntaxKind.LessThanToken:
          break;
        default:
          throw new ArgumentException(nameof(lessThanToken));
      }
      if (name == null)
        throw new ArgumentNullException(nameof(name));
      switch (greaterThanToken.Kind())
      {
        case SyntaxKind.GreaterThanToken:
          break;
        default:
          throw new ArgumentException(nameof(greaterThanToken));
      }
      return (XmlElementStartTagSyntax)Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SyntaxFactory.XmlElementStartTag((Syntax.InternalSyntax.SyntaxToken)lessThanToken.Node, name == null ? null : (Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.XmlNameSyntax)name.Green, attributes.Node.ToGreenList<Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.XmlAttributeSyntax>(), (Syntax.InternalSyntax.SyntaxToken)greaterThanToken.Node).CreateRed();
    }


    /// <summary>Creates a new XmlElementStartTagSyntax instance.</summary>
    public static XmlElementStartTagSyntax XmlElementStartTag(XmlNameSyntax name, SyntaxList<XmlAttributeSyntax> attributes)
    {
      return SyntaxFactory.XmlElementStartTag(SyntaxFactory.Token(SyntaxKind.LessThanToken), name, attributes, SyntaxFactory.Token(SyntaxKind.GreaterThanToken));
    }

    /// <summary>Creates a new XmlElementStartTagSyntax instance.</summary>
    public static XmlElementStartTagSyntax XmlElementStartTag(XmlNameSyntax name)
    {
      return SyntaxFactory.XmlElementStartTag(SyntaxFactory.Token(SyntaxKind.LessThanToken), name, default(SyntaxList<XmlAttributeSyntax>), SyntaxFactory.Token(SyntaxKind.GreaterThanToken));
    }

    /// <summary>Creates a new XmlElementEndTagSyntax instance.</summary>
    public static XmlElementEndTagSyntax XmlElementEndTag(SyntaxToken lessThanSlashToken, XmlNameSyntax name, SyntaxToken greaterThanToken)
    {
      switch (lessThanSlashToken.Kind())
      {
        case SyntaxKind.LessThanSlashToken:
          break;
        default:
          throw new ArgumentException(nameof(lessThanSlashToken));
      }
      if (name == null)
        throw new ArgumentNullException(nameof(name));
      switch (greaterThanToken.Kind())
      {
        case SyntaxKind.GreaterThanToken:
          break;
        default:
          throw new ArgumentException(nameof(greaterThanToken));
      }
      return (XmlElementEndTagSyntax)Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SyntaxFactory.XmlElementEndTag((Syntax.InternalSyntax.SyntaxToken)lessThanSlashToken.Node, name == null ? null : (Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.XmlNameSyntax)name.Green, (Syntax.InternalSyntax.SyntaxToken)greaterThanToken.Node).CreateRed();
    }


    /// <summary>Creates a new XmlElementEndTagSyntax instance.</summary>
    public static XmlElementEndTagSyntax XmlElementEndTag(XmlNameSyntax name)
    {
      return SyntaxFactory.XmlElementEndTag(SyntaxFactory.Token(SyntaxKind.LessThanSlashToken), name, SyntaxFactory.Token(SyntaxKind.GreaterThanToken));
    }

    /// <summary>Creates a new XmlEmptyElementSyntax instance.</summary>
    public static XmlEmptyElementSyntax XmlEmptyElement(SyntaxToken lessThanToken, XmlNameSyntax name, SyntaxList<XmlAttributeSyntax> attributes, SyntaxToken slashGreaterThanToken)
    {
      switch (lessThanToken.Kind())
      {
        case SyntaxKind.LessThanToken:
          break;
        default:
          throw new ArgumentException(nameof(lessThanToken));
      }
      if (name == null)
        throw new ArgumentNullException(nameof(name));
      switch (slashGreaterThanToken.Kind())
      {
        case SyntaxKind.SlashGreaterThanToken:
          break;
        default:
          throw new ArgumentException(nameof(slashGreaterThanToken));
      }
      return (XmlEmptyElementSyntax)Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SyntaxFactory.XmlEmptyElement((Syntax.InternalSyntax.SyntaxToken)lessThanToken.Node, name == null ? null : (Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.XmlNameSyntax)name.Green, attributes.Node.ToGreenList<Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.XmlAttributeSyntax>(), (Syntax.InternalSyntax.SyntaxToken)slashGreaterThanToken.Node).CreateRed();
    }


    /// <summary>Creates a new XmlEmptyElementSyntax instance.</summary>
    public static XmlEmptyElementSyntax XmlEmptyElement(XmlNameSyntax name, SyntaxList<XmlAttributeSyntax> attributes)
    {
      return SyntaxFactory.XmlEmptyElement(SyntaxFactory.Token(SyntaxKind.LessThanToken), name, attributes, SyntaxFactory.Token(SyntaxKind.SlashGreaterThanToken));
    }

    /// <summary>Creates a new XmlEmptyElementSyntax instance.</summary>
    public static XmlEmptyElementSyntax XmlEmptyElement(XmlNameSyntax name)
    {
      return SyntaxFactory.XmlEmptyElement(SyntaxFactory.Token(SyntaxKind.LessThanToken), name, default(SyntaxList<XmlAttributeSyntax>), SyntaxFactory.Token(SyntaxKind.SlashGreaterThanToken));
    }

    /// <summary>Creates a new XmlNameSyntax instance.</summary>
    public static XmlNameSyntax XmlName(XmlPrefixSyntax prefix, SyntaxToken localName)
    {
      switch (localName.Kind())
      {
        case SyntaxKind.IdentifierToken:
          break;
        default:
          throw new ArgumentException(nameof(localName));
      }
      return (XmlNameSyntax)Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SyntaxFactory.XmlName(prefix == null ? null : (Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.XmlPrefixSyntax)prefix.Green, (Syntax.InternalSyntax.SyntaxToken)localName.Node).CreateRed();
    }


    /// <summary>Creates a new XmlNameSyntax instance.</summary>
    public static XmlNameSyntax XmlName(SyntaxToken localName)
    {
      return SyntaxFactory.XmlName(default(XmlPrefixSyntax), localName);
    }

    /// <summary>Creates a new XmlNameSyntax instance.</summary>
    public static XmlNameSyntax XmlName(string localName)
    {
      return SyntaxFactory.XmlName(default(XmlPrefixSyntax), SyntaxFactory.Identifier(localName));
    }

    /// <summary>Creates a new XmlPrefixSyntax instance.</summary>
    public static XmlPrefixSyntax XmlPrefix(SyntaxToken prefix, SyntaxToken colonToken)
    {
      switch (prefix.Kind())
      {
        case SyntaxKind.IdentifierToken:
          break;
        default:
          throw new ArgumentException(nameof(prefix));
      }
      switch (colonToken.Kind())
      {
        case SyntaxKind.ColonToken:
          break;
        default:
          throw new ArgumentException(nameof(colonToken));
      }
      return (XmlPrefixSyntax)Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SyntaxFactory.XmlPrefix((Syntax.InternalSyntax.SyntaxToken)prefix.Node, (Syntax.InternalSyntax.SyntaxToken)colonToken.Node).CreateRed();
    }


    /// <summary>Creates a new XmlPrefixSyntax instance.</summary>
    public static XmlPrefixSyntax XmlPrefix(SyntaxToken prefix)
    {
      return SyntaxFactory.XmlPrefix(prefix, SyntaxFactory.Token(SyntaxKind.ColonToken));
    }

    /// <summary>Creates a new XmlPrefixSyntax instance.</summary>
    public static XmlPrefixSyntax XmlPrefix(string prefix)
    {
      return SyntaxFactory.XmlPrefix(SyntaxFactory.Identifier(prefix), SyntaxFactory.Token(SyntaxKind.ColonToken));
    }

    /// <summary>Creates a new XmlTextAttributeSyntax instance.</summary>
    public static XmlTextAttributeSyntax XmlTextAttribute(XmlNameSyntax name, SyntaxToken equalsToken, SyntaxToken startQuoteToken, SyntaxTokenList textTokens, SyntaxToken endQuoteToken)
    {
      if (name == null)
        throw new ArgumentNullException(nameof(name));
      switch (equalsToken.Kind())
      {
        case SyntaxKind.EqualsToken:
          break;
        default:
          throw new ArgumentException(nameof(equalsToken));
      }
      switch (startQuoteToken.Kind())
      {
        case SyntaxKind.SingleQuoteToken:
        case SyntaxKind.DoubleQuoteToken:
          break;
        default:
          throw new ArgumentException(nameof(startQuoteToken));
      }
      switch (endQuoteToken.Kind())
      {
        case SyntaxKind.SingleQuoteToken:
        case SyntaxKind.DoubleQuoteToken:
          break;
        default:
          throw new ArgumentException(nameof(endQuoteToken));
      }
      return (XmlTextAttributeSyntax)Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SyntaxFactory.XmlTextAttribute(name == null ? null : (Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.XmlNameSyntax)name.Green, (Syntax.InternalSyntax.SyntaxToken)equalsToken.Node, (Syntax.InternalSyntax.SyntaxToken)startQuoteToken.Node, textTokens.Node.ToGreenList<Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SyntaxToken>(), (Syntax.InternalSyntax.SyntaxToken)endQuoteToken.Node).CreateRed();
    }


    /// <summary>Creates a new XmlTextAttributeSyntax instance.</summary>
    public static XmlTextAttributeSyntax XmlTextAttribute(XmlNameSyntax name, SyntaxToken startQuoteToken, SyntaxTokenList textTokens, SyntaxToken endQuoteToken)
    {
      return SyntaxFactory.XmlTextAttribute(name, SyntaxFactory.Token(SyntaxKind.EqualsToken), startQuoteToken, textTokens, endQuoteToken);
    }

    /// <summary>Creates a new XmlTextAttributeSyntax instance.</summary>
    public static XmlTextAttributeSyntax XmlTextAttribute(XmlNameSyntax name, SyntaxToken startQuoteToken, SyntaxToken endQuoteToken)
    {
      return SyntaxFactory.XmlTextAttribute(name, SyntaxFactory.Token(SyntaxKind.EqualsToken), startQuoteToken, default(SyntaxTokenList), endQuoteToken);
    }

    /// <summary>Creates a new XmlCrefAttributeSyntax instance.</summary>
    public static XmlCrefAttributeSyntax XmlCrefAttribute(XmlNameSyntax name, SyntaxToken equalsToken, SyntaxToken startQuoteToken, CrefSyntax cref, SyntaxToken endQuoteToken)
    {
      if (name == null)
        throw new ArgumentNullException(nameof(name));
      switch (equalsToken.Kind())
      {
        case SyntaxKind.EqualsToken:
          break;
        default:
          throw new ArgumentException(nameof(equalsToken));
      }
      switch (startQuoteToken.Kind())
      {
        case SyntaxKind.SingleQuoteToken:
        case SyntaxKind.DoubleQuoteToken:
          break;
        default:
          throw new ArgumentException(nameof(startQuoteToken));
      }
      if (cref == null)
        throw new ArgumentNullException(nameof(cref));
      switch (endQuoteToken.Kind())
      {
        case SyntaxKind.SingleQuoteToken:
        case SyntaxKind.DoubleQuoteToken:
          break;
        default:
          throw new ArgumentException(nameof(endQuoteToken));
      }
      return (XmlCrefAttributeSyntax)Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SyntaxFactory.XmlCrefAttribute(name == null ? null : (Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.XmlNameSyntax)name.Green, (Syntax.InternalSyntax.SyntaxToken)equalsToken.Node, (Syntax.InternalSyntax.SyntaxToken)startQuoteToken.Node, cref == null ? null : (Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CrefSyntax)cref.Green, (Syntax.InternalSyntax.SyntaxToken)endQuoteToken.Node).CreateRed();
    }


    /// <summary>Creates a new XmlCrefAttributeSyntax instance.</summary>
    public static XmlCrefAttributeSyntax XmlCrefAttribute(XmlNameSyntax name, SyntaxToken startQuoteToken, CrefSyntax cref, SyntaxToken endQuoteToken)
    {
      return SyntaxFactory.XmlCrefAttribute(name, SyntaxFactory.Token(SyntaxKind.EqualsToken), startQuoteToken, cref, endQuoteToken);
    }

    /// <summary>Creates a new XmlNameAttributeSyntax instance.</summary>
    public static XmlNameAttributeSyntax XmlNameAttribute(XmlNameSyntax name, SyntaxToken equalsToken, SyntaxToken startQuoteToken, IdentifierNameSyntax identifier, SyntaxToken endQuoteToken)
    {
      if (name == null)
        throw new ArgumentNullException(nameof(name));
      switch (equalsToken.Kind())
      {
        case SyntaxKind.EqualsToken:
          break;
        default:
          throw new ArgumentException(nameof(equalsToken));
      }
      switch (startQuoteToken.Kind())
      {
        case SyntaxKind.SingleQuoteToken:
        case SyntaxKind.DoubleQuoteToken:
          break;
        default:
          throw new ArgumentException(nameof(startQuoteToken));
      }
      if (identifier == null)
        throw new ArgumentNullException(nameof(identifier));
      switch (endQuoteToken.Kind())
      {
        case SyntaxKind.SingleQuoteToken:
        case SyntaxKind.DoubleQuoteToken:
          break;
        default:
          throw new ArgumentException(nameof(endQuoteToken));
      }
      return (XmlNameAttributeSyntax)Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SyntaxFactory.XmlNameAttribute(name == null ? null : (Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.XmlNameSyntax)name.Green, (Syntax.InternalSyntax.SyntaxToken)equalsToken.Node, (Syntax.InternalSyntax.SyntaxToken)startQuoteToken.Node, identifier == null ? null : (Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.IdentifierNameSyntax)identifier.Green, (Syntax.InternalSyntax.SyntaxToken)endQuoteToken.Node).CreateRed();
    }


    /// <summary>Creates a new XmlNameAttributeSyntax instance.</summary>
    public static XmlNameAttributeSyntax XmlNameAttribute(XmlNameSyntax name, SyntaxToken startQuoteToken, IdentifierNameSyntax identifier, SyntaxToken endQuoteToken)
    {
      return SyntaxFactory.XmlNameAttribute(name, SyntaxFactory.Token(SyntaxKind.EqualsToken), startQuoteToken, identifier, endQuoteToken);
    }

    /// <summary>Creates a new XmlNameAttributeSyntax instance.</summary>
    public static XmlNameAttributeSyntax XmlNameAttribute(XmlNameSyntax name, SyntaxToken startQuoteToken, string identifier, SyntaxToken endQuoteToken)
    {
      return SyntaxFactory.XmlNameAttribute(name, SyntaxFactory.Token(SyntaxKind.EqualsToken), startQuoteToken, SyntaxFactory.IdentifierName(identifier), endQuoteToken);
    }

    /// <summary>Creates a new XmlTextSyntax instance.</summary>
    public static XmlTextSyntax XmlText(SyntaxTokenList textTokens)
    {
      return (XmlTextSyntax)Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SyntaxFactory.XmlText(textTokens.Node.ToGreenList<Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SyntaxToken>()).CreateRed();
    }


    /// <summary>Creates a new XmlTextSyntax instance.</summary>
    public static XmlTextSyntax XmlText()
    {
      return SyntaxFactory.XmlText(default(SyntaxTokenList));
    }

    /// <summary>Creates a new XmlCDataSectionSyntax instance.</summary>
    public static XmlCDataSectionSyntax XmlCDataSection(SyntaxToken startCDataToken, SyntaxTokenList textTokens, SyntaxToken endCDataToken)
    {
      switch (startCDataToken.Kind())
      {
        case SyntaxKind.XmlCDataStartToken:
          break;
        default:
          throw new ArgumentException(nameof(startCDataToken));
      }
      switch (endCDataToken.Kind())
      {
        case SyntaxKind.XmlCDataEndToken:
          break;
        default:
          throw new ArgumentException(nameof(endCDataToken));
      }
      return (XmlCDataSectionSyntax)Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SyntaxFactory.XmlCDataSection((Syntax.InternalSyntax.SyntaxToken)startCDataToken.Node, textTokens.Node.ToGreenList<Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SyntaxToken>(), (Syntax.InternalSyntax.SyntaxToken)endCDataToken.Node).CreateRed();
    }


    /// <summary>Creates a new XmlCDataSectionSyntax instance.</summary>
    public static XmlCDataSectionSyntax XmlCDataSection(SyntaxTokenList textTokens = default(SyntaxTokenList))
    {
      return SyntaxFactory.XmlCDataSection(SyntaxFactory.Token(SyntaxKind.XmlCDataStartToken), textTokens, SyntaxFactory.Token(SyntaxKind.XmlCDataEndToken));
    }

    /// <summary>Creates a new XmlProcessingInstructionSyntax instance.</summary>
    public static XmlProcessingInstructionSyntax XmlProcessingInstruction(SyntaxToken startProcessingInstructionToken, XmlNameSyntax name, SyntaxTokenList textTokens, SyntaxToken endProcessingInstructionToken)
    {
      switch (startProcessingInstructionToken.Kind())
      {
        case SyntaxKind.XmlProcessingInstructionStartToken:
          break;
        default:
          throw new ArgumentException(nameof(startProcessingInstructionToken));
      }
      if (name == null)
        throw new ArgumentNullException(nameof(name));
      switch (endProcessingInstructionToken.Kind())
      {
        case SyntaxKind.XmlProcessingInstructionEndToken:
          break;
        default:
          throw new ArgumentException(nameof(endProcessingInstructionToken));
      }
      return (XmlProcessingInstructionSyntax)Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SyntaxFactory.XmlProcessingInstruction((Syntax.InternalSyntax.SyntaxToken)startProcessingInstructionToken.Node, name == null ? null : (Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.XmlNameSyntax)name.Green, textTokens.Node.ToGreenList<Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SyntaxToken>(), (Syntax.InternalSyntax.SyntaxToken)endProcessingInstructionToken.Node).CreateRed();
    }


    /// <summary>Creates a new XmlProcessingInstructionSyntax instance.</summary>
    public static XmlProcessingInstructionSyntax XmlProcessingInstruction(XmlNameSyntax name, SyntaxTokenList textTokens)
    {
      return SyntaxFactory.XmlProcessingInstruction(SyntaxFactory.Token(SyntaxKind.XmlProcessingInstructionStartToken), name, textTokens, SyntaxFactory.Token(SyntaxKind.XmlProcessingInstructionEndToken));
    }

    /// <summary>Creates a new XmlProcessingInstructionSyntax instance.</summary>
    public static XmlProcessingInstructionSyntax XmlProcessingInstruction(XmlNameSyntax name)
    {
      return SyntaxFactory.XmlProcessingInstruction(SyntaxFactory.Token(SyntaxKind.XmlProcessingInstructionStartToken), name, default(SyntaxTokenList), SyntaxFactory.Token(SyntaxKind.XmlProcessingInstructionEndToken));
    }

    /// <summary>Creates a new XmlCommentSyntax instance.</summary>
    public static XmlCommentSyntax XmlComment(SyntaxToken lessThanExclamationMinusMinusToken, SyntaxTokenList textTokens, SyntaxToken minusMinusGreaterThanToken)
    {
      switch (lessThanExclamationMinusMinusToken.Kind())
      {
        case SyntaxKind.XmlCommentStartToken:
          break;
        default:
          throw new ArgumentException(nameof(lessThanExclamationMinusMinusToken));
      }
      switch (minusMinusGreaterThanToken.Kind())
      {
        case SyntaxKind.XmlCommentEndToken:
          break;
        default:
          throw new ArgumentException(nameof(minusMinusGreaterThanToken));
      }
      return (XmlCommentSyntax)Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SyntaxFactory.XmlComment((Syntax.InternalSyntax.SyntaxToken)lessThanExclamationMinusMinusToken.Node, textTokens.Node.ToGreenList<Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SyntaxToken>(), (Syntax.InternalSyntax.SyntaxToken)minusMinusGreaterThanToken.Node).CreateRed();
    }


    /// <summary>Creates a new XmlCommentSyntax instance.</summary>
    public static XmlCommentSyntax XmlComment(SyntaxTokenList textTokens = default(SyntaxTokenList))
    {
      return SyntaxFactory.XmlComment(SyntaxFactory.Token(SyntaxKind.XmlCommentStartToken), textTokens, SyntaxFactory.Token(SyntaxKind.XmlCommentEndToken));
    }

    /// <summary>Creates a new IfDirectiveTriviaSyntax instance.</summary>
    public static IfDirectiveTriviaSyntax IfDirectiveTrivia(SyntaxToken hashToken, SyntaxToken ifKeyword, ExpressionSyntax condition, SyntaxToken endOfDirectiveToken, bool isActive, bool branchTaken, bool conditionValue)
    {
      switch (hashToken.Kind())
      {
        case SyntaxKind.HashToken:
          break;
        default:
          throw new ArgumentException(nameof(hashToken));
      }
      switch (ifKeyword.Kind())
      {
        case SyntaxKind.IfKeyword:
          break;
        default:
          throw new ArgumentException(nameof(ifKeyword));
      }
      if (condition == null)
        throw new ArgumentNullException(nameof(condition));
      switch (endOfDirectiveToken.Kind())
      {
        case SyntaxKind.EndOfDirectiveToken:
          break;
        default:
          throw new ArgumentException(nameof(endOfDirectiveToken));
      }
      return (IfDirectiveTriviaSyntax)Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SyntaxFactory.IfDirectiveTrivia((Syntax.InternalSyntax.SyntaxToken)hashToken.Node, (Syntax.InternalSyntax.SyntaxToken)ifKeyword.Node, condition == null ? null : (Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.ExpressionSyntax)condition.Green, (Syntax.InternalSyntax.SyntaxToken)endOfDirectiveToken.Node, isActive, branchTaken, conditionValue).CreateRed();
    }


    /// <summary>Creates a new IfDirectiveTriviaSyntax instance.</summary>
    public static IfDirectiveTriviaSyntax IfDirectiveTrivia(ExpressionSyntax condition, bool isActive, bool branchTaken, bool conditionValue)
    {
      return SyntaxFactory.IfDirectiveTrivia(SyntaxFactory.Token(SyntaxKind.HashToken), SyntaxFactory.Token(SyntaxKind.IfKeyword), condition, SyntaxFactory.Token(SyntaxKind.EndOfDirectiveToken), isActive, branchTaken, conditionValue);
    }

    /// <summary>Creates a new ElifDirectiveTriviaSyntax instance.</summary>
    public static ElifDirectiveTriviaSyntax ElifDirectiveTrivia(SyntaxToken hashToken, SyntaxToken elifKeyword, ExpressionSyntax condition, SyntaxToken endOfDirectiveToken, bool isActive, bool branchTaken, bool conditionValue)
    {
      switch (hashToken.Kind())
      {
        case SyntaxKind.HashToken:
          break;
        default:
          throw new ArgumentException(nameof(hashToken));
      }
      switch (elifKeyword.Kind())
      {
        case SyntaxKind.ElifKeyword:
          break;
        default:
          throw new ArgumentException(nameof(elifKeyword));
      }
      if (condition == null)
        throw new ArgumentNullException(nameof(condition));
      switch (endOfDirectiveToken.Kind())
      {
        case SyntaxKind.EndOfDirectiveToken:
          break;
        default:
          throw new ArgumentException(nameof(endOfDirectiveToken));
      }
      return (ElifDirectiveTriviaSyntax)Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SyntaxFactory.ElifDirectiveTrivia((Syntax.InternalSyntax.SyntaxToken)hashToken.Node, (Syntax.InternalSyntax.SyntaxToken)elifKeyword.Node, condition == null ? null : (Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.ExpressionSyntax)condition.Green, (Syntax.InternalSyntax.SyntaxToken)endOfDirectiveToken.Node, isActive, branchTaken, conditionValue).CreateRed();
    }


    /// <summary>Creates a new ElifDirectiveTriviaSyntax instance.</summary>
    public static ElifDirectiveTriviaSyntax ElifDirectiveTrivia(ExpressionSyntax condition, bool isActive, bool branchTaken, bool conditionValue)
    {
      return SyntaxFactory.ElifDirectiveTrivia(SyntaxFactory.Token(SyntaxKind.HashToken), SyntaxFactory.Token(SyntaxKind.ElifKeyword), condition, SyntaxFactory.Token(SyntaxKind.EndOfDirectiveToken), isActive, branchTaken, conditionValue);
    }

    /// <summary>Creates a new ElseDirectiveTriviaSyntax instance.</summary>
    public static ElseDirectiveTriviaSyntax ElseDirectiveTrivia(SyntaxToken hashToken, SyntaxToken elseKeyword, SyntaxToken endOfDirectiveToken, bool isActive, bool branchTaken)
    {
      switch (hashToken.Kind())
      {
        case SyntaxKind.HashToken:
          break;
        default:
          throw new ArgumentException(nameof(hashToken));
      }
      switch (elseKeyword.Kind())
      {
        case SyntaxKind.ElseKeyword:
          break;
        default:
          throw new ArgumentException(nameof(elseKeyword));
      }
      switch (endOfDirectiveToken.Kind())
      {
        case SyntaxKind.EndOfDirectiveToken:
          break;
        default:
          throw new ArgumentException(nameof(endOfDirectiveToken));
      }
      return (ElseDirectiveTriviaSyntax)Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SyntaxFactory.ElseDirectiveTrivia((Syntax.InternalSyntax.SyntaxToken)hashToken.Node, (Syntax.InternalSyntax.SyntaxToken)elseKeyword.Node, (Syntax.InternalSyntax.SyntaxToken)endOfDirectiveToken.Node, isActive, branchTaken).CreateRed();
    }


    /// <summary>Creates a new ElseDirectiveTriviaSyntax instance.</summary>
    public static ElseDirectiveTriviaSyntax ElseDirectiveTrivia(bool isActive, bool branchTaken)
    {
      return SyntaxFactory.ElseDirectiveTrivia(SyntaxFactory.Token(SyntaxKind.HashToken), SyntaxFactory.Token(SyntaxKind.ElseKeyword), SyntaxFactory.Token(SyntaxKind.EndOfDirectiveToken), isActive, branchTaken);
    }

    /// <summary>Creates a new EndIfDirectiveTriviaSyntax instance.</summary>
    public static EndIfDirectiveTriviaSyntax EndIfDirectiveTrivia(SyntaxToken hashToken, SyntaxToken endIfKeyword, SyntaxToken endOfDirectiveToken, bool isActive)
    {
      switch (hashToken.Kind())
      {
        case SyntaxKind.HashToken:
          break;
        default:
          throw new ArgumentException(nameof(hashToken));
      }
      switch (endIfKeyword.Kind())
      {
        case SyntaxKind.EndIfKeyword:
          break;
        default:
          throw new ArgumentException(nameof(endIfKeyword));
      }
      switch (endOfDirectiveToken.Kind())
      {
        case SyntaxKind.EndOfDirectiveToken:
          break;
        default:
          throw new ArgumentException(nameof(endOfDirectiveToken));
      }
      return (EndIfDirectiveTriviaSyntax)Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SyntaxFactory.EndIfDirectiveTrivia((Syntax.InternalSyntax.SyntaxToken)hashToken.Node, (Syntax.InternalSyntax.SyntaxToken)endIfKeyword.Node, (Syntax.InternalSyntax.SyntaxToken)endOfDirectiveToken.Node, isActive).CreateRed();
    }


    /// <summary>Creates a new EndIfDirectiveTriviaSyntax instance.</summary>
    public static EndIfDirectiveTriviaSyntax EndIfDirectiveTrivia(bool isActive)
    {
      return SyntaxFactory.EndIfDirectiveTrivia(SyntaxFactory.Token(SyntaxKind.HashToken), SyntaxFactory.Token(SyntaxKind.EndIfKeyword), SyntaxFactory.Token(SyntaxKind.EndOfDirectiveToken), isActive);
    }

    /// <summary>Creates a new RegionDirectiveTriviaSyntax instance.</summary>
    public static RegionDirectiveTriviaSyntax RegionDirectiveTrivia(SyntaxToken hashToken, SyntaxToken regionKeyword, SyntaxToken endOfDirectiveToken, bool isActive)
    {
      switch (hashToken.Kind())
      {
        case SyntaxKind.HashToken:
          break;
        default:
          throw new ArgumentException(nameof(hashToken));
      }
      switch (regionKeyword.Kind())
      {
        case SyntaxKind.RegionKeyword:
          break;
        default:
          throw new ArgumentException(nameof(regionKeyword));
      }
      switch (endOfDirectiveToken.Kind())
      {
        case SyntaxKind.EndOfDirectiveToken:
          break;
        default:
          throw new ArgumentException(nameof(endOfDirectiveToken));
      }
      return (RegionDirectiveTriviaSyntax)Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SyntaxFactory.RegionDirectiveTrivia((Syntax.InternalSyntax.SyntaxToken)hashToken.Node, (Syntax.InternalSyntax.SyntaxToken)regionKeyword.Node, (Syntax.InternalSyntax.SyntaxToken)endOfDirectiveToken.Node, isActive).CreateRed();
    }


    /// <summary>Creates a new RegionDirectiveTriviaSyntax instance.</summary>
    public static RegionDirectiveTriviaSyntax RegionDirectiveTrivia(bool isActive)
    {
      return SyntaxFactory.RegionDirectiveTrivia(SyntaxFactory.Token(SyntaxKind.HashToken), SyntaxFactory.Token(SyntaxKind.RegionKeyword), SyntaxFactory.Token(SyntaxKind.EndOfDirectiveToken), isActive);
    }

    /// <summary>Creates a new EndRegionDirectiveTriviaSyntax instance.</summary>
    public static EndRegionDirectiveTriviaSyntax EndRegionDirectiveTrivia(SyntaxToken hashToken, SyntaxToken endRegionKeyword, SyntaxToken endOfDirectiveToken, bool isActive)
    {
      switch (hashToken.Kind())
      {
        case SyntaxKind.HashToken:
          break;
        default:
          throw new ArgumentException(nameof(hashToken));
      }
      switch (endRegionKeyword.Kind())
      {
        case SyntaxKind.EndRegionKeyword:
          break;
        default:
          throw new ArgumentException(nameof(endRegionKeyword));
      }
      switch (endOfDirectiveToken.Kind())
      {
        case SyntaxKind.EndOfDirectiveToken:
          break;
        default:
          throw new ArgumentException(nameof(endOfDirectiveToken));
      }
      return (EndRegionDirectiveTriviaSyntax)Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SyntaxFactory.EndRegionDirectiveTrivia((Syntax.InternalSyntax.SyntaxToken)hashToken.Node, (Syntax.InternalSyntax.SyntaxToken)endRegionKeyword.Node, (Syntax.InternalSyntax.SyntaxToken)endOfDirectiveToken.Node, isActive).CreateRed();
    }


    /// <summary>Creates a new EndRegionDirectiveTriviaSyntax instance.</summary>
    public static EndRegionDirectiveTriviaSyntax EndRegionDirectiveTrivia(bool isActive)
    {
      return SyntaxFactory.EndRegionDirectiveTrivia(SyntaxFactory.Token(SyntaxKind.HashToken), SyntaxFactory.Token(SyntaxKind.EndRegionKeyword), SyntaxFactory.Token(SyntaxKind.EndOfDirectiveToken), isActive);
    }

    /// <summary>Creates a new ErrorDirectiveTriviaSyntax instance.</summary>
    public static ErrorDirectiveTriviaSyntax ErrorDirectiveTrivia(SyntaxToken hashToken, SyntaxToken errorKeyword, SyntaxToken endOfDirectiveToken, bool isActive)
    {
      switch (hashToken.Kind())
      {
        case SyntaxKind.HashToken:
          break;
        default:
          throw new ArgumentException(nameof(hashToken));
      }
      switch (errorKeyword.Kind())
      {
        case SyntaxKind.ErrorKeyword:
          break;
        default:
          throw new ArgumentException(nameof(errorKeyword));
      }
      switch (endOfDirectiveToken.Kind())
      {
        case SyntaxKind.EndOfDirectiveToken:
          break;
        default:
          throw new ArgumentException(nameof(endOfDirectiveToken));
      }
      return (ErrorDirectiveTriviaSyntax)Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SyntaxFactory.ErrorDirectiveTrivia((Syntax.InternalSyntax.SyntaxToken)hashToken.Node, (Syntax.InternalSyntax.SyntaxToken)errorKeyword.Node, (Syntax.InternalSyntax.SyntaxToken)endOfDirectiveToken.Node, isActive).CreateRed();
    }


    /// <summary>Creates a new ErrorDirectiveTriviaSyntax instance.</summary>
    public static ErrorDirectiveTriviaSyntax ErrorDirectiveTrivia(bool isActive)
    {
      return SyntaxFactory.ErrorDirectiveTrivia(SyntaxFactory.Token(SyntaxKind.HashToken), SyntaxFactory.Token(SyntaxKind.ErrorKeyword), SyntaxFactory.Token(SyntaxKind.EndOfDirectiveToken), isActive);
    }

    /// <summary>Creates a new WarningDirectiveTriviaSyntax instance.</summary>
    public static WarningDirectiveTriviaSyntax WarningDirectiveTrivia(SyntaxToken hashToken, SyntaxToken warningKeyword, SyntaxToken endOfDirectiveToken, bool isActive)
    {
      switch (hashToken.Kind())
      {
        case SyntaxKind.HashToken:
          break;
        default:
          throw new ArgumentException(nameof(hashToken));
      }
      switch (warningKeyword.Kind())
      {
        case SyntaxKind.WarningKeyword:
          break;
        default:
          throw new ArgumentException(nameof(warningKeyword));
      }
      switch (endOfDirectiveToken.Kind())
      {
        case SyntaxKind.EndOfDirectiveToken:
          break;
        default:
          throw new ArgumentException(nameof(endOfDirectiveToken));
      }
      return (WarningDirectiveTriviaSyntax)Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SyntaxFactory.WarningDirectiveTrivia((Syntax.InternalSyntax.SyntaxToken)hashToken.Node, (Syntax.InternalSyntax.SyntaxToken)warningKeyword.Node, (Syntax.InternalSyntax.SyntaxToken)endOfDirectiveToken.Node, isActive).CreateRed();
    }


    /// <summary>Creates a new WarningDirectiveTriviaSyntax instance.</summary>
    public static WarningDirectiveTriviaSyntax WarningDirectiveTrivia(bool isActive)
    {
      return SyntaxFactory.WarningDirectiveTrivia(SyntaxFactory.Token(SyntaxKind.HashToken), SyntaxFactory.Token(SyntaxKind.WarningKeyword), SyntaxFactory.Token(SyntaxKind.EndOfDirectiveToken), isActive);
    }

    /// <summary>Creates a new BadDirectiveTriviaSyntax instance.</summary>
    public static BadDirectiveTriviaSyntax BadDirectiveTrivia(SyntaxToken hashToken, SyntaxToken identifier, SyntaxToken endOfDirectiveToken, bool isActive)
    {
      switch (hashToken.Kind())
      {
        case SyntaxKind.HashToken:
          break;
        default:
          throw new ArgumentException(nameof(hashToken));
      }
      switch (endOfDirectiveToken.Kind())
      {
        case SyntaxKind.EndOfDirectiveToken:
          break;
        default:
          throw new ArgumentException(nameof(endOfDirectiveToken));
      }
      return (BadDirectiveTriviaSyntax)Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SyntaxFactory.BadDirectiveTrivia((Syntax.InternalSyntax.SyntaxToken)hashToken.Node, (Syntax.InternalSyntax.SyntaxToken)identifier.Node, (Syntax.InternalSyntax.SyntaxToken)endOfDirectiveToken.Node, isActive).CreateRed();
    }


    /// <summary>Creates a new BadDirectiveTriviaSyntax instance.</summary>
    public static BadDirectiveTriviaSyntax BadDirectiveTrivia(SyntaxToken identifier, bool isActive)
    {
      return SyntaxFactory.BadDirectiveTrivia(SyntaxFactory.Token(SyntaxKind.HashToken), identifier, SyntaxFactory.Token(SyntaxKind.EndOfDirectiveToken), isActive);
    }

    /// <summary>Creates a new DefineDirectiveTriviaSyntax instance.</summary>
    public static DefineDirectiveTriviaSyntax DefineDirectiveTrivia(SyntaxToken hashToken, SyntaxToken defineKeyword, SyntaxToken name, SyntaxToken endOfDirectiveToken, bool isActive)
    {
      switch (hashToken.Kind())
      {
        case SyntaxKind.HashToken:
          break;
        default:
          throw new ArgumentException(nameof(hashToken));
      }
      switch (defineKeyword.Kind())
      {
        case SyntaxKind.DefineKeyword:
          break;
        default:
          throw new ArgumentException(nameof(defineKeyword));
      }
      switch (name.Kind())
      {
        case SyntaxKind.IdentifierToken:
          break;
        default:
          throw new ArgumentException(nameof(name));
      }
      switch (endOfDirectiveToken.Kind())
      {
        case SyntaxKind.EndOfDirectiveToken:
          break;
        default:
          throw new ArgumentException(nameof(endOfDirectiveToken));
      }
      return (DefineDirectiveTriviaSyntax)Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SyntaxFactory.DefineDirectiveTrivia((Syntax.InternalSyntax.SyntaxToken)hashToken.Node, (Syntax.InternalSyntax.SyntaxToken)defineKeyword.Node, (Syntax.InternalSyntax.SyntaxToken)name.Node, (Syntax.InternalSyntax.SyntaxToken)endOfDirectiveToken.Node, isActive).CreateRed();
    }


    /// <summary>Creates a new DefineDirectiveTriviaSyntax instance.</summary>
    public static DefineDirectiveTriviaSyntax DefineDirectiveTrivia(SyntaxToken name, bool isActive)
    {
      return SyntaxFactory.DefineDirectiveTrivia(SyntaxFactory.Token(SyntaxKind.HashToken), SyntaxFactory.Token(SyntaxKind.DefineKeyword), name, SyntaxFactory.Token(SyntaxKind.EndOfDirectiveToken), isActive);
    }

    /// <summary>Creates a new DefineDirectiveTriviaSyntax instance.</summary>
    public static DefineDirectiveTriviaSyntax DefineDirectiveTrivia(string name, bool isActive)
    {
      return SyntaxFactory.DefineDirectiveTrivia(SyntaxFactory.Token(SyntaxKind.HashToken), SyntaxFactory.Token(SyntaxKind.DefineKeyword), SyntaxFactory.Identifier(name), SyntaxFactory.Token(SyntaxKind.EndOfDirectiveToken), isActive);
    }

    /// <summary>Creates a new UndefDirectiveTriviaSyntax instance.</summary>
    public static UndefDirectiveTriviaSyntax UndefDirectiveTrivia(SyntaxToken hashToken, SyntaxToken undefKeyword, SyntaxToken name, SyntaxToken endOfDirectiveToken, bool isActive)
    {
      switch (hashToken.Kind())
      {
        case SyntaxKind.HashToken:
          break;
        default:
          throw new ArgumentException(nameof(hashToken));
      }
      switch (undefKeyword.Kind())
      {
        case SyntaxKind.UndefKeyword:
          break;
        default:
          throw new ArgumentException(nameof(undefKeyword));
      }
      switch (name.Kind())
      {
        case SyntaxKind.IdentifierToken:
          break;
        default:
          throw new ArgumentException(nameof(name));
      }
      switch (endOfDirectiveToken.Kind())
      {
        case SyntaxKind.EndOfDirectiveToken:
          break;
        default:
          throw new ArgumentException(nameof(endOfDirectiveToken));
      }
      return (UndefDirectiveTriviaSyntax)Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SyntaxFactory.UndefDirectiveTrivia((Syntax.InternalSyntax.SyntaxToken)hashToken.Node, (Syntax.InternalSyntax.SyntaxToken)undefKeyword.Node, (Syntax.InternalSyntax.SyntaxToken)name.Node, (Syntax.InternalSyntax.SyntaxToken)endOfDirectiveToken.Node, isActive).CreateRed();
    }


    /// <summary>Creates a new UndefDirectiveTriviaSyntax instance.</summary>
    public static UndefDirectiveTriviaSyntax UndefDirectiveTrivia(SyntaxToken name, bool isActive)
    {
      return SyntaxFactory.UndefDirectiveTrivia(SyntaxFactory.Token(SyntaxKind.HashToken), SyntaxFactory.Token(SyntaxKind.UndefKeyword), name, SyntaxFactory.Token(SyntaxKind.EndOfDirectiveToken), isActive);
    }

    /// <summary>Creates a new UndefDirectiveTriviaSyntax instance.</summary>
    public static UndefDirectiveTriviaSyntax UndefDirectiveTrivia(string name, bool isActive)
    {
      return SyntaxFactory.UndefDirectiveTrivia(SyntaxFactory.Token(SyntaxKind.HashToken), SyntaxFactory.Token(SyntaxKind.UndefKeyword), SyntaxFactory.Identifier(name), SyntaxFactory.Token(SyntaxKind.EndOfDirectiveToken), isActive);
    }

    /// <summary>Creates a new LineDirectiveTriviaSyntax instance.</summary>
    public static LineDirectiveTriviaSyntax LineDirectiveTrivia(SyntaxToken hashToken, SyntaxToken lineKeyword, SyntaxToken line, SyntaxToken file, SyntaxToken endOfDirectiveToken, bool isActive)
    {
      switch (hashToken.Kind())
      {
        case SyntaxKind.HashToken:
          break;
        default:
          throw new ArgumentException(nameof(hashToken));
      }
      switch (lineKeyword.Kind())
      {
        case SyntaxKind.LineKeyword:
          break;
        default:
          throw new ArgumentException(nameof(lineKeyword));
      }
      switch (line.Kind())
      {
        case SyntaxKind.NumericLiteralToken:
        case SyntaxKind.DefaultKeyword:
        case SyntaxKind.HiddenKeyword:
          break;
        default:
          throw new ArgumentException(nameof(line));
      }
      switch (file.Kind())
      {
        case SyntaxKind.StringLiteralToken:
        case SyntaxKind.None:
          break;
        default:
          throw new ArgumentException(nameof(file));
      }
      switch (endOfDirectiveToken.Kind())
      {
        case SyntaxKind.EndOfDirectiveToken:
          break;
        default:
          throw new ArgumentException(nameof(endOfDirectiveToken));
      }
      return (LineDirectiveTriviaSyntax)Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SyntaxFactory.LineDirectiveTrivia((Syntax.InternalSyntax.SyntaxToken)hashToken.Node, (Syntax.InternalSyntax.SyntaxToken)lineKeyword.Node, (Syntax.InternalSyntax.SyntaxToken)line.Node, (Syntax.InternalSyntax.SyntaxToken)file.Node, (Syntax.InternalSyntax.SyntaxToken)endOfDirectiveToken.Node, isActive).CreateRed();
    }


    /// <summary>Creates a new LineDirectiveTriviaSyntax instance.</summary>
    public static LineDirectiveTriviaSyntax LineDirectiveTrivia(SyntaxToken line, SyntaxToken file, bool isActive)
    {
      return SyntaxFactory.LineDirectiveTrivia(SyntaxFactory.Token(SyntaxKind.HashToken), SyntaxFactory.Token(SyntaxKind.LineKeyword), line, file, SyntaxFactory.Token(SyntaxKind.EndOfDirectiveToken), isActive);
    }

    /// <summary>Creates a new LineDirectiveTriviaSyntax instance.</summary>
    public static LineDirectiveTriviaSyntax LineDirectiveTrivia(SyntaxToken line, bool isActive)
    {
      return SyntaxFactory.LineDirectiveTrivia(SyntaxFactory.Token(SyntaxKind.HashToken), SyntaxFactory.Token(SyntaxKind.LineKeyword), line, default(SyntaxToken), SyntaxFactory.Token(SyntaxKind.EndOfDirectiveToken), isActive);
    }

    /// <summary>Creates a new PragmaWarningDirectiveTriviaSyntax instance.</summary>
    public static PragmaWarningDirectiveTriviaSyntax PragmaWarningDirectiveTrivia(SyntaxToken hashToken, SyntaxToken pragmaKeyword, SyntaxToken warningKeyword, SyntaxToken disableOrRestoreKeyword, SeparatedSyntaxList<ExpressionSyntax> errorCodes, SyntaxToken endOfDirectiveToken, bool isActive)
    {
      switch (hashToken.Kind())
      {
        case SyntaxKind.HashToken:
          break;
        default:
          throw new ArgumentException(nameof(hashToken));
      }
      switch (pragmaKeyword.Kind())
      {
        case SyntaxKind.PragmaKeyword:
          break;
        default:
          throw new ArgumentException(nameof(pragmaKeyword));
      }
      switch (warningKeyword.Kind())
      {
        case SyntaxKind.WarningKeyword:
          break;
        default:
          throw new ArgumentException(nameof(warningKeyword));
      }
      switch (disableOrRestoreKeyword.Kind())
      {
        case SyntaxKind.DisableKeyword:
        case SyntaxKind.RestoreKeyword:
          break;
        default:
          throw new ArgumentException(nameof(disableOrRestoreKeyword));
      }
      switch (endOfDirectiveToken.Kind())
      {
        case SyntaxKind.EndOfDirectiveToken:
          break;
        default:
          throw new ArgumentException(nameof(endOfDirectiveToken));
      }
      return (PragmaWarningDirectiveTriviaSyntax)Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SyntaxFactory.PragmaWarningDirectiveTrivia((Syntax.InternalSyntax.SyntaxToken)hashToken.Node, (Syntax.InternalSyntax.SyntaxToken)pragmaKeyword.Node, (Syntax.InternalSyntax.SyntaxToken)warningKeyword.Node, (Syntax.InternalSyntax.SyntaxToken)disableOrRestoreKeyword.Node, errorCodes.Node.ToGreenSeparatedList<Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.ExpressionSyntax>(), (Syntax.InternalSyntax.SyntaxToken)endOfDirectiveToken.Node, isActive).CreateRed();
    }


    /// <summary>Creates a new PragmaWarningDirectiveTriviaSyntax instance.</summary>
    public static PragmaWarningDirectiveTriviaSyntax PragmaWarningDirectiveTrivia(SyntaxToken disableOrRestoreKeyword, SeparatedSyntaxList<ExpressionSyntax> errorCodes, bool isActive)
    {
      return SyntaxFactory.PragmaWarningDirectiveTrivia(SyntaxFactory.Token(SyntaxKind.HashToken), SyntaxFactory.Token(SyntaxKind.PragmaKeyword), SyntaxFactory.Token(SyntaxKind.WarningKeyword), disableOrRestoreKeyword, errorCodes, SyntaxFactory.Token(SyntaxKind.EndOfDirectiveToken), isActive);
    }

    /// <summary>Creates a new PragmaWarningDirectiveTriviaSyntax instance.</summary>
    public static PragmaWarningDirectiveTriviaSyntax PragmaWarningDirectiveTrivia(SyntaxToken disableOrRestoreKeyword, bool isActive)
    {
      return SyntaxFactory.PragmaWarningDirectiveTrivia(SyntaxFactory.Token(SyntaxKind.HashToken), SyntaxFactory.Token(SyntaxKind.PragmaKeyword), SyntaxFactory.Token(SyntaxKind.WarningKeyword), disableOrRestoreKeyword, default(SeparatedSyntaxList<ExpressionSyntax>), SyntaxFactory.Token(SyntaxKind.EndOfDirectiveToken), isActive);
    }

    /// <summary>Creates a new PragmaChecksumDirectiveTriviaSyntax instance.</summary>
    public static PragmaChecksumDirectiveTriviaSyntax PragmaChecksumDirectiveTrivia(SyntaxToken hashToken, SyntaxToken pragmaKeyword, SyntaxToken checksumKeyword, SyntaxToken file, SyntaxToken guid, SyntaxToken bytes, SyntaxToken endOfDirectiveToken, bool isActive)
    {
      switch (hashToken.Kind())
      {
        case SyntaxKind.HashToken:
          break;
        default:
          throw new ArgumentException(nameof(hashToken));
      }
      switch (pragmaKeyword.Kind())
      {
        case SyntaxKind.PragmaKeyword:
          break;
        default:
          throw new ArgumentException(nameof(pragmaKeyword));
      }
      switch (checksumKeyword.Kind())
      {
        case SyntaxKind.ChecksumKeyword:
          break;
        default:
          throw new ArgumentException(nameof(checksumKeyword));
      }
      switch (file.Kind())
      {
        case SyntaxKind.StringLiteralToken:
          break;
        default:
          throw new ArgumentException(nameof(file));
      }
      switch (guid.Kind())
      {
        case SyntaxKind.StringLiteralToken:
          break;
        default:
          throw new ArgumentException(nameof(guid));
      }
      switch (bytes.Kind())
      {
        case SyntaxKind.StringLiteralToken:
          break;
        default:
          throw new ArgumentException(nameof(bytes));
      }
      switch (endOfDirectiveToken.Kind())
      {
        case SyntaxKind.EndOfDirectiveToken:
          break;
        default:
          throw new ArgumentException(nameof(endOfDirectiveToken));
      }
      return (PragmaChecksumDirectiveTriviaSyntax)Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SyntaxFactory.PragmaChecksumDirectiveTrivia((Syntax.InternalSyntax.SyntaxToken)hashToken.Node, (Syntax.InternalSyntax.SyntaxToken)pragmaKeyword.Node, (Syntax.InternalSyntax.SyntaxToken)checksumKeyword.Node, (Syntax.InternalSyntax.SyntaxToken)file.Node, (Syntax.InternalSyntax.SyntaxToken)guid.Node, (Syntax.InternalSyntax.SyntaxToken)bytes.Node, (Syntax.InternalSyntax.SyntaxToken)endOfDirectiveToken.Node, isActive).CreateRed();
    }


    /// <summary>Creates a new PragmaChecksumDirectiveTriviaSyntax instance.</summary>
    public static PragmaChecksumDirectiveTriviaSyntax PragmaChecksumDirectiveTrivia(SyntaxToken file, SyntaxToken guid, SyntaxToken bytes, bool isActive)
    {
      return SyntaxFactory.PragmaChecksumDirectiveTrivia(SyntaxFactory.Token(SyntaxKind.HashToken), SyntaxFactory.Token(SyntaxKind.PragmaKeyword), SyntaxFactory.Token(SyntaxKind.ChecksumKeyword), file, guid, bytes, SyntaxFactory.Token(SyntaxKind.EndOfDirectiveToken), isActive);
    }

    /// <summary>Creates a new ReferenceDirectiveTriviaSyntax instance.</summary>
    public static ReferenceDirectiveTriviaSyntax ReferenceDirectiveTrivia(SyntaxToken hashToken, SyntaxToken referenceKeyword, SyntaxToken file, SyntaxToken endOfDirectiveToken, bool isActive)
    {
      switch (hashToken.Kind())
      {
        case SyntaxKind.HashToken:
          break;
        default:
          throw new ArgumentException(nameof(hashToken));
      }
      switch (referenceKeyword.Kind())
      {
        case SyntaxKind.ReferenceKeyword:
          break;
        default:
          throw new ArgumentException(nameof(referenceKeyword));
      }
      switch (file.Kind())
      {
        case SyntaxKind.StringLiteralToken:
          break;
        default:
          throw new ArgumentException(nameof(file));
      }
      switch (endOfDirectiveToken.Kind())
      {
        case SyntaxKind.EndOfDirectiveToken:
          break;
        default:
          throw new ArgumentException(nameof(endOfDirectiveToken));
      }
      return (ReferenceDirectiveTriviaSyntax)Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SyntaxFactory.ReferenceDirectiveTrivia((Syntax.InternalSyntax.SyntaxToken)hashToken.Node, (Syntax.InternalSyntax.SyntaxToken)referenceKeyword.Node, (Syntax.InternalSyntax.SyntaxToken)file.Node, (Syntax.InternalSyntax.SyntaxToken)endOfDirectiveToken.Node, isActive).CreateRed();
    }


    /// <summary>Creates a new ReferenceDirectiveTriviaSyntax instance.</summary>
    public static ReferenceDirectiveTriviaSyntax ReferenceDirectiveTrivia(SyntaxToken file, bool isActive)
    {
      return SyntaxFactory.ReferenceDirectiveTrivia(SyntaxFactory.Token(SyntaxKind.HashToken), SyntaxFactory.Token(SyntaxKind.ReferenceKeyword), file, SyntaxFactory.Token(SyntaxKind.EndOfDirectiveToken), isActive);
    }

    /// <summary>Creates a new LoadDirectiveTriviaSyntax instance.</summary>
    public static LoadDirectiveTriviaSyntax LoadDirectiveTrivia(SyntaxToken hashToken, SyntaxToken loadKeyword, SyntaxToken file, SyntaxToken endOfDirectiveToken, bool isActive)
    {
      switch (hashToken.Kind())
      {
        case SyntaxKind.HashToken:
          break;
        default:
          throw new ArgumentException(nameof(hashToken));
      }
      switch (loadKeyword.Kind())
      {
        case SyntaxKind.LoadKeyword:
          break;
        default:
          throw new ArgumentException(nameof(loadKeyword));
      }
      switch (file.Kind())
      {
        case SyntaxKind.StringLiteralToken:
          break;
        default:
          throw new ArgumentException(nameof(file));
      }
      switch (endOfDirectiveToken.Kind())
      {
        case SyntaxKind.EndOfDirectiveToken:
          break;
        default:
          throw new ArgumentException(nameof(endOfDirectiveToken));
      }
      return (LoadDirectiveTriviaSyntax)Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SyntaxFactory.LoadDirectiveTrivia((Syntax.InternalSyntax.SyntaxToken)hashToken.Node, (Syntax.InternalSyntax.SyntaxToken)loadKeyword.Node, (Syntax.InternalSyntax.SyntaxToken)file.Node, (Syntax.InternalSyntax.SyntaxToken)endOfDirectiveToken.Node, isActive).CreateRed();
    }


    /// <summary>Creates a new LoadDirectiveTriviaSyntax instance.</summary>
    public static LoadDirectiveTriviaSyntax LoadDirectiveTrivia(SyntaxToken file, bool isActive)
    {
      return SyntaxFactory.LoadDirectiveTrivia(SyntaxFactory.Token(SyntaxKind.HashToken), SyntaxFactory.Token(SyntaxKind.LoadKeyword), file, SyntaxFactory.Token(SyntaxKind.EndOfDirectiveToken), isActive);
    }

    /// <summary>Creates a new ShebangDirectiveTriviaSyntax instance.</summary>
    public static ShebangDirectiveTriviaSyntax ShebangDirectiveTrivia(SyntaxToken hashToken, SyntaxToken exclamationToken, SyntaxToken endOfDirectiveToken, bool isActive)
    {
      switch (hashToken.Kind())
      {
        case SyntaxKind.HashToken:
          break;
        default:
          throw new ArgumentException(nameof(hashToken));
      }
      switch (exclamationToken.Kind())
      {
        case SyntaxKind.ExclamationToken:
          break;
        default:
          throw new ArgumentException(nameof(exclamationToken));
      }
      switch (endOfDirectiveToken.Kind())
      {
        case SyntaxKind.EndOfDirectiveToken:
          break;
        default:
          throw new ArgumentException(nameof(endOfDirectiveToken));
      }
      return (ShebangDirectiveTriviaSyntax)Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SyntaxFactory.ShebangDirectiveTrivia((Syntax.InternalSyntax.SyntaxToken)hashToken.Node, (Syntax.InternalSyntax.SyntaxToken)exclamationToken.Node, (Syntax.InternalSyntax.SyntaxToken)endOfDirectiveToken.Node, isActive).CreateRed();
    }


    /// <summary>Creates a new ShebangDirectiveTriviaSyntax instance.</summary>
    public static ShebangDirectiveTriviaSyntax ShebangDirectiveTrivia(bool isActive)
    {
      return SyntaxFactory.ShebangDirectiveTrivia(SyntaxFactory.Token(SyntaxKind.HashToken), SyntaxFactory.Token(SyntaxKind.ExclamationToken), SyntaxFactory.Token(SyntaxKind.EndOfDirectiveToken), isActive);
    }

    /// <summary>Creates a new NullableDirectiveTriviaSyntax instance.</summary>
    public static NullableDirectiveTriviaSyntax NullableDirectiveTrivia(SyntaxToken hashToken, SyntaxToken nullableKeyword, SyntaxToken settingToken, SyntaxToken targetToken, SyntaxToken endOfDirectiveToken, bool isActive)
    {
      switch (hashToken.Kind())
      {
        case SyntaxKind.HashToken:
          break;
        default:
          throw new ArgumentException(nameof(hashToken));
      }
      switch (nullableKeyword.Kind())
      {
        case SyntaxKind.NullableKeyword:
          break;
        default:
          throw new ArgumentException(nameof(nullableKeyword));
      }
      switch (settingToken.Kind())
      {
        case SyntaxKind.EnableKeyword:
        case SyntaxKind.DisableKeyword:
        case SyntaxKind.RestoreKeyword:
          break;
        default:
          throw new ArgumentException(nameof(settingToken));
      }
      switch (targetToken.Kind())
      {
        case SyntaxKind.WarningsKeyword:
        case SyntaxKind.AnnotationsKeyword:
        case SyntaxKind.None:
          break;
        default:
          throw new ArgumentException(nameof(targetToken));
      }
      switch (endOfDirectiveToken.Kind())
      {
        case SyntaxKind.EndOfDirectiveToken:
          break;
        default:
          throw new ArgumentException(nameof(endOfDirectiveToken));
      }
      return (NullableDirectiveTriviaSyntax)Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SyntaxFactory.NullableDirectiveTrivia((Syntax.InternalSyntax.SyntaxToken)hashToken.Node, (Syntax.InternalSyntax.SyntaxToken)nullableKeyword.Node, (Syntax.InternalSyntax.SyntaxToken)settingToken.Node, (Syntax.InternalSyntax.SyntaxToken)targetToken.Node, (Syntax.InternalSyntax.SyntaxToken)endOfDirectiveToken.Node, isActive).CreateRed();
    }


    /// <summary>Creates a new NullableDirectiveTriviaSyntax instance.</summary>
    public static NullableDirectiveTriviaSyntax NullableDirectiveTrivia(SyntaxToken settingToken, SyntaxToken targetToken, bool isActive)
    {
      return SyntaxFactory.NullableDirectiveTrivia(SyntaxFactory.Token(SyntaxKind.HashToken), SyntaxFactory.Token(SyntaxKind.NullableKeyword), settingToken, targetToken, SyntaxFactory.Token(SyntaxKind.EndOfDirectiveToken), isActive);
    }

    /// <summary>Creates a new NullableDirectiveTriviaSyntax instance.</summary>
    public static NullableDirectiveTriviaSyntax NullableDirectiveTrivia(SyntaxToken settingToken, bool isActive)
    {
      return SyntaxFactory.NullableDirectiveTrivia(SyntaxFactory.Token(SyntaxKind.HashToken), SyntaxFactory.Token(SyntaxKind.NullableKeyword), settingToken, default(SyntaxToken), SyntaxFactory.Token(SyntaxKind.EndOfDirectiveToken), isActive);
    }
  }
}
