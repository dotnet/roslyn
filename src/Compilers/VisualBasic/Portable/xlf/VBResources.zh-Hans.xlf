<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" source-language="en" target-language="zh-Hans" original="../VBResources.resx">
    <body>
      <trans-unit id="ERR_BadSwitchValue">
        <source>Command-line syntax error: '{0}' is not a valid value for the '{1}' option. The value must be of the form '{2}'.</source>
        <target state="translated">命令行语法错误:“{0}”不是“{1}”选项的有效值。值的格式必须为 "{2}"。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CommentsAfterLineContinuationNotAvailable1">
        <source>Please use language version {0} or greater to use comments after line continuation character.</source>
        <target state="translated">请使用语言版本 {0} 或更高版本，以在行继续符后使用注释。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DefaultInterfaceImplementationInNoPIAType">
        <source>Type '{0}' cannot be embedded because it has a non-abstract member. Consider setting the 'Embed Interop Types' property to false.</source>
        <target state="translated">无法嵌入类型“{0}”，因为它有非抽象成员。请考虑将“嵌入互操作类型”属性设置为 false。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_MultipleAnalyzerConfigsInSameDir">
        <source>Multiple analyzer config files cannot be in the same directory ('{0}').</source>
        <target state="translated">多个分析器配置文件不能位于同一目录({0})中。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ReAbstractionInNoPIAType">
        <source>Type '{0}' cannot be embedded because it has a re-abstraction of a member from base interface. Consider setting the 'Embed Interop Types' property to false.</source>
        <target state="translated">无法嵌入类型“{0}”，因为它有基本接口成员的重新抽象。请考虑将“嵌入互操作类型”属性设置为 false。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RuntimeDoesNotSupportDefaultInterfaceImplementation">
        <source>Target runtime doesn't support default interface implementation.</source>
        <target state="translated">目标运行时不支持默认接口实现。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RuntimeDoesNotSupportProtectedAccessForInterfaceMember">
        <source>Target runtime doesn't support 'Protected', 'Protected Friend', or 'Private Protected' accessibility for a member of an interface.</source>
        <target state="translated">目标运行时不支持对接口的成员使用 "Protected"、"Protected Friend" 或 "Private Protected" 辅助功能。</target>
        <note />
      </trans-unit>
      <trans-unit id="FEATURE_CommentsAfterLineContinuation">
        <source>comments after line continuation</source>
        <target state="translated">行继续符之后的注释</target>
        <note />
      </trans-unit>
      <trans-unit id="FEATURE_UnconstrainedTypeParameterInConditional">
        <source>unconstrained type parameters in binary conditional expressions</source>
        <target state="translated">二进制条件表达式中的无约束类型参数</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_VBCHelp">
        <source>                  Visual Basic Compiler Options

                                  - OUTPUT FILE -
-out:&lt;file&gt;                       Specifies the output file name.
-target:exe                       Create a console application (default).
                                  (Short form: -t)
-target:winexe                    Create a Windows application.
-target:library                   Create a library assembly.
-target:module                    Create a module that can be added to an
                                  assembly.
-target:appcontainerexe           Create a Windows application that runs in
                                  AppContainer.
-target:winmdobj                  Create a Windows Metadata intermediate file
-doc[+|-]                         Generates XML documentation file.
-doc:&lt;file&gt;                       Generates XML documentation file to &lt;file&gt;.
-refout:&lt;file&gt;                    Reference assembly output to generate

                                  - INPUT FILES -
-addmodule:&lt;file_list&gt;            Reference metadata from the specified modules
-link:&lt;file_list&gt;                 Embed metadata from the specified interop
                                  assembly. (Short form: -l)
-recurse:&lt;wildcard&gt;               Include all files in the current directory
                                  and subdirectories according to the
                                  wildcard specifications.
-reference:&lt;file_list&gt;            Reference metadata from the specified
                                  assembly. (Short form: -r)
-analyzer:&lt;file_list&gt;             Run the analyzers from this assembly
                                  (Short form: -a)
-additionalfile:&lt;file list&gt;       Additional files that don't directly affect code
                                  generation but may be used by analyzers for producing
                                  errors or warnings.

                                  - RESOURCES -
-linkresource:&lt;resinfo&gt;           Links the specified file as an external
                                  assembly resource.
                                  resinfo:&lt;file&gt;[,&lt;name&gt;[,public|private]]
                                  (Short form: -linkres)
-nowin32manifest                  The default manifest should not be embedded
                                  in the manifest section of the output PE.
-resource:&lt;resinfo&gt;               Adds the specified file as an embedded
                                  assembly resource.
                                  resinfo:&lt;file&gt;[,&lt;name&gt;[,public|private]]
                                  (Short form: -res)
-win32icon:&lt;file&gt;                 Specifies a Win32 icon file (.ico) for the
                                  default Win32 resources.
-win32manifest:&lt;file&gt;             The provided file is embedded in the manifest
                                  section of the output PE.
-win32resource:&lt;file&gt;             Specifies a Win32 resource file (.res).

                                  - CODE GENERATION -
-optimize[+|-]                    Enable optimizations.
-removeintchecks[+|-]             Remove integer checks. Default off.
-debug[+|-]                       Emit debugging information.
-debug:full                       Emit full debugging information (default).
-debug:pdbonly                    Emit full debugging information.
-debug:portable                   Emit cross-platform debugging information.
-debug:embedded                   Emit cross-platform debugging information into
                                  the target .dll or .exe.
-deterministic                    Produce a deterministic assembly
                                  (including module version GUID and timestamp)
-refonly                          Produce a reference assembly in place of the main output
-instrument:TestCoverage          Produce an assembly instrumented to collect
                                  coverage information
-sourcelink:&lt;file&gt;                Source link info to embed into PDB.

                                  - ERRORS AND WARNINGS -
-nowarn                           Disable all warnings.
-nowarn:&lt;number_list&gt;             Disable a list of individual warnings.
-warnaserror[+|-]                 Treat all warnings as errors.
-warnaserror[+|-]:&lt;number_list&gt;   Treat a list of warnings as errors.
-ruleset:&lt;file&gt;                   Specify a ruleset file that disables specific
                                  diagnostics.
-errorlog:&lt;file&gt;[,version=&lt;sarif_version&gt;]         
                                  Specify a file to log all compiler and analyzer
                                  diagnostics in SARIF format.
                                  sarif_version:{1|2|2.1} Default is 1. 2 and 2.1
                                  both mean SARIF version 2.1.0.
-reportanalyzer                   Report additional analyzer information, such as
                                  execution time.

                                  - LANGUAGE -
-define:&lt;symbol_list&gt;             Declare global conditional compilation
                                  symbol(s). symbol_list:name=value,...
                                  (Short form: -d)
-imports:&lt;import_list&gt;            Declare global Imports for namespaces in
                                  referenced metadata files.
                                  import_list:namespace,...
-langversion:?                    Display the allowed values for language version
-langversion:&lt;string&gt;             Specify language version such as
                                  `default` (latest major version), or
                                  `latest` (latest version, including minor versions),
                                  or specific versions like `14` or `15.3`
-optionexplicit[+|-]              Require explicit declaration of variables.
-optioninfer[+|-]                 Allow type inference of variables.
-rootnamespace:&lt;string&gt;           Specifies the root Namespace for all type
                                  declarations.
-optionstrict[+|-]                Enforce strict language semantics.
-optionstrict:custom              Warn when strict language semantics are not
                                  respected.
-optioncompare:binary             Specifies binary-style string comparisons.
                                  This is the default.
-optioncompare:text               Specifies text-style string comparisons.

                                  - MISCELLANEOUS -
-help                             Display this usage message. (Short form: -?)
-noconfig                         Do not auto-include VBC.RSP file.
-nologo                           Do not display compiler copyright banner.
-quiet                            Quiet output mode.
-verbose                          Display verbose messages.
-parallel[+|-]                    Concurrent build.
-version                          Display the compiler version number and exit.

                                  - ADVANCED -
-baseaddress:&lt;number&gt;             The base address for a library or module
                                  (hex).
-checksumalgorithm:&lt;alg&gt;          Specify algorithm for calculating source file
                                  checksum stored in PDB. Supported values are:
                                  SHA1 or SHA256 (default).
-codepage:&lt;number&gt;                Specifies the codepage to use when opening
                                  source files.
-delaysign[+|-]                   Delay-sign the assembly using only the public
                                  portion of the strong name key.
-publicsign[+|-]                  Public-sign the assembly using only the public
                                  portion of the strong name key.
-errorreport:&lt;string&gt;             Specifies how to handle internal compiler
                                  errors; must be prompt, send, none, or queue
                                  (default).
-filealign:&lt;number&gt;               Specify the alignment used for output file
                                  sections.
-highentropyva[+|-]               Enable high-entropy ASLR.
-keycontainer:&lt;string&gt;            Specifies a strong name key container.
-keyfile:&lt;file&gt;                   Specifies a strong name key file.
-libpath:&lt;path_list&gt;              List of directories to search for metadata
                                  references. (Semi-colon delimited.)
-main:&lt;class&gt;                     Specifies the Class or Module that contains
                                  Sub Main. It can also be a Class that
                                  inherits from System.Windows.Forms.Form.
                                  (Short form: -m)
-moduleassemblyname:&lt;string&gt;      Name of the assembly which this module will
                                  be a part of.
-netcf                            Target the .NET Compact Framework.
-nostdlib                         Do not reference standard libraries
                                  (system.dll and VBC.RSP file).
-pathmap:&lt;K1&gt;=&lt;V1&gt;,&lt;K2&gt;=&lt;V2&gt;,...
                                  Specify a mapping for source path names output by
                                  the compiler.
-platform:&lt;string&gt;                Limit which platforms this code can run on;
                                  must be x86, x64, Itanium, arm, arm64
                                  AnyCPU32BitPreferred or anycpu (default).
-preferreduilang                  Specify the preferred output language name.
-nosdkpath                        Disable searching the default SDK path for standard library assemblies.
-sdkpath:&lt;path&gt;                   Location of the .NET Framework SDK directory
                                  (mscorlib.dll).
-subsystemversion:&lt;version&gt;       Specify subsystem version of the output PE.
                                  version:&lt;number&gt;[.&lt;number&gt;]
-utf8output[+|-]                  Emit compiler output in UTF8 character
                                  encoding.
@&lt;file&gt;                           Insert command-line settings from a text file
-vbruntime[+|-|*]                 Compile with/without the default Visual Basic
                                  runtime.
-vbruntime:&lt;file&gt;                 Compile with the alternate Visual Basic
                                  runtime in &lt;file&gt;.
</source>
        <target state="translated">                  Visual Basic 编译器选项

                                  - 输出文件 -
-out:&lt;file&gt;                       指定输出文件名称。
-target:exe                       创建控制台应用程序(默认)。
                                  (缩写: -t)
-target:winexe                    创建 Windows 应用程序。
-target:library                   创建库程序集。
-target:module                    创建可添加到程序集的
                                  模块。
-target:appcontainerexe           创建在 AppContainer 中运行的
                                  Windows 应用程序。
-target:winmdobj                  创建 Windows 元数据中间文件
-doc[+|-]                         生成 XML 文档文件。
-doc:&lt;file&gt;                       将 XML 文档文件生成到 &lt;file&gt;
-refout:&lt;file&gt;                    引用要生成的引用程序集

                                  - 输入文件 -
-addmodule:&lt;file_list&gt;            从指定模块中引用元数据
-link:&lt;file_list&gt;                 嵌入指定互操作程序集中的
                                  元数据。(缩写: -l)
-recurse:&lt;wildcard&gt;               根据通配符规范包括
                                  当前目录和子目录中
                                  的所有文件。
-reference:&lt;file_list&gt;            从指定程序集中引用
                                  元数据。(缩写: -r)
-analyzer:&lt;file_list&gt;             运行此程序集的分析器
                                  (缩写: -a)
-additionalfile:&lt;file list&gt;       不直接影响代码
                                  生成但可能被分析器用于生成
                                  错误或警告的其他文件。

                                  - 资源 -
-linkresource:&lt;resinfo&gt;           将指定文件作为外部
                                  程序集资源进行链接。
                                  resinfo:&lt;file&gt;[,&lt;name&gt;[,public|private]]
                                  (缩写: -linkres)
-nowin32manifest                  默认清单不应嵌入
                                  输出 PE 的清单部分。
-resource:&lt;resinfo&gt;               将指定文件作为嵌入式
                                  程序集资源进行添加。
                                  resinfo:&lt;file&gt;[,&lt;name&gt;[,public|private]]
                                  (缩写: -res)
-win32icon:&lt;file&gt;                 为默认的 Win32 资源
                                  指定 Win32 图标文件(.ico)。
-win32manifest:&lt;file&gt;             提供的文件嵌入在
                                  输出 PE 的清单部分。
-win32resource:&lt;file&gt;             指定 Win32 资源文件(.res)。

                                  - 代码生成 -
-optimize[+|-]                    启用优化。
-removeintchecks[+|-]             删除整数检查。默认为“关”。
-debug[+|-]                       发出调试信息。
-debug:full                       发出完全调试信息(默认)。
-debug:pdbonly            发出完全调试信息。
-debug:portable                   发出跨平台调试信息。
-debug:embedded                   发出跨平台调试信息到
                                  目标 .dll 或 .exe.
-deterministic                    生成确定性程序集
                                  (包括模块版本 GUID 和时间戳)
-refonly                          生成引用程序集来替代主要输出
-instrument:TestCoverage          生成对其检测以收集覆盖率信息的t
                                  程序集
-sourcelink:&lt;file&gt;                要嵌入到 PDB 中的源链接信息。

                                  - 错误和警告 -
-nowarn                           禁用所有警告。
-nowarn:&lt;number_list&gt;             禁用个人警告列表。
-warnaserror[+|-]                 将所有警告视为错误。
-warnaserror[+|-]:&lt;number_list&gt;   将警告列表视为错误。
-ruleset:&lt;file&gt;                   指定禁用特定诊断的
                                  规则集文件。
-errorlog:&lt;file&gt;[,version=&lt;sarif_version&gt;]         
                                  指定用于以 SARIF 格式记录所有编译器和分析器诊断的
                                  文件。
                                  sarif_version:{1|2|2.1} 默认为 1. 2 和 2.1
                                  两者均表示 SARIF 版本 2.1.0。
-reportanalyzer                   报告其他分析器信息，如
                                  执行时间。
                                  - 语言 -

-define:&lt;symbol_list&gt;             声明全局条件编译
                                  符号。symbol_list:name=value,...
                                  (缩写: -d)
-imports:&lt;import_list&gt;            为引用的元数据文件中的命名空间声明
                                  全局导入。
                                  import_list:namespace,...
-langversion:?                    显示允许的语言版本值
-langversion:&lt;string&gt;             指定语言版本，如
                                  “default” (最新主要版本)、
                                  “latest” (最新版本，包括次要版本)
                                  或 “14”、”15.3”等特定版本
-optionexplicit[+|-]              需要显示声明变量。
-optioninfer[+|-]                 允许变量的类型推理。
-rootnamespace:&lt;string&gt;           指定所有类型声明的根
                                  命名空间。
-optionstrict[+|-]                强制严格语言语义。
-optionstrict:custom              不遵从严格语言语义时
                                  发出警告。
-optioncompare:binary             指定二进制样式的字符串比较。
                                  这是默认设置。
-optioncompare:text               指定文本样式字符串比较。

                                  - 杂项 -
-help                             显示此用法消息。(缩写: -?)
-noconfig                         不自动包括 VBC.RSP 文件。
-nologo                           不显示编译器版权横幅。
-quiet                            安静输出模式。
-verbose                          显示详细消息。
-parallel[+|-]                    并发生成。
-version                          显示编译器版本号并退出。

                                  - 高级 -
-baseaddress:&lt;number&gt;             库或模块的基址
                                  (十六进制)。
-checksumalgorithm:&lt;alg&gt;          指定计算存储在 PDB 中的源文件校验和
                                  的算法。支持的值是:
                                  SHA1 或 SHA256 (默认)。
-codepage:&lt;number&gt;                指定打开源文件时要使用的
                                  代码页。
-delaysign[+|-]                   仅使用强名称密钥的公共部分
                                  对程序集进行延迟签名。
-publicsign[+|-]                  仅使用强名称密钥的公共部分
                                  对程序集进行公共签名
-errorreport:&lt;string&gt;             指定处理内部编译器错误的方式；
                                  必须是 prompt、send、none 或 queue
                                  (默认)。
-filealign:&lt;number&gt;               指定用于输出文件节的对齐
                                  方式。
-highentropyva[+|-]               启用高平均信息量的 ASLR。
-keycontainer:&lt;string&gt;            指定强名称密钥容器。
-keyfile:&lt;file&gt;                   指定强名称密钥文件。
-libpath:&lt;path_list&gt;              搜索元数据引用的目录
                                  列表。(分号分隔。)
-main:&lt;class&gt;                     指定包含 Sub Main 的类
                                  或模块。也可为从
                                  System.Windows.Forms.Form 继承的类。
                                  (缩写: -m)
-moduleassemblyname:&lt;string&gt;      此模块所属程序集
                                  的名称。
-netcf                            以 .NET Compact Framework 为目标。
-nostdlib                         不引用标准库
                                  (system.dll 和 VBC.RSP 文件)。
-pathmap:&lt;K1&gt;=&lt;V1&gt;,&lt;K2&gt;=&lt;V2&gt;,...
                                  按编译器指定源路径名称输出的
                                  映射。
-platform:&lt;string&gt;                限制此代码可以在其上运行的平台；
                                  必须是 x86、x64、Itanium、arm、arm64、
                                  AnyCPU32BitPreferred 或 anycpu (默认)。
-preferreduilang                  指定首选输出语言名称。
-nosdkpath                        禁用搜索标准库程序集的默认 SDK 路径
-sdkpath:&lt;path&gt;                   .NET Framework SDK 目录的位置
                                  (mscorlib.dll).
-subsystemversion:&lt;version&gt;       指定输出 PE 的子系统版本。
                                  version:&lt;number&gt;[.&lt;number&gt;]
-utf8output[+|-]                  以 UTF8 字符编码格式
                                  发出编译器输出。
@&lt;file&gt;                           从文本文件插入命令行设置
-vbruntime[+|-|*]                 用/不用默认的 Visual Basic
                                  运行时进行编译。
-vbruntime:&lt;file&gt;                 使用 &lt;file&gt; 中的备用 Visual Basic 运行时
                                  进行编译。
</target>
        <note />
      </trans-unit>
      <trans-unit id="Trees0">
        <source>trees({0})</source>
        <target state="translated">树({0})</target>
        <note />
      </trans-unit>
      <trans-unit id="TreesMustHaveRootNode">
        <source>trees({0}) must have root node with SyntaxKind.CompilationUnit.</source>
        <target state="translated">树({0}) 必须具有带 SyntaxKind.CompilationUnit 的根节点。</target>
        <note />
      </trans-unit>
      <trans-unit id="CannotAddCompilerSpecialTree">
        <source>Cannot add compiler special tree</source>
        <target state="translated">无法添加特定于编译器的树</target>
        <note />
      </trans-unit>
      <trans-unit id="SyntaxTreeAlreadyPresent">
        <source>Syntax tree already present</source>
        <target state="translated">语法树已存在</target>
        <note />
      </trans-unit>
      <trans-unit id="SubmissionCanHaveAtMostOneSyntaxTree">
        <source>Submission can have at most one syntax tree.</source>
        <target state="translated">提交最多可以具有一个语法树。</target>
        <note />
      </trans-unit>
      <trans-unit id="CannotRemoveCompilerSpecialTree">
        <source>Cannot remove compiler special tree</source>
        <target state="translated">无法移除特定于编译器的树</target>
        <note />
      </trans-unit>
      <trans-unit id="SyntaxTreeNotFoundToRemove">
        <source>SyntaxTree '{0}' not found to remove</source>
        <target state="translated">未找到要删除的 SyntaxTree“{0}”。</target>
        <note />
      </trans-unit>
      <trans-unit id="TreeMustHaveARootNodeWithCompilationUnit">
        <source>Tree must have a root node with SyntaxKind.CompilationUnit</source>
        <target state="translated">树必须具有带 SyntaxKind.CompilationUnit 的根节点</target>
        <note />
      </trans-unit>
      <trans-unit id="CompilationVisualBasic">
        <source>Compilation (Visual Basic): </source>
        <target state="translated">编译(Visual Basic):</target>
        <note />
      </trans-unit>
      <trans-unit id="NodeIsNotWithinSyntaxTree">
        <source>Node is not within syntax tree</source>
        <target state="translated">节点不在语法树中</target>
        <note />
      </trans-unit>
      <trans-unit id="CantReferenceCompilationFromTypes">
        <source>Can't reference compilation of type '{0}' from {1} compilation.</source>
        <target state="translated">无法从 {1} 编译引用类型为“{0}”的编译。</target>
        <note />
      </trans-unit>
      <trans-unit id="PositionOfTypeParameterTooLarge">
        <source>position of type parameter too large</source>
        <target state="translated">类型参数的位置太大</target>
        <note />
      </trans-unit>
      <trans-unit id="AssociatedTypeDoesNotHaveTypeParameters">
        <source>Associated type does not have type parameters</source>
        <target state="translated">关联类型没有类型参数</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FunctionReturnType">
        <source>function return type</source>
        <target state="translated">函数返回类型</target>
        <note />
      </trans-unit>
      <trans-unit id="TypeArgumentCannotBeNothing">
        <source>Type argument cannot be Nothing</source>
        <target state="translated">类型参数不能是任何内容</target>
        <note />
      </trans-unit>
      <trans-unit id="WrongNumberOfTypeArguments">
        <source>Wrong number of type arguments</source>
        <target state="translated">类型参数的数目不正确</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_FileNotFound">
        <source>file '{0}' could not be found</source>
        <target state="translated">找不到文件“{0}”。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NoResponseFile">
        <source>unable to open response file '{0}'</source>
        <target state="translated">无法打开响应文件“{0}”</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ArgumentRequired">
        <source>option '{0}' requires '{1}'</source>
        <target state="translated">选项“{0}”需要“{1}”</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_SwitchNeedsBool">
        <source>option '{0}' can be followed only by '+' or '-'</source>
        <target state="translated">选项“{0}”后面只能跟“+”或“-”</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InvalidSwitchValue">
        <source>the value '{1}' is invalid for option '{0}'</source>
        <target state="translated">值“{1}”对选项“{0}”无效</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_MutuallyExclusiveOptions">
        <source>Compilation options '{0}' and '{1}' can't both be specified at the same time.</source>
        <target state="translated">无法同时指定编译选项“{0}”和“{1}”。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_BadUILang">
        <source>The language name '{0}' is invalid.</source>
        <target state="translated">语言名“{0}”无效。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_BadUILang_Title">
        <source>The language name for /preferreduilang is invalid</source>
        <target state="translated">/preferreduilang 的语言名称无效</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_VBCoreNetModuleConflict">
        <source>The options /vbruntime* and /target:module cannot be combined.</source>
        <target state="translated">/vbruntime* 选项不能与 /target:module 选项组合。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InvalidFormatForGuidForOption">
        <source>Command-line syntax error: Invalid Guid format '{0}' for option '{1}'</source>
        <target state="translated">命令行语法错误: Guid 格式“{0}”对于选项“{1}”无效</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_MissingGuidForOption">
        <source>Command-line syntax error: Missing Guid for option '{1}'</source>
        <target state="translated">命令行语法错误: 选项“{1}”缺少 Guid</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadChecksumAlgorithm">
        <source>Algorithm '{0}' is not supported</source>
        <target state="translated">不支持算法“{0}”</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_BadSwitch">
        <source>unrecognized option '{0}'; ignored</source>
        <target state="translated">无法识别的选项“{0}”；已忽略</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_BadSwitch_Title">
        <source>Unrecognized command-line option</source>
        <target state="translated">无法识别的命令行选项</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NoSources">
        <source>no input sources specified</source>
        <target state="translated">未指定输入源</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_FileAlreadyIncluded">
        <source>source file '{0}' specified multiple times</source>
        <target state="translated">源文件“{0}”指定了多次</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_FileAlreadyIncluded_Title">
        <source>Source file specified multiple times</source>
        <target state="translated">多次指定源文件</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CantOpenFileWrite">
        <source>can't open '{0}' for writing: {1}</source>
        <target state="translated">无法打开“{0}”进行写入: {1}</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadCodepage">
        <source>code page '{0}' is invalid or not installed</source>
        <target state="translated">代码页“{0}”无效或未安装</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BinaryFile">
        <source>the file '{0}' is not a text file</source>
        <target state="translated">文件“{0}”不是文本文件</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_LibNotFound">
        <source>could not find library '{0}'</source>
        <target state="translated">找不到库“{0}”</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_MetadataReferencesNotSupported">
        <source>Metadata references not supported.</source>
        <target state="translated">不支持元数据引用。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_IconFileAndWin32ResFile">
        <source>cannot specify both /win32icon and /win32resource</source>
        <target state="translated">不能同时指定 /win32icon 和 /win32resource</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NoConfigInResponseFile">
        <source>ignoring /noconfig option because it was specified in a response file</source>
        <target state="translated">/noconfig 选项是在响应文件中指定的，因此被忽略</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NoConfigInResponseFile_Title">
        <source>Ignoring /noconfig option because it was specified in a response file</source>
        <target state="translated">/noconfig 选项是在响应文件中指定的，因此被忽略</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_InvalidWarningId">
        <source>warning number '{0}' for the option '{1}' is either not configurable or not valid</source>
        <target state="translated">选项“{1}”的警告编号“{0}”不可配置或无效</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_InvalidWarningId_Title">
        <source>Warning number is either not configurable or not valid</source>
        <target state="translated">警告编号不可配置或无效</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NoSourcesOut">
        <source>cannot infer an output file name from resource only input files; provide the '/out' option</source>
        <target state="translated">无法从仅资源输入文件推理出输出文件名；提供“/out”选项</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NeedModule">
        <source>the /moduleassemblyname option may only be specified when building a target of type 'module'</source>
        <target state="translated">只有在生成“module”类型的目标时才能指定 /moduleassemblyname 选项</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InvalidAssemblyName">
        <source>'{0}' is not a valid value for /moduleassemblyname</source>
        <target state="translated">'“{0}”不是 /moduleassemblyname 的有效值。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ConflictingManifestSwitches">
        <source>Error embedding Win32 manifest: Option /win32manifest conflicts with /nowin32manifest.</source>
        <target state="translated">嵌入 Win32 清单时出错: 选项 /win32manifest 与 /nowin32manifest 冲突。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_IgnoreModuleManifest">
        <source>Option /win32manifest ignored. It can be specified only when the target is an assembly.</source>
        <target state="translated">已忽略选项 /win32manifest。只有在目标是程序集时才能指定该选项。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_IgnoreModuleManifest_Title">
        <source>Option /win32manifest ignored</source>
        <target state="translated">/win32manifest 选项已忽略</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InvalidInNamespace">
        <source>Statement is not valid in a namespace.</source>
        <target state="translated">语句在命名空间中无效。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_UndefinedType1">
        <source>Type '{0}' is not defined.</source>
        <target state="translated">未定义类型“{0}”。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_MissingNext">
        <source>'Next' expected.</source>
        <target state="translated">'应为 "Next"。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_IllegalCharConstant">
        <source>Character constant must contain exactly one character.</source>
        <target state="translated">字符常量必须正好包含一个字符。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_UnreferencedAssemblyEvent3">
        <source>Reference required to assembly '{0}' containing the definition for event '{1}'. Add one to your project.</source>
        <target state="translated">需要对程序集“{0}”(包含事件“{1}”的定义)的引用。请在项目中添加一个。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_UnreferencedModuleEvent3">
        <source>Reference required to module '{0}' containing the definition for event '{1}'. Add one to your project.</source>
        <target state="translated">需要对模块“{0}”(包含事件“{1}”的定义)的引用。请在项目中添加一个。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_LbExpectedEndIf">
        <source>'#If' block must end with a matching '#End If'.</source>
        <target state="translated">'"#If" 块必须以匹配的 "#End If" 结束。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_LbNoMatchingIf">
        <source>'#ElseIf', '#Else', or '#End If' must be preceded by a matching '#If'.</source>
        <target state="translated">'"#ElseIf"、"#Else" 或 "#End If" 前面必须是匹配的 "#If"。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_LbBadElseif">
        <source>'#ElseIf' must be preceded by a matching '#If' or '#ElseIf'.</source>
        <target state="translated">'"#ElseIf" 前面必须是匹配的 "#If" 或 "#ElseIf"。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InheritsFromRestrictedType1">
        <source>Inheriting from '{0}' is not valid.</source>
        <target state="translated">从“{0}”继承无效。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InvOutsideProc">
        <source>Labels are not valid outside methods.</source>
        <target state="translated">标签在方法外部无效。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DelegateCantImplement">
        <source>Delegates cannot implement interface methods.</source>
        <target state="translated">委托无法实现接口方法。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DelegateCantHandleEvents">
        <source>Delegates cannot handle events.</source>
        <target state="translated">委托无法处理事件。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_IsOperatorRequiresReferenceTypes1">
        <source>'Is' operator does not accept operands of type '{0}'. Operands must be reference or nullable types.</source>
        <target state="translated">'“Is”运算符不接受类型为“{0}”的操作数。操作数必须是引用类型或可以为 null 的类型。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_TypeOfRequiresReferenceType1">
        <source>'TypeOf ... Is' requires its left operand to have a reference type, but this operand has the value type '{0}'.</source>
        <target state="translated">'“TypeOf ... Is”要求它的左操作数具有引用类型，但此操作数具有值类型“{0}”。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ReadOnlyHasSet">
        <source>Properties declared 'ReadOnly' cannot have a 'Set'.</source>
        <target state="translated">声明为 "ReadOnly" 的属性不能有 "Set"。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_WriteOnlyHasGet">
        <source>Properties declared 'WriteOnly' cannot have a 'Get'.</source>
        <target state="translated">声明为 "WriteOnly" 的属性不能有 "Get"。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InvInsideProc">
        <source>Statement is not valid inside a method.</source>
        <target state="translated">语句在方法内部无效。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InvInsideBlock">
        <source>Statement is not valid inside '{0}' block.</source>
        <target state="translated">语句在“{0}”块内部无效。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_UnexpectedExpressionStatement">
        <source>Expression statement is only allowed at the end of an interactive submission.</source>
        <target state="translated">只允许在交互提交结尾处使用表达式语句。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_EndProp">
        <source>Property missing 'End Property'.</source>
        <target state="translated">Property 缺少 "End Property"。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_EndSubExpected">
        <source>'End Sub' expected.</source>
        <target state="translated">'应为 "End Sub"。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_EndFunctionExpected">
        <source>'End Function' expected.</source>
        <target state="translated">'应为 "End Function"。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_LbElseNoMatchingIf">
        <source>'#Else' must be preceded by a matching '#If' or '#ElseIf'.</source>
        <target state="translated">'"#Else" 前面必须是匹配的 "#If" 或 "#ElseIf"。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CantRaiseBaseEvent">
        <source>Derived classes cannot raise base class events.</source>
        <target state="translated">派生类不能引发基类事件。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_TryWithoutCatchOrFinally">
        <source>Try must have at least one 'Catch' or a 'Finally'.</source>
        <target state="translated">Try 必须至少有一个 "Catch" 或 "Finally"。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_EventsCantBeFunctions">
        <source>Events cannot have a return type.</source>
        <target state="translated">事件不能有返回类型。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_MissingEndBrack">
        <source>Bracketed identifier is missing closing ']'.</source>
        <target state="translated">用括号标识的标识符缺少右边的 "]"。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_Syntax">
        <source>Syntax error.</source>
        <target state="translated">语法错误。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_Overflow">
        <source>Overflow.</source>
        <target state="translated">溢出。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_IllegalChar">
        <source>Character is not valid.</source>
        <target state="translated">字符无效。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_StrictDisallowsObjectOperand1">
        <source>Option Strict On prohibits operands of type Object for operator '{0}'.</source>
        <target state="translated">Option Strict On 禁止将 Object 类型的操作数用于运算符“{0}”。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_LoopControlMustNotBeProperty">
        <source>Loop control variable cannot be a property or a late-bound indexed array.</source>
        <target state="translated">循环控制变量不能是属性或后期绑定索引数组。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_MethodBodyNotAtLineStart">
        <source>First statement of a method body cannot be on the same line as the method declaration.</source>
        <target state="translated">方法主体的第一条语句和方法声明不能位于同一行。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_MaximumNumberOfErrors">
        <source>Maximum number of errors has been exceeded.</source>
        <target state="translated">已超出最大错误数。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_UseOfKeywordNotInInstanceMethod1">
        <source>'{0}' is valid only within an instance method.</source>
        <target state="translated">'“{0}”仅在实例方法中有效。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_UseOfKeywordFromStructure1">
        <source>'{0}' is not valid within a structure.</source>
        <target state="translated">'“{0}”在结构中无效。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadAttributeConstructor1">
        <source>Attribute constructor has a parameter of type '{0}', which is not an integral, floating-point or Enum type or one of Object, Char, String, Boolean, System.Type or 1-dimensional array of these types.</source>
        <target state="translated">特性构造函数具有“{0}”类型的参数，此参数不是整型、浮点型或枚举类型，也不是 Object、Char、String、Boolean、System.Type 之一或这些类型的一维数组。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ParamArrayWithOptArgs">
        <source>Method cannot have both a ParamArray and Optional parameters.</source>
        <target state="translated">方法不能同时具有 ParamArray 和 Optional 参数。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExpectedArray1">
        <source>'{0}' statement requires an array.</source>
        <target state="translated">'“{0}”语句需要数组。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ParamArrayNotArray">
        <source>ParamArray parameter must be an array.</source>
        <target state="translated">ParamArray 参数必须是一个数组。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ParamArrayRank">
        <source>ParamArray parameter must be a one-dimensional array.</source>
        <target state="translated">ParamArray 参数必须是一维数组。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ArrayRankLimit">
        <source>Array exceeds the limit of 32 dimensions.</source>
        <target state="translated">数组超过了 32 维数限制。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AsNewArray">
        <source>Arrays cannot be declared with 'New'.</source>
        <target state="translated">不能用 "New" 声明数组。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_TooManyArgs1">
        <source>Too many arguments to '{0}'.</source>
        <target state="translated">“{0}”的参数太多。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExpectedCase">
        <source>Statements and labels are not valid between 'Select Case' and first 'Case'.</source>
        <target state="translated">位于 "Select Case" 与第一个 "Case" 之间的语句和标签无效。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RequiredConstExpr">
        <source>Constant expression is required.</source>
        <target state="translated">要求常量表达式。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RequiredConstConversion2">
        <source>Conversion from '{0}' to '{1}' cannot occur in a constant expression.</source>
        <target state="translated">常量表达式中不能发生从“{0}”到“{1}”的转换。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InvalidMe">
        <source>'Me' cannot be the target of an assignment.</source>
        <target state="translated">'"Me" 不能作为赋值目标。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ReadOnlyAssignment">
        <source>'ReadOnly' variable cannot be the target of an assignment.</source>
        <target state="translated">'"ReadOnly" 变量不能作为赋值目标。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExitSubOfFunc">
        <source>'Exit Sub' is not valid in a Function or Property.</source>
        <target state="translated">'"Exit Sub" 在函数或属性中无效。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExitPropNot">
        <source>'Exit Property' is not valid in a Function or Sub.</source>
        <target state="translated">'“Exit Property”在函数或 Sub 中无效。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExitFuncOfSub">
        <source>'Exit Function' is not valid in a Sub or Property.</source>
        <target state="translated">'"Exit Function" 在 Sub 或属性中无效。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_LValueRequired">
        <source>Expression is a value and therefore cannot be the target of an assignment.</source>
        <target state="translated">表达式是一个值，因此不能作为赋值目标。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ForIndexInUse1">
        <source>For loop control variable '{0}' already in use by an enclosing For loop.</source>
        <target state="translated">For 循环控制变量“{0}”已由封闭 For 循环使用。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NextForMismatch1">
        <source>Next control variable does not match For loop control variable '{0}'.</source>
        <target state="translated">Next 控制变量与 For 循环控制变量“{0}”不匹配。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CaseElseNoSelect">
        <source>'Case Else' can only appear inside a 'Select Case' statement.</source>
        <target state="translated">'“Case Else”只能出现在“Select Case”语句内。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CaseNoSelect">
        <source>'Case' can only appear inside a 'Select Case' statement.</source>
        <target state="translated">'“Case”只能出现在“Select Case”语句内。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CantAssignToConst">
        <source>Constant cannot be the target of an assignment.</source>
        <target state="translated">常量不能作为赋值目标。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NamedSubscript">
        <source>Named arguments are not valid as array subscripts.</source>
        <target state="translated">命名参数作为数组下标无效。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExpectedEndIf">
        <source>'If' must end with a matching 'End If'.</source>
        <target state="translated">'“If”必须以匹配的“End If”结束。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExpectedEndWhile">
        <source>'While' must end with a matching 'End While'.</source>
        <target state="translated">'“While”必须以匹配的“End While”结束。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExpectedLoop">
        <source>'Do' must end with a matching 'Loop'.</source>
        <target state="translated">'"Do" 必须以匹配的 "Loop" 结束。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExpectedNext">
        <source>'For' must end with a matching 'Next'.</source>
        <target state="translated">'"For" 必须以匹配的 "Next" 结束。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExpectedEndWith">
        <source>'With' must end with a matching 'End With'.</source>
        <target state="translated">'“With”必须以匹配的“End With”结束。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ElseNoMatchingIf">
        <source>'Else' must be preceded by a matching 'If' or 'ElseIf'.</source>
        <target state="translated">'"Else" 前面必须是匹配的 "If" 或 "ElseIf"。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_EndIfNoMatchingIf">
        <source>'End If' must be preceded by a matching 'If'.</source>
        <target state="translated">'"End If" 前面必须是匹配的 "If"。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_EndSelectNoSelect">
        <source>'End Select' must be preceded by a matching 'Select Case'.</source>
        <target state="translated">'"End Select" 前面必须是匹配的 "Select Case"。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExitDoNotWithinDo">
        <source>'Exit Do' can only appear inside a 'Do' statement.</source>
        <target state="translated">'"Exit Do" 只能出现在 "Do" 语句内。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_EndWhileNoWhile">
        <source>'End While' must be preceded by a matching 'While'.</source>
        <target state="translated">'“End While”前面必须是匹配的“While”。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_LoopNoMatchingDo">
        <source>'Loop' must be preceded by a matching 'Do'.</source>
        <target state="translated">'"Loop" 前面必须是匹配的 "Do"。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NextNoMatchingFor">
        <source>'Next' must be preceded by a matching 'For'.</source>
        <target state="translated">'"Next" 前面必须是匹配的 "For"。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_EndWithWithoutWith">
        <source>'End With' must be preceded by a matching 'With'.</source>
        <target state="translated">'“End With”前面必须是匹配的“With”。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_MultiplyDefined1">
        <source>Label '{0}' is already defined in the current method.</source>
        <target state="translated">当前方法中已定义了标签“{0}”。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExpectedEndSelect">
        <source>'Select Case' must end with a matching 'End Select'.</source>
        <target state="translated">'“Select Case”必须以匹配的“End Select”结束。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExitForNotWithinFor">
        <source>'Exit For' can only appear inside a 'For' statement.</source>
        <target state="translated">'"Exit For" 只能出现在 "For" 语句内。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExitWhileNotWithinWhile">
        <source>'Exit While' can only appear inside a 'While' statement.</source>
        <target state="translated">'"Exit While" 只能出现在 "While" 语句内。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ReadOnlyProperty1">
        <source>'ReadOnly' property '{0}' cannot be the target of an assignment.</source>
        <target state="translated">'“ReadOnly”属性“{0}”不能作为赋值目标。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExitSelectNotWithinSelect">
        <source>'Exit Select' can only appear inside a 'Select' statement.</source>
        <target state="translated">'"Exit Select" 只能出现在 "Select" 语句内。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BranchOutOfFinally">
        <source>Branching out of a 'Finally' is not valid.</source>
        <target state="translated">从“Finally”中分支无效。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_QualNotObjectRecord1">
        <source>'!' requires its left operand to have a type parameter, class or interface type, but this operand has the type '{0}'.</source>
        <target state="translated">'“!”要求其左操作数具有类型参数、类或接口类型，但此操作数的类型为“{0}”。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_TooFewIndices">
        <source>Number of indices is less than the number of dimensions of the indexed array.</source>
        <target state="translated">索引数少于索引数组的维数。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_TooManyIndices">
        <source>Number of indices exceeds the number of dimensions of the indexed array.</source>
        <target state="translated">索引数超过索引数组的维数。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_EnumNotExpression1">
        <source>'{0}' is an Enum type and cannot be used as an expression.</source>
        <target state="translated">'“{0}”是一个枚举类型，不能用作表达式。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_TypeNotExpression1">
        <source>'{0}' is a type and cannot be used as an expression.</source>
        <target state="translated">'“{0}”是一个类型，不能用作表达式。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ClassNotExpression1">
        <source>'{0}' is a class type and cannot be used as an expression.</source>
        <target state="translated">'“{0}”是一个类类型，不能用作表达式。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_StructureNotExpression1">
        <source>'{0}' is a structure type and cannot be used as an expression.</source>
        <target state="translated">'“{0}”是一个结构类型，不能用作表达式。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InterfaceNotExpression1">
        <source>'{0}' is an interface type and cannot be used as an expression.</source>
        <target state="translated">'“{0}”是一个接口类型，不能用作表达式。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NamespaceNotExpression1">
        <source>'{0}' is a namespace and cannot be used as an expression.</source>
        <target state="translated">'“{0}”是一个命名空间，不能用作表达式。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadNamespaceName1">
        <source>'{0}' is not a valid name and cannot be used as the root namespace name.</source>
        <target state="translated">'“{0}”不是有效名称，不能用作根命名空间名称。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_XmlPrefixNotExpression">
        <source>'{0}' is an XML prefix and cannot be used as an expression.  Use the GetXmlNamespace operator to create a namespace object.</source>
        <target state="translated">'“{0}”是 XML 前缀，不能用作表达式。请使用 GetXmlNamespace 运算符创建命名空间对象。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_MultipleExtends">
        <source>'Inherits' can appear only once within a 'Class' statement and can only specify one class.</source>
        <target state="translated">'"Inherits" 只能在 "Class" 语句中出现一次，并且只能指定一个类。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PropMustHaveGetSet">
        <source>Property without a 'ReadOnly' or 'WriteOnly' specifier must provide both a 'Get' and a 'Set'.</source>
        <target state="translated">不带 "ReadOnly" 或 "WriteOnly" 说明符的属性必须同时提供 "Get" 和 "Set"。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_WriteOnlyHasNoWrite">
        <source>'WriteOnly' property must provide a 'Set'.</source>
        <target state="translated">'"WriteOnly" 属性必须提供 "Set"。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ReadOnlyHasNoGet">
        <source>'ReadOnly' property must provide a 'Get'.</source>
        <target state="translated">'"ReadOnly" 属性必须提供 "Get"。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadAttribute1">
        <source>Attribute '{0}' is not valid: Incorrect argument value.</source>
        <target state="translated">特性“{0}”无效: 参数值不正确。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_LabelNotDefined1">
        <source>Label '{0}' is not defined.</source>
        <target state="translated">未定义标签“{0}”。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ErrorCreatingWin32ResourceFile">
        <source>Error creating Win32 resources: {0}</source>
        <target state="translated">创建 Win32 资源时出错: {0}</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_UnableToCreateTempFile">
        <source>Cannot create temporary file: {0}</source>
        <target state="translated">无法创建临时文件: {0}</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RequiredNewCall2">
        <source>First statement of this 'Sub New' must be a call to 'MyBase.New' or 'MyClass.New' because base class '{0}' of '{1}' does not have an accessible 'Sub New' that can be called with no arguments.</source>
        <target state="translated">“{1}”的基类“{0}”没有不使用参数就可以调用的可访问“Sub New”，因此该“Sub New”的第一个语句必须是对“MyBase.New”或“MyClass.New”的调用。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_UnimplementedMember3">
        <source>{0} '{1}' must implement '{2}' for interface '{3}'.</source>
        <target state="translated">{0}“{1}”必须为接口“{3}”实现“{2}”。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadWithRef">
        <source>Leading '.' or '!' can only appear inside a 'With' statement.</source>
        <target state="translated">前导“.”或“!”只能出现在“With”语句内。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DuplicateAccessCategoryUsed">
        <source>Only one of 'Public', 'Private', 'Protected', 'Friend', 'Protected Friend', or 'Private Protected' can be specified.</source>
        <target state="translated">只能指定 "Public"、"Private"、"Protected"、"Friend"、"Protected Friend" 或 "Private Protected" 中的一个。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DuplicateModifierCategoryUsed">
        <source>Only one of 'NotOverridable', 'MustOverride', or 'Overridable' can be specified.</source>
        <target state="translated">只能指定 "NotOverridable"、"MustOverride" 或 "Overridable" 中的一个。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DuplicateSpecifier">
        <source>Specifier is duplicated.</source>
        <target state="translated">说明符重复。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_TypeConflict6">
        <source>{0} '{1}' and {2} '{3}' conflict in {4} '{5}'.</source>
        <target state="translated">{0}“{1}”和 {2}“{3}”在 {4}“{5}”中冲突。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_UnrecognizedTypeKeyword">
        <source>Keyword does not name a type.</source>
        <target state="translated">关键字没有指定类型。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExtraSpecifiers">
        <source>Specifiers valid only at the beginning of a declaration.</source>
        <target state="translated">说明符仅在声明的开始处有效。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_UnrecognizedType">
        <source>Type expected.</source>
        <target state="translated">应为类型。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InvalidUseOfKeyword">
        <source>Keyword is not valid as an identifier.</source>
        <target state="translated">关键字作为标识符无效。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InvalidEndEnum">
        <source>'End Enum' must be preceded by a matching 'Enum'.</source>
        <target state="translated">'“End Enum”前面必须是匹配的“Enum”。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_MissingEndEnum">
        <source>'Enum' must end with a matching 'End Enum'.</source>
        <target state="translated">'"Enum" 必须以匹配的 "End Enum" 结束。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExpectedDeclaration">
        <source>Declaration expected.</source>
        <target state="translated">应为声明。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ParamArrayMustBeLast">
        <source>End of parameter list expected. Cannot define parameters after a paramarray parameter.</source>
        <target state="translated">应为参数列表的结尾。不能在 Paramarray 参数后定义参数。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_SpecifiersInvalidOnInheritsImplOpt">
        <source>Specifiers and attributes are not valid on this statement.</source>
        <target state="translated">说明符和特性在此语句上无效。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExpectedSpecifier">
        <source>Expected one of 'Dim', 'Const', 'Public', 'Private', 'Protected', 'Friend', 'Shadows', 'ReadOnly' or 'Shared'.</source>
        <target state="translated">应为“Dim”、“Const”、“Public”、“Private”、“Protected”、“Friend”、“Shadows”、“ReadOnly”或“Shared”中的一个。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExpectedComma">
        <source>Comma expected.</source>
        <target state="translated">应为逗号。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExpectedAs">
        <source>'As' expected.</source>
        <target state="translated">'应为 "As"。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExpectedRparen">
        <source>')' expected.</source>
        <target state="translated">'应为 ")"。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExpectedLparen">
        <source>'(' expected.</source>
        <target state="translated">'应为“(”。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InvalidNewInType">
        <source>'New' is not valid in this context.</source>
        <target state="translated">'"New" 在此上下文中无效。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExpectedExpression">
        <source>Expression expected.</source>
        <target state="translated">应为表达式。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExpectedOptional">
        <source>'Optional' expected.</source>
        <target state="translated">'应为 "Optional"。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExpectedIdentifier">
        <source>Identifier expected.</source>
        <target state="translated">应为标识符。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExpectedIntLiteral">
        <source>Integer constant expected.</source>
        <target state="translated">应为整数常量。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExpectedEOS">
        <source>End of statement expected.</source>
        <target state="translated">应为语句结束。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExpectedForOptionStmt">
        <source>'Option' must be followed by 'Compare', 'Explicit', 'Infer', or 'Strict'.</source>
        <target state="translated">'“Option”的后面必须跟有“Compare”、“Explicit”、“Infer”或“Strict”。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InvalidOptionCompare">
        <source>'Option Compare' must be followed by 'Text' or 'Binary'.</source>
        <target state="translated">'"Option Compare" 的后面必须跟有 "Text" 或 "Binary"。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExpectedOptionCompare">
        <source>'Compare' expected.</source>
        <target state="translated">'应为 "Compare"。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_StrictDisallowImplicitObject">
        <source>Option Strict On requires all variable declarations to have an 'As' clause.</source>
        <target state="translated">Option Strict On 要求所有变量声明都有 "As" 子句。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_StrictDisallowsImplicitProc">
        <source>Option Strict On requires all Function, Property, and Operator declarations to have an 'As' clause.</source>
        <target state="translated">Option Strict On 要求所有函数、属性和运算符声明都有 "As" 子句。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_StrictDisallowsImplicitArgs">
        <source>Option Strict On requires that all method parameters have an 'As' clause.</source>
        <target state="translated">Option Strict On 要求所有方法参数都有 "As" 子句。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InvalidParameterSyntax">
        <source>Comma or ')' expected.</source>
        <target state="translated">应为逗号或 ")"。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExpectedSubFunction">
        <source>'Sub' or 'Function' expected.</source>
        <target state="translated">'应为“Sub”或“Function”。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExpectedStringLiteral">
        <source>String constant expected.</source>
        <target state="translated">应为字符串常量。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_MissingLibInDeclare">
        <source>'Lib' expected.</source>
        <target state="translated">'应为 "Lib"。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DelegateNoInvoke1">
        <source>Delegate class '{0}' has no Invoke method, so an expression of this type cannot be the target of a method call.</source>
        <target state="translated">委托类“{0}”没有 Invoke 方法，所以此类型的表达式不能作为方法调用的目标。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_MissingIsInTypeOf">
        <source>'Is' expected.</source>
        <target state="translated">'应为 "Is"。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DuplicateOption1">
        <source>'Option {0}' statement can only appear once per file.</source>
        <target state="translated">'每个文件中只能出现一次“Option {0}”语句。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ModuleCantInherit">
        <source>'Inherits' not valid in Modules.</source>
        <target state="translated">'"Inherits" 在模块中无效。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ModuleCantImplement">
        <source>'Implements' not valid in Modules.</source>
        <target state="translated">'"Implements" 在模块中无效。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadImplementsType">
        <source>Implemented type must be an interface.</source>
        <target state="translated">已实现的类型必须是接口。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadConstFlags1">
        <source>'{0}' is not valid on a constant declaration.</source>
        <target state="translated">'“{0}”在常量声明中无效。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadWithEventsFlags1">
        <source>'{0}' is not valid on a WithEvents declaration.</source>
        <target state="translated">'“{0}”在 WithEvents 声明中无效。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadDimFlags1">
        <source>'{0}' is not valid on a member variable declaration.</source>
        <target state="translated">'“{0}”在成员变量声明中无效。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DuplicateParamName1">
        <source>Parameter already declared with name '{0}'.</source>
        <target state="translated">已用名称“{0}”声明了参数。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_LoopDoubleCondition">
        <source>'Loop' cannot have a condition if matching 'Do' has one.</source>
        <target state="translated">'"Loop" 和匹配的 "Do" 不能同时具有条件。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExpectedRelational">
        <source>Relational operator expected.</source>
        <target state="translated">应为关系运算符。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExpectedExitKind">
        <source>'Exit' must be followed by 'Sub', 'Function', 'Property', 'Do', 'For', 'While', 'Select', or 'Try'.</source>
        <target state="translated">'“Exit”的后面必须跟有“Sub”、“Function”、“Property”、“Do”、“For”、“While”、“Select”或“Try”。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExpectedNamedArgumentInAttributeList">
        <source>Named argument expected.</source>
        <target state="translated">应为命名参数。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NamedArgumentSpecificationBeforeFixedArgumentInLateboundInvocation">
        <source>Named argument specifications must appear after all fixed arguments have been specified in a late bound invocation.</source>
        <target state="translated">命名参数规范必须出现在已在后期绑定调用中指定的所有固定参数之后。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExpectedNamedArgument">
        <source>Named argument expected. Please use language version {0} or greater to use non-trailing named arguments.</source>
        <target state="translated">需要命名参数。请使用语言版本 {0} 或更高版本，以使用非尾随命名参数。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadMethodFlags1">
        <source>'{0}' is not valid on a method declaration.</source>
        <target state="translated">'“{0}”在方法声明中无效。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadEventFlags1">
        <source>'{0}' is not valid on an event declaration.</source>
        <target state="translated">'“{0}”在事件声明中无效。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadDeclareFlags1">
        <source>'{0}' is not valid on a Declare.</source>
        <target state="translated">'“{0}”在 Declare 中无效。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadLocalConstFlags1">
        <source>'{0}' is not valid on a local constant declaration.</source>
        <target state="translated">'“{0}”在局部常量声明中无效。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadLocalDimFlags1">
        <source>'{0}' is not valid on a local variable declaration.</source>
        <target state="translated">'“{0}”在局部变量声明中无效。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExpectedConditionalDirective">
        <source>'If', 'ElseIf', 'Else', 'Const', 'Region', 'ExternalSource', 'ExternalChecksum', 'Enable', 'Disable', 'End' or 'R' expected.</source>
        <target state="translated">'应为“If”、“ElseIf”、“Else”、“Const”、“Region”、“ExternalSource”、“ExternalChecksum”、“Enable”、“Disable”、“End”或“R”。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExpectedEQ">
        <source>'=' expected.</source>
        <target state="translated">'应为 "="。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ConstructorNotFound1">
        <source>Type '{0}' has no constructors.</source>
        <target state="translated">类型“{0}”没有构造函数。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InvalidEndInterface">
        <source>'End Interface' must be preceded by a matching 'Interface'.</source>
        <target state="translated">'“End Interface”前面必须是匹配的“Interface”。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_MissingEndInterface">
        <source>'Interface' must end with a matching 'End Interface'.</source>
        <target state="translated">'"Interface" 必须以匹配的 "End Interface" 结束。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InheritsFrom2">
        <source>
    '{0}' inherits from '{1}'.</source>
        <target state="translated">
  “{0}”从“{1}”继承。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_IsNestedIn2">
        <source>
    '{0}' is nested in '{1}'.</source>
        <target state="translated">
  “{0}”嵌套在“{1}”中。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InheritanceCycle1">
        <source>Class '{0}' cannot inherit from itself: {1}</source>
        <target state="translated">类“{0}”不能从自身继承: {1}</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InheritsFromNonClass">
        <source>Classes can inherit only from other classes.</source>
        <target state="translated">类只能从其他类继承。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_MultiplyDefinedType3">
        <source>'{0}' is already declared as '{1}' in this {2}.</source>
        <target state="translated">'“{0}”已在此 {2} 中声明为“{1}”。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadOverrideAccess2">
        <source>'{0}' cannot override '{1}' because they have different access levels.</source>
        <target state="translated">'“{0}”无法重写“{1}”，因为它们具有不同的访问级别。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CantOverrideNotOverridable2">
        <source>'{0}' cannot override '{1}' because it is declared 'NotOverridable'.</source>
        <target state="translated">'“{0}”无法重写“{1}”，因为后者已声明为“NotOverridable”。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DuplicateProcDef1">
        <source>'{0}' has multiple definitions with identical signatures.</source>
        <target state="translated">'“{0}”具有多个带相同签名的定义。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DuplicateProcDefWithDifferentTupleNames2">
        <source>'{0}' has multiple definitions with identical signatures with different tuple element names, including '{1}'.</source>
        <target state="translated">'“{0}”具有多个带不同元组元素名称却有相同签名的定义，包括“{1}”。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadInterfaceMethodFlags1">
        <source>'{0}' is not valid on an interface method declaration.</source>
        <target state="translated">'“{0}”在接口方法声明中无效。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NamedParamNotFound2">
        <source>'{0}' is not a parameter of '{1}'.</source>
        <target state="translated">'“{0}”不是“{1}”的参数。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadInterfacePropertyFlags1">
        <source>'{0}' is not valid on an interface property declaration.</source>
        <target state="translated">'“{0}”在接口属性声明中无效。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NamedArgUsedTwice2">
        <source>Parameter '{0}' of '{1}' already has a matching argument.</source>
        <target state="translated">“{1}”的参数“{0}”已有匹配的参数。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InterfaceCantUseEventSpecifier1">
        <source>'{0}' is not valid on an interface event declaration.</source>
        <target state="translated">'“{0}”在接口事件声明中无效。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_TypecharNoMatch2">
        <source>Type character '{0}' does not match declared data type '{1}'.</source>
        <target state="translated">类型字符“{0}”与声明的数据类型“{1}”不匹配。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExpectedSubOrFunction">
        <source>'Sub' or 'Function' expected after 'Delegate'.</source>
        <target state="translated">'“Delegate”后面应为“Sub”或“Function”。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadEmptyEnum1">
        <source>Enum '{0}' must contain at least one member.</source>
        <target state="translated">枚举“{0}”必须至少包含一个成员。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InvalidConstructorCall">
        <source>Constructor call is valid only as the first statement in an instance constructor.</source>
        <target state="translated">构造函数调用仅作为实例构造函数中的第一条语句有效。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CantOverrideConstructor">
        <source>'Sub New' cannot be declared 'Overrides'.</source>
        <target state="translated">'“Sub New”不能声明为“Overrides”。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ConstructorCannotBeDeclaredPartial">
        <source>'Sub New' cannot be declared 'Partial'.</source>
        <target state="translated">'“Sub New”不能声明为“Partial”。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ModuleEmitFailure">
        <source>Failed to emit module '{0}': {1}</source>
        <target state="translated">未能发出模块“{0}”: {1}</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_EncUpdateFailedMissingAttribute">
        <source>Cannot update '{0}'; attribute '{1}' is missing.</source>
        <target state="translated">无法更新“{0}”；特性“{1}”缺失。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_OverrideNotNeeded3">
        <source>{0} '{1}' cannot be declared 'Overrides' because it does not override a {0} in a base class.</source>
        <target state="translated">{0}“{1}”不能声明为“Overrides”，因为它不重写基类中的 {0}。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExpectedDot">
        <source>'.' expected.</source>
        <target state="translated">'应为“.”。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DuplicateLocals1">
        <source>Local variable '{0}' is already declared in the current block.</source>
        <target state="translated">当前块中已声明了局部变量“{0}”。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InvInsideEndsProc">
        <source>Statement cannot appear within a method body. End of method assumed.</source>
        <target state="translated">语句不能出现在方法主体内。假定为方法末尾。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_LocalSameAsFunc">
        <source>Local variable cannot have the same name as the function containing it.</source>
        <target state="translated">局部变量不能与包含它的函数同名。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RecordEmbeds2">
        <source>
    '{0}' contains '{1}' (variable '{2}').</source>
        <target state="translated">
  “{0}”包含“{1}”(变量“{2}”)。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RecordCycle2">
        <source>Structure '{0}' cannot contain an instance of itself: {1}</source>
        <target state="translated">结构“{0}”不能包含自身的实例: {1}</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InterfaceCycle1">
        <source>Interface '{0}' cannot inherit from itself: {1}</source>
        <target state="translated">接口“{0}”不能从自身继承: {1}</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_SubNewCycle2">
        <source>
    '{0}' calls '{1}'.</source>
        <target state="translated">
  “{0}”调用“{1}”。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_SubNewCycle1">
        <source>Constructor '{0}' cannot call itself: {1}</source>
        <target state="translated">构造函数“{0}”不能调用自身: {1}</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InheritsFromCantInherit3">
        <source>'{0}' cannot inherit from {2} '{1}' because '{1}' is declared 'NotInheritable'.</source>
        <target state="translated">'“{1}”已声明为“NotInheritable”，因此“{0}”无法从 {2}“{1}”继承。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_OverloadWithOptional2">
        <source>'{0}' and '{1}' cannot overload each other because they differ only by optional parameters.</source>
        <target state="translated">'“{0}” 和“{1}”的差异仅在于可选参数，因此它们无法重载对方。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_OverloadWithReturnType2">
        <source>'{0}' and '{1}' cannot overload each other because they differ only by return types.</source>
        <target state="translated">'“{0}”和“{1}”的差异仅在于返回类型，因此它们无法重载对方。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_TypeCharWithType1">
        <source>Type character '{0}' cannot be used in a declaration with an explicit type.</source>
        <target state="translated">在具有显式类型的声明中不能使用类型字符“{0}”。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_TypeCharOnSub">
        <source>Type character cannot be used in a 'Sub' declaration because a 'Sub' doesn't return a value.</source>
        <target state="translated">"Sub" 不返回值，因此在 "Sub" 声明中不能使用类型字符。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_OverloadWithDefault2">
        <source>'{0}' and '{1}' cannot overload each other because they differ only by the default values of optional parameters.</source>
        <target state="translated">'“{0}”和“{1}”的差异仅在于可选参数的默认值，因此它们无法重载对方。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_MissingSubscript">
        <source>Array subscript expression missing.</source>
        <target state="translated">缺少数组下标表达式。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_OverrideWithDefault2">
        <source>'{0}' cannot override '{1}' because they differ by the default values of optional parameters.</source>
        <target state="translated">'“{0}”无法重写“{1}”，因为它们在可选参数的默认值上存在差异。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_OverrideWithOptional2">
        <source>'{0}' cannot override '{1}' because they differ by optional parameters.</source>
        <target state="translated">'“{0}”无法重写“{1}”，因为它们在可选参数上存在差异。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_FieldOfValueFieldOfMarshalByRef3">
        <source>Cannot refer to '{0}' because it is a member of the value-typed field '{1}' of class '{2}' which has 'System.MarshalByRefObject' as a base class.</source>
        <target state="translated">“{0}”，是使用“System.MarshalByRefObject”作为基类的类“{2}”的值类型字段“{1}”的成员，无法引用。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_TypeMismatch2">
        <source>Value of type '{0}' cannot be converted to '{1}'.</source>
        <target state="translated">类型“{0}”的值无法转换为“{1}”。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CaseAfterCaseElse">
        <source>'Case' cannot follow a 'Case Else' in the same 'Select' statement.</source>
        <target state="translated">'在同一“Select”语句中，“Case”不能位于“Case Else”之后。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ConvertArrayMismatch4">
        <source>Value of type '{0}' cannot be converted to '{1}' because '{2}' is not derived from '{3}'.</source>
        <target state="translated">类型“{0}”的值无法转换为“{1}”，因为“{2}”不是从“{3}”派生的。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ConvertObjectArrayMismatch3">
        <source>Value of type '{0}' cannot be converted to '{1}' because '{2}' is not a reference type.</source>
        <target state="translated">类型“{0}”的值无法转换为“{1}”，因为“{2}”不是引用类型。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ForLoopType1">
        <source>'For' loop control variable cannot be of type '{0}' because the type does not support the required operators.</source>
        <target state="translated">'“For”循环控制变量的类型不能是“{0}”，因为该类型不支持所需的运算符。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_OverloadWithByref2">
        <source>'{0}' and '{1}' cannot overload each other because they differ only by parameters declared 'ByRef' or 'ByVal'.</source>
        <target state="translated">'“{0}”和“{1}”的差异仅在于声明为“ByRef”或“ByVal”的参数，因此它们无法重载对方。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InheritsFromNonInterface">
        <source>Interface can inherit only from another interface.</source>
        <target state="translated">接口只能从其他接口继承。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadInterfaceOrderOnInherits">
        <source>'Inherits' statements must precede all declarations in an interface.</source>
        <target state="translated">'“Inherits”语句必须位于接口中的所有声明之前。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DuplicateDefaultProps1">
        <source>'Default' can be applied to only one property name in a {0}.</source>
        <target state="translated">'“Default”只可应用于“{0}”中的一个属性名称。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DefaultMissingFromProperty2">
        <source>'{0}' and '{1}' cannot overload each other because only one is declared 'Default'.</source>
        <target state="translated">'“{0}”和“{1}”中只有一个声明为“Default”，因此它们无法相互重载。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_OverridingPropertyKind2">
        <source>'{0}' cannot override '{1}' because they differ by 'ReadOnly' or 'WriteOnly'.</source>
        <target state="translated">'“{0}”无法重写“{1}”，因为它们在是“ReadOnly”还是“WriteOnly”上不同。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NewInInterface">
        <source>'Sub New' cannot be declared in an interface.</source>
        <target state="translated">'"Sub New" 不能在接口中声明。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadFlagsOnNew1">
        <source>'Sub New' cannot be declared '{0}'.</source>
        <target state="translated">'“Sub New”不能声明为“{0}”。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_OverloadingPropertyKind2">
        <source>'{0}' and '{1}' cannot overload each other because they differ only by 'ReadOnly' or 'WriteOnly'.</source>
        <target state="translated">'“{0}” 和“{1}”的差异仅在于“ReadOnly”和“WriteOnly”，因此它们无法重载对方。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NoDefaultNotExtend1">
        <source>Class '{0}' cannot be indexed because it has no default property.</source>
        <target state="translated">无法为类“{0}”编制索引，因为它没有默认属性。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_OverloadWithArrayVsParamArray2">
        <source>'{0}' and '{1}' cannot overload each other because they differ only by parameters declared 'ParamArray'.</source>
        <target state="translated">“{0}”和“{1}”的差异仅在于声明为 "ParamArray" 的参数，因此它们无法重载对方。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadInstanceMemberAccess">
        <source>Cannot refer to an instance member of a class from within a shared method or shared member initializer without an explicit instance of the class.</source>
        <target state="translated">没有类的显式实例，就无法从共享方法或共享成员初始值设定项中引用该类的实例成员。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExpectedRbrace">
        <source>'}' expected.</source>
        <target state="translated">'应为 "}"。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ModuleAsType1">
        <source>Module '{0}' cannot be used as a type.</source>
        <target state="translated">模块“{0}”不能用作类型。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NewIfNullOnNonClass">
        <source>'New' cannot be used on an interface.</source>
        <target state="translated">'"New"不能在接口上使用。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CatchAfterFinally">
        <source>'Catch' cannot appear after 'Finally' within a 'Try' statement.</source>
        <target state="translated">'在“Try”语句中，“Catch”不能出现在“Finally”之后。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CatchNoMatchingTry">
        <source>'Catch' cannot appear outside a 'Try' statement.</source>
        <target state="translated">'“Catch”不能出现在“Try”语句之外。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_FinallyAfterFinally">
        <source>'Finally' can only appear once in a 'Try' statement.</source>
        <target state="translated">'“Finally”只能在“Try”语句中出现一次。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_FinallyNoMatchingTry">
        <source>'Finally' cannot appear outside a 'Try' statement.</source>
        <target state="translated">'“Finally”不能出现在“Try”语句之外。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_EndTryNoTry">
        <source>'End Try' must be preceded by a matching 'Try'.</source>
        <target state="translated">'“End Try”前面必须是匹配的“Try”。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExpectedEndTry">
        <source>'Try' must end with a matching 'End Try'.</source>
        <target state="translated">'“Try”必须以匹配的“End Try”结束。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadDelegateFlags1">
        <source>'{0}' is not valid on a Delegate declaration.</source>
        <target state="translated">'“{0}”在委托声明中无效。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NoConstructorOnBase2">
        <source>Class '{0}' must declare a 'Sub New' because its base class '{1}' does not have an accessible 'Sub New' that can be called with no arguments.</source>
        <target state="translated">类“{0}”必须声明一个“Sub New”，原因是它的基类“{1}”没有不使用参数就可以调用的可访问“Sub New”。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InaccessibleSymbol2">
        <source>'{0}' is not accessible in this context because it is '{1}'.</source>
        <target state="translated">'“{0}”是“{1}”,因此它在此上下文中不可访问。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InaccessibleMember3">
        <source>'{0}.{1}' is not accessible in this context because it is '{2}'.</source>
        <target state="translated">'“{0}.{1}”是“{2}” ,因此它在此上下文中不可访问。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CatchNotException1">
        <source>'Catch' cannot catch type '{0}' because it is not 'System.Exception' or a class that inherits from 'System.Exception'.</source>
        <target state="translated">'“Catch”无法捕捉类型“{0}”，因为该类型既不是“System.Exception”也不是从“System.Exception”继承的类。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExitTryNotWithinTry">
        <source>'Exit Try' can only appear inside a 'Try' statement.</source>
        <target state="translated">'"Exit Try" 只能出现在 "Try" 语句内。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadRecordFlags1">
        <source>'{0}' is not valid on a Structure declaration.</source>
        <target state="translated">'“{0}”在结构声明中无效。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadEnumFlags1">
        <source>'{0}' is not valid on an Enum declaration.</source>
        <target state="translated">'“{0}”在枚举声明中无效。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadInterfaceFlags1">
        <source>'{0}' is not valid on an Interface declaration.</source>
        <target state="translated">'“{0}”在接口声明中无效。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_OverrideWithByref2">
        <source>'{0}' cannot override '{1}' because they differ by a parameter that is marked as 'ByRef' versus 'ByVal'.</source>
        <target state="translated">'“{0}”无法重写“{1}”，因为它们在某个参数上存在差异，一个被标记为“ByRef”，而另一个被标记为“ByVal”。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_MyBaseAbstractCall1">
        <source>'MyBase' cannot be used with method '{0}' because it is declared 'MustOverride'.</source>
        <target state="translated">'“MyBase”不能用和方法“{0}”一起使用，因为它被声明为“MustOverride”。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_IdentNotMemberOfInterface4">
        <source>'{0}' cannot implement '{1}' because there is no matching {2} on interface '{3}'.</source>
        <target state="translated">'“{0}”无法实现“{1}”，因为接口“{3}”上不存在匹配的 {2}。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ImplementingInterfaceWithDifferentTupleNames5">
        <source>'{0}' cannot implement {1} '{2}' on interface '{3}' because the tuple element names in '{4}' do not match those in '{5}'.</source>
        <target state="translated">'“{0}”不能在接口“{3}”上实现{1}“{2}”，因为“{4}”中的元组元素名称与“{5}”中的名称不匹配。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_WithEventsRequiresClass">
        <source>'WithEvents' variables must have an 'As' clause.</source>
        <target state="translated">'"WithEvents" 变量必须有 "As" 子句。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_WithEventsAsStruct">
        <source>'WithEvents' variables can only be typed as classes, interfaces or type parameters with class constraints.</source>
        <target state="translated">'"WithEvents" 变量只能类型化为具有类约束的类、接口或类型参数。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ConvertArrayRankMismatch2">
        <source>Value of type '{0}' cannot be converted to '{1}' because the array types have different numbers of dimensions.</source>
        <target state="translated">类型“{0}”的值无法转换为“{1}”，原因是数组类型的维数不同。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RedimRankMismatch">
        <source>'ReDim' cannot change the number of dimensions of an array.</source>
        <target state="translated">'"ReDim" 无法更改数组的维数。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_StartupCodeNotFound1">
        <source>'Sub Main' was not found in '{0}'.</source>
        <target state="translated">'“{0}”中找不到“Sub Main”。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ConstAsNonConstant">
        <source>Constants must be of an intrinsic or enumerated type, not a class, structure, type parameter, or array type.</source>
        <target state="translated">常量必须是内部类型或者枚举类型，不能是类、结构、类型参数或数组类型。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InvalidEndSub">
        <source>'End Sub' must be preceded by a matching 'Sub'.</source>
        <target state="translated">'“End Sub”前面必须是匹配的“Sub”。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InvalidEndFunction">
        <source>'End Function' must be preceded by a matching 'Function'.</source>
        <target state="translated">'“End Function”前面必须是匹配的“Function”。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InvalidEndProperty">
        <source>'End Property' must be preceded by a matching 'Property'.</source>
        <target state="translated">'“End Property”前面必须是匹配的“Property”。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ModuleCantUseMethodSpecifier1">
        <source>Methods in a Module cannot be declared '{0}'.</source>
        <target state="translated">模块中的方法不能声明为“{0}”。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ModuleCantUseEventSpecifier1">
        <source>Events in a Module cannot be declared '{0}'.</source>
        <target state="translated">模块中的事件不能声明为“{0}”。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_StructCantUseVarSpecifier1">
        <source>Members in a Structure cannot be declared '{0}'.</source>
        <target state="translated">结构中的成员不能声明为“{0}”。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InvalidOverrideDueToReturn2">
        <source>'{0}' cannot override '{1}' because they differ by their return types.</source>
        <target state="translated">'“{0}”无法重写“{1}”，因为它们的返回类型不同。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_InvalidOverrideDueToTupleNames2">
        <source>'{0}' cannot override '{1}' because they differ by their tuple element names.</source>
        <target state="translated">'“{0}”不能替代“{1}”，因为它们的元组元素名称不同。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_InvalidOverrideDueToTupleNames2_Title">
        <source>Member cannot override because it differs by its tuple element names.</source>
        <target state="translated">成员不能替代，因为它的元组元素名称不同。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ConstantWithNoValue">
        <source>Constants must have a value.</source>
        <target state="translated">常量必须具有值。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExpressionOverflow1">
        <source>Constant expression not representable in type '{0}'.</source>
        <target state="translated">常量表达式无法在类型“{0}”中表示。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DuplicatePropertyGet">
        <source>'Get' is already declared.</source>
        <target state="translated">'已声明 "Get"。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DuplicatePropertySet">
        <source>'Set' is already declared.</source>
        <target state="translated">'已声明 "Set"。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NameNotDeclared1">
        <source>'{0}' is not declared. It may be inaccessible due to its protection level.</source>
        <target state="translated">'未声明“{0}”。由于其保护级别，它可能无法访问。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BinaryOperands3">
        <source>Operator '{0}' is not defined for types '{1}' and '{2}'.</source>
        <target state="translated">没有为类型“{1}”和“{2}”定义运算符“{0}”。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExpectedProcedure">
        <source>Expression is not a method.</source>
        <target state="translated">表达式不是方法。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_OmittedArgument2">
        <source>Argument not specified for parameter '{0}' of '{1}'.</source>
        <target state="translated">没有为“{1}”的形参“{0}”指定实参。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NameNotMember2">
        <source>'{0}' is not a member of '{1}'.</source>
        <target state="translated">'“{0}”不是“{1}”的成员。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_EndClassNoClass">
        <source>'End Class' must be preceded by a matching 'Class'.</source>
        <target state="translated">'"End Class" 前面必须是匹配的 "Class"。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadClassFlags1">
        <source>Classes cannot be declared '{0}'.</source>
        <target state="translated">类不能声明为“{0}”。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ImportsMustBeFirst">
        <source>'Imports' statements must precede any declarations.</source>
        <target state="translated">'“Imports”语句前面必须是声明。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NonNamespaceOrClassOnImport2">
        <source>'{1}' for the Imports '{0}' does not refer to a Namespace, Class, Structure, Enum or Module.</source>
        <target state="translated">'Imports “{0}”的“{1}”不引用命名空间、类、结构、枚举或模块。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_TypecharNotallowed">
        <source>Type declaration characters are not valid in this context.</source>
        <target state="translated">类型声明字符在此上下文中无效。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ObjectReferenceNotSupplied">
        <source>Reference to a non-shared member requires an object reference.</source>
        <target state="translated">对非共享成员的引用要求对象引用。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_MyClassNotInClass">
        <source>'MyClass' cannot be used outside of a class.</source>
        <target state="translated">'"MyClass" 不能在类的外部使用。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_IndexedNotArrayOrProc">
        <source>Expression is not an array or a method, and cannot have an argument list.</source>
        <target state="translated">表达式不是数组或方法，不能具有参数列表。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_EventSourceIsArray">
        <source>'WithEvents' variables cannot be typed as arrays.</source>
        <target state="translated">'“WithEvents”变量不能类型化为数组。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_SharedConstructorWithParams">
        <source>Shared 'Sub New' cannot have any parameters.</source>
        <target state="translated">共享的 "Sub New" 不能具有任何参数。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_SharedConstructorIllegalSpec1">
        <source>Shared 'Sub New' cannot be declared '{0}'.</source>
        <target state="translated">共享的“Sub New”不能声明为“{0}”。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExpectedEndClass">
        <source>'Class' statement must end with a matching 'End Class'.</source>
        <target state="translated">'“Class”语句必须以匹配的“End Class”结束。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_UnaryOperand2">
        <source>Operator '{0}' is not defined for type '{1}'.</source>
        <target state="translated">没有为类型“{1}”定义运算符“{0}”。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadFlagsWithDefault1">
        <source>'Default' cannot be combined with '{0}'.</source>
        <target state="translated">'“Default”不能与“{0}”组合。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_VoidValue">
        <source>Expression does not produce a value.</source>
        <target state="translated">表达式不产生值。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ConstructorFunction">
        <source>Constructor must be declared as a Sub, not as a Function.</source>
        <target state="translated">构造函数必须声明为 Sub，而不是 Function。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InvalidLiteralExponent">
        <source>Exponent is not valid.</source>
        <target state="translated">指数无效。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NewCannotHandleEvents">
        <source>'Sub New' cannot handle events.</source>
        <target state="translated">'"Sub New" 无法处理事件。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CircularEvaluation1">
        <source>Constant '{0}' cannot depend on its own value.</source>
        <target state="translated">常量“{0}”不能依赖自身的值。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadFlagsOnSharedMeth1">
        <source>'Shared' cannot be combined with '{0}' on a method declaration.</source>
        <target state="translated">'“Shared”不能与方法声明上的“{0}”组合。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadFlagsOnSharedProperty1">
        <source>'Shared' cannot be combined with '{0}' on a property declaration.</source>
        <target state="translated">'“Shared”不能与属性声明上的“{0}”组合。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadFlagsOnStdModuleProperty1">
        <source>Properties in a Module cannot be declared '{0}'.</source>
        <target state="translated">模块中的属性不能声明为“{0}”。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_SharedOnProcThatImpl">
        <source>Methods or events that implement interface members cannot be declared 'Shared'.</source>
        <target state="translated">实现接口成员的方法或事件不能声明为 "Shared"。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NoWithEventsVarOnHandlesList">
        <source>Handles clause requires a WithEvents variable defined in the containing type or one of its base types.</source>
        <target state="translated">Handles 子句要求一个在包含类型或它的某个基类型中定义的 WithEvents 变量。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InheritanceAccessMismatch5">
        <source>'{0}' cannot inherit from {1} '{2}' because it expands the access of the base {1} to {3} '{4}'.</source>
        <target state="translated">'“{0}”将对基 {1} 的访问扩展到 {3}“{4}”，因此无法从 {1}“{2}”继承。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NarrowingConversionDisallowed2">
        <source>Option Strict On disallows implicit conversions from '{0}' to '{1}'.</source>
        <target state="translated">Option Strict On 不允许从“{0}”到“{1}”的隐式转换。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NoArgumentCountOverloadCandidates1">
        <source>Overload resolution failed because no accessible '{0}' accepts this number of arguments.</source>
        <target state="translated">重载决策失败，因为没有可访问的“{0}”接受此数目的参数。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NoViableOverloadCandidates1">
        <source>Overload resolution failed because no '{0}' is accessible.</source>
        <target state="translated">重载决策失败，因为没有可访问的“{0}”。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NoCallableOverloadCandidates2">
        <source>Overload resolution failed because no accessible '{0}' can be called with these arguments:{1}</source>
        <target state="translated">重载决策失败，因为没有可使用这些参数调用的可访问“{0}”: {1}</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadOverloadCandidates2">
        <source>Overload resolution failed because no accessible '{0}' can be called:{1}</source>
        <target state="translated">重载决策失败，原因是没有可访问的“{0}”可以进行调用:{1}</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NoNonNarrowingOverloadCandidates2">
        <source>Overload resolution failed because no accessible '{0}' can be called without a narrowing conversion:{1}</source>
        <target state="translated">重载决策失败，因为没有不使用收缩转换即可调用的可访问重载“{0}”: {1}</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ArgumentNarrowing3">
        <source>Argument matching parameter '{0}' narrows from '{1}' to '{2}'.</source>
        <target state="translated">与形参“{0}”匹配的实参从“{1}”收缩到“{2}”。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NoMostSpecificOverload2">
        <source>Overload resolution failed because no accessible '{0}' is most specific for these arguments:{1}</source>
        <target state="translated">重载决策失败，因为没有可访问的“{0}”最适合这些参数: {1}</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NotMostSpecificOverload">
        <source>Not most specific.</source>
        <target state="translated">不是最适合。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_OverloadCandidate2">
        <source>
    '{0}': {1}</source>
        <target state="translated">
  “{0}”: {1}</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NoGetProperty1">
        <source>Property '{0}' is 'WriteOnly'.</source>
        <target state="translated">属性“{0}”为“WriteOnly”。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NoSetProperty1">
        <source>Property '{0}' is 'ReadOnly'.</source>
        <target state="translated">属性“{0}”为“ReadOnly”。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ParamTypingInconsistency">
        <source>All parameters must be explicitly typed if any of them are explicitly typed.</source>
        <target state="translated">如果任何一个参数已显式类型化，则所有参数都必须显式类型化。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ParamNameFunctionNameCollision">
        <source>Parameter cannot have the same name as its defining function.</source>
        <target state="translated">参数不能与它的定义函数同名。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DateToDoubleConversion">
        <source>Conversion from 'Date' to 'Double' requires calling the 'Date.ToOADate' method.</source>
        <target state="translated">从“Date”到“Double”的转换需要调用“Date.ToOADate”方法。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DoubleToDateConversion">
        <source>Conversion from 'Double' to 'Date' requires calling the 'Date.FromOADate' method.</source>
        <target state="translated">从 "Double" 到 "Date" 的转换需要调用 "Date.FromOADate" 方法。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ZeroDivide">
        <source>Division by zero occurred while evaluating this expression.</source>
        <target state="translated">计算此表达式时出现被零除的情况。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_TryAndOnErrorDoNotMix">
        <source>Method cannot contain both a 'Try' statement and an 'On Error' or 'Resume' statement.</source>
        <target state="translated">方法不能既包含 "Try" 语句，又包含 "On Error" 或 "Resume" 语句。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PropertyAccessIgnored">
        <source>Property access must assign to the property or use its value.</source>
        <target state="translated">属性访问必须分配给属性或使用属性值。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InterfaceNoDefault1">
        <source>'{0}' cannot be indexed because it has no default property.</source>
        <target state="translated">'无法为“{0}”编制索引，因为它没有默认属性。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InvalidAssemblyAttribute1">
        <source>Attribute '{0}' cannot be applied to an assembly.</source>
        <target state="translated">属性“{0}”不能应用于程序集。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InvalidModuleAttribute1">
        <source>Attribute '{0}' cannot be applied to a module.</source>
        <target state="translated">属性“{0}”不能应用于模块。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AmbiguousInUnnamedNamespace1">
        <source>'{0}' is ambiguous.</source>
        <target state="translated">'“{0}”不明确。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DefaultMemberNotProperty1">
        <source>Default member of '{0}' is not a property.</source>
        <target state="translated">“{0}”的默认成员不是属性。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AmbiguousInNamespace2">
        <source>'{0}' is ambiguous in the namespace '{1}'.</source>
        <target state="translated">'“{1}”在命名空间中“{0}”不明确。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AmbiguousInImports2">
        <source>'{0}' is ambiguous, imported from the namespaces or types '{1}'.</source>
        <target state="translated">'“{0}”不明确，从命名空间或类型“{1}”导入。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AmbiguousInModules2">
        <source>'{0}' is ambiguous between declarations in Modules '{1}'.</source>
        <target state="translated">'“{0}”在模块“{1}”中的声明之间不明确。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AmbiguousInNamespaces2">
        <source>'{0}' is ambiguous between declarations in namespaces '{1}'.</source>
        <target state="translated">'“{0}”在命名空间“{1}”中的声明之间不明确。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ArrayInitializerTooFewDimensions">
        <source>Array initializer has too few dimensions.</source>
        <target state="translated">数组初始值设定项的维数太少。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ArrayInitializerTooManyDimensions">
        <source>Array initializer has too many dimensions.</source>
        <target state="translated">数组初始值设定项的维数太多。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InitializerTooFewElements1">
        <source>Array initializer is missing {0} elements.</source>
        <target state="translated">数组初始值设定项缺少 {0} 个元素。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InitializerTooManyElements1">
        <source>Array initializer has {0} too many elements.</source>
        <target state="translated">数组初始值设定项拥有的元素太多({0}个)。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NewOnAbstractClass">
        <source>'New' cannot be used on a class that is declared 'MustInherit'.</source>
        <target state="translated">'"New" 不能在声明为 "MustInherit" 的类上使用。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DuplicateNamedImportAlias1">
        <source>Alias '{0}' is already declared.</source>
        <target state="translated">已声明别名“{0}”。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DuplicatePrefix">
        <source>XML namespace prefix '{0}' is already declared.</source>
        <target state="translated">已声明 XML 命名空间前缀“{0}”。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_StrictDisallowsLateBinding">
        <source>Option Strict On disallows late binding.</source>
        <target state="translated">Option Strict On 不允许后期绑定。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AddressOfOperandNotMethod">
        <source>'AddressOf' operand must be the name of a method (without parentheses).</source>
        <target state="translated">'“AddressOf”操作数必须是某个方法的名称(不带圆括号)。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_EndExternalSource">
        <source>'#End ExternalSource' must be preceded by a matching '#ExternalSource'.</source>
        <target state="translated">'"#End ExternalSource" 前面必须是匹配的 "#ExternalSource"。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExpectedEndExternalSource">
        <source>'#ExternalSource' statement must end with a matching '#End ExternalSource'.</source>
        <target state="translated">'“#ExternalSource”语句必须以匹配的“#End ExternalSource”结束。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NestedExternalSource">
        <source>'#ExternalSource' directives cannot be nested.</source>
        <target state="translated">'"#ExternalSource" 指令不能嵌套。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AddressOfNotDelegate1">
        <source>'AddressOf' expression cannot be converted to '{0}' because '{0}' is not a delegate type.</source>
        <target state="translated">'“AddressOf”表达式无法转换为“{0} ”，因为“{0}”不是委托类型。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_SyncLockRequiresReferenceType1">
        <source>'SyncLock' operand cannot be of type '{0}' because '{0}' is not a reference type.</source>
        <target state="translated">'"SyncLock" 操作数不能是“{0}”类型，因为“{0}”不是引用类型。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_MethodAlreadyImplemented2">
        <source>'{0}.{1}' cannot be implemented more than once.</source>
        <target state="translated">'“{0}.{1}”不能多次实现。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DuplicateInInherits1">
        <source>'{0}' cannot be inherited more than once.</source>
        <target state="translated">'“{0}”不能被继承多次。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NamedParamArrayArgument">
        <source>Named argument cannot match a ParamArray parameter.</source>
        <target state="translated">命名实参不能匹配 ParamArray 形参。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_OmittedParamArrayArgument">
        <source>Omitted argument cannot match a ParamArray parameter.</source>
        <target state="translated">省略的实参不能匹配 ParamArray 形参。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ParamArrayArgumentMismatch">
        <source>Argument cannot match a ParamArray parameter.</source>
        <target state="translated">参数不能匹配 ParamArray 参数。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_EventNotFound1">
        <source>Event '{0}' cannot be found.</source>
        <target state="translated">找不到事件“{0}”。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ModuleCantUseVariableSpecifier1">
        <source>Variables in Modules cannot be declared '{0}'.</source>
        <target state="translated">模块中的变量不能声明为“{0}”。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_SharedEventNeedsSharedHandler">
        <source>Events of shared WithEvents variables cannot be handled by non-shared methods.</source>
        <target state="translated">共享 WithEvents 变量的事件不能由非共享方法处理。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExpectedMinus">
        <source>'-' expected.</source>
        <target state="translated">'应为“-”。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InterfaceMemberSyntax">
        <source>Interface members must be methods, properties, events, or type definitions.</source>
        <target state="translated">接口成员必须是方法、属性、事件或类型定义。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InvInsideInterface">
        <source>Statement cannot appear within an interface body.</source>
        <target state="translated">语句不能出现在接口体内。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InvInsideEndsInterface">
        <source>Statement cannot appear within an interface body. End of interface assumed.</source>
        <target state="translated">语句不能出现在接口体内。假定为接口末尾。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadFlagsInNotInheritableClass1">
        <source>'NotInheritable' classes cannot have members declared '{0}'.</source>
        <target state="translated">'“NotInheritable”类不能有声明为“{0}”的成员。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BaseOnlyClassesMustBeExplicit2">
        <source>Class '{0}' must either be declared 'MustInherit' or override the following inherited 'MustOverride' member(s): {1}.</source>
        <target state="translated">类“{0}”必须声明为“MustInherit”或重写以下继承的“MustOverride”成员: {1}。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_MustInheritEventNotOverridden">
        <source>'{0}' is a MustOverride event in the base class '{1}'. Visual Basic does not support event overriding. You must either provide an implementation for the event in the base class, or make class '{2}' MustInherit.</source>
        <target state="translated">'“{0}”是基类“{1}” 中的 MustOverride 事件。Visual Basic 不支持事件替代。必须提供基类中事件的实现或让类“{2}“成为 MustInherit。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NegativeArraySize">
        <source>Array dimensions cannot have a negative size.</source>
        <target state="translated">数组维数的大小不能为负。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_MyClassAbstractCall1">
        <source>'MustOverride' method '{0}' cannot be called with 'MyClass'.</source>
        <target state="translated">'无法用“MyClass”调用“MustOverride”方法“{0}”。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_EndDisallowedInDllProjects">
        <source>'End' statement cannot be used in class library projects.</source>
        <target state="translated">'在类库项目中不能使用 "End" 语句。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BlockLocalShadowing1">
        <source>Variable '{0}' hides a variable in an enclosing block.</source>
        <target state="translated">变量“{0}”在封闭块中隐藏变量。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ModuleNotAtNamespace">
        <source>'Module' statements can occur only at file or namespace level.</source>
        <target state="translated">'"Module" 语句只能出现在文件级或命名空间级。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NamespaceNotAtNamespace">
        <source>'Namespace' statements can occur only at file or namespace level.</source>
        <target state="translated">'"Namespace" 语句只能出现在文件级或命名空间级。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InvInsideEnum">
        <source>Statement cannot appear within an Enum body.</source>
        <target state="translated">语句不能出现在枚举体内。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InvInsideEndsEnum">
        <source>Statement cannot appear within an Enum body. End of Enum assumed.</source>
        <target state="translated">语句不能出现在枚举体内。假定已到达枚举末尾。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InvalidOptionStrict">
        <source>'Option Strict' can be followed only by 'On' or 'Off'.</source>
        <target state="translated">'"Option Strict" 的后面只能跟 "On" 或 "Off"。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_EndStructureNoStructure">
        <source>'End Structure' must be preceded by a matching 'Structure'.</source>
        <target state="translated">'"End Structure" 前面必须是匹配的 "Structure"。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_EndModuleNoModule">
        <source>'End Module' must be preceded by a matching 'Module'.</source>
        <target state="translated">'"End Module" 前面必须是匹配的 "Module"。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_EndNamespaceNoNamespace">
        <source>'End Namespace' must be preceded by a matching 'Namespace'.</source>
        <target state="translated">'"End Namespace" 前面必须是匹配的 "Namespace"。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExpectedEndStructure">
        <source>'Structure' statement must end with a matching 'End Structure'.</source>
        <target state="translated">'“Structure”语句必须以匹配的“End Structure”结束。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExpectedEndModule">
        <source>'Module' statement must end with a matching 'End Module'.</source>
        <target state="translated">'“Module”语句必须以匹配的“End Module”结束。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExpectedEndNamespace">
        <source>'Namespace' statement must end with a matching 'End Namespace'.</source>
        <target state="translated">'“Namespace”语句必须以匹配的“End Namespace”结束。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_OptionStmtWrongOrder">
        <source>'Option' statements must precede any declarations or 'Imports' statements.</source>
        <target state="translated">'"Option" 语句必须位于任何声明或 "Imports" 语句之前。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_StructCantInherit">
        <source>Structures cannot have 'Inherits' statements.</source>
        <target state="translated">结构不能有 "Inherits" 语句。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NewInStruct">
        <source>Structures cannot declare a non-shared 'Sub New' with no parameters.</source>
        <target state="translated">结构不能声明没有参数的非共享 "Sub New"。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InvalidEndGet">
        <source>'End Get' must be preceded by a matching 'Get'.</source>
        <target state="translated">'“End Get”前面必须是匹配的“Get”。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_MissingEndGet">
        <source>'Get' statement must end with a matching 'End Get'.</source>
        <target state="translated">'"Get" 语句必须以匹配的 "End Get" 结束。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InvalidEndSet">
        <source>'End Set' must be preceded by a matching 'Set'.</source>
        <target state="translated">'“End Set”前面必须是匹配的“Set”。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_MissingEndSet">
        <source>'Set' statement must end with a matching 'End Set'.</source>
        <target state="translated">'"Set" 语句必须以匹配的 "End Set" 结束。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InvInsideEndsProperty">
        <source>Statement cannot appear within a property body. End of property assumed.</source>
        <target state="translated">语句不能出现在属性体内。假定为属性末尾。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DuplicateWriteabilityCategoryUsed">
        <source>'ReadOnly' and 'WriteOnly' cannot be combined.</source>
        <target state="translated">'"ReadOnly" 不能与 "WriteOnly" 组合。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExpectedGreater">
        <source>'&gt;' expected.</source>
        <target state="translated">'应为“&gt;”。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AttributeStmtWrongOrder">
        <source>Assembly or Module attribute statements must precede any declarations in a file.</source>
        <target state="translated">Assembly 或 Module 特性语句必须位于文件中的任何声明之前。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NoExplicitArraySizes">
        <source>Array bounds cannot appear in type specifiers.</source>
        <target state="translated">数组界限不能出现在类型说明符中。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadPropertyFlags1">
        <source>Properties cannot be declared '{0}'.</source>
        <target state="translated">属性不能声明为“{0}”。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InvalidOptionExplicit">
        <source>'Option Explicit' can be followed only by 'On' or 'Off'.</source>
        <target state="translated">'"Option Explicit" 的后面只能跟 "On" 或 "Off"。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_MultipleParameterSpecifiers">
        <source>'ByVal' and 'ByRef' cannot be combined.</source>
        <target state="translated">'“ByVal”不能与“ByRef”组合。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_MultipleOptionalParameterSpecifiers">
        <source>'Optional' and 'ParamArray' cannot be combined.</source>
        <target state="translated">"Optional" 不能与 "ParamArray" 组合。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_UnsupportedProperty1">
        <source>Property '{0}' is of an unsupported type.</source>
        <target state="translated">属性“{0}”的类型不受支持。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InvalidOptionalParameterUsage1">
        <source>Attribute '{0}' cannot be applied to a method with optional parameters.</source>
        <target state="translated">属性“{0}”不能应用于具有可选参数的方法。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ReturnFromNonFunction">
        <source>'Return' statement in a Sub or a Set cannot return a value.</source>
        <target state="translated">'Sub 或 Set 中的 "Return" 语句不能返回值。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_UnterminatedStringLiteral">
        <source>String constants must end with a double quote.</source>
        <target state="translated">字符串常量必须以双引号结束。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_UnsupportedType1">
        <source>'{0}' is an unsupported type.</source>
        <target state="translated">'“{0}”是不受支持的类型。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InvalidEnumBase">
        <source>Enums must be declared as an integral type.</source>
        <target state="translated">枚举必须声明为整型。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ByRefIllegal1">
        <source>{0} parameters cannot be declared 'ByRef'.</source>
        <target state="translated">{0} 参数不能声明为“ByRef”。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_UnreferencedAssembly3">
        <source>Reference required to assembly '{0}' containing the type '{1}'. Add one to your project.</source>
        <target state="translated">需要对程序集“{0}”(包含类型“{1}”)的引用。请在项目中添加一个。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_UnreferencedModule3">
        <source>Reference required to module '{0}' containing the type '{1}'. Add one to your project.</source>
        <target state="translated">需要对模块“{0}”(包含类型“{1}”)的引用。请在项目中添加一个。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ReturnWithoutValue">
        <source>'Return' statement in a Function, Get, or Operator must return a value.</source>
        <target state="translated">'Function、Get 或 Operator 中的 "Return" 语句必须返回值。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_UnsupportedField1">
        <source>Field '{0}' is of an unsupported type.</source>
        <target state="translated">字段“{0}”的类型不受支持。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_UnsupportedMethod1">
        <source>'{0}' has a return type that is not supported or parameter types that are not supported.</source>
        <target state="translated">'“{0}”有不受支持的返回类型或不受支持的参数类型。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NoNonIndexProperty1">
        <source>Property '{0}' with no parameters cannot be found.</source>
        <target state="translated">无法找到不带参数的属性“{0}”。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadAttributePropertyType1">
        <source>Property or field '{0}' does not have a valid attribute type.</source>
        <target state="translated">属性或字段“{0}”没有有效的特性类型。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_LocalsCannotHaveAttributes">
        <source>Attributes cannot be applied to local variables.</source>
        <target state="translated">特性不能应用于局部变量。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PropertyOrFieldNotDefined1">
        <source>Field or property '{0}' is not found.</source>
        <target state="translated">找不到字段或属性“{0}”。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InvalidAttributeUsage2">
        <source>Attribute '{0}' cannot be applied to '{1}' because the attribute is not valid on this declaration type.</source>
        <target state="translated">属性“{0}”不能应用于“{1}”，因为该属性在此声明类型中无效。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InvalidAttributeUsageOnAccessor">
        <source>Attribute '{0}' cannot be applied to '{1}' of '{2}' because the attribute is not valid on this declaration type.</source>
        <target state="translated">属性“{0}”不能应用于“{2}”的“{1}”，因为该属性在此声明类型中无效。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NestedTypeInInheritsClause2">
        <source>Class '{0}' cannot reference its nested type '{1}' in Inherits clause.</source>
        <target state="translated">类“{0}”无法在 Inherits 子句中引用其嵌套类型“{1}”。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_TypeInItsInheritsClause1">
        <source>Class '{0}' cannot reference itself in Inherits clause.</source>
        <target state="translated">类“{0}”不能在 Inherits 子句中引用自己。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BaseTypeReferences2">
        <source>
    Base type of '{0}' needs '{1}' to be resolved.</source>
        <target state="translated">
  “{0}”基类型需要解析“{1}”。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_IllegalBaseTypeReferences3">
        <source>Inherits clause of {0} '{1}' causes cyclic dependency: {2}</source>
        <target state="translated">{0}“{1}”的继承子句会导致循环依赖: {2}</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InvalidMultipleAttributeUsage1">
        <source>Attribute '{0}' cannot be applied multiple times.</source>
        <target state="translated">属性“{0}”不能应用多次。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InvalidMultipleAttributeUsageInNetModule2">
        <source>Attribute '{0}' in '{1}' cannot be applied multiple times.</source>
        <target state="translated">“{1}”中的属性“{0}”不能应用多次。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CantThrowNonException">
        <source>'Throw' operand must derive from 'System.Exception'.</source>
        <target state="translated">'“Throw”操作数必须从“System.Exception”派生。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_MustBeInCatchToRethrow">
        <source>'Throw' statement cannot omit operand outside a 'Catch' statement or inside a 'Finally' statement.</source>
        <target state="translated">'"Throw" 语句在 "Catch" 语句外或 "Finally" 语句内不能省略操作数。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ParamArrayMustBeByVal">
        <source>ParamArray parameters must be declared 'ByVal'.</source>
        <target state="translated">ParamArray 参数必须声明为 "ByVal"。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_UseOfObsoleteSymbol2">
        <source>'{0}' is obsolete: '{1}'.</source>
        <target state="translated">'“{0}”已过时:“{1}”。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RedimNoSizes">
        <source>'ReDim' statements require a parenthesized list of the new bounds of each dimension of the array.</source>
        <target state="translated">"ReDim" 语句需要一个带圆括号的列表，该列表列出数组每个维度的新界限。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InitWithMultipleDeclarators">
        <source>Explicit initialization is not permitted with multiple variables declared with a single type specifier.</source>
        <target state="translated">不允许通过用单个类型说明符声明多个变量来进行显式初始化。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InitWithExplicitArraySizes">
        <source>Explicit initialization is not permitted for arrays declared with explicit bounds.</source>
        <target state="translated">对于用显式界限声明的数组不允许进行显式初始化。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_EndSyncLockNoSyncLock">
        <source>'End SyncLock' must be preceded by a matching 'SyncLock'.</source>
        <target state="translated">'“End SyncLock”前面必须是匹配的“SyncLock”。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExpectedEndSyncLock">
        <source>'SyncLock' statement must end with a matching 'End SyncLock'.</source>
        <target state="translated">'“SyncLock”语句必须以匹配的“End SyncLock”结束。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NameNotEvent2">
        <source>'{0}' is not an event of '{1}'.</source>
        <target state="translated">'“{0}”不是“{1}”的事件。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AddOrRemoveHandlerEvent">
        <source>'AddHandler' or 'RemoveHandler' statement event operand must be a dot-qualified expression or a simple name.</source>
        <target state="translated">'“AddHandler”或“RemoveHandler”语句事件操作数必须是以点限定的表达式或者是简单的名称。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_UnrecognizedEnd">
        <source>'End' statement not valid.</source>
        <target state="translated">'"End" 语句无效。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ArrayInitForNonArray2">
        <source>Array initializers are valid only for arrays, but the type of '{0}' is '{1}'.</source>
        <target state="translated">数组初始值设定项仅对数组有效，但“{0}”的类型是“{1}”。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_EndRegionNoRegion">
        <source>'#End Region' must be preceded by a matching '#Region'.</source>
        <target state="translated">'"#End Region" 前面必须是匹配的 "#Region"。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExpectedEndRegion">
        <source>'#Region' statement must end with a matching '#End Region'.</source>
        <target state="translated">'"#Region" 语句必须以匹配的 "#End Region" 结束。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InheritsStmtWrongOrder">
        <source>'Inherits' statement must precede all declarations in a class.</source>
        <target state="translated">'“Inherits”语句必须位于类中的所有声明之前。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AmbiguousAcrossInterfaces3">
        <source>'{0}' is ambiguous across the inherited interfaces '{1}' and '{2}'.</source>
        <target state="translated">'“{0}”在继承接口“{1}”和“{2}”之间不明确。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DefaultPropertyAmbiguousAcrossInterfaces4">
        <source>Default property access is ambiguous between the inherited interface members '{0}' of interface '{1}' and '{2}' of interface '{3}'.</source>
        <target state="translated">默认属性访问在接口“{1}”的继承接口成员“{0}”和接口“{3}”的继承接口成员“{2}”之间不明确。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InterfaceEventCantUse1">
        <source>Events in interfaces cannot be declared '{0}'.</source>
        <target state="translated">接口中的事件无法声明为“{0}”。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExecutableAsDeclaration">
        <source>Statement cannot appear outside of a method body.</source>
        <target state="translated">语句不能出现在方法主体外。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_StructureNoDefault1">
        <source>Structure '{0}' cannot be indexed because it has no default property.</source>
        <target state="translated">无法为结构“{0}”编制索引，因为它没有默认属性。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_MustShadow2">
        <source>{0} '{1}' must be declared 'Shadows' because another member with this name is declared 'Shadows'.</source>
        <target state="translated">{0}“{1}”必须声明为“Shadows”，因为具有此名称的另一个成员被声明为“Shadows”。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_OverrideWithOptionalTypes2">
        <source>'{0}' cannot override '{1}' because they differ by the types of optional parameters.</source>
        <target state="translated">'“{0}”无法重写“{1}”，因为它们在可选参数类型上存在差异。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExpectedEndOfExpression">
        <source>End of expression expected.</source>
        <target state="translated">应为表达式结尾。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_StructsCannotHandleEvents">
        <source>Methods declared in structures cannot have 'Handles' clauses.</source>
        <target state="translated">结构中声明的方法不能有 "Handles" 子句。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_OverridesImpliesOverridable">
        <source>Methods declared 'Overrides' cannot be declared 'Overridable' because they are implicitly overridable.</source>
        <target state="translated">声明为 "Overrides" 的方法是隐式可重写的，因此它们不能声明为 "Overridable"。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_LocalNamedSameAsParam1">
        <source>'{0}' is already declared as a parameter of this method.</source>
        <target state="translated">'“{0}”已声明为此方法的参数。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_LocalNamedSameAsParamInLambda1">
        <source>Variable '{0}' is already declared as a parameter of this or an enclosing lambda expression.</source>
        <target state="translated">变量“{0}”已声明为此 lambda 表达式或某个封闭 lambda 表达式的参数。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ModuleCantUseTypeSpecifier1">
        <source>Type in a Module cannot be declared '{0}'.</source>
        <target state="translated">模块中的类型不能声明为“{0}”。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InValidSubMainsFound1">
        <source>No accessible 'Main' method with an appropriate signature was found in '{0}'.</source>
        <target state="translated">“{0}”中找不到带有适当签名的可访问“Main”方法。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_MoreThanOneValidMainWasFound2">
        <source>'Sub Main' is declared more than once in '{0}': {1}</source>
        <target state="translated">'在“{0}”中多次声明了“Sub Main”: {1}</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CannotConvertValue2">
        <source>Value '{0}' cannot be converted to '{1}'.</source>
        <target state="translated">值“{0}”无法转换为“{1}”。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_OnErrorInSyncLock">
        <source>'On Error' statements are not valid within 'SyncLock' statements.</source>
        <target state="translated">'"On Error" 语句在 "SyncLock" 语句内无效。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NarrowingConversionCollection2">
        <source>Option Strict On disallows implicit conversions from '{0}' to '{1}'; the Visual Basic 6.0 collection type is not compatible with the .NET Framework collection type.</source>
        <target state="translated">Option Strict On 不允许从“{0}”到“{1}”的隐式转换；Visual Basic 6.0 集合类型与 .NET Framework 集合类型不兼容。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_GotoIntoTryHandler">
        <source>'GoTo {0}' is not valid because '{0}' is inside a 'Try', 'Catch' or 'Finally' statement that does not contain this statement.</source>
        <target state="translated">'“GoTo {0}”语句无效，因为“{0}”位于不包含此语句的“Try”、“Catch”或“Finally”语句中。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_GotoIntoSyncLock">
        <source>'GoTo {0}' is not valid because '{0}' is inside a 'SyncLock' statement that does not contain this statement.</source>
        <target state="translated">'“GoTo {0}”无效，因为“{0}”位于不包含此语句的“SyncLock”语句中。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_GotoIntoWith">
        <source>'GoTo {0}' is not valid because '{0}' is inside a 'With' statement that does not contain this statement.</source>
        <target state="translated">'“GoTo {0}”无效，因为“{0}”位于不包含此语句的“With”语句中。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_GotoIntoFor">
        <source>'GoTo {0}' is not valid because '{0}' is inside a 'For' or 'For Each' statement that does not contain this statement.</source>
        <target state="translated">'“GoTo {0}”无效，因为“{0}”位于不包含此语句的“For”或“For Each”语句中。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadAttributeNonPublicConstructor">
        <source>Attribute cannot be used because it does not have a Public constructor.</source>
        <target state="translated">特性没有 Public 构造函数，因此不能使用。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DefaultEventNotFound1">
        <source>Event '{0}' specified by the 'DefaultEvent' attribute is not a publicly accessible event for this class.</source>
        <target state="translated">由“DefaultEvent”属性指定的事件“{0}”不是该类的公共可访问事件。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InvalidNonSerializedUsage">
        <source>'NonSerialized' attribute will not have any effect on this member because its containing class is not exposed as 'Serializable'.</source>
        <target state="translated">'"NonSerialized" 特性对此成员无效，因为它的包含类不作为 "Serializable" 公开。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExpectedContinueKind">
        <source>'Continue' must be followed by 'Do', 'For' or 'While'.</source>
        <target state="translated">'“Continue”的后面必须跟有“Do”、“For”或“While”。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ContinueDoNotWithinDo">
        <source>'Continue Do' can only appear inside a 'Do' statement.</source>
        <target state="translated">'“Continue Do”只能出现在“Do”语句内。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ContinueForNotWithinFor">
        <source>'Continue For' can only appear inside a 'For' statement.</source>
        <target state="translated">'“Continue For”只能出现在“For”语句内。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ContinueWhileNotWithinWhile">
        <source>'Continue While' can only appear inside a 'While' statement.</source>
        <target state="translated">'“Continue While”只能出现在“While”语句内。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DuplicateParameterSpecifier">
        <source>Parameter specifier is duplicated.</source>
        <target state="translated">参数说明符重复。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ModuleCantUseDLLDeclareSpecifier1">
        <source>'Declare' statements in a Module cannot be declared '{0}'.</source>
        <target state="translated">'模块中的“Declare”语句不能声明为“{0}”。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_StructCantUseDLLDeclareSpecifier1">
        <source>'Declare' statements in a structure cannot be declared '{0}'.</source>
        <target state="translated">'结构中的“Declare”语句不能声明为“{0}”。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_TryCastOfValueType1">
        <source>'TryCast' operand must be reference type, but '{0}' is a value type.</source>
        <target state="translated">'“TryCast”操作数必须是引用类型，但“{0}”是值类型。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_TryCastOfUnconstrainedTypeParam1">
        <source>'TryCast' operands must be class-constrained type parameter, but '{0}' has no class constraint.</source>
        <target state="translated">'“TryCast”操作数必须是类约束类型参数，但“{0}”没有类约束。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AmbiguousDelegateBinding2">
        <source>No accessible '{0}' is most specific: {1}</source>
        <target state="translated">没有非常明确的可访问“{0}”: {1}</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_SharedStructMemberCannotSpecifyNew">
        <source>Non-shared members in a Structure cannot be declared 'New'.</source>
        <target state="translated">Structure 中的非共享成员不能声明为 "New"。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_GenericSubMainsFound1">
        <source>None of the accessible 'Main' methods with the appropriate signatures found in '{0}' can be the startup method since they are all either generic or nested in generic types.</source>
        <target state="translated">在“{0}”中找到的带有适当签名的可访问“Main”方法要么都是泛型方法，要么嵌套在泛型类型中，因此均不能用作启动方法。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_GeneralProjectImportsError3">
        <source>Error in project-level import '{0}' at '{1}' : {2}</source>
        <target state="translated">项目级 import“{0}”中的“{1}”位置出错: {2}</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InvalidTypeForAliasesImport2">
        <source>'{1}' for the Imports alias to '{0}' does not refer to a Namespace, Class, Structure, Interface, Enum or Module.</source>
        <target state="translated">'“{0}”的 Imports 别名的“{1}”不引用命名空间、类、结构、接口、枚举或模块。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_UnsupportedConstant2">
        <source>Field '{0}.{1}' has an invalid constant value.</source>
        <target state="translated">字段“{0}.{1}”具有无效常量值。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ObsoleteArgumentsNeedParens">
        <source>Method arguments must be enclosed in parentheses.</source>
        <target state="translated">方法参数必须括在括号中。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ObsoleteLineNumbersAreLabels">
        <source>Labels that are numbers must be followed by colons.</source>
        <target state="translated">数字标签后面必须跟冒号。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ObsoleteStructureNotType">
        <source>'Type' statements are no longer supported; use 'Structure' statements instead.</source>
        <target state="translated">'不再支持 "Type" 语句；请改用 "Structure" 语句。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ObsoleteObjectNotVariant">
        <source>'Variant' is no longer a supported type; use the 'Object' type instead.</source>
        <target state="translated">'"Variant" 不再是受支持的类型；请改用 "Object" 类型。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ObsoleteLetSetNotNeeded">
        <source>'Let' and 'Set' assignment statements are no longer supported.</source>
        <target state="translated">'不再支持 "Let" 和 "Set" 赋值语句。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ObsoletePropertyGetLetSet">
        <source>Property Get/Let/Set are no longer supported; use the new Property declaration syntax.</source>
        <target state="translated">不再支持 Property Get/Let/Set；请使用新的 Property 声明语法。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ObsoleteWhileWend">
        <source>'Wend' statements are no longer supported; use 'End While' statements instead.</source>
        <target state="translated">'不再支持 "Wend" 语句；请改用 "End While" 语句。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ObsoleteRedimAs">
        <source>'ReDim' statements can no longer be used to declare array variables.</source>
        <target state="translated">'"ReDim" 语句不能再用于声明数组变量。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ObsoleteOptionalWithoutValue">
        <source>Optional parameters must specify a default value.</source>
        <target state="translated">可选参数必须指定默认值。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ObsoleteGosub">
        <source>'GoSub' statements are no longer supported.</source>
        <target state="translated">'不再支持 "GoSub" 语句。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ObsoleteOnGotoGosub">
        <source>'On GoTo' and 'On GoSub' statements are no longer supported.</source>
        <target state="translated">'不再支持 "On GoTo" 和 "On GoSub" 语句。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ObsoleteEndIf">
        <source>'EndIf' statements are no longer supported; use 'End If' instead.</source>
        <target state="translated">'不再支持 "EndIf" 语句；请改用 "End If"。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ObsoleteExponent">
        <source>'D' can no longer be used to indicate an exponent, use 'E' instead.</source>
        <target state="translated">'"D" 不能再用来表示指数；请改用 "E"。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ObsoleteAsAny">
        <source>'As Any' is not supported in 'Declare' statements.</source>
        <target state="translated">'"Declare" 语句中不支持 "As Any"。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ObsoleteGetStatement">
        <source>'Get' statements are no longer supported. File I/O functionality is available in the 'Microsoft.VisualBasic' namespace.</source>
        <target state="translated">'不再支持 "Get" 语句。"Microsoft.VisualBasic" 命名空间中有文件 I/O 功能。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_OverrideWithArrayVsParamArray2">
        <source>'{0}' cannot override '{1}' because they differ by parameters declared 'ParamArray'.</source>
        <target state="translated">“{0}”无法重写“{1}”，因为它们在声明为 "ParamArray" 的参数上存在差异。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CircularBaseDependencies4">
        <source>This inheritance causes circular dependencies between {0} '{1}' and its nested or base type '{2}'.</source>
        <target state="translated">此继承将导致在 {0}“{1}”及其嵌套类型或基类型“{2}”之间产生循环依赖项。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NestedBase2">
        <source>{0} '{1}' cannot inherit from a type nested within it.</source>
        <target state="translated">{0}“{1}”不能从嵌套在它里面的类型继承。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AccessMismatchOutsideAssembly4">
        <source>'{0}' cannot expose type '{1}' outside the project through {2} '{3}'.</source>
        <target state="translated">'“{0}”不能通过 {2}“{3}”在项目外部公开类型“{1}”。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InheritanceAccessMismatchOutside3">
        <source>'{0}' cannot inherit from {1} '{2}' because it expands the access of the base {1} outside the assembly.</source>
        <target state="translated">'“{0}”将对基 {1} 的访问扩展到程序集之外，因此无法从 {1}“{2}”继承。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_UseOfObsoletePropertyAccessor3">
        <source>'{0}' accessor of '{1}' is obsolete: '{2}'.</source>
        <target state="translated">'“{1}”的“{0}”访问器已过时:“{2}”。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_UseOfObsoletePropertyAccessor2">
        <source>'{0}' accessor of '{1}' is obsolete.</source>
        <target state="translated">'“{1}”的“{0}”访问器已过时。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AccessMismatchImplementedEvent6">
        <source>'{0}' cannot expose the underlying delegate type '{1}' of the event it is implementing to {2} '{3}' through {4} '{5}'.</source>
        <target state="translated">'“{0}”不能通过 {4}“{5}”向 {2}“{3}”公开它正在实现的事件的基础委托类型“{1}”。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AccessMismatchImplementedEvent4">
        <source>'{0}' cannot expose the underlying delegate type '{1}' of the event it is implementing outside the project through {2} '{3}'.</source>
        <target state="translated">'“{0}”不能通过 {2}“{3}”公开它正在实现的事件的基础委托类型“{1}”。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InheritanceCycleInImportedType1">
        <source>Type '{0}' is not supported because it either directly or indirectly inherits from itself.</source>
        <target state="translated">类型“{0}”直接或者间接从自身继承，因此不受支持。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NoNonObsoleteConstructorOnBase3">
        <source>Class '{0}' must declare a 'Sub New' because the '{1}' in its base class '{2}' is marked obsolete.</source>
        <target state="translated">类“{0}”必须声明一个“Sub New”，因为它的基类“{2}”中的“{1}”被标记为已过时。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NoNonObsoleteConstructorOnBase4">
        <source>Class '{0}' must declare a 'Sub New' because the '{1}' in its base class '{2}' is marked obsolete: '{3}'.</source>
        <target state="translated">类“{0}”必须声明一个“Sub New”，因为它的基类“{2}”中的“{1}”被标记为已过时:“{3}”。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RequiredNonObsoleteNewCall3">
        <source>First statement of this 'Sub New' must be an explicit call to 'MyBase.New' or 'MyClass.New' because the '{0}' in the base class '{1}' of '{2}' is marked obsolete.</source>
        <target state="translated">此“Sub New”的第一条语句必须是对“MyBase.New”或“MyClass.New”的显式调用，因为“{2}”的基类“{1}”中的“{0}”被标为已过时。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RequiredNonObsoleteNewCall4">
        <source>First statement of this 'Sub New' must be an explicit call to 'MyBase.New' or 'MyClass.New' because the '{0}' in the base class '{1}' of '{2}' is marked obsolete: '{3}'.</source>
        <target state="translated">此“Sub New”的第一条语句必须是对“MyBase.New”或“MyClass.New”的显式调用，因为“{2}”的基类“{1}”中的“{0}”被标为已过时:“{3}”。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InheritsTypeArgAccessMismatch7">
        <source>'{0}' cannot inherit from {1} '{2}' because it expands the access of type '{3}' to {4} '{5}'.</source>
        <target state="translated">'“{0}”将对类型“{3}”的访问扩展到{4}“{5}”，因此无法从 {1}“{2}”继承。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InheritsTypeArgAccessMismatchOutside5">
        <source>'{0}' cannot inherit from {1} '{2}' because it expands the access of type '{3}' outside the assembly.</source>
        <target state="translated">'“{0}”将对类型“{3}”的访问扩展到程序集之外，因此无法从 {1}“{2}”继承。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PartialTypeAccessMismatch3">
        <source>Specified access '{0}' for '{1}' does not match the access '{2}' specified on one of its other partial types.</source>
        <target state="translated">“{1}”的指定访问“{0}”与它的一个其他分部类型上指定的访问“{2}”不匹配。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PartialTypeBadMustInherit1">
        <source>'MustInherit' cannot be specified for partial type '{0}' because it cannot be combined with 'NotInheritable' specified for one of its other partial types.</source>
        <target state="translated">'“MustInherit”不能为分部类型“{0}”指定，因为它不能与为该类型的某个其他分部类型指定的“NotInheritable”组合。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_MustOverOnNotInheritPartClsMem1">
        <source>'MustOverride' cannot be specified on this member because it is in a partial type that is declared 'NotInheritable' in another partial definition.</source>
        <target state="translated">'不能在此成员上指定“MustOverride”，因为它所在的分部类型在另一个分部定义中被声明为“NotInheritable”。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BaseMismatchForPartialClass3">
        <source>Base class '{0}' specified for class '{1}' cannot be different from the base class '{2}' of one of its other partial types.</source>
        <target state="translated">为类“{1}”指定的基类“{0}”不能与它的其他分部类型之一的基类“{2}”不同。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PartialTypeTypeParamNameMismatch3">
        <source>Type parameter name '{0}' does not match the name '{1}' of the corresponding type parameter defined on one of the other partial types of '{2}'.</source>
        <target state="translated">类型参数名“{0}”与在“{2}”的某个其他分部类型上定义的相应类型参数的名称“{1}”不匹配。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PartialTypeConstraintMismatch1">
        <source>Constraints for this type parameter do not match the constraints on the corresponding type parameter defined on one of the other partial types of '{0}'.</source>
        <target state="translated">此类型参数的约束与在“{0}”的某个其他分部类型上定义的相应类型参数的约束不匹配。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_LateBoundOverloadInterfaceCall1">
        <source>Late bound overload resolution cannot be applied to '{0}' because the accessing instance is an interface type.</source>
        <target state="translated">后期绑定重载决策不能应用于“{0}”，因为访问实例是一个接口类型。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RequiredAttributeConstConversion2">
        <source>Conversion from '{0}' to '{1}' cannot occur in a constant expression used as an argument to an attribute.</source>
        <target state="translated">在用作属性参数的常量表达式中不能发生从“{0}”到“{1}”的转换。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AmbiguousOverrides3">
        <source>Member '{0}' that matches this signature cannot be overridden because the class '{1}' contains multiple members with this same name and signature: {2}</source>
        <target state="translated">无法重写与此签名匹配的成员“{0}”，因为类“{1}”包含多个具有此相同名称和签名的成员: {2}</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_OverriddenCandidate1">
        <source>
   '{0}'</source>
        <target state="translated">
  “{0}”</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AmbiguousImplements3">
        <source>Member '{0}.{1}' that matches this signature cannot be implemented because the interface '{2}' contains multiple members with this same name and signature:
   '{3}'
   '{4}'</source>
        <target state="translated">无法实现与此签名匹配的成员“{0}.{1}”，因为接口“{2}”包含多个具有此相同名称和签名的成员:
  '{3}'
  '{4}'</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AddressOfNotCreatableDelegate1">
        <source>'AddressOf' expression cannot be converted to '{0}' because type '{0}' is declared 'MustInherit' and cannot be created.</source>
        <target state="translated">'“AddressOf”表达式无法转换为“{0}”，因为类型“{0}”已声明为“MustInherit”，无法创建。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ComClassGenericMethod">
        <source>Generic methods cannot be exposed to COM.</source>
        <target state="translated">泛型方法不能向 COM 公开。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_SyntaxInCastOp">
        <source>Syntax error in cast operator; two arguments separated by comma are required.</source>
        <target state="translated">强制转换运算符中有语法错误；需要两个用逗号分隔的参数。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ArrayInitializerForNonConstDim">
        <source>Array initializer cannot be specified for a non constant dimension; use the empty initializer '{}'.</source>
        <target state="translated">无法为不定维度指定数组初始值设定项；请使用空初始值设定项“{}”。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DelegateBindingFailure3">
        <source>No accessible method '{0}' has a signature compatible with delegate '{1}':{2}</source>
        <target state="translated">没有任何可访问的方法“{0}”具有与委托“{1}”兼容的签名: {2}</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_StructLayoutAttributeNotAllowed">
        <source>Attribute 'StructLayout' cannot be applied to a generic type.</source>
        <target state="translated">特性 "StructLayout" 不能应用于泛型类型。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_IterationVariableShadowLocal1">
        <source>Range variable '{0}' hides a variable in an enclosing block or a range variable previously defined in the query expression.</source>
        <target state="translated">范围变量“{0}”隐藏封闭块中的某个变量或以前在查询表达式中定义的某个范围变量。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InvalidOptionInfer">
        <source>'Option Infer' can be followed only by 'On' or 'Off'.</source>
        <target state="translated">'"Option Infer" 后面只能跟 "On" 或 "Off"。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CircularInference1">
        <source>Type of '{0}' cannot be inferred from an expression containing '{0}'.</source>
        <target state="translated">无法从包含“{0}”的表达式中推断“{0}”的类型。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InAccessibleOverridingMethod5">
        <source>'{0}' in class '{1}' cannot override '{2}' in class '{3}' because an intermediate class '{4}' overrides '{2}' in class '{3}' but is not accessible.</source>
        <target state="translated">'类“{1}”中的“{0}”不能重写类“{3}”中的“{2}”，因为中间类“{4}”重写了类“{3}”中的“{2}”，但不可访问。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NoSuitableWidestType1">
        <source>Type of '{0}' cannot be inferred because the loop bounds and the step clause do not convert to the same type.</source>
        <target state="translated">无法推断“{0}”的类型，因为循环边界和 step 子句不会转换为同一类型。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AmbiguousWidestType3">
        <source>Type of '{0}' is ambiguous because the loop bounds and the step clause do not convert to the same type.</source>
        <target state="translated">“{0}”的类型不明确，因为循环边界和 step 子句不会转换为同一类型。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExpectedAssignmentOperatorInInit">
        <source>'=' expected (object initializer).</source>
        <target state="translated">'应为 "="(对象初始值设定项)。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExpectedQualifiedNameInInit">
        <source>Name of field or property being initialized in an object initializer must start with '.'.</source>
        <target state="translated">正在对象初始值设定项中初始化的字段或属性的名称必须以 "."开头。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExpectedLbrace">
        <source>'{' expected.</source>
        <target state="translated">'应为 "{"。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_UnrecognizedTypeOrWith">
        <source>Type or 'With' expected.</source>
        <target state="translated">应为类型或 "With"。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DuplicateAggrMemberInit1">
        <source>Multiple initializations of '{0}'.  Fields and properties can be initialized only once in an object initializer expression.</source>
        <target state="translated">多次初始化“{0}”的。字段和属性只能在对象初始值设定项表达式中初始化一次。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NonFieldPropertyAggrMemberInit1">
        <source>Member '{0}' cannot be initialized in an object initializer expression because it is not a field or property.</source>
        <target state="translated">无法在对象初始值设定项表达式中初始化成员“{0}”，因为它不是一个字段或属性。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_SharedMemberAggrMemberInit1">
        <source>Member '{0}' cannot be initialized in an object initializer expression because it is shared.</source>
        <target state="translated">无法在对象初始值设定项表达式中初始化成员“{0}”，因为它是共享的。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ParameterizedPropertyInAggrInit1">
        <source>Property '{0}' cannot be initialized in an object initializer expression because it requires arguments.</source>
        <target state="translated">无法在对象初始值设定项表达式中初始化属性“{0}”，因为它需要参数。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NoZeroCountArgumentInitCandidates1">
        <source>Property '{0}' cannot be initialized in an object initializer expression because all accessible overloads require arguments.</source>
        <target state="translated">无法在对象初始值设定项表达式中初始化属性“{0}”，因为所有可访问的重载都需要参数。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AggrInitInvalidForObject">
        <source>Object initializer syntax cannot be used to initialize an instance of 'System.Object'.</source>
        <target state="translated">不能使用对象初始值设定项语法初始化“System.Object”的实例。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InitializerExpected">
        <source>Initializer expected.</source>
        <target state="translated">应为初始值设定项。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_LineContWithCommentOrNoPrecSpace">
        <source>The line continuation character '_' must be preceded by at least one white space and it must be followed by a comment or the '_' must be the last character on the line.</source>
        <target state="translated">行继续符 "_" 前面必须至少有一个空格，且其后必须有注释或 "_" 必须是该行的最后一个字符。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadModuleFile1">
        <source>Unable to load module file '{0}': {1}</source>
        <target state="translated">无法加载模块文件“{0}”: {1}</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadRefLib1">
        <source>Unable to load referenced library '{0}': {1}</source>
        <target state="translated">无法加载引用的库“{0}”: {1}</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_EventHandlerSignatureIncompatible2">
        <source>Method '{0}' cannot handle event '{1}' because they do not have a compatible signature.</source>
        <target state="translated">方法“{0}”无法处理事件“{1}”，因为它们的签名不兼容。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ConditionalCompilationConstantNotValid">
        <source>Conditional compilation constant '{1}' is not valid: {0}</source>
        <target state="translated">条件编译常数“{1}”无效: {0}</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InterfaceImplementedTwice1">
        <source>Interface '{0}' can be implemented only once by this type.</source>
        <target state="translated">接口“{0}”只能由此类型实现一次。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InterfaceImplementedTwiceWithDifferentTupleNames2">
        <source>Interface '{0}' can be implemented only once by this type, but already appears with different tuple element names, as '{1}'.</source>
        <target state="translated">接口“{0}”只能通过此类型实现一次，但已显示有不同的元组元素名称，如“{1}”。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InterfaceImplementedTwiceWithDifferentTupleNames3">
        <source>Interface '{0}' can be implemented only once by this type, but already appears with different tuple element names, as '{1}' (via '{2}').</source>
        <target state="translated">接口“{0}”只能通过此类型实现一次，但已显示有不同的元组元素名称，如“{1}”(通过“{2}”)。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InterfaceImplementedTwiceWithDifferentTupleNamesReverse3">
        <source>Interface '{0}' (via '{1}') can be implemented only once by this type, but already appears with different tuple element names, as '{2}'.</source>
        <target state="translated">接口“{0}”只能通过此类型实现一次(通过“{1}”)，但已显示有不同的元组元素名称，如“{2}”。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InterfaceImplementedTwiceWithDifferentTupleNames4">
        <source>Interface '{0}' (via '{1}') can be implemented only once by this type, but already appears with different tuple element names, as '{2}' (via '{3}').</source>
        <target state="translated">接口“{0}”只能通过此类型实现一次(通过“{1}”)，但已显示有不同的元组元素名称，如“{2}”(通过“{3}”)。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InterfaceInheritedTwiceWithDifferentTupleNames2">
        <source>Interface '{0}' can be inherited only once by this interface, but already appears with different tuple element names, as '{1}'.</source>
        <target state="translated">接口“{0}”只能通过此接口继承一次，但已显示有不同的元组元素名称，如“{1}”。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InterfaceInheritedTwiceWithDifferentTupleNames3">
        <source>Interface '{0}' can be inherited only once by this interface, but already appears with different tuple element names, as '{1}' (via '{2}').</source>
        <target state="translated">接口“{0}”只能通过此接口继承一次，但已显示有不同的元组元素名称，如“{1}”(通过“{2}”)。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InterfaceInheritedTwiceWithDifferentTupleNamesReverse3">
        <source>Interface '{0}' (via '{1}') can be inherited only once by this interface, but already appears with different tuple element names, as '{2}'.</source>
        <target state="translated">接口“{0}”只能通过此接口继承一次(通过“{1}”)，但已显示有不同的元组元素名称，如“{2}”。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InterfaceInheritedTwiceWithDifferentTupleNames4">
        <source>Interface '{0}' (via '{1}') can be inherited only once by this interface, but already appears with different tuple element names, as '{2}' (via '{3}').</source>
        <target state="translated">接口“{0}”只能通过此接口继承一次(通过“{1}”)，但已显示有不同的元组元素名称，如“{2}”(通过“{3}”)。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InterfaceNotImplemented1">
        <source>Interface '{0}' is not implemented by this class.</source>
        <target state="translated">接口“{0}”不是由此类实现的。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AmbiguousImplementsMember3">
        <source>'{0}' exists in multiple base interfaces. Use the name of the interface that declares '{0}' in the 'Implements' clause instead of the name of the derived interface.</source>
        <target state="translated">'“{0}”存在于多个基接口中。请使用在“Implements”子句中声明“{0}”的接口的名称，而不要使用派生接口的名称。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ImplementsOnNew">
        <source>'Sub New' cannot implement interface members.</source>
        <target state="translated">'“Sub New”无法实现接口成员。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ArrayInitInStruct">
        <source>Arrays declared as structure members cannot be declared with an initial size.</source>
        <target state="translated">声明为结构成员的数组不能用初始大小声明。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_EventTypeNotDelegate">
        <source>Events declared with an 'As' clause must have a delegate type.</source>
        <target state="translated">用 "As" 子句声明的事件必须有委托类型。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ProtectedTypeOutsideClass">
        <source>Protected types can only be declared inside of a class.</source>
        <target state="translated">受保护的类型只能在类内部声明。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DefaultPropertyWithNoParams">
        <source>Properties with no required parameters cannot be declared 'Default'.</source>
        <target state="translated">不带必选参数的属性不能声明为“Default”。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InitializerInStruct">
        <source>Initializers on structure members are valid only for 'Shared' members and constants.</source>
        <target state="translated">结构成员上的初始值设定项仅对“Shared”成员和常量有效。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DuplicateImport1">
        <source>Namespace or type '{0}' has already been imported.</source>
        <target state="translated">已导入命名空间或类型呢“{0}”。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadModuleFlags1">
        <source>Modules cannot be declared '{0}'.</source>
        <target state="translated">模块不能声明为“{0}”。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ImplementsStmtWrongOrder">
        <source>'Implements' statements must follow any 'Inherits' statement and precede all declarations in a class.</source>
        <target state="translated">'“Implements”语句在类中必须位于任何“Inherits”语句之后，所有声明之前。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_SynthMemberClashesWithSynth7">
        <source>{0} '{1}' implicitly defines '{2}', which conflicts with a member implicitly declared for {3} '{4}' in {5} '{6}'.</source>
        <target state="translated">{0}“{1}”隐式定义的“{2}”与为 {5}“{6}”中的 {3}“{4}”隐式声明的成员冲突。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_SynthMemberClashesWithMember5">
        <source>{0} '{1}' implicitly defines '{2}', which conflicts with a member of the same name in {3} '{4}'.</source>
        <target state="translated">{0}“{1}”隐式定义的“{2}”与 {3}“{4}”中的同名成员冲突。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_MemberClashesWithSynth6">
        <source>{0} '{1}' conflicts with a member implicitly declared for {2} '{3}' in {4} '{5}'.</source>
        <target state="translated">{0}“{1}”与为 {4}“{5}”中的 {2}“{3}”隐式声明的成员冲突。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_TypeClashesWithVbCoreType4">
        <source>{0} '{1}' conflicts with a Visual Basic Runtime {2} '{3}'.</source>
        <target state="translated">{0}“{1}”与 Visual Basic 运行时 {2}“{3}”冲突。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_SecurityAttributeMissingAction">
        <source>First argument to a security attribute must be a valid SecurityAction.</source>
        <target state="translated">安全属性的第一个参数必须是有效的 SecurityAction。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_SecurityAttributeInvalidAction">
        <source>Security attribute '{0}' has an invalid SecurityAction value '{1}'.</source>
        <target state="translated">安全属性“{0}”具有无效的 SecurityAction 值“{1}”。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_SecurityAttributeInvalidActionAssembly">
        <source>SecurityAction value '{0}' is invalid for security attributes applied to an assembly.</source>
        <target state="translated">SecurityAction 值“{0}”对应用于程序集的安全属性无效。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_SecurityAttributeInvalidActionTypeOrMethod">
        <source>SecurityAction value '{0}' is invalid for security attributes applied to a type or a method.</source>
        <target state="translated">SecurityAction 值“{0}”对应用于类型或方法的安全属性无效。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PrincipalPermissionInvalidAction">
        <source>SecurityAction value '{0}' is invalid for PrincipalPermission attribute.</source>
        <target state="translated">SecurityAction 值“{0}”对 PrincipalPermission 属性无效。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PermissionSetAttributeInvalidFile">
        <source>Unable to resolve file path '{0}' specified for the named argument '{1}' for PermissionSet attribute.</source>
        <target state="translated">无法解析为 PermissionSet 属性的命名参数“{1}”指定的文件路径“{0}”。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PermissionSetAttributeFileReadError">
        <source>Error reading file '{0}' specified for the named argument '{1}' for PermissionSet attribute: '{2}'.</source>
        <target state="translated">读取为 PermissionSet 属性的命名参数“{1}”指定的文件“'{0}' ”时出错:“{2}”。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_SetHasOnlyOneParam">
        <source>'Set' method cannot have more than one parameter.</source>
        <target state="translated">'"Set" 方法不能有一个以上的参数。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_SetValueNotPropertyType">
        <source>'Set' parameter must have the same type as the containing property.</source>
        <target state="translated">'"Set" 参数必须与包含属性的类型相同。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_SetHasToBeByVal1">
        <source>'Set' parameter cannot be declared '{0}'.</source>
        <target state="translated">'“Set”参数不能声明为“{0}”。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_StructureCantUseProtected">
        <source>Method in a structure cannot be declared 'Protected', 'Protected Friend', or 'Private Protected'.</source>
        <target state="translated">结构中的方法不能声明为 "Protected"、"Protected Friend" 或 "Private Protected"。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadInterfaceDelegateSpecifier1">
        <source>Delegate in an interface cannot be declared '{0}'.</source>
        <target state="translated">接口中的委托不能声明为“{0}”。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadInterfaceEnumSpecifier1">
        <source>Enum in an interface cannot be declared '{0}'.</source>
        <target state="translated">接口中的枚举不能声明为“{0}”。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadInterfaceClassSpecifier1">
        <source>Class in an interface cannot be declared '{0}'.</source>
        <target state="translated">接口中的类不能声明为“{0}”。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadInterfaceStructSpecifier1">
        <source>Structure in an interface cannot be declared '{0}'.</source>
        <target state="translated">接口中的结构不能声明为“{0}”。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadInterfaceInterfaceSpecifier1">
        <source>Interface in an interface cannot be declared '{0}'.</source>
        <target state="translated">接口中的接口不能声明为“{0}”。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_UseOfObsoleteSymbolNoMessage1">
        <source>'{0}' is obsolete.</source>
        <target state="translated">'“{0}”已过时。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_MetaDataIsNotAssembly">
        <source>'{0}' is a module and cannot be referenced as an assembly.</source>
        <target state="translated">'“{0}”是一个模块，不能作为程序集引用。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_MetaDataIsNotModule">
        <source>'{0}' is an assembly and cannot be referenced as a module.</source>
        <target state="translated">'“{0}”是一个程序集，不能作为模块引用。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ReferenceComparison3">
        <source>Operator '{0}' is not defined for types '{1}' and '{2}'. Use 'Is' operator to compare two reference types.</source>
        <target state="translated">没有为类型“{1}”和“{2}”定义运算符“{0}”。请使用“Is”运算符比较两个引用的类型。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CatchVariableNotLocal1">
        <source>'{0}' is not a local variable or parameter, and so cannot be used as a 'Catch' variable.</source>
        <target state="translated">'“{0}”不是局部变量或参数，因此不能用作“Catch”变量。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ModuleMemberCantImplement">
        <source>Members in a Module cannot implement interface members.</source>
        <target state="translated">模块中的成员无法实现接口成员。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_EventDelegatesCantBeFunctions">
        <source>Events cannot be declared with a delegate type that has a return type.</source>
        <target state="translated">事件不能用具有返回类型的委托类型声明。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InvalidDate">
        <source>Date constant is not valid.</source>
        <target state="translated">日期常量无效。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CantOverride4">
        <source>'{0}' cannot override '{1}' because it is not declared 'Overridable'.</source>
        <target state="translated">'“{0}”无法重写“{1}”，因为后者未声明为“Overridable”。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CantSpecifyArraysOnBoth">
        <source>Array modifiers cannot be specified on both a variable and its type.</source>
        <target state="translated">不能在变量及其类型上同时指定数组修饰符。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NotOverridableRequiresOverrides">
        <source>'NotOverridable' cannot be specified for methods that do not override another method.</source>
        <target state="translated">'不能为不重写另一个方法的方法指定 "NotOverridable"。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PrivateTypeOutsideType">
        <source>Types declared 'Private' must be inside another type.</source>
        <target state="translated">声明为 "Private" 的类型必须在另一个类型内。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_TypeRefResolutionError3">
        <source>Import of type '{0}' from assembly or module '{1}' failed.</source>
        <target state="translated">从程序集或模块“{1}”导入类型“{0}”失败。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ValueTupleTypeRefResolutionError1">
        <source>Predefined type '{0}' is not defined or imported.</source>
        <target state="translated">预定义的类型“{0}”未定义或未导入。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ParamArrayWrongType">
        <source>ParamArray parameters must have an array type.</source>
        <target state="translated">ParamArray 参数必须有数组类型。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CoClassMissing2">
        <source>Implementing class '{0}' for interface '{1}' cannot be found.</source>
        <target state="translated">无法找到接口“{1}”的实现类“{0}”。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InvalidCoClass1">
        <source>Type '{0}' cannot be used as an implementing class.</source>
        <target state="translated">类型“{0}”不能用作实现类。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InvalidMeReference">
        <source>Reference to object under construction is not valid when calling another constructor.</source>
        <target state="translated">调用另一个构造函数时引用尚未完成的对象是无效的。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InvalidImplicitMeReference">
        <source>Implicit reference to object under construction is not valid when calling another constructor.</source>
        <target state="translated">调用另一个构造函数时隐式引用尚未完成的对象是无效的。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RuntimeMemberNotFound2">
        <source>Member '{0}' cannot be found in class '{1}'. This condition is usually the result of a mismatched 'Microsoft.VisualBasic.dll'.</source>
        <target state="translated">类“{1}”中找不到成员“{0}”。此情况通常是由于不匹配的“Microsoft.VisualBasic.dll”造成的。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadPropertyAccessorFlags">
        <source>Property accessors cannot be declared '{0}'.</source>
        <target state="translated">不能将属性访问器声明为“{0}”。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadPropertyAccessorFlagsRestrict">
        <source>Access modifier '{0}' is not valid. The access modifier of 'Get' and 'Set' should be more restrictive than the property access level.</source>
        <target state="translated">访问修饰符“{0}”无效。“Get”和“Set”的访问修饰符的限制性应该比属性访问级别更强。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_OnlyOneAccessorForGetSet">
        <source>Access modifier can only be applied to either 'Get' or 'Set', but not both.</source>
        <target state="translated">访问修饰符只能用于 "Get" 或者 "Set"，但不能同时用于这二者。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NoAccessibleSet">
        <source>'Set' accessor of property '{0}' is not accessible.</source>
        <target state="translated">'属性“{0}”的“Set”访问器不可访问。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NoAccessibleGet">
        <source>'Get' accessor of property '{0}' is not accessible.</source>
        <target state="translated">'属性“{0}”的“Get”访问器不可访问。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_WriteOnlyNoAccessorFlag">
        <source>'WriteOnly' properties cannot have an access modifier on 'Set'.</source>
        <target state="translated">'"WriteOnly" 属性在 "Set" 上不能有访问修饰符。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ReadOnlyNoAccessorFlag">
        <source>'ReadOnly' properties cannot have an access modifier on 'Get'.</source>
        <target state="translated">'"ReadOnly" 属性在 "Get" 上不能有访问修饰符。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadPropertyAccessorFlags1">
        <source>Property accessors cannot be declared '{0}' in a 'NotOverridable' property.</source>
        <target state="translated">属性访问器不能在“NotOverridable”属性中声明为“{0}”。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadPropertyAccessorFlags2">
        <source>Property accessors cannot be declared '{0}' in a 'Default' property.</source>
        <target state="translated">属性访问器不能在“Default”属性中声明为“{0}”。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadPropertyAccessorFlags3">
        <source>Property cannot be declared '{0}' because it contains a 'Private' accessor.</source>
        <target state="translated">属性包含“Private”访问器，因此不能声明为“{0}”。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InAccessibleCoClass3">
        <source>Implementing class '{0}' for interface '{1}' is not accessible in this context because it is '{2}'.</source>
        <target state="translated">接口“{1}”的实现类“{0}”是“{2}”，因此它在此上下文中不可访问。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_MissingValuesForArraysInApplAttrs">
        <source>Arrays used as attribute arguments are required to explicitly specify values for all elements.</source>
        <target state="translated">必须有用作特性参数的数组才能显式指定所有元素的值。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExitEventMemberNotInvalid">
        <source>'Exit AddHandler', 'Exit RemoveHandler' and 'Exit RaiseEvent' are not valid. Use 'Return' to exit from event members.</source>
        <target state="translated">'"Exit AddHandler"、"Exit RemoveHandler" 和 "Exit RaiseEvent" 无效。请使用 "Return" 从事件成员中退出。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InvInsideEndsEvent">
        <source>Statement cannot appear within an event body. End of event assumed.</source>
        <target state="translated">语句不能出现在事件体内。假定为事件末尾。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_MissingEndEvent">
        <source>'Custom Event' must end with a matching 'End Event'.</source>
        <target state="translated">'Custom Event 必须以匹配的 "End Event" 结束。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_MissingEndAddHandler">
        <source>'AddHandler' declaration must end with a matching 'End AddHandler'.</source>
        <target state="translated">'"AddHandler" 声明必须以匹配的 "End AddHandler" 结束。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_MissingEndRemoveHandler">
        <source>'RemoveHandler' declaration must end with a matching 'End RemoveHandler'.</source>
        <target state="translated">'"RemoveHandler" 声明必须以匹配的 "End RemoveHandler" 结束。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_MissingEndRaiseEvent">
        <source>'RaiseEvent' declaration must end with a matching 'End RaiseEvent'.</source>
        <target state="translated">'"RaiseEvent" 声明必须以匹配的 "End RaiseEvent" 结束。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CustomEventInvInInterface">
        <source>'Custom' modifier is not valid on events declared in interfaces.</source>
        <target state="translated">'“Custom”修饰符在接口中声明的事件上无效。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CustomEventRequiresAs">
        <source>'Custom' modifier is not valid on events declared without explicit delegate types.</source>
        <target state="translated">'“Custom”修饰符在未用显式委托类型声明的事件上无效。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InvalidEndEvent">
        <source>'End Event' must be preceded by a matching 'Custom Event'.</source>
        <target state="translated">'“End Event”前面必须是匹配的“Custom Event”。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InvalidEndAddHandler">
        <source>'End AddHandler' must be preceded by a matching 'AddHandler' declaration.</source>
        <target state="translated">'“End AddHandler”前面必须是匹配的“AddHandler”声明。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InvalidEndRemoveHandler">
        <source>'End RemoveHandler' must be preceded by a matching 'RemoveHandler' declaration.</source>
        <target state="translated">'“End RemoveHandler”前面必须是匹配的“RemoveHandler”声明。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InvalidEndRaiseEvent">
        <source>'End RaiseEvent' must be preceded by a matching 'RaiseEvent' declaration.</source>
        <target state="translated">'“End RaiseEvent”前面必须是匹配的“RaiseEvent”声明。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DuplicateAddHandlerDef">
        <source>'AddHandler' is already declared.</source>
        <target state="translated">'已经声明 "AddHandler"。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DuplicateRemoveHandlerDef">
        <source>'RemoveHandler' is already declared.</source>
        <target state="translated">'已经声明 "RemoveHandler"。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DuplicateRaiseEventDef">
        <source>'RaiseEvent' is already declared.</source>
        <target state="translated">'已经声明 "RaiseEvent"。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_MissingAddHandlerDef1">
        <source>'AddHandler' definition missing for event '{0}'.</source>
        <target state="translated">'缺少事件“{0}”的“AddHandler”定义。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_MissingRemoveHandlerDef1">
        <source>'RemoveHandler' definition missing for event '{0}'.</source>
        <target state="translated">'缺少事件“{0}”的“RemoveHandler”定义。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_MissingRaiseEventDef1">
        <source>'RaiseEvent' definition missing for event '{0}'.</source>
        <target state="translated">'缺少事件“{0}”的“RaiseEvent”定义。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_EventAddRemoveHasOnlyOneParam">
        <source>'AddHandler' and 'RemoveHandler' methods must have exactly one parameter.</source>
        <target state="translated">'“AddHandler”和“RemoveHandler”方法必须正好有一个参数。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_EventAddRemoveByrefParamIllegal">
        <source>'AddHandler' and 'RemoveHandler' method parameters cannot be declared 'ByRef'.</source>
        <target state="translated">'“AddHandler”和“RemoveHandler”方法参数不能声明为“ByRef”。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_SpecifiersInvOnEventMethod">
        <source>Specifiers are not valid on 'AddHandler', 'RemoveHandler' and 'RaiseEvent' methods.</source>
        <target state="translated">说明符在 "AddHandler"、"RemoveHandler" 和 "RaiseEvent" 方法上无效。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AddRemoveParamNotEventType">
        <source>'AddHandler' and 'RemoveHandler' method parameters must have the same delegate type as the containing event.</source>
        <target state="translated">'“AddHandler”和“RemoveHandler”方法参数必须与包含事件具有相同的委托类型。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RaiseEventShapeMismatch1">
        <source>'RaiseEvent' method must have the same signature as the containing event's delegate type '{0}'.</source>
        <target state="translated">'“RaiseEvent”方法必须具有与包含事件的委托类型“{0}”相同的签名。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_EventMethodOptionalParamIllegal1">
        <source>'AddHandler', 'RemoveHandler' and 'RaiseEvent' method parameters cannot be declared '{0}'.</source>
        <target state="translated">'“AddHandler”、“RemoveHandler”和“RaiseEvent”方法参数不能声明为“{0}”。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CantReferToMyGroupInsideGroupType1">
        <source>'{0}' cannot refer to itself through its default instance; use 'Me' instead.</source>
        <target state="translated">'“{0}”不能通过其默认实例指代自身；请改用“Me”。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InvalidUseOfCustomModifier">
        <source>'Custom' modifier can only be used immediately before an 'Event' declaration.</source>
        <target state="translated">'"Custom" 修饰符只能在紧靠 "Event" 声明之前使用。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InvalidOptionStrictCustom">
        <source>Option Strict Custom can only be used as an option to the command-line compiler (vbc.exe).</source>
        <target state="translated">Option Strict Custom 只能用作命令行编译器(vbc.exe)的选项。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ObsoleteInvalidOnEventMember">
        <source>'{0}' cannot be applied to the 'AddHandler', 'RemoveHandler', or 'RaiseEvent' definitions. If required, apply the attribute directly to the event.</source>
        <target state="translated">'“{0}”不能应用于“'AddHandler”、“RemoveHandler”或“'RaiseEvent”定义。如有必要，请将该属性直接应用于事件。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DelegateBindingIncompatible2">
        <source>Method '{0}' does not have a signature compatible with delegate '{1}'.</source>
        <target state="translated">方法“{0}”没有与委托“{1}”兼容的签名。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExpectedXmlName">
        <source>XML name expected.</source>
        <target state="translated">应为 XML 名称。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_UndefinedXmlPrefix">
        <source>XML namespace prefix '{0}' is not defined.</source>
        <target state="translated">未定义 XML 命名空间前缀“{0}”。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DuplicateXmlAttribute">
        <source>Duplicate XML attribute '{0}'.</source>
        <target state="translated">重复的 XML 属性“{0}”。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_MismatchedXmlEndTag">
        <source>End tag &lt;/{0}{1}{2}&gt; expected.</source>
        <target state="translated">应为结束标记 &lt;/{0}{1}{2}&gt;。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_MissingXmlEndTag">
        <source>Element is missing an end tag.</source>
        <target state="translated">元素缺少结束标记。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ReservedXmlPrefix">
        <source>XML namespace prefix '{0}' is reserved for use by XML and the namespace URI cannot be changed.</source>
        <target state="translated">XML 命名空间前缀“{0}”已保留供 XML 使用，并且命名空间 URI 不能更改。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_MissingVersionInXmlDecl">
        <source>Required attribute 'version' missing from XML declaration.</source>
        <target state="translated">XML 声明中缺少必需的特性 "version"。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_IllegalAttributeInXmlDecl">
        <source>XML declaration does not allow attribute '{0}{1}{2}'.</source>
        <target state="translated">XML 声明不允许属性“{0}{1}{2}”。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_QuotedEmbeddedExpression">
        <source>Embedded expression cannot appear inside a quoted attribute value.  Try removing quotes.</source>
        <target state="translated">带引号的特性值内不能出现嵌入式表达式。请尝试移除引号。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_VersionMustBeFirstInXmlDecl">
        <source>XML attribute 'version' must be the first attribute in XML declaration.</source>
        <target state="translated">XML 特性 "version" 必须是 XML 声明中的第一个特性。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AttributeOrder">
        <source>XML attribute '{0}' must appear before XML attribute '{1}'.</source>
        <target state="translated">XML 特性“{0}”必须出现在 XML 特性“{1}”之前。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExpectedXmlEndEmbedded">
        <source>Expected closing '%&gt;' for embedded expression.</source>
        <target state="translated">应为嵌入表达式的结束标记“%&gt;”。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExpectedXmlEndPI">
        <source>Expected closing '?&gt;' for XML processor instruction.</source>
        <target state="translated">应为 XML 处理器指令的结束标记“?&gt;”。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExpectedXmlEndComment">
        <source>Expected closing '--&gt;' for XML comment.</source>
        <target state="translated">应为 XML 注释的结束标记“--&gt;”。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExpectedXmlEndCData">
        <source>Expected closing ']]&gt;' for XML CDATA section.</source>
        <target state="translated">应为 XML CDATA 部分的结束标记“]]&gt;”。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExpectedSQuote">
        <source>Expected matching closing single quote for XML attribute value.</source>
        <target state="translated">XML 特性值应有匹配的右单引号。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExpectedQuote">
        <source>Expected matching closing double quote for XML attribute value.</source>
        <target state="translated">XML 特性值应有匹配的右双引号。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExpectedLT">
        <source>Expected beginning '&lt;' for an XML tag.</source>
        <target state="translated">XML 标记前应有 "&lt;"。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_StartAttributeValue">
        <source>Expected quoted XML attribute value or embedded expression.</source>
        <target state="translated">应为带引号的 XML 特性值或嵌入式表达式。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExpectedDiv">
        <source>Expected '/' for XML end tag.</source>
        <target state="translated">应使用“/”作为 XML 结束标记。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NoXmlAxesLateBinding">
        <source>XML axis properties do not support late binding.</source>
        <target state="translated">XML 轴属性不支持后期绑定。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_IllegalXmlStartNameChar">
        <source>Character '{0}' ({1}) is not allowed at the beginning of an XML name.</source>
        <target state="translated">XML 名称的开头不允许出现字符“{0}”({1})。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_IllegalXmlNameChar">
        <source>Character '{0}' ({1}) is not allowed in an XML name.</source>
        <target state="translated">XML 名称中允许字符“{0}”({1})。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_IllegalXmlCommentChar">
        <source>Character sequence '--' is not allowed in an XML comment.</source>
        <target state="translated">XML 注释中不允许出现字符序列“--”。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_EmbeddedExpression">
        <source>An embedded expression cannot be used here.</source>
        <target state="translated">不能在此处使用嵌入式表达式。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExpectedXmlWhiteSpace">
        <source>Missing required white space.</source>
        <target state="translated">缺少必需的空白。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_IllegalProcessingInstructionName">
        <source>XML processing instruction name '{0}' is not valid.</source>
        <target state="translated">XML 处理指令名称“{0}”无效。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DTDNotSupported">
        <source>XML DTDs are not supported.</source>
        <target state="translated">不支持 XML DTD。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_IllegalXmlWhiteSpace">
        <source>White space cannot appear here.</source>
        <target state="translated">此处不能使用空白。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExpectedSColon">
        <source>Expected closing ';' for XML entity.</source>
        <target state="translated">应为 XML 实体的结束标记“;”。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExpectedXmlBeginEmbedded">
        <source>Expected '%=' at start of an embedded expression.</source>
        <target state="translated">嵌入表达式的开头应为“%=”。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_XmlEntityReference">
        <source>XML entity references are not supported.</source>
        <target state="translated">不支持 XML 实体引用。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InvalidAttributeValue1">
        <source>Attribute value is not valid; expecting '{0}'.</source>
        <target state="translated">属性值无效；应为“{0}”。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InvalidAttributeValue2">
        <source>Attribute value is not valid; expecting '{0}' or '{1}'.</source>
        <target state="translated">属性值无效；应为“{0}”或“{1}”。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ReservedXmlNamespace">
        <source>Prefix '{0}' cannot be bound to namespace name reserved for '{1}'.</source>
        <target state="translated">不能将前缀“{0}”绑定到为“{1}”保留的命名空间名称。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_IllegalDefaultNamespace">
        <source>Namespace declaration with prefix cannot have an empty value inside an XML literal.</source>
        <target state="translated">带前缀的命名空间声明在 XML 文本中不能有空值。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_QualifiedNameNotAllowed">
        <source>':' is not allowed. XML qualified names cannot be used in this context.</source>
        <target state="translated">'不允许使用 ":"。不能在此上下文中使用 XML 限定名称。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExpectedXmlns">
        <source>Namespace declaration must start with 'xmlns'.</source>
        <target state="translated">命名空间声明必须以“xmlns”开头。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_IllegalXmlnsPrefix">
        <source>Element names cannot use the 'xmlns' prefix.</source>
        <target state="translated">元素名不能使用“xmlns”前缀。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_XmlFeaturesNotAvailable">
        <source>XML literals and XML axis properties are not available. Add references to System.Xml, System.Xml.Linq, and System.Core or other assemblies declaring System.Linq.Enumerable, System.Xml.Linq.XElement, System.Xml.Linq.XName, System.Xml.Linq.XAttribute and System.Xml.Linq.XNamespace types.</source>
        <target state="translated">XML 文本和 XML 轴属性不可用。添加对 System.Xml、System.Xml.Linq 和 System.Core 的引用，或其他声明 System.Linq.Enumerable、System.Xml.Linq.XElement、System.Xml.Linq.XName、System.Xml.Linq.XAttribute 和 System.Xml.Linq.XNamespace 类型的程序集。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_UnableToReadUacManifest2">
        <source>Unable to open Win32 manifest file '{0}' : {1}</source>
        <target state="translated">无法打开 Win32 清单文件“{0}”: {1}</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UseValueForXmlExpression3">
        <source>Cannot convert '{0}' to '{1}'. You can use the 'Value' property to get the string value of the first element of '{2}'.</source>
        <target state="translated">无法将“{0}”转换为“{1}”。可使用“Value”属性来获取“{2}”的第一个元素的字符串值。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UseValueForXmlExpression3_Title">
        <source>Cannot convert IEnumerable(Of XElement) to String</source>
        <target state="translated">无法将 IEnumerable(Of XElement) 转换为字符串</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_TypeMismatchForXml3">
        <source>Value of type '{0}' cannot be converted to '{1}'. You can use the 'Value' property to get the string value of the first element of '{2}'.</source>
        <target state="translated">类型“{0}”的值无法转换为“{1}”。可使用“Value”属性来获取“{2}”的第一个元素的字符串值。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BinaryOperandsForXml4">
        <source>Operator '{0}' is not defined for types '{1}' and '{2}'. You can use the 'Value' property to get the string value of the first element of '{3}'.</source>
        <target state="translated">没有为类型“{1}”和“{2}”定义运算符“{0}”。可使用“Value”属性来获取“{3}”的第一个元素的字符串值。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_FullWidthAsXmlDelimiter">
        <source>Full width characters are not valid as XML delimiters.</source>
        <target state="translated">全角字符不能用作 XML 分隔符。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InvalidSubsystemVersion">
        <source>The value '{0}' is not a valid subsystem version. The version must be 6.02 or greater for ARM or AppContainerExe, and 4.00 or greater otherwise.</source>
        <target state="translated">值“{0}”不是有效的子系统版本。对于 ARM 或 AppContainerExe，版本必须为 6.02 或更高版本，对于其他内容，版本必须为 4.00 或更高版本。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InvalidFileAlignment">
        <source>Invalid file section alignment '{0}'</source>
        <target state="translated">无效的文件节对齐方式“{0}”</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InvalidOutputName">
        <source>Invalid output name: {0}</source>
        <target state="translated">无效输出名: {0}</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InvalidDebugInformationFormat">
        <source>Invalid debug information format: {0}</source>
        <target state="translated">无效的调试信息格式: {0}</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_LibAnycpu32bitPreferredConflict">
        <source>/platform:anycpu32bitpreferred can only be used with /t:exe, /t:winexe and /t:appcontainerexe.</source>
        <target state="translated">/platform:anycpu32bitpreferred 只能与 /t:exe、/t:winexe 和 /t:appcontainerexe 一起使用。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RestrictedAccess">
        <source>Expression has the type '{0}' which is a restricted type and cannot be used to access members inherited from 'Object' or 'ValueType'.</source>
        <target state="translated">表达式的类型为“{0}”，这是受限类型，不能用于访问从“Object”或“ValueType”继承的成员。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RestrictedConversion1">
        <source>Expression of type '{0}' cannot be converted to 'Object' or 'ValueType'.</source>
        <target state="translated">类型“{0}”的表达式无法转换为“Object”或“ValueType”。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NoTypecharInLabel">
        <source>Type characters are not allowed in label identifiers.</source>
        <target state="translated">标签标识符中不允许使用类型字符。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RestrictedType1">
        <source>'{0}' cannot be made nullable, and cannot be used as the data type of an array element, field, anonymous type member, type argument, 'ByRef' parameter, or return statement.</source>
        <target state="translated">“{0}”不能设置为可以为 null，而且不能用作数组元素、字段、匿名类型成员、类型参数、"ByRef" 参数或 return 语句的数据类型。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NoTypecharInAlias">
        <source>Type characters are not allowed on Imports aliases.</source>
        <target state="translated">在 Imports 别名上不允许使用类型字符。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NoAccessibleConstructorOnBase">
        <source>Class '{0}' has no accessible 'Sub New' and cannot be inherited.</source>
        <target state="translated">类“{0}”没有可访问的“Sub New”，不能被继承。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadStaticLocalInStruct">
        <source>Local variables within methods of structures cannot be declared 'Static'.</source>
        <target state="translated">结构方法内部的局部变量不能声明为“Static”。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DuplicateLocalStatic1">
        <source>Static local variable '{0}' is already declared.</source>
        <target state="translated">已声明静态局部变量“{0}”。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ImportAliasConflictsWithType2">
        <source>Imports alias '{0}' conflicts with '{1}' declared in the root namespace.</source>
        <target state="translated">Imports 别名“{0}”与根命名空间中声明的“{1}”冲突。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CantShadowAMustOverride1">
        <source>'{0}' cannot shadow a method declared 'MustOverride'.</source>
        <target state="translated">'“{0}”不能隐藏声明为“MustOverride”的方法。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_MultipleEventImplMismatch3">
        <source>Event '{0}' cannot implement event '{2}.{1}' because its delegate type does not match the delegate type of another event implemented by '{0}'.</source>
        <target state="translated">事件“{0}”不能实现事件“{2}.{1}”，因为其委托类型与“{0}”实现的另一个事件的委托类型不匹配。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadSpecifierCombo2">
        <source>'{0}' and '{1}' cannot be combined.</source>
        <target state="translated">'“{0}”不能与“{1}”组合。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_MustBeOverloads2">
        <source>{0} '{1}' must be declared 'Overloads' because another '{1}' is declared 'Overloads' or 'Overrides'.</source>
        <target state="translated">{0}“{1}”必须声明为“Overloads”，因为另一个“{1}”声明为“Overloads”或“Overrides”。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_MustOverridesInClass1">
        <source>'{0}' must be declared 'MustInherit' because it contains methods declared 'MustOverride'.</source>
        <target state="translated">'“{0}”包含声明为“MustOverride”的方法，因此它必须声明为“MustInherit”。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_HandlesSyntaxInClass">
        <source>'Handles' in classes must specify a 'WithEvents' variable, 'MyBase', 'MyClass' or 'Me' qualified with a single identifier.</source>
        <target state="translated">'类中的“Handles”必须指定用单个标识符限定的“WithEvents”变量、“MyBase”、“MyClass”或“Me”。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_SynthMemberShadowsMustOverride5">
        <source>'{0}', implicitly declared for {1} '{2}', cannot shadow a 'MustOverride' method in the base {3} '{4}'.</source>
        <target state="translated">'为 {1}“{2}”隐式声明的“{0}”不能隐藏基 {3}“{4}”中的“MustOverride”方法。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CannotOverrideInAccessibleMember">
        <source>'{0}' cannot override '{1}' because it is not accessible in this context.</source>
        <target state="translated">'“{0}”无法重写“{1}”，因为它在此上下文中是无法访问的。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_HandlesSyntaxInModule">
        <source>'Handles' in modules must specify a 'WithEvents' variable qualified with a single identifier.</source>
        <target state="translated">'模块中的“Handles”必须指定用单个标识符限定的“WithEvents”变量。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_IsNotOpRequiresReferenceTypes1">
        <source>'IsNot' requires operands that have reference types, but this operand has the value type '{0}'.</source>
        <target state="translated">'“IsNot”要求具有引用类型的操作数,但此操作数的值类型为“{0}”。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ClashWithReservedEnumMember1">
        <source>'{0}' conflicts with the reserved member by this name that is implicitly declared in all enums.</source>
        <target state="translated">'“{0}”与在所有枚举中隐式声明的同名保留成员冲突。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_MultiplyDefinedEnumMember2">
        <source>'{0}' is already declared in this {1}.</source>
        <target state="translated">'此 {1} 中已声明了“{0}”。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadUseOfVoid">
        <source>'System.Void' can only be used in a GetType expression.</source>
        <target state="translated">'“System.Void”只能在 GetType 表达式中使用。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_EventImplMismatch5">
        <source>Event '{0}' cannot implement event '{1}' on interface '{2}' because their delegate types '{3}' and '{4}' do not match.</source>
        <target state="translated">事件“{0}”无法实现接口“{2}”上的事件“{1}”，因为其委托类型“{3}”和“{4}”不匹配。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ForwardedTypeUnavailable3">
        <source>Type '{0}' in assembly '{1}' has been forwarded to assembly '{2}'. Either a reference to '{2}' is missing from your project or the type '{0}' is missing from assembly '{2}'.</source>
        <target state="translated">程序集“{1}”中的类型“{0}”已转发到程序集“{2}”。您的项目中缺少对“{2}”的引用或者程序集中“{2}”缺少类型“{0}”。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_TypeFwdCycle2">
        <source>'{0}' in assembly '{1}' has been forwarded to itself and so is an unsupported type.</source>
        <target state="translated">'程序集“{1}”中的“{0}”已被转发给自身，因此它是一种不受支持的类型。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadTypeInCCExpression">
        <source>Non-intrinsic type names are not allowed in conditional compilation expressions.</source>
        <target state="translated">在条件编译表达式中不允许有非内部的类型名。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadCCExpression">
        <source>Syntax error in conditional compilation expression.</source>
        <target state="translated">条件编译表达式中有语法错误。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_VoidArrayDisallowed">
        <source>Arrays of type 'System.Void' are not allowed in this expression.</source>
        <target state="translated">此表达式中不允许使用 "System.Void" 类型的数组。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_MetadataMembersAmbiguous3">
        <source>'{0}' is ambiguous because multiple kinds of members with this name exist in {1} '{2}'.</source>
        <target state="translated">'“{0}”不明确，因为 {1}“{2}”中存在多种具有此名称的成员</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_TypeOfExprAlwaysFalse2">
        <source>Expression of type '{0}' can never be of type '{1}'.</source>
        <target state="translated">类型“{0}”的表达式永远不能为类型“{1}”。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_OnlyPrivatePartialMethods1">
        <source>Partial methods must be declared 'Private' instead of '{0}'.</source>
        <target state="translated">必须将分部方法声明为“Private”，而不是“{0}”。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PartialMethodsMustBePrivate">
        <source>Partial methods must be declared 'Private'.</source>
        <target state="translated">必须将分部方法声明为 "Private"。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_OnlyOnePartialMethodAllowed2">
        <source>Method '{0}' cannot be declared 'Partial' because only one method '{1}' can be marked 'Partial'.</source>
        <target state="translated">方法“{0}”不能声明为“Partial”，因为只有一个方法“{1}”可以标记为“Partial”。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_OnlyOneImplementingMethodAllowed3">
        <source>Method '{0}' cannot implement partial method '{1}' because '{2}' already implements it. Only one method can implement a partial method.</source>
        <target state="translated">方法“{0}”无法实现分部方法“{1}”，因为它已经由“{2}”实现。分部方法只能由一个方法实现。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PartialMethodMustBeEmpty">
        <source>Partial methods must have empty method bodies.</source>
        <target state="translated">分部方法必须具有空方法体。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PartialMethodsMustBeSub1">
        <source>'{0}' cannot be declared 'Partial' because partial methods must be Subs.</source>
        <target state="translated">'“{0}”不能声明为“Partial”，因为分部方法必须为 Subs。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PartialMethodGenericConstraints2">
        <source>Method '{0}' does not have the same generic constraints as the partial method '{1}'.</source>
        <target state="translated">方法“{0}”没有与分部方法“{1}”相同的泛型约束。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PartialDeclarationImplements1">
        <source>Partial method '{0}' cannot use the 'Implements' keyword.</source>
        <target state="translated">分部方法“{0}”不能使用“Implements”关键字。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NoPartialMethodInAddressOf1">
        <source>'AddressOf' cannot be applied to '{0}' because '{0}' is a partial method without an implementation.</source>
        <target state="translated">'“AddressOf”不能应用于“{0}”，因为“{0}”是不包含实现的分部方法。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ImplementationMustBePrivate2">
        <source>Method '{0}' must be declared 'Private' in order to implement partial method '{1}'.</source>
        <target state="translated">方法“{0}”必须声明为“Private”，以便实现分部方法“{1}”。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PartialMethodParamNamesMustMatch3">
        <source>Parameter name '{0}' does not match the name of the corresponding parameter, '{1}', defined on the partial method declaration '{2}'.</source>
        <target state="translated">参数名“{0}”与在分部方法声明“{2}”上定义的相应参数的名称“{1}”不匹配。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PartialMethodTypeParamNameMismatch3">
        <source>Name of type parameter '{0}' does not match '{1}', the corresponding type parameter defined on the partial method declaration '{2}'.</source>
        <target state="translated">类型参数“{0}”的名称与在分部方法声明“{2}”上定义的相应类型参数“{1}”不匹配。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadAttributeSharedProperty1">
        <source>'Shared' attribute property '{0}' cannot be the target of an assignment.</source>
        <target state="translated">'“Shared”特性属性“{0}”不能作为赋值的目标。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadAttributeReadOnlyProperty1">
        <source>'ReadOnly' attribute property '{0}' cannot be the target of an assignment.</source>
        <target state="translated">'“ReadOnly”特性属性“{0}”不能作为赋值的目标。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DuplicateResourceName1">
        <source>Resource name '{0}' cannot be used more than once.</source>
        <target state="translated">资源名称“{0}”不能多次使用。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DuplicateResourceFileName1">
        <source>Each linked resource and module must have a unique filename. Filename '{0}' is specified more than once in this assembly.</source>
        <target state="translated">每个链接的资源和模块都必须有唯一的文件名。此程序集中多次指定了文件名“{0}”。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AttributeMustBeClassNotStruct1">
        <source>'{0}' cannot be used as an attribute because it is not a class.</source>
        <target state="translated">'“{0}”不是类，因此不能用作属性。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AttributeMustInheritSysAttr">
        <source>'{0}' cannot be used as an attribute because it does not inherit from 'System.Attribute'.</source>
        <target state="translated">'“{0}”不从“System.Attribute”继承，因此不能用作属性。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AttributeCannotBeAbstract">
        <source>'{0}' cannot be used as an attribute because it is declared 'MustInherit'.</source>
        <target state="translated">'“{0}”已声明为“MustInherit”，因此不能用作属性。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_UnableToOpenResourceFile1">
        <source>Unable to open resource file '{0}': {1}</source>
        <target state="translated">无法打开资源文件“{0}”: {1}</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadAttributeNonPublicProperty1">
        <source>Attribute member '{0}' cannot be the target of an assignment because it is not declared 'Public'.</source>
        <target state="translated">特性成员“{0}”未声明为“Public”，因此不能作为赋值的目标。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_STAThreadAndMTAThread0">
        <source>'System.STAThreadAttribute' and 'System.MTAThreadAttribute' cannot both be applied to the same method.</source>
        <target state="translated">'"System.STAThreadAttribute" 和 "System.MTAThreadAttribute" 不能同时应用于同一方法。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_IndirectUnreferencedAssembly4">
        <source>Project '{0}' makes an indirect reference to assembly '{1}', which contains '{2}'. Add a file reference to '{3}' to your project.</source>
        <target state="translated">项目“{0}”间接引用包含“{2}”的程序集“{1}”。请在您的项目中添加对“{3}”的文件引用。 </target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadAttributeNonPublicType1">
        <source>Type '{0}' cannot be used in an attribute because it is not declared 'Public'.</source>
        <target state="translated">类型“{0}”未声明为“Public”，因此不能用在特性中。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadAttributeNonPublicContType2">
        <source>Type '{0}' cannot be used in an attribute because its container '{1}' is not declared 'Public'.</source>
        <target state="translated">类型“{0}”的容器“{1}”未声明为“Public”，因此不能用在特性中。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DllImportOnNonEmptySubOrFunction">
        <source>'System.Runtime.InteropServices.DllImportAttribute' cannot be applied to a Sub, Function, or Operator with a non-empty body.</source>
        <target state="translated">'"System.Runtime.InteropServices.DllImportAttribute" 不能应用于带有非空体的 Sub、Function 或 Operator。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DllImportNotLegalOnDeclare">
        <source>'System.Runtime.InteropServices.DllImportAttribute' cannot be applied to a Declare.</source>
        <target state="translated">'"System.Runtime.InteropServices.DllImportAttribute" 不能应用于 Declare。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DllImportNotLegalOnGetOrSet">
        <source>'System.Runtime.InteropServices.DllImportAttribute' cannot be applied to a Get or Set.</source>
        <target state="translated">'"System.Runtime.InteropServices.DllImportAttribute" 不能应用于 Get 或 Set。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DllImportOnGenericSubOrFunction">
        <source>'System.Runtime.InteropServices.DllImportAttribute' cannot be applied to a method that is generic or contained in a generic type.</source>
        <target state="translated">'"System.Runtime.InteropServices.DllImportAttribute" 不能应用于属于泛型类型或者包含在泛型类型中的方法。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ComClassOnGeneric">
        <source>'Microsoft.VisualBasic.ComClassAttribute' cannot be applied to a class that is generic or contained inside a generic type.</source>
        <target state="translated">'“Microsoft.VisualBasic.ComClassAttribute”不能应用于属于泛型类型或者包含在泛型类型中的类。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DllImportOnInstanceMethod">
        <source>'System.Runtime.InteropServices.DllImportAttribute' cannot be applied to instance method.</source>
        <target state="translated">'"System.Runtime.InteropServices.DllImportAttribute" 不能应用于实例方法。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DllImportOnInterfaceMethod">
        <source>'System.Runtime.InteropServices.DllImportAttribute' cannot be applied to interface methods.</source>
        <target state="translated">'"System.Runtime.InteropServices.DllImportAttribute" 不能应用于接口方法。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DllImportNotLegalOnEventMethod">
        <source>'System.Runtime.InteropServices.DllImportAttribute' cannot be applied to 'AddHandler', 'RemoveHandler' or 'RaiseEvent' method.</source>
        <target state="translated">'"System.Runtime.InteropServices.DllImportAttribute" 不能应用于 "AddHandler"、"RemoveHandler" 或 "RaiseEvent" 方法。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_FriendAssemblyBadArguments">
        <source>Friend assembly reference '{0}' is invalid. InternalsVisibleTo declarations cannot have a version, culture, public key token, or processor architecture specified.</source>
        <target state="translated">友元程序集引用“{0}”无效。不能在 InternalsVisibleTo 声明中指定版本、区域性、公钥标记或处理器架构。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_FriendAssemblyStrongNameRequired">
        <source>Friend assembly reference '{0}' is invalid. Strong-name signed assemblies must specify a public key in their InternalsVisibleTo declarations.</source>
        <target state="translated">友元程序集引用“{0}”无效。强名称签名的程序集必须在其 InternalsVisibleTo 声明中指定一个公钥。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_FriendAssemblyNameInvalid">
        <source>Friend declaration '{0}' is invalid and cannot be resolved.</source>
        <target state="translated">友元声明“{0}”无效，且无法解析。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_FriendAssemblyBadAccessOverride2">
        <source>Member '{0}' cannot override member '{1}' defined in another assembly/project because the access modifier 'Protected Friend' expands accessibility. Use 'Protected' instead.</source>
        <target state="translated">成员“{0}”无法重写另一个程序集/项目中定义的成员“{1}”，因为访问修饰符“Protected Friend”扩展了可访问性。请改用“Protected”。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_UseOfLocalBeforeDeclaration1">
        <source>Local variable '{0}' cannot be referred to before it is declared.</source>
        <target state="translated">局部变量“{0}”在声明之前不能被引用。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_UseOfKeywordFromModule1">
        <source>'{0}' is not valid within a Module.</source>
        <target state="translated">'“{0}”在模块中无效。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BogusWithinLineIf">
        <source>Statement cannot end a block outside of a line 'If' statement.</source>
        <target state="translated">语句不能在“If”语句行之外结束块。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CharToIntegralTypeMismatch1">
        <source>'Char' values cannot be converted to '{0}'. Use 'Microsoft.VisualBasic.AscW' to interpret a character as a Unicode value or 'Microsoft.VisualBasic.Val' to interpret it as a digit.</source>
        <target state="translated">'“Char”值不能转换为“{0}”。请使用“Microsoft.VisualBasic.AscW”将字符解释为 Unicode 值，或者使用“Microsoft.VisualBasic.Val”将字符解释为数字。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_IntegralToCharTypeMismatch1">
        <source>'{0}' values cannot be converted to 'Char'. Use 'Microsoft.VisualBasic.ChrW' to interpret a numeric value as a Unicode character or first convert it to 'String' to produce a digit.</source>
        <target state="translated">'“{0}”值不能转换为“Char”。使用“Microsoft.VisualBasic.ChrW”将数值解释为 Unicode 字符或先将其转换为“String”以产生数字。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NoDirectDelegateConstruction1">
        <source>Delegate '{0}' requires an 'AddressOf' expression or lambda expression as the only argument to its constructor.</source>
        <target state="translated">委托“{0}”需要使用一个“AddressOf”表达式或 lambda 表达式作为其构造函数的唯一参数。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_MethodMustBeFirstStatementOnLine">
        <source>Method declaration statements must be the first statement on a logical line.</source>
        <target state="translated">方法声明语句必须是逻辑行上的第一条语句。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AttrAssignmentNotFieldOrProp1">
        <source>'{0}' cannot be named as a parameter in an attribute specifier because it is not a field or property.</source>
        <target state="translated">'“{0}”不是字段或属性(Property)，因此不能命名为属性(Attribute)说明符中的参数。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_StrictDisallowsObjectComparison1">
        <source>Option Strict On disallows operands of type Object for operator '{0}'. Use the 'Is' operator to test for object identity.</source>
        <target state="translated">Option Strict On 不允许将类型 Object 的操作数用于运算符“{0}”。请使用“Is”运算符测试对象标识。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NoConstituentArraySizes">
        <source>Bounds can be specified only for the top-level array when initializing an array of arrays.</source>
        <target state="translated">初始化数组的数组时，只能指定顶级数组的界限。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_FileAttributeNotAssemblyOrModule">
        <source>'Assembly' or 'Module' expected.</source>
        <target state="translated">'应为“Assembly”或“Module”。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_FunctionResultCannotBeIndexed1">
        <source>'{0}' has no parameters and its return type cannot be indexed.</source>
        <target state="translated">'“{0}”没有任何参数，并且无法对它的返回类型进行索引。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ArgumentSyntax">
        <source>Comma, ')', or a valid expression continuation expected.</source>
        <target state="translated">应为逗号、")" 或有效的表达式继续符。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExpectedResumeOrGoto">
        <source>'Resume' or 'GoTo' expected.</source>
        <target state="translated">'应为 "Resume" 或 "GoTo"。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExpectedAssignmentOperator">
        <source>'=' expected.</source>
        <target state="translated">'应为 "="。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NamedArgAlsoOmitted2">
        <source>Parameter '{0}' in '{1}' already has a matching omitted argument.</source>
        <target state="translated">“{1}”中的形参“{0}”已具有匹配的省略实参。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CannotCallEvent1">
        <source>'{0}' is an event, and cannot be called directly. Use a 'RaiseEvent' statement to raise an event.</source>
        <target state="translated">'“{0}”是事件，不能直接调用。请使用“RaiseEvent”语句引发事件。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ForEachCollectionDesignPattern1">
        <source>Expression is of type '{0}', which is not a collection type.</source>
        <target state="translated">表达式的类型为“{0}”，该类型不是集合类型。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DefaultValueForNonOptionalParam">
        <source>Default values cannot be supplied for parameters that are not declared 'Optional'.</source>
        <target state="translated">无法向未声明为 "Optional" 的参数提供默认值。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExpectedDotAfterMyBase">
        <source>'MyBase' must be followed by '.' and an identifier.</source>
        <target state="translated">'“MyBase”的后面必须跟有“.”和标识符。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExpectedDotAfterMyClass">
        <source>'MyClass' must be followed by '.' and an identifier.</source>
        <target state="translated">'“MyClass”的后面必须跟有“.”和标识符。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_StrictArgumentCopyBackNarrowing3">
        <source>Option Strict On disallows narrowing from type '{1}' to type '{2}' in copying the value of 'ByRef' parameter '{0}' back to the matching argument.</source>
        <target state="translated">将“ByRef”形参“{0}”的值复制回匹配实参时，Option Strict On 不允许从类型“{1}”收缩为类型“{2}”。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_LbElseifAfterElse">
        <source>'#ElseIf' cannot follow '#Else' as part of a '#If' block.</source>
        <target state="translated">'"#ElseIf" 不能作为 "#If" 块的一部分跟在 "#Else" 之后。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_StandaloneAttribute">
        <source>Attribute specifier is not a complete statement. Use a line continuation to apply the attribute to the following statement.</source>
        <target state="translated">特性说明符不是一个完整的语句。请使用行继续符将该特性应用于下列语句。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NoUniqueConstructorOnBase2">
        <source>Class '{0}' must declare a 'Sub New' because its base class '{1}' has more than one accessible 'Sub New' that can be called with no arguments.</source>
        <target state="translated">类“{0}”必须声明一个“Sub New”，因它的基类“{1}”有多个不使用参数就可以调用的可访问“Sub New”。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExtraNextVariable">
        <source>'Next' statement names more variables than there are matching 'For' statements.</source>
        <target state="translated">'“Next”语句命名的变量比已有的匹配“For”语句多。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RequiredNewCallTooMany2">
        <source>First statement of this 'Sub New' must be a call to 'MyBase.New' or 'MyClass.New' because base class '{0}' of '{1}' has more than one accessible 'Sub New' that can be called with no arguments.</source>
        <target state="translated">“{1}”的基类“{0}”没有不使用参数就可以调用的可访问“Sub New”，因此该“Sub New”的第一个语句必须是对“MyBase.New”或“MyClass.New”的调用。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ForCtlVarArraySizesSpecified">
        <source>Array declared as for loop control variable cannot be declared with an initial size.</source>
        <target state="translated">声明用于循环控制变量的数组时不能使用初始大小的值。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadFlagsOnNewOverloads">
        <source>The '{0}' keyword is used to overload inherited members; do not use the '{0}' keyword when overloading 'Sub New'.</source>
        <target state="translated">“{0}”关键字用于重载继承的成员；重载“Sub New”时不要使用“{0}”关键字。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_TypeCharOnGenericParam">
        <source>Type character cannot be used in a type parameter declaration.</source>
        <target state="translated">在类型参数声明中不能使用类型字符。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_TooFewGenericArguments1">
        <source>Too few type arguments to '{0}'.</source>
        <target state="translated">“{0}”的类型参数太少。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_TooManyGenericArguments1">
        <source>Too many type arguments to '{0}'.</source>
        <target state="translated">“{0}”的类型参数太多。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_GenericConstraintNotSatisfied2">
        <source>Type argument '{0}' does not inherit from or implement the constraint type '{1}'.</source>
        <target state="translated">类型参数“{0}”不能继承自或实现约束类型“{1}”。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_TypeOrMemberNotGeneric1">
        <source>'{0}' has no type parameters and so cannot have type arguments.</source>
        <target state="translated">'“{0}”没有类型形参，因此不能有类型实参。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NewIfNullOnGenericParam">
        <source>'New' cannot be used on a type parameter that does not have a 'New' constraint.</source>
        <target state="translated">'不能在没有 "New" 约束的类型参数上使用 "New"。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_MultipleClassConstraints1">
        <source>Type parameter '{0}' can only have one constraint that is a class.</source>
        <target state="translated">类型参数“{0}”只能有一个属于类的约束。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ConstNotClassInterfaceOrTypeParam1">
        <source>Type constraint '{0}' must be either a class, interface or type parameter.</source>
        <target state="translated">类型约束“{0}”必须是类、接口或类型参数。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DuplicateTypeParamName1">
        <source>Type parameter already declared with name '{0}'.</source>
        <target state="translated">类型参数已使用名称“{0}”声明。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_UnboundTypeParam2">
        <source>Type parameter '{0}' for '{1}' cannot be inferred.</source>
        <target state="translated">无法推断“{1}”的类型参数“{0}”。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_IsOperatorGenericParam1">
        <source>'Is' operand of type '{0}' can be compared only to 'Nothing' because '{0}' is a type parameter with no class constraint.</source>
        <target state="translated">'类型“{0}”是没有类约束的类型参数，因此类型“{0}”的“Is”操作数只能与“Nothing”比较。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ArgumentCopyBackNarrowing3">
        <source>Copying the value of 'ByRef' parameter '{0}' back to the matching argument narrows from type '{1}' to type '{2}'.</source>
        <target state="translated">将“ByRef”参数“{0}”的值复制回匹配的参数将导致从类型“{1}”到类型“{2}”的收缩。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ShadowingGenericParamWithMember1">
        <source>'{0}' has the same name as a type parameter.</source>
        <target state="translated">'“{0}”与一个类型参数同名。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_GenericParamBase2">
        <source>{0} '{1}' cannot inherit from a type parameter.</source>
        <target state="translated">{0}“{1}”不能从类型参数中继承。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ImplementsGenericParam">
        <source>Type parameter not allowed in 'Implements' clause.</source>
        <target state="translated">“Implements”子句中不允许类型参数。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_OnlyNullLowerBound">
        <source>Array lower bounds can be only '0'.</source>
        <target state="translated">数组的下限只能是“0”。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ClassConstraintNotInheritable1">
        <source>Type constraint cannot be a 'NotInheritable' class.</source>
        <target state="translated">类型约束不能是“NotInheritable”类。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ConstraintIsRestrictedType1">
        <source>'{0}' cannot be used as a type constraint.</source>
        <target state="translated">'“{0}”不能用作类型约束。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_GenericParamsOnInvalidMember">
        <source>Type parameters cannot be specified on this declaration.</source>
        <target state="translated">在此声明上不能指定类型参数。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_GenericArgsOnAttributeSpecifier">
        <source>Type arguments are not valid because attributes cannot be generic.</source>
        <target state="translated">由于特性不能是泛型，因此类型参数无效。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AttrCannotBeGenerics">
        <source>Type parameters, generic types or types contained in generic types cannot be used as attributes.</source>
        <target state="translated">类型参数、泛型类型或泛型类型中包含的类型不能用作特性。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadStaticLocalInGenericMethod">
        <source>Local variables within generic methods cannot be declared 'Static'.</source>
        <target state="translated">泛型方法中的局部变量不能声明为“Static”。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_SyntMemberShadowsGenericParam3">
        <source>{0} '{1}' implicitly defines a member '{2}' which has the same name as a type parameter.</source>
        <target state="translated">{0}“{1}”隐式定义了与某个类型参数同名的成员“{2}”。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ConstraintAlreadyExists1">
        <source>Constraint type '{0}' already specified for this type parameter.</source>
        <target state="translated">已为此类型参数指定了约束类型“{0}”。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InterfacePossiblyImplTwice2">
        <source>Cannot implement interface '{0}' because its implementation could conflict with the implementation of another implemented interface '{1}' for some type arguments.</source>
        <target state="translated">无法实现接口“{0}”，因为对于某些类型参数，该接口的实现可能与另一个已实现的接口“{1}”的实现冲突。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ModulesCannotBeGeneric">
        <source>Modules cannot be generic.</source>
        <target state="translated">模块不能是泛型的。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_GenericClassCannotInheritAttr">
        <source>Classes that are generic or contained in a generic type cannot inherit from an attribute class.</source>
        <target state="translated">属于泛型或包含在泛型类型中的类不能从特性类继承。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DeclaresCantBeInGeneric">
        <source>'Declare' statements are not allowed in generic types or types contained in generic types.</source>
        <target state="translated">'泛型类型或包含在泛型类型中的类型中不允许“Declare”语句。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_OverrideWithConstraintMismatch2">
        <source>'{0}' cannot override '{1}' because they differ by type parameter constraints.</source>
        <target state="translated">'“{0}”无法重写“{1}”，因为它们在类型参数约束上存在差异。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ImplementsWithConstraintMismatch3">
        <source>'{0}' cannot implement '{1}.{2}' because they differ by type parameter constraints.</source>
        <target state="translated">'“{0}”无法实现“{1}.{2}”，因为它们在类型参数约束上存在差异。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_OpenTypeDisallowed">
        <source>Type parameters or types constructed with type parameters are not allowed in attribute arguments.</source>
        <target state="translated">特性实参中不允许类型形参或用类型形参构造的类型。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_HandlesInvalidOnGenericMethod">
        <source>Generic methods cannot use 'Handles' clause.</source>
        <target state="translated">泛型方法不能使用“Handles”子句。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_MultipleNewConstraints">
        <source>'New' constraint cannot be specified multiple times for the same type parameter.</source>
        <target state="translated">'"New" 约束不能为同一类型参数指定多次。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_MustInheritForNewConstraint2">
        <source>Type argument '{0}' is declared 'MustInherit' and does not satisfy the 'New' constraint for type parameter '{1}'.</source>
        <target state="translated">类型实参“{0}”声明为“MustInherit”，并且不满足类型形参“{1}”的“New”约束。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NoSuitableNewForNewConstraint2">
        <source>Type argument '{0}' must have a public parameterless instance constructor to satisfy the 'New' constraint for type parameter '{1}'.</source>
        <target state="translated">类型实参“{0}”必须具有一个公共的无参数实例构造函数，才能满足类型形参“{1}”的“New”约束。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadGenericParamForNewConstraint2">
        <source>Type parameter '{0}' must have either a 'New' constraint or a 'Structure' constraint to satisfy the 'New' constraint for type parameter '{1}'.</source>
        <target state="translated">类型参数“{0}”必须具有“New”约束或“Structure”约束，才能满足类型参数“{1}”的“New”约束。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NewArgsDisallowedForTypeParam">
        <source>Arguments cannot be passed to a 'New' used on a type parameter.</source>
        <target state="translated">无法给类型形参上使用的 "New" 传递实参。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DuplicateRawGenericTypeImport1">
        <source>Generic type '{0}' cannot be imported more than once.</source>
        <target state="translated">不能多次导入泛型类型“{0}”。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NoTypeArgumentCountOverloadCand1">
        <source>Overload resolution failed because no accessible '{0}' accepts this number of type arguments.</source>
        <target state="translated">重载决策失败，因为没有可访问的“{0}”接受此数量的类型参数。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_TypeArgsUnexpected">
        <source>Type arguments unexpected.</source>
        <target state="translated">不应为类型参数。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NameSameAsMethodTypeParam1">
        <source>'{0}' is already declared as a type parameter of this method.</source>
        <target state="translated">'“{0}”已声明为此方法的类型参数。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_TypeParamNameFunctionNameCollision">
        <source>Type parameter cannot have the same name as its defining function.</source>
        <target state="translated">类型参数不能与其定义函数同名。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadConstraintSyntax">
        <source>Type or 'New' expected.</source>
        <target state="translated">应为类型或“New”。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_OfExpected">
        <source>'Of' required when specifying type arguments for a generic type or method.</source>
        <target state="translated">'在指定泛型类型或方法的类型参数时需要 "Of"。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ArrayOfRawGenericInvalid">
        <source>'(' unexpected. Arrays of uninstantiated generic types are not allowed.</source>
        <target state="translated">'不应为 "("。不允许非实例化泛型类型的数组。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ForEachAmbiguousIEnumerable1">
        <source>'For Each' on type '{0}' is ambiguous because the type implements multiple instantiations of 'System.Collections.Generic.IEnumerable(Of T)'.</source>
        <target state="translated">'类型“{0}”的“For Each”不明确，因为此类型实现了“System.Collections.Generic.IEnumerable(Of T)”的多个实例化。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_IsNotOperatorGenericParam1">
        <source>'IsNot' operand of type '{0}' can be compared only to 'Nothing' because '{0}' is a type parameter with no class constraint.</source>
        <target state="translated">'类型“{0}”是没有类约束的类型参数，因此类型“{0}”的“Isnot”操作数只能与“Nothing”比较。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_TypeParamQualifierDisallowed">
        <source>Type parameters cannot be used as qualifiers.</source>
        <target state="translated">类型参数不能用作限定符。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_TypeParamMissingCommaOrRParen">
        <source>Comma or ')' expected.</source>
        <target state="translated">应为逗号或 ")"。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_TypeParamMissingAsCommaOrRParen">
        <source>'As', comma or ')' expected.</source>
        <target state="translated">'应为 "As"、逗号或 ")"。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_MultipleReferenceConstraints">
        <source>'Class' constraint cannot be specified multiple times for the same type parameter.</source>
        <target state="translated">'"Class" 约束不能为同一类型参数指定多次。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_MultipleValueConstraints">
        <source>'Structure' constraint cannot be specified multiple times for the same type parameter.</source>
        <target state="translated">'"Structure" 约束不能为同一类型参数指定多次。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NewAndValueConstraintsCombined">
        <source>'New' constraint and 'Structure' constraint cannot be combined.</source>
        <target state="translated">'"New" 约束不能与 "Structure" 约束组合。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RefAndValueConstraintsCombined">
        <source>'Class' constraint and 'Structure' constraint cannot be combined.</source>
        <target state="translated">'"Class" 约束不能与 "Structure" 约束组合。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadTypeArgForStructConstraint2">
        <source>Type argument '{0}' does not satisfy the 'Structure' constraint for type parameter '{1}'.</source>
        <target state="translated">类型实参“{0}”不满足类型形参“{1}”的“Structure”约束。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadTypeArgForRefConstraint2">
        <source>Type argument '{0}' does not satisfy the 'Class' constraint for type parameter '{1}'.</source>
        <target state="translated">类型实参“{0}”不满足类型形参“{1}”的“Class”约束。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RefAndClassTypeConstrCombined">
        <source>'Class' constraint and a specific class type constraint cannot be combined.</source>
        <target state="translated">'"Class" 约束不能与特定的类类型约束组合。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ValueAndClassTypeConstrCombined">
        <source>'Structure' constraint and a specific class type constraint cannot be combined.</source>
        <target state="translated">'"Structure" 约束不能与特定的类类型约束组合。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ConstraintClashIndirectIndirect4">
        <source>Indirect constraint '{0}' obtained from the type parameter constraint '{1}' conflicts with the indirect constraint '{2}' obtained from the type parameter constraint '{3}'.</source>
        <target state="translated">从类型参数约束“{1}”获得的间接约束“{0}”与从类型参数约束“{3}”获得的间接约束“{2}”冲突。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ConstraintClashDirectIndirect3">
        <source>Constraint '{0}' conflicts with the indirect constraint '{1}' obtained from the type parameter constraint '{2}'.</source>
        <target state="translated">约束“{0}”与从类型参数约束“{2}”获得的间接约束“{1}”冲突。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ConstraintClashIndirectDirect3">
        <source>Indirect constraint '{0}' obtained from the type parameter constraint '{1}' conflicts with the constraint '{2}'.</source>
        <target state="translated">从类型参数约束“{1}”获得的间接约束“{0}”与约束“{2}”冲突。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ConstraintCycleLink2">
        <source>
    '{0}' is constrained to '{1}'.</source>
        <target state="translated">
  “{0}”被约束为“{1}”。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ConstraintCycle2">
        <source>Type parameter '{0}' cannot be constrained to itself: {1}</source>
        <target state="translated">类型参数“{0}”不能约束为自身: {1}</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_TypeParamWithStructConstAsConst">
        <source>Type parameter with a 'Structure' constraint cannot be used as a constraint.</source>
        <target state="translated">具有 "Structure" 约束的类型参数不能用作约束。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NullableDisallowedForStructConstr1">
        <source>'System.Nullable' does not satisfy the 'Structure' constraint for type parameter '{0}'. Only non-nullable 'Structure' types are allowed.</source>
        <target state="translated">'“System.Nullable”不满足类型参数“{0}”的“Structure”约束。仅允许不可为 null 的“Structure”类型。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ConflictingDirectConstraints3">
        <source>Constraint '{0}' conflicts with the constraint '{1}' already specified for type parameter '{2}'.</source>
        <target state="translated">约束“{0}”与已为类型参数“{2}”指定的约束“{1}”冲突。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InterfaceUnifiesWithInterface2">
        <source>Cannot inherit interface '{0}' because it could be identical to interface '{1}' for some type arguments.</source>
        <target state="translated">无法继承接口“{0}”，因为对于某些类型参数，该接口与接口“{1}”相同。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BaseUnifiesWithInterfaces3">
        <source>Cannot inherit interface '{0}' because the interface '{1}' from which it inherits could be identical to interface '{2}' for some type arguments.</source>
        <target state="translated">无法继承接口“{0}”，因为对于某些类型参数，它所继承的接口“{1}”可能与接口“{2}”相同。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InterfaceBaseUnifiesWithBase4">
        <source>Cannot inherit interface '{0}' because the interface '{1}' from which it inherits could be identical to interface '{2}' from which the interface '{3}' inherits for some type arguments.</source>
        <target state="translated">无法继承接口“{0}”，因为对于某些类型参数，继承的接口“{1}”可能与接口“{3}”继承的接口“{2}”相同。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InterfaceUnifiesWithBase3">
        <source>Cannot inherit interface '{0}' because it could be identical to interface '{1}' from which the interface '{2}' inherits for some type arguments.</source>
        <target state="translated">无法继承接口“{0}”，因为对于某些类型参数，该接口与接口“{2}”继承的接口“{1}”相同。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ClassInheritsBaseUnifiesWithInterfaces3">
        <source>Cannot implement interface '{0}' because the interface '{1}' from which it inherits could be identical to implemented interface '{2}' for some type arguments.</source>
        <target state="translated">无法实现接口“{0}”，因为对于某些类型参数，它所继承的接口“{1}”可能与实现的接口“{2}”相同。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ClassInheritsInterfaceBaseUnifiesWithBase4">
        <source>Cannot implement interface '{0}' because the interface '{1}' from which it inherits could be identical to interface '{2}' from which the implemented interface '{3}' inherits for some type arguments.</source>
        <target state="translated">无法实现接口“{0}”，因为对于某些类型参数，它所继承的接口“{1}”可能与实现的接口“{3}”所继承的接口“{2}”相同。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ClassInheritsInterfaceUnifiesWithBase3">
        <source>Cannot implement interface '{0}' because it could be identical to interface '{1}' from which the implemented interface '{2}' inherits for some type arguments.</source>
        <target state="translated">无法实现接口“{0}”，因为对于某些类型参数，它可能与实现的接口“{2}”所继承的接口“{1}”相同。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_OptionalsCantBeStructGenericParams">
        <source>Generic parameters used as optional parameter types must be class constrained.</source>
        <target state="translated">用作可选参数类型的泛型参数必须受类约束。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AddressOfNullableMethod">
        <source>Methods of 'System.Nullable(Of T)' cannot be used as operands of the 'AddressOf' operator.</source>
        <target state="translated">“System.Nullable(Of T)”的方法不能用作“AddressOf”运算符的操作数。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_IsOperatorNullable1">
        <source>'Is' operand of type '{0}' can be compared only to 'Nothing' because '{0}' is a nullable type.</source>
        <target state="translated">'类型“{0}”是可以为 null 的类型，因此“{0}”的“Is”操作数只能与“Nothing”进行比较。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_IsNotOperatorNullable1">
        <source>'IsNot' operand of type '{0}' can be compared only to 'Nothing' because '{0}' is a nullable type.</source>
        <target state="translated">'类型“{0}”是可以为 null 的类型，因此“{0}”的“IsNot”操作数只能与“Nothing”进行比较。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ShadowingTypeOutsideClass1">
        <source>'{0}' cannot be declared 'Shadows' outside of a class, structure, or interface.</source>
        <target state="translated">'“{0}”不能在类、结构或接口外声明为“Shadows”。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PropertySetParamCollisionWithValue">
        <source>Property parameters cannot have the name 'Value'.</source>
        <target state="translated">属性参数的名称不能为 "Value"。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_SxSIndirectRefHigherThanDirectRef3">
        <source>The project currently contains references to more than one version of '{0}', a direct reference to version {2} and an indirect reference to version {1}. Change the direct reference to use version {1} (or higher) of {0}.</source>
        <target state="translated">项目当前包含对多个版本的“{0}”的引用、对版本 {2} 的直接引用和对版本 {1} 的间接引用。请将直接引用更改为使用 {0} 的版本 {1} (或更高版本)。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DuplicateReferenceStrong">
        <source>Multiple assemblies with equivalent identity have been imported: '{0}' and '{1}'. Remove one of the duplicate references.</source>
        <target state="translated">导入了具有等效标识的多个程序集:“{0}”和“{1}”。请删除重复引用之一。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DuplicateReference2">
        <source>Project already has a reference to assembly '{0}'. A second reference to '{1}' cannot be added.</source>
        <target state="translated">项目已经具有对程序集“{0}”的引用。无法添加另一个对“{1}”的引用。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_IllegalCallOrIndex">
        <source>Illegal call expression or index expression.</source>
        <target state="translated">非法的调用表达式或索引表达式。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ConflictDefaultPropertyAttribute">
        <source>Conflict between the default property and the 'DefaultMemberAttribute' defined on '{0}'.</source>
        <target state="translated">默认属性与“{0}”上定义的“DefaultMemberAttribute”之间有冲突。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadAttributeUuid2">
        <source>'{0}' cannot be applied because the format of the GUID '{1}' is not correct.</source>
        <target state="translated">'GUID“{1}”的格式不正确，因此无法应用“{0}”。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ComClassAndReservedAttribute1">
        <source>'Microsoft.VisualBasic.ComClassAttribute' and '{0}' cannot both be applied to the same class.</source>
        <target state="translated">'“Microsoft.VisualBasic.ComClassAttribute”和“{0}”不能同时应用于同一个类。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ComClassRequiresPublicClass2">
        <source>'Microsoft.VisualBasic.ComClassAttribute' cannot be applied to '{0}' because its container '{1}' is not declared 'Public'.</source>
        <target state="translated">'“Microsoft.VisualBasic.ComClassAttribute”的容器“{1}”未声明为“Public”，因此不能应用于“{0}”。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ComClassReservedDispIdZero1">
        <source>'System.Runtime.InteropServices.DispIdAttribute' cannot be applied to '{0}' because 'Microsoft.VisualBasic.ComClassAttribute' reserves zero for the default property.</source>
        <target state="translated">'“Microsoft.VisualBasic.ComClassAttribute”为默认属性保留的值为零，因此“System.Runtime.InteropServices.DispIdAttribute”不能应用于“{0}”。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ComClassReservedDispId1">
        <source>'System.Runtime.InteropServices.DispIdAttribute' cannot be applied to '{0}' because 'Microsoft.VisualBasic.ComClassAttribute' reserves values less than zero.</source>
        <target state="translated">'“Microsoft.VisualBasic.ComClassAttribute”保留的值小于零，因此“System.Runtime.InteropServices.DispIdAttribute”不能应用于“{0}”。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ComClassDuplicateGuids1">
        <source>'InterfaceId' and 'EventsId' parameters for 'Microsoft.VisualBasic.ComClassAttribute' on '{0}' cannot have the same value.</source>
        <target state="translated">'“{0}”上“Microsoft.VisualBasic.ComClassAttribute”的“InterfaceId”和“EventsId”参数的值不能相同。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ComClassCantBeAbstract0">
        <source>'Microsoft.VisualBasic.ComClassAttribute' cannot be applied to a class that is declared 'MustInherit'.</source>
        <target state="translated">'“Microsoft.VisualBasic.ComClassAttribute”不能应用于被声明为“MustInherit”的类。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ComClassRequiresPublicClass1">
        <source>'Microsoft.VisualBasic.ComClassAttribute' cannot be applied to '{0}' because it is not declared 'Public'.</source>
        <target state="translated">'“Microsoft.VisualBasic.ComClassAttribute”未声明为“Public”，因此不能应用于“{0}”。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_UnknownOperator">
        <source>Operator declaration must be one of:  +, -, *, \, /, ^, &amp;, Like, Mod, And, Or, Xor, Not, &lt;&lt;, &gt;&gt;, =, &lt;&gt;, &lt;, &lt;=, &gt;, &gt;=, CType, IsTrue, IsFalse.</source>
        <target state="translated">运算符声明必须是以下符号之一: +、-、*、\、/、^、&amp;,、Like、Mod、And、Or、Xor、Not、&lt;&lt;、&gt;&gt;、=、&lt;&gt;、&lt;、&lt;=、&gt;、&gt;=、CType、IsTrue 和 IsFalse。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DuplicateConversionCategoryUsed">
        <source>'Widening' and 'Narrowing' cannot be combined.</source>
        <target state="translated">'"Widening" 不能与 "Narrowing" 组合。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_OperatorNotOverloadable">
        <source>Operator is not overloadable. Operator declaration must be one of:  +, -, *, \, /, ^, &amp;, Like, Mod, And, Or, Xor, Not, &lt;&lt;, &gt;&gt;, =, &lt;&gt;, &lt;, &lt;=, &gt;, &gt;=, CType, IsTrue, IsFalse.</source>
        <target state="translated">运算符不可重载。运算符声明必须是以下符号之一: +、-、*、\、/、^、&amp;,、Like、Mod、And、Or、Xor、Not、&lt;&lt;、&gt;&gt;、=、&lt;&gt;、&lt;、&lt;=、&gt;、&gt;=、CType、IsTrue 和 IsFalse。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InvalidHandles">
        <source>'Handles' is not valid on operator declarations.</source>
        <target state="translated">'“Handles”在运算符声明上无效。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InvalidImplements">
        <source>'Implements' is not valid on operator declarations.</source>
        <target state="translated">'“Implements”在运算符声明上无效。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_EndOperatorExpected">
        <source>'End Operator' expected.</source>
        <target state="translated">'应为 "End Operator"。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_EndOperatorNotAtLineStart">
        <source>'End Operator' must be the first statement on a line.</source>
        <target state="translated">'“End Operator”必须是一行中的第一条语句。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InvalidEndOperator">
        <source>'End Operator' must be preceded by a matching 'Operator'.</source>
        <target state="translated">'“End Operator”前面必须是匹配的“Operator”。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExitOperatorNotValid">
        <source>'Exit Operator' is not valid. Use 'Return' to exit an operator.</source>
        <target state="translated">'"Exit Operator" 无效。请使用 "Return" 从运算符中退出。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ParamArrayIllegal1">
        <source>'{0}' parameters cannot be declared 'ParamArray'.</source>
        <target state="translated">“{0}”参数不能声明为 "ParamArray"。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_OptionalIllegal1">
        <source>'{0}' parameters cannot be declared 'Optional'.</source>
        <target state="translated">'“{0}”参数不能声明为“Optional”。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_OperatorMustBePublic">
        <source>Operators must be declared 'Public'.</source>
        <target state="translated">运算符必须声明为 "Public"。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_OperatorMustBeShared">
        <source>Operators must be declared 'Shared'.</source>
        <target state="translated">运算符必须声明为 "Shared"。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadOperatorFlags1">
        <source>Operators cannot be declared '{0}'.</source>
        <target state="translated">运算符不能声明为“{0}”。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_OneParameterRequired1">
        <source>Operator '{0}' must have one parameter.</source>
        <target state="translated">运算符“{0}”必须有一个参数。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_TwoParametersRequired1">
        <source>Operator '{0}' must have two parameters.</source>
        <target state="translated">运算符“{0}”必须有两个参数。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_OneOrTwoParametersRequired1">
        <source>Operator '{0}' must have either one or two parameters.</source>
        <target state="translated">运算符“{0}”必须有一个两个参数。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ConvMustBeWideningOrNarrowing">
        <source>Conversion operators must be declared either 'Widening' or 'Narrowing'.</source>
        <target state="translated">转换运算符必须声明为“Widening”或者“Narrowing”。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_OperatorDeclaredInModule">
        <source>Operators cannot be declared in modules.</source>
        <target state="translated">运算符不能在模块中声明。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InvalidSpecifierOnNonConversion1">
        <source>Only conversion operators can be declared '{0}'.</source>
        <target state="translated">只有转换运算符可以声明为“{0}”。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_UnaryParamMustBeContainingType1">
        <source>Parameter of this unary operator must be of the containing type '{0}'.</source>
        <target state="translated">此一元运算符的参数必须属于包含类型“{0}”。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BinaryParamMustBeContainingType1">
        <source>At least one parameter of this binary operator must be of the containing type '{0}'.</source>
        <target state="translated">此二元运算符的至少一个参数必须属于包含类型“{0}”。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ConvParamMustBeContainingType1">
        <source>Either the parameter type or the return type of this conversion operator must be of the containing type '{0}'.</source>
        <target state="translated">此转换运算符的参数类型或返回类型必须属于包含类型“{0}”。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_OperatorRequiresBoolReturnType1">
        <source>Operator '{0}' must have a return type of Boolean.</source>
        <target state="translated">运算符“{0}”必须具有 Boolean 返回类型。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ConversionToSameType">
        <source>Conversion operators cannot convert from a type to the same type.</source>
        <target state="translated">转换运算符不能从某一类型转换为相同的类型。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ConversionToInterfaceType">
        <source>Conversion operators cannot convert to an interface type.</source>
        <target state="translated">转换运算符不能转换为接口类型。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ConversionToBaseType">
        <source>Conversion operators cannot convert from a type to its base type.</source>
        <target state="translated">转换运算符不能从某一类型转换为它的基类型。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ConversionToDerivedType">
        <source>Conversion operators cannot convert from a type to its derived type.</source>
        <target state="translated">转换运算符不能从某一类型转换为它的派生类型。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ConversionToObject">
        <source>Conversion operators cannot convert to Object.</source>
        <target state="translated">转换运算符不能转换为 Object。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ConversionFromInterfaceType">
        <source>Conversion operators cannot convert from an interface type.</source>
        <target state="translated">转换运算符不能从接口类型转换。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ConversionFromBaseType">
        <source>Conversion operators cannot convert from a base type.</source>
        <target state="translated">转换运算符不能从基类型转换。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ConversionFromDerivedType">
        <source>Conversion operators cannot convert from a derived type.</source>
        <target state="translated">转换运算符不能从派生类型转换。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ConversionFromObject">
        <source>Conversion operators cannot convert from Object.</source>
        <target state="translated">转换运算符不能从 Object 转换。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_MatchingOperatorExpected2">
        <source>Matching '{0}' operator is required for '{1}'.</source>
        <target state="translated">“{1}”需要匹配“{0}”运算符。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_UnacceptableLogicalOperator3">
        <source>Return and parameter types of '{0}' must be '{1}' to be used in a '{2}' expression.</source>
        <target state="translated">“{0}”的返回类型和参数类型必须是“{1}”，才能在“{2}”表达式中使用。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ConditionOperatorRequired3">
        <source>Type '{0}' must define operator '{1}' to be used in a '{2}' expression.</source>
        <target state="translated">类型“{0}”必须定义运算符“{1}”，才能在“{2}”表达式中使用。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CopyBackTypeMismatch3">
        <source>Cannot copy the value of 'ByRef' parameter '{0}' back to the matching argument because type '{1}' cannot be converted to type '{2}'.</source>
        <target state="translated">由于类型“{1}”不能转换为类型“{2}”，因此无法将“ByRef”参数“{0}”的值复制回匹配的参数。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ForLoopOperatorRequired2">
        <source>Type '{0}' must define operator '{1}' to be used in a 'For' statement.</source>
        <target state="translated">类型“{0}”必须定义运算符“{1}”，才能在“For”语句中使用。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_UnacceptableForLoopOperator2">
        <source>Return and parameter types of '{0}' must be '{1}' to be used in a 'For' statement.</source>
        <target state="translated">“{0}”的返回类型和参数类型必须是“{1}”，才能在“For”语句中使用。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_UnacceptableForLoopRelOperator2">
        <source>Parameter types of '{0}' must be '{1}' to be used in a 'For' statement.</source>
        <target state="translated">“{0}”的参数类型必须是“{1}”，才能在“For”语句中使用。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_OperatorRequiresIntegerParameter1">
        <source>Operator '{0}' must have a second parameter of type 'Integer' or 'Integer?'.</source>
        <target state="translated">运算符“{0}”必须有另一个“Integer”或“Integer?”类型的参数。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CantSpecifyNullableOnBoth">
        <source>Nullable modifier cannot be specified on both a variable and its type.</source>
        <target state="translated">不能在变量及其类型上同时指定可以为 null 的修饰符。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadTypeArgForStructConstraintNull">
        <source>Type '{0}' must be a value type or a type argument constrained to 'Structure' in order to be used with 'Nullable' or nullable modifier '?'.</source>
        <target state="translated">类型“{0}”必须是一个被约束为“Structure”的值类型或类型参数，才能与“Nullable”或可以为 null 的修饰符“?”一起使用。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CantSpecifyArrayAndNullableOnBoth">
        <source>Nullable modifier '?' and array modifiers '(' and ')' cannot be specified on both a variable and its type.</source>
        <target state="translated">不能在变量及其类型上同时指定可为 null 的修饰符“?”和数组修饰符“(”/“)”。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CantSpecifyTypeCharacterOnIIF">
        <source>Expressions used with an 'If' expression cannot contain type characters.</source>
        <target state="translated">与“If”表达式一起使用的表达式不能包含类型字符。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_IllegalOperandInIIFName">
        <source>'If' operands cannot be named arguments.</source>
        <target state="translated">'“If”操作数不能是命名参数。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_IllegalOperandInIIFConversion">
        <source>Cannot infer a common type for the second and third operands of the 'If' operator. One must have a widening conversion to the other.</source>
        <target state="translated">无法推断“If”运算符的第二个和第三个操作数的通用类型。其中一个必须是另一个的扩大转换。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_IllegalCondTypeInIIF">
        <source>First operand in a binary 'If' expression must be a nullable value type, a reference type, or an unconstrained generic type.</source>
        <target state="translated">二进制“If”表达式中的第一个操作数必须是可以为 null 的类型或引用类型。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CantCallIIF">
        <source>'If' operator cannot be used in a 'Call' statement.</source>
        <target state="translated">'“If”运算符不能在“Call”语句中使用。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CantSpecifyAsNewAndNullable">
        <source>Nullable modifier cannot be specified in variable declarations with 'As New'.</source>
        <target state="translated">在变量声明中不能用“As New”指定可以为 null 的修饰符。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_IllegalOperandInIIFConversion2">
        <source>Cannot infer a common type for the first and second operands of the binary 'If' operator. One must have a widening conversion to the other.</source>
        <target state="translated">无法推断二元“If”运算符的第一个和第二个操作数的通用类型。其中一个必须是另一个的扩大转换。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadNullTypeInCCExpression">
        <source>Nullable types are not allowed in conditional compilation expressions.</source>
        <target state="translated">在条件编译表达式中不允许有可以为 null 的类型。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NullableImplicit">
        <source>Nullable modifier cannot be used with a variable whose implicit type is 'Object'.</source>
        <target state="translated">可以为 null 的修饰符不能与隐式类型为 "Object" 的变量一起使用。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_MissingRuntimeHelper">
        <source>Requested operation is not available because the runtime library function '{0}' is not defined.</source>
        <target state="translated">所请求的操作不可用，因为没有定义运行库函数“{0}”。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExpectedDotAfterGlobalNameSpace">
        <source>'Global' must be followed by '.' and an identifier.</source>
        <target state="translated">'“Global”的后面必须跟有“.”和标识符。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NoGlobalExpectedIdentifier">
        <source>'Global' not allowed in this context; identifier expected.</source>
        <target state="translated">'此上下文中不允许 "Global"；应为标识符。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NoGlobalInHandles">
        <source>'Global' not allowed in handles; local name expected.</source>
        <target state="translated">'句柄中不允许 "Global"；应为本地名称。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ElseIfNoMatchingIf">
        <source>'ElseIf' must be preceded by a matching 'If' or 'ElseIf'.</source>
        <target state="translated">'"ElseIf" 前面必须是匹配的 "If" 或 "ElseIf"。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadAttributeConstructor2">
        <source>Attribute constructor has a 'ByRef' parameter of type '{0}'; cannot use constructors with byref parameters to apply the attribute.</source>
        <target state="translated">特性构造函数有一个“{0}”类型的“ByRef”参数；不能用带有 byref 参数的构造函数来应用特性。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_EndUsingWithoutUsing">
        <source>'End Using' must be preceded by a matching 'Using'.</source>
        <target state="translated">'“End Using”前面必须是匹配的“Using”。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExpectedEndUsing">
        <source>'Using' must end with a matching 'End Using'.</source>
        <target state="translated">'“Using”必须以匹配的“End Using”结束。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_GotoIntoUsing">
        <source>'GoTo {0}' is not valid because '{0}' is inside a 'Using' statement that does not contain this statement.</source>
        <target state="translated">'“GoTo {0}”无效，因为“{0}”位于不包含此语句的“Using”语句中。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_UsingRequiresDisposePattern">
        <source>'Using' operand of type '{0}' must implement 'System.IDisposable'.</source>
        <target state="translated">'“{0}”类型的“Using”操作数必须实现“System.IDisposable”。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_UsingResourceVarNeedsInitializer">
        <source>'Using' resource variable must have an explicit initialization.</source>
        <target state="translated">'"Using" 资源变量必须有一个显式初始化。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_UsingResourceVarCantBeArray">
        <source>'Using' resource variable type can not be array type.</source>
        <target state="translated">'"Using" 资源变量类型不能是数组类型。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_OnErrorInUsing">
        <source>'On Error' statements are not valid within 'Using' statements.</source>
        <target state="translated">'"On Error" 语句在 "Using" 语句内无效。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PropertyNameConflictInMyCollection">
        <source>'{0}' has the same name as a member used for type '{1}' exposed in a 'My' group. Rename the type or its enclosing namespace.</source>
        <target state="translated">'“{0}”与“My”组中公开的类型“{1}”所使用的成员同名。请重命名该类型或其封闭命名空间。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InvalidImplicitVar">
        <source>Implicit variable '{0}' is invalid because of '{1}'.</source>
        <target state="translated">由于“{1}”，隐式变量“{0}”无效。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ObjectInitializerRequiresFieldName">
        <source>Object initializers require a field name to initialize.</source>
        <target state="translated">对象初始值设定项需要一个字段名称以便进行初始化。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExpectedFrom">
        <source>'From' expected.</source>
        <target state="translated">'应为“From”。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_LambdaBindingMismatch1">
        <source>Nested function does not have the same signature as delegate '{0}'.</source>
        <target state="translated">嵌套函数与委托“{0}”的签名不相同。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_LambdaBindingMismatch2">
        <source>Nested sub does not have a signature that is compatible with delegate '{0}'.</source>
        <target state="translated">嵌套 Sub 的签名与委托“{0}”不兼容。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CannotLiftByRefParamQuery1">
        <source>'ByRef' parameter '{0}' cannot be used in a query expression.</source>
        <target state="translated">'不能在查询表达式中使用“ByRef”参数“{0}”。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExpressionTreeNotSupported">
        <source>Expression cannot be converted into an expression tree.</source>
        <target state="translated">无法将表达式转换为表达式树。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CannotLiftStructureMeQuery">
        <source>Instance members and 'Me' cannot be used within query expressions in structures.</source>
        <target state="translated">无法在结构中的查询表达式中使用实例成员和“Me”。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InferringNonArrayType1">
        <source>Variable cannot be initialized with non-array type '{0}'.</source>
        <target state="translated">无法用非数组类型“{0}”初始化变量。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ByRefParamInExpressionTree">
        <source>References to 'ByRef' parameters cannot be converted to an expression tree.</source>
        <target state="translated">对“ByRef”参数的引用无法转换为表达式树。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DuplicateAnonTypeMemberName1">
        <source>Anonymous type member or property '{0}' is already declared.</source>
        <target state="translated">已声明匿名类型成员或属性“{0}”。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadAnonymousTypeForExprTree">
        <source>Cannot convert anonymous type to an expression tree because a property of the type is used to initialize another property.</source>
        <target state="translated">无法将匿名类型转换为表达式树，因为此类型的属性用于初始化其他属性。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CannotLiftAnonymousType1">
        <source>Anonymous type property '{0}' cannot be used in the definition of a lambda expression within the same initialization list.</source>
        <target state="translated">不能在同一个初始化列表中的 lambda 表达式定义中使用匿名类型属性“{0}”。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExtensionOnlyAllowedOnModuleSubOrFunction">
        <source>'Extension' attribute can be applied only to 'Module', 'Sub', or 'Function' declarations.</source>
        <target state="translated">'“Extension”特性只能应用于“Module”、“Sub”或“Function”声明。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExtensionMethodNotInModule">
        <source>Extension methods can be defined only in modules.</source>
        <target state="translated">只能在模块中定义扩展方法。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExtensionMethodNoParams">
        <source>Extension methods must declare at least one parameter. The first parameter specifies which type to extend.</source>
        <target state="translated">扩展方法必须至少声明一个参数。第一个参数指定要扩展的类型。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExtensionMethodOptionalFirstArg">
        <source>'Optional' cannot be applied to the first parameter of an extension method. The first parameter specifies which type to extend.</source>
        <target state="translated">'“Optional”无法应用于扩展方法的第一个参数。第一个参数指定要扩展哪个类型。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExtensionMethodParamArrayFirstArg">
        <source>'ParamArray' cannot be applied to the first parameter of an extension method. The first parameter specifies which type to extend.</source>
        <target state="translated">"ParamArray" 无法应用于扩展方法的第一个参数。第一个参数指定要扩展哪个类型。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AnonymousTypeFieldNameInference">
        <source>Anonymous type member name can be inferred only from a simple or qualified name with no arguments.</source>
        <target state="translated">只能从不带参数的简单名或限定名中推断匿名类型成员名称。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NameNotMemberOfAnonymousType2">
        <source>'{0}' is not a member of '{1}'; it does not exist in the current context.</source>
        <target state="translated">'“{0}”不是“{1}”的成员；它不存在于当前上下文。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExtensionAttributeInvalid">
        <source>The custom-designed version of 'System.Runtime.CompilerServices.ExtensionAttribute' found by the compiler is not valid. Its attribute usage flags must be set to allow assemblies, classes, and methods.</source>
        <target state="translated">编译器找到的“System.Runtime.CompilerServices.ExtensionAttribute”的自定义设计版本无效。必须将其特性用法标志设置为允许程序集、类和方法使用。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AnonymousTypePropertyOutOfOrder1">
        <source>Anonymous type member property '{0}' cannot be used to infer the type of another member property because the type of '{0}' is not yet established.</source>
        <target state="translated">无法使用匿名类型成员属性“{0}”来推断另一个成员属性的类型，因为尚未建立“{0}”的类型。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AnonymousTypeDisallowsTypeChar">
        <source>Type characters cannot be used in anonymous type declarations.</source>
        <target state="translated">不能在匿名类型声明中使用类型字符。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_TupleLiteralDisallowsTypeChar">
        <source>Type characters cannot be used in tuple literals.</source>
        <target state="translated">类型字符无法用在元组文本中。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NewWithTupleTypeSyntax">
        <source>'New' cannot be used with tuple type. Use a tuple literal expression instead.</source>
        <target state="translated">'"New" 不能用于元组类型。请改用元组文本表达式。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PredefinedValueTupleTypeMustBeStruct">
        <source>Predefined type '{0}' must be a structure.</source>
        <target state="translated">预定义的类型“{0}”必须是一种结构。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExtensionMethodUncallable1">
        <source>Extension method '{0}' has type constraints that can never be satisfied.</source>
        <target state="translated">扩展方法“{0}”具有无法满足的类型约束。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExtensionMethodOverloadCandidate3">
        <source>
    Extension method '{0}' defined in '{1}': {2}</source>
        <target state="translated">
  “{1}”中定义的扩展方法“{0}”: {2}</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DelegateBindingMismatch">
        <source>Method does not have a signature compatible with the delegate.</source>
        <target state="translated">方法没有与委托兼容的签名。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DelegateBindingTypeInferenceFails">
        <source>Type arguments could not be inferred from the delegate.</source>
        <target state="translated">未能从委托中推断类型参数。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_TooManyArgs">
        <source>Too many arguments.</source>
        <target state="translated">参数太多。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NamedArgAlsoOmitted1">
        <source>Parameter '{0}' already has a matching omitted argument.</source>
        <target state="translated">形参“{0}”已具有匹配的省略实参。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NamedArgUsedTwice1">
        <source>Parameter '{0}' already has a matching argument.</source>
        <target state="translated">形参“{0}”已具有匹配的实参。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NamedParamNotFound1">
        <source>'{0}' is not a method parameter.</source>
        <target state="translated">'“{0}”不是方法参数。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_OmittedArgument1">
        <source>Argument not specified for parameter '{0}'.</source>
        <target state="translated">没有为参数“{0}”指定参数。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_UnboundTypeParam1">
        <source>Type parameter '{0}' cannot be inferred.</source>
        <target state="translated">无法推断类型参数“{0}”。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExtensionMethodOverloadCandidate2">
        <source>
    Extension method '{0}' defined in '{1}'.</source>
        <target state="translated">
  “{1}”中定义的扩展方法“{0}”。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AnonymousTypeNeedField">
        <source>Anonymous type must contain at least one member.</source>
        <target state="translated">匿名类型必须至少包含一个成员。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AnonymousTypeNameWithoutPeriod">
        <source>Anonymous type member name must be preceded by a period.</source>
        <target state="translated">匿名类型成员名前面必须有一个句点。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AnonymousTypeExpectedIdentifier">
        <source>Identifier expected, preceded with a period.</source>
        <target state="translated">应为开头带有句点的标识符。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_TooManyArgs2">
        <source>Too many arguments to extension method '{0}' defined in '{1}'.</source>
        <target state="translated">对“{1}”中定义的扩展方法“{0}”而言，参数太多。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NamedArgAlsoOmitted3">
        <source>Parameter '{0}' in extension method '{1}' defined in '{2}' already has a matching omitted argument.</source>
        <target state="translated">“{2}”中定义的扩展方法中的“{1}”形参“{0}”已具有匹配的省略实参。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NamedArgUsedTwice3">
        <source>Parameter '{0}' of extension method '{1}' defined in '{2}' already has a matching argument.</source>
        <target state="translated">“{2}”中定义的扩展方法“{1}”的形参“{0}”已具有匹配的实参。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NamedParamNotFound3">
        <source>'{0}' is not a parameter of extension method '{1}' defined in '{2}'.</source>
        <target state="translated">'“{0}”不是“{2}”中定义的扩展方法“{1}”的参数。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_OmittedArgument3">
        <source>Argument not specified for parameter '{0}' of extension method '{1}' defined in '{2}'.</source>
        <target state="translated">没有为“{2}”中定义的扩展方法“{1}”的形参“{0}”指定实参。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_UnboundTypeParam3">
        <source>Type parameter '{0}' for extension method '{1}' defined in '{2}' cannot be inferred.</source>
        <target state="translated">无法推断“{2}”中定义的扩展方法“{1}”的类型参数“{0}”。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_TooFewGenericArguments2">
        <source>Too few type arguments to extension method '{0}' defined in '{1}'.</source>
        <target state="translated">对“{1}”中定义的扩展方法“{0}”而言，类型参数太少。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_TooManyGenericArguments2">
        <source>Too many type arguments to extension method '{0}' defined in '{1}'.</source>
        <target state="translated">对“{1}”中定义的扩展方法“{0}”而言，类型参数太多。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExpectedInOrEq">
        <source>'In' or '=' expected.</source>
        <target state="translated">'应为“In”或“=”。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExpectedQueryableSource">
        <source>Expression of type '{0}' is not queryable. Make sure you are not missing an assembly reference and/or namespace import for the LINQ provider.</source>
        <target state="translated">类型“{0}”的表达式不可查询。请确保不缺少程序集引用和/或 LINQ 提供程序的命名空间导入。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_QueryOperatorNotFound">
        <source>Definition of method '{0}' is not accessible in this context.</source>
        <target state="translated">方法“{0}”的定义在此上下文中不可访问。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CannotUseOnErrorGotoWithClosure">
        <source>Method cannot contain both a '{0}' statement and a definition of a variable that is used in a lambda or query expression.</source>
        <target state="translated">方法不能同时包含“{0}”语句以及在 lambda 或查询表达式中使用的变量的定义。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CannotGotoNonScopeBlocksWithClosure">
        <source>'{0}{1}' is not valid because '{2}' is inside a scope that defines a variable that is used in a lambda or query expression.</source>
        <target state="translated">'“{0}{1}”无效，因为“{2}”所在的范围定义一个用在 lambda 表达式或查询表达式中的变量。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CannotLiftRestrictedTypeQuery">
        <source>Instance of restricted type '{0}' cannot be used in a query expression.</source>
        <target state="translated">不能在查询表达式中使用受限类型“{0}”的实例。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_QueryAnonymousTypeFieldNameInference">
        <source>Range variable name can be inferred only from a simple or qualified name with no arguments.</source>
        <target state="translated">只能从不带参数的简单名或限定名中推断范围变量名。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_QueryDuplicateAnonTypeMemberName1">
        <source>Range variable '{0}' is already declared.</source>
        <target state="translated">已声明范围变量“{0}”。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_QueryAnonymousTypeDisallowsTypeChar">
        <source>Type characters cannot be used in range variable declarations.</source>
        <target state="translated">在范围变量声明中不能使用类型字符。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ReadOnlyInClosure">
        <source>'ReadOnly' variable cannot be the target of an assignment in a lambda expression inside a constructor.</source>
        <target state="translated">'在构造函数内的 lambda 表达式中，"ReadOnly" 变量不能作为赋值的目标。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExprTreeNoMultiDimArrayCreation">
        <source>Multi-dimensional array cannot be converted to an expression tree.</source>
        <target state="translated">多维数组无法转换为表达式树。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExprTreeNoLateBind">
        <source>Late binding operations cannot be converted to an expression tree.</source>
        <target state="translated">后期绑定操作无法转换为表达式树。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExpectedBy">
        <source>'By' expected.</source>
        <target state="translated">'应为 "By"。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_QueryInvalidControlVariableName1">
        <source>Range variable name cannot match the name of a member of the 'Object' class.</source>
        <target state="translated">范围变量名无法与 "Object" 类的成员名匹配。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExpectedIn">
        <source>'In' expected.</source>
        <target state="translated">'应为“In”。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_QueryNameNotDeclared">
        <source>Name '{0}' is either not declared or not in the current scope.</source>
        <target state="translated">名称“{0}”未声明或不在当前作用域中。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NestedFunctionArgumentNarrowing3">
        <source>Return type of nested function matching parameter '{0}' narrows from '{1}' to '{2}'.</source>
        <target state="translated">与参数“{0}”匹配的嵌套函数的返回类型从“{1}”收缩到“{2}”。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AnonTypeFieldXMLNameInference">
        <source>Anonymous type member name cannot be inferred from an XML identifier that is not a valid Visual Basic identifier.</source>
        <target state="translated">无法根据不是有效 Visual Basic 标识符的 XML 标识符推断出匿名类型成员名称。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_QueryAnonTypeFieldXMLNameInference">
        <source>Range variable name cannot be inferred from an XML identifier that is not a valid Visual Basic identifier.</source>
        <target state="translated">无法根据不是有效 Visual Basic 标识符的 XML 标识符推断出范围变量名。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExpectedInto">
        <source>'Into' expected.</source>
        <target state="translated">'应为“Into”。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_TypeCharOnAggregation">
        <source>Aggregate function name cannot be used with a type character.</source>
        <target state="translated">聚合函数名不能与类型字符一起使用。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExpectedOn">
        <source>'On' expected.</source>
        <target state="translated">'应为 "On"。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExpectedEquals">
        <source>'Equals' expected.</source>
        <target state="translated">'应为“Equals”。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExpectedAnd">
        <source>'And' expected.</source>
        <target state="translated">'应为 "And"。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_EqualsTypeMismatch">
        <source>'Equals' cannot compare a value of type '{0}' with a value of type '{1}'.</source>
        <target state="translated">'“Equals”不能对类型为“{0}”的值与类型“{1}”的值进行比较。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_EqualsOperandIsBad">
        <source>You must reference at least one range variable on both sides of the 'Equals' operator. Range variable(s) {0} must appear on one side of the 'Equals' operator, and range variable(s) {1} must appear on the other.</source>
        <target state="translated">“Equals”运算符的每一侧都必须至少引用一个范围变量。范围变量 {0} 必须出现在“Equals”运算符的一侧，范围变量 {1} 必须出现在另一侧。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_LambdaNotDelegate1">
        <source>Lambda expression cannot be converted to '{0}' because '{0}' is not a delegate type.</source>
        <target state="translated">Lambda 表达式无法转换为“{0}”，因为“{0}”不是委托类型。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_LambdaNotCreatableDelegate1">
        <source>Lambda expression cannot be converted to '{0}' because type '{0}' is declared 'MustInherit' and cannot be created.</source>
        <target state="translated">Lambda 表达式无法转换为“{0}”，因为类型“{0}”被声明为“MustInherit”，无法创建。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CannotInferNullableForVariable1">
        <source>A nullable type cannot be inferred for variable '{0}'.</source>
        <target state="translated">对于变量“{0}”不能推断可以为 null 的类型。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NullableTypeInferenceNotSupported">
        <source>Nullable type inference is not supported in this context.</source>
        <target state="translated">在该上下文中不支持可以为 null 的类型推理。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExpectedJoin">
        <source>'Join' expected.</source>
        <target state="translated">'应为“Join”。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NullableParameterMustSpecifyType">
        <source>Nullable parameters must specify a type.</source>
        <target state="translated">可以为 null 的参数必须指定一个类型。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_IterationVariableShadowLocal2">
        <source>Range variable '{0}' hides a variable in an enclosing block, a previously defined range variable, or an implicitly declared variable in a query expression.</source>
        <target state="translated">范围变量“{0}”隐藏封闭块中的某个变量、以前定义的某个范围变量或者在查询表达式中隐式声明的某个变量。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_LambdasCannotHaveAttributes">
        <source>Attributes cannot be applied to parameters of lambda expressions.</source>
        <target state="translated">特性不能应用于 lambda 表达式的参数。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_LambdaInSelectCaseExpr">
        <source>Lambda expressions are not valid in the first expression of a 'Select Case' statement.</source>
        <target state="translated">Lambda 表达式在 "Select Case" 语句的第一个表达式中无效。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AddressOfInSelectCaseExpr">
        <source>'AddressOf' expressions are not valid in the first expression of a 'Select Case' statement.</source>
        <target state="translated">'“AddressOf”表达式在“Select Case”语句的第一个表达式中无效。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NullableCharNotSupported">
        <source>The '?' character cannot be used here.</source>
        <target state="translated">此处不能使用 "?" 字符。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CannotLiftStructureMeLambda">
        <source>Instance members and 'Me' cannot be used within a lambda expression in structures.</source>
        <target state="translated">无法在结构中的 lambda 表达式内使用实例成员和“Me”。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CannotLiftByRefParamLambda1">
        <source>'ByRef' parameter '{0}' cannot be used in a lambda expression.</source>
        <target state="translated">'不能在 lambda 表达式中使用“ByRef”参数“{0}”。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CannotLiftRestrictedTypeLambda">
        <source>Instance of restricted type '{0}' cannot be used in a lambda expression.</source>
        <target state="translated">不能在 lambda 表达式中使用受限类型“{0}”的实例。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_LambdaParamShadowLocal1">
        <source>Lambda parameter '{0}' hides a variable in an enclosing block, a previously defined range variable, or an implicitly declared variable in a query expression.</source>
        <target state="translated">Lambda 参数“{0}”隐藏封闭块中的某个变量、以前定义的某个范围变量或者在查询表达式中隐式声明的某个变量。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_StrictDisallowImplicitObjectLambda">
        <source>Option Strict On requires each lambda expression parameter to be declared with an 'As' clause if its type cannot be inferred.</source>
        <target state="translated">Option Strict On 要求使用 "As" 子句来声明其类型无法推断的每个 lambda 表达式参数。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CantSpecifyParamsOnLambdaParamNoType">
        <source>Array modifiers cannot be specified on lambda expression parameter name. They must be specified on its type.</source>
        <target state="translated">不能在 lambda 表达式的参数名中指定数组修饰符。数组修饰符必须在其类型中指定。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_TypeInferenceFailure1">
        <source>Data type(s) of the type parameter(s) cannot be inferred from these arguments. Specifying the data type(s) explicitly might correct this error.</source>
        <target state="translated">无法从这些实参推断类型形参的数据类型。显式指定该数据类型可更正此错误。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_TypeInferenceFailure2">
        <source>Data type(s) of the type parameter(s) in method '{0}' cannot be inferred from these arguments. Specifying the data type(s) explicitly might correct this error.</source>
        <target state="translated">无法从这些实参推断方法“{0}”中类型形参的数据类型。显式指定数据类型可更正此错误。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_TypeInferenceFailure3">
        <source>Data type(s) of the type parameter(s) in extension method '{0}' defined in '{1}' cannot be inferred from these arguments. Specifying the data type(s) explicitly might correct this error.</source>
        <target state="translated">无法从这些实参推断“{1}”中定义的扩展方法“{0}”中类型形参的数据类型。显式指定数据类型可更正此错误。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_TypeInferenceFailureNoExplicit1">
        <source>Data type(s) of the type parameter(s) cannot be inferred from these arguments.</source>
        <target state="translated">无法从这些实参推断类型形参的数据类型。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_TypeInferenceFailureNoExplicit2">
        <source>Data type(s) of the type parameter(s) in method '{0}' cannot be inferred from these arguments.</source>
        <target state="translated">无法从这些实参推断方法“{0}”中类型形参的数据类型。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_TypeInferenceFailureNoExplicit3">
        <source>Data type(s) of the type parameter(s) in extension method '{0}' defined in '{1}' cannot be inferred from these arguments.</source>
        <target state="translated">无法从这些实参推断“{1}”中定义的扩展方法“{0}”中类型形参的数据类型。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_TypeInferenceFailureAmbiguous1">
        <source>Data type(s) of the type parameter(s) cannot be inferred from these arguments because more than one type is possible. Specifying the data type(s) explicitly might correct this error.</source>
        <target state="translated">无法从这些实参推断类型形参的数据类型，因为可能会存在多个类型。显式指定数据类型可更正此错误。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_TypeInferenceFailureAmbiguous2">
        <source>Data type(s) of the type parameter(s) in method '{0}' cannot be inferred from these arguments because more than one type is possible. Specifying the data type(s) explicitly might correct this error.</source>
        <target state="translated">无法从这些实参推断方法“{0}”中类型形参的数据类型，因为可能会存在多个类型。显式指定数据类型可更正此错误。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_TypeInferenceFailureAmbiguous3">
        <source>Data type(s) of the type parameter(s) in extension method '{0}' defined in '{1}' cannot be inferred from these arguments because more than one type is possible. Specifying the data type(s) explicitly might correct this error.</source>
        <target state="translated">无法从这些实参推断“{0}”中定义的扩展方法“{1}”中类型形参的数据类型，因为可能会存在多个类型。显式指定数据类型可更正此错误。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_TypeInferenceFailureNoExplicitAmbiguous1">
        <source>Data type(s) of the type parameter(s) cannot be inferred from these arguments because more than one type is possible.</source>
        <target state="translated">无法从这些实参推断类型形参的数据类型，因为可能会存在多个类型。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_TypeInferenceFailureNoExplicitAmbiguous2">
        <source>Data type(s) of the type parameter(s) in method '{0}' cannot be inferred from these arguments because more than one type is possible.</source>
        <target state="translated">无法从这些实参推断方法“{0}”中类型形参的数据类型，因为可能会存在多个类型。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_TypeInferenceFailureNoExplicitAmbiguous3">
        <source>Data type(s) of the type parameter(s) in extension method '{0}' defined in '{1}' cannot be inferred from these arguments because more than one type is possible.</source>
        <target state="translated">无法从这些实参推断“{0}”中定义的扩展方法“{1}”中类型形参的数据类型，因为可能会存在多个类型。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_TypeInferenceFailureNoBest1">
        <source>Data type(s) of the type parameter(s) cannot be inferred from these arguments because they do not convert to the same type. Specifying the data type(s) explicitly might correct this error.</source>
        <target state="translated">无法从这些实参推断类型形参的数据类型，因为这些数据类型不会转换为同一类型。显式指定数据类型可更正此错误。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_TypeInferenceFailureNoBest2">
        <source>Data type(s) of the type parameter(s) in method '{0}' cannot be inferred from these arguments because they do not convert to the same type. Specifying the data type(s) explicitly might correct this error.</source>
        <target state="translated">无法从这些实参推断方法“{0}”中类型形参的数据类型，因为这些数据类型不会转换为同一类型。显式指定数据类型可更正此错误。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_TypeInferenceFailureNoBest3">
        <source>Data type(s) of the type parameter(s) in extension method '{0}' defined in '{1}' cannot be inferred from these arguments because they do not convert to the same type. Specifying the data type(s) explicitly might correct this error.</source>
        <target state="translated">无法从这些实参推断“{1}”中定义的扩展方法“{0}”中类型形参的数据类型，因为这些数据类型不会转换为同一类型。显式指定数据类型可更正此错误。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_TypeInferenceFailureNoExplicitNoBest1">
        <source>Data type(s) of the type parameter(s) cannot be inferred from these arguments because they do not convert to the same type.</source>
        <target state="translated">无法从这些实参推断类型形参的数据类型，因为这些数据类型不会转换为同一类型。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_TypeInferenceFailureNoExplicitNoBest2">
        <source>Data type(s) of the type parameter(s) in method '{0}' cannot be inferred from these arguments because they do not convert to the same type.</source>
        <target state="translated">无法从这些实参推断方法“{0}”中类型形参的数据类型，因为这些数据类型不会转换为同一类型。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_TypeInferenceFailureNoExplicitNoBest3">
        <source>Data type(s) of the type parameter(s) in extension method '{0}' defined in '{1}' cannot be inferred from these arguments because they do not convert to the same type.</source>
        <target state="translated">无法从这些实参推断“{1}”中定义的扩展方法“{0}”中类型形参的数据类型，因为这些数据类型不会转换为同一类型。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DelegateBindingMismatchStrictOff2">
        <source>Option Strict On does not allow narrowing in implicit type conversions between method '{0}' and delegate '{1}'.</source>
        <target state="translated">Option Strict On 不允许对方法“{0}”和委托“{1}”之间的隐式类型转换进行收缩。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InaccessibleReturnTypeOfMember2">
        <source>'{0}' is not accessible in this context because the return type is not accessible.</source>
        <target state="translated">'“{0}”是不可访问的返回类型，因此它在此上下文中不可访问。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExpectedIdentifierOrGroup">
        <source>'Group' or an identifier expected.</source>
        <target state="translated">'应为“Group”或标识符。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_UnexpectedGroup">
        <source>'Group' not allowed in this context; identifier expected.</source>
        <target state="translated">'此上下文中不允许 "Group"；应为标识符。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DelegateBindingMismatchStrictOff3">
        <source>Option Strict On does not allow narrowing in implicit type conversions between extension method '{0}' defined in '{2}' and delegate '{1}'.</source>
        <target state="translated">Option Strict On 不允许对“{2}”中定义的扩展方法“{0}”和委托“{1}”之间的隐式类型转换进行收缩。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DelegateBindingIncompatible3">
        <source>Extension Method '{0}' defined in '{2}' does not have a signature compatible with delegate '{1}'.</source>
        <target state="translated">“{2}”中定义的扩展方法“{0}”没有与委托“{1}”兼容的签名。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ArgumentNarrowing2">
        <source>Argument matching parameter '{0}' narrows to '{1}'.</source>
        <target state="translated">与形参“{0}”匹配的实参收缩到“{1}”。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_OverloadCandidate1">
        <source>
    {0}</source>
        <target state="translated">
  {0}</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AutoPropertyInitializedInStructure">
        <source>Auto-implemented Properties contained in Structures cannot have initializers unless they are marked 'Shared'.</source>
        <target state="translated">如果没有将结构中包含的自动实现的属性标记为 "Shared"，这些属性就不能有初始值设定项。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_TypeDisallowsElements">
        <source>XML elements cannot be selected from type '{0}'.</source>
        <target state="translated">XML 元素不能从类型“{0}”中选择。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_TypeDisallowsAttributes">
        <source>XML attributes cannot be selected from type '{0}'.</source>
        <target state="translated">XML 特性不能从类型“{0}”中选择。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_TypeDisallowsDescendants">
        <source>XML descendant elements cannot be selected from type '{0}'.</source>
        <target state="translated">XML 子代元素不能从类型“{0}”中选择。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_TypeOrMemberNotGeneric2">
        <source>Extension method '{0}' defined in '{1}' is not generic (or has no free type parameters) and so cannot have type arguments.</source>
        <target state="translated">“{1}”中定义的扩展方法“{0}”不是泛型方法(或没有可用的类型形参)，因此无法拥有类型实参。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExtensionMethodCannotBeLateBound">
        <source>Late-bound extension methods are not supported.</source>
        <target state="translated">不支持后期绑定的扩展方法。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_TypeInferenceArrayRankMismatch1">
        <source>Cannot infer a data type for '{0}' because the array dimensions do not match.</source>
        <target state="translated">无法推断“{0}”的数据类型，因为数组维数不匹配。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_QueryStrictDisallowImplicitObject">
        <source>Type of the range variable cannot be inferred, and late binding is not allowed with Option Strict on. Use an 'As' clause to specify the type.</source>
        <target state="translated">无法推断范围变量的类型，且 Option Strict on 不允许后期绑定。请使用“As”子句来指定类型。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CannotEmbedInterfaceWithGeneric">
        <source>Type '{0}' cannot be embedded because it has generic argument. Consider disabling the embedding of interop types.</source>
        <target state="translated">无法嵌入类型“{0}”，因为它有泛型参数。请考虑禁用互操作类型嵌入。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CannotUseGenericTypeAcrossAssemblyBoundaries">
        <source>Type '{0}' cannot be used across assembly boundaries because it has a generic type argument that is an embedded interop type.</source>
        <target state="translated">无法跨程序集边界使用类型“{0}”，因为它有身为嵌入的互操作类型的泛型类型参数。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UseOfObsoleteSymbol2">
        <source>'{0}' is obsolete: '{1}'.</source>
        <target state="translated">'“{0}”已过时:“{1}”。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UseOfObsoleteSymbol2_Title">
        <source>Type or member is obsolete</source>
        <target state="translated">类型或成员已过时</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_MustOverloadBase4">
        <source>{0} '{1}' shadows an overloadable member declared in the base {2} '{3}'.  If you want to overload the base method, this method must be declared 'Overloads'.</source>
        <target state="translated">{0}“{1}”隐藏在基 {2}“{3}”中声明的可重载的成员。如果要重载基方法，则此方法必须声明为“Overloads”。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_MustOverloadBase4_Title">
        <source>Member shadows an overloadable member declared in the base type</source>
        <target state="translated">成员隐藏在基类型中声明的可重载的成员</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_OverrideType5">
        <source>{0} '{1}' conflicts with {2} '{1}' in the base {3} '{4}' and should be declared 'Shadows'.</source>
        <target state="translated">{0}“{1}”与基 {3}“{4}”中的 {2}“{1}”冲突，应该声明为“Shadows”。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_OverrideType5_Title">
        <source>Member conflicts with member in the base type and should be declared 'Shadows'</source>
        <target state="translated">成员与基类型中的成员发生冲突，因此应声明为 "Shadows"</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_MustOverride2">
        <source>{0} '{1}' shadows an overridable method in the base {2} '{3}'. To override the base method, this method must be declared 'Overrides'.</source>
        <target state="translated">{0}“{1}”隐藏基 {2}“{3}”中的可重写方法。若要重写基方法，必须将此方法声明为“Overrides”。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_MustOverride2_Title">
        <source>Member shadows an overridable method in the base type</source>
        <target state="translated">成员隐藏基类型中的可重写的方法</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_DefaultnessShadowed4">
        <source>Default property '{0}' conflicts with the default property '{1}' in the base {2} '{3}'. '{0}' will be the default property. '{0}' should be declared 'Shadows'.</source>
        <target state="translated">默认属性“{0}”与基 {2}“{3}”中的默认属性“{1}”冲突。“{0}”将成为默认属性。“{0}”应声明为“Shadows”。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_DefaultnessShadowed4_Title">
        <source>Default property conflicts with the default property in the base type</source>
        <target state="translated">默认属性与基类型中的默认属性发生冲突</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UseOfObsoleteSymbolNoMessage1">
        <source>'{0}' is obsolete.</source>
        <target state="translated">'“{0}”已过时。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UseOfObsoleteSymbolNoMessage1_Title">
        <source>Type or member is obsolete</source>
        <target state="translated">类型或成员已过时</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_AssemblyGeneration0">
        <source>Possible problem detected while building assembly: {0}</source>
        <target state="translated">生成程序集时检测到可能存在的问题: {0}</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_AssemblyGeneration0_Title">
        <source>Possible problem detected while building assembly</source>
        <target state="translated">生成程序集时检测到可能的问题</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_AssemblyGeneration1">
        <source>Possible problem detected while building assembly '{0}': {1}</source>
        <target state="translated">生成程序集“{0}”时检测到可能存在的问题: {1}</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_AssemblyGeneration1_Title">
        <source>Possible problem detected while building assembly</source>
        <target state="translated">生成程序集时检测到可能的问题</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_ComClassNoMembers1">
        <source>'Microsoft.VisualBasic.ComClassAttribute' is specified for class '{0}' but '{0}' has no public members that can be exposed to COM; therefore, no COM interfaces are generated.</source>
        <target state="translated">'为类“{0}”指定了“Microsoft.VisualBasic.ComClassAttribute”，但“{0}”没有可以向 COM 公开的公共成员；因此不生成 COM 接口。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_ComClassNoMembers1_Title">
        <source>'Microsoft.VisualBasic.ComClassAttribute' is specified for class but class has no public members that can be exposed to COM</source>
        <target state="translated">'为类指定了 "Microsoft.VisualBasic.ComClassAttribute"，但类没有可向 COM 公开的公共成员</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_SynthMemberShadowsMember5">
        <source>{0} '{1}' implicitly declares '{2}', which conflicts with a member in the base {3} '{4}', and so the {0} should be declared 'Shadows'.</source>
        <target state="translated">{0}“{1}”隐式声明的“{2}”与基 {3}“{4}”中的成员冲突，因此应将 {0} 声明为“Shadows”。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_SynthMemberShadowsMember5_Title">
        <source>Property or event implicitly declares type or member that conflicts with a member in the base type</source>
        <target state="translated">属性或事件隐式声明与基类型中的成员发生冲突的类型或成员</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_MemberShadowsSynthMember6">
        <source>{0} '{1}' conflicts with a member implicitly declared for {2} '{3}' in the base {4} '{5}' and should be declared 'Shadows'.</source>
        <target state="translated">{0}“{1}”与为基 {4}“{5}”中 {2}“{3}”隐式声明的成员冲突，应将它声明为“Shadows”。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_MemberShadowsSynthMember6_Title">
        <source>Member conflicts with a member implicitly declared for property or event in the base type</source>
        <target state="translated">成员与为基类型中的属性或事件隐式声明的成员冲突</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_SynthMemberShadowsSynthMember7">
        <source>{0} '{1}' implicitly declares '{2}', which conflicts with a member implicitly declared for {3} '{4}' in the base {5} '{6}'. {0} should be declared 'Shadows'.</source>
        <target state="translated">{0}“{1}”隐式声明的“{2}”与为基 {5}“{6}”中的 {3}“{4}”隐式声明的成员冲突。{0} 应声明为“Shadows”。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_SynthMemberShadowsSynthMember7_Title">
        <source>Property or event implicitly declares member, which conflicts with a member implicitly declared for property or event in the base type</source>
        <target state="translated">属性或事件隐式声明与为基类型中的属性或事件隐式声明的成员发生冲突的成员</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UseOfObsoletePropertyAccessor3">
        <source>'{0}' accessor of '{1}' is obsolete: '{2}'.</source>
        <target state="translated">'“{1}”的“{0}”访问器已过时:“{2}”。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UseOfObsoletePropertyAccessor3_Title">
        <source>Property accessor is obsolete</source>
        <target state="translated">属性访问器已过时</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UseOfObsoletePropertyAccessor2">
        <source>'{0}' accessor of '{1}' is obsolete.</source>
        <target state="translated">'“{1}”的“{0}”访问器已过时。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UseOfObsoletePropertyAccessor2_Title">
        <source>Property accessor is obsolete</source>
        <target state="translated">属性访问器已过时</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_FieldNotCLSCompliant1">
        <source>Type of member '{0}' is not CLS-compliant.</source>
        <target state="translated">成员“{0}”的类型不符合 CLS。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_FieldNotCLSCompliant1_Title">
        <source>Type of member is not CLS-compliant</source>
        <target state="translated">成员的类型不符合 CLS</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_BaseClassNotCLSCompliant2">
        <source>'{0}' is not CLS-compliant because it derives from '{1}', which is not CLS-compliant.</source>
        <target state="translated">'“{0}”不符合 CLS，因为它是从不符合 CLS 的“{1}”派生的。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_BaseClassNotCLSCompliant2_Title">
        <source>Type is not CLS-compliant because it derives from base type that is not CLS-compliant</source>
        <target state="translated">类型不符合 CLS，原因是它从不符合 CLS 的基类型派生</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_ProcTypeNotCLSCompliant1">
        <source>Return type of function '{0}' is not CLS-compliant.</source>
        <target state="translated">函数“{0}”的返回类型不符合 CLS。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_ProcTypeNotCLSCompliant1_Title">
        <source>Return type of function is not CLS-compliant</source>
        <target state="translated">函数的返回类型不符合 CLS</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_ParamNotCLSCompliant1">
        <source>Type of parameter '{0}' is not CLS-compliant.</source>
        <target state="translated">参数“{0}”的类型不符合 CLS。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_ParamNotCLSCompliant1_Title">
        <source>Type of parameter is not CLS-compliant</source>
        <target state="translated">参数的类型不符合 CLS</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_InheritedInterfaceNotCLSCompliant2">
        <source>'{0}' is not CLS-compliant because the interface '{1}' it inherits from is not CLS-compliant.</source>
        <target state="translated">'“{0}”不符合 CLS，因为它所继承的接口“{1}”不符合 CLS。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_InheritedInterfaceNotCLSCompliant2_Title">
        <source>Type is not CLS-compliant because the interface it inherits from is not CLS-compliant</source>
        <target state="translated">类型不符合 CLS，原因是它继承自的接口不符合 CLS</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CLSMemberInNonCLSType3">
        <source>{0} '{1}' cannot be marked CLS-compliant because its containing type '{2}' is not CLS-compliant.</source>
        <target state="translated">{0}“{1}”不能被标记为符合 CLS，因为它的包含类型“{2}”不符合 CLS。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CLSMemberInNonCLSType3_Title">
        <source>Member cannot be marked CLS-compliant because its containing type is not CLS-compliant</source>
        <target state="translated">无法将成员标记为符合 CLS，原因是它的包含类型不符合 CLS</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NameNotCLSCompliant1">
        <source>Name '{0}' is not CLS-compliant.</source>
        <target state="translated">名称“{0}”不符合 CLS。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NameNotCLSCompliant1_Title">
        <source>Name is not CLS-compliant</source>
        <target state="translated">名称不符合 CLS</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_EnumUnderlyingTypeNotCLS1">
        <source>Underlying type '{0}' of Enum is not CLS-compliant.</source>
        <target state="translated">枚举的基础类型“{0}”不符合 CLS。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_EnumUnderlyingTypeNotCLS1_Title">
        <source>Underlying type of Enum is not CLS-compliant</source>
        <target state="translated">枚举的基础类型不符合 CLS</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NonCLSMemberInCLSInterface1">
        <source>Non CLS-compliant '{0}' is not allowed in a CLS-compliant interface.</source>
        <target state="translated">在符合 CLS 的接口中不允许出现不符合 CLS 的“{0}”。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NonCLSMemberInCLSInterface1_Title">
        <source>Non CLS-compliant member is not allowed in a CLS-compliant interface</source>
        <target state="translated">在符合 CLS 的接口中不允许出现不符合 CLS 的成员</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NonCLSMustOverrideInCLSType1">
        <source>Non CLS-compliant 'MustOverride' member is not allowed in CLS-compliant type '{0}'.</source>
        <target state="translated">在符合 CLS 的类型“{0}”中不允许出现不符合 CLS 的 "MustOverride" 成员。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NonCLSMustOverrideInCLSType1_Title">
        <source>Non CLS-compliant 'MustOverride' member is not allowed in CLS-compliant type</source>
        <target state="translated">在符合 CLS 的类型中不允许出现不符合 CLS 的 "Mustoverride" 成员</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_ArrayOverloadsNonCLS2">
        <source>'{0}' is not CLS-compliant because it overloads '{1}' which differs from it only by array of array parameter types or by the rank of the array parameter types.</source>
        <target state="translated">'“{0}”不符合 CLS，因为它重载仅在数组参数类型的数组或数组参数类型的秩方面与它不同的“{1}”。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_ArrayOverloadsNonCLS2_Title">
        <source>Method is not CLS-compliant because it overloads method which differs from it only by array of array parameter types or by the rank of the array parameter types</source>
        <target state="translated">方法不符合 CLS，因为它重载仅在数组参数类型的数组或数组参数类型的秩方面与它不同的方法</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_RootNamespaceNotCLSCompliant1">
        <source>Root namespace '{0}' is not CLS-compliant.</source>
        <target state="translated">根命名空间“{0}”不符合 CLS。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_RootNamespaceNotCLSCompliant1_Title">
        <source>Root namespace is not CLS-compliant</source>
        <target state="translated">根命名空间不符合 CLS</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_RootNamespaceNotCLSCompliant2">
        <source>Name '{0}' in the root namespace '{1}' is not CLS-compliant.</source>
        <target state="translated">根命名空间“{1}”中的名称“{0}”不符合 CLS。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_RootNamespaceNotCLSCompliant2_Title">
        <source>Part of the root namespace is not CLS-compliant</source>
        <target state="translated">根命名空间的一部分不符合 CLS</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_GenericConstraintNotCLSCompliant1">
        <source>Generic parameter constraint type '{0}' is not CLS-compliant.</source>
        <target state="translated">泛型形参约束类型“{0}”不符合 CLS。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_GenericConstraintNotCLSCompliant1_Title">
        <source>Generic parameter constraint type is not CLS-compliant</source>
        <target state="translated">泛型参数约束类型不符合 CLS</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_TypeNotCLSCompliant1">
        <source>Type '{0}' is not CLS-compliant.</source>
        <target state="translated">类型“{0}”不符合 CLS。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_TypeNotCLSCompliant1_Title">
        <source>Type is not CLS-compliant</source>
        <target state="translated">类型不符合 CLS</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_OptionalValueNotCLSCompliant1">
        <source>Type of optional value for optional parameter '{0}' is not CLS-compliant.</source>
        <target state="translated">可选参数“{0}”的可选值的类型不符合 CLS。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_OptionalValueNotCLSCompliant1_Title">
        <source>Type of optional value for optional parameter is not CLS-compliant</source>
        <target state="translated">可选参数的可选值类型不符合 CLS</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CLSAttrInvalidOnGetSet">
        <source>System.CLSCompliantAttribute cannot be applied to property 'Get' or 'Set'.</source>
        <target state="translated">System.CLSCompliantAttribute 不能应用于属性 "Get" 或 "Set"。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CLSAttrInvalidOnGetSet_Title">
        <source>System.CLSCompliantAttribute cannot be applied to property 'Get' or 'Set'</source>
        <target state="translated">System.CLSCompliantAttribute 不能应用于属性 "Get" 或 "Set"</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_TypeConflictButMerged6">
        <source>{0} '{1}' and partial {2} '{3}' conflict in {4} '{5}', but are being merged because one of them is declared partial.</source>
        <target state="translated">{0}“{1}”和分部 {2}“{3}”在 {4}“{5}”中冲突，但由于其中的一个被声明为 Partial，因此正在合并。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_TypeConflictButMerged6_Title">
        <source>Type and partial type conflict, but are being merged because one of them is declared partial</source>
        <target state="translated">类型和分部类型冲突，但由于其中一个被声明为 Partial，因此正在合并</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_ShadowingGenericParamWithParam1">
        <source>Type parameter '{0}' has the same name as a type parameter of an enclosing type. Enclosing type's type parameter will be shadowed.</source>
        <target state="translated">类型参数“{0}”与封闭类型的类型参数同名。封闭类型的类型参数将被隐藏。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_ShadowingGenericParamWithParam1_Title">
        <source>Type parameter has the same name as a type parameter of an enclosing type</source>
        <target state="translated">类型参数与封闭类型的类型参数具有相同的名称</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CannotFindStandardLibrary1">
        <source>Could not find standard library '{0}'.</source>
        <target state="translated">未能找到标准库“{0}”。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CannotFindStandardLibrary1_Title">
        <source>Could not find standard library</source>
        <target state="translated">找不到标准库</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_EventDelegateTypeNotCLSCompliant2">
        <source>Delegate type '{0}' of event '{1}' is not CLS-compliant.</source>
        <target state="translated">事件“{1}”的委托类型“{0}”不符合 CLS。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_EventDelegateTypeNotCLSCompliant2_Title">
        <source>Delegate type of event is not CLS-compliant</source>
        <target state="translated">事件的委托类型不符合 CLS</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_DebuggerHiddenIgnoredOnProperties">
        <source>System.Diagnostics.DebuggerHiddenAttribute does not affect 'Get' or 'Set' when applied to the Property definition.  Apply the attribute directly to the 'Get' and 'Set' procedures as appropriate.</source>
        <target state="translated">System.Diagnostics.DebuggerHiddenAttribute 在应用于属性定义时不影响“Get”或“Set”。请根据相应的情况，将此特性直接应用于“Get”和“Set”过程。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_DebuggerHiddenIgnoredOnProperties_Title">
        <source>System.Diagnostics.DebuggerHiddenAttribute does not affect 'Get' or 'Set' when applied to the Property definition</source>
        <target state="translated">在应用到属性定义时，System.Diagnostics.DebuggerHiddenAttribute 不影响 "Get" 或 "Set"</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_SelectCaseInvalidRange">
        <source>Range specified for 'Case' statement is not valid. Make sure that the lower bound is less than or equal to the upper bound.</source>
        <target state="translated">为 "Case" 语句指定的范围无效。请确保下限小于或等于上限。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_SelectCaseInvalidRange_Title">
        <source>Range specified for 'Case' statement is not valid</source>
        <target state="translated">为 "Case" 语句指定的范围无效</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CLSEventMethodInNonCLSType3">
        <source>'{0}' method for event '{1}' cannot be marked CLS compliant because its containing type '{2}' is not CLS compliant.</source>
        <target state="translated">'事件“{1}”的“{0}”方法不能被标记为符合 CLS，因为它的包含类型“{2}”不符合 CLS。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CLSEventMethodInNonCLSType3_Title">
        <source>AddHandler or RemoveHandler method for event cannot be marked CLS compliant because its containing type is not CLS compliant</source>
        <target state="translated">事件的 AddHandler 方法或 RemoveHandler 方法无法标记为符合 CLS，原因是它的包含类型不符合 CLS</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_ExpectedInitComponentCall2">
        <source>'{0}' in designer-generated type '{1}' should call InitializeComponent method.</source>
        <target state="translated">'设计器生成的类型“{1}”中的“{0}”应调用 InitializeComponent 方法。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_ExpectedInitComponentCall2_Title">
        <source>Constructor in designer-generated type should call InitializeComponent method</source>
        <target state="translated">设计器生成的类型中的构造函数应调用 InitializeComponent 方法</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NamespaceCaseMismatch3">
        <source>Casing of namespace name '{0}' does not match casing of namespace name '{1}' in '{2}'.</source>
        <target state="translated">命名空间名“{0}”的大小写与“{2}”中命名空间名“{1}”的大小写不匹配。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NamespaceCaseMismatch3_Title">
        <source>Casing of namespace name does not match</source>
        <target state="translated">命名空间名称的大小写不匹配</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UndefinedOrEmptyNamespaceOrClass1">
        <source>Namespace or type specified in the Imports '{0}' doesn't contain any public member or cannot be found. Make sure the namespace or the type is defined and contains at least one public member. Make sure the imported element name doesn't use any aliases.</source>
        <target state="translated">Imports“{0}”中指定的命名空间或类型不包含任何公共成员，或者找不到该命名空间或类型。确保定义了该命名空间或类型且其中至少包含一个公共成员。确保导入的元素名不使用任何别名。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UndefinedOrEmptyNamespaceOrClass1_Title">
        <source>Namespace or type specified in Imports statement doesn't contain any public member or cannot be found</source>
        <target state="translated">在 Imports 语句中指定的命名空间或类型不包含任何公共成员或找不到公共成员</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UndefinedOrEmptyProjectNamespaceOrClass1">
        <source>Namespace or type specified in the project-level Imports '{0}' doesn't contain any public member or cannot be found. Make sure the namespace or the type is defined and contains at least one public member. Make sure the imported element name doesn't use any aliases.</source>
        <target state="translated">项目级 Imports“{0}”中指定的命名空间或类型不包含任何公共成员，或者找不到公共成员。要确保定义了该命名空间或类型且其中至少包含一个公共成员；还要确保导入的元素名不使用任何别名。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UndefinedOrEmptyProjectNamespaceOrClass1_Title">
        <source>Namespace or type imported at project level doesn't contain any public member or cannot be found</source>
        <target state="translated">在项目级别导入的命名空间或类型不包含任何公共成员或找不到公共成员</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_IndirectRefToLinkedAssembly2">
        <source>A reference was created to embedded interop assembly '{0}' because of an indirect reference to that assembly from assembly '{1}'. Consider changing the 'Embed Interop Types' property on either assembly.</source>
        <target state="translated">已创建对嵌入的互操作程序集“{0}”的引用，因为程序集“{1}”间接引用了该程序集。请考虑更改其中一个程序集的“嵌入互操作类型”属性。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_IndirectRefToLinkedAssembly2_Title">
        <source>A reference was created to embedded interop assembly because of an indirect reference to that assembly</source>
        <target state="translated">已创建对嵌入的互操作程序集的引用，因为间接引用了该程序集</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NoNonObsoleteConstructorOnBase3">
        <source>Class '{0}' should declare a 'Sub New' because the '{1}' in its base class '{2}' is marked obsolete.</source>
        <target state="translated">类“{0}”应该声明一个“Sub New”，因为其基类“{2}”中的“{1}”被标记为已过时。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NoNonObsoleteConstructorOnBase3_Title">
        <source>Class should declare a 'Sub New' because the constructor in its base class is marked obsolete</source>
        <target state="translated">类应声明 "Sub New"，原因是它的基类中的构造函数被标记为已过时</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NoNonObsoleteConstructorOnBase4">
        <source>Class '{0}' should declare a 'Sub New' because the '{1}' in its base class '{2}' is marked obsolete: '{3}'.</source>
        <target state="translated">类“{0}”应该声明一个“Sub New”，因为其基类“{2}”中的“{1}”被标记为已过时:“{3}”。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NoNonObsoleteConstructorOnBase4_Title">
        <source>Class should declare a 'Sub New' because the constructor in its base class is marked obsolete</source>
        <target state="translated">类应声明 "Sub New"，原因是它的基类中的构造函数被标记为已过时</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_RequiredNonObsoleteNewCall3">
        <source>First statement of this 'Sub New' should be an explicit call to 'MyBase.New' or 'MyClass.New' because the '{0}' in the base class '{1}' of '{2}' is marked obsolete.</source>
        <target state="translated">此“Sub New”中的第一条语句应为对“MyBase.New”或“MyClass.New”的显式调用，因为“{2}”的基类“{1}”中的“{0}”被标记为已过时。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_RequiredNonObsoleteNewCall3_Title">
        <source>First statement of this 'Sub New' should be an explicit call to 'MyBase.New' or 'MyClass.New' because the constructor in the base class is marked obsolete</source>
        <target state="translated">此 "Sub New" 的第一条语句必须是对 "MyBase.New" 或 "MyClass.New" 的显式调用，原因是基类中的构造函数被标为已过时</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_RequiredNonObsoleteNewCall4">
        <source>First statement of this 'Sub New' should be an explicit call to 'MyBase.New' or 'MyClass.New' because the '{0}' in the base class '{1}' of '{2}' is marked obsolete: '{3}'</source>
        <target state="translated">此“Sub New”中的第一条语句应为对“MyBase.New”或“MyClass.New”的显式调用，因为“{2}”的基类“{1}”中的“{0}”被标记为已过时:“{3}”</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_RequiredNonObsoleteNewCall4_Title">
        <source>First statement of this 'Sub New' should be an explicit call to 'MyBase.New' or 'MyClass.New' because the constructor in the base class is marked obsolete</source>
        <target state="translated">此 "Sub New" 的第一条语句必须是对 "MyBase.New" 或 "MyClass.New" 的显式调用，原因是基类中的构造函数被标为已过时</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_MissingAsClauseinOperator">
        <source>Operator without an 'As' clause; type of Object assumed.</source>
        <target state="translated">运算符没有 "As" 子句；假定为 Object 类型。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_MissingAsClauseinOperator_Title">
        <source>Operator without an 'As' clause</source>
        <target state="translated">运算符没有 "As" 子句</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_ConstraintsFailedForInferredArgs2">
        <source>Type arguments inferred for method '{0}' result in the following warnings :{1}</source>
        <target state="translated">为方法“{0}”推断的类型参数导致以下警告:{1}</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_ConstraintsFailedForInferredArgs2_Title">
        <source>Type arguments inferred for method result in warnings</source>
        <target state="translated">为方法推断的类型参数导致警告</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_ConditionalNotValidOnFunction">
        <source>Attribute 'Conditional' is only valid on 'Sub' declarations.</source>
        <target state="translated">特性 "Conditional" 只在 "Sub" 声明中有效。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_ConditionalNotValidOnFunction_Title">
        <source>Attribute 'Conditional' is only valid on 'Sub' declarations</source>
        <target state="translated">特性 "Conditional" 只在 "Sub" 声明中有效</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UseSwitchInsteadOfAttribute">
        <source>Use command-line option '{0}' or appropriate project settings instead of '{1}'.</source>
        <target state="translated">请使用命令行选项“{0}”或适当的项目设置，而不是“{1}”。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UseSwitchInsteadOfAttribute_Title">
        <source>Use command-line option /keyfile, /keycontainer, or /delaysign instead of AssemblyKeyFileAttribute, AssemblyKeyNameAttribute, or AssemblyDelaySignAttribute</source>
        <target state="translated">使用命令行选项 /keyfile、/keycontainer 或 /delaysign，而不要使用 AssemblyKeyFileAttribute、AssemblyKeyNameAttribute 或 AssemblyDelaySignAttribute</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_RecursiveAddHandlerCall">
        <source>Statement recursively calls the containing '{0}' for event '{1}'.</source>
        <target state="translated">语句以递归方式调用事件“{1}”的包含“{0}”。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_RecursiveAddHandlerCall_Title">
        <source>Statement recursively calls the event's containing AddHandler</source>
        <target state="translated">语句递归调用事件包含的 AddHandler</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_ImplicitConversionCopyBack">
        <source>Implicit conversion from '{1}' to '{2}' in copying the value of 'ByRef' parameter '{0}' back to the matching argument.</source>
        <target state="translated">将“ByRef”形参“{0}”的值复制回匹配实参时，发生从“{1}”到“{2}”的隐式转换。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_ImplicitConversionCopyBack_Title">
        <source>Implicit conversion in copying the value of 'ByRef' parameter back to the matching argument</source>
        <target state="translated">在把 "ByRef" 参数的值复制回匹配参数的过程中进行隐式转换</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_MustShadowOnMultipleInheritance2">
        <source>{0} '{1}' conflicts with other members of the same name across the inheritance hierarchy and so should be declared 'Shadows'.</source>
        <target state="translated">{0}“{1}”与继承层次结构中的其他同名成员冲突，因此应声明为“Shadows”。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_MustShadowOnMultipleInheritance2_Title">
        <source>Method conflicts with other members of the same name across the inheritance hierarchy and so should be declared 'Shadows'</source>
        <target state="translated">方法与继承层次结构中的其他同名成员冲突，因此应声明为 "Shadows"</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_RecursiveOperatorCall">
        <source>Expression recursively calls the containing Operator '{0}'.</source>
        <target state="translated">表达式以递归方式调用包含运算符“{0}”。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_RecursiveOperatorCall_Title">
        <source>Expression recursively calls the containing Operator</source>
        <target state="translated">表达式递归调用包含运算符</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_ImplicitConversion2">
        <source>Implicit conversion from '{0}' to '{1}'.</source>
        <target state="translated">从“{0}”到“{1}”的隐式转换。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_ImplicitConversion2_Title">
        <source>Implicit conversion</source>
        <target state="translated">隐式转换</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_MutableStructureInUsing">
        <source>Local variable '{0}' is read-only and its type is a structure. Invoking its members or passing it ByRef does not change its content and might lead to unexpected results. Consider declaring this variable outside of the 'Using' block.</source>
        <target state="translated">局部变量“{0}”是只读的并且其类型是结构。调用此变量的成员或通过 ByRef 传递它不会更改其内容，并可能导致意外的错误。考虑在“Using”块之外声明此变量。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_MutableStructureInUsing_Title">
        <source>Local variable declared by Using statement is read-only and its type is a structure</source>
        <target state="translated">Using 语句声明的局部变量是只读的，它的类型是一种结构</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_MutableGenericStructureInUsing">
        <source>Local variable '{0}' is read-only. When its type is a structure, invoking its members or passing it ByRef does not change its content and might lead to unexpected results. Consider declaring this variable outside of the 'Using' block.</source>
        <target state="translated">局部变量“{0}”是只读的。其类型为结构时，调用其成员或使用 ByRef 传递该类型不会更改其内容，并可能会导致意外的结果。考虑在“Using”块之外声明此变量。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_MutableGenericStructureInUsing_Title">
        <source>Local variable declared by Using statement is read-only and its type may be a structure</source>
        <target state="translated">Using 语句声明的局部变量是只读的，它的类型可能是一种结构</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_ImplicitConversionSubst1">
        <source>{0}</source>
        <target state="translated">{0}</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_ImplicitConversionSubst1_Title">
        <source>Implicit conversion</source>
        <target state="translated">隐式转换</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_LateBindingResolution">
        <source>Late bound resolution; runtime errors could occur.</source>
        <target state="translated">后期绑定解决方案；可能会发生运行时错误。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_LateBindingResolution_Title">
        <source>Late bound resolution</source>
        <target state="translated">后期绑定解决方案</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_ObjectMath1">
        <source>Operands of type Object used for operator '{0}'; use the 'Is' operator to test object identity.</source>
        <target state="translated">对运算符“{0}”使用了 Object 类型的操作数；应使用“Is”运算符来测试对象标识。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_ObjectMath1_Title">
        <source>Operands of type Object used for operator</source>
        <target state="translated">为运算符使用的 Object 类型的操作数</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_ObjectMath2">
        <source>Operands of type Object used for operator '{0}'; runtime errors could occur.</source>
        <target state="translated">对运算符“{0}”使用了 Object 类型的操作数；可能会发生运行时错误。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_ObjectMath2_Title">
        <source>Operands of type Object used for operator</source>
        <target state="translated">为运算符使用的 Object 类型的操作数</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_ObjectAssumedVar1">
        <source>{0}</source>
        <target state="translated">{0}</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_ObjectAssumedVar1_Title">
        <source>Variable declaration without an 'As' clause</source>
        <target state="translated">变量声明没有 "As" 子句</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_ObjectAssumed1">
        <source>{0}</source>
        <target state="translated">{0}</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_ObjectAssumed1_Title">
        <source>Function without an 'As' clause</source>
        <target state="translated">函数没有 "As" 子句</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_ObjectAssumedProperty1">
        <source>{0}</source>
        <target state="translated">{0}</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_ObjectAssumedProperty1_Title">
        <source>Property without an 'As' clause</source>
        <target state="translated">属性没有 "As" 子句</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_MissingAsClauseinVarDecl">
        <source>Variable declaration without an 'As' clause; type of Object assumed.</source>
        <target state="translated">变量声明没有 "As" 子句；假定为 Object 类型。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_MissingAsClauseinVarDecl_Title">
        <source>Variable declaration without an 'As' clause</source>
        <target state="translated">变量声明没有 "As" 子句</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_MissingAsClauseinFunction">
        <source>Function without an 'As' clause; return type of Object assumed.</source>
        <target state="translated">函数没有 "As" 子句；假定返回类型为 Object。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_MissingAsClauseinFunction_Title">
        <source>Function without an 'As' clause</source>
        <target state="translated">函数没有 "As" 子句</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_MissingAsClauseinProperty">
        <source>Property without an 'As' clause; type of Object assumed.</source>
        <target state="translated">属性没有 "As" 子句；假定为 Object 类型。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_MissingAsClauseinProperty_Title">
        <source>Property without an 'As' clause</source>
        <target state="translated">属性没有 "As" 子句</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UnusedLocal">
        <source>Unused local variable: '{0}'.</source>
        <target state="translated">未使用的局部变量:“{0}”。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UnusedLocal_Title">
        <source>Unused local variable</source>
        <target state="translated">未使用的本地变量</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_SharedMemberThroughInstance">
        <source>Access of shared member, constant member, enum member or nested type through an instance; qualifying expression will not be evaluated.</source>
        <target state="translated">通过实例访问共享成员、常量成员、枚举成员或嵌套类型；将不计算限定表达式。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_SharedMemberThroughInstance_Title">
        <source>Access of shared member, constant member, enum member or nested type through an instance</source>
        <target state="translated">通过实例访问共享成员、常量成员、枚举成员或嵌套类型</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_RecursivePropertyCall">
        <source>Expression recursively calls the containing property '{0}'.</source>
        <target state="translated">表达式递归调用包含属性“{0}”。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_RecursivePropertyCall_Title">
        <source>Expression recursively calls the containing property</source>
        <target state="translated">表达式递归调用包含属性</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_OverlappingCatch">
        <source>'Catch' block never reached, because '{0}' inherits from '{1}'.</source>
        <target state="translated">'永远不会到达“Catch”块，因为“{0}”从“{1}”继承。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_OverlappingCatch_Title">
        <source>'Catch' block never reached; exception type's base type handled above in the same Try statement</source>
        <target state="translated">'永远不会到达 "Catch" 块；异常类型的基类型已在上面同一个 Try 语句中处理</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_DefAsgUseNullRefByRef">
        <source>Variable '{0}' is passed by reference before it has been assigned a value. A null reference exception could result at runtime.</source>
        <target state="translated">变量“{0}”在赋值前通过引用传递。可能会在运行时导致 null 引用异常。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_DefAsgUseNullRefByRef_Title">
        <source>Variable is passed by reference before it has been assigned a value</source>
        <target state="translated">在为变量赋值之前，变量已通过引用传递</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_DuplicateCatch">
        <source>'Catch' block never reached; '{0}' handled above in the same Try statement.</source>
        <target state="translated">'永远不会到达“Catch”块；“{0}”已在上面同一个 Try 语句中处理。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_DuplicateCatch_Title">
        <source>'Catch' block never reached; exception type handled above in the same Try statement</source>
        <target state="translated">'永远不会到达 "Catch" 块；异常类型已在上面同一个 Try 语句中处理</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_ObjectMath1Not">
        <source>Operands of type Object used for operator '{0}'; use the 'IsNot' operator to test object identity.</source>
        <target state="translated">对运算符“{0}”使用了 Object 类型的操作数；应使用“IsNot”运算符来测试对象标识。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_ObjectMath1Not_Title">
        <source>Operands of type Object used for operator &lt;&gt;</source>
        <target state="translated">为运算符 &lt;&gt; 使用的 Object 类型的操作数</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_BadChecksumValExtChecksum">
        <source>Bad checksum value, non hex digits or odd number of hex digits.</source>
        <target state="translated">错误的校验和值、非十六进制数字或奇数个十六进制数字。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_BadChecksumValExtChecksum_Title">
        <source>Bad checksum value, non hex digits or odd number of hex digits</source>
        <target state="translated">错误的校验和值、非十六进制数字或奇数个十六进制数字</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_MultipleDeclFileExtChecksum">
        <source>File name already declared with a different GUID and checksum value.</source>
        <target state="translated">已使用另一个 GUID 和校验和值声明了文件名。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_MultipleDeclFileExtChecksum_Title">
        <source>File name already declared with a different GUID and checksum value</source>
        <target state="translated">已使用另一个 GUID 和校验和值声明了文件名</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_BadGUIDFormatExtChecksum">
        <source>Bad GUID format.</source>
        <target state="translated">错误的 GUID 格式。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_BadGUIDFormatExtChecksum_Title">
        <source>Bad GUID format</source>
        <target state="translated">错误的 GUID 格式</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_ObjectMathSelectCase">
        <source>Operands of type Object used in expressions for 'Select', 'Case' statements; runtime errors could occur.</source>
        <target state="translated">在 "Select"、"Case" 语句的表达式中使用了 Object 类型的操作数；可能会发生运行时错误。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_ObjectMathSelectCase_Title">
        <source>Operands of type Object used in expressions for 'Select', 'Case' statements</source>
        <target state="translated">"Select"、"Case" 语句的表达式中使用的 Object 类型的操作数</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_EqualToLiteralNothing">
        <source>This expression will always evaluate to Nothing (due to null propagation from the equals operator). To check if the value is null consider using 'Is Nothing'.</source>
        <target state="translated">此表达式的计算结果始终为 Nothing (由于来自等于运算符的 null 传播)。若要检查值是否为 null，请考虑使用 "Is Nothing"。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_EqualToLiteralNothing_Title">
        <source>This expression will always evaluate to Nothing</source>
        <target state="translated">此表达式的计算结果始终为 Nothing</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NotEqualToLiteralNothing">
        <source>This expression will always evaluate to Nothing (due to null propagation from the equals operator). To check if the value is not null consider using 'IsNot Nothing'.</source>
        <target state="translated">此表达式的计算结果始终为 Nothing (由于来自等于运算符的 null 传播)。若要检查值是否不为 null，请考虑使用 "IsNot Nothing"。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NotEqualToLiteralNothing_Title">
        <source>This expression will always evaluate to Nothing</source>
        <target state="translated">此表达式的计算结果始终为 Nothing</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UnusedLocalConst">
        <source>Unused local constant: '{0}'.</source>
        <target state="translated">未使用的局部常量:“{0}”。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UnusedLocalConst_Title">
        <source>Unused local constant</source>
        <target state="translated">未使用的局部常量</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_ComClassInterfaceShadows5">
        <source>'Microsoft.VisualBasic.ComClassAttribute' on class '{0}' implicitly declares {1} '{2}', which conflicts with a member of the same name in {3} '{4}'. Use 'Microsoft.VisualBasic.ComClassAttribute(InterfaceShadows:=True)' if you want to hide the name on the base {4}.</source>
        <target state="translated">'类“{0}”上的“Microsoft.VisualBasic.ComClassAttribute”隐式声明的 {1}“{2}”与 {3}“{4}”中的同名成员冲突。如果要隐藏基 {4} 上的名称，请使用“Microsoft.VisualBasic.ComClassAttribute(InterfaceShadows:=True)”。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_ComClassInterfaceShadows5_Title">
        <source>'Microsoft.VisualBasic.ComClassAttribute' on class implicitly declares member, which conflicts with a member of the same name</source>
        <target state="translated">'类上的 "Microsoft.VisualBasic.ComClassAttribute" 隐式声明与同名成员发生冲突的成员</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_ComClassPropertySetObject1">
        <source>'{0}' cannot be exposed to COM as a property 'Let'. You will not be able to assign non-object values (such as numbers or strings) to this property from Visual Basic 6.0 using a 'Let' statement.</source>
        <target state="translated">'“{0}”无法作为属性“Let”向 COM 公开。将无法使用“Let”语句从 Visual Basic 6.0 向该属性分配非对象值(如数字或字符串)。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_ComClassPropertySetObject1_Title">
        <source>Property cannot be exposed to COM as a property 'Let'</source>
        <target state="translated">无法将属性作为 "Let" 属性向 COM 公开</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_DefAsgUseNullRef">
        <source>Variable '{0}' is used before it has been assigned a value. A null reference exception could result at runtime.</source>
        <target state="translated">变量“{0}”在赋值前被使用。可能会在运行时导致 null 引用异常。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_DefAsgUseNullRef_Title">
        <source>Variable is used before it has been assigned a value</source>
        <target state="translated">在为变量赋值之前，变量已被使用</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_DefAsgNoRetValFuncRef1">
        <source>Function '{0}' doesn't return a value on all code paths. A null reference exception could occur at run time when the result is used.</source>
        <target state="translated">函数“{0}”不会在所有代码路径上都返回值。当使用结果时，可能会在运行时发生 null 引用异常。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_DefAsgNoRetValFuncRef1_Title">
        <source>Function doesn't return a value on all code paths</source>
        <target state="translated">函数没有在所有代码路径上返回值</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_DefAsgNoRetValOpRef1">
        <source>Operator '{0}' doesn't return a value on all code paths. A null reference exception could occur at run time when the result is used.</source>
        <target state="translated">运算符“{0}”不会在所有代码路径上都返回值。当使用结果时，可能会在运行时发生 null 引用异常。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_DefAsgNoRetValOpRef1_Title">
        <source>Operator doesn't return a value on all code paths</source>
        <target state="translated">运算符没有在所有代码路径上返回值</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_DefAsgNoRetValPropRef1">
        <source>Property '{0}' doesn't return a value on all code paths. A null reference exception could occur at run time when the result is used.</source>
        <target state="translated">属性“{0}”不会在所有代码路径上都返回值。当使用结果时，可能会在运行时发生 null 引用异常。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_DefAsgNoRetValPropRef1_Title">
        <source>Property doesn't return a value on all code paths</source>
        <target state="translated">属性没有在所有代码路径上返回值</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_DefAsgUseNullRefByRefStr">
        <source>Variable '{0}' is passed by reference before it has been assigned a value. A null reference exception could result at runtime. Make sure the structure or all the reference members are initialized before use</source>
        <target state="translated">变量“{0}”在赋值前通过引用传递。可能会在运行时导致 null 引用异常。请确保结构或所有引用成员在使用前已经初始化</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_DefAsgUseNullRefByRefStr_Title">
        <source>Variable is passed by reference before it has been assigned a value</source>
        <target state="translated">在为变量赋值之前，变量已通过引用传递</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_DefAsgUseNullRefStr">
        <source>Variable '{0}' is used before it has been assigned a value. A null reference exception could result at runtime. Make sure the structure or all the reference members are initialized before use</source>
        <target state="translated">变量“{0}”在赋值前被使用。可能会在运行时导致 null 引用异常。请确保结构或所有引用成员在使用前已经初始化</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_DefAsgUseNullRefStr_Title">
        <source>Variable is used before it has been assigned a value</source>
        <target state="translated">在为变量赋值之前，变量已被使用</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_StaticLocalNoInference">
        <source>Static variable declared without an 'As' clause; type of Object assumed.</source>
        <target state="translated">未使用 "As" 子句声明的静态变量；假定为 Object 类型。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_StaticLocalNoInference_Title">
        <source>Static variable declared without an 'As' clause</source>
        <target state="translated">声明静态变量时未使用 "As" 子句</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_InvalidAssemblyName">
        <source>Assembly reference '{0}' is invalid and cannot be resolved.</source>
        <target state="translated">程序集引用“{0}”无效，无法解析。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_InvalidAssemblyName_Title">
        <source>Assembly reference is invalid and cannot be resolved</source>
        <target state="translated">程序集引用无效，无法解析</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_XMLDocBadXMLLine">
        <source>XML comment block must immediately precede the language element to which it applies. XML comment will be ignored.</source>
        <target state="translated">XML 注释块必须紧挨着它应用于的语言元素的前面。XML 注释将被忽略。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_XMLDocBadXMLLine_Title">
        <source>XML comment block must immediately precede the language element to which it applies</source>
        <target state="translated">XML 注释块必须紧跟它所应用于的语言元素</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_XMLDocMoreThanOneCommentBlock">
        <source>Only one XML comment block is allowed per language element.</source>
        <target state="translated">每个语言元素只能有一个 XML 注释块。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_XMLDocMoreThanOneCommentBlock_Title">
        <source>Only one XML comment block is allowed per language element</source>
        <target state="translated">每个语言元素只能有一个 XML 注释块</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_XMLDocNotFirstOnLine">
        <source>XML comment must be the first statement on a line. XML comment will be ignored.</source>
        <target state="translated">XML 注释必须是一行中的第一条语句。XML 注释将被忽略。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_XMLDocNotFirstOnLine_Title">
        <source>XML comment must be the first statement on a line</source>
        <target state="translated">XML 注释必须是一行上的第一条语句</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_XMLDocInsideMethod">
        <source>XML comment cannot appear within a method or a property. XML comment will be ignored.</source>
        <target state="translated">XML 注释不能在方法或属性内出现。XML 注释将被忽略。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_XMLDocInsideMethod_Title">
        <source>XML comment cannot appear within a method or a property</source>
        <target state="translated">XML 注释不能在方法或属性内出现</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_XMLDocParseError1">
        <source>XML documentation parse error: {0} XML comment will be ignored.</source>
        <target state="translated">XML 文档分析错误: {0} XML 注释将被忽略。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_XMLDocParseError1_Title">
        <source>XML documentation parse error</source>
        <target state="translated">XML 文档分析错误</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_XMLDocDuplicateXMLNode1">
        <source>XML comment tag '{0}' appears with identical attributes more than once in the same XML comment block.</source>
        <target state="translated">具有相同特性的 XML 注释标记“{0}”在同一 XML 注释块中出现多次。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_XMLDocDuplicateXMLNode1_Title">
        <source>XML comment tag appears with identical attributes more than once in the same XML comment block</source>
        <target state="translated">具有相同属性的 XML 注释标记在同一个 XML 注释块中出现多次</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_XMLDocIllegalTagOnElement2">
        <source>XML comment tag '{0}' is not permitted on a '{1}' language element.</source>
        <target state="translated">“{1}”语言元素中不允许 XML 注释标记“{0}”。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_XMLDocIllegalTagOnElement2_Title">
        <source>XML comment tag is not permitted on language element</source>
        <target state="translated">语言元素中不允许出现 XML 注释标记</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_XMLDocBadParamTag2">
        <source>XML comment parameter '{0}' does not match a parameter on the corresponding '{1}' statement.</source>
        <target state="translated">XML 注释参数“{0}”和相应的“{1}”语句的参数不匹配。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_XMLDocBadParamTag2_Title">
        <source>XML comment parameter does not match a parameter on the corresponding declaration statement</source>
        <target state="translated">XML 注释参数与相应的声明语句上的参数不匹配</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_XMLDocParamTagWithoutName">
        <source>XML comment parameter must have a 'name' attribute.</source>
        <target state="translated">XML 注释参数必须具有 "name" 属性。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_XMLDocParamTagWithoutName_Title">
        <source>XML comment parameter must have a 'name' attribute</source>
        <target state="translated">XML 注释参数必须具有 "name" 属性</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_XMLDocCrefAttributeNotFound1">
        <source>XML comment has a tag with a 'cref' attribute '{0}' that could not be resolved.</source>
        <target state="translated">XML 注释中的一个标记具有未能解析的“cref”特性“{0}”。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_XMLDocCrefAttributeNotFound1_Title">
        <source>XML comment has a tag with a 'cref' attribute that could not be resolved</source>
        <target state="translated">XML 注释包含具有无法解析的 "cref" 属性的标记</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_XMLMissingFileOrPathAttribute1">
        <source>XML comment tag 'include' must have a '{0}' attribute. XML comment will be ignored.</source>
        <target state="translated">XML 注释标记“include”必须具有“{0}”特性。XML 注释将被忽略。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_XMLMissingFileOrPathAttribute1_Title">
        <source>XML comment tag 'include' must have 'file' and 'path' attributes</source>
        <target state="translated">XML 注释标记 "include" 必须具有 "file" 和 "path" 特性</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_XMLCannotWriteToXMLDocFile2">
        <source>Unable to create XML documentation file '{0}': {1}</source>
        <target state="translated">无法创建 XML 文档文件“{0}”: {1}</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_XMLCannotWriteToXMLDocFile2_Title">
        <source>Unable to create XML documentation file</source>
        <target state="translated">无法创建 XML 文档文件</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_XMLDocWithoutLanguageElement">
        <source>XML documentation comments must precede member or type declarations.</source>
        <target state="translated">XML 文档注释必须位于成员声明或类型声明之前。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_XMLDocWithoutLanguageElement_Title">
        <source>XML documentation comments must precede member or type declarations</source>
        <target state="translated">XML 文档注释必须位于成员声明或类型声明之前</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_XMLDocReturnsOnWriteOnlyProperty">
        <source>XML comment tag 'returns' is not permitted on a 'WriteOnly' Property.</source>
        <target state="translated">WriteOnly 属性中不允许有 XML 注释标记 "returns"。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_XMLDocReturnsOnWriteOnlyProperty_Title">
        <source>XML comment tag 'returns' is not permitted on a 'WriteOnly' Property</source>
        <target state="translated">"WriteOnly" 属性中不允许出现 XML 注释标记 "returns"</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_XMLDocOnAPartialType">
        <source>XML comment cannot be applied more than once on a partial {0}. XML comments for this {0} will be ignored.</source>
        <target state="translated">XML 注释在分部 {0} 中不能应用多次。此 {0} 的 XML 注释将被忽略。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_XMLDocOnAPartialType_Title">
        <source>XML comment cannot be applied more than once on a partial type</source>
        <target state="translated">XML 注释无法在一个分部类型上应用多次</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_XMLDocReturnsOnADeclareSub">
        <source>XML comment tag 'returns' is not permitted on a 'declare sub' language element.</source>
        <target state="translated">declare sub 语言元素中不允许有 XML 注释标记 "returns"。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_XMLDocReturnsOnADeclareSub_Title">
        <source>XML comment tag 'returns' is not permitted on a 'declare sub' language element</source>
        <target state="translated">"declare sub" 语言元素中不允许出现 XML 注释标记 "returns"</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_XMLDocStartTagWithNoEndTag">
        <source>XML documentation parse error: Start tag '{0}' doesn't have a matching end tag. XML comment will be ignored.</source>
        <target state="translated">XML 文档分析错误: 开始标记“{0}”没有匹配的结束标记。XML 注释将被忽略。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_XMLDocStartTagWithNoEndTag_Title">
        <source>XML documentation parse error: Start tag doesn't have a matching end tag</source>
        <target state="translated">XML 文档分析错误: 开始标记没有匹配的结束标记</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_XMLDocBadGenericParamTag2">
        <source>XML comment type parameter '{0}' does not match a type parameter on the corresponding '{1}' statement.</source>
        <target state="translated">XML 注释类型参数“{0}”和相应的“{1}”语句的类型参数不匹配。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_XMLDocBadGenericParamTag2_Title">
        <source>XML comment type parameter does not match a type parameter on the corresponding declaration statement</source>
        <target state="translated">XML 注释类型参数与相应的声明语句上的类型参数不匹配</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_XMLDocGenericParamTagWithoutName">
        <source>XML comment type parameter must have a 'name' attribute.</source>
        <target state="translated">XML 注释类型参数必须具有 "name" 属性。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_XMLDocGenericParamTagWithoutName_Title">
        <source>XML comment type parameter must have a 'name' attribute</source>
        <target state="translated">XML 注释类型参数必须具有 "name" 属性</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_XMLDocExceptionTagWithoutCRef">
        <source>XML comment exception must have a 'cref' attribute.</source>
        <target state="translated">XML 注释异常必须具有 "cref" 属性。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_XMLDocExceptionTagWithoutCRef_Title">
        <source>XML comment exception must have a 'cref' attribute</source>
        <target state="translated">XML 注释异常必须具有 "cref" 属性</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_XMLDocInvalidXMLFragment">
        <source>Unable to include XML fragment '{0}' of file '{1}'.</source>
        <target state="translated">无法包括文件“{1}”的 XML 段落“{0}”。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_XMLDocInvalidXMLFragment_Title">
        <source>Unable to include XML fragment</source>
        <target state="translated">无法包括 XML 段落。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_XMLDocBadFormedXML">
        <source>Unable to include XML fragment '{1}' of file '{0}'. {2}</source>
        <target state="translated">无法包括文件“{0}”的 XML 段落“{1}”。{2}</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_XMLDocBadFormedXML_Title">
        <source>Unable to include XML fragment</source>
        <target state="translated">无法包括 XML 段落。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_InterfaceConversion2">
        <source>Runtime errors might occur when converting '{0}' to '{1}'.</source>
        <target state="translated">将“{0}”转换为“{1}”时可能发生运行时错误。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_InterfaceConversion2_Title">
        <source>Runtime errors might occur when converting to or from interface type</source>
        <target state="translated">运行时错误可能在转换到或从接口类型转换时发生</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_LiftControlVariableLambda">
        <source>Using the iteration variable in a lambda expression may have unexpected results.  Instead, create a local variable within the loop and assign it the value of the iteration variable.</source>
        <target state="translated">在 lambda 表达式中使用迭代变量可能会产生意外的结果。应改为在循环中创建一个局部变量并将迭代变量的值赋给它。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_LiftControlVariableLambda_Title">
        <source>Using the iteration variable in a lambda expression may have unexpected results</source>
        <target state="translated">在 lambda 表达式中使用迭代变量可能会产生意外的结果</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_LambdaPassedToRemoveHandler">
        <source>Lambda expression will not be removed from this event handler. Assign the lambda expression to a variable and use the variable to add and remove the event.</source>
        <target state="translated">Lambda 表达式将不会从此事件处理程序中移除。将 lambda 表达式赋给变量，并使用该变量添加和移除事件。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_LambdaPassedToRemoveHandler_Title">
        <source>Lambda expression will not be removed from this event handler</source>
        <target state="translated">Lambda 表达式将不会从此事件处理程序中删除</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_LiftControlVariableQuery">
        <source>Using the iteration variable in a query expression may have unexpected results.  Instead, create a local variable within the loop and assign it the value of the iteration variable.</source>
        <target state="translated">在查询表达式中使用迭代变量可能会产生意外的结果。应改为在循环中创建一个局部变量并将迭代变量的值赋给它。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_LiftControlVariableQuery_Title">
        <source>Using the iteration variable in a query expression may have unexpected results</source>
        <target state="translated">在查询表达式中使用迭代变量可能会产生意外的结果</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_RelDelegatePassedToRemoveHandler">
        <source>The 'AddressOf' expression has no effect in this context because the method argument to 'AddressOf' requires a relaxed conversion to the delegate type of the event. Assign the 'AddressOf' expression to a variable, and use the variable to add or remove the method as the handler.</source>
        <target state="translated">"AddressOf" 表达式在此上下文中不起作用，因为 "AddressOf" 的方法参数需要到该事件的委托类型的宽松转换。将 "AddressOf' 表达式赋给变量，并使用变量将该方法作为处理程序进行添加或移除。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_RelDelegatePassedToRemoveHandler_Title">
        <source>The 'AddressOf' expression has no effect in this context because the method argument to 'AddressOf' requires a relaxed conversion to the delegate type of the event</source>
        <target state="translated">"AddressOf" 表达式在此上下文中不起作用，原因是 "AddressOf" 的方法参数需要到该事件的委托类型的宽松转换</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_QueryMissingAsClauseinVarDecl">
        <source>Range variable is assumed to be of type Object because its type cannot be inferred. Use an 'As' clause to specify a different type.</source>
        <target state="translated">假定范围变量属于对象类型，因为无法推断其类型。请使用“As”子句指定不同类型。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_QueryMissingAsClauseinVarDecl_Title">
        <source>Range variable is assumed to be of type Object because its type cannot be inferred</source>
        <target state="translated">范围变量被假设为 Object 类型，原因是无法推断它的类型</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_MultilineLambdaMissingFunction">
        <source>Multiline lambda expression is missing 'End Function'.</source>
        <target state="translated">多行 lambda 表达式缺少 "End Function"。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_MultilineLambdaMissingSub">
        <source>Multiline lambda expression is missing 'End Sub'.</source>
        <target state="translated">多行 lambda 表达式缺少 "End Sub"。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AttributeOnLambdaReturnType">
        <source>Attributes cannot be applied to return types of lambda expressions.</source>
        <target state="translated">特性不能应用于 lambda 表达式的返回类型。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_SubDisallowsStatement">
        <source>Statement is not valid inside a single-line statement lambda.</source>
        <target state="translated">该语句在单行语句 lambda 中无效。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_SubRequiresParenthesesBang">
        <source>This single-line statement lambda must be enclosed in parentheses. For example: (Sub() &lt;statement&gt;)!key</source>
        <target state="translated">此单行语句 lambda 必须括在括号中。例如: (Sub() &lt;语句&gt;)!key</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_SubRequiresParenthesesDot">
        <source>This single-line statement lambda must be enclosed in parentheses. For example: (Sub() &lt;statement&gt;).Invoke()</source>
        <target state="translated">此单行语句 lambda 必须括在括号中。例如: (Sub() &lt;语句&gt;).Invoke()</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_SubRequiresParenthesesLParen">
        <source>This single-line statement lambda must be enclosed in parentheses. For example: Call (Sub() &lt;statement&gt;) ()</source>
        <target state="translated">此单行语句 lambda 必须括在括号中。例如: Call (Sub() &lt;语句&gt;) ()</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_SubRequiresSingleStatement">
        <source>Single-line statement lambdas must include exactly one statement.</source>
        <target state="translated">单行语句 lambda 必须仅包含一个语句。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_StaticInLambda">
        <source>Static local variables cannot be declared inside lambda expressions.</source>
        <target state="translated">无法在 lambda 表达式内声明静态局部变量。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InitializedExpandedProperty">
        <source>Expanded Properties cannot be initialized.</source>
        <target state="translated">无法初始化扩展属性。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AutoPropertyCantHaveParams">
        <source>Auto-implemented properties cannot have parameters.</source>
        <target state="translated">自动实现的属性不能带有参数。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AutoPropertyCantBeWriteOnly">
        <source>Auto-implemented properties cannot be WriteOnly.</source>
        <target state="translated">自动实现的属性不能为 WriteOnly。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_IllegalOperandInIIFCount">
        <source>'If' operator requires either two or three operands.</source>
        <target state="translated">'“If”运算符需要两个或三个操作数。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NotACollection1">
        <source>Cannot initialize the type '{0}' with a collection initializer because it is not a collection type.</source>
        <target state="translated">无法用集合初始值设定项初始化类型“{0}”，因为该类型不是集合类型。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NoAddMethod1">
        <source>Cannot initialize the type '{0}' with a collection initializer because it does not have an accessible 'Add' method.</source>
        <target state="translated">无法用集合初始值设定项初始化类型“{0}”，因为该类型没有可访问的“Add”方法。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CantCombineInitializers">
        <source>An Object Initializer and a Collection Initializer cannot be combined in the same initialization.</source>
        <target state="translated">不能将对象初始值设定项与集合初始值设定项组合到同一个初始化过程中。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_EmptyAggregateInitializer">
        <source>An aggregate collection initializer entry must contain at least one element.</source>
        <target state="translated">聚合集合初始值设定项必须至少包含一个元素。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_XmlEndElementNoMatchingStart">
        <source>XML end element must be preceded by a matching start element.</source>
        <target state="translated">XML 结束元素前面必须是匹配的开始元素。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_MultilineLambdasCannotContainOnError">
        <source>'On Error' and 'Resume' cannot appear inside a lambda expression.</source>
        <target state="translated">'“On Error”和“Resume”不能出现在 lambda 表达式内。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_VarianceDisallowedHere">
        <source>Keywords 'Out' and 'In' can only be used in interface and delegate declarations.</source>
        <target state="translated">关键字 "Out" 和 "In" 只能在接口声明和委托声明中使用。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_XmlEndCDataNotAllowedInContent">
        <source>The literal string ']]&gt;' is not allowed in element content.</source>
        <target state="translated">元素内容中不允许使用字符串“]]&gt;”。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_OverloadsModifierInModule">
        <source>Inappropriate use of '{0}' keyword in a module.</source>
        <target state="translated">模块中不恰当地使用了“{0}”关键字。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_UndefinedTypeOrNamespace1">
        <source>Type or namespace '{0}' is not defined.</source>
        <target state="translated">未定义类型或命名空间“{0}”。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_IdentityDirectCastForFloat">
        <source>Using DirectCast operator to cast a floating-point value to the same type is not supported.</source>
        <target state="translated">不支持使用 DirectCast 运算符将浮点值强制转换为同一类型。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_ObsoleteIdentityDirectCastForValueType">
        <source>Using DirectCast operator to cast a value-type to the same type is obsolete.</source>
        <target state="translated">使用 DirectCast 运算符将值类型强制转换为同一类型的做法已过时。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_ObsoleteIdentityDirectCastForValueType_Title">
        <source>Using DirectCast operator to cast a value-type to the same type is obsolete</source>
        <target state="translated">使用 DirectCast 运算符将值类型强制转换为同一类型的做法已过时</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UnreachableCode">
        <source>Unreachable code detected.</source>
        <target state="translated">检测到无法访问的代码。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UnreachableCode_Title">
        <source>Unreachable code detected</source>
        <target state="translated">检测到无法访问的代码</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_DefAsgNoRetValFuncVal1">
        <source>Function '{0}' doesn't return a value on all code paths. Are you missing a 'Return' statement?</source>
        <target state="translated">函数“{0}”不会在所有代码路径上都返回值。是否缺少“Return”语句?</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_DefAsgNoRetValFuncVal1_Title">
        <source>Function doesn't return a value on all code paths</source>
        <target state="translated">函数没有在所有代码路径上返回值</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_DefAsgNoRetValOpVal1">
        <source>Operator '{0}' doesn't return a value on all code paths. Are you missing a 'Return' statement?</source>
        <target state="translated">运算符“{0}”不会在所有代码路径上都返回值。是否缺少“Return”语句?</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_DefAsgNoRetValOpVal1_Title">
        <source>Operator doesn't return a value on all code paths</source>
        <target state="translated">运算符没有在所有代码路径上返回值</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_DefAsgNoRetValPropVal1">
        <source>Property '{0}' doesn't return a value on all code paths. Are you missing a 'Return' statement?</source>
        <target state="translated">属性“{0}”不会在所有代码路径上都返回值。是否缺少“Return”语句?</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_DefAsgNoRetValPropVal1_Title">
        <source>Property doesn't return a value on all code paths</source>
        <target state="translated">属性没有在所有代码路径上返回值</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NestedGlobalNamespace">
        <source>Global namespace may not be nested in another namespace.</source>
        <target state="translated">全局命名空间不能嵌套在另一个命名空间中。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AccessMismatch6">
        <source>'{0}' cannot expose type '{1}' in {2} '{3}' through {4} '{5}'.</source>
        <target state="translated">'“{0}”不能通过 {4}“{5}”在 {2}“{3}”中公开类型“{1}”。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadMetaDataReference1">
        <source>'{0}' cannot be referenced because it is not a valid assembly.</source>
        <target state="translated">'“{0}”不是有效程序集，因此无法引用它。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PropertyDoesntImplementAllAccessors">
        <source>'{0}' cannot be implemented by a {1} property.</source>
        <target state="translated">'“{0}”无法由 {1} 属性实现。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_UnimplementedMustOverride">
        <source>
    {0}: {1}</source>
        <target state="translated">
  {0}: {1}</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_IfTooManyTypesObjectDisallowed">
        <source>Cannot infer a common type because more than one type is possible.</source>
        <target state="translated">无法推断通用类型，因为可能存在多个类型。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_IfTooManyTypesObjectAssumed">
        <source>Cannot infer a common type because more than one type is possible; 'Object' assumed.</source>
        <target state="translated">无法推断通用类型，因为可能存在多个类型；假定为 "Object"。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_IfTooManyTypesObjectAssumed_Title">
        <source>Cannot infer a common type because more than one type is possible</source>
        <target state="translated">无法推断通用类型，原因是可能存在多个类型</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_IfNoTypeObjectDisallowed">
        <source>Cannot infer a common type, and Option Strict On does not allow 'Object' to be assumed.</source>
        <target state="translated">无法推断通用类型，且 Option Strict On 不允许假定“Object”。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_IfNoTypeObjectAssumed">
        <source>Cannot infer a common type; 'Object' assumed.</source>
        <target state="translated">无法推断通用类型；假定为“Object”。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_IfNoTypeObjectAssumed_Title">
        <source>Cannot infer a common type</source>
        <target state="translated">无法推断通用类型</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_IfNoType">
        <source>Cannot infer a common type.</source>
        <target state="translated">无法推断通用类型。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PublicKeyFileFailure">
        <source>Error extracting public key from file '{0}': {1}</source>
        <target state="translated">从文件“{0}”中提取公钥时出错: {1}</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PublicKeyContainerFailure">
        <source>Error extracting public key from container '{0}': {1}</source>
        <target state="translated">从容器“{0}”中提取公钥时出错: {1}</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_FriendRefNotEqualToThis">
        <source>Friend access was granted by '{0}', but the public key of the output assembly does not match that specified by the attribute in the granting assembly.</source>
        <target state="translated">友元访问权限由“{0}”授予，但是输出程序集的公钥与授予程序集中特性指定的公钥不匹配。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_FriendRefSigningMismatch">
        <source>Friend access was granted by '{0}', but the strong name signing state of the output assembly does not match that of the granting assembly.</source>
        <target state="translated">友元访问权限由“{0}”授予，但是输出程序集的强名称签名状态与授予程序集的强名称签名状态不匹配。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PublicSignNoKey">
        <source>Public sign was specified and requires a public key, but no public key was specified</source>
        <target state="translated">已指定公共符号并且它需要一个公钥，但未指定任何公钥</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PublicSignNetModule">
        <source>Public signing is not supported for netmodules.</source>
        <target state="translated">netmodule 不支持公共签名。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_AttributeIgnoredWhenPublicSigning">
        <source>Attribute '{0}' is ignored when public signing is specified.</source>
        <target state="translated">指定公共签名时，将忽略特性“{0}”。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_AttributeIgnoredWhenPublicSigning_Title">
        <source>Attribute is ignored when public signing is specified.</source>
        <target state="translated">指定公共签名时，将忽略特性。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_DelaySignButNoKey">
        <source>Delay signing was specified and requires a public key, but no public key was specified.</source>
        <target state="translated">指定了延迟签名，这需要公钥，但是未指定任何公钥。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_DelaySignButNoKey_Title">
        <source>Delay signing was specified and requires a public key, but no public key was specified</source>
        <target state="translated">指定了延迟签名，这需要公钥，但是未指定任何公钥</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_SignButNoPrivateKey">
        <source>Key file '{0}' is missing the private key needed for signing.</source>
        <target state="translated">密钥文件“{0}”缺少进行签名所需的私钥。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_FailureSigningAssembly">
        <source>Error signing assembly '{0}': {1}</source>
        <target state="translated">对程序集“{0}”签名时出错: {1}</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InvalidVersionFormat">
        <source>The specified version string does not conform to the required format - major[.minor[.build|*[.revision|*]]]</source>
        <target state="translated">指定的版本字符串不符合所需格式 - major[.minor[.build|*[.revision|*]]]</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_InvalidVersionFormat">
        <source>The specified version string does not conform to the recommended format - major.minor.build.revision</source>
        <target state="translated">指定版本字符串不符合建议格式 - major.minor.build.revision</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_InvalidVersionFormat_Title">
        <source>The specified version string does not conform to the recommended format</source>
        <target state="translated">指定的版本字符串不符合建议的格式</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InvalidVersionFormat2">
        <source>The specified version string does not conform to the recommended format - major.minor.build.revision</source>
        <target state="translated">指定版本字符串不符合建议格式 - major.minor.build.revision</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InvalidAssemblyCultureForExe">
        <source>Executables cannot be satellite assemblies; culture should always be empty</source>
        <target state="translated">可执行文件不能是附属程序集；区域性应始终为空</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_MainIgnored">
        <source>The entry point of the program is global script code; ignoring '{0}' entry point.</source>
        <target state="translated">程序的入口点是全局脚本代码；正在忽略“{0}”入口点。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_MainIgnored_Title">
        <source>The entry point of the program is global script code; ignoring entry point</source>
        <target state="translated">程序的入口点是全局脚本代码；正在忽略入口点</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_EmptyPrefixAndXmlnsLocalName">
        <source>The xmlns attribute has special meaning and should not be written with a prefix.</source>
        <target state="translated">xmlns 特性具有特殊含义，不应使用前缀进行编写。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_EmptyPrefixAndXmlnsLocalName_Title">
        <source>The xmlns attribute has special meaning and should not be written with a prefix</source>
        <target state="translated">xmlns 特性具有特殊含义，不应使用前缀进行编写</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_PrefixAndXmlnsLocalName">
        <source>It is not recommended to have attributes named xmlns. Did you mean to write 'xmlns:{0}' to define a prefix named '{0}'?</source>
        <target state="translated">建议不要将特性命名为 xmlns。是否有意编写“xmlns:{0}”以定义名为“{0}”的前缀?</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_PrefixAndXmlnsLocalName_Title">
        <source>It is not recommended to have attributes named xmlns</source>
        <target state="translated">不建议拥有名为 xmlns 的属性</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExpectedSingleScript">
        <source>Expected a single script (.vbx file)</source>
        <target state="translated">需要一个脚本 (.vbx 文件)</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ReservedAssemblyName">
        <source>The assembly name '{0}' is reserved and cannot be used as a reference in an interactive session</source>
        <target state="translated">程序集名“{0}”保留名称，不能在交互会话中用作引用</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ReferenceDirectiveOnlyAllowedInScripts">
        <source>#R is only allowed in scripts</source>
        <target state="translated">仅在脚本中允许 #R</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NamespaceNotAllowedInScript">
        <source>You cannot declare Namespace in script code</source>
        <target state="translated">不能在脚本代码中声明命名空间</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_KeywordNotAllowedInScript">
        <source>You cannot use '{0}' in top-level script code</source>
        <target state="translated">您不能使用顶级脚本代码中的“{0}”</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_LambdaNoType">
        <source>Cannot infer a return type.  Consider adding an 'As' clause to specify the return type.</source>
        <target state="translated">无法推断返回类型。请考虑添加一个“As”子句来指定返回类型。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_LambdaNoTypeObjectAssumed">
        <source>Cannot infer a return type; 'Object' assumed.</source>
        <target state="translated">无法推断返回类型；假定为 "Object"。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_LambdaNoTypeObjectAssumed_Title">
        <source>Cannot infer a return type</source>
        <target state="translated">无法推断返回类型</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_LambdaTooManyTypesObjectAssumed">
        <source>Cannot infer a return type because more than one type is possible; 'Object' assumed.</source>
        <target state="translated">无法推断返回类型，因为可能存在多个类型；假定为 "Object"。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_LambdaTooManyTypesObjectAssumed_Title">
        <source>Cannot infer a return type because more than one type is possible</source>
        <target state="translated">无法推断返回类型，原因是可能存在多个类型</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_LambdaNoTypeObjectDisallowed">
        <source>Cannot infer a return type. Consider adding an 'As' clause to specify the return type.</source>
        <target state="translated">无法推断返回类型。请考虑添加一个 "As" 子句来指定返回类型。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_LambdaTooManyTypesObjectDisallowed">
        <source>Cannot infer a return type because more than one type is possible. Consider adding an 'As' clause to specify the return type.</source>
        <target state="translated">无法推断返回类型，因为可能存在多个类型。请考虑添加一个 "As" 子句来指定返回类型。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UnimplementedCommandLineSwitch">
        <source>The command line switch '{0}' is not yet implemented and was ignored.</source>
        <target state="translated">命令行开关“{0}”尚未实现，已忽略。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UnimplementedCommandLineSwitch_Title">
        <source>Command line switch is not yet implemented</source>
        <target state="translated">命令行开关尚未实现</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ArrayInitNoTypeObjectDisallowed">
        <source>Cannot infer an element type, and Option Strict On does not allow 'Object' to be assumed. Specifying the type of the array might correct this error.</source>
        <target state="translated">无法推断元素类型，且 Option Strict On 不允许假定 "Object"。指定数组的类型可更正此错误。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ArrayInitNoType">
        <source>Cannot infer an element type. Specifying the type of the array might correct this error.</source>
        <target state="translated">无法推断元素类型。指定数组的类型可更正此错误。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ArrayInitTooManyTypesObjectDisallowed">
        <source>Cannot infer an element type because more than one type is possible. Specifying the type of the array might correct this error.</source>
        <target state="translated">无法推断元素类型，因为可能存在多个类型。指定数组的类型可更正此错误。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_ArrayInitNoTypeObjectAssumed">
        <source>Cannot infer an element type; 'Object' assumed.</source>
        <target state="translated">无法推断元素类型；假定为 "Object"。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_ArrayInitNoTypeObjectAssumed_Title">
        <source>Cannot infer an element type</source>
        <target state="translated">无法推断元素类型</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_ArrayInitTooManyTypesObjectAssumed">
        <source>Cannot infer an element type because more than one type is possible; 'Object' assumed.</source>
        <target state="translated">无法推断元素类型，因为可能存在多个类型；假定为 "Object"。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_ArrayInitTooManyTypesObjectAssumed_Title">
        <source>Cannot infer an element type because more than one type is possible</source>
        <target state="translated">无法推断元素类型，原因是可能存在多个类型</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_TypeInferenceAssumed3">
        <source>Data type of '{0}' in '{1}' could not be inferred. '{2}' assumed.</source>
        <target state="translated">未能推断“{1}”中“{0}”的数据类型。假定为“{2}”。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_TypeInferenceAssumed3_Title">
        <source>Data type could not be inferred</source>
        <target state="translated">无法推断数据类型</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AmbiguousCastConversion2">
        <source>Option Strict On does not allow implicit conversions from '{0}' to '{1}' because the conversion is ambiguous.</source>
        <target state="translated">Option Strict 不允许进行“{0}”到“{1}”的隐式转换，因为转换不明确。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_AmbiguousCastConversion2">
        <source>Conversion from '{0}' to '{1}' may be ambiguous.</source>
        <target state="translated">从“{0}”到“{1}”的转换可能不明确。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_AmbiguousCastConversion2_Title">
        <source>Conversion may be ambiguous</source>
        <target state="translated">转换可能不明确</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_VarianceIEnumerableSuggestion3">
        <source>'{0}' cannot be converted to '{1}'. Consider using '{2}' instead.</source>
        <target state="translated">'“{0}”不能转换为“{1}”。考虑改用“{2}”。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_VarianceIEnumerableSuggestion3">
        <source>'{0}' cannot be converted to '{1}'. Consider using '{2}' instead.</source>
        <target state="translated">'“{0}”不能转换为“{1}”。考虑改用“{2}”。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_VarianceIEnumerableSuggestion3_Title">
        <source>Type cannot be converted to target collection type</source>
        <target state="translated">无法将类型转换为目标集合类型</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_VarianceConversionFailedIn6">
        <source>'{4}' cannot be converted to '{5}' because '{0}' is not derived from '{1}', as required for the 'In' generic parameter '{2}' in '{3}'.</source>
        <target state="translated">'“{4}”不能转换为“{5}”，因为根据“{3}”中“In”泛型形参“{2}”的需要，“{0}”不是从“{1}”派生的。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_VarianceConversionFailedOut6">
        <source>'{4}' cannot be converted to '{5}' because '{0}' is not derived from '{1}', as required for the 'Out' generic parameter '{2}' in '{3}'.</source>
        <target state="translated">'“{4}”不能转换为“{5}”，因为根据“{3}”中“Out”泛型形参“{2}”的需要，“{0}”不是从“{1}”派生的。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_VarianceConversionFailedIn6">
        <source>Implicit conversion from '{4}' to '{5}'; this conversion may fail because '{0}' is not derived from '{1}', as required for the 'In' generic parameter '{2}' in '{3}'.</source>
        <target state="translated">从“{4}”到“{5}”的隐式转换；此转换可能失败，因为根据“{3}”中“In”泛型形参“{2}”的需要，“{0}”不是从“{1}”派生的。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_VarianceConversionFailedIn6_Title">
        <source>Implicit conversion; this conversion may fail because the target type is not derived from the source type, as required for 'In' generic parameter</source>
        <target state="translated">隐式转换；此转换可能失败，原因是目标类型不是从源类型派生的，而这是 "In" 泛型参数所必需的</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_VarianceConversionFailedOut6">
        <source>Implicit conversion from '{4}' to '{5}'; this conversion may fail because '{0}' is not derived from '{1}', as required for the 'Out' generic parameter '{2}' in '{3}'.</source>
        <target state="translated">从“{4}”到“{5}”的隐式转换；此转换可能失败，因为根据“{3}”中“Out”泛型形参“{2}”的需要，“{0}”不是从“{1}”派生的。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_VarianceConversionFailedOut6_Title">
        <source>Implicit conversion; this conversion may fail because the target type is not derived from the source type, as required for 'Out' generic parameter</source>
        <target state="translated">隐式转换；此转换可能失败，原因是目标类型不是从源类型派生的，而这是 "Out" 泛型参数所必需的</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_VarianceConversionFailedTryIn4">
        <source>'{0}' cannot be converted to '{1}'. Consider changing the '{2}' in the definition of '{3}' to an In type parameter, 'In {2}'.</source>
        <target state="translated">'“{0}”不能转换为“{1}”。考虑在“{3}”的定义中将“{2}”改为 In 类型参数“In {2}”。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_VarianceConversionFailedTryOut4">
        <source>'{0}' cannot be converted to '{1}'. Consider changing the '{2}' in the definition of '{3}' to an Out type parameter, 'Out {2}'.</source>
        <target state="translated">'“{0}”不能转换为“{1}”。考虑在“{3}”的定义中将“{2}”改为 Out 类型参数“Out {2}”。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_VarianceConversionFailedTryIn4">
        <source>'{0}' cannot be converted to '{1}'. Consider changing the '{2}' in the definition of '{3}' to an In type parameter, 'In {2}'.</source>
        <target state="translated">'“{0}”不能转换为“{1}”。考虑在“{3}”的定义中将“{2}”改为 In 类型参数“In {2}”。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_VarianceConversionFailedTryIn4_Title">
        <source>Type cannot be converted to target type</source>
        <target state="translated">无法将类型转换为目标类型</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_VarianceConversionFailedTryOut4">
        <source>'{0}' cannot be converted to '{1}'. Consider changing the '{2}' in the definition of '{3}' to an Out type parameter, 'Out {2}'.</source>
        <target state="translated">'“{0}”不能转换为“{1}”。考虑在“{3}”的定义中将“{2}”改为 Out 类型参数“Out {2}”。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_VarianceConversionFailedTryOut4_Title">
        <source>Type cannot be converted to target type</source>
        <target state="translated">无法将类型转换为目标类型</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_VarianceDeclarationAmbiguous3">
        <source>Interface '{0}' is ambiguous with another implemented interface '{1}' due to the 'In' and 'Out' parameters in '{2}'.</source>
        <target state="translated">“{2}”中的“In”和“Out”参数导致接口“{0}”与另一个已实现的接口“{1}”一起使用时目的不明确。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_VarianceDeclarationAmbiguous3_Title">
        <source>Interface is ambiguous with another implemented interface due to 'In' and 'Out' parameters</source>
        <target state="translated">接口对于另一个实现的接口不明确，原因在于 "In" 和 "Out" 参数</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_VarianceInterfaceNesting">
        <source>Enumerations, classes, and structures cannot be declared in an interface that has an 'In' or 'Out' type parameter.</source>
        <target state="translated">无法在含有 "In" 或 "Out" 类型参数的接口中声明枚举、类和结构。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_VariancePreventsSynthesizedEvents2">
        <source>Event definitions with parameters are not allowed in an interface such as '{0}' that has 'In' or 'Out' type parameters. Consider declaring the event by using a delegate type which is not defined within '{0}'. For example, 'Event {1} As Action(Of ...)'.</source>
        <target state="translated">在“{0}”这样的含有“In”或“Out”类型参数的接口中，不允许带参数的事件定义。考虑使用不在“{0}”中定义的委托类型来声明事件。例如，“Event {1} As Action(Of ...)”。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_VarianceInByRefDisallowed1">
        <source>Type '{0}' cannot be used in this context because 'In' and 'Out' type parameters cannot be used for ByRef parameter types, and '{0}' is an 'In' type parameter.</source>
        <target state="translated">类型“{0}”不能用于此上下文，因为“In”和“Out”类型参数不能用于 ByRef 参数类型，且“{0}”是“In”类型参数。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_VarianceInNullableDisallowed2">
        <source>Type '{0}' cannot be used in '{1}' because 'In' and 'Out' type parameters cannot be made nullable, and '{0}' is an 'In' type parameter.</source>
        <target state="translated">类型“{0}”不能用于“{1}”，因为“In”和“Out”类型参数不能设置为可以为 null，并且“{0}”是“In”类型参数。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_VarianceInParamDisallowed1">
        <source>Type '{0}' cannot be used in this context because '{0}' is an 'In' type parameter.</source>
        <target state="translated">类型“{0}”不能用于此上下文，因为“{0}”是“In”类型参数。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_VarianceInParamDisallowedForGeneric3">
        <source>Type '{0}' cannot be used for the '{1}' in '{2}' in this context because '{0}' is an 'In' type parameter.</source>
        <target state="translated">在此上下文中，类型“{0}”不能用于“{2}”中的“{1}”，因为“{0}”是“In”类型参数。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_VarianceInParamDisallowedHere2">
        <source>Type '{0}' cannot be used in '{1}' in this context because '{0}' is an 'In' type parameter.</source>
        <target state="translated">在此上下文中，类型“{0}”不能用于“{1}”，因为“{0}”是“In”类型参数。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_VarianceInParamDisallowedHereForGeneric4">
        <source>Type '{0}' cannot be used for the '{2}' of '{3}' in '{1}' in this context because '{0}' is an 'In' type parameter.</source>
        <target state="translated">在此上下文中，类型“{0}”不能用于“{1}”中“{3}”的“{2}”，因为“{0}”是“In”类型参数。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_VarianceInPropertyDisallowed1">
        <source>Type '{0}' cannot be used as a property type in this context because '{0}' is an 'In' type parameter and the property is not marked WriteOnly.</source>
        <target state="translated">在此上下文中，类型“{0}”不能用作属性类型，因为“{0}”是“In”类型参数，且该属性未标记为 WriteOnly。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_VarianceInReadOnlyPropertyDisallowed1">
        <source>Type '{0}' cannot be used as a ReadOnly property type because '{0}' is an 'In' type parameter.</source>
        <target state="translated">类型“{0}”不能用作 ReadOnly 属性类型，因为“{0}”是“In”类型参数。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_VarianceInReturnDisallowed1">
        <source>Type '{0}' cannot be used as a return type because '{0}' is an 'In' type parameter.</source>
        <target state="translated">类型“{0}”不能用作返回类型，因为“{0}”是“In”类型参数。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_VarianceOutByRefDisallowed1">
        <source>Type '{0}' cannot be used in this context because 'In' and 'Out' type parameters cannot be used for ByRef parameter types, and '{0}' is an 'Out' type parameter.</source>
        <target state="translated">类型“{0}”不能用于此上下文，因为“In”和“Out”类型参数不能用于 ByRef 参数类型，且“{0}”是“Out”类型参数。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_VarianceOutByValDisallowed1">
        <source>Type '{0}' cannot be used as a ByVal parameter type because '{0}' is an 'Out' type parameter.</source>
        <target state="translated">类型“{0}”不能用作 ByVal 参数类型，因为“{0}”是“Out”类型参数。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_VarianceOutConstraintDisallowed1">
        <source>Type '{0}' cannot be used as a generic type constraint because '{0}' is an 'Out' type parameter.</source>
        <target state="translated">类型“{0}”不能用作泛型类型约束，因为“{0}”是“Out”类型参数。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_VarianceOutNullableDisallowed2">
        <source>Type '{0}' cannot be used in '{1}' because 'In' and 'Out' type parameters cannot be made nullable, and '{0}' is an 'Out' type parameter.</source>
        <target state="translated">类型“{0}”不能用于“{1}”，因为“In”和“Out”类型参数不能设置为可以为 null，并且“{0}”是“Out”类型参数。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_VarianceOutParamDisallowed1">
        <source>Type '{0}' cannot be used in this context because '{0}' is an 'Out' type parameter.</source>
        <target state="translated">类型“{0}”不能用于此上下文，因为“{0}”是“Out”类型参数。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_VarianceOutParamDisallowedForGeneric3">
        <source>Type '{0}' cannot be used for the '{1}' in '{2}' in this context because '{0}' is an 'Out' type parameter.</source>
        <target state="translated">在此上下文中，类型“{0}”不能用于“{2}”中的“{1}”，因为“{0}”是“Out”类型参数。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_VarianceOutParamDisallowedHere2">
        <source>Type '{0}' cannot be used in '{1}' in this context because '{0}' is an 'Out' type parameter.</source>
        <target state="translated">在此上下文中，类型“{0}”不能用于“{1}”，因为“{0}”是“Out”类型参数。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_VarianceOutParamDisallowedHereForGeneric4">
        <source>Type '{0}' cannot be used for the '{2}' of '{3}' in '{1}' in this context because '{0}' is an 'Out' type parameter.</source>
        <target state="translated">在此上下文中，类型“{0}”不能用于“{1}”中“{3}”的“{2}”，因为“{0}”是“Out”类型参数。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_VarianceOutPropertyDisallowed1">
        <source>Type '{0}' cannot be used as a property type in this context because '{0}' is an 'Out' type parameter and the property is not marked ReadOnly.</source>
        <target state="translated">在此上下文中，类型“{0}”不能用作属性类型，因为“{0}”是“Out”类型参数，且该属性未标记为 ReadOnly。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_VarianceOutWriteOnlyPropertyDisallowed1">
        <source>Type '{0}' cannot be used as a WriteOnly property type because '{0}' is an 'Out' type parameter.</source>
        <target state="translated">类型“{0}”不能用作 WriteOnly 属性类型，因为“{0}”是“Out”类型参数。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_VarianceTypeDisallowed2">
        <source>Type '{0}' cannot be used in this context because both the context and the definition of '{0}' are nested within interface '{1}', and '{1}' has 'In' or 'Out' type parameters. Consider moving the definition of '{0}' outside of '{1}'.</source>
        <target state="translated">类型“{0}”不能用于此上下文，因为此上下文和“{0}”的定义均嵌套在接口“{1}”内，而“{1}”含有“In”或“Out”类型参数。考虑将“{0}”的定义移出“{1}”。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_VarianceTypeDisallowedForGeneric4">
        <source>Type '{0}' cannot be used for the '{2}' in '{3}' in this context because both the context and the definition of '{0}' are nested within interface '{1}', and '{1}' has 'In' or 'Out' type parameters. Consider moving the definition of '{0}' outside of '{1}'.</source>
        <target state="translated">类型“{0}”不能在此上下文中用于“{3}”中的“{2}”，因为此上下文和“{0}”的定义均嵌套在接口“{1}”内，而“{1}”含有“In”或“Out”类型参数。考虑将“{0}”的定义移出“{1}”。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_VarianceTypeDisallowedHere3">
        <source>Type '{0}' cannot be used in '{2}' in this context because both the context and the definition of '{0}' are nested within interface '{1}', and '{1}' has 'In' or 'Out' type parameters. Consider moving the definition of '{0}' outside of '{1}'.</source>
        <target state="translated">类型“{0}”不能在此上下文用于“{2}”，因为此上下文和“{0}”的定义均嵌套在接口“{1}”内，而“{1}”含有“In”或“Out”类型参数。考虑将“{0}”的定义移出“{1}”。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_VarianceTypeDisallowedHereForGeneric5">
        <source>Type '{0}' cannot be used for the '{3}' of '{4}' in '{2}' in this context because both the context and the definition of '{0}' are nested within interface '{1}', and '{1}' has 'In' or 'Out' type parameters. Consider moving the definition of '{0}' outside of '{1}'.</source>
        <target state="translated">类型“{0}”不能在此上下文中用于“{2}”中“{4}”的“{3}”，因为此上下文和“{0}”的定义均嵌套在接口“{1}”内，而“{1}”含有“In”或“Out”类型参数。考虑将“{0}”的定义移出“{1}”。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ParameterNotValidForType">
        <source>Parameter not valid for the specified unmanaged type.</source>
        <target state="translated">参数对于指定非托管类型无效。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_MarshalUnmanagedTypeNotValidForFields">
        <source>Unmanaged type '{0}' not valid for fields.</source>
        <target state="translated">非托管类型“{0}”对于字段无效。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_MarshalUnmanagedTypeOnlyValidForFields">
        <source>Unmanaged type '{0}' is only valid for fields.</source>
        <target state="translated">非托管类型“{0}”仅对字段有效。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AttributeParameterRequired1">
        <source>Attribute parameter '{0}' must be specified.</source>
        <target state="translated">必须指定特性参数“{0}”。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AttributeParameterRequired2">
        <source>Attribute parameter '{0}' or '{1}' must be specified.</source>
        <target state="translated">必须指定特性参数“{0}”或“{1}”。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_MemberConflictWithSynth4">
        <source>Conflicts with '{0}', which is implicitly declared for '{1}' in {2} '{3}'.</source>
        <target state="translated">与为 {2}“{3}”中的“{1}”隐式声明的“{0}”冲突。</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_ProjectSettingsLocationName">
        <source>&lt;project settings&gt;</source>
        <target state="translated">&lt;项目设置&gt;</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_ReturnTypeAttributeOnWriteOnlyProperty">
        <source>Attributes applied on a return type of a WriteOnly Property have no effect.</source>
        <target state="translated">应用于 WriteOnly 属性的返回类型的特性不起作用。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_ReturnTypeAttributeOnWriteOnlyProperty_Title">
        <source>Attributes applied on a return type of a WriteOnly Property have no effect</source>
        <target state="translated">应用于 WriteOnly 属性的返回类型的特性不起作用</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_SecurityAttributeInvalidTarget">
        <source>Security attribute '{0}' is not valid on this declaration type. Security attributes are only valid on assembly, type and method declarations.</source>
        <target state="translated">安全特性“{0}”对此声明类型无效。安全特性仅对程序集、类型和方法声明有效。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AbsentReferenceToPIA1">
        <source>Cannot find the interop type that matches the embedded type '{0}'. Are you missing an assembly reference?</source>
        <target state="translated">找不到与嵌入的类型“{0}”匹配的互操作类型。是否缺少程序集引用?</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CannotLinkClassWithNoPIA1">
        <source>Reference to class '{0}' is not allowed when its assembly is configured to embed interop types.</source>
        <target state="translated">当类“{0}”的程序集配置为嵌入互操作类型时，不允许使用对该类的引用。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InvalidStructMemberNoPIA1">
        <source>Embedded interop structure '{0}' can contain only public instance fields.</source>
        <target state="translated">嵌入的互操作结构“{0}”只能包含公共实例字段。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NoPIAAttributeMissing2">
        <source>Interop type '{0}' cannot be embedded because it is missing the required '{1}' attribute.</source>
        <target state="translated">无法嵌入互操作类型“{0}”，因为它缺少必需的“{1}”特性。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PIAHasNoAssemblyGuid1">
        <source>Cannot embed interop types from assembly '{0}' because it is missing the '{1}' attribute.</source>
        <target state="translated">无法嵌入来自程序集“{0}”的互操作类型，因为它缺少“{1}”特性。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DuplicateLocalTypes3">
        <source>Cannot embed interop type '{0}' found in both assembly '{1}' and '{2}'. Consider disabling the embedding of interop types.</source>
        <target state="translated">无法嵌入程序集“{1}”和“{2}”中找到的互操作类型“{0}”。请考虑禁用互操作类型的嵌入。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PIAHasNoTypeLibAttribute1">
        <source>Cannot embed interop types from assembly '{0}' because it is missing either the '{1}' attribute or the '{2}' attribute.</source>
        <target state="translated">无法嵌入来自程序集“{0}”的互操作类型，因为它缺少“{1}”特性或“{2}”特性。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_SourceInterfaceMustBeInterface">
        <source>Interface '{0}' has an invalid source interface which is required to embed event '{1}'.</source>
        <target state="translated">接口“{0}”的源接口无效，该源接口是嵌入事件“{1}”所必需的。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_EventNoPIANoBackingMember">
        <source>Source interface '{0}' is missing method '{1}', which is required to embed event '{2}'.</source>
        <target state="translated">源接口“{0}”缺少方法“{2}”，此方法对嵌入事件“{1}”是必需的。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NestedInteropType">
        <source>Nested type '{0}' cannot be embedded.</source>
        <target state="translated">无法嵌入嵌套类型“{0}”。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_LocalTypeNameClash2">
        <source>Embedding the interop type '{0}' from assembly '{1}' causes a name clash in the current assembly. Consider disabling the embedding of interop types.</source>
        <target state="translated">嵌入来自程序集“{1}”中的互操作类型“{0}”会导致当前程序集中发生名称冲突。请考虑禁用互操作类型的嵌入。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InteropMethodWithBody1">
        <source>Embedded interop method '{0}' contains a body.</source>
        <target state="translated">嵌入互操作方法“{0}”包含主体。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadAsyncInQuery">
        <source>'Await' may only be used in a query expression within the first collection expression of the initial 'From' clause or within the collection expression of a 'Join' clause.</source>
        <target state="translated">'"Await" 只能在初始 "From" 子句的第一个集合表达式或 "Join" 子句的集合表达式的查询表达式中使用。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadGetAwaiterMethod1">
        <source>'Await' requires that the type '{0}' have a suitable GetAwaiter method.</source>
        <target state="translated">'“Await”要求类型“{0}”包含适当的 GetAwaiter 方法。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadIsCompletedOnCompletedGetResult2">
        <source>'Await' requires that the return type '{0}' of '{1}.GetAwaiter()' have suitable IsCompleted, OnCompleted and GetResult members, and implement INotifyCompletion or ICriticalNotifyCompletion.</source>
        <target state="translated">'“Await”要求“{1}.GetAwaiter()”的返回类型“{0}”包含适当的 IsCompleted、OnCompleted 和 GetResult 成员，并实现 INotifyCompletion 或 ICriticalNotifyCompletion</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DoesntImplementAwaitInterface2">
        <source>'{0}' does not implement '{1}'.</source>
        <target state="translated">'“{0}”未实现“{1}”。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadAwaitNothing">
        <source>Cannot await Nothing. Consider awaiting 'Task.Yield()' instead.</source>
        <target state="translated">不能等待 Nothing。请考虑改为等待“Task.Yield()”。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadAsyncByRefParam">
        <source>Async methods cannot have ByRef parameters.</source>
        <target state="translated">异步方法不能包含 ByRef 参数。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InvalidAsyncIteratorModifiers">
        <source>'Async' and 'Iterator' modifiers cannot be used together.</source>
        <target state="translated">'“Async”和“Iterator”修饰符不能一起使用。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadResumableAccessReturnVariable">
        <source>The implicit return variable of an Iterator or Async method cannot be accessed.</source>
        <target state="translated">无法访问迭代器方法或异步方法的隐式返回变量。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ReturnFromNonGenericTaskAsync">
        <source>'Return' statements in this Async method cannot return a value since the return type of the function is 'Task'. Consider changing the function's return type to 'Task(Of T)'.</source>
        <target state="translated">'此异步方法中的 "Return" 语句无法返回值，因为函数的返回类型为 "Task" 。请考虑将函数的返回类型更改为 "Task(Of T)"。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadAsyncReturnOperand1">
        <source>Since this is an async method, the return expression must be of type '{0}' rather than 'Task(Of {0})'.</source>
        <target state="translated">这是一个异步方法，因此返回表达式的类型必须为“{0}”而不是“Task(Of {0})”。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadAsyncReturn">
        <source>The 'Async' modifier can only be used on Subs, or on Functions that return Task or Task(Of T).</source>
        <target state="translated">只能在 Sub 上或者在返回 Task 或 Task(Of T) 的函数上使用 "Async" 修饰符。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CantAwaitAsyncSub1">
        <source>'{0}' does not return a Task and cannot be awaited. Consider changing it to an Async Function.</source>
        <target state="translated">'“{0}”不返回 Task 且无法等待。请考虑将它更改为 Async Function。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InvalidLambdaModifier">
        <source>'Only the 'Async' or 'Iterator' modifier is valid on a lambda.</source>
        <target state="translated">'仅“Async”或“Iterator”修饰符在 lambda 上有效。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadAwaitInNonAsyncMethod">
        <source>'Await' can only be used within an Async method. Consider marking this method with the 'Async' modifier and changing its return type to 'Task(Of {0})'.</source>
        <target state="translated">'“Await”只能在异步方法中使用。请考虑使用“Async”修饰符标记此方法，并将其返回类型更改为“Task(Of {0})”。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadAwaitInNonAsyncVoidMethod">
        <source>'Await' can only be used within an Async method. Consider marking this method with the 'Async' modifier and changing its return type to 'Task'.</source>
        <target state="translated">'“Await”只能用于异步方法中。请考虑用“Async”修饰符标记此方法，并将其返回类型更改为“Task”。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadAwaitInNonAsyncLambda">
        <source>'Await' can only be used within an Async lambda expression. Consider marking this lambda expression with the 'Async' modifier.</source>
        <target state="translated">'“Await”只能用于异步 lambda 表达式中。请考虑用“Async”修饰符标记此 lambda 表达式。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadAwaitNotInAsyncMethodOrLambda">
        <source>'Await' can only be used when contained within a method or lambda expression marked with the 'Async' modifier.</source>
        <target state="translated">'仅当其包含方法或 lambda 表达式用“Async”修饰符标记时，才能使用“Await”。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_StatementLambdaInExpressionTree">
        <source>Statement lambdas cannot be converted to expression trees.</source>
        <target state="translated">语句 lambda 不能转换为表达式树。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UnobservedAwaitableExpression">
        <source>Because this call is not awaited, execution of the current method continues before the call is completed. Consider applying the Await operator to the result of the call.</source>
        <target state="translated">由于此调用不会等待，因此在调用完成前将继续执行当前方法。请考虑对调用结果应用 Await 运算符。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UnobservedAwaitableExpression_Title">
        <source>Because this call is not awaited, execution of the current method continues before the call is completed</source>
        <target state="translated">由于此调用不会等待，因此在调用完成前将继续执行当前方法</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_LoopControlMustNotAwait">
        <source>Loop control variable cannot include an 'Await'.</source>
        <target state="translated">循环控制变量不可包含 "Await"。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadStaticInitializerInResumable">
        <source>Static variables cannot appear inside Async or Iterator methods.</source>
        <target state="translated">静态变量不能出现在异步方法或迭代器方法内。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RestrictedResumableType1">
        <source>'{0}' cannot be used as a parameter type for an Iterator or Async method.</source>
        <target state="translated">'“{0}”不能用作 Iterator 或 Async 方法的参数类型。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ConstructorAsync">
        <source>Constructor must not have the 'Async' modifier.</source>
        <target state="translated">构造函数不得包含“Async”修饰符。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PartialMethodsMustNotBeAsync1">
        <source>'{0}' cannot be declared 'Partial' because it has the 'Async' modifier.</source>
        <target state="translated">'“{0}”不能声明为“Partial”，因为它具有“Async”修饰符。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ResumablesCannotContainOnError">
        <source>'On Error' and 'Resume' cannot appear inside async or iterator methods.</source>
        <target state="translated">'"On Error" 和 "Resume" 不能出现在异步方法或迭代器方法内。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ResumableLambdaInExpressionTree">
        <source>Lambdas with the 'Async' or 'Iterator' modifiers cannot be converted to expression trees.</source>
        <target state="translated">无法将带 "Async" 或 "Iterator" 修饰符的 lambda 转换为表达式树。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CannotLiftRestrictedTypeResumable1">
        <source>Variable of restricted type '{0}' cannot be declared in an Async or Iterator method.</source>
        <target state="translated">不能在异步方法或迭代器方法中声明受限类型“{0}”的变量。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadAwaitInTryHandler">
        <source>'Await' cannot be used inside a 'Catch' statement, a 'Finally' statement, or a 'SyncLock' statement.</source>
        <target state="translated">'不能在“Catch”语句、“Finally”语句或“SyncLock”语句内使用“Await”。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_AsyncLacksAwaits">
        <source>This async method lacks 'Await' operators and so will run synchronously. Consider using the 'Await' operator to await non-blocking API calls, or 'Await Task.Run(...)' to do CPU-bound work on a background thread.</source>
        <target state="translated">此异步方法缺少 "Await" 运算符，因此它将同步运行。请考虑使用 "Await" 运算符等待非阻止 API 调用，或使用 "Await Task.Run(...)" 利用后台线程执行占用大量 CPU 的工作。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_AsyncLacksAwaits_Title">
        <source>This async method lacks 'Await' operators and so will run synchronously</source>
        <target state="translated">此异步方法缺少 "Await" 运算符，因此将以同步方式运行</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UnobservedAwaitableDelegate">
        <source>The Task returned from this Async Function will be dropped, and any exceptions in it ignored. Consider changing it to an Async Sub so its exceptions are propagated.</source>
        <target state="translated">从此 Async Function 返回的任务将被删除，并且忽略其中的任何异常。考虑将其更改为 Async Sub，以便传播其异常。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UnobservedAwaitableDelegate_Title">
        <source>The Task returned from this Async Function will be dropped, and any exceptions in it ignored</source>
        <target state="translated">自此 Async Function 返回的任务将被丢弃，它包含的任何异常也将被忽略</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_SecurityCriticalAsyncInClassOrStruct">
        <source>Async and Iterator methods are not allowed in a [Class|Structure|Interface|Module] that has the 'SecurityCritical' or 'SecuritySafeCritical' attribute.</source>
        <target state="translated">在具有“SecurityCritical”或“SecuritySafeCritical”属性的 [Class|Structure|Interface|Module] 中不允许使用 Async 或 Iterator 方法。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_SecurityCriticalAsync">
        <source>Security attribute '{0}' cannot be applied to an Async or Iterator method.</source>
        <target state="translated">安全属性“{0}”不能应用于 Async 或 Iterator 方法。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DllImportOnResumableMethod">
        <source>'System.Runtime.InteropServices.DllImportAttribute' cannot be applied to an Async or Iterator method.</source>
        <target state="translated">'"System.Runtime.InteropServices.DllImportAttribute" 不能应用于异步方法或迭代器方法。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_SynchronizedAsyncMethod">
        <source>'MethodImplOptions.Synchronized' cannot be applied to an Async method.</source>
        <target state="translated">'"MethodImplOptions.Synchronized" 不能应用于异步方法。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AsyncSubMain">
        <source>The 'Main' method cannot be marked 'Async'.</source>
        <target state="translated">"Main" 方法不能标记为 "Async"。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_AsyncSubCouldBeFunction">
        <source>Some overloads here take an Async Function rather than an Async Sub. Consider either using an Async Function, or casting this Async Sub explicitly to the desired type.</source>
        <target state="translated">此处某些重载使用的是 Async Function 而不是 Async Sub。请考虑使用 Async Function 或将此 Async Sub 显式强制转换为所需类型。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_AsyncSubCouldBeFunction_Title">
        <source>Some overloads here take an Async Function rather than an Async Sub</source>
        <target state="translated">此处的一些重载采用的是 Async Function，而不是 Async Sub</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_MyGroupCollectionAttributeCycle">
        <source>MyGroupCollectionAttribute cannot be applied to itself.</source>
        <target state="translated">MyGroupCollectionAttribute 不能应用于自身。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_LiteralExpected">
        <source>Literal expected.</source>
        <target state="translated">应为文本。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_WinRTEventWithoutDelegate">
        <source>Event declarations that target WinMD must specify a delegate type.  Add an As clause to the event declaration.</source>
        <target state="translated">面向 WinMD 的事件声明必须指定委托类型。请在事件声明中添加一个 As 子句。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_MixingWinRTAndNETEvents">
        <source>Event '{0}' cannot implement a Windows Runtime event '{1}' and a regular .NET event '{2}'</source>
        <target state="translated">事件“{0}”无法实现 Windows 运行时事件“{1}”和常规 .NET 事件“{2}”</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_EventImplRemoveHandlerParamWrong">
        <source>Event '{0}' cannot implement event '{1}' on interface '{2}' because the parameters of their 'RemoveHandler' methods do not match.</source>
        <target state="translated">事件“{0}”无法实现接口“{2}”上的事件“{1}”，因为其“RemoveHandler”方法的参数不匹配。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AddParamWrongForWinRT">
        <source>The type of the 'AddHandler' method's parameter must be the same as the type of the event.</source>
        <target state="translated">“AddHandler”方法的参数的类型必须与事件的类型相同。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RemoveParamWrongForWinRT">
        <source>In a Windows Runtime event, the type of the 'RemoveHandler' method parameter must be 'EventRegistrationToken'</source>
        <target state="translated">在 Windows Runtime 事件中，“RemoveHandler”方法参数的类型必须为“EventRegistrationToken”</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ReImplementingWinRTInterface5">
        <source>'{0}.{1}' from 'implements {2}' is already implemented by the base class '{3}'. Re-implementation of Windows Runtime Interface '{4}' is not allowed</source>
        <target state="translated">'“实现 {2}”中的“{0}.{1}”已由基类“{3}”实现。不允许重新实现 Windows Runtime 接口“{4}”</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ReImplementingWinRTInterface4">
        <source>'{0}.{1}' is already implemented by the base class '{2}'. Re-implementation of Windows Runtime Interface '{3}' is not allowed</source>
        <target state="translated">'“{0}.{1}”已由基类“{2}”实现。不允许重新实现 Windows Runtime 接口“{3}”</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadIteratorByRefParam">
        <source>Iterator methods cannot have ByRef parameters.</source>
        <target state="translated">迭代器方法不能包含 ByRef 参数。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadIteratorExpressionLambda">
        <source>Single-line lambdas cannot have the 'Iterator' modifier. Use a multiline lambda instead.</source>
        <target state="translated">单行 lambda 不能包含“Iterator”修饰符。请改用多行 lambda。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadIteratorReturn">
        <source>Iterator functions must return either IEnumerable(Of T), or IEnumerator(Of T), or the non-generic forms IEnumerable or IEnumerator.</source>
        <target state="translated">迭代器函数必须返回 IEnumerable(Of T) 或 IEnumerator(Of T)，或返回非泛型格式的 IEnumerable 或 IEnumerator。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadReturnValueInIterator">
        <source>To return a value from an Iterator function, use 'Yield' rather than 'Return'.</source>
        <target state="translated">若要从迭代器函数返回值，请使用“Yield”而不是“Return”。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadYieldInNonIteratorMethod">
        <source>'Yield' can only be used in a method marked with the 'Iterator' modifier.</source>
        <target state="translated">'只能在用“Iterator”修饰符标记的方法中使用“Yield”。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadYieldInTryHandler">
        <source>'Yield' cannot be used inside a 'Catch' statement or a 'Finally' statement.</source>
        <target state="translated">'不能在“Catch”语句或“Finally”语句内使用“Yield”。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_DefAsgNoRetValWinRtEventVal1">
        <source>The AddHandler for Windows Runtime event '{0}' doesn't return a value on all code paths. Are you missing a 'Return' statement?</source>
        <target state="translated">Windows 运行时事件“{0}”的 AddHandler 不会在所有代码路径上都返回值。是否缺少“Return”语句?</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_DefAsgNoRetValWinRtEventVal1_Title">
        <source>The AddHandler for Windows Runtime event doesn't return a value on all code paths</source>
        <target state="translated">Windows 运行时事件的 AddHandler 没有在所有代码路径上返回值</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PartialMethodDefaultParameterValueMismatch2">
        <source>Optional parameter of a method '{0}' does not have the same default value as the corresponding parameter of the partial method '{1}'.</source>
        <target state="translated">方法“{0}”的可选参数没有与分部方法“{1}”的相应参数相同的默认值。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PartialMethodParamArrayMismatch2">
        <source>Parameter of a method '{0}' differs by ParamArray modifier from the corresponding parameter of the partial method '{1}'.</source>
        <target state="translated">方法“{0}”的参数在分部方法“{1}”的相应参数的 ParamArray 修饰符上存在差异。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NetModuleNameMismatch">
        <source>Module name '{0}' stored in '{1}' must match its filename.</source>
        <target state="translated">存储在“{1}”中的模块名“{0}”必须与其文件名匹配。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadModuleName">
        <source>Invalid module name: {0}</source>
        <target state="translated">无效的模块名称: {0}</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_AssemblyAttributeFromModuleIsOverridden">
        <source>Attribute '{0}' from module '{1}' will be ignored in favor of the instance appearing in source.</source>
        <target state="translated">来自模块“{1}”的特性“{0}”将忽略，以便支持源中出现的实例。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_AssemblyAttributeFromModuleIsOverridden_Title">
        <source>Attribute from module will be ignored in favor of the instance appearing in source</source>
        <target state="translated">为支持源中出现的实例，将忽略模块的特性</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CmdOptionConflictsSource">
        <source>Attribute '{0}' given in a source file conflicts with option '{1}'.</source>
        <target state="translated">源文件中提供的特定“{0}”与选项“{1}”冲突。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_ReferencedAssemblyDoesNotHaveStrongName">
        <source>Referenced assembly '{0}' does not have a strong name.</source>
        <target state="translated">引用程序集“{0}”没有强名称。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_ReferencedAssemblyDoesNotHaveStrongName_Title">
        <source>Referenced assembly does not have a strong name</source>
        <target state="translated">引用程序集没有强名称</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InvalidSignaturePublicKey">
        <source>Invalid signature public key specified in AssemblySignatureKeyAttribute.</source>
        <target state="translated">在 AssemblySignatureKeyAttribute 中指定的签名公钥无效。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CollisionWithPublicTypeInModule">
        <source>Type '{0}' conflicts with public type defined in added module '{1}'.</source>
        <target state="translated">类型“{0}”与添加的模块“{1}”中定义的公共类型冲突。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExportedTypeConflictsWithDeclaration">
        <source>Type '{0}' exported from module '{1}' conflicts with type declared in primary module of this assembly.</source>
        <target state="translated">从模块“{1}”导出的类型“{0}”与此程序集主模块中声明的类型冲突。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExportedTypesConflict">
        <source>Type '{0}' exported from module '{1}' conflicts with type '{2}' exported from module '{3}'.</source>
        <target state="translated">从模块“{1}”导出的类型“{0}”与从模块“{3}”导出的类型“{2}”冲突。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_RefCultureMismatch">
        <source>Referenced assembly '{0}' has different culture setting of '{1}'.</source>
        <target state="translated">引用程序集“{0}”具有不同区域性设置“{1}”。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_RefCultureMismatch_Title">
        <source>Referenced assembly has different culture setting</source>
        <target state="translated">引用程序集具有不同区域性设置</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AgnosticToMachineModule">
        <source>Agnostic assembly cannot have a processor specific module '{0}'.</source>
        <target state="translated">不可知的程序集不能具有特定于处理器的模块“{0}”。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ConflictingMachineModule">
        <source>Assembly and module '{0}' cannot target different processors.</source>
        <target state="translated">程序集和模块“{0}”不能以不同处理器为目标。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_ConflictingMachineAssembly">
        <source>Referenced assembly '{0}' targets a different processor.</source>
        <target state="translated">引用程序集“{0}”面向的是另一个处理器。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_ConflictingMachineAssembly_Title">
        <source>Referenced assembly targets a different processor</source>
        <target state="translated">引用程序集面向的是另一个处理器</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CryptoHashFailed">
        <source>Cryptographic failure while creating hashes.</source>
        <target state="translated">创建哈希时加密失败。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CantHaveWin32ResAndManifest">
        <source>Conflicting options specified: Win32 resource file; Win32 manifest.</source>
        <target state="translated">指定的选项冲突: Win32 资源文件；Win32 清单。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ForwardedTypeConflictsWithDeclaration">
        <source>Forwarded type '{0}' conflicts with type declared in primary module of this assembly.</source>
        <target state="translated">转发的类型“{0}”与此程序集主模块中声明的类型冲突。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ForwardedTypesConflict">
        <source>Type '{0}' forwarded to assembly '{1}' conflicts with type '{2}' forwarded to assembly '{3}'.</source>
        <target state="translated">转发到程序集“{1}”的类型“{0}”与转发到程序集“{3}”的类型“{2}”冲突。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_TooLongMetadataName">
        <source>Name '{0}' exceeds the maximum length allowed in metadata.</source>
        <target state="translated">名称“{0}”超出元数据中允许的最大长度。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_MissingNetModuleReference">
        <source>Reference to '{0}' netmodule missing.</source>
        <target state="translated">缺少对“{0}”netmodule 的引用。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NetModuleNameMustBeUnique">
        <source>Module '{0}' is already defined in this assembly. Each module must have a unique filename.</source>
        <target state="translated">模块“{0}”已在此程序集中定义。每个模块必须具有唯一的文件名。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ForwardedTypeConflictsWithExportedType">
        <source>Type '{0}' forwarded to assembly '{1}' conflicts with type '{2}' exported from module '{3}'.</source>
        <target state="translated">转发到程序集“{1}”的类型“{0}”与从模块“{3}”导出的类型“{2}”冲突。</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_MSG_ADDREFERENCE">
        <source>Adding assembly reference '{0}'</source>
        <target state="translated">正在添加程序集引用“{0}”</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_MSG_ADDLINKREFERENCE">
        <source>Adding embedded assembly reference '{0}'</source>
        <target state="translated">正在添加嵌入程序集引用“{0}”</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_MSG_ADDMODULE">
        <source>Adding module reference '{0}'</source>
        <target state="translated">正在添加模块引用“{0}”</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NestingViolatesCLS1">
        <source>Type '{0}' does not inherit the generic type parameters of its container.</source>
        <target state="translated">类型“{0}”不继承其容器的泛型类型参数。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PDBWritingFailed">
        <source>Failure writing debug information: {0}</source>
        <target state="translated">写入调试信息失败: {0}</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ParamDefaultValueDiffersFromAttribute">
        <source>The parameter has multiple distinct default values.</source>
        <target state="translated">参数具有多个不同的默认值。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_FieldHasMultipleDistinctConstantValues">
        <source>The field has multiple distinct constant values.</source>
        <target state="translated">字段具有多个不同的常量值。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_EncNoPIAReference">
        <source>Cannot continue since the edit includes a reference to an embedded type: '{0}'.</source>
        <target state="translated">无法继续，因为编辑包括对嵌入类型的引用:“{0}”。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_EncReferenceToAddedMember">
        <source>Member '{0}' added during the current debug session can only be accessed from within its declaring assembly '{1}'.</source>
        <target state="translated">在当前调试会话期间添加的成员“{0}”只能从其声明的程序集“{1}”中访问。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_UnsupportedModule1">
        <source>'{0}' is an unsupported .NET module.</source>
        <target state="translated">'“{0}”是不受支持的 .NET 模块。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_UnsupportedEvent1">
        <source>'{0}' is an unsupported event.</source>
        <target state="translated">'“{0}”是不受支持的事件。</target>
        <note />
      </trans-unit>
      <trans-unit id="PropertiesCanNotHaveTypeArguments">
        <source>Properties can not have type arguments</source>
        <target state="translated">属性不能具有类型参数</target>
        <note />
      </trans-unit>
      <trans-unit id="IdentifierSyntaxNotWithinSyntaxTree">
        <source>IdentifierSyntax not within syntax tree</source>
        <target state="translated">IdentifierSyntax 不在语法树中</target>
        <note />
      </trans-unit>
      <trans-unit id="AnonymousObjectCreationExpressionSyntaxNotWithinTree">
        <source>AnonymousObjectCreationExpressionSyntax not within syntax tree</source>
        <target state="translated">AnonymousObjectCreationExpressionSyntax 未在语法树内</target>
        <note />
      </trans-unit>
      <trans-unit id="FieldInitializerSyntaxNotWithinSyntaxTree">
        <source>FieldInitializerSyntax not within syntax tree</source>
        <target state="translated">FieldInitializerSyntax 不在语法树中</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_TheSystemCannotFindThePathSpecified">
        <source>The system cannot find the path specified</source>
        <target state="translated">系统无法找到指定路径</target>
        <note />
      </trans-unit>
      <trans-unit id="ThereAreNoPointerTypesInVB">
        <source>There are no pointer types in VB.</source>
        <target state="translated">VB 中没有任何指针属性。</target>
        <note />
      </trans-unit>
      <trans-unit id="ThereIsNoDynamicTypeInVB">
        <source>There is no dynamic type in VB.</source>
        <target state="translated">VB 中没有任何动态类型。</target>
        <note />
      </trans-unit>
      <trans-unit id="VariableSyntaxNotWithinSyntaxTree">
        <source>variableSyntax not within syntax tree</source>
        <target state="translated">variableSyntax 不在语法树中</target>
        <note />
      </trans-unit>
      <trans-unit id="AggregateSyntaxNotWithinSyntaxTree">
        <source>AggregateSyntax not within syntax tree</source>
        <target state="translated">AggregateSyntax 未在语法树内</target>
        <note />
      </trans-unit>
      <trans-unit id="FunctionSyntaxNotWithinSyntaxTree">
        <source>FunctionSyntax not within syntax tree</source>
        <target state="translated">FunctionSyntax 不在语法树中</target>
        <note />
      </trans-unit>
      <trans-unit id="PositionIsNotWithinSyntax">
        <source>Position is not within syntax tree</source>
        <target state="translated">位置不在语法树中</target>
        <note />
      </trans-unit>
      <trans-unit id="RangeVariableSyntaxNotWithinSyntaxTree">
        <source>RangeVariableSyntax not within syntax tree</source>
        <target state="translated">RangeVariableSyntax 不在语法树中</target>
        <note />
      </trans-unit>
      <trans-unit id="DeclarationSyntaxNotWithinSyntaxTree">
        <source>DeclarationSyntax not within syntax tree</source>
        <target state="translated">DeclarationSyntax 未在语法树内</target>
        <note />
      </trans-unit>
      <trans-unit id="StatementOrExpressionIsNotAValidType">
        <source>StatementOrExpression is not an ExecutableStatementSyntax or an ExpressionSyntax</source>
        <target state="translated">StatementOrExpression 不是 ExecutableStatementSyntax 或 ExpressionSyntax</target>
        <note />
      </trans-unit>
      <trans-unit id="DeclarationSyntaxNotWithinTree">
        <source>DeclarationSyntax not within tree</source>
        <target state="translated">DeclarationSyntax 未在树内</target>
        <note />
      </trans-unit>
      <trans-unit id="TypeParameterNotWithinTree">
        <source>TypeParameter not within tree</source>
        <target state="translated">TypeParameter 不在树中</target>
        <note />
      </trans-unit>
      <trans-unit id="NotWithinTree">
        <source> not within tree</source>
        <target state="translated"> 不在树中</target>
        <note />
      </trans-unit>
      <trans-unit id="LocationMustBeProvided">
        <source>Location must be provided in order to provide minimal type qualification.</source>
        <target state="translated">必须提供位置才能提供最低程度的类型限定。</target>
        <note />
      </trans-unit>
      <trans-unit id="SemanticModelMustBeProvided">
        <source>SemanticModel must be provided in order to provide minimal type qualification.</source>
        <target state="translated">必须提供 SemanticModel 才能提供最低程度的类型限定。</target>
        <note />
      </trans-unit>
      <trans-unit id="NumberOfTypeParametersAndArgumentsMustMatch">
        <source>the number of type parameters and arguments should be the same</source>
        <target state="translated">类型形参和实参的数量应相同</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ResourceInModule">
        <source>Cannot link resource files when building a module</source>
        <target state="translated">生成模块时，无法链接资源文件</target>
        <note />
      </trans-unit>
      <trans-unit id="NotAVbSymbol">
        <source>Not a VB symbol.</source>
        <target state="translated">不是 VB 符号。</target>
        <note />
      </trans-unit>
      <trans-unit id="ElementsCannotBeNull">
        <source>Elements cannot be null.</source>
        <target state="translated">元素不能为 Null。</target>
        <note />
      </trans-unit>
      <trans-unit id="HDN_UnusedImportClause">
        <source>Unused import clause.</source>
        <target state="translated">未使用导入子句。</target>
        <note />
      </trans-unit>
      <trans-unit id="HDN_UnusedImportStatement">
        <source>Unused import statement.</source>
        <target state="translated">未使用导入语句。</target>
        <note />
      </trans-unit>
      <trans-unit id="WrongSemanticModelType">
        <source>Expected a {0} SemanticModel.</source>
        <target state="translated">应为 {0} SemanticModel。</target>
        <note />
      </trans-unit>
      <trans-unit id="PositionNotWithinTree">
        <source>Position must be within span of the syntax tree.</source>
        <target state="translated">位置必须处于语法树范围内。</target>
        <note />
      </trans-unit>
      <trans-unit id="SpeculatedSyntaxNodeCannotBelongToCurrentCompilation">
        <source>Syntax node to be speculated cannot belong to a syntax tree from the current compilation.</source>
        <target state="translated">要推断的语法节点不能属于来自当前编译的语法树。</target>
        <note />
      </trans-unit>
      <trans-unit id="ChainingSpeculativeModelIsNotSupported">
        <source>Chaining speculative semantic model is not supported. You should create a speculative model from the non-speculative ParentModel.</source>
        <target state="translated">不支持链接推理语义模型。应从非推理 ParentModel 创建推理模型。</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_ToolName">
        <source>Microsoft (R) Visual Basic Compiler</source>
        <target state="translated">Microsoft (R) Visual Basic 编译器</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_LogoLine1">
        <source>{0} version {1}</source>
        <target state="translated">{0} 版本 {1}</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_LogoLine2">
        <source>Copyright (C) Microsoft Corporation. All rights reserved.</source>
        <target state="translated">版权所有(C) Microsoft Corporation。保留所有权利。</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_LangVersions">
        <source>Supported language versions:</source>
        <target state="translated">支持的语言版本:</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_PdbLocalNameTooLong">
        <source>Local name '{0}' is too long for PDB.  Consider shortening or compiling without /debug.</source>
        <target state="translated">本地名称“{0}”对于 PDB 太长。请考虑缩短或在不使用 /debug 的情况下编译。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_PdbLocalNameTooLong_Title">
        <source>Local name is too long for PDB</source>
        <target state="translated">本地名称对于 PDB 太长</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_PdbUsingNameTooLong">
        <source>Import string '{0}' is too long for PDB.  Consider shortening or compiling without /debug.</source>
        <target state="translated">导入字符串“{0}”对于 PDB 太长。请考虑缩短或在不使用 /debug 的情况下编译。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_PdbUsingNameTooLong_Title">
        <source>Import string is too long for PDB</source>
        <target state="translated">导入字符串对 PDB 而言太长</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_XMLDocCrefToTypeParameter">
        <source>XML comment has a tag with a 'cref' attribute '{0}' that bound to a type parameter.  Use the &lt;typeparamref&gt; tag instead.</source>
        <target state="translated">XML 注释中的一个标记具有绑定到类型参数的“cref”特性“{0}”。请改用 &lt;typeparamref&gt; 标记。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_XMLDocCrefToTypeParameter_Title">
        <source>XML comment has a tag with a 'cref' attribute that bound to a type parameter</source>
        <target state="translated">XML 注释包含的一个标记具有绑定到类型参数的 "cref" 属性</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_LinkedNetmoduleMetadataMustProvideFullPEImage">
        <source>Linked netmodule metadata must provide a full PE image: '{0}'.</source>
        <target state="translated">链接 netmodule 元数据必须提供完整 PE 映像:“{0}”。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_AnalyzerCannotBeCreated">
        <source>An instance of analyzer {0} cannot be created from {1} : {2}.</source>
        <target state="translated">无法从 {1} 创建分析器 {0} 的实例: {2}。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_AnalyzerCannotBeCreated_Title">
        <source>Instance of analyzer cannot be created</source>
        <target state="translated">无法创建分析器实例</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NoAnalyzerInAssembly">
        <source>The assembly {0} does not contain any analyzers.</source>
        <target state="translated">程序集 {0} 不包含任何分析器。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NoAnalyzerInAssembly_Title">
        <source>Assembly does not contain any analyzers</source>
        <target state="translated">程序集不包含任何分析器</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UnableToLoadAnalyzer">
        <source>Unable to load analyzer assembly {0} : {1}.</source>
        <target state="translated">无法加载分析器程序集 {0}: {1}。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UnableToLoadAnalyzer_Title">
        <source>Unable to load analyzer assembly</source>
        <target state="translated">无法加载分析器程序集</target>
        <note />
      </trans-unit>
      <trans-unit id="INF_UnableToLoadSomeTypesInAnalyzer">
        <source>Skipping some types in analyzer assembly {0} due to a ReflectionTypeLoadException : {1}.</source>
        <target state="translated">正在跳过分析器程序集 {0} 中的某些类型，因为出现 ReflectionTypeLoadException: {1}。</target>
        <note />
      </trans-unit>
      <trans-unit id="INF_UnableToLoadSomeTypesInAnalyzer_Title">
        <source>Skip loading types in analyzer assembly that fail due to a ReflectionTypeLoadException</source>
        <target state="translated">跳过加载分析器程序集中因 ReflectionTypeLoadException 而失败的类型</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CantReadRulesetFile">
        <source>Error reading ruleset file {0} - {1}</source>
        <target state="translated">读取规则集文件 {0} 时出错 - {1}</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PlatformDoesntSupport">
        <source>{0} is not supported in current project type.</source>
        <target state="translated">当前项目类型不支持 {0}。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CantUseRequiredAttribute">
        <source>The RequiredAttribute attribute is not permitted on Visual Basic types.</source>
        <target state="translated">Visual Basic 类型上不允许有 RequiredAttribute 特性。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_EncodinglessSyntaxTree">
        <source>Cannot emit debug information for a source text without encoding.</source>
        <target state="translated">无法在不进行编码的情况下发出源文本的调试信息。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InvalidFormatSpecifier">
        <source>'{0}' is not a valid format specifier</source>
        <target state="translated">'“{0}”不是有效的格式说明符</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InvalidPreprocessorConstantType">
        <source>Preprocessor constant '{0}' of type '{1}' is not supported, only primitive types are allowed.</source>
        <target state="translated">不支持“{1}”类型的预处理器常数“{0}”，仅允许使用基元类型。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExpectedWarningKeyword">
        <source>'Warning' expected.</source>
        <target state="translated">'应为“Warning”。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CannotBeMadeNullable1">
        <source>'{0}' cannot be made nullable.</source>
        <target state="translated">'“{0}”不可以为 Null。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadConditionalWithRef">
        <source>Leading '?' can only appear inside a 'With' statement, but not inside an object member initializer.</source>
        <target state="translated">以 "?" 开头的情况只能出现在“With”语句中，不能出现在对象成员初始值设定项中。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NullPropagatingOpInExpressionTree">
        <source>A null propagating operator cannot be converted into an expression tree.</source>
        <target state="translated">无法将 null 传播运算符转换为表达式树。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_TooLongOrComplexExpression">
        <source>An expression is too long or complex to compile</source>
        <target state="translated">表达式太长或者过于复杂，无法编译</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExpressionDoesntHaveName">
        <source>This expression does not have a name.</source>
        <target state="translated">该表达式不具有名称。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InvalidNameOfSubExpression">
        <source>This sub-expression cannot be used inside NameOf argument.</source>
        <target state="translated">此子表达式不能在 NameOf 参数中使用。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_MethodTypeArgsUnexpected">
        <source>Method type arguments unexpected.</source>
        <target state="translated">意外的方法类型参数。</target>
        <note />
      </trans-unit>
      <trans-unit id="NoNoneSearchCriteria">
        <source>SearchCriteria is expected.</source>
        <target state="translated">需要 SearchCriteria。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InvalidAssemblyCulture">
        <source>Assembly culture strings may not contain embedded NUL characters.</source>
        <target state="translated">程序集区域性字符串可能不包含嵌入式 NUL 字符。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InReferencedAssembly">
        <source>There is an error in a referenced assembly '{0}'.</source>
        <target state="translated">引用的程序集“{0}”中有错误。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InterpolationFormatWhitespace">
        <source>Format specifier may not contain trailing whitespace.</source>
        <target state="translated">格式说明符可能不包含尾随空格。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InterpolationAlignmentOutOfRange">
        <source>Alignment value is outside of the supported range.</source>
        <target state="translated">对齐值不在支持的范围内。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InterpolatedStringFactoryError">
        <source>There were one or more errors emitting a call to {0}.{1}. Method or its return type may be missing or malformed.</source>
        <target state="translated">向 {0}.{1} 发出调用时出现一个或多个错误。方法或其返回类型可能缺失或格式不正确。</target>
        <note />
      </trans-unit>
      <trans-unit id="HDN_UnusedImportClause_Title">
        <source>Unused import clause</source>
        <target state="translated">未使用 import 子句</target>
        <note />
      </trans-unit>
      <trans-unit id="HDN_UnusedImportStatement_Title">
        <source>Unused import statement</source>
        <target state="translated">未使用 import 语句</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ConstantStringTooLong">
        <source>Length of String constant resulting from concatenation exceeds System.Int32.MaxValue.  Try splitting the string into multiple constants.</source>
        <target state="translated">由串联所得的字符串常量长度超过了 System.Int32.MaxValue。请尝试将字符串拆分为多个常量。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_LanguageVersion">
        <source>Visual Basic {0} does not support {1}.</source>
        <target state="translated">Visual Basic {0} 不支持 {1}。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadPdbData">
        <source>Error reading debug information for '{0}'</source>
        <target state="translated">读取“{0}”的调试信息时出错</target>
        <note />
      </trans-unit>
      <trans-unit id="FEATURE_ArrayLiterals">
        <source>array literal expressions</source>
        <target state="translated">数组文本表达式</target>
        <note />
      </trans-unit>
      <trans-unit id="FEATURE_AsyncExpressions">
        <source>async methods or lambdas</source>
        <target state="translated">异步方法或 lambda</target>
        <note />
      </trans-unit>
      <trans-unit id="FEATURE_AutoProperties">
        <source>auto-implemented properties</source>
        <target state="translated">自动实现的属性</target>
        <note />
      </trans-unit>
      <trans-unit id="FEATURE_ReadonlyAutoProperties">
        <source>readonly auto-implemented properties</source>
        <target state="translated">自动实现的只读属性</target>
        <note />
      </trans-unit>
      <trans-unit id="FEATURE_CoContraVariance">
        <source>variance</source>
        <target state="translated">变型</target>
        <note />
      </trans-unit>
      <trans-unit id="FEATURE_CollectionInitializers">
        <source>collection initializers</source>
        <target state="translated">集合初始值设定项</target>
        <note />
      </trans-unit>
      <trans-unit id="FEATURE_GlobalNamespace">
        <source>declaring a Global namespace</source>
        <target state="translated">声明全局命名空间</target>
        <note />
      </trans-unit>
      <trans-unit id="FEATURE_Iterators">
        <source>iterators</source>
        <target state="translated">迭代器</target>
        <note />
      </trans-unit>
      <trans-unit id="FEATURE_LineContinuation">
        <source>implicit line continuation</source>
        <target state="translated">隐式行继续符</target>
        <note />
      </trans-unit>
      <trans-unit id="FEATURE_StatementLambdas">
        <source>multi-line lambda expressions</source>
        <target state="translated">多行 lambda 表达式</target>
        <note />
      </trans-unit>
      <trans-unit id="FEATURE_SubLambdas">
        <source>'Sub' lambda expressions</source>
        <target state="translated">'“Sub”lambda 表达式</target>
        <note />
      </trans-unit>
      <trans-unit id="FEATURE_NullPropagatingOperator">
        <source>null conditional operations</source>
        <target state="translated">空条件操作</target>
        <note />
      </trans-unit>
      <trans-unit id="FEATURE_NameOfExpressions">
        <source>'nameof' expressions</source>
        <target state="translated">'"nameof" 表达式</target>
        <note />
      </trans-unit>
      <trans-unit id="FEATURE_RegionsEverywhere">
        <source>region directives within method bodies or regions crossing boundaries of declaration blocks</source>
        <target state="translated">方法主体内的 region 指令或跨声明块边界的 region</target>
        <note />
      </trans-unit>
      <trans-unit id="FEATURE_MultilineStringLiterals">
        <source>multiline string literals</source>
        <target state="translated">多行字符串文本</target>
        <note />
      </trans-unit>
      <trans-unit id="FEATURE_CObjInAttributeArguments">
        <source>CObj in attribute arguments</source>
        <target state="translated">属性参数中的 CObj</target>
        <note />
      </trans-unit>
      <trans-unit id="FEATURE_LineContinuationComments">
        <source>line continuation comments</source>
        <target state="translated">行延续注释</target>
        <note />
      </trans-unit>
      <trans-unit id="FEATURE_TypeOfIsNot">
        <source>TypeOf IsNot expression</source>
        <target state="translated">TypeOf IsNot 表达式</target>
        <note />
      </trans-unit>
      <trans-unit id="FEATURE_YearFirstDateLiterals">
        <source>year-first date literals</source>
        <target state="translated">年份在最前面的日期文本</target>
        <note />
      </trans-unit>
      <trans-unit id="FEATURE_WarningDirectives">
        <source>warning directives</source>
        <target state="translated">warning 指令</target>
        <note />
      </trans-unit>
      <trans-unit id="FEATURE_PartialModules">
        <source>partial modules</source>
        <target state="translated">部分模块</target>
        <note />
      </trans-unit>
      <trans-unit id="FEATURE_PartialInterfaces">
        <source>partial interfaces</source>
        <target state="translated">部分接口</target>
        <note />
      </trans-unit>
      <trans-unit id="FEATURE_ImplementingReadonlyOrWriteonlyPropertyWithReadwrite">
        <source>implementing read-only or write-only property with read-write property</source>
        <target state="translated">使用读写属性实现只读或只写属性</target>
        <note />
      </trans-unit>
      <trans-unit id="FEATURE_DigitSeparators">
        <source>digit separators</source>
        <target state="translated">数字分隔符</target>
        <note />
      </trans-unit>
      <trans-unit id="FEATURE_BinaryLiterals">
        <source>binary literals</source>
        <target state="translated">二进制文字</target>
        <note />
      </trans-unit>
      <trans-unit id="FEATURE_Tuples">
        <source>tuples</source>
        <target state="translated">元组</target>
        <note />
      </trans-unit>
      <trans-unit id="FEATURE_PrivateProtected">
        <source>Private Protected</source>
        <target state="translated">Private Protected</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DebugEntryPointNotSourceMethodDefinition">
        <source>Debug entry point must be a definition of a method declared in the current compilation.</source>
        <target state="translated">调试入口点必须是当前编译中声明的方法的定义。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InvalidPathMap">
        <source>The pathmap option was incorrectly formatted.</source>
        <target state="translated">路径映射选项的格式不正确。</target>
        <note />
      </trans-unit>
      <trans-unit id="SyntaxTreeIsNotASubmission">
        <source>Syntax tree should be created from a submission.</source>
        <target state="translated">应从提交创建语法树。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_TooManyUserStrings">
        <source>Combined length of user strings used by the program exceeds allowed limit. Try to decrease use of string or XML literals.</source>
        <target state="translated">该程序所使用的用户字符串的合并后长度超出所允许的限制。请尝试减少字符串文本或 XML 文本的使用。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PeWritingFailure">
        <source>An error occurred while writing the output file: {0}</source>
        <target state="translated">写入输出文件时出错: {0}</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_OptionMustBeAbsolutePath">
        <source>Option '{0}' must be an absolute path.</source>
        <target state="translated">选项“{0}”必须是绝对路径。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_SourceLinkRequiresPdb">
        <source>/sourcelink switch is only supported when emitting PDB.</source>
        <target state="translated">只在发出 PDB 时才支持 /sourcelink 开关。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_TupleDuplicateElementName">
        <source>Tuple element names must be unique.</source>
        <target state="translated">元组元素名称必须是唯一的。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_TupleLiteralNameMismatch">
        <source>The tuple element name '{0}' is ignored because a different name or no name is specified by the target type '{1}'.</source>
        <target state="translated">由于目标类型“{1}”指定了其他名称或未指定名称，因此元组元素名称“{0}”被忽略。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_TupleLiteralNameMismatch_Title">
        <source>The tuple element name is ignored because a different name or no name is specified by the assignment target.</source>
        <target state="translated">由于分配目标指定了其他名称或未指定名称，因此元组元素名称被忽略。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_TupleReservedElementName">
        <source>Tuple element name '{0}' is only allowed at position {1}.</source>
        <target state="translated">只允许位置 {1} 使用元组元素名称“{0}”。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_TupleReservedElementNameAnyPosition">
        <source>Tuple element name '{0}' is disallowed at any position.</source>
        <target state="translated">任何位置都不允许使用元组元素名称“{0}”。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_TupleTooFewElements">
        <source>Tuple must contain at least two elements.</source>
        <target state="translated">元组必须包含至少两个元素。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_TupleElementNamesAttributeMissing">
        <source>Cannot define a class or member that utilizes tuples because the compiler required type '{0}' cannot be found. Are you missing a reference?</source>
        <target state="translated">由于找不到编译器必需的类型“{0}”，因此无法使用元组来定义类或成员。是否缺少引用?</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExplicitTupleElementNamesAttribute">
        <source>Cannot reference 'System.Runtime.CompilerServices.TupleElementNamesAttribute' explicitly. Use the tuple syntax to define tuple names.</source>
        <target state="translated">无法显式引用 "System.Runtime.CompilerServices.TupleElementNamesAttribute"。请使用元组语法指定元组名称。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RefReturningCallInExpressionTree">
        <source>An expression tree may not contain a call to a method or property that returns by reference.</source>
        <target state="translated">表达式树不能包含对引用所返回的方法或属性的调用。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CannotEmbedWithoutPdb">
        <source>/embed switch is only supported when emitting a PDB.</source>
        <target state="translated">仅在发出 PDB 时才支持 /embed 开关。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InvalidInstrumentationKind">
        <source>Invalid instrumentation kind: {0}</source>
        <target state="translated">无效的检测类型: {0}</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DocFileGen">
        <source>Error writing to XML documentation file: {0}</source>
        <target state="translated">写入 XML 文档文件时出错: {0}</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadAssemblyName">
        <source>Invalid assembly name: {0}</source>
        <target state="translated">无效的程序集名称: {0}</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_TypeForwardedToMultipleAssemblies">
        <source>Module '{0}' in assembly '{1}' is forwarding the type '{2}' to multiple assemblies: '{3}' and '{4}'.</source>
        <target state="translated">程序集“{1}”中的模块“{0}”将类型“{2}”转发到多个程序集: “{3}”和“{4}”。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_Merge_conflict_marker_encountered">
        <source>Merge conflict marker encountered</source>
        <target state="translated">遇到合并冲突标记</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NoRefOutWhenRefOnly">
        <source>Do not use refout when using refonly.</source>
        <target state="translated">不要在使用 refonly 时使用 refout。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NoNetModuleOutputWhenRefOutOrRefOnly">
        <source>Cannot compile net modules when using /refout or /refonly.</source>
        <target state="translated">无法在使用 /refout 或 /refonly 时编译 Net 模块。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadNonTrailingNamedArgument">
        <source>Named argument '{0}' is used out-of-position but is followed by an unnamed argument</source>
        <target state="translated">命名参数“{0}”的使用位置不当，但后跟一个未命名参数</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadDocumentationMode">
        <source>Provided documentation mode is unsupported or invalid: '{0}'.</source>
        <target state="translated">提供的文档模式不受支持或无效:“{0}”。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadLanguageVersion">
        <source>Provided language version is unsupported or invalid: '{0}'.</source>
        <target state="translated">提供的语言版本不受支持或无效:“{0}”。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadSourceCodeKind">
        <source>Provided source code kind is unsupported or invalid: '{0}'</source>
        <target state="translated">提供的源代码类型不受支持或无效:“{0}”</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_TupleInferredNamesNotAvailable">
        <source>Tuple element name '{0}' is inferred. Please use language version {1} or greater to access an element by its inferred name.</source>
        <target state="translated">推断出元组元素名称“{0}”。请使用语言版本 {1} 或更高版本按推断名称访问元素。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_Experimental">
        <source>'{0}' is for evaluation purposes only and is subject to change or removal in future updates.</source>
        <target state="translated">'“{0}”仅用于评估，在将来的更新中可能会被更改或删除。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_Experimental_Title">
        <source>Type is for evaluation purposes only and is subject to change or removal in future updates.</source>
        <target state="translated">类型仅用于评估，在将来的更新中可能会被更改或删除。</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InvalidDebugInfo">
        <source>Unable to read debug information of method '{0}' (token 0x{1}) from assembly '{2}'</source>
        <target state="translated">无法从程序集“{2}”读取方法“{0}”(令牌 0x{1})的调试信息</target>
        <note />
      </trans-unit>
      <trans-unit id="IConversionExpressionIsNotVisualBasicConversion">
        <source>{0} is not a valid Visual Basic conversion expression</source>
        <target state="translated">{0} 不是有效的 Visual Basic 转换表达式</target>
        <note />
      </trans-unit>
      <trans-unit id="IArgumentIsNotVisualBasicArgument">
        <source>{0} is not a valid Visual Basic argument</source>
        <target state="translated">{0} 不是有效的 Visual Basic 参数</target>
        <note />
      </trans-unit>
      <trans-unit id="FEATURE_LeadingDigitSeparator">
        <source>leading digit separator</source>
        <target state="translated">前导数字分隔符</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ValueTupleResolutionAmbiguous3">
        <source>Predefined type '{0}' is declared in multiple referenced assemblies: '{1}' and '{2}'</source>
        <target state="translated">已在多个引用的程序集(“{1}”和“{2}”)中声明了预定义类型“{0}”。</target>
        <note />
      </trans-unit>
      <trans-unit id="ICompoundAssignmentOperationIsNotVisualBasicCompoundAssignment">
        <source>{0} is not a valid Visual Basic compound assignment operation</source>
        <target state="translated">{0} 不是有效的 Visual Basic 复合赋值运算</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InvalidHashAlgorithmName">
        <source>Invalid hash algorithm name: '{0}'</source>
        <target state="translated">无效的哈希算法名称:“{0}”</target>
        <note />
      </trans-unit>
      <trans-unit id="FEATURE_InterpolatedStrings">
        <source>interpolated strings</source>
        <target state="translated">内插字符串</target>
        <note />
      </trans-unit>
      <trans-unit id="FTL_InvalidInputFileName">
        <source>File name '{0}' is empty, contains invalid characters, has a drive specification without an absolute path, or is too long</source>
        <target state="translated">文件名“{0}”为空、包含无效字符、未使用绝对路径指定驱动器或太长</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_AttributeNotSupportedInVB">
        <source>'{0}' is not supported in VB.</source>
        <target state="translated">VB 中不支持“{0}”。</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_AttributeNotSupportedInVB_Title">
        <source>Attribute is not supported in VB</source>
        <target state="translated">VB 中不支持属性</target>
        <note />
      </trans-unit>
    </body>
  </file>
</xliff>