<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" source-language="en" target-language="ko" original="../VBResources.resx">
    <body>
      <trans-unit id="ERR_AssignmentInitOnly">
        <source>Init-only property '{0}' can only be assigned by an object member initializer, or on 'Me', 'MyClass` or 'MyBase' in an instance constructor.</source>
        <target state="translated">초기값 전용 속성 '{0}'은(는) 개체 멤버 이니셜라이저에 의해서나 인스턴스 생성자의 'Me', 'MyClass` 또는 'MyBase'에만 할당할 수 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadSwitchValue">
        <source>Command-line syntax error: '{0}' is not a valid value for the '{1}' option. The value must be of the form '{2}'.</source>
        <target state="translated">명령줄 구문 오류: '{0}'은(는) '{1}' 옵션에 유효한 값이 아닙니다. 값은 '{2}' 형식이어야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CommentsAfterLineContinuationNotAvailable1">
        <source>Please use language version {0} or greater to use comments after line continuation character.</source>
        <target state="translated">줄 연속 문자 뒤에 주석을 사용하려면 언어 버전 {0} 이상을 사용하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DefaultInterfaceImplementationInNoPIAType">
        <source>Type '{0}' cannot be embedded because it has a non-abstract member. Consider setting the 'Embed Interop Types' property to false.</source>
        <target state="translated">'{0}' 형식에는 비추상 멤버가 있으므로 해당 형식을 포함할 수 없습니다. 'Interop 형식 포함' 속성을 false로 설정해보세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_MultipleAnalyzerConfigsInSameDir">
        <source>Multiple analyzer config files cannot be in the same directory ('{0}').</source>
        <target state="translated">분석기 구성 파일 여러 개가 동일한 디렉터리('{0}')에 있을 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_OverridingInitOnlyProperty">
        <source>'{0}' cannot override init-only '{1}'.</source>
        <target state="translated">'{0}'은(는) 초기값 전용 '{1}'을(를) 재정의할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PropertyDoesntImplementInitOnly">
        <source>Init-only '{0}' cannot be implemented.</source>
        <target state="translated">초기값 전용 '{0}'을(를) 구현할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ReAbstractionInNoPIAType">
        <source>Type '{0}' cannot be embedded because it has a re-abstraction of a member from base interface. Consider setting the 'Embed Interop Types' property to false.</source>
        <target state="translated">'{0}' 형식에는 기본 인터페이스 멤버의 재추상화가 있으므로 해당 형식을 포함할 수 없습니다. 'Interop 형식 포함' 속성을 false로 설정해 보세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RuntimeDoesNotSupportDefaultInterfaceImplementation">
        <source>Target runtime doesn't support default interface implementation.</source>
        <target state="translated">대상 런타임이 기본 인터페이스 구현을 지원하지 않습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RuntimeDoesNotSupportProtectedAccessForInterfaceMember">
        <source>Target runtime doesn't support 'Protected', 'Protected Friend', or 'Private Protected' accessibility for a member of an interface.</source>
        <target state="translated">대상 런타임은 인터페이스의 멤버에 대해 'Protected', 'Protected Friend' 또는 'Private Protected' 접근성을 지원하지 않습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_SharedEventNeedsHandlerInTheSameType">
        <source>Events of shared WithEvents variables cannot be handled by methods in a different type.</source>
        <target state="translated">공유 WithEvents 변수의 이벤트는 다른 형식의 메서드에서 처리할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_UnmanagedCallersOnlyNotSupported">
        <source>'UnmanagedCallersOnly' attribute is not supported.</source>
        <target state="new">'UnmanagedCallersOnly' attribute is not supported.</target>
        <note />
      </trans-unit>
      <trans-unit id="FEATURE_CommentsAfterLineContinuation">
        <source>comments after line continuation</source>
        <target state="translated">줄 연속 뒤 주석</target>
        <note />
      </trans-unit>
      <trans-unit id="FEATURE_InitOnlySettersUsage">
        <source>assigning to or passing 'ByRef' properties with init-only setters</source>
        <target state="translated">초기값 전용 setter를 사용하여 'ByRef' 속성에 할당 또는 이 속성을 전달</target>
        <note />
      </trans-unit>
      <trans-unit id="FEATURE_UnconstrainedTypeParameterInConditional">
        <source>unconstrained type parameters in binary conditional expressions</source>
        <target state="translated">이진 조건식의 비제한 형식 매개 변수</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_VBCHelp">
        <source>                  Visual Basic Compiler Options

                                  - OUTPUT FILE -
-out:&lt;file&gt;                       Specifies the output file name.
-target:exe                       Create a console application (default).
                                  (Short form: -t)
-target:winexe                    Create a Windows application.
-target:library                   Create a library assembly.
-target:module                    Create a module that can be added to an
                                  assembly.
-target:appcontainerexe           Create a Windows application that runs in
                                  AppContainer.
-target:winmdobj                  Create a Windows Metadata intermediate file
-doc[+|-]                         Generates XML documentation file.
-doc:&lt;file&gt;                       Generates XML documentation file to &lt;file&gt;.
-refout:&lt;file&gt;                    Reference assembly output to generate

                                  - INPUT FILES -
-addmodule:&lt;file_list&gt;            Reference metadata from the specified modules
-link:&lt;file_list&gt;                 Embed metadata from the specified interop
                                  assembly. (Short form: -l)
-recurse:&lt;wildcard&gt;               Include all files in the current directory
                                  and subdirectories according to the
                                  wildcard specifications.
-reference:&lt;file_list&gt;            Reference metadata from the specified
                                  assembly. (Short form: -r)
-analyzer:&lt;file_list&gt;             Run the analyzers from this assembly
                                  (Short form: -a)
-additionalfile:&lt;file list&gt;       Additional files that don't directly affect code
                                  generation but may be used by analyzers for producing
                                  errors or warnings.

                                  - RESOURCES -
-linkresource:&lt;resinfo&gt;           Links the specified file as an external
                                  assembly resource.
                                  resinfo:&lt;file&gt;[,&lt;name&gt;[,public|private]]
                                  (Short form: -linkres)
-nowin32manifest                  The default manifest should not be embedded
                                  in the manifest section of the output PE.
-resource:&lt;resinfo&gt;               Adds the specified file as an embedded
                                  assembly resource.
                                  resinfo:&lt;file&gt;[,&lt;name&gt;[,public|private]]
                                  (Short form: -res)
-win32icon:&lt;file&gt;                 Specifies a Win32 icon file (.ico) for the
                                  default Win32 resources.
-win32manifest:&lt;file&gt;             The provided file is embedded in the manifest
                                  section of the output PE.
-win32resource:&lt;file&gt;             Specifies a Win32 resource file (.res).

                                  - CODE GENERATION -
-optimize[+|-]                    Enable optimizations.
-removeintchecks[+|-]             Remove integer checks. Default off.
-debug[+|-]                       Emit debugging information.
-debug:full                       Emit full debugging information (default).
-debug:pdbonly                    Emit full debugging information.
-debug:portable                   Emit cross-platform debugging information.
-debug:embedded                   Emit cross-platform debugging information into
                                  the target .dll or .exe.
-deterministic                    Produce a deterministic assembly
                                  (including module version GUID and timestamp)
-refonly                          Produce a reference assembly in place of the main output
-instrument:TestCoverage          Produce an assembly instrumented to collect
                                  coverage information
-sourcelink:&lt;file&gt;                Source link info to embed into PDB.

                                  - ERRORS AND WARNINGS -
-nowarn                           Disable all warnings.
-nowarn:&lt;number_list&gt;             Disable a list of individual warnings.
-warnaserror[+|-]                 Treat all warnings as errors.
-warnaserror[+|-]:&lt;number_list&gt;   Treat a list of warnings as errors.
-ruleset:&lt;file&gt;                   Specify a ruleset file that disables specific
                                  diagnostics.
-errorlog:&lt;file&gt;[,version=&lt;sarif_version&gt;]         
                                  Specify a file to log all compiler and analyzer
                                  diagnostics in SARIF format.
                                  sarif_version:{1|2|2.1} Default is 1. 2 and 2.1
                                  both mean SARIF version 2.1.0.
-reportanalyzer                   Report additional analyzer information, such as
                                  execution time.
-skipanalyzers[+|-]               Skip execution of diagnostic analyzers.

                                  - LANGUAGE -
-define:&lt;symbol_list&gt;             Declare global conditional compilation
                                  symbol(s). symbol_list:name=value,...
                                  (Short form: -d)
-imports:&lt;import_list&gt;            Declare global Imports for namespaces in
                                  referenced metadata files.
                                  import_list:namespace,...
-langversion:?                    Display the allowed values for language version
-langversion:&lt;string&gt;             Specify language version such as
                                  `default` (latest major version), or
                                  `latest` (latest version, including minor versions),
                                  or specific versions like `14` or `15.3`
-optionexplicit[+|-]              Require explicit declaration of variables.
-optioninfer[+|-]                 Allow type inference of variables.
-rootnamespace:&lt;string&gt;           Specifies the root Namespace for all type
                                  declarations.
-optionstrict[+|-]                Enforce strict language semantics.
-optionstrict:custom              Warn when strict language semantics are not
                                  respected.
-optioncompare:binary             Specifies binary-style string comparisons.
                                  This is the default.
-optioncompare:text               Specifies text-style string comparisons.

                                  - MISCELLANEOUS -
-help                             Display this usage message. (Short form: -?)
-noconfig                         Do not auto-include VBC.RSP file.
-nologo                           Do not display compiler copyright banner.
-quiet                            Quiet output mode.
-verbose                          Display verbose messages.
-parallel[+|-]                    Concurrent build.
-version                          Display the compiler version number and exit.

                                  - ADVANCED -
-baseaddress:&lt;number&gt;             The base address for a library or module
                                  (hex).
-checksumalgorithm:&lt;alg&gt;          Specify algorithm for calculating source file
                                  checksum stored in PDB. Supported values are:
                                  SHA1 or SHA256 (default).
-codepage:&lt;number&gt;                Specifies the codepage to use when opening
                                  source files.
-delaysign[+|-]                   Delay-sign the assembly using only the public
                                  portion of the strong name key.
-publicsign[+|-]                  Public-sign the assembly using only the public
                                  portion of the strong name key.
-errorreport:&lt;string&gt;             Specifies how to handle internal compiler
                                  errors; must be prompt, send, none, or queue
                                  (default).
-filealign:&lt;number&gt;               Specify the alignment used for output file
                                  sections.
-highentropyva[+|-]               Enable high-entropy ASLR.
-keycontainer:&lt;string&gt;            Specifies a strong name key container.
-keyfile:&lt;file&gt;                   Specifies a strong name key file.
-libpath:&lt;path_list&gt;              List of directories to search for metadata
                                  references. (Semi-colon delimited.)
-main:&lt;class&gt;                     Specifies the Class or Module that contains
                                  Sub Main. It can also be a Class that
                                  inherits from System.Windows.Forms.Form.
                                  (Short form: -m)
-moduleassemblyname:&lt;string&gt;      Name of the assembly which this module will
                                  be a part of.
-netcf                            Target the .NET Compact Framework.
-nostdlib                         Do not reference standard libraries
                                  (system.dll and VBC.RSP file).
-pathmap:&lt;K1&gt;=&lt;V1&gt;,&lt;K2&gt;=&lt;V2&gt;,...
                                  Specify a mapping for source path names output by
                                  the compiler.
-platform:&lt;string&gt;                Limit which platforms this code can run on;
                                  must be x86, x64, Itanium, arm, arm64
                                  AnyCPU32BitPreferred or anycpu (default).
-preferreduilang                  Specify the preferred output language name.
-nosdkpath                        Disable searching the default SDK path for standard library assemblies.
-sdkpath:&lt;path&gt;                   Location of the .NET Framework SDK directory
                                  (mscorlib.dll).
-subsystemversion:&lt;version&gt;       Specify subsystem version of the output PE.
                                  version:&lt;number&gt;[.&lt;number&gt;]
-utf8output[+|-]                  Emit compiler output in UTF8 character
                                  encoding.
@&lt;file&gt;                           Insert command-line settings from a text file
-vbruntime[+|-|*]                 Compile with/without the default Visual Basic
                                  runtime.
-vbruntime:&lt;file&gt;                 Compile with the alternate Visual Basic
                                  runtime in &lt;file&gt;.
</source>
        <target state="translated">                  Visual Basic 컴파일러 옵션

                                  - 출력 파일 -
-out:&lt;file&gt;                        출력 파일 이름을 지정합니다.
-target:exe                       콘솔 애플리케이션을 만듭니다(기본값).
                                  (약식: -t)
-target:winexe                    Windows 애플리케이션을 만듭니다.
-target:library                   라이브러리 어셈블리를 만듭니다.
-target:module                    어셈블리에 추가할 수 있는 모듈을
                                  만듭니다.
-target:appcontainerexe           AppContainer에서 실행되는 Windows 애플리케이션을
                                  만듭니다.
-target:winmdobj                  Windows 메타데이터 중간 파일을 만듭니다.
-doc[+|-]                         XML 문서 파일을 생성합니다.
-doc:&lt;file&gt;                        XML 문서 파일을 &lt;file&gt;에 생성합니다.
-refout:&lt;file&gt;                     생성할 참조 어셈블리 출력입니다.

                                  - 입력 파일 -
-addmodule:&lt;file_list&gt;            지정한 모듈의 메타데이터를 참조합니다.
-link:&lt;file_list&gt;                 지정한 interop 어셈블리의 메타데이터를
                                  포함합니다. (약식: -l)
-recurse:&lt;wildcard&gt;                와일드카드 지정에 따라 현재 디렉터리와
                                  하위 디렉터리에 있는 모든 파일을
                                  포함합니다.
-reference:&lt;file_list&gt;            지정한 어셈블리 파일의 메타데이터를
                                  참조합니다. (약식: -r)
-analyzer:&lt;file_list&gt;             이 어셈블리에서 분석기를 실행합니다.
                                  (약식: -a)
-additionalfile:&lt;file list&gt;       코드 생성에 직접적인 영향을 주지 않지만
                                  오류 또는 경고 생성을 위해 분석기에서 사용될 수 있는
                                  추가 파일입니다.

                                  - 리소스 -
-linkresource:&lt;resinfo&gt;           지정한 파일을 외부 어셈블리
                                  리소스로 연결합니다.
                                  resinfo:&lt;file&gt;[,&lt;name&gt;[,public|private]]
                                  (약식: -linkres)
-nowin32manifest                  기본 매니페스트는 출력 PE의 매니페스트 섹션에
                                  포함하면 안 됩니다.
-resource:&lt;resinfo&gt;               지정한 파일을 포함된 어셈블리
                                  리소스로 추가합니다.
                                  resinfo:&lt;file&gt;[,&lt;name&gt;[,public|private]]
                                  (약식: -res)
-win32icon:&lt;file&gt;                  기본 Win32 리소스에 사용되는 Win32 아이콘 파일(.ico)을
                                  지정합니다.
-win32manifest:&lt;file&gt;              제공한 파일이 출력 PE의 매니페스트
                                  섹션에 포함됩니다.
-win32resource:&lt;file&gt;              Win32 리소스 파일(.res)을 지정합니다.

                                  - 코드 생성 -
-optimize[+|-]                    최적화를 사용하도록 설정합니다.
-removeintchecks[+|-]             정수 오류 검사를 제거합니다. 기본값은 off입니다.
-debug[+|-]                       디버깅 정보를 내보냅니다.
-debug:full                       전체 디버깅 정보를 내보냅니다(기본값).
-debug:pdbonly                    전체 디버깅 정보를 내보냅니다.
-debug:portable                   플랫폼 간 디버깅 정보를 내보냅니다.
-debug:embedded                   플랫폼 간 디버깅 정보를 대상 .dll 또는 .exe로
                                  내보냅니다.
-deterministic                    결정적 어셈블리를 생성합니다
                                  (모듈 버전 GUID 및 타임스탬프 포함).
-refonly                          주 출력 대신 참조 어셈블리를 생성합니다.
-instrument:TestCoverage          검사 정보를 수집하기 위해 계측한
                                  어셈블리를 생성합니다.
-sourcelink:&lt;file&gt;                 PDB에 포함할 소스 링크 정보입니다.

                                  - 오류 및 경고 -
-nowarn                           모든 경고를 사용하지 않도록 설정합니다.
-nowarn:&lt;number_list&gt;             개별 경고 목록을 사용하지 않도록 설정합니다.
-warnaserror[+|-]                 모든 경고를 오류로 처리합니다.
-warnaserror[+|-]:&lt;number_list&gt;   경고 목록을 오류로 처리합니다.
-ruleset:&lt;file&gt;                    특정 진단을 사용하지 않도록 설정하는 규칙 집합 파일을
                                  지정합니다.
-errorlog:&lt;file&gt;[,version=&lt;sarif_version&gt;]         
                                  모든 컴파일러 및 분석기 진단을 기록할 파일을
                                  SARIF 형식으로 지정합니다.
                                  sarif_version:{1|2|2.1} 기본값 1. 2와 2.1은 모두
                                  SARIF 버전 2.1.0을 의미합니다.
-reportanalyzer                   추가 분석기 정보(예: 실행 시간)를
                                  보고합니다.
-skipanalyzers[+|-]               진단 분석기의 실행을 건너뜁니다.

                                  - 언어 -
-define:&lt;symbol_list&gt;             전역 조건부 컴파일 기호를
                                  선언합니다. symbol_list:name=value,...
                                  (약식: -d)
-imports:&lt;import_list&gt;            참조된 메타데이터 파일에 있는 네임스페이스의
                                  전역 가져오기를 선언합니다.
                                  import_list:namespace,...
-langversion:?                    언어 버전에 허용되는 값을 표시합니다.
-langversion:&lt;string&gt;               언어 버전을
                                  'default'(최신 주 버전),
                                  'latest'(최신 버전, 부 버전 포함),
                                  '14' 또는 '15.3' 같은 특정 버전으로 지정합니다.
-optionexplicit[+|-]              변수의 명시적 선언을 요구합니다.
-optioninfer[+|-]                 변수의 형식 유추를 허용합니다.
-rootnamespace:&lt;string&gt;             모든 형식 선언의 루트 네임스페이스를
                                  지정합니다.
-optionstrict[+|-]                엄격한 언어 의미 체계를 적용합니다.
-optionstrict:custom              엄격한 언어 의미 체계가 적용되지 않을 경우
                                  경고합니다.
-optioncompare:binary             이진 스타일 문자열 비교를 지정합니다.
                                  기본값입니다.
-optioncompare:text               텍스트 스타일 문자열 비교를 지정합니다.

                                  - 기타 -
-help                             사용법 메시지를 표시합니다. (약식: -?)
-noconfig                         VBC.RSP 파일을 자동으로 포함하지 않습니다.
-nologo                           컴파일러 저작권 배너를 표시하지 않습니다.
-quiet                            자동 출력 모드입니다.
-verbose                          자세한 메시지를 표시합니다.
-parallel[+|-]                    동시 빌드입니다.
-version                          컴파일러 버전 번호를 표시하고 종료합니다.

                                  - 고급 -
-baseaddress:&lt;number&gt;                라이브러리 또는 모듈의 기준
                                  주소(16진수)입니다.
-checksumalgorithm:&lt;alg&gt;          PDB에 저장된 소스 파일 체크섬을 계산하기 위한
                                  알고리즘을 지정합니다. 지원되는 값은
                                  SHA1 또는 SHA256(기본값)입니다.
-codepage:&lt;number&gt;                   소스 파일을 열 때 사용할 코드 페이지를
                                  지정합니다.
-delaysign[+|-]                   강력한 이름 키의 공개 부분만 사용하여
                                  어셈블리 서명을 연기합니다.
-publicsign[+|-]                  강력한 이름 키의 공개 부분만 사용하여
                                  어셈블리에 공개 서명합니다.
-errorreport:&lt;string&gt;               내부 컴파일러 오류를 처리하는 방법을
                                  prompt, send, none 또는 queue(기본값)로
                                  지정합니다.
-filealign:&lt;number&gt;                  출력 파일 섹션에 사용되는 맞춤을
                                  지정합니다.
-highentropyva[+|-]               높은 엔트로피 ASLR을 사용하도록 설정합니다.
-keycontainer:&lt;string&gt;              강력한 이름의 키 컨테이너를 지정합니다.
-keyfile:&lt;file&gt;                    강력한 이름의 키 파일을 지정합니다.
-libpath:&lt;path_list&gt;              메타데이터 참조를 검색할 디렉터리
                                  목록이며 세미콜론으로 구분됩니다.
-main:&lt;class&gt;                      Sub Main을 포함하는 클래스 또는 모듈을
                                  지정합니다. System.Windows.Forms.Form에서 상속하는
                                  클래스를 사용할 수도 있습니다.
                                  (약식: -m)
-moduleassemblyname:&lt;string&gt;        이 모듈이 속할 어셈블리의
                                  이름입니다.
-netcf                            .NET Compact Framework를 대상으로 지정합니다.
-nostdlib                         표준 라이브러리(system.dll 및 VBC.RSP 파일)를
                                  참조하지 않습니다.
-pathmap:&lt;K1&gt;=&lt;V1&gt;,&lt;K2&gt;=&lt;V2&gt;,...
                                  컴파일러에서 출력된 소스 경로 이름에 대한
                                  매핑을 지정합니다.
-platform:&lt;string&gt;                  이 코드를 실행할 수 있는 플랫폼을
                                  x86, x64, Itanium, arm, arm64,
                                  AnyCPU32BitPreferred 또는 anycpu(기본값)로 제한합니다.
-preferreduilang                  기본 출력 언어 이름을 지정합니다.
-nosdkpath                        기본 SDK 경로에서 표준 라이브러리 어셈블리를 검색하지 않도록 설정합니다.
-sdkpath:&lt;path&gt;                    .NET Framework SDK 디렉터리(mscorlib.dll)의
                                  위치입니다.
-subsystemversion:&lt;version&gt;           출력 PE의 하위 시스템 버전을 지정합니다.
                                  version:&lt;number&gt;[.&lt;number&gt;]
-utf8output[+|-]                  컴파일러 출력을 UTF8 문자 인코딩으로
                                  내보냅니다.
@&lt;file&gt;                            텍스트 파일에서 명령줄 설정을 삽입합니다.
-vbruntime[+|-|*]                 기본 Visual Basic 런타임을 사용하거나 사용하지 않고
                                  컴파일합니다.
-vbruntime:&lt;file&gt;                  &lt;file&gt;의 대체 Visual Basic 런타임을 사용하여
                                  컴파일합니다.
</target>
        <note />
      </trans-unit>
      <trans-unit id="ThereAreNoFunctionPointerTypesInVB">
        <source>There are no function pointer types in VB.</source>
        <target state="translated">VB에 함수 포인터 형식이 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ThereAreNoNativeIntegerTypesInVB">
        <source>There are no native integer types in VB.</source>
        <target state="translated">VB에는 원시 정수 형식이 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="Trees0">
        <source>trees({0})</source>
        <target state="translated">트리({0})</target>
        <note />
      </trans-unit>
      <trans-unit id="TreesMustHaveRootNode">
        <source>trees({0}) must have root node with SyntaxKind.CompilationUnit.</source>
        <target state="translated">트리({0})는 SyntaxKind.CompilationUnit을 사용하는 루트 노드여야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="CannotAddCompilerSpecialTree">
        <source>Cannot add compiler special tree</source>
        <target state="translated">컴파일러 특별 트리를 추가할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="SyntaxTreeAlreadyPresent">
        <source>Syntax tree already present</source>
        <target state="translated">구문 트리가 이미 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="SubmissionCanHaveAtMostOneSyntaxTree">
        <source>Submission can have at most one syntax tree.</source>
        <target state="translated">구문 트리를 최대 하나만 제출할 수 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="CannotRemoveCompilerSpecialTree">
        <source>Cannot remove compiler special tree</source>
        <target state="translated">컴파일러 특별 트리를 제거할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="SyntaxTreeNotFoundToRemove">
        <source>SyntaxTree '{0}' not found to remove</source>
        <target state="translated">제거할 '{0}' SyntaxTree를 찾을 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="TreeMustHaveARootNodeWithCompilationUnit">
        <source>Tree must have a root node with SyntaxKind.CompilationUnit</source>
        <target state="translated">트리는 SyntaxKind.CompilationUnit을 사용하는 루트 노드여야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="CompilationVisualBasic">
        <source>Compilation (Visual Basic): </source>
        <target state="translated">컴파일(Visual Basic): </target>
        <note />
      </trans-unit>
      <trans-unit id="NodeIsNotWithinSyntaxTree">
        <source>Node is not within syntax tree</source>
        <target state="translated">노드가 구문 트리 내에 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="CantReferenceCompilationFromTypes">
        <source>Can't reference compilation of type '{0}' from {1} compilation.</source>
        <target state="translated">{1} 컴파일에서 '{0}' 형식의 컴파일을 참조할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="PositionOfTypeParameterTooLarge">
        <source>position of type parameter too large</source>
        <target state="translated">형식 매개 변수 위치가 너무 깁니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="AssociatedTypeDoesNotHaveTypeParameters">
        <source>Associated type does not have type parameters</source>
        <target state="translated">연결된 형식에 형식 매개 변수가 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_FunctionReturnType">
        <source>function return type</source>
        <target state="translated">함수 반환 형식</target>
        <note />
      </trans-unit>
      <trans-unit id="TypeArgumentCannotBeNothing">
        <source>Type argument cannot be Nothing</source>
        <target state="translated">형식 인수는 Nothing일 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_AnalyzerReferencesFramework">
        <source>The assembly '{0}' containing type '{1}' references .NET Framework, which is not supported.</source>
        <target state="translated">'{1}' 형식을 포함하는 '{0}' 어셈블리가 지원되지 않는 .NET Framework를 참조합니다.</target>
        <note>{1} is the type that was loaded, {0} is the containing assembly.</note>
      </trans-unit>
      <trans-unit id="WRN_AnalyzerReferencesFramework_Title">
        <source>The loaded assembly references .NET Framework, which is not supported.</source>
        <target state="translated">로드된 어셈블리가 지원되지 않는 .NET Framework를 참조합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_GeneratorFailedDuringGeneration">
        <source>Generator '{0}' failed to generate source. It will not contribute to the output and compilation errors may occur as a result. Exception was of type '{1}' with message '{2}'</source>
        <target state="translated">생성기 '{0}'이(가) 소스를 생성하지 못했습니다. 출력에 기여하지 않으므로 컴파일 오류가 발생할 수 있습니다. 예외의 형식은 '{1}'이고 메시지는 '{2}'입니다.</target>
        <note>{0} is the name of the generator that failed. {1} is the type of exception that was thrown {2} is the message in the exception</note>
      </trans-unit>
      <trans-unit id="WRN_GeneratorFailedDuringGeneration_Description">
        <source>Generator threw the following exception:
'{0}'.</source>
        <target state="translated">생성기에서 다음 예외를 throw했습니다.
'{0}'.</target>
        <note>{0} is the string representation of the exception that was thrown.</note>
      </trans-unit>
      <trans-unit id="WRN_GeneratorFailedDuringGeneration_Title">
        <source>Generator failed to generate source.</source>
        <target state="translated">생성기가 소스를 생성하지 못했습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_GeneratorFailedDuringInitialization">
        <source>Generator '{0}' failed to initialize. It will not contribute to the output and compilation errors may occur as a result. Exception was of type '{1}' with message '{2}'</source>
        <target state="translated">생성기 '{0}'이(가) 초기화하지 못했습니다. 출력에 기여하지 않으므로 컴파일 오류가 발생할 수 있습니다. 예외의 형식은 '{1}'이고 메시지는 '{2}'입니다.</target>
        <note>{0} is the name of the generator that failed. {1} is the type of exception that was thrown {2} is the message in the exception</note>
      </trans-unit>
      <trans-unit id="WRN_GeneratorFailedDuringInitialization_Description">
        <source>Generator threw the following exception:
'{0}'.</source>
        <target state="translated">생성기에서 다음 예외를 throw했습니다.
'{0}'.</target>
        <note>{0} is the string representation of the exception that was thrown.</note>
      </trans-unit>
      <trans-unit id="WRN_GeneratorFailedDuringInitialization_Title">
        <source>Generator failed to initialize.</source>
        <target state="translated">생성기가 초기화하지 못했습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="WrongNumberOfTypeArguments">
        <source>Wrong number of type arguments</source>
        <target state="translated">형식 인수 수가 잘못되었습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_FileNotFound">
        <source>file '{0}' could not be found</source>
        <target state="translated">'{0}' 파일을 찾을 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NoResponseFile">
        <source>unable to open response file '{0}'</source>
        <target state="translated">'{0}' 응답 파일을 열 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ArgumentRequired">
        <source>option '{0}' requires '{1}'</source>
        <target state="translated">'{0}' 옵션을 사용하려면 '{1}'이(가) 필요합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_SwitchNeedsBool">
        <source>option '{0}' can be followed only by '+' or '-'</source>
        <target state="translated">'{0}' 옵션 뒤에는 '+' 또는 '-'만 올 수 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InvalidSwitchValue">
        <source>the value '{1}' is invalid for option '{0}'</source>
        <target state="translated">'{1}' 값은 '{0}' 옵션에 사용할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_MutuallyExclusiveOptions">
        <source>Compilation options '{0}' and '{1}' can't both be specified at the same time.</source>
        <target state="translated">컴파일 옵션 '{0}'과(와) '{1}'을(를) 동시에 지정할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_BadUILang">
        <source>The language name '{0}' is invalid.</source>
        <target state="translated">'{0}' 언어 이름이 잘못되었습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_BadUILang_Title">
        <source>The language name for /preferreduilang is invalid</source>
        <target state="translated">/preferreduilang의 언어 이름이 잘못됨</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_VBCoreNetModuleConflict">
        <source>The options /vbruntime* and /target:module cannot be combined.</source>
        <target state="translated">/vbruntime* 옵션과 /target:module 옵션은 함께 사용할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InvalidFormatForGuidForOption">
        <source>Command-line syntax error: Invalid Guid format '{0}' for option '{1}'</source>
        <target state="translated">명령줄 구문 오류: '{1}' 옵션에 대해 잘못된 '{0}' Guid 형식입니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_MissingGuidForOption">
        <source>Command-line syntax error: Missing Guid for option '{1}'</source>
        <target state="translated">명령줄 구문 오류: '{1}' 옵션에 대한 Guid가 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadChecksumAlgorithm">
        <source>Algorithm '{0}' is not supported</source>
        <target state="translated">'{0}' 알고리즘은 지원되지 않습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_BadSwitch">
        <source>unrecognized option '{0}'; ignored</source>
        <target state="translated">인식할 수 없는 '{0}' 옵션입니다. 무시됩니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_BadSwitch_Title">
        <source>Unrecognized command-line option</source>
        <target state="translated">인식할 수 없는 명령줄 옵션</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NoSources">
        <source>no input sources specified</source>
        <target state="translated">입력 소스를 지정하지 않았습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_FileAlreadyIncluded">
        <source>source file '{0}' specified multiple times</source>
        <target state="translated">'{0}' 소스 파일을 여러 번 지정했습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_FileAlreadyIncluded_Title">
        <source>Source file specified multiple times</source>
        <target state="translated">소스 파일이 여러 번 지정되었습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CantOpenFileWrite">
        <source>can't open '{0}' for writing: {1}</source>
        <target state="translated">'{0}'을(를) 쓰기용으로 열 수 없습니다('{1}').</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadCodepage">
        <source>code page '{0}' is invalid or not installed</source>
        <target state="translated">'{0}' 코드 페이지가 잘못되었거나 설치되어 있지 않습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BinaryFile">
        <source>the file '{0}' is not a text file</source>
        <target state="translated">'{0}' 파일은 텍스트 파일이 아닙니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_LibNotFound">
        <source>could not find library '{0}'</source>
        <target state="translated">'{0}' 라이브러리가 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_MetadataReferencesNotSupported">
        <source>Metadata references not supported.</source>
        <target state="translated">메타데이터 참조는 지원되지 않습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_IconFileAndWin32ResFile">
        <source>cannot specify both /win32icon and /win32resource</source>
        <target state="translated">/win32icon과 /win32resource를 모두 지정할 수는 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NoConfigInResponseFile">
        <source>ignoring /noconfig option because it was specified in a response file</source>
        <target state="translated">지시 파일에 지정되었기 때문에 /noconfig 옵션을 무시합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NoConfigInResponseFile_Title">
        <source>Ignoring /noconfig option because it was specified in a response file</source>
        <target state="translated">지시 파일에 지정되었기 때문에 /noconfig 옵션을 무시합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_InvalidWarningId">
        <source>warning number '{0}' for the option '{1}' is either not configurable or not valid</source>
        <target state="translated">'{1}' 옵션에 대한 '{0}' 경고 번호를 구성할 수 없거나 잘못되었습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_InvalidWarningId_Title">
        <source>Warning number is either not configurable or not valid</source>
        <target state="translated">경고 번호가 구성 가능하지 않거나 잘못되었습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NoSourcesOut">
        <source>cannot infer an output file name from resource only input files; provide the '/out' option</source>
        <target state="translated">리소스 전용 입력 파일에서 출력 파일 이름을 유추할 수 없습니다. '/out' 옵션을 지정하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NeedModule">
        <source>the /moduleassemblyname option may only be specified when building a target of type 'module'</source>
        <target state="translated">/moduleassemblyname 옵션은 'module' 형식의 대상을 빌드할 때에만 지정할 수 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InvalidAssemblyName">
        <source>'{0}' is not a valid value for /moduleassemblyname</source>
        <target state="translated">'{0}'은(는) /moduleassemblyname에 유효한 값이 아닙니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ConflictingManifestSwitches">
        <source>Error embedding Win32 manifest: Option /win32manifest conflicts with /nowin32manifest.</source>
        <target state="translated">Win32 매니페스트를 포함하는 동안 오류가 발생했습니다. /win32manifest 옵션이 /nowin32manifest와 충돌합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_IgnoreModuleManifest">
        <source>Option /win32manifest ignored. It can be specified only when the target is an assembly.</source>
        <target state="translated">/win32manifest 옵션을 무시합니다. 이 옵션은 대상이 어셈블리일 때만 지정할 수 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_IgnoreModuleManifest_Title">
        <source>Option /win32manifest ignored</source>
        <target state="translated">/win32manifest 옵션이 무시됩니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InvalidInNamespace">
        <source>Statement is not valid in a namespace.</source>
        <target state="translated">네임스페이스에는 문을 사용할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_UndefinedType1">
        <source>Type '{0}' is not defined.</source>
        <target state="translated">'{0}' 형식이 정의되지 않았습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_MissingNext">
        <source>'Next' expected.</source>
        <target state="translated">'Next'가 필요합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_IllegalCharConstant">
        <source>Character constant must contain exactly one character.</source>
        <target state="translated">문자 상수에는 문자가 하나만 있어야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_UnreferencedAssemblyEvent3">
        <source>Reference required to assembly '{0}' containing the definition for event '{1}'. Add one to your project.</source>
        <target state="translated">'{1}' 이벤트에 대한 정의를 포함하는 '{0}' 어셈블리에 대한 참조를 찾을 수 없습니다. 프로젝트에 추가하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_UnreferencedModuleEvent3">
        <source>Reference required to module '{0}' containing the definition for event '{1}'. Add one to your project.</source>
        <target state="translated">'{1}' 이벤트에 대한 정의를 포함하는 '{0}' 모듈에 대한 참조를 찾을 수 없습니다. 프로젝트에 추가하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_LbExpectedEndIf">
        <source>'#If' block must end with a matching '#End If'.</source>
        <target state="translated">'#If' 블록은 짝이 되는 '#End If'로 끝나야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_LbNoMatchingIf">
        <source>'#ElseIf', '#Else', or '#End If' must be preceded by a matching '#If'.</source>
        <target state="translated">'#ElseIf', '#Else' 또는 '#End If'는 짝이 되는 '#If' 뒤에 와야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_LbBadElseif">
        <source>'#ElseIf' must be preceded by a matching '#If' or '#ElseIf'.</source>
        <target state="translated">'#ElseIf'는 짝이 되는 '#If' 또는 '#ElseIf' 뒤에 와야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InheritsFromRestrictedType1">
        <source>Inheriting from '{0}' is not valid.</source>
        <target state="translated">'{0}'에서 상속할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InvOutsideProc">
        <source>Labels are not valid outside methods.</source>
        <target state="translated">메서드 외부에서는 레이블이 유효하지 않습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DelegateCantImplement">
        <source>Delegates cannot implement interface methods.</source>
        <target state="translated">대리자는 인터페이스 메서드를 구현할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DelegateCantHandleEvents">
        <source>Delegates cannot handle events.</source>
        <target state="translated">대리자는 이벤트를 처리할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_IsOperatorRequiresReferenceTypes1">
        <source>'Is' operator does not accept operands of type '{0}'. Operands must be reference or nullable types.</source>
        <target state="translated">'Is' 연산자에는 '{0}' 형식의 피연산자를 사용할 수 없습니다. 피연산자는 참조 또는 null 허용 형식이어야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_TypeOfRequiresReferenceType1">
        <source>'TypeOf ... Is' requires its left operand to have a reference type, but this operand has the value type '{0}'.</source>
        <target state="translated">'TypeOf ... Is'의 왼쪽 피연산자는 참조 형식이어야 하는데 이 피연산자의 값 형식은 '{0}'입니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ReadOnlyHasSet">
        <source>Properties declared 'ReadOnly' cannot have a 'Set'.</source>
        <target state="translated">ReadOnly'로 선언된 속성에는 'Set'을 사용할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_WriteOnlyHasGet">
        <source>Properties declared 'WriteOnly' cannot have a 'Get'.</source>
        <target state="translated">WriteOnly'로 선언된 속성에는 'Get'을 사용할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InvInsideProc">
        <source>Statement is not valid inside a method.</source>
        <target state="translated">메서드 내부에는 문을 사용할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InvInsideBlock">
        <source>Statement is not valid inside '{0}' block.</source>
        <target state="translated">'{0}' 블록 내부에서는 문이 유효하지 않습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_UnexpectedExpressionStatement">
        <source>Expression statement is only allowed at the end of an interactive submission.</source>
        <target state="translated">식 문은 대화형 제출의 끝에서만 허용됩니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_EndProp">
        <source>Property missing 'End Property'.</source>
        <target state="translated">속성에 'End Property'가 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_EndSubExpected">
        <source>'End Sub' expected.</source>
        <target state="translated">'End Sub'가 필요합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_EndFunctionExpected">
        <source>'End Function' expected.</source>
        <target state="translated">'End Function'이 필요합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_LbElseNoMatchingIf">
        <source>'#Else' must be preceded by a matching '#If' or '#ElseIf'.</source>
        <target state="translated">'#Else'는 짝이 되는 '#If' 또는 '#ElseIf' 뒤에 와야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CantRaiseBaseEvent">
        <source>Derived classes cannot raise base class events.</source>
        <target state="translated">파생 클래스는 기본 클래스 이벤트를 발생시킬 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_TryWithoutCatchOrFinally">
        <source>Try must have at least one 'Catch' or a 'Finally'.</source>
        <target state="translated">Try에는 적어도 'Catch' 또는 'Finally' 중 하나가 있어야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_EventsCantBeFunctions">
        <source>Events cannot have a return type.</source>
        <target state="translated">이벤트에는 반환 형식을 사용할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_MissingEndBrack">
        <source>Bracketed identifier is missing closing ']'.</source>
        <target state="translated">대괄호로 묶은 식별자에 닫는 ']'가 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_Syntax">
        <source>Syntax error.</source>
        <target state="translated">구문 오류입니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_Overflow">
        <source>Overflow.</source>
        <target state="translated">오버플로가 발생했습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_IllegalChar">
        <source>Character is not valid.</source>
        <target state="translated">문자가 잘못되었습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_StdInOptionProvidedButConsoleInputIsNotRedirected">
        <source>stdin argument '-' is specified, but input has not been redirected from the standard input stream.</source>
        <target state="translated">stdin 인수 '-'를 지정했지만 표준 입력 스트림에서 입력이 리디렉션되지 않았습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_StrictDisallowsObjectOperand1">
        <source>Option Strict On prohibits operands of type Object for operator '{0}'.</source>
        <target state="translated">Option Strict On에서는 '{0}' 연산자에 대해 Object 형식의 피연산자를 사용할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_LoopControlMustNotBeProperty">
        <source>Loop control variable cannot be a property or a late-bound indexed array.</source>
        <target state="translated">루프 제어 변수는 속성 또는 런타임에 바인딩된 인덱스 배열일 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_MethodBodyNotAtLineStart">
        <source>First statement of a method body cannot be on the same line as the method declaration.</source>
        <target state="translated">메서드 본문의 첫째 문은 메서드 선언과 같은 줄에 있을 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_MaximumNumberOfErrors">
        <source>Maximum number of errors has been exceeded.</source>
        <target state="translated">최대 오류 개수를 초과했습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_UseOfKeywordNotInInstanceMethod1">
        <source>'{0}' is valid only within an instance method.</source>
        <target state="translated">'{0}'은(는) 인스턴스 메서드 내에서만 유효합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_UseOfKeywordFromStructure1">
        <source>'{0}' is not valid within a structure.</source>
        <target state="translated">'구조체 내에서는 {0}'이(가) 유효하지 않습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadAttributeConstructor1">
        <source>Attribute constructor has a parameter of type '{0}', which is not an integral, floating-point or Enum type or one of Object, Char, String, Boolean, System.Type or 1-dimensional array of these types.</source>
        <target state="translated">특성 생성자의 매개 변수 형식은 '{0}'입니다. 이 형식이 정수 계열, 부동 소수점 또는 열거형이 아니거나, Object, Char, String, Boolean, System.Type 또는 이러한 형식의 1차원 배열이 아닙니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ParamArrayWithOptArgs">
        <source>Method cannot have both a ParamArray and Optional parameters.</source>
        <target state="translated">메서드에는 ParamArray 매개 변수와 Optional 매개 변수를 함께 사용할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExpectedArray1">
        <source>'{0}' statement requires an array.</source>
        <target state="translated">'{0}' 문은 배열이 필요합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ParamArrayNotArray">
        <source>ParamArray parameter must be an array.</source>
        <target state="translated">ParamArray 매개 변수는 배열이어야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ParamArrayRank">
        <source>ParamArray parameter must be a one-dimensional array.</source>
        <target state="translated">ParamArray 매개 변수는 1차원 배열이어야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ArrayRankLimit">
        <source>Array exceeds the limit of 32 dimensions.</source>
        <target state="translated">배열이 한계인 32차원을 초과합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AsNewArray">
        <source>Arrays cannot be declared with 'New'.</source>
        <target state="translated">배열은 'New'로 선언할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_TooManyArgs1">
        <source>Too many arguments to '{0}'.</source>
        <target state="translated">'{0}'에 대한 인수가 너무 많습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExpectedCase">
        <source>Statements and labels are not valid between 'Select Case' and first 'Case'.</source>
        <target state="translated">Select Case'와 첫 번째 'Case' 사이에는 문 및 레이블을 사용할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RequiredConstExpr">
        <source>Constant expression is required.</source>
        <target state="translated">상수 식이 필요합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RequiredConstConversion2">
        <source>Conversion from '{0}' to '{1}' cannot occur in a constant expression.</source>
        <target state="translated">상수 식에서는 '{0}'에서 '{1}'(으)로 변환할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InvalidMe">
        <source>'Me' cannot be the target of an assignment.</source>
        <target state="translated">'Me'는 할당 대상일 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ReadOnlyAssignment">
        <source>'ReadOnly' variable cannot be the target of an assignment.</source>
        <target state="translated">'ReadOnly' 변수는 할당 대상일 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExitSubOfFunc">
        <source>'Exit Sub' is not valid in a Function or Property.</source>
        <target state="translated">'Function 또는 Property에서는 'Exit Sub'를 사용할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExitPropNot">
        <source>'Exit Property' is not valid in a Function or Sub.</source>
        <target state="translated">'Function 또는 Sub에서는 'Exit Property'를 사용할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExitFuncOfSub">
        <source>'Exit Function' is not valid in a Sub or Property.</source>
        <target state="translated">'Sub 또는 Property에서는 'Exit Function'을 사용할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_LValueRequired">
        <source>Expression is a value and therefore cannot be the target of an assignment.</source>
        <target state="translated">식이 값이므로 할당 대상일 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ForIndexInUse1">
        <source>For loop control variable '{0}' already in use by an enclosing For loop.</source>
        <target state="translated">For 루프 제어 변수 '{0}'이(가) 바깥쪽 For 루프에 이미 사용되고 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NextForMismatch1">
        <source>Next control variable does not match For loop control variable '{0}'.</source>
        <target state="translated">Next 제어 변수가 For 루프 제어 변수 '{0}'과(와) 일치하지 않습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CaseElseNoSelect">
        <source>'Case Else' can only appear inside a 'Select Case' statement.</source>
        <target state="translated">'Case Else'는 'Select Case' 문 내부에만 사용할 수 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CaseNoSelect">
        <source>'Case' can only appear inside a 'Select Case' statement.</source>
        <target state="translated">'Case'는 'Select Case' 문 내부에만 사용할 수 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CantAssignToConst">
        <source>Constant cannot be the target of an assignment.</source>
        <target state="translated">상수는 할당 대상일 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NamedSubscript">
        <source>Named arguments are not valid as array subscripts.</source>
        <target state="translated">명명된 인수는 배열 첨자로 사용할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExpectedEndIf">
        <source>'If' must end with a matching 'End If'.</source>
        <target state="translated">'If'는 짝이 되는 'End If'로 끝나야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExpectedEndWhile">
        <source>'While' must end with a matching 'End While'.</source>
        <target state="translated">'While'은 짝이 되는 'End While'로 끝나야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExpectedLoop">
        <source>'Do' must end with a matching 'Loop'.</source>
        <target state="translated">'Do'는 짝이 되는 'Loop'로 끝나야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExpectedNext">
        <source>'For' must end with a matching 'Next'.</source>
        <target state="translated">'For'는 짝이 되는 'Next'로 끝나야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExpectedEndWith">
        <source>'With' must end with a matching 'End With'.</source>
        <target state="translated">'With'는 짝이 되는 'End With'로 끝나야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ElseNoMatchingIf">
        <source>'Else' must be preceded by a matching 'If' or 'ElseIf'.</source>
        <target state="translated">'Else'는 짝이 되는 'If' 또는 'ElseIf' 뒤에 와야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_EndIfNoMatchingIf">
        <source>'End If' must be preceded by a matching 'If'.</source>
        <target state="translated">'End If'는 짝이 되는 'If' 뒤에 와야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_EndSelectNoSelect">
        <source>'End Select' must be preceded by a matching 'Select Case'.</source>
        <target state="translated">'End Select'는 짝이 되는 'Select Case' 뒤에 와야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExitDoNotWithinDo">
        <source>'Exit Do' can only appear inside a 'Do' statement.</source>
        <target state="translated">'Exit Do'는 'Do' 문 내부에만 사용할 수 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_EndWhileNoWhile">
        <source>'End While' must be preceded by a matching 'While'.</source>
        <target state="translated">'End While'은 짝이 되는 'While' 뒤에 와야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_LoopNoMatchingDo">
        <source>'Loop' must be preceded by a matching 'Do'.</source>
        <target state="translated">'Loop'는 짝이 되는 'Do' 뒤에 와야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NextNoMatchingFor">
        <source>'Next' must be preceded by a matching 'For'.</source>
        <target state="translated">'Next'는 짝이 되는 'For' 뒤에 와야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_EndWithWithoutWith">
        <source>'End With' must be preceded by a matching 'With'.</source>
        <target state="translated">'End With'는 짝이 되는 'With' 뒤에 와야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_MultiplyDefined1">
        <source>Label '{0}' is already defined in the current method.</source>
        <target state="translated">'{0}' 레이블이 현재 메서드에 이미 정의되었습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExpectedEndSelect">
        <source>'Select Case' must end with a matching 'End Select'.</source>
        <target state="translated">'Select Case'는 짝이 되는 'End Select'로 끝나야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExitForNotWithinFor">
        <source>'Exit For' can only appear inside a 'For' statement.</source>
        <target state="translated">'Exit For'는 'For' 문 내부에만 사용할 수 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExitWhileNotWithinWhile">
        <source>'Exit While' can only appear inside a 'While' statement.</source>
        <target state="translated">'Exit While'은 'While' 문 내부에만 사용할 수 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ReadOnlyProperty1">
        <source>'ReadOnly' property '{0}' cannot be the target of an assignment.</source>
        <target state="translated">'ReadOnly' 속성의 '{0}' 속성은 할당 대상일 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExitSelectNotWithinSelect">
        <source>'Exit Select' can only appear inside a 'Select' statement.</source>
        <target state="translated">'Exit Select'는 'Select' 문 내부에만 사용할 수 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BranchOutOfFinally">
        <source>Branching out of a 'Finally' is not valid.</source>
        <target state="translated">Finally' 밖으로는 분기할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_QualNotObjectRecord1">
        <source>'!' requires its left operand to have a type parameter, class or interface type, but this operand has the type '{0}'.</source>
        <target state="translated">'!'의 왼쪽 피연산자는 형식 매개 변수, 클래스 또는 인터페이스 형식이어야 하는데 이 피연산자는 '{0}' 형식입니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_TooFewIndices">
        <source>Number of indices is less than the number of dimensions of the indexed array.</source>
        <target state="translated">인덱스 수가 인덱싱된 배열의 차수보다 적습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_TooManyIndices">
        <source>Number of indices exceeds the number of dimensions of the indexed array.</source>
        <target state="translated">인덱스 수가 인덱싱된 배열의 차수보다 많습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_EnumNotExpression1">
        <source>'{0}' is an Enum type and cannot be used as an expression.</source>
        <target state="translated">'{0}'은(는) 열거형 형식이므로 식으로 사용할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_TypeNotExpression1">
        <source>'{0}' is a type and cannot be used as an expression.</source>
        <target state="translated">'{0}'은(는) 형식이므로 식으로 사용할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ClassNotExpression1">
        <source>'{0}' is a class type and cannot be used as an expression.</source>
        <target state="translated">'{0}'은(는) 클래스 형식이므로 식으로 사용할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_StructureNotExpression1">
        <source>'{0}' is a structure type and cannot be used as an expression.</source>
        <target state="translated">'{0}'은(는) 구조체 형식이므로 식으로 사용할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InterfaceNotExpression1">
        <source>'{0}' is an interface type and cannot be used as an expression.</source>
        <target state="translated">'{0}'은(는) 인터페이스 형식이므로 식으로 사용할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NamespaceNotExpression1">
        <source>'{0}' is a namespace and cannot be used as an expression.</source>
        <target state="translated">'{0}'은(는) 네임스페이스여서 식으로 사용할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadNamespaceName1">
        <source>'{0}' is not a valid name and cannot be used as the root namespace name.</source>
        <target state="translated">'{0}'은(는) 유효한 이름이 아니므로 루트 네임스페이스 이름으로 사용할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_XmlPrefixNotExpression">
        <source>'{0}' is an XML prefix and cannot be used as an expression.  Use the GetXmlNamespace operator to create a namespace object.</source>
        <target state="translated">'{0}'은(는) XML 접두사이므로 식으로 사용할 수 없습니다. 네임스페이스 개체를 만들려면 GetXmlNamespace 연산자를 사용하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_MultipleExtends">
        <source>'Inherits' can appear only once within a 'Class' statement and can only specify one class.</source>
        <target state="translated">'Inherits'는 'Class' 문 안에 한 번만 사용할 수 있으며 하나의 클래스만 지정할 수 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PropMustHaveGetSet">
        <source>Property without a 'ReadOnly' or 'WriteOnly' specifier must provide both a 'Get' and a 'Set'.</source>
        <target state="translated">ReadOnly' 또는 'WriteOnly' 지정자가 없는 속성에는 'Get'과 'Set'을 모두 지정해야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_WriteOnlyHasNoWrite">
        <source>'WriteOnly' property must provide a 'Set'.</source>
        <target state="translated">'WriteOnly' 속성에는 'Set'을 지정해야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ReadOnlyHasNoGet">
        <source>'ReadOnly' property must provide a 'Get'.</source>
        <target state="translated">'ReadOnly' 속성에는 'Get'을 지정해야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadAttribute1">
        <source>Attribute '{0}' is not valid: Incorrect argument value.</source>
        <target state="translated">'{0}' 특성이 잘못되었습니다. 잘못된 인수 값입니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_LabelNotDefined1">
        <source>Label '{0}' is not defined.</source>
        <target state="translated">'{0}' 레이블이 정의되지 않았습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ErrorCreatingWin32ResourceFile">
        <source>Error creating Win32 resources: {0}</source>
        <target state="translated">Win32 리소스를 만드는 동안 오류가 발생했습니다({0}).</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_UnableToCreateTempFile">
        <source>Cannot create temporary file: {0}</source>
        <target state="translated">{0} 임시 파일을 만들 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RequiredNewCall2">
        <source>First statement of this 'Sub New' must be a call to 'MyBase.New' or 'MyClass.New' because base class '{0}' of '{1}' does not have an accessible 'Sub New' that can be called with no arguments.</source>
        <target state="translated">'{1}'의 기본 클래스 '{0}'에 인수 없이 호출할 수 있는 액세스 가능한 'Sub New'가 없으므로 이 'Sub New'의 첫째 문은 'MyBase.New' 또는 'MyClass.New'에 대한 호출이어야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_UnimplementedMember3">
        <source>{0} '{1}' must implement '{2}' for interface '{3}'.</source>
        <target state="translated">{0} '{1}'은(는) '{3}' 인터페이스에 대한 '{2}'을(를) 구현해야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadWithRef">
        <source>Leading '.' or '!' can only appear inside a 'With' statement.</source>
        <target state="translated">With' 문 내부에서만 '.' 또는 '!'로 시작할 수 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DuplicateAccessCategoryUsed">
        <source>Only one of 'Public', 'Private', 'Protected', 'Friend', 'Protected Friend', or 'Private Protected' can be specified.</source>
        <target state="translated">Public', 'Private', 'Protected', 'Friend', 'Protected Friend' 또는 'Private Protected' 중 하나만 지정할 수 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DuplicateModifierCategoryUsed">
        <source>Only one of 'NotOverridable', 'MustOverride', or 'Overridable' can be specified.</source>
        <target state="translated">NotOverridable', 'MustOverride' 또는 'Overridable' 중 하나만 지정할 수 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DuplicateSpecifier">
        <source>Specifier is duplicated.</source>
        <target state="translated">지정자가 중복되었습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_TypeConflict6">
        <source>{0} '{1}' and {2} '{3}' conflict in {4} '{5}'.</source>
        <target state="translated">{0} '{1}' 및 {2} '{3}'이(가) {4} '{5}'에 충돌합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_UnrecognizedTypeKeyword">
        <source>Keyword does not name a type.</source>
        <target state="translated">키워드는 형식의 이름을 지정하지 않습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExtraSpecifiers">
        <source>Specifiers valid only at the beginning of a declaration.</source>
        <target state="translated">지정자는 선언의 시작 부분에서만 사용할 수 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_UnrecognizedType">
        <source>Type expected.</source>
        <target state="translated">형식이 필요합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InvalidUseOfKeyword">
        <source>Keyword is not valid as an identifier.</source>
        <target state="translated">키워드를 식별자로 사용할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InvalidEndEnum">
        <source>'End Enum' must be preceded by a matching 'Enum'.</source>
        <target state="translated">'End Enum'은 짝이 되는 'Enum' 뒤에 와야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_MissingEndEnum">
        <source>'Enum' must end with a matching 'End Enum'.</source>
        <target state="translated">'Enum'은 짝이 되는 'End Enum'으로 끝나야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExpectedDeclaration">
        <source>Declaration expected.</source>
        <target state="translated">선언이 필요합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ParamArrayMustBeLast">
        <source>End of parameter list expected. Cannot define parameters after a paramarray parameter.</source>
        <target state="translated">매개 변수 목록의 끝이어야 합니다. paramarray 매개 변수 뒤에는 매개 변수를 정의할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_SpecifiersInvalidOnInheritsImplOpt">
        <source>Specifiers and attributes are not valid on this statement.</source>
        <target state="translated">이 문에는 지정자 및 특성을 사용할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExpectedSpecifier">
        <source>Expected one of 'Dim', 'Const', 'Public', 'Private', 'Protected', 'Friend', 'Shadows', 'ReadOnly' or 'Shared'.</source>
        <target state="translated">Dim', 'Const', 'Public', 'Private', 'Protected', 'Friend', 'Shadows', 'ReadOnly' 또는 'Shared' 중 하나가 필요합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExpectedComma">
        <source>Comma expected.</source>
        <target state="translated">쉼표가 필요합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExpectedAs">
        <source>'As' expected.</source>
        <target state="translated">'As'가 필요합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExpectedRparen">
        <source>')' expected.</source>
        <target state="translated">')'가 필요합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExpectedLparen">
        <source>'(' expected.</source>
        <target state="translated">'('가 필요합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InvalidNewInType">
        <source>'New' is not valid in this context.</source>
        <target state="translated">'이 컨텍스트에서는 'New'를 사용할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExpectedExpression">
        <source>Expression expected.</source>
        <target state="translated">식이 필요합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExpectedOptional">
        <source>'Optional' expected.</source>
        <target state="translated">'Optional'이 필요합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExpectedIdentifier">
        <source>Identifier expected.</source>
        <target state="translated">식별자가 필요합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExpectedIntLiteral">
        <source>Integer constant expected.</source>
        <target state="translated">정수 계열 상수가 필요합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExpectedEOS">
        <source>End of statement expected.</source>
        <target state="translated">문의 끝이 필요합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExpectedForOptionStmt">
        <source>'Option' must be followed by 'Compare', 'Explicit', 'Infer', or 'Strict'.</source>
        <target state="translated">'Option' 뒤에는 'Compare', 'Explicit', 'Infer' 또는 'Strict'가 와야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InvalidOptionCompare">
        <source>'Option Compare' must be followed by 'Text' or 'Binary'.</source>
        <target state="translated">'Option Compare' 뒤에는 'Text' 또는 'Binary'가 와야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExpectedOptionCompare">
        <source>'Compare' expected.</source>
        <target state="translated">'Compare'가 필요합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_StrictDisallowImplicitObject">
        <source>Option Strict On requires all variable declarations to have an 'As' clause.</source>
        <target state="translated">Option Strict On에서는 모든 변수 선언에 'As' 절을 사용해야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_StrictDisallowsImplicitProc">
        <source>Option Strict On requires all Function, Property, and Operator declarations to have an 'As' clause.</source>
        <target state="translated">Option Strict On에서는 모든 함수, 속성 및 연산자 선언에 'As' 절을 사용해야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_StrictDisallowsImplicitArgs">
        <source>Option Strict On requires that all method parameters have an 'As' clause.</source>
        <target state="translated">Option Strict On에서는 모든 메서드 매개 변수에 'As' 절을 사용해야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InvalidParameterSyntax">
        <source>Comma or ')' expected.</source>
        <target state="translated">쉼표 또는 ')'가 필요합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExpectedSubFunction">
        <source>'Sub' or 'Function' expected.</source>
        <target state="translated">'Sub' 또는 'Function'이 필요합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExpectedStringLiteral">
        <source>String constant expected.</source>
        <target state="translated">문자열 상수가 필요합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_MissingLibInDeclare">
        <source>'Lib' expected.</source>
        <target state="translated">'Lib'가 필요합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DelegateNoInvoke1">
        <source>Delegate class '{0}' has no Invoke method, so an expression of this type cannot be the target of a method call.</source>
        <target state="translated">'{0}' 대리자 클래스에는 Invoke 메서드가 없으므로 이러한 형식의 식은 메서드 호출의 대상일 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_MissingIsInTypeOf">
        <source>'Is' expected.</source>
        <target state="translated">'Is'가 필요합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DuplicateOption1">
        <source>'Option {0}' statement can only appear once per file.</source>
        <target state="translated">'파일당 'Option {0}' 문을 한 번만 사용할 수 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ModuleCantInherit">
        <source>'Inherits' not valid in Modules.</source>
        <target state="translated">'모듈에는 'Inherits'를 사용할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ModuleCantImplement">
        <source>'Implements' not valid in Modules.</source>
        <target state="translated">'모듈에는 'Implements'를 사용할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadImplementsType">
        <source>Implemented type must be an interface.</source>
        <target state="translated">구현 형식은 인터페이스여야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadConstFlags1">
        <source>'{0}' is not valid on a constant declaration.</source>
        <target state="translated">'상수 선언에서는 '{0}'이(가) 유효하지 않습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadWithEventsFlags1">
        <source>'{0}' is not valid on a WithEvents declaration.</source>
        <target state="translated">'WithEvents 선언에서는 '{0}'이(가) 유효하지 않습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadDimFlags1">
        <source>'{0}' is not valid on a member variable declaration.</source>
        <target state="translated">'멤버 변수 선언에서는 '{0}'이(가) 유효하지 않습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DuplicateParamName1">
        <source>Parameter already declared with name '{0}'.</source>
        <target state="translated">이름이 '{0}'인 매개 변수가 이미 선언되었습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_LoopDoubleCondition">
        <source>'Loop' cannot have a condition if matching 'Do' has one.</source>
        <target state="translated">'짝이 되는 'Do'에 조건이 있으면 'Loop'에는 조건을 사용할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExpectedRelational">
        <source>Relational operator expected.</source>
        <target state="translated">관계형 연산자가 필요합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExpectedExitKind">
        <source>'Exit' must be followed by 'Sub', 'Function', 'Property', 'Do', 'For', 'While', 'Select', or 'Try'.</source>
        <target state="translated">'Exit' 뒤에는 'Sub', 'Function', 'Property', 'Do', 'For', 'While', 'Select' 또는 'Try'가 와야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExpectedNamedArgumentInAttributeList">
        <source>Named argument expected.</source>
        <target state="translated">명명된 인수가 필요합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NamedArgumentSpecificationBeforeFixedArgumentInLateboundInvocation">
        <source>Named argument specifications must appear after all fixed arguments have been specified in a late bound invocation.</source>
        <target state="translated">명명된 인수 사양은 런타임에 바인딩된 호출에서 모든 고정 인수를 지정한 다음에 와야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExpectedNamedArgument">
        <source>Named argument expected. Please use language version {0} or greater to use non-trailing named arguments.</source>
        <target state="translated">명명된 인수가 필요합니다. 뒤에 오지 않는 명명된 인수를 사용하려면 {0} 이상의 언어 버전을 사용하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadMethodFlags1">
        <source>'{0}' is not valid on a method declaration.</source>
        <target state="translated">'메서드 선언에서는 '{0}'이(가) 유효하지 않습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadEventFlags1">
        <source>'{0}' is not valid on an event declaration.</source>
        <target state="translated">'이벤트 선언에서는 '{0}'이(가) 유효하지 않습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadDeclareFlags1">
        <source>'{0}' is not valid on a Declare.</source>
        <target state="translated">'Declare에서는 '{0}'이(가) 유효하지 않습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadLocalConstFlags1">
        <source>'{0}' is not valid on a local constant declaration.</source>
        <target state="translated">'지역 상수 선언에서는 '{0}'이(가) 유효하지 않습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadLocalDimFlags1">
        <source>'{0}' is not valid on a local variable declaration.</source>
        <target state="translated">'지역 변수 선언에서는 '{0}'이(가) 유효하지 않습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExpectedConditionalDirective">
        <source>'If', 'ElseIf', 'Else', 'Const', 'Region', 'ExternalSource', 'ExternalChecksum', 'Enable', 'Disable', 'End' or 'R' expected.</source>
        <target state="translated">'If', 'ElseIf', 'Else', 'Const', 'Region', 'ExternalSource', 'ExternalChecksum', 'Enable', 'Disable', 'End' 또는 'R'이 필요합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExpectedEQ">
        <source>'=' expected.</source>
        <target state="translated">'='가 필요합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ConstructorNotFound1">
        <source>Type '{0}' has no constructors.</source>
        <target state="translated">'{0}' 형식에 생성자가 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InvalidEndInterface">
        <source>'End Interface' must be preceded by a matching 'Interface'.</source>
        <target state="translated">'End Interface'는 짝이 되는 'Interface' 뒤에 와야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_MissingEndInterface">
        <source>'Interface' must end with a matching 'End Interface'.</source>
        <target state="translated">'Interface'는 짝이 되는 'End Interface'로 끝나야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InheritsFrom2">
        <source>
    '{0}' inherits from '{1}'.</source>
        <target state="translated">
    '{0}'이(가) '{1}'에서 상속됩니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_IsNestedIn2">
        <source>
    '{0}' is nested in '{1}'.</source>
        <target state="translated">
    '{0}'이(가) '{1}'에 중첩됩니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InheritanceCycle1">
        <source>Class '{0}' cannot inherit from itself: {1}</source>
        <target state="translated">'{0}' 클래스는 자체 클래스({1})에서 상속할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InheritsFromNonClass">
        <source>Classes can inherit only from other classes.</source>
        <target state="translated">클래스는 다른 클래스에서만 상속할 수 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_MultiplyDefinedType3">
        <source>'{0}' is already declared as '{1}' in this {2}.</source>
        <target state="translated">'{0}'은(는) 이 {2}에 '{1}'(으)로 이미 선언되었습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadOverrideAccess2">
        <source>'{0}' cannot override '{1}' because they have different access levels.</source>
        <target state="translated">'액세스 수준이 서로 달라 '{0}'에서는 '{1}'을(를) 재정의할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CantOverrideNotOverridable2">
        <source>'{0}' cannot override '{1}' because it is declared 'NotOverridable'.</source>
        <target state="translated">'{0}'은(는) 'NotOverridable'로 선언되었으므로 '{1}'을(를) 재정의할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DuplicateProcDef1">
        <source>'{0}' has multiple definitions with identical signatures.</source>
        <target state="translated">'{0}'에 시그니처가 동일한 정의가 여러 개 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DuplicateProcDefWithDifferentTupleNames2">
        <source>'{0}' has multiple definitions with identical signatures with different tuple element names, including '{1}'.</source>
        <target state="translated">'{0}'에 '{1}'을(를) 비롯한 다른 튜플 요소 이름과 시니그처가 동일한 정의가 여러 개 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadInterfaceMethodFlags1">
        <source>'{0}' is not valid on an interface method declaration.</source>
        <target state="translated">'인터페이스 메서드 선언에서는 '{0}'이(가) 유효하지 않습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NamedParamNotFound2">
        <source>'{0}' is not a parameter of '{1}'.</source>
        <target state="translated">'{0}'은(는) '{1}'의 매개 변수가 아닙니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadInterfacePropertyFlags1">
        <source>'{0}' is not valid on an interface property declaration.</source>
        <target state="translated">'인터페이스 속성 선언에서는 '{0}'이(가) 유효하지 않습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NamedArgUsedTwice2">
        <source>Parameter '{0}' of '{1}' already has a matching argument.</source>
        <target state="translated">'{1}'의 '{0}' 매개 변수와 일치하는 인수가 이미 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InterfaceCantUseEventSpecifier1">
        <source>'{0}' is not valid on an interface event declaration.</source>
        <target state="translated">'인터페이스 이벤트 선언에서는 '{0}'이(가) 유효하지 않습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_TypecharNoMatch2">
        <source>Type character '{0}' does not match declared data type '{1}'.</source>
        <target state="translated">'{0}' 형식 문자가 선언된 '{1}' 데이터 형식과 일치하지 않습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExpectedSubOrFunction">
        <source>'Sub' or 'Function' expected after 'Delegate'.</source>
        <target state="translated">'Delegate' 뒤에 'Sub' 또는 'Function'이 필요합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadEmptyEnum1">
        <source>Enum '{0}' must contain at least one member.</source>
        <target state="translated">열거형 '{0}'에는 하나 이상의 멤버가 있어야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InvalidConstructorCall">
        <source>Constructor call is valid only as the first statement in an instance constructor.</source>
        <target state="translated">인스턴스 생성자의 첫째 문으로만 생성자를 호출할 수 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CantOverrideConstructor">
        <source>'Sub New' cannot be declared 'Overrides'.</source>
        <target state="translated">'Sub New'는 'Overrides'로 선언할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ConstructorCannotBeDeclaredPartial">
        <source>'Sub New' cannot be declared 'Partial'.</source>
        <target state="translated">'Sub New'는 'Partial'로 선언할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ModuleEmitFailure">
        <source>Failed to emit module '{0}': {1}</source>
        <target state="translated">모듈 '{0}'을(를) 내보내지 못했습니다. {1}</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_EncUpdateFailedMissingAttribute">
        <source>Cannot update '{0}'; attribute '{1}' is missing.</source>
        <target state="translated">'{0}'을(를) 업데이트할 수 없습니다. 특성 '{1}'이(가) 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_OverrideNotNeeded3">
        <source>{0} '{1}' cannot be declared 'Overrides' because it does not override a {0} in a base class.</source>
        <target state="translated">{0} '{1}'은(는) 기본 클래스의 {0}을(를) 재정의하지 않으므로 'Overrides'로 선언할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExpectedDot">
        <source>'.' expected.</source>
        <target state="translated">'.'가 필요합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DuplicateLocals1">
        <source>Local variable '{0}' is already declared in the current block.</source>
        <target state="translated">'{0}' 지역 변수가 현재 블록에 이미 선언되었습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InvInsideEndsProc">
        <source>Statement cannot appear within a method body. End of method assumed.</source>
        <target state="translated">메서드 본문 안에는 문을 사용할 수 없습니다. 메서드의 끝으로 간주합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_LocalSameAsFunc">
        <source>Local variable cannot have the same name as the function containing it.</source>
        <target state="translated">지역 변수에는 해당 변수가 포함된 함수와 같은 이름을 사용할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RecordEmbeds2">
        <source>
    '{0}' contains '{1}' (variable '{2}').</source>
        <target state="translated">
    '{0}'이(가) '{1}'('{2}' 변수)을(를) 포함합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RecordCycle2">
        <source>Structure '{0}' cannot contain an instance of itself: {1}</source>
        <target state="translated">'{0}' 구조체는 자체 인스턴스({1})를 포함할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InterfaceCycle1">
        <source>Interface '{0}' cannot inherit from itself: {1}</source>
        <target state="translated">'{0}' 인터페이스는 자체 인터페이스({1})에서 상속할 수 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_SubNewCycle2">
        <source>
    '{0}' calls '{1}'.</source>
        <target state="translated">
    '{0}'에서 '{1}'을(를) 호출합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_SubNewCycle1">
        <source>Constructor '{0}' cannot call itself: {1}</source>
        <target state="translated">'{0}' 생성자는 자신({1})을 호출할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InheritsFromCantInherit3">
        <source>'{0}' cannot inherit from {2} '{1}' because '{1}' is declared 'NotInheritable'.</source>
        <target state="translated">'{1}'이(가) 'NotInheritable'로 선언되었으므로 '{0}'은(는) {2} '{1}'에서 상속할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_OverloadWithOptional2">
        <source>'{0}' and '{1}' cannot overload each other because they differ only by optional parameters.</source>
        <target state="translated">'{0}'과(와) '{1}'은(는) 선택적 매개 변수만 다르므로 서로 오버로드할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_OverloadWithReturnType2">
        <source>'{0}' and '{1}' cannot overload each other because they differ only by return types.</source>
        <target state="translated">'{0}'과(와) '{1}'은(는) 반환 형식만 다르므로 서로 오버로드할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_TypeCharWithType1">
        <source>Type character '{0}' cannot be used in a declaration with an explicit type.</source>
        <target state="translated">명시적 형식이 있는 선언에는 '{0}' 형식 문자를 사용할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_TypeCharOnSub">
        <source>Type character cannot be used in a 'Sub' declaration because a 'Sub' doesn't return a value.</source>
        <target state="translated">Sub'는 값을 반환하지 않으므로 'Sub' 선언에 형식 문자를 사용할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_OverloadWithDefault2">
        <source>'{0}' and '{1}' cannot overload each other because they differ only by the default values of optional parameters.</source>
        <target state="translated">'{0}'과(와) '{1}'은(는) 선택적 매개 변수의 기본값만 다르므로 서로 오버로드할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_MissingSubscript">
        <source>Array subscript expression missing.</source>
        <target state="translated">배열 첨자식이 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_OverrideWithDefault2">
        <source>'{0}' cannot override '{1}' because they differ by the default values of optional parameters.</source>
        <target state="translated">'선택적 매개 변수의 기본값이 서로 다르므로 '{0}'은(는) '{1}'을(를) 재정의할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_OverrideWithOptional2">
        <source>'{0}' cannot override '{1}' because they differ by optional parameters.</source>
        <target state="translated">'선택적 매개 변수가 서로 다르므로 '{0}'은(는) '{1}'을(를) 재정의할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_FieldOfValueFieldOfMarshalByRef3">
        <source>Cannot refer to '{0}' because it is a member of the value-typed field '{1}' of class '{2}' which has 'System.MarshalByRefObject' as a base class.</source>
        <target state="translated">'{0}'은(는) 'System.MarshalByRefObject'를 기본 클래스로 사용하는 '{2}' 클래스의 값 형식 필드 '{1}'의 멤버이므로 참조할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_TypeMismatch2">
        <source>Value of type '{0}' cannot be converted to '{1}'.</source>
        <target state="translated">'{0}' 형식의 변수는 '{1}'(으)로 변환할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CaseAfterCaseElse">
        <source>'Case' cannot follow a 'Case Else' in the same 'Select' statement.</source>
        <target state="translated">'Case'는 같은 'Select'에서 'Case Else' 뒤에 올 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ConvertArrayMismatch4">
        <source>Value of type '{0}' cannot be converted to '{1}' because '{2}' is not derived from '{3}'.</source>
        <target state="translated">'{2}'이(가) '{3}'에서 파생되지 않으므로 '{0}' 형식의 값을 '{1}'(으)로 변환할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ConvertObjectArrayMismatch3">
        <source>Value of type '{0}' cannot be converted to '{1}' because '{2}' is not a reference type.</source>
        <target state="translated">'{2}'이(가) 참조 형식이 아니므로 '{0}' 형식의 값을 '{1}'(으)로 변환할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ForLoopType1">
        <source>'For' loop control variable cannot be of type '{0}' because the type does not support the required operators.</source>
        <target state="translated">'For' 루프 제어 변수는 '{0}' 형식일 수 없습니다. 이 형식은 필요한 연산자를 지원하지 않습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_OverloadWithByref2">
        <source>'{0}' and '{1}' cannot overload each other because they differ only by parameters declared 'ByRef' or 'ByVal'.</source>
        <target state="translated">'{0}'과(와) '{1}'은(는) 'ByRef' 또는 'ByVal'로 선언된 매개 변수만 다르므로 서로 오버로드할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InheritsFromNonInterface">
        <source>Interface can inherit only from another interface.</source>
        <target state="translated">인터페이스는 다른 인터페이스에서만 상속할 수 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadInterfaceOrderOnInherits">
        <source>'Inherits' statements must precede all declarations in an interface.</source>
        <target state="translated">'Inherits' 문은 인터페이스의 모든 선언 앞에 와야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DuplicateDefaultProps1">
        <source>'Default' can be applied to only one property name in a {0}.</source>
        <target state="translated">'{0}에서 'Default'를 하나의 속성 이름에만 적용할 수 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DefaultMissingFromProperty2">
        <source>'{0}' and '{1}' cannot overload each other because only one is declared 'Default'.</source>
        <target state="translated">'{0}'과(와) '{1}' 중 하나만 'Default'로 선언되었으므로 서로 오버로드할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_OverridingPropertyKind2">
        <source>'{0}' cannot override '{1}' because they differ by 'ReadOnly' or 'WriteOnly'.</source>
        <target state="translated">'ReadOnly' 또는 'WriteOnly'만 서로 다르므로 '{0}'은(는) '{1}'을(를) 재정의할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NewInInterface">
        <source>'Sub New' cannot be declared in an interface.</source>
        <target state="translated">'Sub New'는 인터페이스에 선언할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadFlagsOnNew1">
        <source>'Sub New' cannot be declared '{0}'.</source>
        <target state="translated">'Sub New'는 '{0}'(으)로 선언할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_OverloadingPropertyKind2">
        <source>'{0}' and '{1}' cannot overload each other because they differ only by 'ReadOnly' or 'WriteOnly'.</source>
        <target state="translated">'{0}'과(와) '{1}'은(는) 'ReadOnly' 또는 'WriteOnly'만 다르므로 서로 오버로드할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NoDefaultNotExtend1">
        <source>Class '{0}' cannot be indexed because it has no default property.</source>
        <target state="translated">'{0}' 클래스는 기본 속성이 없으므로 인덱싱될 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_OverloadWithArrayVsParamArray2">
        <source>'{0}' and '{1}' cannot overload each other because they differ only by parameters declared 'ParamArray'.</source>
        <target state="translated">'{0}'과(와) '{1}'은(는) 'ParamArray'로 선언된 매개 변수만 다르므로 서로 오버로드할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadInstanceMemberAccess">
        <source>Cannot refer to an instance member of a class from within a shared method or shared member initializer without an explicit instance of the class.</source>
        <target state="translated">클래스의 명시적 인스턴스가 없는 공유 메서드 또는 공유 멤버 이니셜라이저에서는 클래스의 인스턴스 멤버를 참조할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExpectedRbrace">
        <source>'}' expected.</source>
        <target state="translated">'}'가 필요합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ModuleAsType1">
        <source>Module '{0}' cannot be used as a type.</source>
        <target state="translated">'{0}' 모듈은 형식으로 사용할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NewIfNullOnNonClass">
        <source>'New' cannot be used on an interface.</source>
        <target state="translated">'New'는 인터페이스에 사용할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CatchAfterFinally">
        <source>'Catch' cannot appear after 'Finally' within a 'Try' statement.</source>
        <target state="translated">'Catch'는 'Try' 문 안에서 'Finally' 뒤에 사용할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CatchNoMatchingTry">
        <source>'Catch' cannot appear outside a 'Try' statement.</source>
        <target state="translated">'Catch'는 'Try' 문 외부에 사용할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_FinallyAfterFinally">
        <source>'Finally' can only appear once in a 'Try' statement.</source>
        <target state="translated">'Finally'는 'Try' 문에서 한 번만 사용할 수 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_FinallyNoMatchingTry">
        <source>'Finally' cannot appear outside a 'Try' statement.</source>
        <target state="translated">'Finally'는 'Try' 문 외부에 사용할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_EndTryNoTry">
        <source>'End Try' must be preceded by a matching 'Try'.</source>
        <target state="translated">'End Try'는 짝이 되는 'Try' 뒤에 와야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExpectedEndTry">
        <source>'Try' must end with a matching 'End Try'.</source>
        <target state="translated">'Try'는 짝이 되는 'End Try'로 끝나야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadDelegateFlags1">
        <source>'{0}' is not valid on a Delegate declaration.</source>
        <target state="translated">'Delegate 선언에서는 '{0}'이(가) 유효하지 않습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NoConstructorOnBase2">
        <source>Class '{0}' must declare a 'Sub New' because its base class '{1}' does not have an accessible 'Sub New' that can be called with no arguments.</source>
        <target state="translated">'{0}' 클래스의 기본 클래스 '{1}'에는 인수 없이 호출할 수 있는 액세스 가능한 'Sub New'가 두 개 이상 있으므로 'Sub New'를 선언해야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InaccessibleSymbol2">
        <source>'{0}' is not accessible in this context because it is '{1}'.</source>
        <target state="translated">'{0}'은(는) '{1}'이므로 이 컨텍스트에서 액세스할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InaccessibleMember3">
        <source>'{0}.{1}' is not accessible in this context because it is '{2}'.</source>
        <target state="translated">'{0}.{1}'은(는) '{2}'이므로 이 컨텍스트에서 액세스할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CatchNotException1">
        <source>'Catch' cannot catch type '{0}' because it is not 'System.Exception' or a class that inherits from 'System.Exception'.</source>
        <target state="translated">'{0}' 형식은 'System.Exception' 또는 'System.Exception'에서 상속한 클래스가 아니므로 'Catch'로 이 형식을 Catch할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExitTryNotWithinTry">
        <source>'Exit Try' can only appear inside a 'Try' statement.</source>
        <target state="translated">'Exit Try'는 'Try' 문 내부에만 사용할 수 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadRecordFlags1">
        <source>'{0}' is not valid on a Structure declaration.</source>
        <target state="translated">구조체 선언에서는 '{0}'이(가) 유효하지 않습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadEnumFlags1">
        <source>'{0}' is not valid on an Enum declaration.</source>
        <target state="translated">열거형 선언에서는 '{0}'이(가) 유효하지 않습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadInterfaceFlags1">
        <source>'{0}' is not valid on an Interface declaration.</source>
        <target state="translated">인터페이스 선언에서는 '{0}'이(가) 유효하지 않습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_OverrideWithByref2">
        <source>'{0}' cannot override '{1}' because they differ by a parameter that is marked as 'ByRef' versus 'ByVal'.</source>
        <target state="translated">'ByRef' 또는 'ByVal'로 표시된 매개 변수가 서로 다르므로 '{0}'은(는) '{1}'을(를) 재정의할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_MyBaseAbstractCall1">
        <source>'MyBase' cannot be used with method '{0}' because it is declared 'MustOverride'.</source>
        <target state="translated">'MyBase'는 'MustOverride'로 선언된 '{0}' 메서드를 함께 사용할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_IdentNotMemberOfInterface4">
        <source>'{0}' cannot implement '{1}' because there is no matching {2} on interface '{3}'.</source>
        <target state="translated">'{3}' 인터페이스에 일치하는 {2}이(가) 없으므로 '{0}'에서 '{1}'을(를) 구현할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ImplementingInterfaceWithDifferentTupleNames5">
        <source>'{0}' cannot implement {1} '{2}' on interface '{3}' because the tuple element names in '{4}' do not match those in '{5}'.</source>
        <target state="translated">'{4}'의 튜플 요소 이름이 '{5}'의 이름과 일치하지 않으므로 '{0}'은(는) '{3}' 인터페이스에서 {1} '{2}'을(를) 구현할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_WithEventsRequiresClass">
        <source>'WithEvents' variables must have an 'As' clause.</source>
        <target state="translated">'WithEvents' 변수에는 'As' 절이 있어야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_WithEventsAsStruct">
        <source>'WithEvents' variables can only be typed as classes, interfaces or type parameters with class constraints.</source>
        <target state="translated">'WithEvents' 변수는 클래스, 인터페이스 또는 클래스 제약 조건이 있는 형식 매개 변수로만 형식화될 수 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ConvertArrayRankMismatch2">
        <source>Value of type '{0}' cannot be converted to '{1}' because the array types have different numbers of dimensions.</source>
        <target state="translated">형식이 다른 두 배열의 차수가 달라 '{0}' 형식의 값을 '{1}'(으)로 변환할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RedimRankMismatch">
        <source>'ReDim' cannot change the number of dimensions of an array.</source>
        <target state="translated">'ReDim'은 배열의 차수를 변경할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_StartupCodeNotFound1">
        <source>'Sub Main' was not found in '{0}'.</source>
        <target state="translated">'{0}'에서 'Sub Main'을 찾을 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ConstAsNonConstant">
        <source>Constants must be of an intrinsic or enumerated type, not a class, structure, type parameter, or array type.</source>
        <target state="translated">상수는 클래스, 구조체, 형식 매개 변수 또는 배열 형식이 아닌 내장 또는 열거 형식이어야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InvalidEndSub">
        <source>'End Sub' must be preceded by a matching 'Sub'.</source>
        <target state="translated">'End Sub'는 짝이 되는 'Sub' 뒤에 와야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InvalidEndFunction">
        <source>'End Function' must be preceded by a matching 'Function'.</source>
        <target state="translated">'End Function'은 짝이 되는 'Function' 뒤에 와야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InvalidEndProperty">
        <source>'End Property' must be preceded by a matching 'Property'.</source>
        <target state="translated">'End Property'는 짝이 되는 'Property' 뒤에 와야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ModuleCantUseMethodSpecifier1">
        <source>Methods in a Module cannot be declared '{0}'.</source>
        <target state="translated">모듈의 메서드는 '{0}'(으)로 선언할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ModuleCantUseEventSpecifier1">
        <source>Events in a Module cannot be declared '{0}'.</source>
        <target state="translated">모듈의 이벤트는 '{0}'(으)로 선언할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_StructCantUseVarSpecifier1">
        <source>Members in a Structure cannot be declared '{0}'.</source>
        <target state="translated">구조체의 멤버는 '{0}'(으)로 선언할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InvalidOverrideDueToReturn2">
        <source>'{0}' cannot override '{1}' because they differ by their return types.</source>
        <target state="translated">'반환 형식이 서로 다르므로 '{0}'은(는) '{1}'을(를) 재정의할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_InvalidOverrideDueToTupleNames2">
        <source>'{0}' cannot override '{1}' because they differ by their tuple element names.</source>
        <target state="translated">'튜플 요소 이름이 서로 다르므로 '{0}'은(는) '{1}'을(를) 재정의할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_InvalidOverrideDueToTupleNames2_Title">
        <source>Member cannot override because it differs by its tuple element names.</source>
        <target state="translated">튜플 요소 이름이 서로 다르므로 멤버를 재정의할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ConstantWithNoValue">
        <source>Constants must have a value.</source>
        <target state="translated">상수에는 값이 있어야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExpressionOverflow1">
        <source>Constant expression not representable in type '{0}'.</source>
        <target state="translated">상수 식은 '{0}' 형식으로 표현할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DuplicatePropertyGet">
        <source>'Get' is already declared.</source>
        <target state="translated">'Get'이 이미 선언되었습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DuplicatePropertySet">
        <source>'Set' is already declared.</source>
        <target state="translated">'Set'이 이미 선언되었습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NameNotDeclared1">
        <source>'{0}' is not declared. It may be inaccessible due to its protection level.</source>
        <target state="translated">'{0}'이(가) 선언되지 않았습니다. 해당 보호 수준 때문에 액세스할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BinaryOperands3">
        <source>Operator '{0}' is not defined for types '{1}' and '{2}'.</source>
        <target state="translated">'{1}' 및 '{2}' 형식에 대한 '{0}' 연산자가 정의되지 않았습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExpectedProcedure">
        <source>Expression is not a method.</source>
        <target state="translated">식이 메서드가 아닙니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_OmittedArgument2">
        <source>Argument not specified for parameter '{0}' of '{1}'.</source>
        <target state="translated">'{1}'의 '{0}' 매개 변수에는 인수가 지정되어 있지 않습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NameNotMember2">
        <source>'{0}' is not a member of '{1}'.</source>
        <target state="translated">'{0}'은(는) '{1}'의 멤버가 아닙니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_EndClassNoClass">
        <source>'End Class' must be preceded by a matching 'Class'.</source>
        <target state="translated">'End Class'는 짝이 되는 'Class' 뒤에 와야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadClassFlags1">
        <source>Classes cannot be declared '{0}'.</source>
        <target state="translated">클래스는 '{0}'(으)로 선언할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ImportsMustBeFirst">
        <source>'Imports' statements must precede any declarations.</source>
        <target state="translated">'Imports' 문은 모든 선언의 앞에 와야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NonNamespaceOrClassOnImport2">
        <source>'{1}' for the Imports '{0}' does not refer to a Namespace, Class, Structure, Enum or Module.</source>
        <target state="translated">'Imports '{0}'의 '{1}'은(는) Namespace, Class, Structure, Enum 또는 Module을 참조하지 않습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_TypecharNotallowed">
        <source>Type declaration characters are not valid in this context.</source>
        <target state="translated">이 컨텍스트에서는 형식 선언 문자를 사용할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ObjectReferenceNotSupplied">
        <source>Reference to a non-shared member requires an object reference.</source>
        <target state="translated">공유되지 않는 멤버에 대한 참조에 개체 참조가 필요합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_MyClassNotInClass">
        <source>'MyClass' cannot be used outside of a class.</source>
        <target state="translated">'MyClass'는 클래스 외부에 사용할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_IndexedNotArrayOrProc">
        <source>Expression is not an array or a method, and cannot have an argument list.</source>
        <target state="translated">식이 배열 또는 메서드가 아니므로 인수 목록을 사용할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_EventSourceIsArray">
        <source>'WithEvents' variables cannot be typed as arrays.</source>
        <target state="translated">'WithEvents' 변수는 배열로 형식화할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_SharedConstructorWithParams">
        <source>Shared 'Sub New' cannot have any parameters.</source>
        <target state="translated">Shared 'Sub New'에는 매개 변수를 사용할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_SharedConstructorIllegalSpec1">
        <source>Shared 'Sub New' cannot be declared '{0}'.</source>
        <target state="translated">공유 'Sub New'는 '{0}'(으)로 선언할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExpectedEndClass">
        <source>'Class' statement must end with a matching 'End Class'.</source>
        <target state="translated">'Class' 문은 짝이 되는 'End Class'로 끝나야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_UnaryOperand2">
        <source>Operator '{0}' is not defined for type '{1}'.</source>
        <target state="translated">'{1}' 형식에 대한 '{0}' 연산자가 정의되지 않았습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadFlagsWithDefault1">
        <source>'Default' cannot be combined with '{0}'.</source>
        <target state="translated">'Default'는 '{0}'과(와) 함께 사용할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_VoidValue">
        <source>Expression does not produce a value.</source>
        <target state="translated">식이 값을 산출하지 않습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ConstructorFunction">
        <source>Constructor must be declared as a Sub, not as a Function.</source>
        <target state="translated">생성자는 Function이 아니라 Sub로 선언되어야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InvalidLiteralExponent">
        <source>Exponent is not valid.</source>
        <target state="translated">지수가 잘못되었습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NewCannotHandleEvents">
        <source>'Sub New' cannot handle events.</source>
        <target state="translated">'Sub New'는 이벤트를 처리할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CircularEvaluation1">
        <source>Constant '{0}' cannot depend on its own value.</source>
        <target state="translated">'{0}' 상수는 자신의 값에 종속될 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadFlagsOnSharedMeth1">
        <source>'Shared' cannot be combined with '{0}' on a method declaration.</source>
        <target state="translated">'Shared'는 메서드 선언에서 '{0}'과(와) 함께 사용할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadFlagsOnSharedProperty1">
        <source>'Shared' cannot be combined with '{0}' on a property declaration.</source>
        <target state="translated">'Shared'는 속성 선언에서 '{0}'과(와) 함께 사용할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadFlagsOnStdModuleProperty1">
        <source>Properties in a Module cannot be declared '{0}'.</source>
        <target state="translated">모듈의 속성은 '{0}'(으)로 선언할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_SharedOnProcThatImpl">
        <source>Methods or events that implement interface members cannot be declared 'Shared'.</source>
        <target state="translated">인터페이스 멤버를 구현하는 메서드 또는 이벤트는 'Shared'로 선언할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NoWithEventsVarOnHandlesList">
        <source>Handles clause requires a WithEvents variable defined in the containing type or one of its base types.</source>
        <target state="translated">Handles 절에는 포함하는 형식 또는 해당 형식의 기본 형식 중 하나에 정의된 WithEvents 변수가 필요합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InheritanceAccessMismatch5">
        <source>'{0}' cannot inherit from {1} '{2}' because it expands the access of the base {1} to {3} '{4}'.</source>
        <target state="translated">'{0}'은(는) 기본 {1}의 액세스를 {3} '{4}'(으)로 확장하므로 {1} '{2}'에서 상속할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NarrowingConversionDisallowed2">
        <source>Option Strict On disallows implicit conversions from '{0}' to '{1}'.</source>
        <target state="translated">Option Strict On에서는 '{0}'에서 '{1}'(으)로 암시적으로 변환할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NoArgumentCountOverloadCandidates1">
        <source>Overload resolution failed because no accessible '{0}' accepts this number of arguments.</source>
        <target state="translated">지정한 개수의 인수를 허용하는 액세스 가능한 '{0}'이(가) 없으므로 오버로드를 확인하지 못했습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NoViableOverloadCandidates1">
        <source>Overload resolution failed because no '{0}' is accessible.</source>
        <target state="translated">액세스 가능한 '{0}'이(가) 없으므로 오버로드를 확인하지 못했습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NoCallableOverloadCandidates2">
        <source>Overload resolution failed because no accessible '{0}' can be called with these arguments:{1}</source>
        <target state="translated">이 인수로 호출할 수 있는 액세스 가능한 '{0}'이(가) 없으므로 오버로드를 확인하지 못했습니다({1}).</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadOverloadCandidates2">
        <source>Overload resolution failed because no accessible '{0}' can be called:{1}</source>
        <target state="translated">액세스 가능한 '{0}'을(를) 호출할 수 없어 오버로드를 확인하지 못했습니다({1}).</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NoNonNarrowingOverloadCandidates2">
        <source>Overload resolution failed because no accessible '{0}' can be called without a narrowing conversion:{1}</source>
        <target state="translated">형식을 축소 변환하지 않고 호출할 수 있는 액세스 가능한 '{0}'이(가) 없으므로 오버로드를 확인하지 못했습니다({1}).</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ArgumentNarrowing3">
        <source>Argument matching parameter '{0}' narrows from '{1}' to '{2}'.</source>
        <target state="translated">'{0}' 매개 변수와 일치하는 인수는 '{1}'에서 '{2}'(으)로 한정됩니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NoMostSpecificOverload2">
        <source>Overload resolution failed because no accessible '{0}' is most specific for these arguments:{1}</source>
        <target state="translated">다음 인수에만 한정되는 액세스 가능한 '{0}'이(가) 없으므로 오버로드를 확인하지 못했습니다({1}).</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NotMostSpecificOverload">
        <source>Not most specific.</source>
        <target state="translated">한정적이지 않습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_OverloadCandidate2">
        <source>
    '{0}': {1}</source>
        <target state="translated">
    '{0}': {1}</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NoGetProperty1">
        <source>Property '{0}' is 'WriteOnly'.</source>
        <target state="translated">'{0}' 속성은 'WriteOnly'입니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NoSetProperty1">
        <source>Property '{0}' is 'ReadOnly'.</source>
        <target state="translated">'{0}' 속성이 'ReadOnly'입니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ParamTypingInconsistency">
        <source>All parameters must be explicitly typed if any of them are explicitly typed.</source>
        <target state="translated">매개 변수 중 하나라도 명시적으로 형식화된 경우 모든 매개 변수를 명시적으로 형식화해야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ParamNameFunctionNameCollision">
        <source>Parameter cannot have the same name as its defining function.</source>
        <target state="translated">매개 변수에는 자신을 정의하는 함수와 같은 이름을 사용할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DateToDoubleConversion">
        <source>Conversion from 'Date' to 'Double' requires calling the 'Date.ToOADate' method.</source>
        <target state="translated">Date'를 'Double'로 변환하려면 'Date.ToOADate' 메서드를 호출해야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DoubleToDateConversion">
        <source>Conversion from 'Double' to 'Date' requires calling the 'Date.FromOADate' method.</source>
        <target state="translated">Double'을 'Date'로 변환하려면 'Date.FromOADate' 메서드를 호출해야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ZeroDivide">
        <source>Division by zero occurred while evaluating this expression.</source>
        <target state="translated">이 식을 계산할 때 0으로 나눠졌습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_TryAndOnErrorDoNotMix">
        <source>Method cannot contain both a 'Try' statement and an 'On Error' or 'Resume' statement.</source>
        <target state="translated">메서드에는 'Try' 문과 함께 'On Error' 또는 'Resume' 문을 사용할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PropertyAccessIgnored">
        <source>Property access must assign to the property or use its value.</source>
        <target state="translated">속성 액세스를 속성에 할당하거나 속성 액세스에서 속성 값을 사용해야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InterfaceNoDefault1">
        <source>'{0}' cannot be indexed because it has no default property.</source>
        <target state="translated">'{0}'은(는) 기본 속성이 없으므로 인덱싱될 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InvalidAssemblyAttribute1">
        <source>Attribute '{0}' cannot be applied to an assembly.</source>
        <target state="translated">'{0}' 특성을 어셈블리에 적용할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InvalidModuleAttribute1">
        <source>Attribute '{0}' cannot be applied to a module.</source>
        <target state="translated">'{0}' 특성을 모듈에 적용할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AmbiguousInUnnamedNamespace1">
        <source>'{0}' is ambiguous.</source>
        <target state="translated">'{0}'이(가) 모호합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DefaultMemberNotProperty1">
        <source>Default member of '{0}' is not a property.</source>
        <target state="translated">'{0}'의 기본 멤버는 속성이 아닙니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AmbiguousInNamespace2">
        <source>'{0}' is ambiguous in the namespace '{1}'.</source>
        <target state="translated">'{0}'이(가) '{1}' 네임스페이스에서 모호합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AmbiguousInImports2">
        <source>'{0}' is ambiguous, imported from the namespaces or types '{1}'.</source>
        <target state="translated">'{1}' 네임스페이스 또는 형식에서 가져온 '{0}'이(가) 모호합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AmbiguousInModules2">
        <source>'{0}' is ambiguous between declarations in Modules '{1}'.</source>
        <target state="translated">'{0}'이(가) '{1}' 모듈의 선언 사이에서 모호합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AmbiguousInNamespaces2">
        <source>'{0}' is ambiguous between declarations in namespaces '{1}'.</source>
        <target state="translated">'{0}'이(가) '{1}' 네임스페이스의 선언 사이에서 모호합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ArrayInitializerTooFewDimensions">
        <source>Array initializer has too few dimensions.</source>
        <target state="translated">배열 이니셜라이저의 차원이 너무 적습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ArrayInitializerTooManyDimensions">
        <source>Array initializer has too many dimensions.</source>
        <target state="translated">배열 이니셜라이저의 차원이 너무 많습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InitializerTooFewElements1">
        <source>Array initializer is missing {0} elements.</source>
        <target state="translated">배열 이니셜라이저에 요소가 {0}개 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InitializerTooManyElements1">
        <source>Array initializer has {0} too many elements.</source>
        <target state="translated">배열 이니셜라이저의 요소가 {0}개 많습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NewOnAbstractClass">
        <source>'New' cannot be used on a class that is declared 'MustInherit'.</source>
        <target state="translated">'New'는 'MustInherit'으로 선언된 클래스에 사용할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DuplicateNamedImportAlias1">
        <source>Alias '{0}' is already declared.</source>
        <target state="translated">'{0}' 별칭이 이미 선언되었습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DuplicatePrefix">
        <source>XML namespace prefix '{0}' is already declared.</source>
        <target state="translated">XML 네임스페이스 접두사 '{0}'이(가) 이미 선언되었습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_StrictDisallowsLateBinding">
        <source>Option Strict On disallows late binding.</source>
        <target state="translated">Option Strict On에서는 런타임에 바인딩을 사용할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AddressOfOperandNotMethod">
        <source>'AddressOf' operand must be the name of a method (without parentheses).</source>
        <target state="translated">'AddressOf' 피연산자에는 괄호 없이 메서드 이름을 사용해야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_EndExternalSource">
        <source>'#End ExternalSource' must be preceded by a matching '#ExternalSource'.</source>
        <target state="translated">'#End ExternalSource'는 짝이 되는 '#ExternalSource' 뒤에 와야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExpectedEndExternalSource">
        <source>'#ExternalSource' statement must end with a matching '#End ExternalSource'.</source>
        <target state="translated">'#ExternalSource' 문은 짝이 되는 '#End ExternalSource'로 끝나야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NestedExternalSource">
        <source>'#ExternalSource' directives cannot be nested.</source>
        <target state="translated">'#ExternalSource' 지시문은 중첩될 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AddressOfNotDelegate1">
        <source>'AddressOf' expression cannot be converted to '{0}' because '{0}' is not a delegate type.</source>
        <target state="translated">'{0}'이(가) 대리자 형식이 아니므로 'AddressOf' 식을 '{0}'(으)로 변환할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_SyncLockRequiresReferenceType1">
        <source>'SyncLock' operand cannot be of type '{0}' because '{0}' is not a reference type.</source>
        <target state="translated">'{0}'이(가) 참조 형식이 아니므로 'SyncLock' 피연산자는 '{0}' 형식일 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_MethodAlreadyImplemented2">
        <source>'{0}.{1}' cannot be implemented more than once.</source>
        <target state="translated">'{0}.{1}'은(는) 두 번 이상 구현할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DuplicateInInherits1">
        <source>'{0}' cannot be inherited more than once.</source>
        <target state="translated">'{0}'을(를) 두 번 이상 상속할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NamedParamArrayArgument">
        <source>Named argument cannot match a ParamArray parameter.</source>
        <target state="translated">명명된 인수는 ParamArray 매개 변수와 일치할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_OmittedParamArrayArgument">
        <source>Omitted argument cannot match a ParamArray parameter.</source>
        <target state="translated">생략된 인수는 ParamArray 매개 변수와 일치할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ParamArrayArgumentMismatch">
        <source>Argument cannot match a ParamArray parameter.</source>
        <target state="translated">인수는 ParamArray 매개 변수와 일치할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_EventNotFound1">
        <source>Event '{0}' cannot be found.</source>
        <target state="translated">'{0}' 이벤트가 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ModuleCantUseVariableSpecifier1">
        <source>Variables in Modules cannot be declared '{0}'.</source>
        <target state="translated">모듈의 변수는 '{0}'(으)로 선언할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_SharedEventNeedsSharedHandler">
        <source>Events of shared WithEvents variables cannot be handled by non-shared methods.</source>
        <target state="translated">비공유 메서드에서는 공유 WithEvents 변수의 이벤트를 처리할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExpectedMinus">
        <source>'-' expected.</source>
        <target state="translated">'-'가 필요합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InterfaceMemberSyntax">
        <source>Interface members must be methods, properties, events, or type definitions.</source>
        <target state="translated">인터페이스 멤버는 메서드, 속성, 이벤트 또는 형식 정의여야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InvInsideInterface">
        <source>Statement cannot appear within an interface body.</source>
        <target state="translated">인터페이스 본문 안에는 문을 사용할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InvInsideEndsInterface">
        <source>Statement cannot appear within an interface body. End of interface assumed.</source>
        <target state="translated">인터페이스 본문 안에는 문을 사용할 수 없습니다. 인터페이스의 끝으로 간주합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadFlagsInNotInheritableClass1">
        <source>'NotInheritable' classes cannot have members declared '{0}'.</source>
        <target state="translated">'NotInheritable' 클래스에는 '{0}'(으)로 선언된 멤버를 포함할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BaseOnlyClassesMustBeExplicit2">
        <source>Class '{0}' must either be declared 'MustInherit' or override the following inherited 'MustOverride' member(s): {1}.</source>
        <target state="translated">'{0}' 클래스를 'MustInherit'으로 선언하거나, 상속된 'MustOverride' 멤버인 '{1}'을(를) 재정의해야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_MustInheritEventNotOverridden">
        <source>'{0}' is a MustOverride event in the base class '{1}'. Visual Basic does not support event overriding. You must either provide an implementation for the event in the base class, or make class '{2}' MustInherit.</source>
        <target state="translated">'{0}'은(는) 기본 클래스 '{1}'의 MustOverride 이벤트입니다. Visual Basic은 이벤트 재정의를 지원하지 않습니다. 기본 클래스에서 해당 이벤트를 위한 구현을 제공하거나 클래스 '{2}' MustInherit를 만들어야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NegativeArraySize">
        <source>Array dimensions cannot have a negative size.</source>
        <target state="translated">배열 차원의 크기는 음수일 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_MyClassAbstractCall1">
        <source>'MustOverride' method '{0}' cannot be called with 'MyClass'.</source>
        <target state="translated">'MustOverride' 메서드 '{0}'은(는) 'MyClass'로 호출할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_EndDisallowedInDllProjects">
        <source>'End' statement cannot be used in class library projects.</source>
        <target state="translated">'End' 문은 클래스 라이브러리 프로젝트에 사용할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BlockLocalShadowing1">
        <source>Variable '{0}' hides a variable in an enclosing block.</source>
        <target state="translated">'{0}' 변수는 바깥쪽 블록에 있는 변수를 숨깁니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ModuleNotAtNamespace">
        <source>'Module' statements can occur only at file or namespace level.</source>
        <target state="translated">'Module' 문은 파일이나 네임스페이스 수준에서만 사용할 수 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NamespaceNotAtNamespace">
        <source>'Namespace' statements can occur only at file or namespace level.</source>
        <target state="translated">'Namespace' 문은 파일이나 네임스페이스 수준에서만 사용할 수 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InvInsideEnum">
        <source>Statement cannot appear within an Enum body.</source>
        <target state="translated">열거형 본문 안에는 문을 사용할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InvInsideEndsEnum">
        <source>Statement cannot appear within an Enum body. End of Enum assumed.</source>
        <target state="translated">열거형 본문 안에는 문을 사용할 수 없습니다. 열거형의 끝으로 간주합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InvalidOptionStrict">
        <source>'Option Strict' can be followed only by 'On' or 'Off'.</source>
        <target state="translated">'Option Strict' 뒤에는 'On' 또는 'Off'만 올 수 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_EndStructureNoStructure">
        <source>'End Structure' must be preceded by a matching 'Structure'.</source>
        <target state="translated">'End Structure'는 짝이 되는 'Structure' 뒤에 와야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_EndModuleNoModule">
        <source>'End Module' must be preceded by a matching 'Module'.</source>
        <target state="translated">'End Module'은 짝이 되는 'Module' 뒤에 와야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_EndNamespaceNoNamespace">
        <source>'End Namespace' must be preceded by a matching 'Namespace'.</source>
        <target state="translated">'End Namespace'는 짝이 되는 'Namespace' 뒤에 와야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExpectedEndStructure">
        <source>'Structure' statement must end with a matching 'End Structure'.</source>
        <target state="translated">'Structure' 문은 짝이 되는 'End Structure'로 끝나야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExpectedEndModule">
        <source>'Module' statement must end with a matching 'End Module'.</source>
        <target state="translated">'Module' 문은 짝이 되는 'End Module'로 끝나야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExpectedEndNamespace">
        <source>'Namespace' statement must end with a matching 'End Namespace'.</source>
        <target state="translated">'Namespace' 문은 짝이 되는 'End Namespace'로 끝나야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_OptionStmtWrongOrder">
        <source>'Option' statements must precede any declarations or 'Imports' statements.</source>
        <target state="translated">'Option' 문은 모든 선언 또는 'Imports' 문 앞에 와야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_StructCantInherit">
        <source>Structures cannot have 'Inherits' statements.</source>
        <target state="translated">구조체에는 'Inherits' 문을 사용할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NewInStruct">
        <source>Structures cannot declare a non-shared 'Sub New' with no parameters.</source>
        <target state="translated">구조는 매개 변수가 없고 공유되지 않는 'Sub New'를 선언할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InvalidEndGet">
        <source>'End Get' must be preceded by a matching 'Get'.</source>
        <target state="translated">'End Get'은 짝이 되는 'Get' 뒤에 와야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_MissingEndGet">
        <source>'Get' statement must end with a matching 'End Get'.</source>
        <target state="translated">'Get' 문은 짝이 되는 'End Get'으로 끝나야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InvalidEndSet">
        <source>'End Set' must be preceded by a matching 'Set'.</source>
        <target state="translated">'End Set'은 짝이 되는 'Set' 뒤에 와야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_MissingEndSet">
        <source>'Set' statement must end with a matching 'End Set'.</source>
        <target state="translated">'Set' 문은 짝이 되는 'End Set'으로 끝나야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InvInsideEndsProperty">
        <source>Statement cannot appear within a property body. End of property assumed.</source>
        <target state="translated">속성 본문 안에는 문을 사용할 수 없습니다. 속성의 끝으로 간주합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DuplicateWriteabilityCategoryUsed">
        <source>'ReadOnly' and 'WriteOnly' cannot be combined.</source>
        <target state="translated">'ReadOnly'와 'WriteOnly'는 함께 사용할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExpectedGreater">
        <source>'&gt;' expected.</source>
        <target state="translated">'&gt;'가 필요합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AttributeStmtWrongOrder">
        <source>Assembly or Module attribute statements must precede any declarations in a file.</source>
        <target state="translated">어셈블리 또는 모듈 특성 문은 파일의 모든 선언 앞에 와야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NoExplicitArraySizes">
        <source>Array bounds cannot appear in type specifiers.</source>
        <target state="translated">배열 범위는 형식 지정자에 사용할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadPropertyFlags1">
        <source>Properties cannot be declared '{0}'.</source>
        <target state="translated">속성은 '{0}'(으)로 선언할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InvalidOptionExplicit">
        <source>'Option Explicit' can be followed only by 'On' or 'Off'.</source>
        <target state="translated">'Option Explicit' 뒤에는 'On' 또는 'Off'만 올 수 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_MultipleParameterSpecifiers">
        <source>'ByVal' and 'ByRef' cannot be combined.</source>
        <target state="translated">'ByVal'과 'ByRef'는 함께 사용할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_MultipleOptionalParameterSpecifiers">
        <source>'Optional' and 'ParamArray' cannot be combined.</source>
        <target state="translated">'Optional'과 'ParamArray'는 함께 사용할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_UnsupportedProperty1">
        <source>Property '{0}' is of an unsupported type.</source>
        <target state="translated">'{0}' 속성은 지원되지 않는 형식입니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InvalidOptionalParameterUsage1">
        <source>Attribute '{0}' cannot be applied to a method with optional parameters.</source>
        <target state="translated">'{0}' 특성을 선택적 매개 변수가 있는 메서드에 적용할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ReturnFromNonFunction">
        <source>'Return' statement in a Sub or a Set cannot return a value.</source>
        <target state="translated">'Sub 또는 Set의 'Return' 문은 값을 반환할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_UnterminatedStringLiteral">
        <source>String constants must end with a double quote.</source>
        <target state="translated">문자열 상수는 큰따옴표로 끝나야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_UnsupportedType1">
        <source>'{0}' is an unsupported type.</source>
        <target state="translated">'{0}'은(는) 지원되지 않는 형식입니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InvalidEnumBase">
        <source>Enums must be declared as an integral type.</source>
        <target state="translated">열거형은 정수 계열 형식으로 선언해야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ByRefIllegal1">
        <source>{0} parameters cannot be declared 'ByRef'.</source>
        <target state="translated">{0} 매개 변수는 'ByRef'로 선언할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_UnreferencedAssembly3">
        <source>Reference required to assembly '{0}' containing the type '{1}'. Add one to your project.</source>
        <target state="translated">'{1}' 형식을 포함하는 '{0}' 어셈블리에 대한 참조를 찾을 수 없습니다. 프로젝트에 추가하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_UnreferencedModule3">
        <source>Reference required to module '{0}' containing the type '{1}'. Add one to your project.</source>
        <target state="translated">'{1}' 형식을 포함하는 '{0}' 모듈에 대한 참조를 찾을 수 없습니다. 프로젝트에 추가하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ReturnWithoutValue">
        <source>'Return' statement in a Function, Get, or Operator must return a value.</source>
        <target state="translated">'Function, Get 또는 Operator의 'Return' 문은 값을 반환해야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_UnsupportedField1">
        <source>Field '{0}' is of an unsupported type.</source>
        <target state="translated">'{0}' 필드는 지원되지 않는 형식입니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_UnsupportedMethod1">
        <source>'{0}' has a return type that is not supported or parameter types that are not supported.</source>
        <target state="translated">'{0}'에 지원되지 않는 반환 형식 또는 지원되지 않는 매개 변수 형식이 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NoNonIndexProperty1">
        <source>Property '{0}' with no parameters cannot be found.</source>
        <target state="translated">매개 변수가 없는 '{0}' 속성을 찾을 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadAttributePropertyType1">
        <source>Property or field '{0}' does not have a valid attribute type.</source>
        <target state="translated">'{0}' 속성 또는 필드의 특성 형식이 잘못되었습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_LocalsCannotHaveAttributes">
        <source>Attributes cannot be applied to local variables.</source>
        <target state="translated">지역 변수에는 특성을 적용할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PropertyOrFieldNotDefined1">
        <source>Field or property '{0}' is not found.</source>
        <target state="translated">'{0}' 속성 또는 필드를 찾을 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InvalidAttributeUsage2">
        <source>Attribute '{0}' cannot be applied to '{1}' because the attribute is not valid on this declaration type.</source>
        <target state="translated">이 선언 형식에서는 '{0}' 특성이 유효하지 않으므로 '{1}'에 적용할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InvalidAttributeUsageOnAccessor">
        <source>Attribute '{0}' cannot be applied to '{1}' of '{2}' because the attribute is not valid on this declaration type.</source>
        <target state="translated">이 선언 형식에서는 '{0}' 특성이 유효하지 않으므로 '{2}'의 '{1}'에 적용할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NestedTypeInInheritsClause2">
        <source>Class '{0}' cannot reference its nested type '{1}' in Inherits clause.</source>
        <target state="translated">'{0}' 클래스는 상속 절에서 '{1}' 중첩 형식을 참조할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_TypeInItsInheritsClause1">
        <source>Class '{0}' cannot reference itself in Inherits clause.</source>
        <target state="translated">'{0}' 클래스는 상속 절에서 자신을 참조할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BaseTypeReferences2">
        <source>
    Base type of '{0}' needs '{1}' to be resolved.</source>
        <target state="translated">
    '{0}'의 형식은 모두 확인하려면 '{1}'이(가) 필요합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_IllegalBaseTypeReferences3">
        <source>Inherits clause of {0} '{1}' causes cyclic dependency: {2}</source>
        <target state="translated">{0} '{1}' 절을 상속하면 종속성이 순환됩니다({2}).</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InvalidMultipleAttributeUsage1">
        <source>Attribute '{0}' cannot be applied multiple times.</source>
        <target state="translated">'{0}' 특성을 여러 번 적용할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InvalidMultipleAttributeUsageInNetModule2">
        <source>Attribute '{0}' in '{1}' cannot be applied multiple times.</source>
        <target state="translated">'{1}'에서 '{0}' 특성을 여러 번 적용할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CantThrowNonException">
        <source>'Throw' operand must derive from 'System.Exception'.</source>
        <target state="translated">'Throw' 피연산자는 'System.Exception'에서 파생되어야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_MustBeInCatchToRethrow">
        <source>'Throw' statement cannot omit operand outside a 'Catch' statement or inside a 'Finally' statement.</source>
        <target state="translated">'Throw' 문은 'Catch' 문 외부 또는 'Finally' 문 내부에서 피연산자를 생략할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ParamArrayMustBeByVal">
        <source>ParamArray parameters must be declared 'ByVal'.</source>
        <target state="translated">ParamArray 매개 변수는 'ByVal'로 선언해야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_UseOfObsoleteSymbol2">
        <source>'{0}' is obsolete: '{1}'.</source>
        <target state="translated">'{0}'은(는) 사용되지 않습니다('{1}').</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RedimNoSizes">
        <source>'ReDim' statements require a parenthesized list of the new bounds of each dimension of the array.</source>
        <target state="translated">'ReDim' 문에는 배열의 각 차원에 대한 새 범위의 괄호로 묶인 목록이 있어야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InitWithMultipleDeclarators">
        <source>Explicit initialization is not permitted with multiple variables declared with a single type specifier.</source>
        <target state="translated">단일 형식 지정자로 선언된 여러 개의 변수로는 명시적으로 초기화할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InitWithExplicitArraySizes">
        <source>Explicit initialization is not permitted for arrays declared with explicit bounds.</source>
        <target state="translated">명시적 범위로 선언된 배열은 명시적으로 초기화할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_EndSyncLockNoSyncLock">
        <source>'End SyncLock' must be preceded by a matching 'SyncLock'.</source>
        <target state="translated">'End SyncLock'은 짝이 되는 'SyncLock' 뒤에 와야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExpectedEndSyncLock">
        <source>'SyncLock' statement must end with a matching 'End SyncLock'.</source>
        <target state="translated">'SyncLock' 문은 짝이 되는 'End SyncLock'으로 끝나야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NameNotEvent2">
        <source>'{0}' is not an event of '{1}'.</source>
        <target state="translated">'{0}'은(는) '{1}'의 이벤트가 아닙니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AddOrRemoveHandlerEvent">
        <source>'AddHandler' or 'RemoveHandler' statement event operand must be a dot-qualified expression or a simple name.</source>
        <target state="translated">'AddHandler' 또는 'RemoveHandler' 문의 이벤트 피연산자는 점으로 한정된 식이거나 단순한 이름이어야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_UnrecognizedEnd">
        <source>'End' statement not valid.</source>
        <target state="translated">'End' 문이 잘못되었습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ArrayInitForNonArray2">
        <source>Array initializers are valid only for arrays, but the type of '{0}' is '{1}'.</source>
        <target state="translated">배열 이니셜라이저는 배열에만 유효하지만 '{0}'의 형식은 '{1}'입니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_EndRegionNoRegion">
        <source>'#End Region' must be preceded by a matching '#Region'.</source>
        <target state="translated">'#End Region'은 짝이 되는 '#Region' 뒤에 와야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExpectedEndRegion">
        <source>'#Region' statement must end with a matching '#End Region'.</source>
        <target state="translated">'#Region' 문은 짝이 되는 '#End Region'으로 끝나야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InheritsStmtWrongOrder">
        <source>'Inherits' statement must precede all declarations in a class.</source>
        <target state="translated">'Inherits' 문은 클래스의 모든 선언 앞에 와야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AmbiguousAcrossInterfaces3">
        <source>'{0}' is ambiguous across the inherited interfaces '{1}' and '{2}'.</source>
        <target state="translated">'{0}'이(가) 상속된 인터페이스 '{1}' 및 '{2}'에서 모호합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DefaultPropertyAmbiguousAcrossInterfaces4">
        <source>Default property access is ambiguous between the inherited interface members '{0}' of interface '{1}' and '{2}' of interface '{3}'.</source>
        <target state="translated">기본 속성 액세스가 '{1}' 인터페이스의 상속된 인터페이스 멤버 '{0}'과(와) '{3}' 인터페이스의 상속된 인터페이스 멤버 '{2}' 사이에서 모호합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InterfaceEventCantUse1">
        <source>Events in interfaces cannot be declared '{0}'.</source>
        <target state="translated">인터페이스의 이벤트는 '{0}'(으)로 선언할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExecutableAsDeclaration">
        <source>Statement cannot appear outside of a method body.</source>
        <target state="translated">문은 메서드 본문 외부에 사용할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_StructureNoDefault1">
        <source>Structure '{0}' cannot be indexed because it has no default property.</source>
        <target state="translated">'{0}' 구조체는 기본 속성이 없으므로 인덱싱될 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_MustShadow2">
        <source>{0} '{1}' must be declared 'Shadows' because another member with this name is declared 'Shadows'.</source>
        <target state="translated">이름이 같은 다른 멤버가 'Shadows'로 선언되었으므로 {0} '{1}'은(는) 'Shadows'로 선언해야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_OverrideWithOptionalTypes2">
        <source>'{0}' cannot override '{1}' because they differ by the types of optional parameters.</source>
        <target state="translated">'선택적 매개 변수의 형식이 서로 다르므로 '{0}'은(는) '{1}'을(를) 재정의할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExpectedEndOfExpression">
        <source>End of expression expected.</source>
        <target state="translated">식의 끝이 필요합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_StructsCannotHandleEvents">
        <source>Methods declared in structures cannot have 'Handles' clauses.</source>
        <target state="translated">구조체에 선언된 메서드에는 'Handles' 절을 사용할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_OverridesImpliesOverridable">
        <source>Methods declared 'Overrides' cannot be declared 'Overridable' because they are implicitly overridable.</source>
        <target state="translated">Overrides'로 선언된 메서드는 암시적으로 재정의할 수 있으므로 'Overridable'로 선언할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_LocalNamedSameAsParam1">
        <source>'{0}' is already declared as a parameter of this method.</source>
        <target state="translated">'{0}'이(가) 이 메서드의 매개 변수로 이미 선언되었습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_LocalNamedSameAsParamInLambda1">
        <source>Variable '{0}' is already declared as a parameter of this or an enclosing lambda expression.</source>
        <target state="translated">'{0}' 변수가 이미 이 항목의 매개 변수 또는 바깥쪽 람다 식으로 선언되어 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ModuleCantUseTypeSpecifier1">
        <source>Type in a Module cannot be declared '{0}'.</source>
        <target state="translated">모듈의 형식은 '{0}'(으)로 선언할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InValidSubMainsFound1">
        <source>No accessible 'Main' method with an appropriate signature was found in '{0}'.</source>
        <target state="translated">'{0}'에 적절한 시그니처가 있는 액세스 가능한 'Main' 메서드가 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_MoreThanOneValidMainWasFound2">
        <source>'Sub Main' is declared more than once in '{0}': {1}</source>
        <target state="translated">'{0}'에서 'Sub Main'을 두 번 이상 선언했습니다({1}).</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CannotConvertValue2">
        <source>Value '{0}' cannot be converted to '{1}'.</source>
        <target state="translated">'{0}' 변수는 '{1}'(으)로 변환할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_OnErrorInSyncLock">
        <source>'On Error' statements are not valid within 'SyncLock' statements.</source>
        <target state="translated">'On Error' 문은 'SyncLock' 문 안에서 사용할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NarrowingConversionCollection2">
        <source>Option Strict On disallows implicit conversions from '{0}' to '{1}'; the Visual Basic 6.0 collection type is not compatible with the .NET Framework collection type.</source>
        <target state="translated">Option Strict On에서는 '{0}'에서 '{1}'(으)로 암시적으로 변환할 수 없습니다. Visual Basic 6.0의 컬렉션 형식은 .NET Framework의 컬렉션 형식과 호환되지 않습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_GotoIntoTryHandler">
        <source>'GoTo {0}' is not valid because '{0}' is inside a 'Try', 'Catch' or 'Finally' statement that does not contain this statement.</source>
        <target state="translated">'{0}'이(가) 이 문을 포함하지 않는 'Try', 'Catch' 또는 'Finally' 문 내부에 있기 때문에 'GoTo {0}'은(는) 유효하지 않습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_GotoIntoSyncLock">
        <source>'GoTo {0}' is not valid because '{0}' is inside a 'SyncLock' statement that does not contain this statement.</source>
        <target state="translated">'{0}'이(가) 이 문을 포함하지 않는 'SyncLock' 문 내부에 있기 때문에 'GoTo {0}'은(는) 유효하지 않습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_GotoIntoWith">
        <source>'GoTo {0}' is not valid because '{0}' is inside a 'With' statement that does not contain this statement.</source>
        <target state="translated">'{0}'이(가) 이 문을 포함하지 않는 'With' 문 내부에 있기 때문에 'GoTo {0}'은(는) 유효하지 않습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_GotoIntoFor">
        <source>'GoTo {0}' is not valid because '{0}' is inside a 'For' or 'For Each' statement that does not contain this statement.</source>
        <target state="translated">'{0}'이(가) 이 문을 포함하지 않는 'For' 또는 'For Each' 문 내부에 있기 때문에 'GoTo {0}'은(는) 유효하지 않습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadAttributeNonPublicConstructor">
        <source>Attribute cannot be used because it does not have a Public constructor.</source>
        <target state="translated">특성에 Public 생성자가 없으므로 특성을 사용할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DefaultEventNotFound1">
        <source>Event '{0}' specified by the 'DefaultEvent' attribute is not a publicly accessible event for this class.</source>
        <target state="translated">DefaultEvent' 특성에 의해 지정된 '{0}' 이벤트의 이 클래스에 대한 액세스 가능성은 public이 아닙니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InvalidNonSerializedUsage">
        <source>'NonSerialized' attribute will not have any effect on this member because its containing class is not exposed as 'Serializable'.</source>
        <target state="translated">'NonSerialized' 특성은 포함하는 클래스가 'Serializable'로 노출되지 않으므로 이 멤버에 영향을 주지 않습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExpectedContinueKind">
        <source>'Continue' must be followed by 'Do', 'For' or 'While'.</source>
        <target state="translated">'Continue' 다음에는 'Do', 'For' 또는 'While'이 와야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ContinueDoNotWithinDo">
        <source>'Continue Do' can only appear inside a 'Do' statement.</source>
        <target state="translated">'Continue Do'는 'Do' 문 내부에만 사용할 수 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ContinueForNotWithinFor">
        <source>'Continue For' can only appear inside a 'For' statement.</source>
        <target state="translated">'Continue For'는 'For' 문 내부에만 사용할 수 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ContinueWhileNotWithinWhile">
        <source>'Continue While' can only appear inside a 'While' statement.</source>
        <target state="translated">'Continue While'은 'While' 문 내부에만 사용할 수 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DuplicateParameterSpecifier">
        <source>Parameter specifier is duplicated.</source>
        <target state="translated">매개 변수 지정자가 중복되었습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ModuleCantUseDLLDeclareSpecifier1">
        <source>'Declare' statements in a Module cannot be declared '{0}'.</source>
        <target state="translated">'모듈의 'Declare' 문은 '{0}'(으)로 선언할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_StructCantUseDLLDeclareSpecifier1">
        <source>'Declare' statements in a structure cannot be declared '{0}'.</source>
        <target state="translated">'구조체의 'Declare' 문은 '{0}'(으)로 선언할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_TryCastOfValueType1">
        <source>'TryCast' operand must be reference type, but '{0}' is a value type.</source>
        <target state="translated">'TryCast' 피연산자는 참조 형식이어야 하는데 '{0}'은(는) 값 형식입니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_TryCastOfUnconstrainedTypeParam1">
        <source>'TryCast' operands must be class-constrained type parameter, but '{0}' has no class constraint.</source>
        <target state="translated">'TryCast' 피연산자는 클래스 제약 조건이 있는 형식 매개 변수여야 하는데, '{0}'에는 클래스 제약 조건이 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AmbiguousDelegateBinding2">
        <source>No accessible '{0}' is most specific: {1}</source>
        <target state="translated">액세스할 수 없는 '{0}'은(는) {1}에만 한정됩니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_SharedStructMemberCannotSpecifyNew">
        <source>Non-shared members in a Structure cannot be declared 'New'.</source>
        <target state="translated">구조체의 멤버 중 비공유 멤버는 'New'로 선언할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_GenericSubMainsFound1">
        <source>None of the accessible 'Main' methods with the appropriate signatures found in '{0}' can be the startup method since they are all either generic or nested in generic types.</source>
        <target state="translated">'{0}'에 있는 적절한 시그니처가 포함된 액세스 가능한 'Main' 메서드는 모두 제네릭이거나 제네릭 형식에 중첩되어 있으므로 시작 메서드일 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_GeneralProjectImportsError3">
        <source>Error in project-level import '{0}' at '{1}' : {2}</source>
        <target state="translated">'{1}'에 있는 프로젝트 수준의 가져오기 '{0}'에서 오류가 발생했습니다({2}).</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InvalidTypeForAliasesImport2">
        <source>'{1}' for the Imports alias to '{0}' does not refer to a Namespace, Class, Structure, Interface, Enum or Module.</source>
        <target state="translated">'{0}'에 대한 Imports 별칭의 '{1}'은(는) Namespace, Class, Structure, Interface, Enum 또는 Module을 참조하지 않습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_UnsupportedConstant2">
        <source>Field '{0}.{1}' has an invalid constant value.</source>
        <target state="translated">{0}.{1}' 필드에 잘못된 상수 값이 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ObsoleteArgumentsNeedParens">
        <source>Method arguments must be enclosed in parentheses.</source>
        <target state="translated">메서드 인수는 괄호로 묶어야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ObsoleteLineNumbersAreLabels">
        <source>Labels that are numbers must be followed by colons.</source>
        <target state="translated">숫자 레이블 뒤에는 콜론이 와야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ObsoleteStructureNotType">
        <source>'Type' statements are no longer supported; use 'Structure' statements instead.</source>
        <target state="translated">'Type' 문이 더 이상 지원되지 않으므로 대신 'Structure' 문을 사용하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ObsoleteObjectNotVariant">
        <source>'Variant' is no longer a supported type; use the 'Object' type instead.</source>
        <target state="translated">'Variant' 형식이 더 이상 지원되지 않으므로 대신 'Object' 형식을 사용하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ObsoleteLetSetNotNeeded">
        <source>'Let' and 'Set' assignment statements are no longer supported.</source>
        <target state="translated">'Let' 및 'Set' 대입문은 더 이상 지원되지 않습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ObsoletePropertyGetLetSet">
        <source>Property Get/Let/Set are no longer supported; use the new Property declaration syntax.</source>
        <target state="translated">Property Get/Let/Set이 더 이상 지원되지 않으므로 새 Property 선언 구문을 사용하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ObsoleteWhileWend">
        <source>'Wend' statements are no longer supported; use 'End While' statements instead.</source>
        <target state="translated">'Wend' 문은 더 이상 지원되지 않습니다. 대신 'End While' 문을 사용하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ObsoleteRedimAs">
        <source>'ReDim' statements can no longer be used to declare array variables.</source>
        <target state="translated">'ReDim' 문은 더 이상 배열 변수를 선언하는 데 사용할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ObsoleteOptionalWithoutValue">
        <source>Optional parameters must specify a default value.</source>
        <target state="translated">선택적 매개 변수는 기본값을 지정해야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ObsoleteGosub">
        <source>'GoSub' statements are no longer supported.</source>
        <target state="translated">'GoSub' 문은 더 이상 지원되지 않습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ObsoleteOnGotoGosub">
        <source>'On GoTo' and 'On GoSub' statements are no longer supported.</source>
        <target state="translated">'On GoTo' 및 'On GoSub' 문은 더 이상 지원되지 않습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ObsoleteEndIf">
        <source>'EndIf' statements are no longer supported; use 'End If' instead.</source>
        <target state="translated">'EndIf' 문은 더 이상 지원되지 않습니다. 대신 'End If' 문을 사용하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ObsoleteExponent">
        <source>'D' can no longer be used to indicate an exponent, use 'E' instead.</source>
        <target state="translated">'지수를 가리키는 데 더 이상 'D'를 사용할 수 없습니다. 대신 'E'를 사용하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ObsoleteAsAny">
        <source>'As Any' is not supported in 'Declare' statements.</source>
        <target state="translated">'Declare' 문에서는 'As Any'가 지원되지 않습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ObsoleteGetStatement">
        <source>'Get' statements are no longer supported. File I/O functionality is available in the 'Microsoft.VisualBasic' namespace.</source>
        <target state="translated">'Get' 문은 더 이상 지원되지 않습니다. 파일 I/O 기능은 'Microsoft.VisualBasic' 네임스페이스에서 사용할 수 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_OverrideWithArrayVsParamArray2">
        <source>'{0}' cannot override '{1}' because they differ by parameters declared 'ParamArray'.</source>
        <target state="translated">'{0}'은(는) '{1}'을(를) 재정의할 수 없습니다. 'ParamArray'로 선언된 매개 변수가 다릅니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CircularBaseDependencies4">
        <source>This inheritance causes circular dependencies between {0} '{1}' and its nested or base type '{2}'.</source>
        <target state="translated">이 상속 때문에 {0} '{1}' 및 그 안에 중첩된 형식이나 기본 형식 '{2}' 사이에서 순환 종속성이 발생합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NestedBase2">
        <source>{0} '{1}' cannot inherit from a type nested within it.</source>
        <target state="translated">{0} '{1}'은(는) 그 안에 중첩된 형식에서 상속할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AccessMismatchOutsideAssembly4">
        <source>'{0}' cannot expose type '{1}' outside the project through {2} '{3}'.</source>
        <target state="translated">'{0}'은(는) {2} '{3}'을(를) 통해 '{1}' 형식을 프로젝트 외부로 노출할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InheritanceAccessMismatchOutside3">
        <source>'{0}' cannot inherit from {1} '{2}' because it expands the access of the base {1} outside the assembly.</source>
        <target state="translated">'{0}'은(는) 기본 {1}의 액세스를 해당 어셈블리 범위 밖으로 확장하므로 {1} '{2}'에서 상속할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_UseOfObsoletePropertyAccessor3">
        <source>'{0}' accessor of '{1}' is obsolete: '{2}'.</source>
        <target state="translated">'{1}'의 '{0}' 접근자는 사용되지 않습니다('{2}').</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_UseOfObsoletePropertyAccessor2">
        <source>'{0}' accessor of '{1}' is obsolete.</source>
        <target state="translated">'{1}'의 '{0}' 접근자는 사용되지 않습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AccessMismatchImplementedEvent6">
        <source>'{0}' cannot expose the underlying delegate type '{1}' of the event it is implementing to {2} '{3}' through {4} '{5}'.</source>
        <target state="translated">'{0}'은(는) {4} '{5}'을(를) 통해 {2} '{3}'에 구현되어 있는 이벤트의 내부 대리자 형식 '{1}'을(를) 노출할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AccessMismatchImplementedEvent4">
        <source>'{0}' cannot expose the underlying delegate type '{1}' of the event it is implementing outside the project through {2} '{3}'.</source>
        <target state="translated">'{0}'은(는) {2} '{3}'을(를) 통해 프로젝트 외부에 구현되어 있는 이벤트의 내부 대리자 형식 '{1}'을(를) 노출할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InheritanceCycleInImportedType1">
        <source>Type '{0}' is not supported because it either directly or indirectly inherits from itself.</source>
        <target state="translated">'{0}' 형식은 직접 또는 간접적으로 자신에게서 상속되므로 지원되지 않습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NoNonObsoleteConstructorOnBase3">
        <source>Class '{0}' must declare a 'Sub New' because the '{1}' in its base class '{2}' is marked obsolete.</source>
        <target state="translated">'{0}' 클래스는 기본 클래스 '{2}'의 '{1}'이(가) obsolete로 표시되어 있으므로 'Sub New'를 선언해야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NoNonObsoleteConstructorOnBase4">
        <source>Class '{0}' must declare a 'Sub New' because the '{1}' in its base class '{2}' is marked obsolete: '{3}'.</source>
        <target state="translated">'{0}' 클래스는 기본 클래스 '{2}'의 '{1}'이(가) obsolete로 표시되어 있으므로 'Sub New'를 선언해야 합니다('{3}').</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RequiredNonObsoleteNewCall3">
        <source>First statement of this 'Sub New' must be an explicit call to 'MyBase.New' or 'MyClass.New' because the '{0}' in the base class '{1}' of '{2}' is marked obsolete.</source>
        <target state="translated">'{2}'의 기본 클래스 '{1}'에 있는 '{0}'이(가) obsolete로 표시되어 있으므로 이 'Sub New'의 첫째 문은 'MyBase.New' 또는 'MyClass.New'에 대한 명시적 호출이어야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RequiredNonObsoleteNewCall4">
        <source>First statement of this 'Sub New' must be an explicit call to 'MyBase.New' or 'MyClass.New' because the '{0}' in the base class '{1}' of '{2}' is marked obsolete: '{3}'.</source>
        <target state="translated">'{2}'의 기본 클래스 '{1}'에 있는 '{0}'이(가) obsolete로 표시되어 있으므로 이 'Sub New'의 첫째 문은 'MyBase.New' 또는 'MyClass.New'에 대한 명시적 호출이어야 합니다. '{3}'</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InheritsTypeArgAccessMismatch7">
        <source>'{0}' cannot inherit from {1} '{2}' because it expands the access of type '{3}' to {4} '{5}'.</source>
        <target state="translated">'{0}'은(는) 형식 '{3}'의 액세스를 {4} '{5}'(으)로 확장하므로 {1} '{2}'에서 상속할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InheritsTypeArgAccessMismatchOutside5">
        <source>'{0}' cannot inherit from {1} '{2}' because it expands the access of type '{3}' outside the assembly.</source>
        <target state="translated">'{0}'은(는) 형식 '{3}'의 액세스를 해당 어셈블리 범위 밖으로 확장하므로 {1} '{2}'에서 상속할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PartialTypeAccessMismatch3">
        <source>Specified access '{0}' for '{1}' does not match the access '{2}' specified on one of its other partial types.</source>
        <target state="translated">'{1}'에 지정된 '{0}' 액세스가 다른 부분 형식(Partial Type) 중 하나에 지정된 '{2}' 액세스와 일치하지 않습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PartialTypeBadMustInherit1">
        <source>'MustInherit' cannot be specified for partial type '{0}' because it cannot be combined with 'NotInheritable' specified for one of its other partial types.</source>
        <target state="translated">'MustInherit'은 다른 부분 형식(Partial Type) 중 하나에 지정된 'NotInheritable'과 함께 사용할 수 없으므로 '{0}' 부분 형식에 지정할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_MustOverOnNotInheritPartClsMem1">
        <source>'MustOverride' cannot be specified on this member because it is in a partial type that is declared 'NotInheritable' in another partial definition.</source>
        <target state="translated">'MustOverride'는 다른 부분 정의에서 'NotInheritable'로 선언된 부분 형식(Partial Type)에 속하므로 이 멤버에 지정할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BaseMismatchForPartialClass3">
        <source>Base class '{0}' specified for class '{1}' cannot be different from the base class '{2}' of one of its other partial types.</source>
        <target state="translated">'{1}' 클래스에 지정된 기본 클래스 '{0}'은(는) 다른 부분 형식(Partial Type) 중 하나의 기본 클래스 '{2}'과(와) 다르면 안 됩니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PartialTypeTypeParamNameMismatch3">
        <source>Type parameter name '{0}' does not match the name '{1}' of the corresponding type parameter defined on one of the other partial types of '{2}'.</source>
        <target state="translated">'{0}' 형식 매개 변수 이름이 '{2}'의 다른 부분 형식(Partial Type) 중 하나에 정의된 해당 '{1}' 형식 매개 변수의 이름과 일치하지 않습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PartialTypeConstraintMismatch1">
        <source>Constraints for this type parameter do not match the constraints on the corresponding type parameter defined on one of the other partial types of '{0}'.</source>
        <target state="translated">이 형식 매개 변수에 대한 제약 조건이 '{0}'의 다른 부분 형식(Partial Type) 중 하나에 정의된 해당 형식 매개 변수의 제약 조건과 일치하지 않습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_LateBoundOverloadInterfaceCall1">
        <source>Late bound overload resolution cannot be applied to '{0}' because the accessing instance is an interface type.</source>
        <target state="translated">액세스하는 인스턴스가 인터페이스 형식이라 바인딩 오버로드 확인을 '{0}'에 적용할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RequiredAttributeConstConversion2">
        <source>Conversion from '{0}' to '{1}' cannot occur in a constant expression used as an argument to an attribute.</source>
        <target state="translated">특성에 대한 인수로 사용된 상수 식에서는 '{0}'에서 '{1}'(으)로 변환할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AmbiguousOverrides3">
        <source>Member '{0}' that matches this signature cannot be overridden because the class '{1}' contains multiple members with this same name and signature: {2}</source>
        <target state="translated">'{1}' 클래스에 이름과 시그니처가 같은 여러 멤버가 포함되어 있으므로 이 시그니처와 일치하는 '{0}' 멤버를 재정의할 수 없습니다({2}).</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_OverriddenCandidate1">
        <source>
   '{0}'</source>
        <target state="translated">
   '{0}'</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AmbiguousImplements3">
        <source>Member '{0}.{1}' that matches this signature cannot be implemented because the interface '{2}' contains multiple members with this same name and signature:
   '{3}'
   '{4}'</source>
        <target state="translated">'{2}' 인터페이스에 이름과 시그니처가 같은 여러 멤버가 포함되어 있으므로 이 시그니처와 일치하는 '{0}.{1}' 멤버를 구현할 수 없습니다.
   '{3}'
   '{4}'</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AddressOfNotCreatableDelegate1">
        <source>'AddressOf' expression cannot be converted to '{0}' because type '{0}' is declared 'MustInherit' and cannot be created.</source>
        <target state="translated">'{0}' 형식이 'MustInherit'으로 선언되어 있어 만들 수 없으므로 'AddressOf' 식을 '{0}'(으)로 변환할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ComClassGenericMethod">
        <source>Generic methods cannot be exposed to COM.</source>
        <target state="translated">제네릭 메서드를 COM에 노출할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_SyntaxInCastOp">
        <source>Syntax error in cast operator; two arguments separated by comma are required.</source>
        <target state="translated">캐스트 연산자에 구문 오류가 있습니다. 쉼표로 구분된 인수 두 개가 필요합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ArrayInitializerForNonConstDim">
        <source>Array initializer cannot be specified for a non constant dimension; use the empty initializer '{}'.</source>
        <target state="translated">비상수 차원에는 배열 이니셜라이저를 지정할 수 없습니다. 빈 이니셜라이저 '{}'를 사용하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DelegateBindingFailure3">
        <source>No accessible method '{0}' has a signature compatible with delegate '{1}':{2}</source>
        <target state="translated">'{1}':{2} 대리자와 호환되는 시그니처를 포함하는 액세스 가능한 '{0}' 메서드가 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_StructLayoutAttributeNotAllowed">
        <source>Attribute 'StructLayout' cannot be applied to a generic type.</source>
        <target state="translated">StructLayout' 특성은 제네릭 형식에 적용할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_IterationVariableShadowLocal1">
        <source>Range variable '{0}' hides a variable in an enclosing block or a range variable previously defined in the query expression.</source>
        <target state="translated">'{0}' 범위 변수가 바깥쪽 블록의 변수를 숨기거나 이전에 쿼리 식에 정의한 범위 변수를 숨깁니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InvalidOptionInfer">
        <source>'Option Infer' can be followed only by 'On' or 'Off'.</source>
        <target state="translated">'Option Infer' 뒤에는 'On' 또는 'Off'만 올 수 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CircularInference1">
        <source>Type of '{0}' cannot be inferred from an expression containing '{0}'.</source>
        <target state="translated">'{0}'이(가) 포함된 식에서 '{0}' 형식을 유추할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InAccessibleOverridingMethod5">
        <source>'{0}' in class '{1}' cannot override '{2}' in class '{3}' because an intermediate class '{4}' overrides '{2}' in class '{3}' but is not accessible.</source>
        <target state="translated">'중간 클래스 '{4}'이(가) '{3}' 클래스의 '{2}'을(를) 재정의하지만 이 중간 클래스에 액세스할 수 없으므로 '{1}' 클래스의 '{0}'이(가) '{3}' 클래스의 '{2}'을(를) 재정의할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NoSuitableWidestType1">
        <source>Type of '{0}' cannot be inferred because the loop bounds and the step clause do not convert to the same type.</source>
        <target state="translated">루프 범위와 단계 절은 같은 형식으로 변환할 수 없으므로 '{0}' 형식을 유추할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AmbiguousWidestType3">
        <source>Type of '{0}' is ambiguous because the loop bounds and the step clause do not convert to the same type.</source>
        <target state="translated">루프 범위와 단계 절은 같은 형식으로 변환되지 않아 '{0}' 형식이 모호합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExpectedAssignmentOperatorInInit">
        <source>'=' expected (object initializer).</source>
        <target state="translated">'='가 필요합니다(개체 이니셜라이저).</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExpectedQualifiedNameInInit">
        <source>Name of field or property being initialized in an object initializer must start with '.'.</source>
        <target state="translated">개체 이니셜라이저에서 초기화되는 필드 또는 속성 이름은 '.'으로 시작해야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExpectedLbrace">
        <source>'{' expected.</source>
        <target state="translated">'{'가 필요합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_UnrecognizedTypeOrWith">
        <source>Type or 'With' expected.</source>
        <target state="translated">형식 또는 'With'가 필요합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DuplicateAggrMemberInit1">
        <source>Multiple initializations of '{0}'.  Fields and properties can be initialized only once in an object initializer expression.</source>
        <target state="translated">'{0}'을(를) 여러 번 초기화했습니다. 개체 이니셜라이저 식에서 필드와 속성은 한 번만 초기화할 수 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NonFieldPropertyAggrMemberInit1">
        <source>Member '{0}' cannot be initialized in an object initializer expression because it is not a field or property.</source>
        <target state="translated">'{0}' 멤버는 필드 또는 속성이 아니므로 개체 이니셜라이저 식에서 초기화할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_SharedMemberAggrMemberInit1">
        <source>Member '{0}' cannot be initialized in an object initializer expression because it is shared.</source>
        <target state="translated">'{0}' 멤버를 공유하고 있으므로 개체 이니셜라이저 식에서 초기화할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ParameterizedPropertyInAggrInit1">
        <source>Property '{0}' cannot be initialized in an object initializer expression because it requires arguments.</source>
        <target state="translated">인수가 필요하므로 개체 이니셜라이저 식에서 '{0}' 속성을 초기화할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NoZeroCountArgumentInitCandidates1">
        <source>Property '{0}' cannot be initialized in an object initializer expression because all accessible overloads require arguments.</source>
        <target state="translated">액세스 가능한 모든 오버로드에 인수가 필요하므로 개체 이니셜라이저 식에서 '{0}' 속성을 초기화할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AggrInitInvalidForObject">
        <source>Object initializer syntax cannot be used to initialize an instance of 'System.Object'.</source>
        <target state="translated">개체 이니셜라이저 구문은 'System.Object'의 인스턴스를 초기화하는 데 사용할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InitializerExpected">
        <source>Initializer expected.</source>
        <target state="translated">이니셜라이저가 필요합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_LineContWithCommentOrNoPrecSpace">
        <source>The line continuation character '_' must be preceded by at least one white space and it must be followed by a comment or the '_' must be the last character on the line.</source>
        <target state="translated">줄 연속 문자 '_'은 앞에 공백이 하나 이상 있어야 하며, 뒤에 주석이 오거나 '_'이 줄의 마지막 문자여야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadModuleFile1">
        <source>Unable to load module file '{0}': {1}</source>
        <target state="translated">'{0}' 모듈 파일을 로드할 수 없습니다({1}).</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadRefLib1">
        <source>Unable to load referenced library '{0}': {1}</source>
        <target state="translated">참조된 라이브러리('{0}')를 로드할 수 없습니다({1}).</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_EventHandlerSignatureIncompatible2">
        <source>Method '{0}' cannot handle event '{1}' because they do not have a compatible signature.</source>
        <target state="translated">'{0}' 메서드에 호환되는 시그니처가 없으므로 '{1}' 이벤트를 처리할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ConditionalCompilationConstantNotValid">
        <source>Conditional compilation constant '{1}' is not valid: {0}</source>
        <target state="translated">조건부 컴파일 상수 '{1}'이(가) 잘못되었습니다. {0}</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InterfaceImplementedTwice1">
        <source>Interface '{0}' can be implemented only once by this type.</source>
        <target state="translated">'{0}' 인터페이스는 이 형식으로 한 번만 구현할 수 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InterfaceImplementedTwiceWithDifferentTupleNames2">
        <source>Interface '{0}' can be implemented only once by this type, but already appears with different tuple element names, as '{1}'.</source>
        <target state="translated">'{0}' 인터페이스는 이 형식으로 한 번만 구현할 수 있지만 이미 다른 튜플 요소 이름을 사용하여 '{1}'(으)로 표시되어 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InterfaceImplementedTwiceWithDifferentTupleNames3">
        <source>Interface '{0}' can be implemented only once by this type, but already appears with different tuple element names, as '{1}' (via '{2}').</source>
        <target state="translated">'{0}' 인터페이스는 이 형식으로 한 번만 구현할 수 있지만 이미 다른 튜플 요소 이름을 사용하여 '{2}'을(를) 통해 '{1}'(으)로 표시되어 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InterfaceImplementedTwiceWithDifferentTupleNamesReverse3">
        <source>Interface '{0}' (via '{1}') can be implemented only once by this type, but already appears with different tuple element names, as '{2}'.</source>
        <target state="translated">'{0}' 인터페이스는 '{1}'을(를) 통해 이 형식으로 한 번만 구현할 수 있지만 이미 다른 튜플 요소 이름을 사용하여 '{2}'(으)로 표시되어 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InterfaceImplementedTwiceWithDifferentTupleNames4">
        <source>Interface '{0}' (via '{1}') can be implemented only once by this type, but already appears with different tuple element names, as '{2}' (via '{3}').</source>
        <target state="translated">'{0}' 인터페이스는 '{1}'을(를) 통해 이 형식으로 한 번만 구현할 수 있지만 이미 다른 튜플 요소 이름을 사용하여 '{3}'을(를) 통해 '{2}'(으)로 표시되어 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InterfaceInheritedTwiceWithDifferentTupleNames2">
        <source>Interface '{0}' can be inherited only once by this interface, but already appears with different tuple element names, as '{1}'.</source>
        <target state="translated">'{0}' 인터페이스는 이 인터페이스에서 한 번만 상속될 수 있지만 이미 다른 튜플 요소 이름을 사용하여 '{1}'(으)로 표시되어 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InterfaceInheritedTwiceWithDifferentTupleNames3">
        <source>Interface '{0}' can be inherited only once by this interface, but already appears with different tuple element names, as '{1}' (via '{2}').</source>
        <target state="translated">'{0}' 인터페이스는 이 인터페이스에서 한 번만 상속될 수 있지만 이미 다른 튜플 요소 이름을 사용하여 '{2}'을(를) 통해 '{1}'(으)로 표시되어 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InterfaceInheritedTwiceWithDifferentTupleNamesReverse3">
        <source>Interface '{0}' (via '{1}') can be inherited only once by this interface, but already appears with different tuple element names, as '{2}'.</source>
        <target state="translated">'{0}' 인터페이스는 '{1}'을(를) 통해 이 인터페이스에서 한 번만 상속될 수 있지만 이미 다른 튜플 요소 이름을 사용하여 '{2}'(으)로 표시되어 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InterfaceInheritedTwiceWithDifferentTupleNames4">
        <source>Interface '{0}' (via '{1}') can be inherited only once by this interface, but already appears with different tuple element names, as '{2}' (via '{3}').</source>
        <target state="translated">'{0}' 인터페이스는 '{1}'을(를) 통해 이 인터페이스에서 한 번만 상속될 수 있지만 이미 다른 튜플 요소 이름을 사용하여 '{3}'을(를) 통해 '{2}'(으)로 표시되어 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InterfaceNotImplemented1">
        <source>Interface '{0}' is not implemented by this class.</source>
        <target state="translated">'{0}' 인터페이스가 이 클래스에서 구현되지 않았습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AmbiguousImplementsMember3">
        <source>'{0}' exists in multiple base interfaces. Use the name of the interface that declares '{0}' in the 'Implements' clause instead of the name of the derived interface.</source>
        <target state="translated">'{0}'이(가) 여러 기본 인터페이스에 있습니다. 파생 인터페이스 이름 대신 'Implements' 절에서 '{0}'을(를) 선언하는 인터페이스 이름을 사용하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ImplementsOnNew">
        <source>'Sub New' cannot implement interface members.</source>
        <target state="translated">'Sub New'는 인터페이스 멤버를 구현할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ArrayInitInStruct">
        <source>Arrays declared as structure members cannot be declared with an initial size.</source>
        <target state="translated">구조체 멤버로 선언된 배열은 초기 크기로 선언할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_EventTypeNotDelegate">
        <source>Events declared with an 'As' clause must have a delegate type.</source>
        <target state="translated">As' 절로 선언된 이벤트에는 대리자 형식을 지정해야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ProtectedTypeOutsideClass">
        <source>Protected types can only be declared inside of a class.</source>
        <target state="translated">Protected 형식은 클래스 내부에서만 선언할 수 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DefaultPropertyWithNoParams">
        <source>Properties with no required parameters cannot be declared 'Default'.</source>
        <target state="translated">필요한 매개 변수가 없는 속성은 'Default'로 선언할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InitializerInStruct">
        <source>Initializers on structure members are valid only for 'Shared' members and constants.</source>
        <target state="translated">구조체 멤버의 이니셜라이저는 'Shared' 멤버 및 상수에만 사용할 수 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DuplicateImport1">
        <source>Namespace or type '{0}' has already been imported.</source>
        <target state="translated">'{0}' 네임스페이스 또는 형식을 이미 가져왔습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadModuleFlags1">
        <source>Modules cannot be declared '{0}'.</source>
        <target state="translated">모듈은 '{0}'(으)로 선언할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ImplementsStmtWrongOrder">
        <source>'Implements' statements must follow any 'Inherits' statement and precede all declarations in a class.</source>
        <target state="translated">'Implements' 문은 모든 'Inherits' 문 다음에 와야 하고 클래스의 모든 선언 앞에 와야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_SynthMemberClashesWithSynth7">
        <source>{0} '{1}' implicitly defines '{2}', which conflicts with a member implicitly declared for {3} '{4}' in {5} '{6}'.</source>
        <target state="translated">{0} '{1}'은(는) {5} '{6}'의 {3} '{4}'에 대해 암시적으로 선언된 멤버와 충돌하는 '{2}'을(를) 암시적으로 정의합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_SynthMemberClashesWithMember5">
        <source>{0} '{1}' implicitly defines '{2}', which conflicts with a member of the same name in {3} '{4}'.</source>
        <target state="translated">{0} '{1}'은(는) {3} '{4}'에서 이름이 같은 멤버와 충돌하는 '{2}'을(를) 암시적으로 정의합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_MemberClashesWithSynth6">
        <source>{0} '{1}' conflicts with a member implicitly declared for {2} '{3}' in {4} '{5}'.</source>
        <target state="translated">{0} '{1}'은(는) {4} '{5}'의 {2} '{3}'에 대해 암시적으로 선언된 멤버와 충돌합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_TypeClashesWithVbCoreType4">
        <source>{0} '{1}' conflicts with a Visual Basic Runtime {2} '{3}'.</source>
        <target state="translated">{0} '{1}'이(가) Visual Basic Runtime {2} '{3}'과(와) 충돌합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_SecurityAttributeMissingAction">
        <source>First argument to a security attribute must be a valid SecurityAction.</source>
        <target state="translated">보안 특성에 대한 첫 번째 인수는 유효한 SecurityAction이어야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_SecurityAttributeInvalidAction">
        <source>Security attribute '{0}' has an invalid SecurityAction value '{1}'.</source>
        <target state="translated">'{0}' 보안 특성에 있는 SecurityAction 값('{1}')이 잘못되었습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_SecurityAttributeInvalidActionAssembly">
        <source>SecurityAction value '{0}' is invalid for security attributes applied to an assembly.</source>
        <target state="translated">어셈블리에 적용된 보안 특성에 대한 SecurityAction 값('{0}')이 잘못되었습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_SecurityAttributeInvalidActionTypeOrMethod">
        <source>SecurityAction value '{0}' is invalid for security attributes applied to a type or a method.</source>
        <target state="translated">형식 또는 메서드에 적용된 보안 특성에 대한 SecurityAction 값('{0}')이 잘못되었습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PrincipalPermissionInvalidAction">
        <source>SecurityAction value '{0}' is invalid for PrincipalPermission attribute.</source>
        <target state="translated">PrincipalPermission 특성에 대한 SecurityAction 값('{0}')이 잘못되었습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PermissionSetAttributeInvalidFile">
        <source>Unable to resolve file path '{0}' specified for the named argument '{1}' for PermissionSet attribute.</source>
        <target state="translated">PermissionSet 특성에 대해 명명된 인수 '{1}'에 지정된 '{0}' 파일 경로를 확인할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PermissionSetAttributeFileReadError">
        <source>Error reading file '{0}' specified for the named argument '{1}' for PermissionSet attribute: '{2}'.</source>
        <target state="translated">PermissionSet 특성에 대해 명명된 인수 '{1}'에 지정된 '{0}' 파일을 읽는 동안 오류가 발생했습니다('{2}').</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_SetHasOnlyOneParam">
        <source>'Set' method cannot have more than one parameter.</source>
        <target state="translated">'Set' 메서드에는 매개 변수를 둘 이상 사용할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_SetValueNotPropertyType">
        <source>'Set' parameter must have the same type as the containing property.</source>
        <target state="translated">'Set' 매개 변수는 포함하는 속성과 형식이 같아야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_SetHasToBeByVal1">
        <source>'Set' parameter cannot be declared '{0}'.</source>
        <target state="translated">'Set' 매개 변수는 '{0}'(으)로 선언할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_StructureCantUseProtected">
        <source>Method in a structure cannot be declared 'Protected', 'Protected Friend', or 'Private Protected'.</source>
        <target state="translated">구조체의 메서드는 'Protected', 'Protected Friend' 또는 'Private Protected'로 선언할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadInterfaceDelegateSpecifier1">
        <source>Delegate in an interface cannot be declared '{0}'.</source>
        <target state="translated">인터페이스의 대리자는 '{0}'(으)로 선언할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadInterfaceEnumSpecifier1">
        <source>Enum in an interface cannot be declared '{0}'.</source>
        <target state="translated">인터페이스의 열거형은 '{0}'(으)로 선언할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadInterfaceClassSpecifier1">
        <source>Class in an interface cannot be declared '{0}'.</source>
        <target state="translated">인터페이스의 클래스는 '{0}'(으)로 선언할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadInterfaceStructSpecifier1">
        <source>Structure in an interface cannot be declared '{0}'.</source>
        <target state="translated">인터페이스의 구조체는 '{0}'(으)로 선언할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadInterfaceInterfaceSpecifier1">
        <source>Interface in an interface cannot be declared '{0}'.</source>
        <target state="translated">인터페이스의 인터페이스는 '{0}'(으)로 선언할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_UseOfObsoleteSymbolNoMessage1">
        <source>'{0}' is obsolete.</source>
        <target state="translated">'{0}'은(는) 사용되지 않습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_MetaDataIsNotAssembly">
        <source>'{0}' is a module and cannot be referenced as an assembly.</source>
        <target state="translated">'{0}'은(는) 모듈이며 어셈블리로 참조할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_MetaDataIsNotModule">
        <source>'{0}' is an assembly and cannot be referenced as a module.</source>
        <target state="translated">'{0}'은(는) 어셈블리이며 모듈로 참조할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ReferenceComparison3">
        <source>Operator '{0}' is not defined for types '{1}' and '{2}'. Use 'Is' operator to compare two reference types.</source>
        <target state="translated">'{1}' 및 '{2}' 형식에 대한 '{0}' 연산자가 정의되지 않았습니다. 두 참조 형식을 비교하려면 'Is' 연산자를 사용하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CatchVariableNotLocal1">
        <source>'{0}' is not a local variable or parameter, and so cannot be used as a 'Catch' variable.</source>
        <target state="translated">'{0}'은(는) 지역 변수 또는 매개 변수가 아니므로 'Catch' 변수로 사용할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ModuleMemberCantImplement">
        <source>Members in a Module cannot implement interface members.</source>
        <target state="translated">모듈의 멤버는 인터페이스 멤버를 구현할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_EventDelegatesCantBeFunctions">
        <source>Events cannot be declared with a delegate type that has a return type.</source>
        <target state="translated">이벤트는 반환 형식이 있는 대리자 형식으로 선언할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InvalidDate">
        <source>Date constant is not valid.</source>
        <target state="translated">날짜 상수가 잘못되었습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CantOverride4">
        <source>'{0}' cannot override '{1}' because it is not declared 'Overridable'.</source>
        <target state="translated">'{0}'은(는) 'Overridable'로 선언되지 않았으므로 '{1}'을(를) 재정의할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CantSpecifyArraysOnBoth">
        <source>Array modifiers cannot be specified on both a variable and its type.</source>
        <target state="translated">변수와 그 형식 모두에 배열 한정자를 지정할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NotOverridableRequiresOverrides">
        <source>'NotOverridable' cannot be specified for methods that do not override another method.</source>
        <target state="translated">'NotOverridable'은 다른 메서드를 재정의하지 않는 메서드에 지정할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PrivateTypeOutsideType">
        <source>Types declared 'Private' must be inside another type.</source>
        <target state="translated">'Private'으로 선언된 형식은 다른 형식의 내부에 있어야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_TypeRefResolutionError3">
        <source>Import of type '{0}' from assembly or module '{1}' failed.</source>
        <target state="translated">'{1}' 어셈블리 또는 모듈에서 '{0}' 형식을 가져오지 못했습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ValueTupleTypeRefResolutionError1">
        <source>Predefined type '{0}' is not defined or imported.</source>
        <target state="translated">미리 정의된 형식 '{0}'을(를) 정의하지 않았거나 가져오지 않았습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ParamArrayWrongType">
        <source>ParamArray parameters must have an array type.</source>
        <target state="translated">ParamArray 매개 변수에는 배열 형식이 있어야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CoClassMissing2">
        <source>Implementing class '{0}' for interface '{1}' cannot be found.</source>
        <target state="translated">'{1}' 인터페이스에 대한 '{0}' 구현 클래스를 찾을 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InvalidCoClass1">
        <source>Type '{0}' cannot be used as an implementing class.</source>
        <target state="translated">'{0}' 형식은 클래스를 구현하는 데 사용할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InvalidMeReference">
        <source>Reference to object under construction is not valid when calling another constructor.</source>
        <target state="translated">다른 생성자를 호출하는 동안에는 생성 중인 개체를 참조할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InvalidImplicitMeReference">
        <source>Implicit reference to object under construction is not valid when calling another constructor.</source>
        <target state="translated">다른 생성자를 호출하는 동안에는 생성 중인 개체를 암시적으로 참조할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RuntimeMemberNotFound2">
        <source>Member '{0}' cannot be found in class '{1}'. This condition is usually the result of a mismatched 'Microsoft.VisualBasic.dll'.</source>
        <target state="translated">'{0}' 멤버가 '{1}' 클래스에 없습니다. 일반적으로 'Microsoft.VisualBasic.dll'이 일치하는 않은 결과로 발생하는 조건입니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadPropertyAccessorFlags">
        <source>Property accessors cannot be declared '{0}'.</source>
        <target state="translated">속성 접근자는 '{0}'(으)로 선언할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadPropertyAccessorFlagsRestrict">
        <source>Access modifier '{0}' is not valid. The access modifier of 'Get' and 'Set' should be more restrictive than the property access level.</source>
        <target state="translated">'{0}' 액세스 한정자가 잘못되었습니다. 'Get' 및 'Set'의 액세스 한정자는 속성 액세스 수준보다 제한적이어야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_OnlyOneAccessorForGetSet">
        <source>Access modifier can only be applied to either 'Get' or 'Set', but not both.</source>
        <target state="translated">액세스 한정자는 'Get' 또는 'Set' 중 하나에만 적용할 수 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NoAccessibleSet">
        <source>'Set' accessor of property '{0}' is not accessible.</source>
        <target state="translated">'{0}' 속성의 'Set' 접근자에 액세스할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NoAccessibleGet">
        <source>'Get' accessor of property '{0}' is not accessible.</source>
        <target state="translated">'{0}' 속성의 'Get' 접근자에 액세스할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_WriteOnlyNoAccessorFlag">
        <source>'WriteOnly' properties cannot have an access modifier on 'Set'.</source>
        <target state="translated">'WriteOnly' 속성에는 'Set'에 대한 액세스 한정자를 사용할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ReadOnlyNoAccessorFlag">
        <source>'ReadOnly' properties cannot have an access modifier on 'Get'.</source>
        <target state="translated">'ReadOnly' 속성에는 'Get'에 대한 액세스 한정자를 사용할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadPropertyAccessorFlags1">
        <source>Property accessors cannot be declared '{0}' in a 'NotOverridable' property.</source>
        <target state="translated">NotOverridable' 속성에서는 속성 접근자를 '{0}'(으)로 선언할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadPropertyAccessorFlags2">
        <source>Property accessors cannot be declared '{0}' in a 'Default' property.</source>
        <target state="translated">Default' 속성에서는 속성 접근자를 '{0}'(으)로 선언할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadPropertyAccessorFlags3">
        <source>Property cannot be declared '{0}' because it contains a 'Private' accessor.</source>
        <target state="translated">속성에 'Private' 접근자가 포함되어 있어 '{0}'(으)로 선언할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InAccessibleCoClass3">
        <source>Implementing class '{0}' for interface '{1}' is not accessible in this context because it is '{2}'.</source>
        <target state="translated">'{1}' 인터페이스의 '{0}' 구현 클래스는 '{2}'이므로 이 컨텍스트에서 액세스할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_MissingValuesForArraysInApplAttrs">
        <source>Arrays used as attribute arguments are required to explicitly specify values for all elements.</source>
        <target state="translated">모든 요소에 대한 값을 명시적으로 지정하려면 특성 인수로 사용되는 배열이 필요합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExitEventMemberNotInvalid">
        <source>'Exit AddHandler', 'Exit RemoveHandler' and 'Exit RaiseEvent' are not valid. Use 'Return' to exit from event members.</source>
        <target state="translated">'Exit AddHandler', 'Exit RemoveHandler' 및 'Exit RaiseEvent'가 잘못되었습니다. 이벤트 멤버에서 나오려면 'Return'을 사용하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InvInsideEndsEvent">
        <source>Statement cannot appear within an event body. End of event assumed.</source>
        <target state="translated">이벤트 본문 안에는 문을 사용할 수 없습니다. 이벤트의 끝으로 간주합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_MissingEndEvent">
        <source>'Custom Event' must end with a matching 'End Event'.</source>
        <target state="translated">'Custom Event'는 짝이 되는 'End Event'로 끝나야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_MissingEndAddHandler">
        <source>'AddHandler' declaration must end with a matching 'End AddHandler'.</source>
        <target state="translated">'AddHandler' 선언은 짝이 되는 'End AddHandler'로 끝나야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_MissingEndRemoveHandler">
        <source>'RemoveHandler' declaration must end with a matching 'End RemoveHandler'.</source>
        <target state="translated">'RemoveHandler' 선언은 짝이 되는 'End RemoveHandler'로 끝나야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_MissingEndRaiseEvent">
        <source>'RaiseEvent' declaration must end with a matching 'End RaiseEvent'.</source>
        <target state="translated">'RaiseEvent' 선언은 짝이 되는 'End RaiseEvent'로 끝나야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CustomEventInvInInterface">
        <source>'Custom' modifier is not valid on events declared in interfaces.</source>
        <target state="translated">'인터페이스에 선언된 이벤트에는 'Custom' 한정자를 사용할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CustomEventRequiresAs">
        <source>'Custom' modifier is not valid on events declared without explicit delegate types.</source>
        <target state="translated">'명시적 대리자 형식 없이 선언된 이벤트에는 'Custom' 한정자를 사용할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InvalidEndEvent">
        <source>'End Event' must be preceded by a matching 'Custom Event'.</source>
        <target state="translated">'End Event'는 짝이 되는 'Custom Event' 뒤에 와야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InvalidEndAddHandler">
        <source>'End AddHandler' must be preceded by a matching 'AddHandler' declaration.</source>
        <target state="translated">'End AddHandler'는 짝이 되는 'AddHandler' 선언 뒤에 와야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InvalidEndRemoveHandler">
        <source>'End RemoveHandler' must be preceded by a matching 'RemoveHandler' declaration.</source>
        <target state="translated">'End RemoveHandler'는 짝이 되는 'RemoveHandler' 선언 뒤에 와야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InvalidEndRaiseEvent">
        <source>'End RaiseEvent' must be preceded by a matching 'RaiseEvent' declaration.</source>
        <target state="translated">'End RaiseEvent'는 짝이 되는 'RaiseEvent' 선언 뒤에 와야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DuplicateAddHandlerDef">
        <source>'AddHandler' is already declared.</source>
        <target state="translated">'AddHandler'가 이미 선언되었습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DuplicateRemoveHandlerDef">
        <source>'RemoveHandler' is already declared.</source>
        <target state="translated">'RemoveHandler'가 이미 선언되었습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DuplicateRaiseEventDef">
        <source>'RaiseEvent' is already declared.</source>
        <target state="translated">'RaiseEvent'가 이미 선언되었습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_MissingAddHandlerDef1">
        <source>'AddHandler' definition missing for event '{0}'.</source>
        <target state="translated">'{0}' 이벤트에 대한 'AddHandler' 정의가 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_MissingRemoveHandlerDef1">
        <source>'RemoveHandler' definition missing for event '{0}'.</source>
        <target state="translated">'{0}' 이벤트에 대한 'RemoveHandler' 정의가 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_MissingRaiseEventDef1">
        <source>'RaiseEvent' definition missing for event '{0}'.</source>
        <target state="translated">'{0}' 이벤트에 대한 'RaiseEvent' 정의가 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_EventAddRemoveHasOnlyOneParam">
        <source>'AddHandler' and 'RemoveHandler' methods must have exactly one parameter.</source>
        <target state="translated">'AddHandler' 및 'RemoveHandler' 메서드에는 매개 변수를 하나만 사용해야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_EventAddRemoveByrefParamIllegal">
        <source>'AddHandler' and 'RemoveHandler' method parameters cannot be declared 'ByRef'.</source>
        <target state="translated">'AddHandler' 및 'RemoveHandler' 메서드 매개 변수는 'ByRef'로 선언할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_SpecifiersInvOnEventMethod">
        <source>Specifiers are not valid on 'AddHandler', 'RemoveHandler' and 'RaiseEvent' methods.</source>
        <target state="translated">AddHandler', 'RemoveHandler' 및 'RaiseEvent' 메서드에는 지정자를 사용할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AddRemoveParamNotEventType">
        <source>'AddHandler' and 'RemoveHandler' method parameters must have the same delegate type as the containing event.</source>
        <target state="translated">'AddHandler' 및 'RemoveHandler' 메서드 매개 변수의 대리자 형식은 포함하는 이벤트의 대리자 형식과 같아야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RaiseEventShapeMismatch1">
        <source>'RaiseEvent' method must have the same signature as the containing event's delegate type '{0}'.</source>
        <target state="translated">'RaiseEvent' 메서드의 시그니처는 포함하는 이벤트의 대리자 형식 '{0}'의 시그니처와 같아야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_EventMethodOptionalParamIllegal1">
        <source>'AddHandler', 'RemoveHandler' and 'RaiseEvent' method parameters cannot be declared '{0}'.</source>
        <target state="translated">'AddHandler', 'RemoveHandler' 및 'RaiseEvent' 메서드 매개 변수는 '{0}'(으)로 선언할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CantReferToMyGroupInsideGroupType1">
        <source>'{0}' cannot refer to itself through its default instance; use 'Me' instead.</source>
        <target state="translated">'{0}'은(는) 기본 인스턴스를 통해 자신을 참조할 수 없습니다. 대신 'Me'를 사용하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InvalidUseOfCustomModifier">
        <source>'Custom' modifier can only be used immediately before an 'Event' declaration.</source>
        <target state="translated">'Custom' 한정자는 'Event' 선언 바로 앞에만 사용할 수 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InvalidOptionStrictCustom">
        <source>Option Strict Custom can only be used as an option to the command-line compiler (vbc.exe).</source>
        <target state="translated">Option Strict Custom은 명령줄 컴파일러(vbc.exe)에 대한 옵션으로만 사용할 수 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ObsoleteInvalidOnEventMember">
        <source>'{0}' cannot be applied to the 'AddHandler', 'RemoveHandler', or 'RaiseEvent' definitions. If required, apply the attribute directly to the event.</source>
        <target state="translated">'{0}'은(는) 'AddHandler', 'RemoveHandler' 또는 'RaiseEvent' 정의에 적용할 수 없습니다. 필요한 경우 특성을 이벤트에 직접 적용하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DelegateBindingIncompatible2">
        <source>Method '{0}' does not have a signature compatible with delegate '{1}'.</source>
        <target state="translated">'{0}' 메서드에 '{1}' 대리자와 호환되는 시그니처가 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExpectedXmlName">
        <source>XML name expected.</source>
        <target state="translated">XML 이름이 필요합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_UndefinedXmlPrefix">
        <source>XML namespace prefix '{0}' is not defined.</source>
        <target state="translated">XML 네임스페이스 접두사 '{0}'이(가) 정의되지 않았습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DuplicateXmlAttribute">
        <source>Duplicate XML attribute '{0}'.</source>
        <target state="translated">'{0}' XML 특성이 중복되었습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_MismatchedXmlEndTag">
        <source>End tag &lt;/{0}{1}{2}&gt; expected.</source>
        <target state="translated">&lt;/{0}{1}{2}&gt; 끝 태그가 필요합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_MissingXmlEndTag">
        <source>Element is missing an end tag.</source>
        <target state="translated">요소에 끝 태그가 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ReservedXmlPrefix">
        <source>XML namespace prefix '{0}' is reserved for use by XML and the namespace URI cannot be changed.</source>
        <target state="translated">XML 네임스페이스 접두사('{0}')는 XML에서 사용하도록 예약되었으므로 네임스페이스 URI를 변경할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_MissingVersionInXmlDecl">
        <source>Required attribute 'version' missing from XML declaration.</source>
        <target state="translated">필요한 'version' 특성이 XML 선언에 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_IllegalAttributeInXmlDecl">
        <source>XML declaration does not allow attribute '{0}{1}{2}'.</source>
        <target state="translated">XML 선언에는 특성 '{0}{1}{2}'을(를) 사용할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_QuotedEmbeddedExpression">
        <source>Embedded expression cannot appear inside a quoted attribute value.  Try removing quotes.</source>
        <target state="translated">포함 식은 따옴표로 묶인 특성 값 내에 표시할 수 없습니다. 따옴표를 제거해 보세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_VersionMustBeFirstInXmlDecl">
        <source>XML attribute 'version' must be the first attribute in XML declaration.</source>
        <target state="translated">XML 특성 'version'은 XML 선언에서 첫 번째 특성이어야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AttributeOrder">
        <source>XML attribute '{0}' must appear before XML attribute '{1}'.</source>
        <target state="translated">XML 특성 '{0}'은(는) XML 특성 '{1}' 앞에 와야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExpectedXmlEndEmbedded">
        <source>Expected closing '%&gt;' for embedded expression.</source>
        <target state="translated">포함 식에 닫는 '%&gt;'가 필요합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExpectedXmlEndPI">
        <source>Expected closing '?&gt;' for XML processor instruction.</source>
        <target state="translated">XML 프로세서 명령에 닫는 '?&gt;'가 필요합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExpectedXmlEndComment">
        <source>Expected closing '--&gt;' for XML comment.</source>
        <target state="translated">XML 주석에 닫는 '--&gt;'가 필요합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExpectedXmlEndCData">
        <source>Expected closing ']]&gt;' for XML CDATA section.</source>
        <target state="translated">XML CDATA 섹션에 닫는 ']]&gt;'가 필요합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExpectedSQuote">
        <source>Expected matching closing single quote for XML attribute value.</source>
        <target state="translated">XML 특성 값에 짝이 되는 닫는 작은따옴표가 필요합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExpectedQuote">
        <source>Expected matching closing double quote for XML attribute value.</source>
        <target state="translated">XML 특성 값에 짝이 되는 닫는 큰따옴표가 필요합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExpectedLT">
        <source>Expected beginning '&lt;' for an XML tag.</source>
        <target state="translated">XML 태그에 시작 '&lt;'가 필요합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_StartAttributeValue">
        <source>Expected quoted XML attribute value or embedded expression.</source>
        <target state="translated">따옴표 붙은 XML 특성 값 또는 포함 식이 필요합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExpectedDiv">
        <source>Expected '/' for XML end tag.</source>
        <target state="translated">XML 끝 태그에 '/'가 필요합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NoXmlAxesLateBinding">
        <source>XML axis properties do not support late binding.</source>
        <target state="translated">XML 축 속성은 런타임 바인딩을 지원하지 않습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_IllegalXmlStartNameChar">
        <source>Character '{0}' ({1}) is not allowed at the beginning of an XML name.</source>
        <target state="translated">XML 이름은 '{0}'({1}) 문자로 시작할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_IllegalXmlNameChar">
        <source>Character '{0}' ({1}) is not allowed in an XML name.</source>
        <target state="translated">XML 이름에는 '{0}'({1}) 문자를 사용할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_IllegalXmlCommentChar">
        <source>Character sequence '--' is not allowed in an XML comment.</source>
        <target state="translated">XML 주석에는 문자 시퀀스 '--'을 사용할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_EmbeddedExpression">
        <source>An embedded expression cannot be used here.</source>
        <target state="translated">포함 식은 여기에 사용할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExpectedXmlWhiteSpace">
        <source>Missing required white space.</source>
        <target state="translated">필요한 공백이 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_IllegalProcessingInstructionName">
        <source>XML processing instruction name '{0}' is not valid.</source>
        <target state="translated">XML 처리 명령 이름 '{0}'이(가) 잘못되었습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DTDNotSupported">
        <source>XML DTDs are not supported.</source>
        <target state="translated">XML DTD는 지원되지 않습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_IllegalXmlWhiteSpace">
        <source>White space cannot appear here.</source>
        <target state="translated">공백은 여기에 표시할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExpectedSColon">
        <source>Expected closing ';' for XML entity.</source>
        <target state="translated">XML 엔터티에 닫는 ';'이 필요합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExpectedXmlBeginEmbedded">
        <source>Expected '%=' at start of an embedded expression.</source>
        <target state="translated">포함 식의 시작 부분에 '%='가 필요합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_XmlEntityReference">
        <source>XML entity references are not supported.</source>
        <target state="translated">XML 엔터티 참조가 지원되지 않습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InvalidAttributeValue1">
        <source>Attribute value is not valid; expecting '{0}'.</source>
        <target state="translated">특성 값이 잘못되었습니다. '{0}'이(가) 필요합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InvalidAttributeValue2">
        <source>Attribute value is not valid; expecting '{0}' or '{1}'.</source>
        <target state="translated">특성 값이 잘못되었습니다. '{0}'또는 '{1}'이(가) 필요합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ReservedXmlNamespace">
        <source>Prefix '{0}' cannot be bound to namespace name reserved for '{1}'.</source>
        <target state="translated">'{0}' 접두사는 '{1}'에 사용하도록 예약된 네임스페이스 이름에 바인딩할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_IllegalDefaultNamespace">
        <source>Namespace declaration with prefix cannot have an empty value inside an XML literal.</source>
        <target state="translated">접두사가 있는 네임스페이스 선언에는 XML 리터럴 내에 빈 값을 사용할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_QualifiedNameNotAllowed">
        <source>':' is not allowed. XML qualified names cannot be used in this context.</source>
        <target state="translated">':'을 사용할 수 없습니다. 이 컨텍스트에서는 정규화된 XML 이름을 사용할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExpectedXmlns">
        <source>Namespace declaration must start with 'xmlns'.</source>
        <target state="translated">네임스페이스 선언은 'xmlns'로 시작해야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_IllegalXmlnsPrefix">
        <source>Element names cannot use the 'xmlns' prefix.</source>
        <target state="translated">요소 이름에는 'xmlns' 접두사를 사용할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_XmlFeaturesNotAvailable">
        <source>XML literals and XML axis properties are not available. Add references to System.Xml, System.Xml.Linq, and System.Core or other assemblies declaring System.Linq.Enumerable, System.Xml.Linq.XElement, System.Xml.Linq.XName, System.Xml.Linq.XAttribute and System.Xml.Linq.XNamespace types.</source>
        <target state="translated">XML 리터럴 및 XML 축 속성을 사용할 수 없습니다. System.Xml, System.Xml.Linq 및 System.Core에 참조를 추가하거나 System.Linq.Enumerable, System.Xml.Linq.XElement, System.Xml.Linq.XName, System.Xml.Linq.XAttribute 및 System.Xml.Linq.XNamespace 형식을 선언하는 기타 어셈블리에 참조를 추가하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_UnableToReadUacManifest2">
        <source>Unable to open Win32 manifest file '{0}' : {1}</source>
        <target state="translated">'{0}' Win32 매니페스트 파일을 열 수 없습니다({1}).</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UseValueForXmlExpression3">
        <source>Cannot convert '{0}' to '{1}'. You can use the 'Value' property to get the string value of the first element of '{2}'.</source>
        <target state="translated">'{0}'을(를) '{1}'(으)로 변환할 수 없습니다. 'Value' 속성을 사용하여 '{2}'의 첫 번째 요소의 문자열 값을 가져올 수 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UseValueForXmlExpression3_Title">
        <source>Cannot convert IEnumerable(Of XElement) to String</source>
        <target state="translated">IEnumerable(Of XElement)을 문자열로 변환할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_TypeMismatchForXml3">
        <source>Value of type '{0}' cannot be converted to '{1}'. You can use the 'Value' property to get the string value of the first element of '{2}'.</source>
        <target state="translated">'{0}' 형식의 값을 '{1}'(으)로 변환할 수 없습니다. 'Value' 속성을 사용하여 '{2}'의 첫 번째 요소의 문자열 값을 가져올 수 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BinaryOperandsForXml4">
        <source>Operator '{0}' is not defined for types '{1}' and '{2}'. You can use the 'Value' property to get the string value of the first element of '{3}'.</source>
        <target state="translated">'{1}' 및 '{2}' 형식에 대한 '{0}' 연산자가 정의되지 않았습니다. 'Value' 속성을 사용하여 첫 번째 '{3}' 요소의 문자열 값을 가져올 수 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_FullWidthAsXmlDelimiter">
        <source>Full width characters are not valid as XML delimiters.</source>
        <target state="translated">전자 문자는 XML 구분 기호로 사용할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InvalidSubsystemVersion">
        <source>The value '{0}' is not a valid subsystem version. The version must be 6.02 or greater for ARM or AppContainerExe, and 4.00 or greater otherwise.</source>
        <target state="translated">'{0}' 값이 유효한 하위 시스템 버전이 아닙니다. 버전은 ARM 또는 AppContainerExe의 경우 6.02 이상이어야 하고, 그 외의 경우 4.00 이상이어야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InvalidFileAlignment">
        <source>Invalid file section alignment '{0}'</source>
        <target state="translated">잘못된 파일 섹션 맞춤 '{0}'</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InvalidOutputName">
        <source>Invalid output name: {0}</source>
        <target state="translated">잘못된 출력 이름: {0}</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InvalidDebugInformationFormat">
        <source>Invalid debug information format: {0}</source>
        <target state="translated">잘못된 디버그 정보 형식: {0}</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_LibAnycpu32bitPreferredConflict">
        <source>/platform:anycpu32bitpreferred can only be used with /t:exe, /t:winexe and /t:appcontainerexe.</source>
        <target state="translated">/platform:anycpu32bitpreferred는 /t:exe, /t:winexe 및 /t:appcontainerexe하고만 사용할 수 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RestrictedAccess">
        <source>Expression has the type '{0}' which is a restricted type and cannot be used to access members inherited from 'Object' or 'ValueType'.</source>
        <target state="translated">식에 있는 '{0}' 형식은 제한된 형식이므로 'Object' 또는 'ValueType'에서 상속된 멤버에 액세스하는 데 사용할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RestrictedConversion1">
        <source>Expression of type '{0}' cannot be converted to 'Object' or 'ValueType'.</source>
        <target state="translated">'{0}' 형식의 식은 'Object' 또는 'ValueType'으로 변환할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NoTypecharInLabel">
        <source>Type characters are not allowed in label identifiers.</source>
        <target state="translated">레이블 식별자에는 형식 문자를 사용할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RestrictedType1">
        <source>'{0}' cannot be made nullable, and cannot be used as the data type of an array element, field, anonymous type member, type argument, 'ByRef' parameter, or return statement.</source>
        <target state="translated">'{0}'은(는) null을 허용할 수 없고 배열 요소, 필드, 익명 형식 멤버, 형식 인수, 'ByRef' 매개 변수 또는 return 문의 데이터 형식으로 사용할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NoTypecharInAlias">
        <source>Type characters are not allowed on Imports aliases.</source>
        <target state="translated">Imports 별칭에는 형식 문자를 사용할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NoAccessibleConstructorOnBase">
        <source>Class '{0}' has no accessible 'Sub New' and cannot be inherited.</source>
        <target state="translated">'{0}' 클래스에 액세스 가능한 'Sub New'가 없으므로 상속할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadStaticLocalInStruct">
        <source>Local variables within methods of structures cannot be declared 'Static'.</source>
        <target state="translated">구조체의 메서드 안에 있는 지역 변수는 'Static'으로 선언할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DuplicateLocalStatic1">
        <source>Static local variable '{0}' is already declared.</source>
        <target state="translated">'{0}' static 지역 변수가 이미 선언되었습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ImportAliasConflictsWithType2">
        <source>Imports alias '{0}' conflicts with '{1}' declared in the root namespace.</source>
        <target state="translated">Imports 별칭 '{0}'이(가) 루트 네임스페이스에 선언된 '{1}'과(와) 충돌합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CantShadowAMustOverride1">
        <source>'{0}' cannot shadow a method declared 'MustOverride'.</source>
        <target state="translated">'{0}'은(는) 'MustOverride'로 선언된 메서드를 숨길 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_MultipleEventImplMismatch3">
        <source>Event '{0}' cannot implement event '{2}.{1}' because its delegate type does not match the delegate type of another event implemented by '{0}'.</source>
        <target state="translated">{2}.{1}' 이벤트의 대리자 형식이 '{0}' 이벤트에 의해 구현된 다른 이벤트의 대리자 형식과 일치하지 않으므로 '{0}' 이벤트에서 이 이벤트를 구현할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadSpecifierCombo2">
        <source>'{0}' and '{1}' cannot be combined.</source>
        <target state="translated">'{0}' 및 '{1}'은(는) 조합할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_MustBeOverloads2">
        <source>{0} '{1}' must be declared 'Overloads' because another '{1}' is declared 'Overloads' or 'Overrides'.</source>
        <target state="translated">다른 '{1}'이(가) 'Overloads' 또는 'Overrides'로 선언되어 있으므로 {0} '{1}'은(는) 'Overloads'로 선언해야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_MustOverridesInClass1">
        <source>'{0}' must be declared 'MustInherit' because it contains methods declared 'MustOverride'.</source>
        <target state="translated">'{0}'은(는) 'MustOverride'로 선언된 메서드를 포함하므로 'MustInherit'으로 선언해야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_HandlesSyntaxInClass">
        <source>'Handles' in classes must specify a 'WithEvents' variable, 'MyBase', 'MyClass' or 'Me' qualified with a single identifier.</source>
        <target state="translated">'클래스의 'Handles'는 단일 식별자로 한정된 'WithEvents' 변수, 'MyBase', 'MyClass' 또는 'Me'를 지정해야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_SynthMemberShadowsMustOverride5">
        <source>'{0}', implicitly declared for {1} '{2}', cannot shadow a 'MustOverride' method in the base {3} '{4}'.</source>
        <target state="translated">'{1} '{2}'에 대해 암시적으로 선언된 '{0}'은(는) 기본 {3} '{4}'의 'MustOverride' 메서드를 숨길 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CannotOverrideInAccessibleMember">
        <source>'{0}' cannot override '{1}' because it is not accessible in this context.</source>
        <target state="translated">'{0}'은(는) 이 컨텍스트에서 액세스할 수 없으므로 '{1}'을(를) 재정의할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_HandlesSyntaxInModule">
        <source>'Handles' in modules must specify a 'WithEvents' variable qualified with a single identifier.</source>
        <target state="translated">'모듈의 'Handles'는 단일 식별자로 한정된 'WithEvents' 변수를 지정해야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_IsNotOpRequiresReferenceTypes1">
        <source>'IsNot' requires operands that have reference types, but this operand has the value type '{0}'.</source>
        <target state="translated">'IsNot'의 피연산자는 참조 형식이어야 하는데 이 피연산자의 값 형식은 '{0}'입니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ClashWithReservedEnumMember1">
        <source>'{0}' conflicts with the reserved member by this name that is implicitly declared in all enums.</source>
        <target state="translated">'{0}'은(는) 모든 열거형에서 암시적으로 선언된 이 이름으로 예약된 멤버와 충돌합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_MultiplyDefinedEnumMember2">
        <source>'{0}' is already declared in this {1}.</source>
        <target state="translated">'{0}'은(는) 이 {1}에 이미 선언되었습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadUseOfVoid">
        <source>'System.Void' can only be used in a GetType expression.</source>
        <target state="translated">'System.Void'는 GetType 식에서만 사용할 수 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_EventImplMismatch5">
        <source>Event '{0}' cannot implement event '{1}' on interface '{2}' because their delegate types '{3}' and '{4}' do not match.</source>
        <target state="translated">대리자 형식 '{3}'과(와) '{4}'이(가) 일치하지 않으므로 '{0}' 이벤트에서 '{2}' 인터페이스에 대해 '{1}' 이벤트를 구현할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ForwardedTypeUnavailable3">
        <source>Type '{0}' in assembly '{1}' has been forwarded to assembly '{2}'. Either a reference to '{2}' is missing from your project or the type '{0}' is missing from assembly '{2}'.</source>
        <target state="translated">'{1}' 어셈블리의 '{0}' 형식이 '{2}' 어셈블리로 전달되었습니다. 프로젝트에 '{2}'에 대한 참조가 없거나 '{2}' 어셈블리에 '{0}' 형식이 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_TypeFwdCycle2">
        <source>'{0}' in assembly '{1}' has been forwarded to itself and so is an unsupported type.</source>
        <target state="translated">'{1}' 어셈블리의 '{0}'이(가) 자신에게 전달되었습니다. 이는 지원되지 않는 형식입니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadTypeInCCExpression">
        <source>Non-intrinsic type names are not allowed in conditional compilation expressions.</source>
        <target state="translated">조건부 컴파일 식에는 내장 형식 이름만 사용할 수 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadCCExpression">
        <source>Syntax error in conditional compilation expression.</source>
        <target state="translated">조건부 컴파일 식에 구문 오류가 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_VoidArrayDisallowed">
        <source>Arrays of type 'System.Void' are not allowed in this expression.</source>
        <target state="translated">이 식에는 'System.Void' 형식의 배열을 사용할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_MetadataMembersAmbiguous3">
        <source>'{0}' is ambiguous because multiple kinds of members with this name exist in {1} '{2}'.</source>
        <target state="translated">'이름이 같은 여러 종류의 멤버가 {1} '{2}'에 있으므로 '{0}'은(는) 모호합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_TypeOfExprAlwaysFalse2">
        <source>Expression of type '{0}' can never be of type '{1}'.</source>
        <target state="translated">'{0}' 형식의 식은 '{1}' 형식일 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_OnlyPrivatePartialMethods1">
        <source>Partial methods must be declared 'Private' instead of '{0}'.</source>
        <target state="translated">부분 메서드(Partial Method)는 '{0}' 대신 'Private'으로 선언해야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PartialMethodsMustBePrivate">
        <source>Partial methods must be declared 'Private'.</source>
        <target state="translated">부분 메서드(Partial Method)는 'Private'으로 선언해야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_OnlyOnePartialMethodAllowed2">
        <source>Method '{0}' cannot be declared 'Partial' because only one method '{1}' can be marked 'Partial'.</source>
        <target state="translated">'{1}' 메서드 하나만 'Partial'로 표시할 수 있으므로 '{0}' 메서드는 'Partial'로 선언할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_OnlyOneImplementingMethodAllowed3">
        <source>Method '{0}' cannot implement partial method '{1}' because '{2}' already implements it. Only one method can implement a partial method.</source>
        <target state="translated">'{2}'에서 이미 '{1}' 부분 메서드(Partial Method)를 구현했으므로 '{0}' 메서드에서 부분 메서드를 구현할 수 없습니다. 메서드 하나만 부분 메서드를 구현할 수 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PartialMethodMustBeEmpty">
        <source>Partial methods must have empty method bodies.</source>
        <target state="translated">부분 메서드(Partial Method)의 본문은 비어 있어야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PartialMethodsMustBeSub1">
        <source>'{0}' cannot be declared 'Partial' because partial methods must be Subs.</source>
        <target state="translated">'부분 메서드(Partial Method)는 Sub여야 하므로 '{0}'은(는) 'Partial'로 선언할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PartialMethodGenericConstraints2">
        <source>Method '{0}' does not have the same generic constraints as the partial method '{1}'.</source>
        <target state="translated">'{0}' 메서드에는 '{1}' 부분 메서드(Partial Method)과 같은 제네릭 제약 조건이 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PartialDeclarationImplements1">
        <source>Partial method '{0}' cannot use the 'Implements' keyword.</source>
        <target state="translated">'{0}' 부분 메서드(Partial Method)에서 'Implements' 키워드를 사용할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NoPartialMethodInAddressOf1">
        <source>'AddressOf' cannot be applied to '{0}' because '{0}' is a partial method without an implementation.</source>
        <target state="translated">'{0}'은(는) 구현하지 않은 부분 메서드(Partial Method)이므로 'AddressOf'를 '{0}'에 적용할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ImplementationMustBePrivate2">
        <source>Method '{0}' must be declared 'Private' in order to implement partial method '{1}'.</source>
        <target state="translated">'{1}' 부분 메서드(Partial Method)를 구현하려면 '{0}' 메서드를 'Private'으로 선언해야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PartialMethodParamNamesMustMatch3">
        <source>Parameter name '{0}' does not match the name of the corresponding parameter, '{1}', defined on the partial method declaration '{2}'.</source>
        <target state="translated">'{0}' 매개 변수 이름이 '{2}' 부분 메서드(Partial Method) 선언에 정의된 해당 '{1}' 매개 변수의 이름과 일치하지 않습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PartialMethodTypeParamNameMismatch3">
        <source>Name of type parameter '{0}' does not match '{1}', the corresponding type parameter defined on the partial method declaration '{2}'.</source>
        <target state="translated">'{0}' 형식 매개 변수의 이름이 '{2}' 부분 메서드(Partial Method) 선언에 정의된 해당 '{1}' 형식 매개 변수와 일치하지 않습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadAttributeSharedProperty1">
        <source>'Shared' attribute property '{0}' cannot be the target of an assignment.</source>
        <target state="translated">'Shared' 특성의 속성 '{0}'은(는) 할당 대상일 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadAttributeReadOnlyProperty1">
        <source>'ReadOnly' attribute property '{0}' cannot be the target of an assignment.</source>
        <target state="translated">'ReadOnly' 특성의 속성 '{0}'은(는) 할당 대상일 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DuplicateResourceName1">
        <source>Resource name '{0}' cannot be used more than once.</source>
        <target state="translated">리소스 이름 '{0}'은(는) 두 번 이상 사용할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DuplicateResourceFileName1">
        <source>Each linked resource and module must have a unique filename. Filename '{0}' is specified more than once in this assembly.</source>
        <target state="translated">링크된 각 리소스와 모듈에는 고유한 파일 이름이 있어야 합니다. '{0}' 파일 이름은 이 어셈블리에 두 번 이상 지정되었습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AttributeMustBeClassNotStruct1">
        <source>'{0}' cannot be used as an attribute because it is not a class.</source>
        <target state="translated">'{0}'은(는) 클래스가 아니므로 특성으로 사용할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AttributeMustInheritSysAttr">
        <source>'{0}' cannot be used as an attribute because it does not inherit from 'System.Attribute'.</source>
        <target state="translated">'{0}'은(는) 'System.Attribute'에서 상속하지 않으므로 특성으로 사용할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AttributeCannotBeAbstract">
        <source>'{0}' cannot be used as an attribute because it is declared 'MustInherit'.</source>
        <target state="translated">'{0}'은(는) 'MustInherit'으로 선언되었으므로 특성으로 사용할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_UnableToOpenResourceFile1">
        <source>Unable to open resource file '{0}': {1}</source>
        <target state="translated">'{0}' 리소스 파일을 열 수 없습니다({1}).</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadAttributeNonPublicProperty1">
        <source>Attribute member '{0}' cannot be the target of an assignment because it is not declared 'Public'.</source>
        <target state="translated">특성 멤버 '{0}'은(는) 'Public'으로 선언되지 않았으므로 할당 대상일 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_STAThreadAndMTAThread0">
        <source>'System.STAThreadAttribute' and 'System.MTAThreadAttribute' cannot both be applied to the same method.</source>
        <target state="translated">'System.STAThreadAttribute'와 'System.MTAThreadAttribute'를 같은 메서드에 함께 적용할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_IndirectUnreferencedAssembly4">
        <source>Project '{0}' makes an indirect reference to assembly '{1}', which contains '{2}'. Add a file reference to '{3}' to your project.</source>
        <target state="translated">'{0}' 프로젝트는 '{2}'을(를) 포함하는 '{1}' 어셈블리에 대한 간접 참조를 만듭니다. '{3}'에 대한 파일 참조를 프로젝트에 추가하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadAttributeNonPublicType1">
        <source>Type '{0}' cannot be used in an attribute because it is not declared 'Public'.</source>
        <target state="translated">'{0}' 형식은 'Public'으로 선언되지 않았으므로 특성에 사용할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadAttributeNonPublicContType2">
        <source>Type '{0}' cannot be used in an attribute because its container '{1}' is not declared 'Public'.</source>
        <target state="translated">'{0}' 형식의 컨테이너 '{1}'이(가) 'Public'으로 선언되지 않았으므로 이 형식을 특성에 사용할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DllImportOnNonEmptySubOrFunction">
        <source>'System.Runtime.InteropServices.DllImportAttribute' cannot be applied to a Sub, Function, or Operator with a non-empty body.</source>
        <target state="translated">'System.Runtime.InteropServices.DllImportAttribute'는 본문이 비어 있는 Sub, Function 또는 Operator에만 적용할 수 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DllImportNotLegalOnDeclare">
        <source>'System.Runtime.InteropServices.DllImportAttribute' cannot be applied to a Declare.</source>
        <target state="translated">'System.Runtime.InteropServices.DllImportAttribute'는 Declare에 적용할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DllImportNotLegalOnGetOrSet">
        <source>'System.Runtime.InteropServices.DllImportAttribute' cannot be applied to a Get or Set.</source>
        <target state="translated">'System.Runtime.InteropServices.DllImportAttribute'는 Get 또는 Set에 적용할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DllImportOnGenericSubOrFunction">
        <source>'System.Runtime.InteropServices.DllImportAttribute' cannot be applied to a method that is generic or contained in a generic type.</source>
        <target state="translated">'System.Runtime.InteropServices.DllImportAttribute'는 제네릭이거나 제네릭 형식에 포함된 메서드에 적용할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ComClassOnGeneric">
        <source>'Microsoft.VisualBasic.ComClassAttribute' cannot be applied to a class that is generic or contained inside a generic type.</source>
        <target state="translated">'Microsoft.VisualBasic.ComClassAttribute'는 제네릭 또는 제네릭 형식에 포함된 클래스에 적용할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DllImportOnInstanceMethod">
        <source>'System.Runtime.InteropServices.DllImportAttribute' cannot be applied to instance method.</source>
        <target state="translated">'System.Runtime.InteropServices.DllImportAttribute'는 인스턴스 메서드에 적용할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DllImportOnInterfaceMethod">
        <source>'System.Runtime.InteropServices.DllImportAttribute' cannot be applied to interface methods.</source>
        <target state="translated">'System.Runtime.InteropServices.DllImportAttribute'는 인터페이스 메서드에 적용할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DllImportNotLegalOnEventMethod">
        <source>'System.Runtime.InteropServices.DllImportAttribute' cannot be applied to 'AddHandler', 'RemoveHandler' or 'RaiseEvent' method.</source>
        <target state="translated">'System.Runtime.InteropServices.DllImportAttribute'는 'AddHandler', 'RemoveHandler' 또는 'RaiseEvent' 메서드에 적용할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_FriendAssemblyBadArguments">
        <source>Friend assembly reference '{0}' is invalid. InternalsVisibleTo declarations cannot have a version, culture, public key token, or processor architecture specified.</source>
        <target state="translated">Friend 어셈블리 참조 '{0}'이(가) 잘못되었습니다. InternalsVisibleTo 선언에는 버전, 문화권, 공개 키 토큰 또는 프로세서 아키텍처를 지정할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_FriendAssemblyStrongNameRequired">
        <source>Friend assembly reference '{0}' is invalid. Strong-name signed assemblies must specify a public key in their InternalsVisibleTo declarations.</source>
        <target state="translated">Friend 어셈블리 참조 '{0}'이(가) 잘못되었습니다. 강력한 이름의 서명된 어셈블리에는 InternalsVisibleTo 선언에 공개 키를 지정해야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_FriendAssemblyNameInvalid">
        <source>Friend declaration '{0}' is invalid and cannot be resolved.</source>
        <target state="translated">friend 선언 '{0}'이(가) 잘못되어 확인할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_FriendAssemblyBadAccessOverride2">
        <source>Member '{0}' cannot override member '{1}' defined in another assembly/project because the access modifier 'Protected Friend' expands accessibility. Use 'Protected' instead.</source>
        <target state="translated">액세스 한정자 'Protected Friend'가 액세스 가능성을 확장하므로 '{0}' 멤버는 다른 어셈블리/프로젝트에 정의된 '{1}' 멤버를 재정의할 수 없습니다. 대신 'Protected'를 사용하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_UseOfLocalBeforeDeclaration1">
        <source>Local variable '{0}' cannot be referred to before it is declared.</source>
        <target state="translated">'{0}' 지역 변수를 참조하려면 이 변수를 먼저 선언해야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_UseOfKeywordFromModule1">
        <source>'{0}' is not valid within a Module.</source>
        <target state="translated">'모듈 내에서는 '{0}'이(가) 유효하지 않습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BogusWithinLineIf">
        <source>Statement cannot end a block outside of a line 'If' statement.</source>
        <target state="translated">문이 'If' 문 줄 외부의 블록에서 끝날 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CharToIntegralTypeMismatch1">
        <source>'Char' values cannot be converted to '{0}'. Use 'Microsoft.VisualBasic.AscW' to interpret a character as a Unicode value or 'Microsoft.VisualBasic.Val' to interpret it as a digit.</source>
        <target state="translated">'Char' 값을 '{0}'(으)로 변환할 수 없습니다. 'Microsoft.VisualBasic.AscW'를 사용하여 문자를 유니코드 값으로 해석하거나 'Microsoft.VisualBasic.Val'을 사용하여 문자를 숫자로 해석하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_IntegralToCharTypeMismatch1">
        <source>'{0}' values cannot be converted to 'Char'. Use 'Microsoft.VisualBasic.ChrW' to interpret a numeric value as a Unicode character or first convert it to 'String' to produce a digit.</source>
        <target state="translated">'{0}' 값을 'Char'로 변환할 수 없습니다. 'Microsoft.VisualBasic.ChrW'를 사용하여 숫자 값을 유니코드 문자로 해석하거나 먼저 숫자 값을 'String'으로 변환하여 숫자를 산출하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NoDirectDelegateConstruction1">
        <source>Delegate '{0}' requires an 'AddressOf' expression or lambda expression as the only argument to its constructor.</source>
        <target state="translated">'{0}' 대리자에서는 'AddressOf' 식 또는 람다 식을 해당 생성자의 유일한 인수로 지정해야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_MethodMustBeFirstStatementOnLine">
        <source>Method declaration statements must be the first statement on a logical line.</source>
        <target state="translated">메서드 선언문은 논리 줄의 첫 번째 문이어야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AttrAssignmentNotFieldOrProp1">
        <source>'{0}' cannot be named as a parameter in an attribute specifier because it is not a field or property.</source>
        <target state="translated">'{0}'은(는) 필드 또는 속성이 아니므로 특성 지정자에서 매개 변수로 명명할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_StrictDisallowsObjectComparison1">
        <source>Option Strict On disallows operands of type Object for operator '{0}'. Use the 'Is' operator to test for object identity.</source>
        <target state="translated">Option Strict On에서는 '{0}' 연산자에 대해 Object 형식의 피연산자를 사용할 수 없습니다. 개체 ID를 테스트하려면 'Is' 연산자를 사용하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NoConstituentArraySizes">
        <source>Bounds can be specified only for the top-level array when initializing an array of arrays.</source>
        <target state="translated">배열의 배열을 초기화하는 동안에는 최상위 배열에 대해서만 범위를 지정할 수 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_FileAttributeNotAssemblyOrModule">
        <source>'Assembly' or 'Module' expected.</source>
        <target state="translated">'Assembly' 또는 'Module'이 필요합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_FunctionResultCannotBeIndexed1">
        <source>'{0}' has no parameters and its return type cannot be indexed.</source>
        <target state="translated">'{0}'에는 매개 변수가 없으며 반환 형식을 인덱싱할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ArgumentSyntax">
        <source>Comma, ')', or a valid expression continuation expected.</source>
        <target state="translated">쉼표, ')' 또는 이어지는 올바른 식이 필요합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExpectedResumeOrGoto">
        <source>'Resume' or 'GoTo' expected.</source>
        <target state="translated">'Resume' 또는 'GoTo'가 필요합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExpectedAssignmentOperator">
        <source>'=' expected.</source>
        <target state="translated">'='가 필요합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NamedArgAlsoOmitted2">
        <source>Parameter '{0}' in '{1}' already has a matching omitted argument.</source>
        <target state="translated">'{1}'의 '{0}' 매개 변수에 일치하는 생략된 인수가 이미 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CannotCallEvent1">
        <source>'{0}' is an event, and cannot be called directly. Use a 'RaiseEvent' statement to raise an event.</source>
        <target state="translated">'{0}'은(는) 이벤트이므로 직접 호출할 수 없습니다. 이벤트를 발생시키려면 'RaiseEvent' 문을 사용하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ForEachCollectionDesignPattern1">
        <source>Expression is of type '{0}', which is not a collection type.</source>
        <target state="translated">식의 형식이 컬렉션 형식이 아닌 '{0}'입니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DefaultValueForNonOptionalParam">
        <source>Default values cannot be supplied for parameters that are not declared 'Optional'.</source>
        <target state="translated">Optional'로 선언하지 않은 매개 변수에 대해 기본값을 지정할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExpectedDotAfterMyBase">
        <source>'MyBase' must be followed by '.' and an identifier.</source>
        <target state="translated">'MyBase' 뒤에는 '.'과 식별자가 와야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExpectedDotAfterMyClass">
        <source>'MyClass' must be followed by '.' and an identifier.</source>
        <target state="translated">'MyClass' 뒤에는 '.'과 식별자가 와야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_StrictArgumentCopyBackNarrowing3">
        <source>Option Strict On disallows narrowing from type '{1}' to type '{2}' in copying the value of 'ByRef' parameter '{0}' back to the matching argument.</source>
        <target state="translated">Option Strict On에서는 'ByRef' 매개 변수 '{0}'의 값을 해당 인수에 다시 복사하는 동안 '{1}' 형식에서 '{2}' 형식으로 축소 변환할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_LbElseifAfterElse">
        <source>'#ElseIf' cannot follow '#Else' as part of a '#If' block.</source>
        <target state="translated">'#ElseIf'는 ''#If' 블록의 일부로 '#Else' 뒤에 올 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_StandaloneAttribute">
        <source>Attribute specifier is not a complete statement. Use a line continuation to apply the attribute to the following statement.</source>
        <target state="translated">특성 지정자 문이 종결되지 않았습니다. 줄 연속 문자를 사용하여 다음 문에 특성을 적용하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NoUniqueConstructorOnBase2">
        <source>Class '{0}' must declare a 'Sub New' because its base class '{1}' has more than one accessible 'Sub New' that can be called with no arguments.</source>
        <target state="translated">'{0}' 클래스의 기본 클래스 '{1}'에는 인수 없이 호출할 수 있는 액세스 가능한 'Sub New'가 두 개 이상 있으므로 'Sub New'를 선언해야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExtraNextVariable">
        <source>'Next' statement names more variables than there are matching 'For' statements.</source>
        <target state="translated">'Next' 문은 해당 'For' 문에 있는 변수보다 많은 변수를 명명합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RequiredNewCallTooMany2">
        <source>First statement of this 'Sub New' must be a call to 'MyBase.New' or 'MyClass.New' because base class '{0}' of '{1}' has more than one accessible 'Sub New' that can be called with no arguments.</source>
        <target state="translated">'{1}'의 기본 클래스 '{0}'에는 인수 없이 호출할 수 있는 액세스 가능한 'Sub New'가 두 개 이상 있으므로 이 'Sub New'의 첫째 문은 'MyBase.New' 또는 'MyClass.New'에 대한 호출이어야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ForCtlVarArraySizesSpecified">
        <source>Array declared as for loop control variable cannot be declared with an initial size.</source>
        <target state="translated">For 루프 제어 변수를 통해 선언되는 배열은 초기 크기를 지정하여 선언할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadFlagsOnNewOverloads">
        <source>The '{0}' keyword is used to overload inherited members; do not use the '{0}' keyword when overloading 'Sub New'.</source>
        <target state="translated">'{0}' 키워드를 사용하여 상속된 멤버를 오버로드했습니다. 'Sub New'를 오버로드할 때에는 '{0}' 키워드를 사용하지 마세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_TypeCharOnGenericParam">
        <source>Type character cannot be used in a type parameter declaration.</source>
        <target state="translated">형식 매개 변수 선언에는 형식 문자를 사용할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_TooFewGenericArguments1">
        <source>Too few type arguments to '{0}'.</source>
        <target state="translated">'{0}'에 대한 형식 인수가 너무 적습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_TooManyGenericArguments1">
        <source>Too many type arguments to '{0}'.</source>
        <target state="translated">'{0}'에 대한 형식 인수가 너무 많습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_GenericConstraintNotSatisfied2">
        <source>Type argument '{0}' does not inherit from or implement the constraint type '{1}'.</source>
        <target state="translated">'{0}' 형식 인수는 '{1}' 제약 조건 형식에서 상속되지 않거나 이를 구현하지 않습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_TypeOrMemberNotGeneric1">
        <source>'{0}' has no type parameters and so cannot have type arguments.</source>
        <target state="translated">'{0}'에는 형식 매개 변수가 없으므로 형식 인수를 사용할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NewIfNullOnGenericParam">
        <source>'New' cannot be used on a type parameter that does not have a 'New' constraint.</source>
        <target state="translated">'New' 제약 조건이 없는 형식 매개 변수에는 'New'를 사용할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_MultipleClassConstraints1">
        <source>Type parameter '{0}' can only have one constraint that is a class.</source>
        <target state="translated">'{0}' 형식 매개 변수는 제약 조건(클래스)을 하나만 포함할 수 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ConstNotClassInterfaceOrTypeParam1">
        <source>Type constraint '{0}' must be either a class, interface or type parameter.</source>
        <target state="translated">형식 제약 조건 '{0}'은(는) 클래스, 인터페이스 또는 형식 매개 변수여야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DuplicateTypeParamName1">
        <source>Type parameter already declared with name '{0}'.</source>
        <target state="translated">이름이 '{0}'인 형식 매개 변수가 이미 선언되었습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_UnboundTypeParam2">
        <source>Type parameter '{0}' for '{1}' cannot be inferred.</source>
        <target state="translated">'{1}'의 형식 매개 변수 '{0}'을(를) 유추할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_IsOperatorGenericParam1">
        <source>'Is' operand of type '{0}' can be compared only to 'Nothing' because '{0}' is a type parameter with no class constraint.</source>
        <target state="translated">'{0}'은(는) 클래스 제약 조건이 없는 형식 매개 변수이므로 '{0}' 형식의 'Is' 피연산자는 'Nothing'과만 비교할 수 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ArgumentCopyBackNarrowing3">
        <source>Copying the value of 'ByRef' parameter '{0}' back to the matching argument narrows from type '{1}' to type '{2}'.</source>
        <target state="translated">ByRef' 매개 변수 '{0}'의 값을 해당 인수에 다시 복사하면 '{1}' 형식에서 '{2}' 형식으로 축소 변환됩니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ShadowingGenericParamWithMember1">
        <source>'{0}' has the same name as a type parameter.</source>
        <target state="translated">'{0}'의 이름이 형식 매개 변수와 같습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_GenericParamBase2">
        <source>{0} '{1}' cannot inherit from a type parameter.</source>
        <target state="translated">{0} '{1}'은(는) 형식 매개 변수에서 상속할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ImplementsGenericParam">
        <source>Type parameter not allowed in 'Implements' clause.</source>
        <target state="translated">Implements' 절에는 형식 매개 변수를 사용할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_OnlyNullLowerBound">
        <source>Array lower bounds can be only '0'.</source>
        <target state="translated">배열 하한으로는 '0'만 사용할 수 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ClassConstraintNotInheritable1">
        <source>Type constraint cannot be a 'NotInheritable' class.</source>
        <target state="translated">형식 제약 조건은 'NotInheritable' 클래스일 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ConstraintIsRestrictedType1">
        <source>'{0}' cannot be used as a type constraint.</source>
        <target state="translated">'{0}'은(는) 형식 제약 조건으로 사용할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_GenericParamsOnInvalidMember">
        <source>Type parameters cannot be specified on this declaration.</source>
        <target state="translated">이 선언에는 형식 매개 변수를 지정할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_GenericArgsOnAttributeSpecifier">
        <source>Type arguments are not valid because attributes cannot be generic.</source>
        <target state="translated">특성이 제네릭일 수 없으므로 형식 인수를 사용할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AttrCannotBeGenerics">
        <source>Type parameters, generic types or types contained in generic types cannot be used as attributes.</source>
        <target state="translated">형식 매개 변수, 제네릭 형식 또는 제네릭 형식에 포함된 형식은 특성으로 사용할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadStaticLocalInGenericMethod">
        <source>Local variables within generic methods cannot be declared 'Static'.</source>
        <target state="translated">제네릭 메서드 안에 있는 지역 변수는 'Static'으로 선언할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_SyntMemberShadowsGenericParam3">
        <source>{0} '{1}' implicitly defines a member '{2}' which has the same name as a type parameter.</source>
        <target state="translated">{0} '{1}'은(는) 형식 매개 변수와 이름이 같은 '{2}' 멤버를 암시적으로 정의합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ConstraintAlreadyExists1">
        <source>Constraint type '{0}' already specified for this type parameter.</source>
        <target state="translated">제약 조건 형식 '{0}'이(가) 이 형식 매개 변수에 대해 이미 지정되어 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InterfacePossiblyImplTwice2">
        <source>Cannot implement interface '{0}' because its implementation could conflict with the implementation of another implemented interface '{1}' for some type arguments.</source>
        <target state="translated">'{0}' 인터페이스 구현이 일부 형식 인수에 대해 구현된 다른 인터페이스 '{1}'의 구현과 충돌할 수 있으므로 이 인터페이스를 구현할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ModulesCannotBeGeneric">
        <source>Modules cannot be generic.</source>
        <target state="translated">모듈은 제네릭일 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_GenericClassCannotInheritAttr">
        <source>Classes that are generic or contained in a generic type cannot inherit from an attribute class.</source>
        <target state="translated">제네릭 또는 제네릭 형식에 포함된 클래스는 특성 클래스에서 상속할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DeclaresCantBeInGeneric">
        <source>'Declare' statements are not allowed in generic types or types contained in generic types.</source>
        <target state="translated">'제네릭 형식 또는 제네릭 형식을 포함하는 형식에서 'Declare' 문이 허용되지 않습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_OverrideWithConstraintMismatch2">
        <source>'{0}' cannot override '{1}' because they differ by type parameter constraints.</source>
        <target state="translated">'형식 매개 변수 제약 조건이 서로 다르므로 '{0}'은(는) '{1}'을(를) 재정의할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ImplementsWithConstraintMismatch3">
        <source>'{0}' cannot implement '{1}.{2}' because they differ by type parameter constraints.</source>
        <target state="translated">'형식 매개 변수 제약 조건이 서로 다르므로 '{0}'은(는) '{1}.{2}'을(를) 구현할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_OpenTypeDisallowed">
        <source>Type parameters or types constructed with type parameters are not allowed in attribute arguments.</source>
        <target state="translated">형식 매개 변수로 생성된 형식 매개 변수 또는 형식은 특성 인수에 사용할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_HandlesInvalidOnGenericMethod">
        <source>Generic methods cannot use 'Handles' clause.</source>
        <target state="translated">제네릭 메서드에서는 'Handles' 절을 사용할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_MultipleNewConstraints">
        <source>'New' constraint cannot be specified multiple times for the same type parameter.</source>
        <target state="translated">'동일한 형식 매개 변수에는 'New' 제약 조건을 여러 번 지정할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_MustInheritForNewConstraint2">
        <source>Type argument '{0}' is declared 'MustInherit' and does not satisfy the 'New' constraint for type parameter '{1}'.</source>
        <target state="translated">'{0}' 형식 인수는 'MustInherit'으로 선언되었으며 형식 매개 변수 '{1}'에 대한 'New' 제약 조건을 만족하지 않습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NoSuitableNewForNewConstraint2">
        <source>Type argument '{0}' must have a public parameterless instance constructor to satisfy the 'New' constraint for type parameter '{1}'.</source>
        <target state="translated">형식 매개 변수 '{1}'에 대한 'New' 제약 조건을 만족하려면 형식 인수 '{0}'에 매개 변수가 없는 public 인스턴스 생성자가 있어야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadGenericParamForNewConstraint2">
        <source>Type parameter '{0}' must have either a 'New' constraint or a 'Structure' constraint to satisfy the 'New' constraint for type parameter '{1}'.</source>
        <target state="translated">형식 매개 변수 '{1}'에 대한 'New' 제약 조건을 만족하려면 형식 매개 변수 '{0}'에 'New' 제약 조건 또는 'Structure' 제약 조건이 있어야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NewArgsDisallowedForTypeParam">
        <source>Arguments cannot be passed to a 'New' used on a type parameter.</source>
        <target state="translated">형식 매개 변수에 사용된 'New'에 인수를 전달할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DuplicateRawGenericTypeImport1">
        <source>Generic type '{0}' cannot be imported more than once.</source>
        <target state="translated">제네릭 형식 '{0}'은(는) 두 번 이상 가져올 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NoTypeArgumentCountOverloadCand1">
        <source>Overload resolution failed because no accessible '{0}' accepts this number of type arguments.</source>
        <target state="translated">지정한 개수의 형식 인수를 허용하는 액세스 가능한 '{0}'이(가) 없으므로 오버로드를 확인하지 못했습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_TypeArgsUnexpected">
        <source>Type arguments unexpected.</source>
        <target state="translated">예기치 않은 형식 인수입니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NameSameAsMethodTypeParam1">
        <source>'{0}' is already declared as a type parameter of this method.</source>
        <target state="translated">'{0}'이(가) 이 메서드의 형식 매개 변수로 이미 선언되었습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_TypeParamNameFunctionNameCollision">
        <source>Type parameter cannot have the same name as its defining function.</source>
        <target state="translated">형식 매개 변수에는 자신을 정의하는 함수와 같은 이름을 사용할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadConstraintSyntax">
        <source>Type or 'New' expected.</source>
        <target state="translated">형식 또는 'New'가 필요합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_OfExpected">
        <source>'Of' required when specifying type arguments for a generic type or method.</source>
        <target state="translated">'제네릭 형식 또는 메서드에 형식 인수를 지정하는 경우에는 'Of'가 필요합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ArrayOfRawGenericInvalid">
        <source>'(' unexpected. Arrays of uninstantiated generic types are not allowed.</source>
        <target state="translated">'예기치 않은 '('입니다. 인스턴스화되지 않은 제네릭 형식의 배열은 사용할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ForEachAmbiguousIEnumerable1">
        <source>'For Each' on type '{0}' is ambiguous because the type implements multiple instantiations of 'System.Collections.Generic.IEnumerable(Of T)'.</source>
        <target state="translated">'{0}' 형식은 'System.Collections.Generic.IEnumerable(Of T)'의 여러 인스턴스화를 구현하므로 이 형식의 'For Each'가 모호합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_IsNotOperatorGenericParam1">
        <source>'IsNot' operand of type '{0}' can be compared only to 'Nothing' because '{0}' is a type parameter with no class constraint.</source>
        <target state="translated">'{0}'은(는) 클래스 제약 조건이 없는 형식 매개 변수이므로 '{0}' 형식의 'IsNot' 피연산자는 'Nothing'과만 비교할 수 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_TypeParamQualifierDisallowed">
        <source>Type parameters cannot be used as qualifiers.</source>
        <target state="translated">형식 매개 변수는 한정자로 사용할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_TypeParamMissingCommaOrRParen">
        <source>Comma or ')' expected.</source>
        <target state="translated">쉼표 또는 ')'가 필요합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_TypeParamMissingAsCommaOrRParen">
        <source>'As', comma or ')' expected.</source>
        <target state="translated">'As', 쉼표 또는 ')'가 필요합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_MultipleReferenceConstraints">
        <source>'Class' constraint cannot be specified multiple times for the same type parameter.</source>
        <target state="translated">'동일한 형식 매개 변수에는 'Class' 제약 조건을 여러 번 지정할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_MultipleValueConstraints">
        <source>'Structure' constraint cannot be specified multiple times for the same type parameter.</source>
        <target state="translated">'동일한 형식 매개 변수에는 'Structure' 제약 조건을 여러 번 지정할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NewAndValueConstraintsCombined">
        <source>'New' constraint and 'Structure' constraint cannot be combined.</source>
        <target state="translated">'New' 제약 조건과 'Structure' 제약 조건은 함께 사용할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RefAndValueConstraintsCombined">
        <source>'Class' constraint and 'Structure' constraint cannot be combined.</source>
        <target state="translated">'Class' 제약 조건과 'Structure' 제약 조건은 함께 사용할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadTypeArgForStructConstraint2">
        <source>Type argument '{0}' does not satisfy the 'Structure' constraint for type parameter '{1}'.</source>
        <target state="translated">'{0}' 형식 인수는 '{1}' 형식 매개 변수에 대한 'Structure' 제약 조건을 만족하지 않습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadTypeArgForRefConstraint2">
        <source>Type argument '{0}' does not satisfy the 'Class' constraint for type parameter '{1}'.</source>
        <target state="translated">'{0}' 형식 인수는 '{1}' 형식 매개 변수에 대한 'Class' 제약 조건을 만족하지 않습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RefAndClassTypeConstrCombined">
        <source>'Class' constraint and a specific class type constraint cannot be combined.</source>
        <target state="translated">'Class' 제약 조건과 특정 클래스 형식 제약 조건은 함께 사용할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ValueAndClassTypeConstrCombined">
        <source>'Structure' constraint and a specific class type constraint cannot be combined.</source>
        <target state="translated">'Structure' 제약 조건과 특정 클래스 형식 제약 조건은 함께 사용할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ConstraintClashIndirectIndirect4">
        <source>Indirect constraint '{0}' obtained from the type parameter constraint '{1}' conflicts with the indirect constraint '{2}' obtained from the type parameter constraint '{3}'.</source>
        <target state="translated">형식 매개 변수 제약 조건 '{1}'에서 가져온 간접 제약 조건 '{0}'이(가) 형식 매개 변수 제약 조건 '{3}'에서 가져온 간접 제약 조건 '{2}'과(와) 충돌합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ConstraintClashDirectIndirect3">
        <source>Constraint '{0}' conflicts with the indirect constraint '{1}' obtained from the type parameter constraint '{2}'.</source>
        <target state="translated">형식 매개 변수 제약 조건 '{2}'에서 가져온 간접 제약 조건 '{1}'이(가) '{0}' 제약 조건과 충돌합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ConstraintClashIndirectDirect3">
        <source>Indirect constraint '{0}' obtained from the type parameter constraint '{1}' conflicts with the constraint '{2}'.</source>
        <target state="translated">형식 매개 변수 제약 조건 '{1}'에서 가져온 간접 제약 조건 '{0}'이(가) '{2}' 제약 조건과 충돌합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ConstraintCycleLink2">
        <source>
    '{0}' is constrained to '{1}'.</source>
        <target state="translated">
    '{0}'은(는) '{1}'의 제약을 받습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ConstraintCycle2">
        <source>Type parameter '{0}' cannot be constrained to itself: {1}</source>
        <target state="translated">'{0}' 형식 매개 변수는 자신의 제약을 받을 수 없습니다({1}).</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_TypeParamWithStructConstAsConst">
        <source>Type parameter with a 'Structure' constraint cannot be used as a constraint.</source>
        <target state="translated">Structure' 제약 조건이 있는 형식 매개 변수는 제약 조건으로 사용할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NullableDisallowedForStructConstr1">
        <source>'System.Nullable' does not satisfy the 'Structure' constraint for type parameter '{0}'. Only non-nullable 'Structure' types are allowed.</source>
        <target state="translated">'System.Nullable'은 형식 매개 변수 '{0}'에 대한 'Structure' 제약 조건을 만족하지 않습니다. null을 허용하지 않는 'Structure' 형식만 사용할 수 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ConflictingDirectConstraints3">
        <source>Constraint '{0}' conflicts with the constraint '{1}' already specified for type parameter '{2}'.</source>
        <target state="translated">제약 조건 '{0}'이(가) 형식 매개 변수 '{2}'에 이미 지정된 제약 조건 '{1}'과(와) 충돌합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InterfaceUnifiesWithInterface2">
        <source>Cannot inherit interface '{0}' because it could be identical to interface '{1}' for some type arguments.</source>
        <target state="translated">'{0}' 인터페이스가 일부 형식 인수에 대해 '{1}' 인터페이스와 동일할 수 있으므로 인터페이스를 상속할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BaseUnifiesWithInterfaces3">
        <source>Cannot inherit interface '{0}' because the interface '{1}' from which it inherits could be identical to interface '{2}' for some type arguments.</source>
        <target state="translated">'{0}' 인터페이스를 상속할 수 없습니다. 이 인터페이스가 상속된 '{1}' 인터페이스가 일부 형식 인수에 대해 '{2}' 인터페이스와 동일할 수 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InterfaceBaseUnifiesWithBase4">
        <source>Cannot inherit interface '{0}' because the interface '{1}' from which it inherits could be identical to interface '{2}' from which the interface '{3}' inherits for some type arguments.</source>
        <target state="translated">'{0}' 인터페이스를 상속할 수 없습니다. 이 인터페이스가 상속된 '{1}' 인터페이스가 일부 형식 인수에 대해 '{3}' 인터페이스가 상속된 '{2}' 인터페이스와 동일할 수 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InterfaceUnifiesWithBase3">
        <source>Cannot inherit interface '{0}' because it could be identical to interface '{1}' from which the interface '{2}' inherits for some type arguments.</source>
        <target state="translated">'{0}' 인터페이스를 상속할 수 없습니다. 이 인터페이스가 일부 형식 인수에 대해 '{2}' 인터페이스가 상속된 '{1}' 인터페이스와 동일할 수 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ClassInheritsBaseUnifiesWithInterfaces3">
        <source>Cannot implement interface '{0}' because the interface '{1}' from which it inherits could be identical to implemented interface '{2}' for some type arguments.</source>
        <target state="translated">'{0}' 인터페이스를 구현할 수 없습니다. 이 인터페이스가 구현된 '{1}' 인터페이스가 일부 형식 인수에 대해 '{2}' 인터페이스와 동일할 수 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ClassInheritsInterfaceBaseUnifiesWithBase4">
        <source>Cannot implement interface '{0}' because the interface '{1}' from which it inherits could be identical to interface '{2}' from which the implemented interface '{3}' inherits for some type arguments.</source>
        <target state="translated">'{0}' 인터페이스를 구현할 수 없습니다. 이 인터페이스가 상속된 '{1}' 인터페이스가 일부 형식 인수에 대해 구현된 '{3}' 인터페이스가 상속된 '{2}' 인터페이스와 동일할 수 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ClassInheritsInterfaceUnifiesWithBase3">
        <source>Cannot implement interface '{0}' because it could be identical to interface '{1}' from which the implemented interface '{2}' inherits for some type arguments.</source>
        <target state="translated">'{0}' 인터페이스를 구현할 수 없습니다. 이 인터페이스가 일부 형식 인수에 대해 구현된 '{2}' 인터페이스가 상속된 '{1}' 인터페이스와 동일할 수 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_OptionalsCantBeStructGenericParams">
        <source>Generic parameters used as optional parameter types must be class constrained.</source>
        <target state="translated">선택적 매개 변수 형식으로 사용되는 제네릭 매개 변수는 클래스 제약 조건이 있어야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AddressOfNullableMethod">
        <source>Methods of 'System.Nullable(Of T)' cannot be used as operands of the 'AddressOf' operator.</source>
        <target state="translated">System.Nullable(Of T)'의 메서드를 'AddressOf' 연산자의 피연산자로 사용할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_IsOperatorNullable1">
        <source>'Is' operand of type '{0}' can be compared only to 'Nothing' because '{0}' is a nullable type.</source>
        <target state="translated">'{0}'은(는) null 허용 형식이므로 '{0}' 형식의 'Is' 피연산자는 'Nothing'과만 비교할 수 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_IsNotOperatorNullable1">
        <source>'IsNot' operand of type '{0}' can be compared only to 'Nothing' because '{0}' is a nullable type.</source>
        <target state="translated">'{0}'은(는) null 허용 형식이므로 '{0}' 형식의 'IsNot' 피연산자는 'Nothing'과만 비교할 수 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ShadowingTypeOutsideClass1">
        <source>'{0}' cannot be declared 'Shadows' outside of a class, structure, or interface.</source>
        <target state="translated">'클래스, 구조체 또는 인터페이스 외부에서는 '{0}'을(를) 'Shadows'로 선언할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PropertySetParamCollisionWithValue">
        <source>Property parameters cannot have the name 'Value'.</source>
        <target state="translated">속성 매개 변수 이름에는 'Value'를 사용할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_SxSIndirectRefHigherThanDirectRef3">
        <source>The project currently contains references to more than one version of '{0}', a direct reference to version {2} and an indirect reference to version {1}. Change the direct reference to use version {1} (or higher) of {0}.</source>
        <target state="translated">프로젝트에는 현재 두 가지 이상 버전의 '{0}' 참조, 즉 버전 {2}에 대한 직접 참조와 버전 {1}에 대한 간접 참조가 포함되어 있습니다. 버전 {1} 이상의 {0}을(를) 사용하려면 직접 참조를 변경하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DuplicateReferenceStrong">
        <source>Multiple assemblies with equivalent identity have been imported: '{0}' and '{1}'. Remove one of the duplicate references.</source>
        <target state="translated">ID가 동일한 여러 어셈블리를 가져왔습니다('{0}', '{1}'). 중복된 참조 중 하나를 제거하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DuplicateReference2">
        <source>Project already has a reference to assembly '{0}'. A second reference to '{1}' cannot be added.</source>
        <target state="translated">프로젝트에 이미 '{0}' 어셈블리에 대한 참조가 있습니다. '{1}'에 대한 두 번째 참조를 추가할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_IllegalCallOrIndex">
        <source>Illegal call expression or index expression.</source>
        <target state="translated">호출 식 또는 인덱스 식이 잘못되었습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ConflictDefaultPropertyAttribute">
        <source>Conflict between the default property and the 'DefaultMemberAttribute' defined on '{0}'.</source>
        <target state="translated">'{0}'에 정의된 'DefaultMemberAttribute'와 기본 속성이 충돌합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadAttributeUuid2">
        <source>'{0}' cannot be applied because the format of the GUID '{1}' is not correct.</source>
        <target state="translated">'GUID '{1}'의 형식이 잘못되어 '{0}'을(를) 적용할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ComClassAndReservedAttribute1">
        <source>'Microsoft.VisualBasic.ComClassAttribute' and '{0}' cannot both be applied to the same class.</source>
        <target state="translated">'Microsoft.VisualBasic.ComClassAttribute'와 '{0}'을(를) 같은 클래스에 적용할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ComClassRequiresPublicClass2">
        <source>'Microsoft.VisualBasic.ComClassAttribute' cannot be applied to '{0}' because its container '{1}' is not declared 'Public'.</source>
        <target state="translated">'해당 컨테이너 '{1}'가 'Public'으로 선언되지 않았으므로 'Microsoft.VisualBasic.ComClassAttribute'를 '{0}'에 적용할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ComClassReservedDispIdZero1">
        <source>'System.Runtime.InteropServices.DispIdAttribute' cannot be applied to '{0}' because 'Microsoft.VisualBasic.ComClassAttribute' reserves zero for the default property.</source>
        <target state="translated">'Microsoft.VisualBasic.ComClassAttribute'는 기본 속성으로 0을 예약하므로 'System.Runtime.InteropServices.DispIdAttribute'를 '{0}'에 적용할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ComClassReservedDispId1">
        <source>'System.Runtime.InteropServices.DispIdAttribute' cannot be applied to '{0}' because 'Microsoft.VisualBasic.ComClassAttribute' reserves values less than zero.</source>
        <target state="translated">'Microsoft.VisualBasic.ComClassAttribute'는 0보다 작은 값을 예약하므로 'System.Runtime.InteropServices.DispIdAttribute'를 '{0}'에 적용할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ComClassDuplicateGuids1">
        <source>'InterfaceId' and 'EventsId' parameters for 'Microsoft.VisualBasic.ComClassAttribute' on '{0}' cannot have the same value.</source>
        <target state="translated">'{0}'의 'Microsoft.VisualBasic.ComClassAttribute'에 대한 'InterfaceId' 및 'EventsId' 매개 변수에는 같은 값을 사용할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ComClassCantBeAbstract0">
        <source>'Microsoft.VisualBasic.ComClassAttribute' cannot be applied to a class that is declared 'MustInherit'.</source>
        <target state="translated">'Microsoft.VisualBasic.ComClassAttribute'는 'MustInherit'으로 선언된 클래스에 적용할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ComClassRequiresPublicClass1">
        <source>'Microsoft.VisualBasic.ComClassAttribute' cannot be applied to '{0}' because it is not declared 'Public'.</source>
        <target state="translated">'Microsoft.VisualBasic.ComClassAttribute'는 'Public'으로 선언되지 않았으므로 '{0}'에 적용할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_UnknownOperator">
        <source>Operator declaration must be one of:  +, -, *, \, /, ^, &amp;, Like, Mod, And, Or, Xor, Not, &lt;&lt;, &gt;&gt;, =, &lt;&gt;, &lt;, &lt;=, &gt;, &gt;=, CType, IsTrue, IsFalse.</source>
        <target state="translated">연산자 선언은 +, -, *, \, /, ^, &amp;, Like, Mod, And, Or, Xor, Not, &lt;&lt;, &gt;&gt;, =, &lt;&gt;, &lt;, &lt;=, &gt;, &gt;=, CType, IsTrue, IsFalse 중 하나여야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DuplicateConversionCategoryUsed">
        <source>'Widening' and 'Narrowing' cannot be combined.</source>
        <target state="translated">'Widening'과 'Narrowing'은 함께 사용할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_OperatorNotOverloadable">
        <source>Operator is not overloadable. Operator declaration must be one of:  +, -, *, \, /, ^, &amp;, Like, Mod, And, Or, Xor, Not, &lt;&lt;, &gt;&gt;, =, &lt;&gt;, &lt;, &lt;=, &gt;, &gt;=, CType, IsTrue, IsFalse.</source>
        <target state="translated">연산자를 오버로드할 수 없습니다. 연산자 선언은 +, -, *, \, /, ^, &amp;, Like, Mod, And, Or, Xor, Not, &lt;&lt;, &gt;&gt;, =, &lt;&gt;, &lt;, &lt;=, &gt;, &gt;=, CType, IsTrue, IsFalse 중 하나여야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InvalidHandles">
        <source>'Handles' is not valid on operator declarations.</source>
        <target state="translated">'연산자 선언에는 'Handles'를 사용할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InvalidImplements">
        <source>'Implements' is not valid on operator declarations.</source>
        <target state="translated">'연산자 선언에는 'Implements'를 사용할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_EndOperatorExpected">
        <source>'End Operator' expected.</source>
        <target state="translated">'End Operator'가 필요합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_EndOperatorNotAtLineStart">
        <source>'End Operator' must be the first statement on a line.</source>
        <target state="translated">'End Operator'는 줄의 첫 번째 문이어야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InvalidEndOperator">
        <source>'End Operator' must be preceded by a matching 'Operator'.</source>
        <target state="translated">'End Operator'는 짝이 되는 'Operator' 뒤에 와야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExitOperatorNotValid">
        <source>'Exit Operator' is not valid. Use 'Return' to exit an operator.</source>
        <target state="translated">'Exit Operator'가 잘못되었습니다. 연산자를 종료하려면 'Return'을 사용하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ParamArrayIllegal1">
        <source>'{0}' parameters cannot be declared 'ParamArray'.</source>
        <target state="translated">'{0}' 매개 변수는 'ParamArray'로 선언할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_OptionalIllegal1">
        <source>'{0}' parameters cannot be declared 'Optional'.</source>
        <target state="translated">'{0}' 매개 변수는 'Optional'로 선언할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_OperatorMustBePublic">
        <source>Operators must be declared 'Public'.</source>
        <target state="translated">연산자를 'Public'으로 선언해야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_OperatorMustBeShared">
        <source>Operators must be declared 'Shared'.</source>
        <target state="translated">연산자를 'Shared'로 선언해야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadOperatorFlags1">
        <source>Operators cannot be declared '{0}'.</source>
        <target state="translated">연산자는 '{0}'(으)로 선언할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_OneParameterRequired1">
        <source>Operator '{0}' must have one parameter.</source>
        <target state="translated">'{0}' 연산자에는 매개 변수를 한 개만 사용할 수 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_TwoParametersRequired1">
        <source>Operator '{0}' must have two parameters.</source>
        <target state="translated">'{0}' 연산자에는 두 가지 매개 변수를 사용해야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_OneOrTwoParametersRequired1">
        <source>Operator '{0}' must have either one or two parameters.</source>
        <target state="translated">'{0}' 연산자에는 매개 변수를 한 개 또는 두 개만 사용할 수 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ConvMustBeWideningOrNarrowing">
        <source>Conversion operators must be declared either 'Widening' or 'Narrowing'.</source>
        <target state="translated">변환 연산자를 'Widening' 또는 'Narrowing'으로 선언해야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_OperatorDeclaredInModule">
        <source>Operators cannot be declared in modules.</source>
        <target state="translated">모듈에는 연산자를 선언할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InvalidSpecifierOnNonConversion1">
        <source>Only conversion operators can be declared '{0}'.</source>
        <target state="translated">변환 연산자만 '{0}'(으)로 선언할 수 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_UnaryParamMustBeContainingType1">
        <source>Parameter of this unary operator must be of the containing type '{0}'.</source>
        <target state="translated">이 단항 연산자의 매개 변수는 포함하는 형식 '{0}'이어야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BinaryParamMustBeContainingType1">
        <source>At least one parameter of this binary operator must be of the containing type '{0}'.</source>
        <target state="translated">이 이항 연산자의 매개 변수 중 하나 이상은 포함하는 형식 '{0}'이어야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ConvParamMustBeContainingType1">
        <source>Either the parameter type or the return type of this conversion operator must be of the containing type '{0}'.</source>
        <target state="translated">이 변환 연산자의 매개 변수 형식 또는 반환 형식은 포함하는 '{0}' 형식이어야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_OperatorRequiresBoolReturnType1">
        <source>Operator '{0}' must have a return type of Boolean.</source>
        <target state="translated">'{0}' 연산자의 반환 형식은 Boolean이어야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ConversionToSameType">
        <source>Conversion operators cannot convert from a type to the same type.</source>
        <target state="translated">변환 연산자는 특정 형식에서 동일한 형식으로 변환할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ConversionToInterfaceType">
        <source>Conversion operators cannot convert to an interface type.</source>
        <target state="translated">변환 연산자는 인터페이스 형식으로 변환할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ConversionToBaseType">
        <source>Conversion operators cannot convert from a type to its base type.</source>
        <target state="translated">변환 연산자는 특정 형식에서 해당 형식의 기본 형식으로 변환할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ConversionToDerivedType">
        <source>Conversion operators cannot convert from a type to its derived type.</source>
        <target state="translated">변환 연산자는 특정 형식에서 해당 형식의 파생 형식으로 변환할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ConversionToObject">
        <source>Conversion operators cannot convert to Object.</source>
        <target state="translated">변환 연산자는 Object로 변환할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ConversionFromInterfaceType">
        <source>Conversion operators cannot convert from an interface type.</source>
        <target state="translated">변환 연산자는 인터페이스 형식에서 변환할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ConversionFromBaseType">
        <source>Conversion operators cannot convert from a base type.</source>
        <target state="translated">변환 연산자는 기본 형식에서 변환할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ConversionFromDerivedType">
        <source>Conversion operators cannot convert from a derived type.</source>
        <target state="translated">변환 연산자는 파생 형식에서 변환할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ConversionFromObject">
        <source>Conversion operators cannot convert from Object.</source>
        <target state="translated">변환 연산자는 Object에서 변환할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_MatchingOperatorExpected2">
        <source>Matching '{0}' operator is required for '{1}'.</source>
        <target state="translated">짝이 되는 '{0}' 연산자가 '{1}'에 필요합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_UnacceptableLogicalOperator3">
        <source>Return and parameter types of '{0}' must be '{1}' to be used in a '{2}' expression.</source>
        <target state="translated">'{0}'의 반환 및 매개 변수 형식은 '{2}' 식에서 사용할 '{1}'이어야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ConditionOperatorRequired3">
        <source>Type '{0}' must define operator '{1}' to be used in a '{2}' expression.</source>
        <target state="translated">'{0}' 형식은 '{2}' 식에서 사용할 '{1}' 연산자를 정의해야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CopyBackTypeMismatch3">
        <source>Cannot copy the value of 'ByRef' parameter '{0}' back to the matching argument because type '{1}' cannot be converted to type '{2}'.</source>
        <target state="translated">'{1}' 형식은 '{2}' 형식으로 변환할 수 없으므로 'ByRef' 매개 변수 '{0}'의 값을 해당 인수에 다시 복사할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ForLoopOperatorRequired2">
        <source>Type '{0}' must define operator '{1}' to be used in a 'For' statement.</source>
        <target state="translated">'{0}' 형식은 'For' 문에서 사용할 '{1}' 연산자를 정의해야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_UnacceptableForLoopOperator2">
        <source>Return and parameter types of '{0}' must be '{1}' to be used in a 'For' statement.</source>
        <target state="translated">'{0}'의 반환 및 매개 변수 형식은 'For' 문에서 사용할 '{1}'이어야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_UnacceptableForLoopRelOperator2">
        <source>Parameter types of '{0}' must be '{1}' to be used in a 'For' statement.</source>
        <target state="translated">'{0}'의 매개 변수 형식은 'For' 문에서 사용할 '{1}'이어야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_OperatorRequiresIntegerParameter1">
        <source>Operator '{0}' must have a second parameter of type 'Integer' or 'Integer?'.</source>
        <target state="translated">'{0}' 연산자의 두 번째 매개 변수 형식은 'Integer' 또는 'Integer?'여야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CantSpecifyNullableOnBoth">
        <source>Nullable modifier cannot be specified on both a variable and its type.</source>
        <target state="translated">변수와 그 형식 모두에 null 허용 한정자를 지정할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadTypeArgForStructConstraintNull">
        <source>Type '{0}' must be a value type or a type argument constrained to 'Structure' in order to be used with 'Nullable' or nullable modifier '?'.</source>
        <target state="translated">'{0}' 형식을 'Null 허용' 또는 null 허용 한정자 '?'와 함께 사용하려면 해당 형식이 'Structure'의 제약을 받는 형식 인수이거나 값 형식이어야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CantSpecifyArrayAndNullableOnBoth">
        <source>Nullable modifier '?' and array modifiers '(' and ')' cannot be specified on both a variable and its type.</source>
        <target state="translated">변수와 그 형식 모두에 null 허용 한정자 '?'와 배열 한정자 '(' 및 ')'를 지정할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CantSpecifyTypeCharacterOnIIF">
        <source>Expressions used with an 'If' expression cannot contain type characters.</source>
        <target state="translated">If' 식을 사용한 식은 형식 문자를 포함할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_IllegalOperandInIIFName">
        <source>'If' operands cannot be named arguments.</source>
        <target state="translated">'If' 피연산자는 명명된 인수일 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_IllegalOperandInIIFConversion">
        <source>Cannot infer a common type for the second and third operands of the 'If' operator. One must have a widening conversion to the other.</source>
        <target state="translated">If' 연산자의 두 번째, 세 번째 피연산자에 대한 공용 형식을 유추할 수 없습니다. 하나가 다른 하나에 대해 확대 변환을 해야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_IllegalCondTypeInIIF">
        <source>First operand in a binary 'If' expression must be a nullable value type, a reference type, or an unconstrained generic type.</source>
        <target state="translated">If' 이항 식의 첫 번째 피연산자는 nullable이거나 참조 형식이어야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CantCallIIF">
        <source>'If' operator cannot be used in a 'Call' statement.</source>
        <target state="translated">'If' 연산자는 'Call' 문에서 사용할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CantSpecifyAsNewAndNullable">
        <source>Nullable modifier cannot be specified in variable declarations with 'As New'.</source>
        <target state="translated">As New'를 사용하는 변수 선언에는 null 허용 한정자를 지정할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_IllegalOperandInIIFConversion2">
        <source>Cannot infer a common type for the first and second operands of the binary 'If' operator. One must have a widening conversion to the other.</source>
        <target state="translated">이진 'If' 연산자의 첫 번째, 두 번째 피연산자에 대한 공용 형식을 유추할 수 없습니다. 하나가 다른 하나에 대해 확대 변환을 해야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadNullTypeInCCExpression">
        <source>Nullable types are not allowed in conditional compilation expressions.</source>
        <target state="translated">조건부 컴파일 식에는 nullable 형식을 사용할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NullableImplicit">
        <source>Nullable modifier cannot be used with a variable whose implicit type is 'Object'.</source>
        <target state="translated">null 허용 한정자는 암시적 형식이 'Object'인 변수와 함께 사용할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_MissingRuntimeHelper">
        <source>Requested operation is not available because the runtime library function '{0}' is not defined.</source>
        <target state="translated">'{0}' 런타임 라이브러리 함수가 정의되어 있지 않아 요청한 작업을 수행할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExpectedDotAfterGlobalNameSpace">
        <source>'Global' must be followed by '.' and an identifier.</source>
        <target state="translated">'Global' 다음에는 '.'과 식별자가 와야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NoGlobalExpectedIdentifier">
        <source>'Global' not allowed in this context; identifier expected.</source>
        <target state="translated">'이 컨텍스트에서는 'Global'을 사용할 수 없습니다. 식별자가 필요합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NoGlobalInHandles">
        <source>'Global' not allowed in handles; local name expected.</source>
        <target state="translated">'핸들에는 'Global'을 사용할 수 없습니다. 로컬 이름이 필요합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ElseIfNoMatchingIf">
        <source>'ElseIf' must be preceded by a matching 'If' or 'ElseIf'.</source>
        <target state="translated">'ElseIf'는 짝이 되는 'If' 또는 'ElseIf' 뒤에 와야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadAttributeConstructor2">
        <source>Attribute constructor has a 'ByRef' parameter of type '{0}'; cannot use constructors with byref parameters to apply the attribute.</source>
        <target state="translated">특성 생성자에 'ByRef' 매개 변수 형식 '{0}'이 있으므로 byref 매개 변수와 함께 생성자를 사용하여 특성을 적용할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_EndUsingWithoutUsing">
        <source>'End Using' must be preceded by a matching 'Using'.</source>
        <target state="translated">'End Using'은 짝이 되는 'Using' 뒤에 와야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExpectedEndUsing">
        <source>'Using' must end with a matching 'End Using'.</source>
        <target state="translated">'Using'은 짝이 되는 'End Using'으로 끝나야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_GotoIntoUsing">
        <source>'GoTo {0}' is not valid because '{0}' is inside a 'Using' statement that does not contain this statement.</source>
        <target state="translated">'{0}'이(가) 이 문을 포함하지 않는 'Using' 문 내부에 있기 때문에 'GoTo {0}'은(는) 유효하지 않습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_UsingRequiresDisposePattern">
        <source>'Using' operand of type '{0}' must implement 'System.IDisposable'.</source>
        <target state="translated">'{0}' 형식의 'Using' 피연산자는 'System.IDisposable'을 구현해야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_UsingResourceVarNeedsInitializer">
        <source>'Using' resource variable must have an explicit initialization.</source>
        <target state="translated">'Using' 리소스 변수에는 명시적 초기화를 사용해야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_UsingResourceVarCantBeArray">
        <source>'Using' resource variable type can not be array type.</source>
        <target state="translated">'Using' 리소스 변수 형식은 배열 형식일 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_OnErrorInUsing">
        <source>'On Error' statements are not valid within 'Using' statements.</source>
        <target state="translated">'On Error' 문은 'Using' 문 안에서 사용할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PropertyNameConflictInMyCollection">
        <source>'{0}' has the same name as a member used for type '{1}' exposed in a 'My' group. Rename the type or its enclosing namespace.</source>
        <target state="translated">'{0}'의 이름이 '{1}' 형식을 'My' 그룹에 노출하는 데 사용한 멤버와 같습니다. 형식 또는 형식의 바깥쪽 네임스페이스의 이름을 바꾸세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InvalidImplicitVar">
        <source>Implicit variable '{0}' is invalid because of '{1}'.</source>
        <target state="translated">'{0}' 암시적 변수가 '{1}' 때문에 잘못되었습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ObjectInitializerRequiresFieldName">
        <source>Object initializers require a field name to initialize.</source>
        <target state="translated">개체 이니셜라이저에 초기화할 필드 이름이 필요합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExpectedFrom">
        <source>'From' expected.</source>
        <target state="translated">'From'이 필요합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_LambdaBindingMismatch1">
        <source>Nested function does not have the same signature as delegate '{0}'.</source>
        <target state="translated">중첩된 함수에 '{0}' 대리자와 동일한 시그니처가 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_LambdaBindingMismatch2">
        <source>Nested sub does not have a signature that is compatible with delegate '{0}'.</source>
        <target state="translated">중첩된 sub에 '{0}' 대리자와 호환되는 시그니처가 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CannotLiftByRefParamQuery1">
        <source>'ByRef' parameter '{0}' cannot be used in a query expression.</source>
        <target state="translated">'쿼리 식에는 'ByRef' 매개 변수 '{0}'을(를) 사용할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExpressionTreeNotSupported">
        <source>Expression cannot be converted into an expression tree.</source>
        <target state="translated">식은 식 트리로 변환할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CannotLiftStructureMeQuery">
        <source>Instance members and 'Me' cannot be used within query expressions in structures.</source>
        <target state="translated">인스턴스 멤버와 'Me'는 구조체의 쿼리 식에 사용할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InferringNonArrayType1">
        <source>Variable cannot be initialized with non-array type '{0}'.</source>
        <target state="translated">배열이 아닌 형식 '{0}'을(를) 사용하여 변수를 초기화할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ByRefParamInExpressionTree">
        <source>References to 'ByRef' parameters cannot be converted to an expression tree.</source>
        <target state="translated">ByRef' 매개 변수에 대한 참조는 식 트리로 변환할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DuplicateAnonTypeMemberName1">
        <source>Anonymous type member or property '{0}' is already declared.</source>
        <target state="translated">익명 형식 멤버 또는 속성 '{0}'이(가) 이미 선언되어 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadAnonymousTypeForExprTree">
        <source>Cannot convert anonymous type to an expression tree because a property of the type is used to initialize another property.</source>
        <target state="translated">익명 형식의 속성이 다른 속성을 초기화하는 데 사용되므로 익명 형식을 식 트리로 변환할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CannotLiftAnonymousType1">
        <source>Anonymous type property '{0}' cannot be used in the definition of a lambda expression within the same initialization list.</source>
        <target state="translated">동일한 초기화 목록 내의 람다 식 정의에는 익명 형식 속성 '{0}'을(를) 사용할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExtensionOnlyAllowedOnModuleSubOrFunction">
        <source>'Extension' attribute can be applied only to 'Module', 'Sub', or 'Function' declarations.</source>
        <target state="translated">'Extension' 특성은 'Module', 'Sub' 또는 'Function' 선언에만 적용할 수 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExtensionMethodNotInModule">
        <source>Extension methods can be defined only in modules.</source>
        <target state="translated">확장 메서드는 모듈에만 정의할 수 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExtensionMethodNoParams">
        <source>Extension methods must declare at least one parameter. The first parameter specifies which type to extend.</source>
        <target state="translated">확장 메서드는 하나 이상의 매개 변수를 선언해야 합니다. 첫 번째 매개 변수는 확장할 형식을 지정합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExtensionMethodOptionalFirstArg">
        <source>'Optional' cannot be applied to the first parameter of an extension method. The first parameter specifies which type to extend.</source>
        <target state="translated">'Optional'은 확장 메서드의 첫 번째 매개 변수에 적용할 수 없습니다. 첫 번째 매개 변수는 확장할 형식을 지정합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExtensionMethodParamArrayFirstArg">
        <source>'ParamArray' cannot be applied to the first parameter of an extension method. The first parameter specifies which type to extend.</source>
        <target state="translated">'ParamArray'는 확장 메서드의 첫 번째 매개 변수에 적용할 수 없습니다. 첫 번째 매개 변수는 확장할 형식을 지정합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AnonymousTypeFieldNameInference">
        <source>Anonymous type member name can be inferred only from a simple or qualified name with no arguments.</source>
        <target state="translated">익명 형식 멤버 이름은 인수가 없는 단순한 이름 또는 정규화된 이름에서만 유추할 수 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NameNotMemberOfAnonymousType2">
        <source>'{0}' is not a member of '{1}'; it does not exist in the current context.</source>
        <target state="translated">'{0}'은(는) '{1}'의 멤버가 아닙니다. 현재 컨텍스트에 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExtensionAttributeInvalid">
        <source>The custom-designed version of 'System.Runtime.CompilerServices.ExtensionAttribute' found by the compiler is not valid. Its attribute usage flags must be set to allow assemblies, classes, and methods.</source>
        <target state="translated">컴파일러에서 검색한 'System.Runtime.CompilerServices.ExtensionAttribute'의 사용자 지정 디자인 버전이 잘못되었습니다. 해당 특성 사용 플래그가 어셈블리, 클래스 및 메서드를 허용하도록 설정되어야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AnonymousTypePropertyOutOfOrder1">
        <source>Anonymous type member property '{0}' cannot be used to infer the type of another member property because the type of '{0}' is not yet established.</source>
        <target state="translated">'{0}' 형식이 아직 설정되지 않아 다른 멤버 속성의 형식을 유추하는 데 익명 형식 멤버 속성 '{0}'을(를) 사용할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AnonymousTypeDisallowsTypeChar">
        <source>Type characters cannot be used in anonymous type declarations.</source>
        <target state="translated">형식 문자는 익명 형식 선언에 사용할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_TupleLiteralDisallowsTypeChar">
        <source>Type characters cannot be used in tuple literals.</source>
        <target state="translated">형식 문자는 튜플 리터럴에 사용할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NewWithTupleTypeSyntax">
        <source>'New' cannot be used with tuple type. Use a tuple literal expression instead.</source>
        <target state="translated">'New'는 튜플 형식과 함께 사용할 수 없습니다. 대신 튜플 리터럴 식을 사용하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PredefinedValueTupleTypeMustBeStruct">
        <source>Predefined type '{0}' must be a structure.</source>
        <target state="translated">미리 정의된 형식 '{0}'은(는) 구조체여야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExtensionMethodUncallable1">
        <source>Extension method '{0}' has type constraints that can never be satisfied.</source>
        <target state="translated">확장 메서드 '{0}'에 충족될 수 없는 형식 제약 조건이 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExtensionMethodOverloadCandidate3">
        <source>
    Extension method '{0}' defined in '{1}': {2}</source>
        <target state="translated">
    '{1}'에서 '{0}' 확장 메서드가 정의되었습니다({2}).</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DelegateBindingMismatch">
        <source>Method does not have a signature compatible with the delegate.</source>
        <target state="translated">메서드에 대리자와 호환되는 시그니처가 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DelegateBindingTypeInferenceFails">
        <source>Type arguments could not be inferred from the delegate.</source>
        <target state="translated">대리자에서 형식 인수를 유추할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_TooManyArgs">
        <source>Too many arguments.</source>
        <target state="translated">인수가 너무 많습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NamedArgAlsoOmitted1">
        <source>Parameter '{0}' already has a matching omitted argument.</source>
        <target state="translated">'{0}' 매개 변수에 일치하는 생략된 인수가 이미 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NamedArgUsedTwice1">
        <source>Parameter '{0}' already has a matching argument.</source>
        <target state="translated">'{0}' 매개 변수에 일치하는 인수가 이미 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NamedParamNotFound1">
        <source>'{0}' is not a method parameter.</source>
        <target state="translated">'{0}'은(는) 메서드 매개 변수가 아닙니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_OmittedArgument1">
        <source>Argument not specified for parameter '{0}'.</source>
        <target state="translated">'{0}' 매개 변수에는 인수가 지정되어 있지 않습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_UnboundTypeParam1">
        <source>Type parameter '{0}' cannot be inferred.</source>
        <target state="translated">형식 매개 변수 '{0}'을(를) 유추할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExtensionMethodOverloadCandidate2">
        <source>
    Extension method '{0}' defined in '{1}'.</source>
        <target state="translated">
    '{1}'에서 '{0}' 확장 메서드가 정의되었습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AnonymousTypeNeedField">
        <source>Anonymous type must contain at least one member.</source>
        <target state="translated">익명 형식에는 하나 이상의 멤버가 있어야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AnonymousTypeNameWithoutPeriod">
        <source>Anonymous type member name must be preceded by a period.</source>
        <target state="translated">익명 형식 멤버 이름은 마침표 뒤에 와야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AnonymousTypeExpectedIdentifier">
        <source>Identifier expected, preceded with a period.</source>
        <target state="translated">마침표가 앞에 오는 식별자가 필요합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_TooManyArgs2">
        <source>Too many arguments to extension method '{0}' defined in '{1}'.</source>
        <target state="translated">'{1}'에 정의된 확장 메서드 '{0}'의 인수가 너무 많습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NamedArgAlsoOmitted3">
        <source>Parameter '{0}' in extension method '{1}' defined in '{2}' already has a matching omitted argument.</source>
        <target state="translated">'{2}'에 정의된 확장 메서드 '{1}'의 '{0}' 매개 변수에는 일치하는 생략된 인수가 이미 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NamedArgUsedTwice3">
        <source>Parameter '{0}' of extension method '{1}' defined in '{2}' already has a matching argument.</source>
        <target state="translated">'{2}'에 정의된 확장 메서드 '{1}'의 '{0}' 매개 변수에는 일치하는 인수가 이미 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NamedParamNotFound3">
        <source>'{0}' is not a parameter of extension method '{1}' defined in '{2}'.</source>
        <target state="translated">'{0}'은(는) '{2}'에 정의된 확장 메서드 '{1}'의 매개 변수가 아닙니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_OmittedArgument3">
        <source>Argument not specified for parameter '{0}' of extension method '{1}' defined in '{2}'.</source>
        <target state="translated">'{2}'에 정의된 '{1}' 확장 메서드의 '{0}' 매개 변수에는 인수가 지정되어 있지 않습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_UnboundTypeParam3">
        <source>Type parameter '{0}' for extension method '{1}' defined in '{2}' cannot be inferred.</source>
        <target state="translated">'{2}'에 정의된 확장 메서드 '{1}'의 형식 매개 변수 '{0}'을(를) 유추할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_TooFewGenericArguments2">
        <source>Too few type arguments to extension method '{0}' defined in '{1}'.</source>
        <target state="translated">'{1}'에 정의된 확장 메서드 '{0}'의 인수가 너무 적습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_TooManyGenericArguments2">
        <source>Too many type arguments to extension method '{0}' defined in '{1}'.</source>
        <target state="translated">'{1}'에 정의된 확장 메서드 '{0}'의 형식 인수가 너무 많습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExpectedInOrEq">
        <source>'In' or '=' expected.</source>
        <target state="translated">'In' 또는 '='가 필요합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExpectedQueryableSource">
        <source>Expression of type '{0}' is not queryable. Make sure you are not missing an assembly reference and/or namespace import for the LINQ provider.</source>
        <target state="translated">'{0}' 형식의 식은 쿼리할 수 없습니다. LINQ 공급자에 대한 네임스페이스 가져오기 및/또는 어셈블리 참조가 있는지 확인하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_QueryOperatorNotFound">
        <source>Definition of method '{0}' is not accessible in this context.</source>
        <target state="translated">이 컨텍스트에서는 '{0}' 메서드의 정의에 액세스할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CannotUseOnErrorGotoWithClosure">
        <source>Method cannot contain both a '{0}' statement and a definition of a variable that is used in a lambda or query expression.</source>
        <target state="translated">메서드는 '{0}' 문과 람다 또는 쿼리 식에 사용되는 변수 정의를 모두 포함할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CannotGotoNonScopeBlocksWithClosure">
        <source>'{0}{1}' is not valid because '{2}' is inside a scope that defines a variable that is used in a lambda or query expression.</source>
        <target state="translated">'{2}'이(가) 람다 또는 쿼리 식에 사용되는 변수를 정의하는 범위 안에 있으므로 '{0}{1}'이(가) 유효하지 않습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CannotLiftRestrictedTypeQuery">
        <source>Instance of restricted type '{0}' cannot be used in a query expression.</source>
        <target state="translated">제한된 '{0}' 형식의 인스턴스는 쿼리 식에 사용할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_QueryAnonymousTypeFieldNameInference">
        <source>Range variable name can be inferred only from a simple or qualified name with no arguments.</source>
        <target state="translated">범위 변수 이름은 인수가 없는 단순한 이름 또는 정규화된 이름에서만 유추할 수 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_QueryDuplicateAnonTypeMemberName1">
        <source>Range variable '{0}' is already declared.</source>
        <target state="translated">'{0}' 범위 변수가 이미 선언되었습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_QueryAnonymousTypeDisallowsTypeChar">
        <source>Type characters cannot be used in range variable declarations.</source>
        <target state="translated">형식 문자는 범위 변수 선언에 사용할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ReadOnlyInClosure">
        <source>'ReadOnly' variable cannot be the target of an assignment in a lambda expression inside a constructor.</source>
        <target state="translated">'ReadOnly' 변수는 생성자 내부의 람다 식에서 할당 대상일 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExprTreeNoMultiDimArrayCreation">
        <source>Multi-dimensional array cannot be converted to an expression tree.</source>
        <target state="translated">다차원 배열은 식 트리로 변환할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExprTreeNoLateBind">
        <source>Late binding operations cannot be converted to an expression tree.</source>
        <target state="translated">런타임 바인딩 작업은 식 트리로 변환할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExpectedBy">
        <source>'By' expected.</source>
        <target state="translated">'By'가 필요합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_QueryInvalidControlVariableName1">
        <source>Range variable name cannot match the name of a member of the 'Object' class.</source>
        <target state="translated">범위 변수 이름은 'Object' 클래스의 멤버 이름과 일치할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExpectedIn">
        <source>'In' expected.</source>
        <target state="translated">'In'이 필요합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_QueryNameNotDeclared">
        <source>Name '{0}' is either not declared or not in the current scope.</source>
        <target state="translated">'{0}' 이름이 선언되지 않았거나 현재 범위에 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NestedFunctionArgumentNarrowing3">
        <source>Return type of nested function matching parameter '{0}' narrows from '{1}' to '{2}'.</source>
        <target state="translated">'{0}' 매개 변수와 일치하는 중첩된 함수의 반환 형식이 '{1}'에서 '{2}'(으)로 축소 변환됩니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AnonTypeFieldXMLNameInference">
        <source>Anonymous type member name cannot be inferred from an XML identifier that is not a valid Visual Basic identifier.</source>
        <target state="translated">익명 형식 멤버 이름은 올바른 Visual Basic 식별자가 아닌 XML 식별자에서 유추할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_QueryAnonTypeFieldXMLNameInference">
        <source>Range variable name cannot be inferred from an XML identifier that is not a valid Visual Basic identifier.</source>
        <target state="translated">범위 변수 이름은 올바른 Visual Basic 식별자가 아닌 XML 식별자에서 유추할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExpectedInto">
        <source>'Into' expected.</source>
        <target state="translated">'Into'가 필요합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_TypeCharOnAggregation">
        <source>Aggregate function name cannot be used with a type character.</source>
        <target state="translated">집계 함수 이름에는 형식 문자를 사용할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExpectedOn">
        <source>'On' expected.</source>
        <target state="translated">'On'이 필요합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExpectedEquals">
        <source>'Equals' expected.</source>
        <target state="translated">'Equals'가 필요합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExpectedAnd">
        <source>'And' expected.</source>
        <target state="translated">'And'가 필요합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_EqualsTypeMismatch">
        <source>'Equals' cannot compare a value of type '{0}' with a value of type '{1}'.</source>
        <target state="translated">'Equals'에서 '{0}' 형식의 값을 '{1}' 형식의 값과 비교할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_EqualsOperandIsBad">
        <source>You must reference at least one range variable on both sides of the 'Equals' operator. Range variable(s) {0} must appear on one side of the 'Equals' operator, and range variable(s) {1} must appear on the other.</source>
        <target state="translated">Equals' 연산자의 양쪽에서 범위 변수를 하나 이상 참조해야 합니다. {0} 범위 변수는 'Equals' 연산자의 한쪽에 표시되어야 하며 {1} 범위 변수는 다른 쪽에 표시되어야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_LambdaNotDelegate1">
        <source>Lambda expression cannot be converted to '{0}' because '{0}' is not a delegate type.</source>
        <target state="translated">'{0}'이(가) 대리자 형식이 아니므로 람다 식을 '{0}'(으)로 변환할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_LambdaNotCreatableDelegate1">
        <source>Lambda expression cannot be converted to '{0}' because type '{0}' is declared 'MustInherit' and cannot be created.</source>
        <target state="translated">'{0}' 형식이 'MustInherit'으로 선언되어 있어 만들 수 없으므로 람다 식을 '{0}'(으)로 변환할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CannotInferNullableForVariable1">
        <source>A nullable type cannot be inferred for variable '{0}'.</source>
        <target state="translated">'{0}' 변수에 대해 null 허용 형식을 유추할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NullableTypeInferenceNotSupported">
        <source>Nullable type inference is not supported in this context.</source>
        <target state="translated">이 컨텍스트에서는 nullable 형식을 유추할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExpectedJoin">
        <source>'Join' expected.</source>
        <target state="translated">'Join'이 필요합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NullableParameterMustSpecifyType">
        <source>Nullable parameters must specify a type.</source>
        <target state="translated">nullable 매개 변수에 형식을 지정해야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_IterationVariableShadowLocal2">
        <source>Range variable '{0}' hides a variable in an enclosing block, a previously defined range variable, or an implicitly declared variable in a query expression.</source>
        <target state="translated">'{0}' 범위 변수가 바깥쪽 블록의 변수, 이전에 정의한 범위 변수 또는 쿼리 식에 암시적으로 선언한 변수를 숨깁니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_LambdasCannotHaveAttributes">
        <source>Attributes cannot be applied to parameters of lambda expressions.</source>
        <target state="translated">람다 식의 매개 변수에는 특성을 적용할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_LambdaInSelectCaseExpr">
        <source>Lambda expressions are not valid in the first expression of a 'Select Case' statement.</source>
        <target state="translated">람다 식은 'Select Case' 문의 첫 번째 식에 사용할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AddressOfInSelectCaseExpr">
        <source>'AddressOf' expressions are not valid in the first expression of a 'Select Case' statement.</source>
        <target state="translated">'Select Case' 문의 첫 번째 식에서는 'AddressOf' 식을 사용할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NullableCharNotSupported">
        <source>The '?' character cannot be used here.</source>
        <target state="translated">?' 문자는 여기에서 사용할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CannotLiftStructureMeLambda">
        <source>Instance members and 'Me' cannot be used within a lambda expression in structures.</source>
        <target state="translated">인스턴스 멤버와 'Me'는 구조체의 람다 식에 사용할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CannotLiftByRefParamLambda1">
        <source>'ByRef' parameter '{0}' cannot be used in a lambda expression.</source>
        <target state="translated">'람다 식에는 'ByRef' 매개 변수 '{0}'을(를) 사용할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CannotLiftRestrictedTypeLambda">
        <source>Instance of restricted type '{0}' cannot be used in a lambda expression.</source>
        <target state="translated">제한된 '{0}' 형식의 인스턴스는 람다 식에 사용할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_LambdaParamShadowLocal1">
        <source>Lambda parameter '{0}' hides a variable in an enclosing block, a previously defined range variable, or an implicitly declared variable in a query expression.</source>
        <target state="translated">람다 매개 변수 '{0}'이(가) 바깥쪽 블록의 변수, 이전에 정의한 범위 변수 또는 쿼리 식에 암시적으로 선언한 변수를 숨깁니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_StrictDisallowImplicitObjectLambda">
        <source>Option Strict On requires each lambda expression parameter to be declared with an 'As' clause if its type cannot be inferred.</source>
        <target state="translated">Option Strict On에서는 각 람다 식 매개 변수의 형식을 유추할 수 없을 경우 해당 매개 변수를 'As' 절로 선언해야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CantSpecifyParamsOnLambdaParamNoType">
        <source>Array modifiers cannot be specified on lambda expression parameter name. They must be specified on its type.</source>
        <target state="translated">람다 식 매개 변수 이름에는 배열 한정자를 지정할 수 없습니다. 배열 한정자는 해당 형식에 지정해야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_TypeInferenceFailure1">
        <source>Data type(s) of the type parameter(s) cannot be inferred from these arguments. Specifying the data type(s) explicitly might correct this error.</source>
        <target state="translated">이 인수에서 형식 매개 변수의 데이터 형식을 유추할 수 없습니다. 데이터 형식을 명시적으로 지정하면 이 오류를 해결할 수 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_TypeInferenceFailure2">
        <source>Data type(s) of the type parameter(s) in method '{0}' cannot be inferred from these arguments. Specifying the data type(s) explicitly might correct this error.</source>
        <target state="translated">이 인수에서 '{0}' 메서드에 있는 형식 매개 변수의 데이터 형식을 유추할 수 없습니다. 데이터 형식을 명시적으로 지정하면 이 오류를 해결할 수 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_TypeInferenceFailure3">
        <source>Data type(s) of the type parameter(s) in extension method '{0}' defined in '{1}' cannot be inferred from these arguments. Specifying the data type(s) explicitly might correct this error.</source>
        <target state="translated">이 인수에서 '{1}'에 정의된 확장 메서드 '{0}'의 형식 매개 변수에 대한 데이터 형식을 유추할 수 없습니다. 데이터 형식을 명시적으로 지정하면 이 오류를 해결할 수 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_TypeInferenceFailureNoExplicit1">
        <source>Data type(s) of the type parameter(s) cannot be inferred from these arguments.</source>
        <target state="translated">이 인수에서 형식 매개 변수의 데이터 형식을 유추할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_TypeInferenceFailureNoExplicit2">
        <source>Data type(s) of the type parameter(s) in method '{0}' cannot be inferred from these arguments.</source>
        <target state="translated">이 인수에서 '{0}' 메서드에 있는 형식 매개 변수의 데이터 형식을 유추할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_TypeInferenceFailureNoExplicit3">
        <source>Data type(s) of the type parameter(s) in extension method '{0}' defined in '{1}' cannot be inferred from these arguments.</source>
        <target state="translated">이 인수에서 '{1}'에 정의된 확장 메서드 '{0}'의 형식 매개 변수에 대한 데이터 형식을 유추할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_TypeInferenceFailureAmbiguous1">
        <source>Data type(s) of the type parameter(s) cannot be inferred from these arguments because more than one type is possible. Specifying the data type(s) explicitly might correct this error.</source>
        <target state="translated">두 개 이상의 형식이 가능하므로 이 인수에서 형식 매개 변수의 데이터 형식을 유추할 수 없습니다. 데이터 형식을 명시적으로 지정하면 이 오류를 해결할 수 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_TypeInferenceFailureAmbiguous2">
        <source>Data type(s) of the type parameter(s) in method '{0}' cannot be inferred from these arguments because more than one type is possible. Specifying the data type(s) explicitly might correct this error.</source>
        <target state="translated">두 개 이상의 형식이 가능하므로 이 인수에서 '{0}' 메서드에 있는 형식 매개 변수의 데이터 형식을 유추할 수 없습니다. 데이터 형식을 명시적으로 지정하면 이 오류를 해결할 수 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_TypeInferenceFailureAmbiguous3">
        <source>Data type(s) of the type parameter(s) in extension method '{0}' defined in '{1}' cannot be inferred from these arguments because more than one type is possible. Specifying the data type(s) explicitly might correct this error.</source>
        <target state="translated">두 개 이상의 형식이 가능하므로 이 인수에서 '{1}'에 정의된 확장 메서드 '{0}'에 있는 형식 매개 변수의 데이터 형식을 유추할 수 없습니다. 데이터 형식을 명시적으로 지정하면 이 오류를 해결할 수 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_TypeInferenceFailureNoExplicitAmbiguous1">
        <source>Data type(s) of the type parameter(s) cannot be inferred from these arguments because more than one type is possible.</source>
        <target state="translated">두 개 이상의 형식이 가능하므로 이 인수에서 형식 매개 변수의 데이터 형식을 유추할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_TypeInferenceFailureNoExplicitAmbiguous2">
        <source>Data type(s) of the type parameter(s) in method '{0}' cannot be inferred from these arguments because more than one type is possible.</source>
        <target state="translated">두 개 이상의 형식이 가능하므로 이 인수에서 '{0}' 메서드에 있는 형식 매개 변수의 데이터 형식을 유추할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_TypeInferenceFailureNoExplicitAmbiguous3">
        <source>Data type(s) of the type parameter(s) in extension method '{0}' defined in '{1}' cannot be inferred from these arguments because more than one type is possible.</source>
        <target state="translated">두 개 이상의 형식이 가능하므로 이 인수에서 '{1}'에 정의된 확장 메서드 '{0}'에 있는 형식 매개 변수의 데이터 형식을 유추할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_TypeInferenceFailureNoBest1">
        <source>Data type(s) of the type parameter(s) cannot be inferred from these arguments because they do not convert to the same type. Specifying the data type(s) explicitly might correct this error.</source>
        <target state="translated">동일한 형식으로 변환할 수 없으므로 이 인수에서 형식 매개 변수의 데이터 형식을 유추할 수 없습니다. 데이터 형식을 명시적으로 지정하면 이 오류를 해결할 수 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_TypeInferenceFailureNoBest2">
        <source>Data type(s) of the type parameter(s) in method '{0}' cannot be inferred from these arguments because they do not convert to the same type. Specifying the data type(s) explicitly might correct this error.</source>
        <target state="translated">동일한 형식으로 변환할 수 없으므로 이 인수에서 '{0}' 메서드에 있는 형식 매개 변수의 데이터 형식을 유추할 수 없습니다. 데이터 형식을 명시적으로 지정하면 이 오류를 해결할 수 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_TypeInferenceFailureNoBest3">
        <source>Data type(s) of the type parameter(s) in extension method '{0}' defined in '{1}' cannot be inferred from these arguments because they do not convert to the same type. Specifying the data type(s) explicitly might correct this error.</source>
        <target state="translated">동일한 형식으로 변환할 수 없으므로 이 인수에서 '{1}'에 정의된 확장 메서드 '{0}'의 형식 매개 변수에 대한 데이터 형식을 유추할 수 없습니다. 데이터 형식을 명시적으로 지정하면 이 오류를 해결할 수 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_TypeInferenceFailureNoExplicitNoBest1">
        <source>Data type(s) of the type parameter(s) cannot be inferred from these arguments because they do not convert to the same type.</source>
        <target state="translated">동일한 형식으로 변환할 수 없으므로 이 인수에서 형식 매개 변수의 데이터 형식을 유추할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_TypeInferenceFailureNoExplicitNoBest2">
        <source>Data type(s) of the type parameter(s) in method '{0}' cannot be inferred from these arguments because they do not convert to the same type.</source>
        <target state="translated">동일한 형식으로 변환할 수 없으므로 이 인수에서 '{0}' 메서드의 형식 매개 변수에 대한 데이터 형식을 유추할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_TypeInferenceFailureNoExplicitNoBest3">
        <source>Data type(s) of the type parameter(s) in extension method '{0}' defined in '{1}' cannot be inferred from these arguments because they do not convert to the same type.</source>
        <target state="translated">동일한 형식으로 변환할 수 없으므로 이 인수에서 '{1}'에 정의된 확장 메서드 '{0}'의 형식 매개 변수에 대한 데이터 형식을 유추할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DelegateBindingMismatchStrictOff2">
        <source>Option Strict On does not allow narrowing in implicit type conversions between method '{0}' and delegate '{1}'.</source>
        <target state="translated">Option Strict On에서는 '{0}' 메서드와 '{1}' 대리자 사이의 암시적 형식 변환에 축소 변환을 사용할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InaccessibleReturnTypeOfMember2">
        <source>'{0}' is not accessible in this context because the return type is not accessible.</source>
        <target state="translated">'반환 형식에 액세스할 수 없으므로 이 컨텍스트에서 '{0}'에 액세스할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExpectedIdentifierOrGroup">
        <source>'Group' or an identifier expected.</source>
        <target state="translated">'Group' 또는 식별자가 필요합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_UnexpectedGroup">
        <source>'Group' not allowed in this context; identifier expected.</source>
        <target state="translated">'이 컨텍스트에서는 'Group'을 사용할 수 없습니다. 식별자가 필요합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DelegateBindingMismatchStrictOff3">
        <source>Option Strict On does not allow narrowing in implicit type conversions between extension method '{0}' defined in '{2}' and delegate '{1}'.</source>
        <target state="translated">Option Strict On에서는 '{2}'에 정의된 확장 메서드 '{0}'과(와) '{1}' 대리자 사이의 암시적 형식 변환에 축소 변환을 사용할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DelegateBindingIncompatible3">
        <source>Extension Method '{0}' defined in '{2}' does not have a signature compatible with delegate '{1}'.</source>
        <target state="translated">'{2}'에 정의된 '{0}' 확장 메서드에 '{1}' 대리자와 호환되는 시그니처가 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ArgumentNarrowing2">
        <source>Argument matching parameter '{0}' narrows to '{1}'.</source>
        <target state="translated">'{0}' 매개 변수와 일치하는 인수는 '{1}'(으)로 한정됩니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_OverloadCandidate1">
        <source>
    {0}</source>
        <target state="translated">
    {0}</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AutoPropertyInitializedInStructure">
        <source>Auto-implemented Properties contained in Structures cannot have initializers unless they are marked 'Shared'.</source>
        <target state="translated">구조체에 포함된 자동 구현 속성은 'Shared'로 표시되지 않는 한 이니셜라이저를 사용할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_TypeDisallowsElements">
        <source>XML elements cannot be selected from type '{0}'.</source>
        <target state="translated">XML 요소는 '{0}' 형식에서 선택할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_TypeDisallowsAttributes">
        <source>XML attributes cannot be selected from type '{0}'.</source>
        <target state="translated">XML 특성은 '{0}' 형식에서 선택할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_TypeDisallowsDescendants">
        <source>XML descendant elements cannot be selected from type '{0}'.</source>
        <target state="translated">XML 하위 요소는 '{0}' 형식에서 선택할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_TypeOrMemberNotGeneric2">
        <source>Extension method '{0}' defined in '{1}' is not generic (or has no free type parameters) and so cannot have type arguments.</source>
        <target state="translated">'{1}'에 정의된 확장 메서드 '{0}'은(는) 제네릭이 아니거나 형식이 자유로운 매개 변수를 포함하지 않으므로 형식 인수를 사용할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExtensionMethodCannotBeLateBound">
        <source>Late-bound extension methods are not supported.</source>
        <target state="translated">런타임에 바인딩된 확장 메서드는 지원되지 않습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_TypeInferenceArrayRankMismatch1">
        <source>Cannot infer a data type for '{0}' because the array dimensions do not match.</source>
        <target state="translated">배열 차원이 일치하지 않으므로 '{0}'의 데이터 형식을 유추할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_QueryStrictDisallowImplicitObject">
        <source>Type of the range variable cannot be inferred, and late binding is not allowed with Option Strict on. Use an 'As' clause to specify the type.</source>
        <target state="translated">범위 변수의 형태를 유추할 수 없고 Option Strict On에서는 런타임에 바인딩을 사용할 수 없습니다. 'As' 절을 사용하여 형식을 지정하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CannotEmbedInterfaceWithGeneric">
        <source>Type '{0}' cannot be embedded because it has generic argument. Consider disabling the embedding of interop types.</source>
        <target state="translated">'{0}' 형식에 제네릭 인수가 있기 때문에 이 형식을 포함할 수 없습니다. interop 형식을 포함하지 않도록 설정하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CannotUseGenericTypeAcrossAssemblyBoundaries">
        <source>Type '{0}' cannot be used across assembly boundaries because it has a generic type argument that is an embedded interop type.</source>
        <target state="translated">'{0}' 형식에 포함된 interop 형식인 제네릭 형식 인수가 있기 때문에 이 형식을 다른 어셈블리에서 사용할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UseOfObsoleteSymbol2">
        <source>'{0}' is obsolete: '{1}'.</source>
        <target state="translated">'{0}'은(는) 사용되지 않습니다('{1}').</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UseOfObsoleteSymbol2_Title">
        <source>Type or member is obsolete</source>
        <target state="translated">형식 또는 멤버는 사용되지 않습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_MustOverloadBase4">
        <source>{0} '{1}' shadows an overloadable member declared in the base {2} '{3}'.  If you want to overload the base method, this method must be declared 'Overloads'.</source>
        <target state="translated">{0} '{1}'은(는) 기본 {2} '{3}'에 선언된 오버로드 가능한 멤버를 숨깁니다. 기본 메서드를 오버로드하려면 이 메서드를 'Overloads'로 선언해야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_MustOverloadBase4_Title">
        <source>Member shadows an overloadable member declared in the base type</source>
        <target state="translated">멤버가 기본 형식에 선언된 오버로드 가능 멤버를 섀도 처리함</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_OverrideType5">
        <source>{0} '{1}' conflicts with {2} '{1}' in the base {3} '{4}' and should be declared 'Shadows'.</source>
        <target state="translated">{0} '{1}'은(는) 기본 {3} '{4}'의 {2} '{1}'과(와) 충돌하므로 'Shadows'로 선언해야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_OverrideType5_Title">
        <source>Member conflicts with member in the base type and should be declared 'Shadows'</source>
        <target state="translated">멤버가 기본 형식의 멤버와 충돌하며 'Shadows'로 선언되어야 함</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_MustOverride2">
        <source>{0} '{1}' shadows an overridable method in the base {2} '{3}'. To override the base method, this method must be declared 'Overrides'.</source>
        <target state="translated">{0} '{1}'은(는) 기본 {2} '{3}'의 재정의 가능한 메서드를 숨깁니다. 기본 메서드를 재정의하려면 이 메서드를 'Overrides'로 선언해야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_MustOverride2_Title">
        <source>Member shadows an overridable method in the base type</source>
        <target state="translated">멤버가 기본 형식의 오버로드 가능 메서드를 섀도 처리함</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_DefaultnessShadowed4">
        <source>Default property '{0}' conflicts with the default property '{1}' in the base {2} '{3}'. '{0}' will be the default property. '{0}' should be declared 'Shadows'.</source>
        <target state="translated">기본 {2} '{3}'에서 '{0}' 기본 속성이 '{1}' 기본 속성과 충돌합니다. '{0}'이(가) 기본 속성이 됩니다. '{0}'은(는) 'Shadows'로 선언해야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_DefaultnessShadowed4_Title">
        <source>Default property conflicts with the default property in the base type</source>
        <target state="translated">기본 속성이 기본 형식의 기본 속성과 충돌함</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UseOfObsoleteSymbolNoMessage1">
        <source>'{0}' is obsolete.</source>
        <target state="translated">'{0}'은(는) 사용되지 않습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UseOfObsoleteSymbolNoMessage1_Title">
        <source>Type or member is obsolete</source>
        <target state="translated">형식 또는 멤버는 사용되지 않습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_AssemblyGeneration0">
        <source>Possible problem detected while building assembly: {0}</source>
        <target state="translated">어셈블리를 빌드하는 동안 발생 가능한 문제가 발견되었습니다({0}).</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_AssemblyGeneration0_Title">
        <source>Possible problem detected while building assembly</source>
        <target state="translated">어셈블리를 빌드하는 동안 발생 가능한 문제가 발견되었습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_AssemblyGeneration1">
        <source>Possible problem detected while building assembly '{0}': {1}</source>
        <target state="translated">'{0}' 어셈블리를 빌드하는 동안 발생 가능한 문제가 발견되었습니다({1}).</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_AssemblyGeneration1_Title">
        <source>Possible problem detected while building assembly</source>
        <target state="translated">어셈블리를 빌드하는 동안 발생 가능한 문제가 발견되었습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_ComClassNoMembers1">
        <source>'Microsoft.VisualBasic.ComClassAttribute' is specified for class '{0}' but '{0}' has no public members that can be exposed to COM; therefore, no COM interfaces are generated.</source>
        <target state="translated">'{0}' 클래스에 'Microsoft.VisualBasic.ComClassAttribute'가 지정되어 있지만 COM에 노출할 수 있는 public 멤버가 '{0}'에 없으므로 COM 인터페이스가 생성되지 않았습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_ComClassNoMembers1_Title">
        <source>'Microsoft.VisualBasic.ComClassAttribute' is specified for class but class has no public members that can be exposed to COM</source>
        <target state="translated">'Microsoft.VisualBasic.ComClassAttribute'가 클래스에 지정되었지만 COM에 노출할 수 있는 공용 멤버가 클래스에 없음</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_SynthMemberShadowsMember5">
        <source>{0} '{1}' implicitly declares '{2}', which conflicts with a member in the base {3} '{4}', and so the {0} should be declared 'Shadows'.</source>
        <target state="translated">{0} '{1}'은(는) 기본 {3} '{4}'의 멤버와 충돌하는 '{2}'을(를) 암시적으로 선언하므로 {0}을(를) 'Shadows'로 선언해야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_SynthMemberShadowsMember5_Title">
        <source>Property or event implicitly declares type or member that conflicts with a member in the base type</source>
        <target state="translated">속성 또는 이벤트가 기본 형식의 멤버와 충돌하는 형식 또는 멤버를 암시적으로 선언함</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_MemberShadowsSynthMember6">
        <source>{0} '{1}' conflicts with a member implicitly declared for {2} '{3}' in the base {4} '{5}' and should be declared 'Shadows'.</source>
        <target state="translated">{0} '{1}'은(는) 기본 {4} '{5}'의 {2} '{3}'에 대해 암시적으로 선언된 멤버와 충돌하므로 'Shadows'로 선언해야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_MemberShadowsSynthMember6_Title">
        <source>Member conflicts with a member implicitly declared for property or event in the base type</source>
        <target state="translated">멤버가 기본 형식에서 속성 또는 이벤트에 대해 암시적으로 선언된 멤버와 충돌함</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_SynthMemberShadowsSynthMember7">
        <source>{0} '{1}' implicitly declares '{2}', which conflicts with a member implicitly declared for {3} '{4}' in the base {5} '{6}'. {0} should be declared 'Shadows'.</source>
        <target state="translated">{0} '{1}'은(는) 기본 {5} '{6}'의 {3} '{4}'에 대해 암시적으로 선언된 멤버와 충돌하는 '{2}'을(를) 암시적으로 선언하므로 {0}을(를) 'Shadows'로 선언해야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_SynthMemberShadowsSynthMember7_Title">
        <source>Property or event implicitly declares member, which conflicts with a member implicitly declared for property or event in the base type</source>
        <target state="translated">속성 또는 이벤트가 기본 형식에서 속성 또는 이벤트에 대해 암시적으로 선언된 멤버와 충돌하는 멤버를 암시적으로 선언함</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UseOfObsoletePropertyAccessor3">
        <source>'{0}' accessor of '{1}' is obsolete: '{2}'.</source>
        <target state="translated">'{1}'의 '{0}' 접근자는 사용되지 않습니다('{2}').</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UseOfObsoletePropertyAccessor3_Title">
        <source>Property accessor is obsolete</source>
        <target state="translated">속성 접근자가 사용되지 않음</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UseOfObsoletePropertyAccessor2">
        <source>'{0}' accessor of '{1}' is obsolete.</source>
        <target state="translated">'{1}'의 '{0}' 접근자는 사용되지 않습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UseOfObsoletePropertyAccessor2_Title">
        <source>Property accessor is obsolete</source>
        <target state="translated">속성 접근자가 사용되지 않음</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_FieldNotCLSCompliant1">
        <source>Type of member '{0}' is not CLS-compliant.</source>
        <target state="translated">'{0}' 멤버의 형식이 CLS 규격이 아닙니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_FieldNotCLSCompliant1_Title">
        <source>Type of member is not CLS-compliant</source>
        <target state="translated">멤버 형식이 CLS 규격이 아님</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_BaseClassNotCLSCompliant2">
        <source>'{0}' is not CLS-compliant because it derives from '{1}', which is not CLS-compliant.</source>
        <target state="translated">'{0}'은(는) CLS 규격이 아닌 '{1}'에서 파생되므로 CLS 규격이 아닙니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_BaseClassNotCLSCompliant2_Title">
        <source>Type is not CLS-compliant because it derives from base type that is not CLS-compliant</source>
        <target state="translated">CLS 규격이 아닌 기본 형식에서 파생되므로 형식이 CLS 규격이 아님</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_ProcTypeNotCLSCompliant1">
        <source>Return type of function '{0}' is not CLS-compliant.</source>
        <target state="translated">'{0}' 함수의 반환 형식이 CLS 규격이 아닙니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_ProcTypeNotCLSCompliant1_Title">
        <source>Return type of function is not CLS-compliant</source>
        <target state="translated">함수의 반환 형식이 CLS 규격이 아님</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_ParamNotCLSCompliant1">
        <source>Type of parameter '{0}' is not CLS-compliant.</source>
        <target state="translated">'{0}' 매개 변수의 형식이 CLS 규격이 아닙니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_ParamNotCLSCompliant1_Title">
        <source>Type of parameter is not CLS-compliant</source>
        <target state="translated">매개 변수 형식이 CLS 규격이 아님</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_InheritedInterfaceNotCLSCompliant2">
        <source>'{0}' is not CLS-compliant because the interface '{1}' it inherits from is not CLS-compliant.</source>
        <target state="translated">'{1}' 인터페이스가 CLS 규격이 아니므로 이 인터페이스에서 상속된 '{0}'은(는) CLS 규격이 아닙니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_InheritedInterfaceNotCLSCompliant2_Title">
        <source>Type is not CLS-compliant because the interface it inherits from is not CLS-compliant</source>
        <target state="translated">상속되는 인터페이스가 CLS 규격이 아니므로 형식이 CLS 규격이 아님</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CLSMemberInNonCLSType3">
        <source>{0} '{1}' cannot be marked CLS-compliant because its containing type '{2}' is not CLS-compliant.</source>
        <target state="translated">포함하는 형식 '{2}'이(가) CLS 규격이 아니므로 {0} '{1}'을(를) CLS 규격으로 표시할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CLSMemberInNonCLSType3_Title">
        <source>Member cannot be marked CLS-compliant because its containing type is not CLS-compliant</source>
        <target state="translated">포함하는 형식이 CLS 규격이 아니므로 멤버를 CLS 규격으로 표시할 수 없음</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NameNotCLSCompliant1">
        <source>Name '{0}' is not CLS-compliant.</source>
        <target state="translated">이름 '{0}'은(는) CLS 규격이 아닙니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NameNotCLSCompliant1_Title">
        <source>Name is not CLS-compliant</source>
        <target state="translated">이름이 CLS 규격이 아님</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_EnumUnderlyingTypeNotCLS1">
        <source>Underlying type '{0}' of Enum is not CLS-compliant.</source>
        <target state="translated">열거형의 '{0}' 내부 형식이 CLS 규격이 아닙니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_EnumUnderlyingTypeNotCLS1_Title">
        <source>Underlying type of Enum is not CLS-compliant</source>
        <target state="translated">열거형의 내부 형식이 CLS 규격이 아님</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NonCLSMemberInCLSInterface1">
        <source>Non CLS-compliant '{0}' is not allowed in a CLS-compliant interface.</source>
        <target state="translated">CLS 규격 인터페이스에는 CLS 규격이 아닌 '{0}'을(를) 사용할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NonCLSMemberInCLSInterface1_Title">
        <source>Non CLS-compliant member is not allowed in a CLS-compliant interface</source>
        <target state="translated">CLS 규격이 아닌 멤버는 CLS 규격 인터페이스에 사용할 수 없음</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NonCLSMustOverrideInCLSType1">
        <source>Non CLS-compliant 'MustOverride' member is not allowed in CLS-compliant type '{0}'.</source>
        <target state="translated">CLS 규격이 아닌 'MustOverride' 멤버는 CLS 규격의 '{0}' 형식에 사용할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NonCLSMustOverrideInCLSType1_Title">
        <source>Non CLS-compliant 'MustOverride' member is not allowed in CLS-compliant type</source>
        <target state="translated">CLS 규격이 아닌 'MustOverride' 멤버는 CLS 규격 형식에 사용할 수 없음</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_ArrayOverloadsNonCLS2">
        <source>'{0}' is not CLS-compliant because it overloads '{1}' which differs from it only by array of array parameter types or by the rank of the array parameter types.</source>
        <target state="translated">'{0}'은(는) 배열 매개 변수 형식의 배열만 다르거나 배열 매개 변수 형식의 차수만 다른 '{1}'을(를) 오버로드하므로 CLS 규격이 아닙니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_ArrayOverloadsNonCLS2_Title">
        <source>Method is not CLS-compliant because it overloads method which differs from it only by array of array parameter types or by the rank of the array parameter types</source>
        <target state="translated">배열 매개 변수 형식의 배열만 다르거나 배열 매개 변수 형식의 차수만 다른 메서드를 오버로드하므로 메서드가 CLS 규격이 아님</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_RootNamespaceNotCLSCompliant1">
        <source>Root namespace '{0}' is not CLS-compliant.</source>
        <target state="translated">'{0}' 루트 네임스페이스가 CLS 규격이 아닙니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_RootNamespaceNotCLSCompliant1_Title">
        <source>Root namespace is not CLS-compliant</source>
        <target state="translated">루트 네임스페이스가 CLS 규격이 아님</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_RootNamespaceNotCLSCompliant2">
        <source>Name '{0}' in the root namespace '{1}' is not CLS-compliant.</source>
        <target state="translated">'{1}' 루트 네임스페이스의 '{0}' 이름이 CLS 규격이 아닙니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_RootNamespaceNotCLSCompliant2_Title">
        <source>Part of the root namespace is not CLS-compliant</source>
        <target state="translated">루트 네임스페이스의 일부가 CLS 규격이 아님</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_GenericConstraintNotCLSCompliant1">
        <source>Generic parameter constraint type '{0}' is not CLS-compliant.</source>
        <target state="translated">'{0}' 제네릭 매개 변수 제약 조건 형식이 CLS 규격이 아닙니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_GenericConstraintNotCLSCompliant1_Title">
        <source>Generic parameter constraint type is not CLS-compliant</source>
        <target state="translated">제네릭 매개 변수 제약 조건 형식이 CLS 규격이 아님</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_TypeNotCLSCompliant1">
        <source>Type '{0}' is not CLS-compliant.</source>
        <target state="translated">'{0}' 형식이 CLS 규격이 아닙니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_TypeNotCLSCompliant1_Title">
        <source>Type is not CLS-compliant</source>
        <target state="translated">형식이 CLS 규격이 아닙니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_OptionalValueNotCLSCompliant1">
        <source>Type of optional value for optional parameter '{0}' is not CLS-compliant.</source>
        <target state="translated">선택적 매개 변수 '{0}'에 대한 선택적 값의 형식이 CLS 규격이 아닙니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_OptionalValueNotCLSCompliant1_Title">
        <source>Type of optional value for optional parameter is not CLS-compliant</source>
        <target state="translated">선택적 매개 변수에 대한 선택적 값의 형식이 CLS 규격이 아님</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CLSAttrInvalidOnGetSet">
        <source>System.CLSCompliantAttribute cannot be applied to property 'Get' or 'Set'.</source>
        <target state="translated">System.CLSCompliantAttribute는 'Get' 또는 'Set' 속성에 적용할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CLSAttrInvalidOnGetSet_Title">
        <source>System.CLSCompliantAttribute cannot be applied to property 'Get' or 'Set'</source>
        <target state="translated">System.CLSCompliantAttribute는 'Get' 또는 'Set' 속성에 적용할 수 없음</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_TypeConflictButMerged6">
        <source>{0} '{1}' and partial {2} '{3}' conflict in {4} '{5}', but are being merged because one of them is declared partial.</source>
        <target state="translated">{0} '{1}' 및 부분 형식(Partial Type) {2} '{3}'이(가) {4} '{5}'에서 충돌하지만 이 중 하나가 partail로 선언되었으므로 병합되고 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_TypeConflictButMerged6_Title">
        <source>Type and partial type conflict, but are being merged because one of them is declared partial</source>
        <target state="translated">형식 및 부분 형식(Partial Type)이 충돌하지만 형식 중 하나가 부분으로 선언되었으므로 병합됨</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_ShadowingGenericParamWithParam1">
        <source>Type parameter '{0}' has the same name as a type parameter of an enclosing type. Enclosing type's type parameter will be shadowed.</source>
        <target state="translated">'{0}' 형식 매개 변수의 이름이 바깥쪽 형식의 형식 매개 변수 이름과 같습니다. 바깥쪽 형식의 형식 매개 변수가 숨겨집니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_ShadowingGenericParamWithParam1_Title">
        <source>Type parameter has the same name as a type parameter of an enclosing type</source>
        <target state="translated">형식 매개 변수의 이름이 바깥쪽 형식의 형식 매개 변수와 동일함</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CannotFindStandardLibrary1">
        <source>Could not find standard library '{0}'.</source>
        <target state="translated">'{0}' 표준 라이브러리를 찾을 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CannotFindStandardLibrary1_Title">
        <source>Could not find standard library</source>
        <target state="translated">표준 라이브러리를 찾을 수 없음</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_EventDelegateTypeNotCLSCompliant2">
        <source>Delegate type '{0}' of event '{1}' is not CLS-compliant.</source>
        <target state="translated">'{1}' 이벤트의 '{0}' 대리자 형식이 CLS 규격이 아닙니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_EventDelegateTypeNotCLSCompliant2_Title">
        <source>Delegate type of event is not CLS-compliant</source>
        <target state="translated">이벤트의 대리자 형식이 CLS 규격이 아님</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_DebuggerHiddenIgnoredOnProperties">
        <source>System.Diagnostics.DebuggerHiddenAttribute does not affect 'Get' or 'Set' when applied to the Property definition.  Apply the attribute directly to the 'Get' and 'Set' procedures as appropriate.</source>
        <target state="translated">System.Diagnostics.DebuggerHiddenAttribute는 속성 정의에 적용될 때 'Get' 또는 'Set'에 영향을 주지 않습니다. 특성을 'Get' 및 'Set' 프로시저에 적절히 직접 적용하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_DebuggerHiddenIgnoredOnProperties_Title">
        <source>System.Diagnostics.DebuggerHiddenAttribute does not affect 'Get' or 'Set' when applied to the Property definition</source>
        <target state="translated">System.Diagnostics.DebuggerHiddenAttribute는 속성 정의에 적용될 때 'Get' 또는 'Set'에 영향을 주지 않음</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_SelectCaseInvalidRange">
        <source>Range specified for 'Case' statement is not valid. Make sure that the lower bound is less than or equal to the upper bound.</source>
        <target state="translated">Case' 문에 지정한 범위가 잘못되었습니다. 하한이 상한보다 작거나 같은지 확인하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_SelectCaseInvalidRange_Title">
        <source>Range specified for 'Case' statement is not valid</source>
        <target state="translated">Case' 문에 지정한 범위가 잘못됨</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CLSEventMethodInNonCLSType3">
        <source>'{0}' method for event '{1}' cannot be marked CLS compliant because its containing type '{2}' is not CLS compliant.</source>
        <target state="translated">'포함하는 형식 '{2}'이(가) CLS 규격이 아니므로 '{1}' 이벤트의 '{0}' 메서드를 CLS 규격으로 표시할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_CLSEventMethodInNonCLSType3_Title">
        <source>AddHandler or RemoveHandler method for event cannot be marked CLS compliant because its containing type is not CLS compliant</source>
        <target state="translated">포함하는 형식이 CLS 규격이 아니므로 이벤트에 대한 AddHandler 또는 RemoveHandler 메서드를 CLS 규격으로 표시할 수 없음</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_ExpectedInitComponentCall2">
        <source>'{0}' in designer-generated type '{1}' should call InitializeComponent method.</source>
        <target state="translated">'디자이너에서 생성한 '{1}' 형식의 '{0}'이(가) InitializeComponent 메서드를 호출해야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_ExpectedInitComponentCall2_Title">
        <source>Constructor in designer-generated type should call InitializeComponent method</source>
        <target state="translated">디자이너에서 생성된 형식의 생성자는 InitializeComponent 메서드를 호출해야 함</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NamespaceCaseMismatch3">
        <source>Casing of namespace name '{0}' does not match casing of namespace name '{1}' in '{2}'.</source>
        <target state="translated">네임스페이스 이름 '{0}'의 대/소문자가 '{2}'의 네임스페이스 이름 '{1}'의 대/소문자와 일치하지 않습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NamespaceCaseMismatch3_Title">
        <source>Casing of namespace name does not match</source>
        <target state="translated">네임스페이스 이름의 대/소문자가 일치하지 않음</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UndefinedOrEmptyNamespaceOrClass1">
        <source>Namespace or type specified in the Imports '{0}' doesn't contain any public member or cannot be found. Make sure the namespace or the type is defined and contains at least one public member. Make sure the imported element name doesn't use any aliases.</source>
        <target state="translated">Imports '{0}'에 지정된 네임스페이스 또는 형식에 public 멤버가 없거나, 해당 네임스페이스 또는 형식을 찾을 수 없습니다. 네임스페이스 또는 형식이 정의되어 있고 public 멤버를 하나 이상 포함하는지, 그리고 가져온 요소 이름이 별칭을 사용하지 않는지 확인하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UndefinedOrEmptyNamespaceOrClass1_Title">
        <source>Namespace or type specified in Imports statement doesn't contain any public member or cannot be found</source>
        <target state="translated">Imports 문에 지정된 네임스페이스 또는 형식에 public 멤버가 없거나 해당 네임스페이스 또는 형식을 찾을 수 없음</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UndefinedOrEmptyProjectNamespaceOrClass1">
        <source>Namespace or type specified in the project-level Imports '{0}' doesn't contain any public member or cannot be found. Make sure the namespace or the type is defined and contains at least one public member. Make sure the imported element name doesn't use any aliases.</source>
        <target state="translated">프로젝트 수준의 Imports '{0}'에 지정된 네임스페이스 또는 형식에 public 멤버가 없거나 해당 네임스페이스 또는 형식을 찾을 수 없습니다. 네임스페이스 또는 형식이 정의되어 있고 하나 이상의 public 멤버를 포함하는지, 그리고 가져온 요소 이름이 별칭을 사용하지 않는지 확인하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UndefinedOrEmptyProjectNamespaceOrClass1_Title">
        <source>Namespace or type imported at project level doesn't contain any public member or cannot be found</source>
        <target state="translated">프로젝트 수준에서 가져온 네임스페이스 또는 형식에 public 멤버가 없거나 해당 네임스페이스 또는 형식을 찾을 수 없음</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_IndirectRefToLinkedAssembly2">
        <source>A reference was created to embedded interop assembly '{0}' because of an indirect reference to that assembly from assembly '{1}'. Consider changing the 'Embed Interop Types' property on either assembly.</source>
        <target state="translated">포함된 interop '{0}' 어셈블리에 대한 참조는 해당 어셈블리에 대한 '{1}' 어셈블리의 간접 참조 때문에 만들어졌습니다. 두 어셈블리 중 하나의 'Interop 형식 포함' 속성을 변경하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_IndirectRefToLinkedAssembly2_Title">
        <source>A reference was created to embedded interop assembly because of an indirect reference to that assembly</source>
        <target state="translated">포함된 interop 어셈블리에 대한 간접 참조로 인해 해당 어셈블리에 대한 참조가 만들어짐</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NoNonObsoleteConstructorOnBase3">
        <source>Class '{0}' should declare a 'Sub New' because the '{1}' in its base class '{2}' is marked obsolete.</source>
        <target state="translated">'{0}' 클래스는 기본 클래스 '{2}'의 '{1}'이(가) obsolete로 표시되어 있으므로 'Sub New'를 선언해야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NoNonObsoleteConstructorOnBase3_Title">
        <source>Class should declare a 'Sub New' because the constructor in its base class is marked obsolete</source>
        <target state="translated">기본 클래스의 생성자가 obsolete로 표시되어 있으므로 클래스에서 'Sub New'를 선언해야 함</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NoNonObsoleteConstructorOnBase4">
        <source>Class '{0}' should declare a 'Sub New' because the '{1}' in its base class '{2}' is marked obsolete: '{3}'.</source>
        <target state="translated">'{0}' 클래스는 기본 클래스 '{2}'의 '{1}'이(가) obsolete로 표시되어 있으므로 'Sub New'를 선언해야 합니다('{3}').</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NoNonObsoleteConstructorOnBase4_Title">
        <source>Class should declare a 'Sub New' because the constructor in its base class is marked obsolete</source>
        <target state="translated">기본 클래스의 생성자가 obsolete로 표시되어 있으므로 클래스에서 'Sub New'를 선언해야 함</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_RequiredNonObsoleteNewCall3">
        <source>First statement of this 'Sub New' should be an explicit call to 'MyBase.New' or 'MyClass.New' because the '{0}' in the base class '{1}' of '{2}' is marked obsolete.</source>
        <target state="translated">'{2}'의 기본 클래스 '{1}'에 있는 '{0}'이(가) 사용되지 않는 상태로 표시되어 있으므로, 이 'Sub New'의 첫째 문은 'MyBase.New' 또는 'MyClass.New'에 대한 명시적 호출이어야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_RequiredNonObsoleteNewCall3_Title">
        <source>First statement of this 'Sub New' should be an explicit call to 'MyBase.New' or 'MyClass.New' because the constructor in the base class is marked obsolete</source>
        <target state="translated">기본 클래스의 생성자가 obsolete로 표시되어 있으므로 이 'Sub New'의 첫째 문은 'MyBase.New' 또는 'MyClass.New'에 대한 명시적 호출이어야 함</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_RequiredNonObsoleteNewCall4">
        <source>First statement of this 'Sub New' should be an explicit call to 'MyBase.New' or 'MyClass.New' because the '{0}' in the base class '{1}' of '{2}' is marked obsolete: '{3}'</source>
        <target state="translated">'{2}'의 기본 클래스 '{1}'에 있는 '{0}'이(가) obsolete로 표시되어 있으므로 이 'Sub New'의 첫째 문은 'MyBase.New' 또는 'MyClass.New'에 대한 명시적 호출이어야 합니다('{3}').</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_RequiredNonObsoleteNewCall4_Title">
        <source>First statement of this 'Sub New' should be an explicit call to 'MyBase.New' or 'MyClass.New' because the constructor in the base class is marked obsolete</source>
        <target state="translated">기본 클래스의 생성자가 obsolete로 표시되어 있으므로 이 'Sub New'의 첫째 문은 'MyBase.New' 또는 'MyClass.New'에 대한 명시적 호출이어야 함</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_MissingAsClauseinOperator">
        <source>Operator without an 'As' clause; type of Object assumed.</source>
        <target state="translated">연산자에 'As' 절이 없습니다. Object 형식으로 간주합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_MissingAsClauseinOperator_Title">
        <source>Operator without an 'As' clause</source>
        <target state="translated">As' 절이 없는 연산자</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_ConstraintsFailedForInferredArgs2">
        <source>Type arguments inferred for method '{0}' result in the following warnings :{1}</source>
        <target state="translated">'{0}' 메서드에 대해 유추된 형식 인수가 다음 경고를 표시했습니다({1})</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_ConstraintsFailedForInferredArgs2_Title">
        <source>Type arguments inferred for method result in warnings</source>
        <target state="translated">메서드에 대해 유추된 형식 인수로 인해 경고 발생</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_ConditionalNotValidOnFunction">
        <source>Attribute 'Conditional' is only valid on 'Sub' declarations.</source>
        <target state="translated">Conditional' 특성은 'Sub' 선언에서만 사용할 수 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_ConditionalNotValidOnFunction_Title">
        <source>Attribute 'Conditional' is only valid on 'Sub' declarations</source>
        <target state="translated">Conditional' 특성은 'Sub' 선언에서만 유효함</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UseSwitchInsteadOfAttribute">
        <source>Use command-line option '{0}' or appropriate project settings instead of '{1}'.</source>
        <target state="translated">'{1}' 대신 명령줄 옵션 '{0}' 또는 적합한 프로젝트 설정을 사용하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UseSwitchInsteadOfAttribute_Title">
        <source>Use command-line option /keyfile, /keycontainer, or /delaysign instead of AssemblyKeyFileAttribute, AssemblyKeyNameAttribute, or AssemblyDelaySignAttribute</source>
        <target state="translated">AssemblyKeyFileAttribute, AssemblyKeyNameAttribute 또는 AssemblyDelaySignAttribute 대신 명령줄 옵션 /keyfile, /keycontainer 또는 /delaysign 사용</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_RecursiveAddHandlerCall">
        <source>Statement recursively calls the containing '{0}' for event '{1}'.</source>
        <target state="translated">문이 '{1}' 이벤트에 대해 포함하는 '{0}'을(를) 재귀적으로 호출합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_RecursiveAddHandlerCall_Title">
        <source>Statement recursively calls the event's containing AddHandler</source>
        <target state="translated">이벤트에 대해 포함하는 AddHandler를 문이 재귀적으로 호출함</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_ImplicitConversionCopyBack">
        <source>Implicit conversion from '{1}' to '{2}' in copying the value of 'ByRef' parameter '{0}' back to the matching argument.</source>
        <target state="translated">ByRef' 매개 변수 '{0}'의 값을 해당 인수에 다시 복사하는 동안 발생하는 '{1}'에서 '{2}'(으)로의 암시적 변환입니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_ImplicitConversionCopyBack_Title">
        <source>Implicit conversion in copying the value of 'ByRef' parameter back to the matching argument</source>
        <target state="translated">ByRef' 매개 변수의 값을 일치하는 인수에 다시 복사할 때 수행되는 암시적 변환</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_MustShadowOnMultipleInheritance2">
        <source>{0} '{1}' conflicts with other members of the same name across the inheritance hierarchy and so should be declared 'Shadows'.</source>
        <target state="translated">{0} '{1}'은(는) 상속 계층 구조에서 이름이 같은 다른 멤버와 충돌하므로 'Shadows'로 선언해야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_MustShadowOnMultipleInheritance2_Title">
        <source>Method conflicts with other members of the same name across the inheritance hierarchy and so should be declared 'Shadows'</source>
        <target state="translated">메서드가 상속 계층 구조에서 이름이 같은 다른 멤버와 충돌하므로 'Shadows'로 선언해야 함</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_RecursiveOperatorCall">
        <source>Expression recursively calls the containing Operator '{0}'.</source>
        <target state="translated">포함하는 '{0}' 연산자를 식이 재귀적으로 호출합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_RecursiveOperatorCall_Title">
        <source>Expression recursively calls the containing Operator</source>
        <target state="translated">포함하는 연산자를 식이 재귀적으로 호출함</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_ImplicitConversion2">
        <source>Implicit conversion from '{0}' to '{1}'.</source>
        <target state="translated">'{0}'에서 '{1}'(으)로의 암시적 변환입니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_ImplicitConversion2_Title">
        <source>Implicit conversion</source>
        <target state="translated">암시적 변환</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_MutableStructureInUsing">
        <source>Local variable '{0}' is read-only and its type is a structure. Invoking its members or passing it ByRef does not change its content and might lead to unexpected results. Consider declaring this variable outside of the 'Using' block.</source>
        <target state="translated">지역 변수 '{0}'은(는) 읽기 전용이며 형식이 구조체입니다. 해당 멤버를 호출하거나 ByRef로 전달하면 해당 내용이 변경되지 않으므로 예기치 않은 결과가 발생할 수 있습니다. 이 변수는 'Using' 블록 외부에 선언하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_MutableStructureInUsing_Title">
        <source>Local variable declared by Using statement is read-only and its type is a structure</source>
        <target state="translated">Using 문으로 선언된 지역 변수가 읽기 전용이며 해당 형식이 구조임</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_MutableGenericStructureInUsing">
        <source>Local variable '{0}' is read-only. When its type is a structure, invoking its members or passing it ByRef does not change its content and might lead to unexpected results. Consider declaring this variable outside of the 'Using' block.</source>
        <target state="translated">지역 변수 '{0}'은(는) 읽기 전용입니다. 해당 형식이 구조체인 경우 해당 멤버를 호출하거나 ByRef로 전달하면 해당 내용이 변경되지 않으므로 예기치 않은 결과가 발생할 수 있습니다. 이 변수는 'Using' 블록 외부에 선언하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_MutableGenericStructureInUsing_Title">
        <source>Local variable declared by Using statement is read-only and its type may be a structure</source>
        <target state="translated">Using 문으로 선언된 지역 변수가 읽기 전용이며 해당 형식이 구조일 수 있음</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_ImplicitConversionSubst1">
        <source>{0}</source>
        <target state="translated">{0}</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_ImplicitConversionSubst1_Title">
        <source>Implicit conversion</source>
        <target state="translated">암시적 변환</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_LateBindingResolution">
        <source>Late bound resolution; runtime errors could occur.</source>
        <target state="translated">런타임에 바인딩을 확인합니다. 런타임 오류가 발생할 수 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_LateBindingResolution_Title">
        <source>Late bound resolution</source>
        <target state="translated">런타임에 바인딩 확인</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_ObjectMath1">
        <source>Operands of type Object used for operator '{0}'; use the 'Is' operator to test object identity.</source>
        <target state="translated">'{0}' 연산자에 대해 Object 형식의 피연산자를 사용했습니다. 개체 ID를 테스트하려면 'Is' 연산자를 사용하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_ObjectMath1_Title">
        <source>Operands of type Object used for operator</source>
        <target state="translated">연산자에 대해 Object 형식의 피연산자를 사용함</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_ObjectMath2">
        <source>Operands of type Object used for operator '{0}'; runtime errors could occur.</source>
        <target state="translated">'{0}' 연산자에 대해 Object 형식의 피연산자를 사용했습니다. 런타임 오류가 발생할 수 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_ObjectMath2_Title">
        <source>Operands of type Object used for operator</source>
        <target state="translated">연산자에 대해 Object 형식의 피연산자를 사용함</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_ObjectAssumedVar1">
        <source>{0}</source>
        <target state="translated">{0}</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_ObjectAssumedVar1_Title">
        <source>Variable declaration without an 'As' clause</source>
        <target state="translated">As' 절이 없는 변수 선언</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_ObjectAssumed1">
        <source>{0}</source>
        <target state="translated">{0}</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_ObjectAssumed1_Title">
        <source>Function without an 'As' clause</source>
        <target state="translated">As' 절이 없는 함수</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_ObjectAssumedProperty1">
        <source>{0}</source>
        <target state="translated">{0}</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_ObjectAssumedProperty1_Title">
        <source>Property without an 'As' clause</source>
        <target state="translated">As' 절이 없는 속성</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_MissingAsClauseinVarDecl">
        <source>Variable declaration without an 'As' clause; type of Object assumed.</source>
        <target state="translated">변수 선언에 'As' 절이 없습니다. Object 형식으로 간주합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_MissingAsClauseinVarDecl_Title">
        <source>Variable declaration without an 'As' clause</source>
        <target state="translated">As' 절이 없는 변수 선언</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_MissingAsClauseinFunction">
        <source>Function without an 'As' clause; return type of Object assumed.</source>
        <target state="translated">함수에 'As' 절이 없습니다. Object 반환 형식으로 간주합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_MissingAsClauseinFunction_Title">
        <source>Function without an 'As' clause</source>
        <target state="translated">As' 절이 없는 함수</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_MissingAsClauseinProperty">
        <source>Property without an 'As' clause; type of Object assumed.</source>
        <target state="translated">속성에 'As' 절이 없습니다. Object 형식으로 간주합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_MissingAsClauseinProperty_Title">
        <source>Property without an 'As' clause</source>
        <target state="translated">As' 절이 없는 속성</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UnusedLocal">
        <source>Unused local variable: '{0}'.</source>
        <target state="translated">사용되지 않는 지역 변수: '{0}'</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UnusedLocal_Title">
        <source>Unused local variable</source>
        <target state="translated">사용하지 않는 지역 변수</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_SharedMemberThroughInstance">
        <source>Access of shared member, constant member, enum member or nested type through an instance; qualifying expression will not be evaluated.</source>
        <target state="translated">인스턴스를 통한 공유 멤버, 상수 멤버, 열거형 멤버 또는 중첩 형식 액세스입니다. 정규화 식을 계산하지 않습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_SharedMemberThroughInstance_Title">
        <source>Access of shared member, constant member, enum member or nested type through an instance</source>
        <target state="translated">인스턴스를 통한 공유 멤버, 상수 멤버, 열거형 멤버 또는 중첩 형식 액세스임</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_RecursivePropertyCall">
        <source>Expression recursively calls the containing property '{0}'.</source>
        <target state="translated">포함하는 '{0}' 속성을 식이 재귀적으로 호출합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_RecursivePropertyCall_Title">
        <source>Expression recursively calls the containing property</source>
        <target state="translated">포함하는 속성을 식이 재귀적으로 호출함</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_OverlappingCatch">
        <source>'Catch' block never reached, because '{0}' inherits from '{1}'.</source>
        <target state="translated">'{0}'이(가) '{1}'에서 상속되므로 'Catch' 블록에 도달하지 않습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_OverlappingCatch_Title">
        <source>'Catch' block never reached; exception type's base type handled above in the same Try statement</source>
        <target state="translated">'Catch' 블록에 도달할 수 없어 예외 형식의 기본 형식이 동일한 Try 문의 윗부분에서 처리됨</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_DefAsgUseNullRefByRef">
        <source>Variable '{0}' is passed by reference before it has been assigned a value. A null reference exception could result at runtime.</source>
        <target state="translated">값이 할당되기 전에 '{0}' 변수를 참조로 전달했습니다. 런타임에 null 참조 예외가 발생할 수 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_DefAsgUseNullRefByRef_Title">
        <source>Variable is passed by reference before it has been assigned a value</source>
        <target state="translated">변수에 값이 할당되기 전에 참조로 변수가 전달됨</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_DuplicateCatch">
        <source>'Catch' block never reached; '{0}' handled above in the same Try statement.</source>
        <target state="translated">'Catch' 블록에 도달할 수 없습니다. '{0}'이(가) 같은 Try 문의 윗부분에서 처리되었습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_DuplicateCatch_Title">
        <source>'Catch' block never reached; exception type handled above in the same Try statement</source>
        <target state="translated">'Catch' 블록에 도달할 수 없어 예외 형식이 동일한 Try 문의 윗부분에서 처리됨</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_ObjectMath1Not">
        <source>Operands of type Object used for operator '{0}'; use the 'IsNot' operator to test object identity.</source>
        <target state="translated">'{0}' 연산자에 대해 Object 형식의 피연산자를 사용했습니다. 개체 ID를 테스트하려면 'IsNot' 연산자를 사용하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_ObjectMath1Not_Title">
        <source>Operands of type Object used for operator &lt;&gt;</source>
        <target state="translated">&lt;&gt; 연산자에 대해 Object 형식의 피연산자를 사용함</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_BadChecksumValExtChecksum">
        <source>Bad checksum value, non hex digits or odd number of hex digits.</source>
        <target state="translated">체크섬 값이 잘못되었습니다. 16진수가 아니거나 16진수 값이 홀수입니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_BadChecksumValExtChecksum_Title">
        <source>Bad checksum value, non hex digits or odd number of hex digits</source>
        <target state="translated">체크섬 값이 잘못됨, 16진수가 아니거나 16진수 값이 홀수임</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_MultipleDeclFileExtChecksum">
        <source>File name already declared with a different GUID and checksum value.</source>
        <target state="translated">파일 이름이 이미 다른 GUID와 체크섬 값으로 선언되어 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_MultipleDeclFileExtChecksum_Title">
        <source>File name already declared with a different GUID and checksum value</source>
        <target state="translated">파일 이름이 이미 다른 GUID와 체크섬 값으로 선언되어 있음</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_BadGUIDFormatExtChecksum">
        <source>Bad GUID format.</source>
        <target state="translated">잘못된 GUID 형식입니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_BadGUIDFormatExtChecksum_Title">
        <source>Bad GUID format</source>
        <target state="translated">잘못된 GUID 형식</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_ObjectMathSelectCase">
        <source>Operands of type Object used in expressions for 'Select', 'Case' statements; runtime errors could occur.</source>
        <target state="translated">Select', 'Case' 문의 식에서 Object 형식의 피연산자를 사용했습니다. 런타임 오류가 발생할 수 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_ObjectMathSelectCase_Title">
        <source>Operands of type Object used in expressions for 'Select', 'Case' statements</source>
        <target state="translated">Select', 'Case' 문의 식에 Object 형식의 피연산자를 사용함</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_EqualToLiteralNothing">
        <source>This expression will always evaluate to Nothing (due to null propagation from the equals operator). To check if the value is null consider using 'Is Nothing'.</source>
        <target state="translated">Equals 연산자의 null 전파 때문에 이 식은 항상 Nothing으로 평가됩니다. 값이 null인지 확인하려면 'Is Nothing'을 사용하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_EqualToLiteralNothing_Title">
        <source>This expression will always evaluate to Nothing</source>
        <target state="translated">이 식은 항상 Nothing으로 평가됨</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NotEqualToLiteralNothing">
        <source>This expression will always evaluate to Nothing (due to null propagation from the equals operator). To check if the value is not null consider using 'IsNot Nothing'.</source>
        <target state="translated">Equals 연산자의 null 전파 때문에 이 식은 항상 Nothing으로 평가됩니다. 값이 null이 아닌지 확인하려면 'IsNot Nothing'을 사용하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NotEqualToLiteralNothing_Title">
        <source>This expression will always evaluate to Nothing</source>
        <target state="translated">이 식은 항상 Nothing으로 평가됨</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UnusedLocalConst">
        <source>Unused local constant: '{0}'.</source>
        <target state="translated">사용되지 않는 지역 상수: '{0}'</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UnusedLocalConst_Title">
        <source>Unused local constant</source>
        <target state="translated">사용하지 않는 로컬 상수</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_ComClassInterfaceShadows5">
        <source>'Microsoft.VisualBasic.ComClassAttribute' on class '{0}' implicitly declares {1} '{2}', which conflicts with a member of the same name in {3} '{4}'. Use 'Microsoft.VisualBasic.ComClassAttribute(InterfaceShadows:=True)' if you want to hide the name on the base {4}.</source>
        <target state="translated">'{0}' 클래스의 'Microsoft.VisualBasic.ComClassAttribute'는 {3} '{4}'에서 이름이 같은 멤버와 충돌하는 {1} '{2}'을(를) 암시적으로 선언합니다. 기본 {4}의 이름을 숨기려면 'Microsoft.VisualBasic.ComClassAttribute(InterfaceShadows:=True)'를 사용하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_ComClassInterfaceShadows5_Title">
        <source>'Microsoft.VisualBasic.ComClassAttribute' on class implicitly declares member, which conflicts with a member of the same name</source>
        <target state="translated">'클래스의 'Microsoft.VisualBasic.ComClassAttribute'가 동일한 이름의 멤버와 충돌하는 멤버를 암시적으로 선언함</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_ComClassPropertySetObject1">
        <source>'{0}' cannot be exposed to COM as a property 'Let'. You will not be able to assign non-object values (such as numbers or strings) to this property from Visual Basic 6.0 using a 'Let' statement.</source>
        <target state="translated">'{0}'을(를) 'Let' 속성으로 COM에 노출할 수 없습니다. Visual Basic 6.0의 'Let' 문을 사용하여 이 속성에 숫자나 문자열 같은 개체가 아닌 값을 할당할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_ComClassPropertySetObject1_Title">
        <source>Property cannot be exposed to COM as a property 'Let'</source>
        <target state="translated">속성을 COM에 'Let' 속성으로 노출할 수 없음</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_DefAsgUseNullRef">
        <source>Variable '{0}' is used before it has been assigned a value. A null reference exception could result at runtime.</source>
        <target state="translated">값이 할당되기 전에 '{0}' 변수를 사용했습니다. 런타임에 null 참조 예외가 발생할 수 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_DefAsgUseNullRef_Title">
        <source>Variable is used before it has been assigned a value</source>
        <target state="translated">변수에 값이 할당되기 전에 변수가 사용됨</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_DefAsgNoRetValFuncRef1">
        <source>Function '{0}' doesn't return a value on all code paths. A null reference exception could occur at run time when the result is used.</source>
        <target state="translated">'{0}' 함수가 일부 코드 경로에서만 값을 반환합니다. 이 결과를 사용하면 런타임에 null 참조 예외가 발생할 수 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_DefAsgNoRetValFuncRef1_Title">
        <source>Function doesn't return a value on all code paths</source>
        <target state="translated">함수가 일부 코드 경로의 값을 반환하지 않음</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_DefAsgNoRetValOpRef1">
        <source>Operator '{0}' doesn't return a value on all code paths. A null reference exception could occur at run time when the result is used.</source>
        <target state="translated">'{0}' 연산자가 일부 코드 경로에 대해서만 값을 반환합니다. 이 결과를 사용하면 런타임에 null 참조 예외가 발생할 수 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_DefAsgNoRetValOpRef1_Title">
        <source>Operator doesn't return a value on all code paths</source>
        <target state="translated">연산자가 일부 코드 경로의 값을 반환하지 않음</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_DefAsgNoRetValPropRef1">
        <source>Property '{0}' doesn't return a value on all code paths. A null reference exception could occur at run time when the result is used.</source>
        <target state="translated">'{0}' 속성이 일부 코드 경로에서만 값을 반환합니다. 이 결과를 사용하면 런타임에 null 참조 예외가 발생할 수 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_DefAsgNoRetValPropRef1_Title">
        <source>Property doesn't return a value on all code paths</source>
        <target state="translated">속성이 일부 코드 경로의 값을 반환하지 않음</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_DefAsgUseNullRefByRefStr">
        <source>Variable '{0}' is passed by reference before it has been assigned a value. A null reference exception could result at runtime. Make sure the structure or all the reference members are initialized before use</source>
        <target state="translated">값이 할당되기 전에 '{0}' 변수를 참조로 전달했습니다. 런타임에 null 참조 예외가 발생할 수 있습니다. 사용하기 전에 구조체 또는 모든 참조 멤버가 초기화되었는지 확인하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_DefAsgUseNullRefByRefStr_Title">
        <source>Variable is passed by reference before it has been assigned a value</source>
        <target state="translated">변수에 값이 할당되기 전에 참조로 변수가 전달됨</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_DefAsgUseNullRefStr">
        <source>Variable '{0}' is used before it has been assigned a value. A null reference exception could result at runtime. Make sure the structure or all the reference members are initialized before use</source>
        <target state="translated">값이 할당되기 전에 '{0}' 변수를 사용했습니다. 런타임에 null 참조 예외가 발생할 수 있습니다. 사용하기 전에 구조체 또는 모든 참조 멤버가 초기화되었는지 확인하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_DefAsgUseNullRefStr_Title">
        <source>Variable is used before it has been assigned a value</source>
        <target state="translated">변수에 값이 할당되기 전에 변수가 사용됨</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_StaticLocalNoInference">
        <source>Static variable declared without an 'As' clause; type of Object assumed.</source>
        <target state="translated">As' 절 없이 정적 변수가 선언되었습니다. Object 형식으로 간주합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_StaticLocalNoInference_Title">
        <source>Static variable declared without an 'As' clause</source>
        <target state="translated">As' 절 없이 정적 변수가 선언됨</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_InvalidAssemblyName">
        <source>Assembly reference '{0}' is invalid and cannot be resolved.</source>
        <target state="translated">'{0}' 어셈블리 참조가 잘못되어 확인할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_InvalidAssemblyName_Title">
        <source>Assembly reference is invalid and cannot be resolved</source>
        <target state="translated">어셈블리 참조가 잘못되어 확인할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_XMLDocBadXMLLine">
        <source>XML comment block must immediately precede the language element to which it applies. XML comment will be ignored.</source>
        <target state="translated">XML 주석 블록은 이 주석 블록이 적용되는 언어 요소의 바로 앞에 와야 합니다. XML 주석이 무시됩니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_XMLDocBadXMLLine_Title">
        <source>XML comment block must immediately precede the language element to which it applies</source>
        <target state="translated">XML 주석 블록은 이 주석 블록이 적용되는 언어 요소의 바로 앞에 와야 함</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_XMLDocMoreThanOneCommentBlock">
        <source>Only one XML comment block is allowed per language element.</source>
        <target state="translated">XML 주석 블록은 언어 요소마다 하나만 사용할 수 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_XMLDocMoreThanOneCommentBlock_Title">
        <source>Only one XML comment block is allowed per language element</source>
        <target state="translated">XML 주석 블록은 언어 요소마다 하나만 사용할 수 있음</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_XMLDocNotFirstOnLine">
        <source>XML comment must be the first statement on a line. XML comment will be ignored.</source>
        <target state="translated">XML 주석은 줄의 첫 번째 문이어야 합니다. XML 주석이 무시됩니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_XMLDocNotFirstOnLine_Title">
        <source>XML comment must be the first statement on a line</source>
        <target state="translated">XML 주석은 줄의 첫째 문이어야 함</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_XMLDocInsideMethod">
        <source>XML comment cannot appear within a method or a property. XML comment will be ignored.</source>
        <target state="translated">메서드 또는 속성에는 XML 주석을 사용할 수 없습니다. XML 주석이 무시됩니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_XMLDocInsideMethod_Title">
        <source>XML comment cannot appear within a method or a property</source>
        <target state="translated">메서드 또는 속성 내에 XML 주석이 표시될 수 없음</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_XMLDocParseError1">
        <source>XML documentation parse error: {0} XML comment will be ignored.</source>
        <target state="translated">XML 문서 구문 분석 오류: {0} XML 주석이 무시됩니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_XMLDocParseError1_Title">
        <source>XML documentation parse error</source>
        <target state="translated">XML 문서 구문 분석 오류</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_XMLDocDuplicateXMLNode1">
        <source>XML comment tag '{0}' appears with identical attributes more than once in the same XML comment block.</source>
        <target state="translated">특성이 같은 '{0}' XML 주석 태그가 동일한 XML 주석 블록에서 두 번 이상 나타납니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_XMLDocDuplicateXMLNode1_Title">
        <source>XML comment tag appears with identical attributes more than once in the same XML comment block</source>
        <target state="translated">특성이 같은 XML 주석 태그가 동일한 XML 주석 블록에서 두 번 이상 나타남</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_XMLDocIllegalTagOnElement2">
        <source>XML comment tag '{0}' is not permitted on a '{1}' language element.</source>
        <target state="translated">'{0}' XML 주석 태그는 '{1}' 언어 요소에서 허용되지 않습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_XMLDocIllegalTagOnElement2_Title">
        <source>XML comment tag is not permitted on language element</source>
        <target state="translated">XML 주석 태그는 언어 요소에 사용할 수 없음</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_XMLDocBadParamTag2">
        <source>XML comment parameter '{0}' does not match a parameter on the corresponding '{1}' statement.</source>
        <target state="translated">'{0}' XML 주석 매개 변수가 해당 '{1}' 문의 매개 변수와 일치하지 않습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_XMLDocBadParamTag2_Title">
        <source>XML comment parameter does not match a parameter on the corresponding declaration statement</source>
        <target state="translated">XML 주석 매개 변수가 해당 선언 문의 매개 변수와 일치하지 않음</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_XMLDocParamTagWithoutName">
        <source>XML comment parameter must have a 'name' attribute.</source>
        <target state="translated">XML 주석 매개 변수에는 'name' 특성이 있어야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_XMLDocParamTagWithoutName_Title">
        <source>XML comment parameter must have a 'name' attribute</source>
        <target state="translated">XML 주석 매개 변수에는 'name' 특성이 있어야 함</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_XMLDocCrefAttributeNotFound1">
        <source>XML comment has a tag with a 'cref' attribute '{0}' that could not be resolved.</source>
        <target state="translated">XML 주석에 확인할 수 없는 'cref' 특성('{0}')이 포함된 태그가 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_XMLDocCrefAttributeNotFound1_Title">
        <source>XML comment has a tag with a 'cref' attribute that could not be resolved</source>
        <target state="translated">XML 주석에 확인할 수 없는 'cref' 특성이 포함된 태그가 있음</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_XMLMissingFileOrPathAttribute1">
        <source>XML comment tag 'include' must have a '{0}' attribute. XML comment will be ignored.</source>
        <target state="translated">XML 주석 태그 'include'에는 '{0}' 특성이 있어야 합니다. XML 주석이 무시됩니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_XMLMissingFileOrPathAttribute1_Title">
        <source>XML comment tag 'include' must have 'file' and 'path' attributes</source>
        <target state="translated">XML 주석 태그 'include'에는 'file' 및 'path' 특성이 있어야 함</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_XMLCannotWriteToXMLDocFile2">
        <source>Unable to create XML documentation file '{0}': {1}</source>
        <target state="translated">XML 문서 파일 '{0}'을(를) 만들 수 없습니다({1}).</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_XMLCannotWriteToXMLDocFile2_Title">
        <source>Unable to create XML documentation file</source>
        <target state="translated">XML 문서 파일을 만들 수 없음</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_XMLDocWithoutLanguageElement">
        <source>XML documentation comments must precede member or type declarations.</source>
        <target state="translated">XML 문서 주석은 멤버 또는 형식 선언 앞에 와야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_XMLDocWithoutLanguageElement_Title">
        <source>XML documentation comments must precede member or type declarations</source>
        <target state="translated">XML 문서 주석은 멤버 또는 형식 선언 앞에 와야 함</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_XMLDocReturnsOnWriteOnlyProperty">
        <source>XML comment tag 'returns' is not permitted on a 'WriteOnly' Property.</source>
        <target state="translated">XML 주석 태그 'returns'는 'WriteOnly' 속성에 사용할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_XMLDocReturnsOnWriteOnlyProperty_Title">
        <source>XML comment tag 'returns' is not permitted on a 'WriteOnly' Property</source>
        <target state="translated">XML 주석 태그 'returns'는 'WriteOnly' 속성에 사용할 수 없음</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_XMLDocOnAPartialType">
        <source>XML comment cannot be applied more than once on a partial {0}. XML comments for this {0} will be ignored.</source>
        <target state="translated">부분 {0}에는 XML 주석을 두 번 이상 적용할 수 없습니다. 이 {0}에 대한 XML 주석이 무시됩니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_XMLDocOnAPartialType_Title">
        <source>XML comment cannot be applied more than once on a partial type</source>
        <target state="translated">부분 형식(Partial Type)에는 XML 주석을 두 번 이상 적용할 수 없음</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_XMLDocReturnsOnADeclareSub">
        <source>XML comment tag 'returns' is not permitted on a 'declare sub' language element.</source>
        <target state="translated">XML 주석 태그 'returns'는 'declare sub' 언어 요소에서 사용할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_XMLDocReturnsOnADeclareSub_Title">
        <source>XML comment tag 'returns' is not permitted on a 'declare sub' language element</source>
        <target state="translated">XML 주석 태그 'returns'는 'declare sub' 언어 요소에서 사용할 수 없음</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_XMLDocStartTagWithNoEndTag">
        <source>XML documentation parse error: Start tag '{0}' doesn't have a matching end tag. XML comment will be ignored.</source>
        <target state="translated">XML 문서 구문 분석 오류: 시작 태그 '{0}'에 짝이 되는 끝 태그가 없습니다. XML 주석이 무시됩니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_XMLDocStartTagWithNoEndTag_Title">
        <source>XML documentation parse error: Start tag doesn't have a matching end tag</source>
        <target state="translated">XML 문서 구문 분석 오류: 시작 태그에 짝이 되는 끝 태그가 없음</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_XMLDocBadGenericParamTag2">
        <source>XML comment type parameter '{0}' does not match a type parameter on the corresponding '{1}' statement.</source>
        <target state="translated">'{0}' XML 주석 형식 매개 변수가 해당 '{1}' 문의 형식 매개 변수와 일치하지 않습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_XMLDocBadGenericParamTag2_Title">
        <source>XML comment type parameter does not match a type parameter on the corresponding declaration statement</source>
        <target state="translated">XML 주석 형식 매개 변수가 해당 선언 문의 형식 매개 변수와 일치하지 않음</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_XMLDocGenericParamTagWithoutName">
        <source>XML comment type parameter must have a 'name' attribute.</source>
        <target state="translated">XML 주석 형식 매개 변수에는 'name' 특성이 있어야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_XMLDocGenericParamTagWithoutName_Title">
        <source>XML comment type parameter must have a 'name' attribute</source>
        <target state="translated">XML 주석 형식 매개 변수에는 'name' 특성이 있어야 함</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_XMLDocExceptionTagWithoutCRef">
        <source>XML comment exception must have a 'cref' attribute.</source>
        <target state="translated">XML 주석 예외에는 'cref' 특성이 있어야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_XMLDocExceptionTagWithoutCRef_Title">
        <source>XML comment exception must have a 'cref' attribute</source>
        <target state="translated">XML 주석 예외에는 'cref' 특성이 있어야 함</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_XMLDocInvalidXMLFragment">
        <source>Unable to include XML fragment '{0}' of file '{1}'.</source>
        <target state="translated">'{1}' 파일의 '{0}' XML 조각을 포함할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_XMLDocInvalidXMLFragment_Title">
        <source>Unable to include XML fragment</source>
        <target state="translated">XML 조각을 포함할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_XMLDocBadFormedXML">
        <source>Unable to include XML fragment '{1}' of file '{0}'. {2}</source>
        <target state="translated">'{0}' 파일의 '{1}' XML 조각을 포함할 수 없습니다({2}).</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_XMLDocBadFormedXML_Title">
        <source>Unable to include XML fragment</source>
        <target state="translated">XML 조각을 포함할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_InterfaceConversion2">
        <source>Runtime errors might occur when converting '{0}' to '{1}'.</source>
        <target state="translated">'{0}'에서 '{1}'(으)로 변환할 경우 런타임 오류가 발생할 수 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_InterfaceConversion2_Title">
        <source>Runtime errors might occur when converting to or from interface type</source>
        <target state="translated">인터페이스 형식과 변환할 때 런타임 오류가 발생할 수 있음</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_LiftControlVariableLambda">
        <source>Using the iteration variable in a lambda expression may have unexpected results.  Instead, create a local variable within the loop and assign it the value of the iteration variable.</source>
        <target state="translated">람다 식에 반복 변수를 사용하면 예기치 않은 결과가 발생할 수 있습니다. 대신 루프 내에 지역 변수를 만든 다음 여기에 반복 변수 값을 할당하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_LiftControlVariableLambda_Title">
        <source>Using the iteration variable in a lambda expression may have unexpected results</source>
        <target state="translated">람다 식에 반복 변수를 사용하면 예기치 않은 결과가 발생할 수 있음</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_LambdaPassedToRemoveHandler">
        <source>Lambda expression will not be removed from this event handler. Assign the lambda expression to a variable and use the variable to add and remove the event.</source>
        <target state="translated">이벤트 처리기에서 람다 식이 제거되지 않습니다. 변수에 람다 식을 할당한 후 변수를 사용하여 이벤트를 추가하거나 제거하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_LambdaPassedToRemoveHandler_Title">
        <source>Lambda expression will not be removed from this event handler</source>
        <target state="translated">이벤트 처리기에서 람다 식이 제거되지 않음</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_LiftControlVariableQuery">
        <source>Using the iteration variable in a query expression may have unexpected results.  Instead, create a local variable within the loop and assign it the value of the iteration variable.</source>
        <target state="translated">쿼리 식에 반복 변수를 사용하면 예기치 않은 결과가 발생할 수 있습니다. 대신 루프 내에 지역 변수를 만든 다음 여기에 반복 변수 값을 할당하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_LiftControlVariableQuery_Title">
        <source>Using the iteration variable in a query expression may have unexpected results</source>
        <target state="translated">쿼리 식에 반복 변수를 사용하면 예기치 않은 결과가 발생할 수 있음</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_RelDelegatePassedToRemoveHandler">
        <source>The 'AddressOf' expression has no effect in this context because the method argument to 'AddressOf' requires a relaxed conversion to the delegate type of the event. Assign the 'AddressOf' expression to a variable, and use the variable to add or remove the method as the handler.</source>
        <target state="translated">AddressOf'의 메서드 인수를 사용하려면 이벤트의 대리자 형식으로 낮은 수준의 변환을 수행해야 하므로 'AddressOf' 식은 이 컨텍스트에서는 의미가 없습니다. 변수에 'AddressOf' 식을 할당한 후 해당 변수를 사용하여 메서드를 처리기로 추가하거나 제거하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_RelDelegatePassedToRemoveHandler_Title">
        <source>The 'AddressOf' expression has no effect in this context because the method argument to 'AddressOf' requires a relaxed conversion to the delegate type of the event</source>
        <target state="translated">AddressOf'의 메서드 인수를 사용하려면 이벤트의 대리자 형식으로 낮은 수준의 변환을 수행해야 하므로 'AddressOf' 식은 이 컨텍스트에서 효과가 없음</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_QueryMissingAsClauseinVarDecl">
        <source>Range variable is assumed to be of type Object because its type cannot be inferred. Use an 'As' clause to specify a different type.</source>
        <target state="translated">형식을 유추할 수 없어 범위 변수가 Object 형식으로 간주됩니다. 'As' 절을 사용하여 다른 형식을 지정하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_QueryMissingAsClauseinVarDecl_Title">
        <source>Range variable is assumed to be of type Object because its type cannot be inferred</source>
        <target state="translated">형식을 유추할 수 없으므로 범위 변수를 Object 형식으로 가정함</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_MultilineLambdaMissingFunction">
        <source>Multiline lambda expression is missing 'End Function'.</source>
        <target state="translated">여러 줄 람다 식에 'End Function'이 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_MultilineLambdaMissingSub">
        <source>Multiline lambda expression is missing 'End Sub'.</source>
        <target state="translated">여러 줄 람다 식에 'End Sub'가 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AttributeOnLambdaReturnType">
        <source>Attributes cannot be applied to return types of lambda expressions.</source>
        <target state="translated">람다 식의 반환 형식에 특성을 적용할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_SubDisallowsStatement">
        <source>Statement is not valid inside a single-line statement lambda.</source>
        <target state="translated">한 줄 문 람다 내부에는 문을 사용할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_SubRequiresParenthesesBang">
        <source>This single-line statement lambda must be enclosed in parentheses. For example: (Sub() &lt;statement&gt;)!key</source>
        <target state="translated">이 한 줄 문 람다는 괄호로 묶어야 합니다(예: (Sub() &lt;statement&gt;)!key).</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_SubRequiresParenthesesDot">
        <source>This single-line statement lambda must be enclosed in parentheses. For example: (Sub() &lt;statement&gt;).Invoke()</source>
        <target state="translated">이 한 줄 문 람다는 괄호로 묶어야 합니다(예: (Sub() &lt;statement&gt;).Invoke()).</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_SubRequiresParenthesesLParen">
        <source>This single-line statement lambda must be enclosed in parentheses. For example: Call (Sub() &lt;statement&gt;) ()</source>
        <target state="translated">이 한 줄 문 람다는 괄호로 묶어야 합니다(예: Call (Sub() &lt;statement&gt;) ()).</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_SubRequiresSingleStatement">
        <source>Single-line statement lambdas must include exactly one statement.</source>
        <target state="translated">한 줄 문 람다에는 정확히 하나의 문만 있어야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_StaticInLambda">
        <source>Static local variables cannot be declared inside lambda expressions.</source>
        <target state="translated">static 지역 변수는 람다 식 내부에 선언할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InitializedExpandedProperty">
        <source>Expanded Properties cannot be initialized.</source>
        <target state="translated">확장된 속성은 초기화할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AutoPropertyCantHaveParams">
        <source>Auto-implemented properties cannot have parameters.</source>
        <target state="translated">자동 구현 속성은 매개 변수를 사용할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AutoPropertyCantBeWriteOnly">
        <source>Auto-implemented properties cannot be WriteOnly.</source>
        <target state="translated">자동 구현 속성은 WriteOnly일 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_IllegalOperandInIIFCount">
        <source>'If' operator requires either two or three operands.</source>
        <target state="translated">'If' 연산자에는 두 개 또는 세 개의 피연산자가 필요합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NotACollection1">
        <source>Cannot initialize the type '{0}' with a collection initializer because it is not a collection type.</source>
        <target state="translated">'{0}' 형식이 컬렉션 형식이 아니므로 컬렉션 이니셜라이저를 사용하여 해당 형식을 초기화할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NoAddMethod1">
        <source>Cannot initialize the type '{0}' with a collection initializer because it does not have an accessible 'Add' method.</source>
        <target state="translated">'{0}' 형식에 액세스 가능한 'Add' 메서드가 없으므로 컬렉션 이니셜라이저를 사용하여 해당 형식을 초기화할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CantCombineInitializers">
        <source>An Object Initializer and a Collection Initializer cannot be combined in the same initialization.</source>
        <target state="translated">개체 이니셜라이저와 컬렉션 이니셜라이저를 동일한 초기화 작업에서 함께 사용할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_EmptyAggregateInitializer">
        <source>An aggregate collection initializer entry must contain at least one element.</source>
        <target state="translated">집계 컬렉션 이니셜라이저 항목에는 하나 이상의 요소가 있어야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_XmlEndElementNoMatchingStart">
        <source>XML end element must be preceded by a matching start element.</source>
        <target state="translated">XML 끝 요소는 짝이 되는 시작 요소 뒤에 와야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_MultilineLambdasCannotContainOnError">
        <source>'On Error' and 'Resume' cannot appear inside a lambda expression.</source>
        <target state="translated">'On Error' 및 'Resume'은 람다 식 내부에 사용할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_VarianceDisallowedHere">
        <source>Keywords 'Out' and 'In' can only be used in interface and delegate declarations.</source>
        <target state="translated">Out' 및 'In' 키워드는 인터페이스 및 대리자 선언에만 사용할 수 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_XmlEndCDataNotAllowedInContent">
        <source>The literal string ']]&gt;' is not allowed in element content.</source>
        <target state="translated">요소 콘텐츠에는 ']]&gt;' 리터럴 문자열이 허용되지 않습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_OverloadsModifierInModule">
        <source>Inappropriate use of '{0}' keyword in a module.</source>
        <target state="translated">모듈에 적절하지 않은 '{0}' 키워드가 사용되었습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_UndefinedTypeOrNamespace1">
        <source>Type or namespace '{0}' is not defined.</source>
        <target state="translated">형식 또는 네임스페이스 '{0}'이(가) 정의되지 않았습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_IdentityDirectCastForFloat">
        <source>Using DirectCast operator to cast a floating-point value to the same type is not supported.</source>
        <target state="translated">DirectCast 연산자를 사용하여 부동 소수점 값을 동일한 형식으로 캐스팅할 수는 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_ObsoleteIdentityDirectCastForValueType">
        <source>Using DirectCast operator to cast a value-type to the same type is obsolete.</source>
        <target state="translated">DirectCast 연산자를 사용하여 값 형식을 동일한 형식으로 캐스팅하는 작업은 사용되지 않습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_ObsoleteIdentityDirectCastForValueType_Title">
        <source>Using DirectCast operator to cast a value-type to the same type is obsolete</source>
        <target state="translated">DirectCast 연산자를 사용하여 값 형식을 동일한 형식으로 캐스팅하는 작업은 사용되지 않음</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UnreachableCode">
        <source>Unreachable code detected.</source>
        <target state="translated">접근할 수 없는 코드가 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UnreachableCode_Title">
        <source>Unreachable code detected</source>
        <target state="translated">접근할 수 없는 코드가 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_DefAsgNoRetValFuncVal1">
        <source>Function '{0}' doesn't return a value on all code paths. Are you missing a 'Return' statement?</source>
        <target state="translated">'{0}' 함수가 일부 코드 경로에서만 값을 반환합니다. 'Return' 문이 있는지 확인하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_DefAsgNoRetValFuncVal1_Title">
        <source>Function doesn't return a value on all code paths</source>
        <target state="translated">함수가 일부 코드 경로의 값을 반환하지 않음</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_DefAsgNoRetValOpVal1">
        <source>Operator '{0}' doesn't return a value on all code paths. Are you missing a 'Return' statement?</source>
        <target state="translated">'{0}' 연산자가 일부 코드 경로에서만 값을 반환합니다. 'Return' 문이 있는지 확인하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_DefAsgNoRetValOpVal1_Title">
        <source>Operator doesn't return a value on all code paths</source>
        <target state="translated">연산자가 일부 코드 경로의 값을 반환하지 않음</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_DefAsgNoRetValPropVal1">
        <source>Property '{0}' doesn't return a value on all code paths. Are you missing a 'Return' statement?</source>
        <target state="translated">'{0}' 속성이 일부 코드 경로에서만 값을 반환합니다. 'Return' 문이 있는지 확인하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_DefAsgNoRetValPropVal1_Title">
        <source>Property doesn't return a value on all code paths</source>
        <target state="translated">속성이 일부 코드 경로의 값을 반환하지 않음</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NestedGlobalNamespace">
        <source>Global namespace may not be nested in another namespace.</source>
        <target state="translated">전역 네임스페이스는 다른 네임스페이스에 중첩할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AccessMismatch6">
        <source>'{0}' cannot expose type '{1}' in {2} '{3}' through {4} '{5}'.</source>
        <target state="translated">'{0}'은(는) {4} '{5}'을(를) 통해 {2} '{3}'의 '{1}' 형식을 노출할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadMetaDataReference1">
        <source>'{0}' cannot be referenced because it is not a valid assembly.</source>
        <target state="translated">'{0}'은(는) 유효한 어셈블리가 아니므로 참조할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PropertyDoesntImplementAllAccessors">
        <source>'{0}' cannot be implemented by a {1} property.</source>
        <target state="translated">'{1} 속성에서 '{0}'을(를) 구현할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_UnimplementedMustOverride">
        <source>
    {0}: {1}</source>
        <target state="translated">
    {0}: {1}</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_IfTooManyTypesObjectDisallowed">
        <source>Cannot infer a common type because more than one type is possible.</source>
        <target state="translated">두 개 이상의 형식이 가능하므로 공용 형식을 유추할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_IfTooManyTypesObjectAssumed">
        <source>Cannot infer a common type because more than one type is possible; 'Object' assumed.</source>
        <target state="translated">두 개 이상의 형식이 가능하므로 공용 형식을 유추할 수 없습니다. 'Object'로 간주합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_IfTooManyTypesObjectAssumed_Title">
        <source>Cannot infer a common type because more than one type is possible</source>
        <target state="translated">두 개 이상의 형식이 가능하므로 공용 형식을 유추할 수 없음</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_IfNoTypeObjectDisallowed">
        <source>Cannot infer a common type, and Option Strict On does not allow 'Object' to be assumed.</source>
        <target state="translated">공용 형식을 유추할 수 없으며 Option Strict On에서 'Object'를 간주할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_IfNoTypeObjectAssumed">
        <source>Cannot infer a common type; 'Object' assumed.</source>
        <target state="translated">공용 형식을 유추할 수 없습니다. 'Object'로 간주합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_IfNoTypeObjectAssumed_Title">
        <source>Cannot infer a common type</source>
        <target state="translated">공용 형식을 유추할 수 없음</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_IfNoType">
        <source>Cannot infer a common type.</source>
        <target state="translated">공용 형식을 유추할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PublicKeyFileFailure">
        <source>Error extracting public key from file '{0}': {1}</source>
        <target state="translated">'{0}' 파일에서 공용 키를 추출하는 동안 오류가 발생했습니다({1}).</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PublicKeyContainerFailure">
        <source>Error extracting public key from container '{0}': {1}</source>
        <target state="translated">'{0}' 컨테이너에서 공용 키를 추출하는 동안 오류가 발생했습니다({1}).</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_FriendRefNotEqualToThis">
        <source>Friend access was granted by '{0}', but the public key of the output assembly does not match that specified by the attribute in the granting assembly.</source>
        <target state="translated">'{0}'에서 friend 액세스 권한을 부여했지만, 출력 어셈블리의 공용 키가 부여한 어셈블리의 특성에서 지정된 키와 일치하지 않습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_FriendRefSigningMismatch">
        <source>Friend access was granted by '{0}', but the strong name signing state of the output assembly does not match that of the granting assembly.</source>
        <target state="translated">'{0}'에서 friend 액세스 권한을 부여했지만, 출력 어셈블리의 강력한 이름 서명 상태가 부여한 어셈블리의 상태와 일치하지 않습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PublicSignNoKey">
        <source>Public sign was specified and requires a public key, but no public key was specified</source>
        <target state="translated">공개 기호가 지정되었고 공개 키가 필요하지만 공개 키가 지정되지 않았습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PublicSignNetModule">
        <source>Public signing is not supported for netmodules.</source>
        <target state="translated">netmodule에 대해 공개 서명이 지원되지 않습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_AttributeIgnoredWhenPublicSigning">
        <source>Attribute '{0}' is ignored when public signing is specified.</source>
        <target state="translated">공개 서명이 지정된 경우 '{0}' 특성이 무시됩니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_AttributeIgnoredWhenPublicSigning_Title">
        <source>Attribute is ignored when public signing is specified.</source>
        <target state="translated">공개 서명이 지정된 경우 특성이 무시됩니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_DelaySignButNoKey">
        <source>Delay signing was specified and requires a public key, but no public key was specified.</source>
        <target state="translated">서명 연기가 지정되어 공개 키가 필요하지만 지정된 공개 키가 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_DelaySignButNoKey_Title">
        <source>Delay signing was specified and requires a public key, but no public key was specified</source>
        <target state="translated">서명 연기가 지정되어 공개 키가 필요하지만 지정된 공개 키가 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_SignButNoPrivateKey">
        <source>Key file '{0}' is missing the private key needed for signing.</source>
        <target state="translated">'{0}' 키 파일에 서명에 필요한 프라이빗 키가 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_FailureSigningAssembly">
        <source>Error signing assembly '{0}': {1}</source>
        <target state="translated">'{0}' 어셈블리에 서명하는 동안 오류가 발생했습니다({1}).</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InvalidVersionFormat">
        <source>The specified version string does not conform to the required format - major[.minor[.build|*[.revision|*]]]</source>
        <target state="translated">지정한 버전 문자열이 필요한 형식 major[.minor[.build|*[.revision|*]]]을 따르지 않습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_InvalidVersionFormat">
        <source>The specified version string does not conform to the recommended format - major.minor.build.revision</source>
        <target state="translated">지정한 버전 문자열이 권장 형식 major.minor.build.revision을 따르지 않습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_InvalidVersionFormat_Title">
        <source>The specified version string does not conform to the recommended format</source>
        <target state="translated">지정한 버전 문자열이 권장 형식을 따르지 않음</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InvalidVersionFormat2">
        <source>The specified version string does not conform to the recommended format - major.minor.build.revision</source>
        <target state="translated">지정한 버전 문자열이 권장 형식 major.minor.build.revision을 따르지 않습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InvalidAssemblyCultureForExe">
        <source>Executables cannot be satellite assemblies; culture should always be empty</source>
        <target state="translated">실행 파일은 위성 어셈블리일 수 없습니다. 문화권은 항상 비워 두어야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_MainIgnored">
        <source>The entry point of the program is global script code; ignoring '{0}' entry point.</source>
        <target state="translated">프로그램의 진입점은 전역 스크립트 코드이므로 '{0}' 진입점을 무시합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_MainIgnored_Title">
        <source>The entry point of the program is global script code; ignoring entry point</source>
        <target state="translated">프로그램의 진입점이 전역 스크립트 코드이며 진입점을 무시함</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_EmptyPrefixAndXmlnsLocalName">
        <source>The xmlns attribute has special meaning and should not be written with a prefix.</source>
        <target state="translated">xmlns 특성은 특별한 의미가 있으므로 접두사를 사용하여 쓰면 안 됩니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_EmptyPrefixAndXmlnsLocalName_Title">
        <source>The xmlns attribute has special meaning and should not be written with a prefix</source>
        <target state="translated">xmlns 특성은 특별한 의미가 있으므로 접두사를 사용하여 쓰면 안 됨</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_PrefixAndXmlnsLocalName">
        <source>It is not recommended to have attributes named xmlns. Did you mean to write 'xmlns:{0}' to define a prefix named '{0}'?</source>
        <target state="translated">특성 이름으로 xmlns를 지정하지 않는 것이 좋습니다. 명명된 접두사 '{0}'을(를) 정의하는 데 'xmlns:{0}'을 쓰려고 했습니까?</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_PrefixAndXmlnsLocalName_Title">
        <source>It is not recommended to have attributes named xmlns</source>
        <target state="translated">이름이 xmlns인 특성을 사용하지 않는 것이 좋음</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExpectedSingleScript">
        <source>Expected a single script (.vbx file)</source>
        <target state="translated">단일 스크립트(.vbx 파일) 필요</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ReservedAssemblyName">
        <source>The assembly name '{0}' is reserved and cannot be used as a reference in an interactive session</source>
        <target state="translated">'{0}' 어셈블리 이름은 예약된 것이므로 대화형 세션에 참조로 사용할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ReferenceDirectiveOnlyAllowedInScripts">
        <source>#R is only allowed in scripts</source>
        <target state="translated">#R은 스크립트에서만 허용됩니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NamespaceNotAllowedInScript">
        <source>You cannot declare Namespace in script code</source>
        <target state="translated">스크립트 코드에서 네임스페이스를 선언할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_KeywordNotAllowedInScript">
        <source>You cannot use '{0}' in top-level script code</source>
        <target state="translated">최상위 스크립트 코드에서 '{0}'을(를) 사용할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_LambdaNoType">
        <source>Cannot infer a return type.  Consider adding an 'As' clause to specify the return type.</source>
        <target state="translated">반환 형식을 유추할 수 없습니다. 'As' 절을 추가하여 반환 형식을 지정하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_LambdaNoTypeObjectAssumed">
        <source>Cannot infer a return type; 'Object' assumed.</source>
        <target state="translated">반환 형식을 유추할 수 없습니다. 'Object'로 간주합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_LambdaNoTypeObjectAssumed_Title">
        <source>Cannot infer a return type</source>
        <target state="translated">반환 형식을 유추할 수 없음</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_LambdaTooManyTypesObjectAssumed">
        <source>Cannot infer a return type because more than one type is possible; 'Object' assumed.</source>
        <target state="translated">두 개 이상의 형식이 가능하므로 반환 형식을 유추할 수 없습니다. 'Object'로 간주합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_LambdaTooManyTypesObjectAssumed_Title">
        <source>Cannot infer a return type because more than one type is possible</source>
        <target state="translated">두 개 이상의 형식이 가능하므로 반환 형식을 유추할 수 없음</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_LambdaNoTypeObjectDisallowed">
        <source>Cannot infer a return type. Consider adding an 'As' clause to specify the return type.</source>
        <target state="translated">반환 형식을 유추할 수 없습니다. 'As' 절을 추가하여 반환 형식을 지정하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_LambdaTooManyTypesObjectDisallowed">
        <source>Cannot infer a return type because more than one type is possible. Consider adding an 'As' clause to specify the return type.</source>
        <target state="translated">두 개 이상의 형식이 가능하므로 반환 형식을 유추할 수 없습니다. 'As' 절을 추가하여 반환 형식을 지정하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UnimplementedCommandLineSwitch">
        <source>The command line switch '{0}' is not yet implemented and was ignored.</source>
        <target state="translated">명령줄 스위치 '{0}'이(가) 아직 구현되지 않아 무시되었습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UnimplementedCommandLineSwitch_Title">
        <source>Command line switch is not yet implemented</source>
        <target state="translated">명령줄 스위치가 아직 구현되지 않았습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ArrayInitNoTypeObjectDisallowed">
        <source>Cannot infer an element type, and Option Strict On does not allow 'Object' to be assumed. Specifying the type of the array might correct this error.</source>
        <target state="translated">요소 형식을 유추할 수 없으며 Option Strict On에서 'Object'를 간주할 수 없습니다. 배열의 형식을 지정하면 이 오류를 해결할 수 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ArrayInitNoType">
        <source>Cannot infer an element type. Specifying the type of the array might correct this error.</source>
        <target state="translated">요소 형식을 유추할 수 없습니다. 배열의 형식을 지정하면 이 오류를 해결할 수 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ArrayInitTooManyTypesObjectDisallowed">
        <source>Cannot infer an element type because more than one type is possible. Specifying the type of the array might correct this error.</source>
        <target state="translated">두 개 이상의 형식이 가능하므로 요소 형식을 유추할 수 없습니다. 배열의 형식을 지정하면 이 오류를 해결할 수 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_ArrayInitNoTypeObjectAssumed">
        <source>Cannot infer an element type; 'Object' assumed.</source>
        <target state="translated">요소 형식을 유추할 수 없습니다. 'Object'로 간주합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_ArrayInitNoTypeObjectAssumed_Title">
        <source>Cannot infer an element type</source>
        <target state="translated">요소 형식을 유추할 수 없음</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_ArrayInitTooManyTypesObjectAssumed">
        <source>Cannot infer an element type because more than one type is possible; 'Object' assumed.</source>
        <target state="translated">두 개 이상의 형식이 가능하므로 요소 형식을 유추할 수 없습니다. 'Object'로 간주합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_ArrayInitTooManyTypesObjectAssumed_Title">
        <source>Cannot infer an element type because more than one type is possible</source>
        <target state="translated">두 개 이상의 형식이 가능하므로 요소 형식을 유추할 수 없음</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_TypeInferenceAssumed3">
        <source>Data type of '{0}' in '{1}' could not be inferred. '{2}' assumed.</source>
        <target state="translated">'{1}'에 있는 '{0}'의 데이터 형식을 유추할 수 없습니다. '{2}'(으)로 간주합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_TypeInferenceAssumed3_Title">
        <source>Data type could not be inferred</source>
        <target state="translated">데이터 형식을 유추할 수 없음</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AmbiguousCastConversion2">
        <source>Option Strict On does not allow implicit conversions from '{0}' to '{1}' because the conversion is ambiguous.</source>
        <target state="translated">변환이 모호하므로 Option Strict On에서는 '{0}'에서 '{1}'(으)로 암시적으로 변환할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_AmbiguousCastConversion2">
        <source>Conversion from '{0}' to '{1}' may be ambiguous.</source>
        <target state="translated">'{0}'에서 '{1}'(으)로의 변환이 모호할 수 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_AmbiguousCastConversion2_Title">
        <source>Conversion may be ambiguous</source>
        <target state="translated">변환이 모호할 수 있음</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_VarianceIEnumerableSuggestion3">
        <source>'{0}' cannot be converted to '{1}'. Consider using '{2}' instead.</source>
        <target state="translated">'{0}'을(를) '{1}'(으)로 변환할 수 없습니다. 대신 '{2}'을(를) 사용하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_VarianceIEnumerableSuggestion3">
        <source>'{0}' cannot be converted to '{1}'. Consider using '{2}' instead.</source>
        <target state="translated">'{0}'을(를) '{1}'(으)로 변환할 수 없습니다. 대신 '{2}'을(를) 사용하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_VarianceIEnumerableSuggestion3_Title">
        <source>Type cannot be converted to target collection type</source>
        <target state="translated">형식을 대상 컬렉션 형식으로 변환할 수 없음</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_VarianceConversionFailedIn6">
        <source>'{4}' cannot be converted to '{5}' because '{0}' is not derived from '{1}', as required for the 'In' generic parameter '{2}' in '{3}'.</source>
        <target state="translated">'{3}'에 있는 'In' 제네릭 매개 변수 '{2}'에 필요한 대로 '{0}'이(가) '{1}'에서 파생되지 않았으므로 '{4}'을(를) '{5}'(으)로 변환할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_VarianceConversionFailedOut6">
        <source>'{4}' cannot be converted to '{5}' because '{0}' is not derived from '{1}', as required for the 'Out' generic parameter '{2}' in '{3}'.</source>
        <target state="translated">'{3}'에 있는 'Out' 제네릭 매개 변수 '{2}'에 필요한 대로 '{0}'이(가) '{1}'에서 파생되지 않았으므로 '{4}'을(를) '{5}'(으)로 변환할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_VarianceConversionFailedIn6">
        <source>Implicit conversion from '{4}' to '{5}'; this conversion may fail because '{0}' is not derived from '{1}', as required for the 'In' generic parameter '{2}' in '{3}'.</source>
        <target state="translated">'{4}'에서 '{5}'(으)로 암시적 변환을 수행합니다. '{3}'에 있는 'In' 제네릭 매개 변수 '{2}'에 필요한 대로 '{0}'이(가) '{1}'에서 파생되지 않았으므로 이 변환 작업을 수행하지 못할 수 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_VarianceConversionFailedIn6_Title">
        <source>Implicit conversion; this conversion may fail because the target type is not derived from the source type, as required for 'In' generic parameter</source>
        <target state="translated">암시적 변환임, 'In' 제네릭 매개 변수에 필요한 것처럼 대상 형식이 소스 형식에서 파생되지 않았으므로 이 변환은 실패할 수 있음</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_VarianceConversionFailedOut6">
        <source>Implicit conversion from '{4}' to '{5}'; this conversion may fail because '{0}' is not derived from '{1}', as required for the 'Out' generic parameter '{2}' in '{3}'.</source>
        <target state="translated">'{4}'에서 '{5}'(으)로 암시적 변환을 수행합니다. '{3}'에 있는 'Out' 제네릭 매개 변수 '{2}'에 필요한 대로 '{0}'이(가) '{1}'에서 파생되지 않았으므로 이 변환 작업을 수행하지 못할 수 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_VarianceConversionFailedOut6_Title">
        <source>Implicit conversion; this conversion may fail because the target type is not derived from the source type, as required for 'Out' generic parameter</source>
        <target state="translated">암시적 변환임, 'Out' 제네릭 매개 변수에 필요한 것처럼 대상 형식이 소스 형식에서 파생되지 않았으므로 이 변환은 실패할 수 있음</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_VarianceConversionFailedTryIn4">
        <source>'{0}' cannot be converted to '{1}'. Consider changing the '{2}' in the definition of '{3}' to an In type parameter, 'In {2}'.</source>
        <target state="translated">'{0}'을(를) '{1}'(으)로 변환할 수 없습니다. '{3}'의 정의에 있는 '{2}'을(를) In 형식 매개 변수 'In {2}'(으)로 변경하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_VarianceConversionFailedTryOut4">
        <source>'{0}' cannot be converted to '{1}'. Consider changing the '{2}' in the definition of '{3}' to an Out type parameter, 'Out {2}'.</source>
        <target state="translated">'{0}'을(를) '{1}'(으)로 변환할 수 없습니다. '{3}'의 정의에 있는 '{2}'을(를) Out 형식 매개 변수 'Out {2}'(으)로 변경하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_VarianceConversionFailedTryIn4">
        <source>'{0}' cannot be converted to '{1}'. Consider changing the '{2}' in the definition of '{3}' to an In type parameter, 'In {2}'.</source>
        <target state="translated">'{0}'을(를) '{1}'(으)로 변환할 수 없습니다. '{3}'의 정의에 있는 '{2}'을(를) In 형식 매개 변수 'In {2}'(으)로 변경하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_VarianceConversionFailedTryIn4_Title">
        <source>Type cannot be converted to target type</source>
        <target state="translated">형식을 대상 형식으로 변환할 수 없음</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_VarianceConversionFailedTryOut4">
        <source>'{0}' cannot be converted to '{1}'. Consider changing the '{2}' in the definition of '{3}' to an Out type parameter, 'Out {2}'.</source>
        <target state="translated">'{0}'을(를) '{1}'(으)로 변환할 수 없습니다. '{3}'의 정의에 있는 '{2}'을(를) Out 형식 매개 변수 'Out {2}'(으)로 변경하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_VarianceConversionFailedTryOut4_Title">
        <source>Type cannot be converted to target type</source>
        <target state="translated">형식을 대상 형식으로 변환할 수 없음</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_VarianceDeclarationAmbiguous3">
        <source>Interface '{0}' is ambiguous with another implemented interface '{1}' due to the 'In' and 'Out' parameters in '{2}'.</source>
        <target state="translated">'{2}'에 있는 'In' 및 'Out' 매개 변수로 인해 '{0}' 인터페이스가 구현된 다른 인터페이스 '{1}'에 대해 모호합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_VarianceDeclarationAmbiguous3_Title">
        <source>Interface is ambiguous with another implemented interface due to 'In' and 'Out' parameters</source>
        <target state="translated">In' 및 'Out' 매개 변수로 인해 인터페이스와 다른 구현된 인터페이스를 구별하기가 모호함</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_VarianceInterfaceNesting">
        <source>Enumerations, classes, and structures cannot be declared in an interface that has an 'In' or 'Out' type parameter.</source>
        <target state="translated">열거형, 클래스 및 구조체는 'In' 또는 'Out' 형식 매개 변수가 있는 인터페이스에서 선언할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_VariancePreventsSynthesizedEvents2">
        <source>Event definitions with parameters are not allowed in an interface such as '{0}' that has 'In' or 'Out' type parameters. Consider declaring the event by using a delegate type which is not defined within '{0}'. For example, 'Event {1} As Action(Of ...)'.</source>
        <target state="translated">In' 또는 'Out' 형식 매개 변수가 있는 '{0}'과(와) 같은 인터페이스에는 매개 변수가 있는 이벤트 정의를 사용할 수 없습니다. '{0}' 내에 정의되지 않은 대리자 형식을 사용하여 이벤트를 선언하세요(예: 'Event {1} As Action(Of ...)').</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_VarianceInByRefDisallowed1">
        <source>Type '{0}' cannot be used in this context because 'In' and 'Out' type parameters cannot be used for ByRef parameter types, and '{0}' is an 'In' type parameter.</source>
        <target state="translated">ByRef 매개 변수 형식에는 'In' 및 'Out' 형식 매개 변수를 사용할 수 없고 '{0}'이(가) 'In' 형식 매개 변수이므로, '{0}' 형식을 이 컨텍스트에서 사용할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_VarianceInNullableDisallowed2">
        <source>Type '{0}' cannot be used in '{1}' because 'In' and 'Out' type parameters cannot be made nullable, and '{0}' is an 'In' type parameter.</source>
        <target state="translated">In' 및 'Out' 형식 매개 변수를 null 허용 형식으로 만들 수 없고 '{0}'이(가) 'In' 형식 매개 변수이므로, '{0}' 형식을 '{1}'에 사용할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_VarianceInParamDisallowed1">
        <source>Type '{0}' cannot be used in this context because '{0}' is an 'In' type parameter.</source>
        <target state="translated">'{0}'이(가) 'In' 형식 매개 변수이므로 '{0}' 형식을 이 컨텍스트에서 사용할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_VarianceInParamDisallowedForGeneric3">
        <source>Type '{0}' cannot be used for the '{1}' in '{2}' in this context because '{0}' is an 'In' type parameter.</source>
        <target state="translated">'{0}'이(가) 'In' 형식 매개 변수이므로 '{0}' 형식을 이 컨텍스트에서 '{2}'에 있는 '{1}'에는 사용할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_VarianceInParamDisallowedHere2">
        <source>Type '{0}' cannot be used in '{1}' in this context because '{0}' is an 'In' type parameter.</source>
        <target state="translated">'{0}'이(가) 'In' 형식 매개 변수이므로 '{0}' 형식을 이 컨텍스트에서 '{1}'에 사용할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_VarianceInParamDisallowedHereForGeneric4">
        <source>Type '{0}' cannot be used for the '{2}' of '{3}' in '{1}' in this context because '{0}' is an 'In' type parameter.</source>
        <target state="translated">'{0}'이(가) 'In' 형식 매개 변수이므로 '{0}' 형식을 이 컨텍스트에서 '{1}'에 있는 '{3}'의 '{2}'에는 사용할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_VarianceInPropertyDisallowed1">
        <source>Type '{0}' cannot be used as a property type in this context because '{0}' is an 'In' type parameter and the property is not marked WriteOnly.</source>
        <target state="translated">'{0}'이(가) 'In' 형식 매개 변수이며 속성이 WriteOnly로 표시되어 있지 않으므로 '{0}' 형식을 이 컨텍스트에서 속성 형식으로 사용할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_VarianceInReadOnlyPropertyDisallowed1">
        <source>Type '{0}' cannot be used as a ReadOnly property type because '{0}' is an 'In' type parameter.</source>
        <target state="translated">'{0}'이(가) 'In' 형식 매개 변수이므로 '{0}' 형식을 ReadOnly 속성 형식으로 사용할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_VarianceInReturnDisallowed1">
        <source>Type '{0}' cannot be used as a return type because '{0}' is an 'In' type parameter.</source>
        <target state="translated">'{0}'이(가) 'In' 형식 매개 변수이므로 '{0}' 형식을 반환 형식으로 사용할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_VarianceOutByRefDisallowed1">
        <source>Type '{0}' cannot be used in this context because 'In' and 'Out' type parameters cannot be used for ByRef parameter types, and '{0}' is an 'Out' type parameter.</source>
        <target state="translated">ByRef 매개 변수 형식에는 'In' 및 'Out' 형식 매개 변수를 사용할 수 없고 '{0}'이(가) 'Out' 형식 매개 변수이므로, '{0}' 형식을 이 컨텍스트에서 사용할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_VarianceOutByValDisallowed1">
        <source>Type '{0}' cannot be used as a ByVal parameter type because '{0}' is an 'Out' type parameter.</source>
        <target state="translated">'{0}'이(가) 'Out' 형식 매개 변수이므로 '{0}' 형식을 ByVal 매개 변수 형식으로 사용할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_VarianceOutConstraintDisallowed1">
        <source>Type '{0}' cannot be used as a generic type constraint because '{0}' is an 'Out' type parameter.</source>
        <target state="translated">'{0}'이(가) 'Out' 형식 매개 변수이므로 '{0}' 형식을 제네릭 형식 제약 조건으로 사용할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_VarianceOutNullableDisallowed2">
        <source>Type '{0}' cannot be used in '{1}' because 'In' and 'Out' type parameters cannot be made nullable, and '{0}' is an 'Out' type parameter.</source>
        <target state="translated">In' 및 'Out' 형식 매개 변수를 null 허용 형식으로 만들 수 없고 '{0}'이(가) 'Out' 형식 매개 변수이므로, '{0}' 형식을 '{1}'에 사용할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_VarianceOutParamDisallowed1">
        <source>Type '{0}' cannot be used in this context because '{0}' is an 'Out' type parameter.</source>
        <target state="translated">'{0}'이(가) 'Out' 형식 매개 변수이므로 '{0}' 형식을 이 컨텍스트에서 사용할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_VarianceOutParamDisallowedForGeneric3">
        <source>Type '{0}' cannot be used for the '{1}' in '{2}' in this context because '{0}' is an 'Out' type parameter.</source>
        <target state="translated">'{0}'이(가) 'Out' 형식 매개 변수이므로 '{0}' 형식을 이 컨텍스트에서 '{2}'에 있는 '{1}'에는 사용할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_VarianceOutParamDisallowedHere2">
        <source>Type '{0}' cannot be used in '{1}' in this context because '{0}' is an 'Out' type parameter.</source>
        <target state="translated">'{0}'이(가) 'Out' 형식 매개 변수이므로 '{0}' 형식을 이 컨텍스트에서 '{1}'에 사용할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_VarianceOutParamDisallowedHereForGeneric4">
        <source>Type '{0}' cannot be used for the '{2}' of '{3}' in '{1}' in this context because '{0}' is an 'Out' type parameter.</source>
        <target state="translated">'{0}'이(가) 'Out' 형식 매개 변수이므로 '{0}' 형식을 이 컨텍스트에서 '{1}'에 있는 '{3}'의 '{2}'에는 사용할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_VarianceOutPropertyDisallowed1">
        <source>Type '{0}' cannot be used as a property type in this context because '{0}' is an 'Out' type parameter and the property is not marked ReadOnly.</source>
        <target state="translated">'{0}'이(가) 'Out' 형식 매개 변수이고 속성이 ReadOnly로 표시되어 있지 않으므로, '{0}' 형식을 이 컨텍스트에서 속성 형식으로 사용할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_VarianceOutWriteOnlyPropertyDisallowed1">
        <source>Type '{0}' cannot be used as a WriteOnly property type because '{0}' is an 'Out' type parameter.</source>
        <target state="translated">'{0}'이(가) 'Out' 형식 매개 변수이므로 '{0}' 형식을 WriteOnly 속성 형식으로 사용할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_VarianceTypeDisallowed2">
        <source>Type '{0}' cannot be used in this context because both the context and the definition of '{0}' are nested within interface '{1}', and '{1}' has 'In' or 'Out' type parameters. Consider moving the definition of '{0}' outside of '{1}'.</source>
        <target state="translated">'{0}'의 컨텍스트와 정의가 모두 '{1}' 인터페이스 안에 중첩되어 있고 '{1}'에 'In' 또는 'Out' 형식 매개 변수가 있으므로, '{0}' 형식을 이 컨텍스트에서 사용할 수 없습니다. '{0}'의 정의를 '{1}' 외부로 이동하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_VarianceTypeDisallowedForGeneric4">
        <source>Type '{0}' cannot be used for the '{2}' in '{3}' in this context because both the context and the definition of '{0}' are nested within interface '{1}', and '{1}' has 'In' or 'Out' type parameters. Consider moving the definition of '{0}' outside of '{1}'.</source>
        <target state="translated">'{0}'의 컨텍스트와 정의가 모두 '{1}' 인터페이스 안에 중첩되어 있고 '{1}'에 'In' 또는 'Out' 형식 매개 변수가 있으므로, '{0}' 형식을 이 컨텍스트에서 '{3}'에 있는 '{2}'에 대해 사용할 수 없습니다. '{0}'의 정의를 '{1}' 외부로 이동하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_VarianceTypeDisallowedHere3">
        <source>Type '{0}' cannot be used in '{2}' in this context because both the context and the definition of '{0}' are nested within interface '{1}', and '{1}' has 'In' or 'Out' type parameters. Consider moving the definition of '{0}' outside of '{1}'.</source>
        <target state="translated">'{0}'의 컨텍스트와 정의가 모두 '{1}' 인터페이스 안에 중첩되어 있고 '{1}'에 'In' 또는 'Out' 형식 매개 변수가 있으므로, '{0}' 형식을 이 컨텍스트에서 '{2}'에 사용할 수 없습니다. '{0}'의 정의를 '{1}' 외부로 이동하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_VarianceTypeDisallowedHereForGeneric5">
        <source>Type '{0}' cannot be used for the '{3}' of '{4}' in '{2}' in this context because both the context and the definition of '{0}' are nested within interface '{1}', and '{1}' has 'In' or 'Out' type parameters. Consider moving the definition of '{0}' outside of '{1}'.</source>
        <target state="translated">'{0}'의 컨텍스트와 정의가 모두 '{1}' 인터페이스 안에 중첩되어 있고 '{1}'에 'In' 또는 'Out' 형식 매개 변수가 있으므로, '{0}' 형식을 이 컨텍스트에서 '{2}'에 있는 '{4}'의 '{3}'에 대해 사용할 수 없습니다. '{0}'의 정의를 '{1}' 외부로 이동하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ParameterNotValidForType">
        <source>Parameter not valid for the specified unmanaged type.</source>
        <target state="translated">지정한 관리되지 않은 형식에 대한 매개 변수가 잘못되었습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_MarshalUnmanagedTypeNotValidForFields">
        <source>Unmanaged type '{0}' not valid for fields.</source>
        <target state="translated">관리되지 않은 형식 '{0}'은(는) 필드에서 유효하지 않습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_MarshalUnmanagedTypeOnlyValidForFields">
        <source>Unmanaged type '{0}' is only valid for fields.</source>
        <target state="translated">관리되지 않은 형식 '{0}'은(는) 필드에서만 유효합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AttributeParameterRequired1">
        <source>Attribute parameter '{0}' must be specified.</source>
        <target state="translated">'{0}' 특성 매개 변수를 지정해야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AttributeParameterRequired2">
        <source>Attribute parameter '{0}' or '{1}' must be specified.</source>
        <target state="translated">'{0}' 또는 '{1}' 특성 매개 변수를 지정해야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_MemberConflictWithSynth4">
        <source>Conflicts with '{0}', which is implicitly declared for '{1}' in {2} '{3}'.</source>
        <target state="translated">{2} '{3}'의 '{1}'에 대해 암시적으로 선언된 '{0}'과(와) 충돌합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_ProjectSettingsLocationName">
        <source>&lt;project settings&gt;</source>
        <target state="translated">&lt;프로젝트 설정&gt;</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_ReturnTypeAttributeOnWriteOnlyProperty">
        <source>Attributes applied on a return type of a WriteOnly Property have no effect.</source>
        <target state="translated">WriteOnly 속성의 반환 형식에 적용된 특성은 효과가 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_ReturnTypeAttributeOnWriteOnlyProperty_Title">
        <source>Attributes applied on a return type of a WriteOnly Property have no effect</source>
        <target state="translated">WriteOnly 속성의 반환 형식에 적용된 특성은 효과가 없음</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_SecurityAttributeInvalidTarget">
        <source>Security attribute '{0}' is not valid on this declaration type. Security attributes are only valid on assembly, type and method declarations.</source>
        <target state="translated">이 선언 형식에서는 '{0}' 보안 특성이 유효하지 않습니다. 보안 특성은 어셈블리, 형식 및 메서드 선언에서만 유효합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AbsentReferenceToPIA1">
        <source>Cannot find the interop type that matches the embedded type '{0}'. Are you missing an assembly reference?</source>
        <target state="translated">포함된 형식 '{0}'과(와) 일치하는 interop 형식을 찾을 수 없습니다. 어셈블리 참조가 있는지 확인하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CannotLinkClassWithNoPIA1">
        <source>Reference to class '{0}' is not allowed when its assembly is configured to embed interop types.</source>
        <target state="translated">해당 어셈블리가 interop 형식을 포함하도록 구성되어 있으면 '{0}' 클래스에 대한 참조를 사용할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InvalidStructMemberNoPIA1">
        <source>Embedded interop structure '{0}' can contain only public instance fields.</source>
        <target state="translated">포함된 interop 구조체 '{0}'은(는) public 인스턴스 필드만 포함할 수 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NoPIAAttributeMissing2">
        <source>Interop type '{0}' cannot be embedded because it is missing the required '{1}' attribute.</source>
        <target state="translated">필수 '{1}' 특성이 없으므로 Interop 형식 '{0}'을(를) 포함할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PIAHasNoAssemblyGuid1">
        <source>Cannot embed interop types from assembly '{0}' because it is missing the '{1}' attribute.</source>
        <target state="translated">어셈블리 '{0}'에 '{1}' 특성이 없으므로 이 어셈블리의 interop 형식을 포함할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DuplicateLocalTypes3">
        <source>Cannot embed interop type '{0}' found in both assembly '{1}' and '{2}'. Consider disabling the embedding of interop types.</source>
        <target state="translated">어셈블리 '{1}'과(와) '{2}'에 모두 있는 interop 형식 '{0}'을(를) 포함할 수 없습니다. interop 형식을 포함하지 않도록 설정하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PIAHasNoTypeLibAttribute1">
        <source>Cannot embed interop types from assembly '{0}' because it is missing either the '{1}' attribute or the '{2}' attribute.</source>
        <target state="translated">어셈블리 '{0}'에 '{1}' 특성 또는 '{2}' 특성이 없으므로 이 어셈블리의 interop 형식을 포함할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_SourceInterfaceMustBeInterface">
        <source>Interface '{0}' has an invalid source interface which is required to embed event '{1}'.</source>
        <target state="translated">'{0}' 인터페이스에는 '{1}' 이벤트를 포함하는 데 필요한 소스 인터페이스가 잘못 포함되어 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_EventNoPIANoBackingMember">
        <source>Source interface '{0}' is missing method '{1}', which is required to embed event '{2}'.</source>
        <target state="translated">소스 인터페이스 '{0}'에 '{2}' 이벤트를 포함하는 데 필요한 '{1}' 메서드가 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NestedInteropType">
        <source>Nested type '{0}' cannot be embedded.</source>
        <target state="translated">'{0}' 중첩 형식을 포함할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_LocalTypeNameClash2">
        <source>Embedding the interop type '{0}' from assembly '{1}' causes a name clash in the current assembly. Consider disabling the embedding of interop types.</source>
        <target state="translated">'{1}' 어셈블리의 interop 형식 '{0}'을(를) 포함하면 현재 어셈블리에서 이름이 충돌합니다. interop 형식을 포함하지 않도록 설정하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InteropMethodWithBody1">
        <source>Embedded interop method '{0}' contains a body.</source>
        <target state="translated">포함된 interop 메서드 '{0}'에 본문이 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadAsyncInQuery">
        <source>'Await' may only be used in a query expression within the first collection expression of the initial 'From' clause or within the collection expression of a 'Join' clause.</source>
        <target state="translated">'Await'는 초기 'From' 절의 첫 번째 Collection 식이나 'Join' 절의 Collection 식 내의 쿼리 식에서만 사용할 수 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadGetAwaiterMethod1">
        <source>'Await' requires that the type '{0}' have a suitable GetAwaiter method.</source>
        <target state="translated">'Await'의 경우 {0} 형식에 적합한 GetAwaiter 메서드가 있어야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadIsCompletedOnCompletedGetResult2">
        <source>'Await' requires that the return type '{0}' of '{1}.GetAwaiter()' have suitable IsCompleted, OnCompleted and GetResult members, and implement INotifyCompletion or ICriticalNotifyCompletion.</source>
        <target state="translated">'Await'의 경우 '{1}.GetAwaiter()'의 반환 형식 '{0}'에 적합한 IsCompleted, OnCompleted 및 GetResult 멤버가 있어야 하며 INotifyCompletion 또는 ICriticalNotifyCompletion을 구현해야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DoesntImplementAwaitInterface2">
        <source>'{0}' does not implement '{1}'.</source>
        <target state="translated">'{0}'은(는) '{1}'을(를) 구현하지 않습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadAwaitNothing">
        <source>Cannot await Nothing. Consider awaiting 'Task.Yield()' instead.</source>
        <target state="translated">Nothing에 await를 사용할 수 없습니다. 대신 'Task.Yield()'에 await를 사용하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadAsyncByRefParam">
        <source>Async methods cannot have ByRef parameters.</source>
        <target state="translated">비동기 메서드에는 ByRef 매개 변수를 사용할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InvalidAsyncIteratorModifiers">
        <source>'Async' and 'Iterator' modifiers cannot be used together.</source>
        <target state="translated">'Async' 및 'Iterator' 한정자는 함께 사용할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadResumableAccessReturnVariable">
        <source>The implicit return variable of an Iterator or Async method cannot be accessed.</source>
        <target state="translated">반복기 또는 비동기 메서드의 암시적 반환 변수에 액세스할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ReturnFromNonGenericTaskAsync">
        <source>'Return' statements in this Async method cannot return a value since the return type of the function is 'Task'. Consider changing the function's return type to 'Task(Of T)'.</source>
        <target state="translated">'이 비동기 메서드의 'Return' 문은 함수의 반환 형식이 'Task'이기 때문에 값을 반환할 수 없습니다. 함수의 반환 형식을 'Task(Of T)'로 변경하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadAsyncReturnOperand1">
        <source>Since this is an async method, the return expression must be of type '{0}' rather than 'Task(Of {0})'.</source>
        <target state="translated">비동기 메서드이기 때문에 이 메서드의 반환 식은 'Task(Of {0})' 형식이 아니라 '{0}' 형식이어야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadAsyncReturn">
        <source>The 'Async' modifier can only be used on Subs, or on Functions that return Task or Task(Of T).</source>
        <target state="translated">Async' 한정자는 Task 또는 Task(Of T)를 반환하는 Sub 또는 함수에서만 사용할 수 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CantAwaitAsyncSub1">
        <source>'{0}' does not return a Task and cannot be awaited. Consider changing it to an Async Function.</source>
        <target state="translated">'{0}'은(는) Task를 반환하지 않으므로 await를 사용할 수 없습니다. 비동기 함수로 변경하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InvalidLambdaModifier">
        <source>'Only the 'Async' or 'Iterator' modifier is valid on a lambda.</source>
        <target state="translated">'람다에서는 'Async' 또는 'Iterator' 한정자만 유효합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadAwaitInNonAsyncMethod">
        <source>'Await' can only be used within an Async method. Consider marking this method with the 'Async' modifier and changing its return type to 'Task(Of {0})'.</source>
        <target state="translated">'Await'는 비동기 메서드 내에서만 사용할 수 있습니다. 'Async' 한정자로 이 메서드를 표시하고 해당 반환 형식을 'Task(Of {0})'로 변경하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadAwaitInNonAsyncVoidMethod">
        <source>'Await' can only be used within an Async method. Consider marking this method with the 'Async' modifier and changing its return type to 'Task'.</source>
        <target state="translated">'Await'는 비동기 메서드 내에서만 사용할 수 있습니다. 'Async' 한정자로 이 메서드를 표시하고 해당 반환 형식을 'Task'로 변경하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadAwaitInNonAsyncLambda">
        <source>'Await' can only be used within an Async lambda expression. Consider marking this lambda expression with the 'Async' modifier.</source>
        <target state="translated">'Await'는 Async 람다 식 내에서만 사용할 수 있습니다. 'Async' 한정자로 이 람다 식을 표시하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadAwaitNotInAsyncMethodOrLambda">
        <source>'Await' can only be used when contained within a method or lambda expression marked with the 'Async' modifier.</source>
        <target state="translated">'Await'는 'Async' 한정자로 표시된 메서드나 람다 식 내에 포함된 경우에만 사용할 수 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_StatementLambdaInExpressionTree">
        <source>Statement lambdas cannot be converted to expression trees.</source>
        <target state="translated">문 람다를 식 트리로 변환할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UnobservedAwaitableExpression">
        <source>Because this call is not awaited, execution of the current method continues before the call is completed. Consider applying the Await operator to the result of the call.</source>
        <target state="translated">이 호출이 대기되지 않으므로 호출이 완료되기 전에 현재 메서드가 계속 실행됩니다. 호출 결과에 Await 연산자를 적용해 보세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UnobservedAwaitableExpression_Title">
        <source>Because this call is not awaited, execution of the current method continues before the call is completed</source>
        <target state="translated">이 호출을 대기하지 않으므로 호출이 완료되기 전에 현재 메서드가 계속 실행됩니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_LoopControlMustNotAwait">
        <source>Loop control variable cannot include an 'Await'.</source>
        <target state="translated">루프 제어 변수에는 'Await'를 포함할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadStaticInitializerInResumable">
        <source>Static variables cannot appear inside Async or Iterator methods.</source>
        <target state="translated">정적 변수는 비동기 또는 리터럴 메서드 내에 나타날 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RestrictedResumableType1">
        <source>'{0}' cannot be used as a parameter type for an Iterator or Async method.</source>
        <target state="translated">'{0}'은(는) 반복기 또는 비동기 메서드의 매개 변수 형식으로 사용할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ConstructorAsync">
        <source>Constructor must not have the 'Async' modifier.</source>
        <target state="translated">생성자에는 'Async' 한정자를 사용하면 안 됩니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PartialMethodsMustNotBeAsync1">
        <source>'{0}' cannot be declared 'Partial' because it has the 'Async' modifier.</source>
        <target state="translated">'{0}'은(는) 'Async' 한정자가 있으므로 'Partial'로 선언할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ResumablesCannotContainOnError">
        <source>'On Error' and 'Resume' cannot appear inside async or iterator methods.</source>
        <target state="translated">'On Error' 및 'Resume'은 비동기 또는 반복기 메서드 내에 표시될 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ResumableLambdaInExpressionTree">
        <source>Lambdas with the 'Async' or 'Iterator' modifiers cannot be converted to expression trees.</source>
        <target state="translated">Async' 또는 'Iterator' 한정자가 있는 람다는 식 트리로 변환할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CannotLiftRestrictedTypeResumable1">
        <source>Variable of restricted type '{0}' cannot be declared in an Async or Iterator method.</source>
        <target state="translated">제한된 '{0}' 형식의 변수는 비동기 또는 반복기 메서드에서 선언할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadAwaitInTryHandler">
        <source>'Await' cannot be used inside a 'Catch' statement, a 'Finally' statement, or a 'SyncLock' statement.</source>
        <target state="translated">'Await'는 'Catch' 문, 'Finally' 문 또는 'SyncLock' 문 내에서 사용할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_AsyncLacksAwaits">
        <source>This async method lacks 'Await' operators and so will run synchronously. Consider using the 'Await' operator to await non-blocking API calls, or 'Await Task.Run(...)' to do CPU-bound work on a background thread.</source>
        <target state="translated">이 비동기 메서드에는 'Await' 연산자가 없으며 메서드가 동시에 실행됩니다. 'Await' 연산자를 사용하여 비블로킹 API 호출을 대기하거나 'Await Task.Run(...)'을 사용하여 백그라운드 스레드에서 CPU 바인딩된 작업을 수행하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_AsyncLacksAwaits_Title">
        <source>This async method lacks 'Await' operators and so will run synchronously</source>
        <target state="translated">이 비동기 메서드에는 'Await' 연산자가 없으며 메서드가 동시에 실행됨</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UnobservedAwaitableDelegate">
        <source>The Task returned from this Async Function will be dropped, and any exceptions in it ignored. Consider changing it to an Async Sub so its exceptions are propagated.</source>
        <target state="translated">이 비동기 함수에서 반환된 Task가 삭제되고 작업의 예외가 무시됩니다. 예외가 전파되도록 비동기 Sub로 변경해 보세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UnobservedAwaitableDelegate_Title">
        <source>The Task returned from this Async Function will be dropped, and any exceptions in it ignored</source>
        <target state="translated">이 비동기 함수에서 반환된 Task가 삭제되고 작업의 예외가 무시됨</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_SecurityCriticalAsyncInClassOrStruct">
        <source>Async and Iterator methods are not allowed in a [Class|Structure|Interface|Module] that has the 'SecurityCritical' or 'SecuritySafeCritical' attribute.</source>
        <target state="translated">특성이 'SecurityCritical' 또는 'SecuritySafeCritical'인 [Class|Structure|Interface|Module]에서는 비동기 및 반복기 메서드가 허용되지 않습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_SecurityCriticalAsync">
        <source>Security attribute '{0}' cannot be applied to an Async or Iterator method.</source>
        <target state="translated">'{0}' 보안 특성은 비동기 또는 반복기 메서드에 적용할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DllImportOnResumableMethod">
        <source>'System.Runtime.InteropServices.DllImportAttribute' cannot be applied to an Async or Iterator method.</source>
        <target state="translated">'System.Runtime.InteropServices.DllImportAttribute'는 비동기 또는 반복기 메서드에 적용할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_SynchronizedAsyncMethod">
        <source>'MethodImplOptions.Synchronized' cannot be applied to an Async method.</source>
        <target state="translated">'MethodImplOptions.Synchronized'는 비동기 메서드에 적용할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AsyncSubMain">
        <source>The 'Main' method cannot be marked 'Async'.</source>
        <target state="translated">Main' 메서드는 'Async'로 표시할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_AsyncSubCouldBeFunction">
        <source>Some overloads here take an Async Function rather than an Async Sub. Consider either using an Async Function, or casting this Async Sub explicitly to the desired type.</source>
        <target state="translated">여기서 일부 오버로드는 비동기 Sub 대신 비동기 함수를 받아들입니다. 비동기 함수를 사용하거나 명시적으로 이 비동기 Sub를 원하는 형식으로 캐스팅하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_AsyncSubCouldBeFunction_Title">
        <source>Some overloads here take an Async Function rather than an Async Sub</source>
        <target state="translated">여기서 일부 오버로드는 비동기 Sub 대신 비동기 함수를 받아들임</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_MyGroupCollectionAttributeCycle">
        <source>MyGroupCollectionAttribute cannot be applied to itself.</source>
        <target state="translated">MyGroupCollectionAttribute를 자체적으로 적용할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_LiteralExpected">
        <source>Literal expected.</source>
        <target state="translated">리터럴이 필요합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_WinRTEventWithoutDelegate">
        <source>Event declarations that target WinMD must specify a delegate type.  Add an As clause to the event declaration.</source>
        <target state="translated">WinMD를 대상으로 하는 이벤트 선언은 대리자 형식을 지정해야 합니다.  이벤트 선언에 As 절을 추가합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_MixingWinRTAndNETEvents">
        <source>Event '{0}' cannot implement a Windows Runtime event '{1}' and a regular .NET event '{2}'</source>
        <target state="translated">'{0}' 이벤트에서 Windows Runtime 이벤트 '{1}'과(와) 일반 .NET 이벤트 '{2}'을(를) 모두 구현할 수는 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_EventImplRemoveHandlerParamWrong">
        <source>Event '{0}' cannot implement event '{1}' on interface '{2}' because the parameters of their 'RemoveHandler' methods do not match.</source>
        <target state="translated">RemoveHandler' 메서드의 매개 변수가 일치하지 않으므로 '{0}' 이벤트에서 '{2}' 인터페이스에 대해 '{1}' 이벤트를 구현할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AddParamWrongForWinRT">
        <source>The type of the 'AddHandler' method's parameter must be the same as the type of the event.</source>
        <target state="translated">AddHandler' 메서드 매개 변수의 형식은 이벤트 형식과 같아야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RemoveParamWrongForWinRT">
        <source>In a Windows Runtime event, the type of the 'RemoveHandler' method parameter must be 'EventRegistrationToken'</source>
        <target state="translated">Windows 런타임 이벤트에서 'RemoveHandler' 메서드 매개 변수의 형식은 'EventRegistrationToken'이어야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ReImplementingWinRTInterface5">
        <source>'{0}.{1}' from 'implements {2}' is already implemented by the base class '{3}'. Re-implementation of Windows Runtime Interface '{4}' is not allowed</source>
        <target state="translated">'implements {0}'에서 구현된 '{1}.{2}'은(는) 기본 클래스 '{3}'에 의해 이미 구현되었습니다. Windows Runtime 인터페이스 '{4}'을(를) 다시 구현할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ReImplementingWinRTInterface4">
        <source>'{0}.{1}' is already implemented by the base class '{2}'. Re-implementation of Windows Runtime Interface '{3}' is not allowed</source>
        <target state="translated">'{0}.{1}'은(는) 기본 클래스 '{2}'에 의해 이미 구현되었습니다. Windows Runtime 인터페이스 '{3}'을(를) 다시 구현할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadIteratorByRefParam">
        <source>Iterator methods cannot have ByRef parameters.</source>
        <target state="translated">반복기 메서드에는 ByRef 매개 변수를 사용할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadIteratorExpressionLambda">
        <source>Single-line lambdas cannot have the 'Iterator' modifier. Use a multiline lambda instead.</source>
        <target state="translated">한 줄 람다에는 'Iterator' 한정자를 사용할 수 없습니다. 대신 여러 줄 람다를 사용하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadIteratorReturn">
        <source>Iterator functions must return either IEnumerable(Of T), or IEnumerator(Of T), or the non-generic forms IEnumerable or IEnumerator.</source>
        <target state="translated">반복기 함수는 IEnumerable(Of T), IEnumerator(Of T) 또는 제네릭이 아닌 폼 IEnumerable 또는 IEnumerator를 반환해야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadReturnValueInIterator">
        <source>To return a value from an Iterator function, use 'Yield' rather than 'Return'.</source>
        <target state="translated">반복기 함수의 값을 반환하려면 'Return' 대신 'Yield'를 사용하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadYieldInNonIteratorMethod">
        <source>'Yield' can only be used in a method marked with the 'Iterator' modifier.</source>
        <target state="translated">'Yield'는 'Iterator' 한정자로 표시된 메서드에서만 사용할 수 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadYieldInTryHandler">
        <source>'Yield' cannot be used inside a 'Catch' statement or a 'Finally' statement.</source>
        <target state="translated">'Yield'는 'Catch' 문이나 'Finally' 문 내에서 사용할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_DefAsgNoRetValWinRtEventVal1">
        <source>The AddHandler for Windows Runtime event '{0}' doesn't return a value on all code paths. Are you missing a 'Return' statement?</source>
        <target state="translated">Windows Runtime용 AddHandler 이벤트 '{0}'이(가) 일부 코드 경로에서만 값을 반환합니다. 'Return' 문이 있는지 확인하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_DefAsgNoRetValWinRtEventVal1_Title">
        <source>The AddHandler for Windows Runtime event doesn't return a value on all code paths</source>
        <target state="translated">Windows 런타임 이벤트에 대한 AddHandler가 일부 코드 경로의 값을 반환하지 않음</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PartialMethodDefaultParameterValueMismatch2">
        <source>Optional parameter of a method '{0}' does not have the same default value as the corresponding parameter of the partial method '{1}'.</source>
        <target state="translated">'{0}' 메서드의 선택적 매개 변수에는 '{1}' 부분 메서드(Partial Method)에 해당하는 매개 변수와 동일한 기본값이 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PartialMethodParamArrayMismatch2">
        <source>Parameter of a method '{0}' differs by ParamArray modifier from the corresponding parameter of the partial method '{1}'.</source>
        <target state="translated">'{0}' 메서드의 매개 변수는 '{1}' 부분 메서드(Partial Method)에 해당하는 매개 변수의 ParamArray 한정자와 다릅니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NetModuleNameMismatch">
        <source>Module name '{0}' stored in '{1}' must match its filename.</source>
        <target state="translated">'{1}'에 저장된 '{0}' 모듈 이름은 파일 이름과 일치해야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadModuleName">
        <source>Invalid module name: {0}</source>
        <target state="translated">잘못된 모듈 이름: {0}</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_AssemblyAttributeFromModuleIsOverridden">
        <source>Attribute '{0}' from module '{1}' will be ignored in favor of the instance appearing in source.</source>
        <target state="translated">'{1}' 모듈의 '{0}' 특성은 소스에 나타나는 인스턴스를 위해 무시됩니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_AssemblyAttributeFromModuleIsOverridden_Title">
        <source>Attribute from module will be ignored in favor of the instance appearing in source</source>
        <target state="translated">모듈의 특성이 무시되고 소스에 표시되는 인스턴스가 대신 사용됨</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CmdOptionConflictsSource">
        <source>Attribute '{0}' given in a source file conflicts with option '{1}'.</source>
        <target state="translated">소스 파일에 지정된 '{0}' 특성이 '{1}' 옵션과 충돌합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_ReferencedAssemblyDoesNotHaveStrongName">
        <source>Referenced assembly '{0}' does not have a strong name.</source>
        <target state="translated">참조된 어셈블리 '{0}'에 강력한 이름이 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_ReferencedAssemblyDoesNotHaveStrongName_Title">
        <source>Referenced assembly does not have a strong name</source>
        <target state="translated">참조된 어셈블리는 강력한 이름을 사용하지 않습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InvalidSignaturePublicKey">
        <source>Invalid signature public key specified in AssemblySignatureKeyAttribute.</source>
        <target state="translated">AssemblySignatureKeyAttribute에 잘못된 시그니처 공개 키가 지정되었습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CollisionWithPublicTypeInModule">
        <source>Type '{0}' conflicts with public type defined in added module '{1}'.</source>
        <target state="translated">'{0}' 형식이 추가된 모듈 '{1}'에 정의된 public 형식과 충돌합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExportedTypeConflictsWithDeclaration">
        <source>Type '{0}' exported from module '{1}' conflicts with type declared in primary module of this assembly.</source>
        <target state="translated">'{1}' 모듈에서 내보낸 '{0}' 형식이 이 어셈블리의 주 모듈에서 선언된 형식과 충돌합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExportedTypesConflict">
        <source>Type '{0}' exported from module '{1}' conflicts with type '{2}' exported from module '{3}'.</source>
        <target state="translated">'{1}' 모듈에서 내보낸 '{0}' 형식이 '{3}' 모델에서 내보낸 '{2}' 형식과 충돌합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_RefCultureMismatch">
        <source>Referenced assembly '{0}' has different culture setting of '{1}'.</source>
        <target state="translated">참조된 어셈블리 '{0}'에 다른 '{1}' 문화권 설정이 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_RefCultureMismatch_Title">
        <source>Referenced assembly has different culture setting</source>
        <target state="translated">참조된 어셈블리의 문화권 설정이 다릅니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_AgnosticToMachineModule">
        <source>Agnostic assembly cannot have a processor specific module '{0}'.</source>
        <target state="translated">알 수 없는 어셈블리는 프로세서의 특정 모듈('{0}')을 포함할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ConflictingMachineModule">
        <source>Assembly and module '{0}' cannot target different processors.</source>
        <target state="translated">어셈블리 및 '{0}' 모듈은 다른 프로세서를 대상으로 할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_ConflictingMachineAssembly">
        <source>Referenced assembly '{0}' targets a different processor.</source>
        <target state="translated">참조된 어셈블리 '{0}'이(가) 다른 프로세서를 대상으로 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_ConflictingMachineAssembly_Title">
        <source>Referenced assembly targets a different processor</source>
        <target state="translated">참조된 어셈블리가 다른 프로세서를 대상으로 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CryptoHashFailed">
        <source>Cryptographic failure while creating hashes.</source>
        <target state="translated">해시를 만드는 동안 암호화 오류가 발생했습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CantHaveWin32ResAndManifest">
        <source>Conflicting options specified: Win32 resource file; Win32 manifest.</source>
        <target state="translated">Win32 리소스 파일과 Win32 매니페스트는 서로 충돌하므로 함께 지정할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ForwardedTypeConflictsWithDeclaration">
        <source>Forwarded type '{0}' conflicts with type declared in primary module of this assembly.</source>
        <target state="translated">전달된 '{0}' 형식이 이 어셈블리의 주 모듈에서 선언된 형식과 충돌합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ForwardedTypesConflict">
        <source>Type '{0}' forwarded to assembly '{1}' conflicts with type '{2}' forwarded to assembly '{3}'.</source>
        <target state="translated">'{1}' 어셈블리로 전달된 '{0}' 형식이 '{3}' 어셈블리로 전달된 '{2}' 형식과 충돌합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_TooLongMetadataName">
        <source>Name '{0}' exceeds the maximum length allowed in metadata.</source>
        <target state="translated">'{0}' 이름이 메타데이터에 허용된 최대 길이를 초과했습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_MissingNetModuleReference">
        <source>Reference to '{0}' netmodule missing.</source>
        <target state="translated">'{0}' netmodule에 대한 참조가 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NetModuleNameMustBeUnique">
        <source>Module '{0}' is already defined in this assembly. Each module must have a unique filename.</source>
        <target state="translated">'{0}' 모듈이 이 어셈블리에 이미 정의되었습니다. 각 모듈에 고유한 파일 이름이 있어야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ForwardedTypeConflictsWithExportedType">
        <source>Type '{0}' forwarded to assembly '{1}' conflicts with type '{2}' exported from module '{3}'.</source>
        <target state="translated">'{1}' 어셈블리로 전달된 '{0}' 형식이 '{3}'에서 내보낸 '{2}' 형식과 충돌합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_MSG_ADDREFERENCE">
        <source>Adding assembly reference '{0}'</source>
        <target state="translated">'{0}' 어셈블리 참조 추가 중</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_MSG_ADDLINKREFERENCE">
        <source>Adding embedded assembly reference '{0}'</source>
        <target state="translated">포함된 '{0}' 어셈블리 참조 추가 중</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_MSG_ADDMODULE">
        <source>Adding module reference '{0}'</source>
        <target state="translated">'{0}' 모듈 참조 추가 중</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NestingViolatesCLS1">
        <source>Type '{0}' does not inherit the generic type parameters of its container.</source>
        <target state="translated">'{0}' 형식이 해당 컨테이너의 제네릭 형식 매개 변수를 상속하지 않습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PDBWritingFailed">
        <source>Failure writing debug information: {0}</source>
        <target state="translated">디버그 정보를 쓰지 못했습니다({0}).</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ParamDefaultValueDiffersFromAttribute">
        <source>The parameter has multiple distinct default values.</source>
        <target state="translated">매개 변수에 고유한 기본값이 여러 개 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_FieldHasMultipleDistinctConstantValues">
        <source>The field has multiple distinct constant values.</source>
        <target state="translated">필드에 고유한 상수 값이 여러 개 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_EncNoPIAReference">
        <source>Cannot continue since the edit includes a reference to an embedded type: '{0}'.</source>
        <target state="translated">편집의 포함된 형식 '{0}'에 대한 참조가 포함되어 있어 계속할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_EncReferenceToAddedMember">
        <source>Member '{0}' added during the current debug session can only be accessed from within its declaring assembly '{1}'.</source>
        <target state="translated">현재 디버그 세션 중에 추가되는 '{0}' 멤버는 해당 선언 어셈블리 '{1}' 내에서만 액세스할 수 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_UnsupportedModule1">
        <source>'{0}' is an unsupported .NET module.</source>
        <target state="translated">'{0}'은(는) 지원되지 않는 .NET 모듈입니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_UnsupportedEvent1">
        <source>'{0}' is an unsupported event.</source>
        <target state="translated">'{0}'은(는) 지원되지 않는 이벤트입니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="PropertiesCanNotHaveTypeArguments">
        <source>Properties can not have type arguments</source>
        <target state="translated">속성에 형식 인수를 사용할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="IdentifierSyntaxNotWithinSyntaxTree">
        <source>IdentifierSyntax not within syntax tree</source>
        <target state="translated">구문 트리 내에 IdentifierSyntax가 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="AnonymousObjectCreationExpressionSyntaxNotWithinTree">
        <source>AnonymousObjectCreationExpressionSyntax not within syntax tree</source>
        <target state="translated">AnonymousObjectCreationExpressionSyntax가 구문 트리 내에 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="FieldInitializerSyntaxNotWithinSyntaxTree">
        <source>FieldInitializerSyntax not within syntax tree</source>
        <target state="translated">구문 트리 내에 FieldInitializerSyntax가 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_TheSystemCannotFindThePathSpecified">
        <source>The system cannot find the path specified</source>
        <target state="translated">시스템이 지정한 경로를 찾을 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ThereAreNoPointerTypesInVB">
        <source>There are no pointer types in VB.</source>
        <target state="translated">VB에 포인터 형식이 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ThereIsNoDynamicTypeInVB">
        <source>There is no dynamic type in VB.</source>
        <target state="translated">VB에 동적 형식이 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="VariableSyntaxNotWithinSyntaxTree">
        <source>variableSyntax not within syntax tree</source>
        <target state="translated">구문 트리 내에 variableSyntax가 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="AggregateSyntaxNotWithinSyntaxTree">
        <source>AggregateSyntax not within syntax tree</source>
        <target state="translated">AggregateSyntax가 구문 트리 내에 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="FunctionSyntaxNotWithinSyntaxTree">
        <source>FunctionSyntax not within syntax tree</source>
        <target state="translated">구문 트리 내에 FunctionSyntax가 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="PositionIsNotWithinSyntax">
        <source>Position is not within syntax tree</source>
        <target state="translated">위치가 구문 트리 내에 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="RangeVariableSyntaxNotWithinSyntaxTree">
        <source>RangeVariableSyntax not within syntax tree</source>
        <target state="translated">구문 트리 내에 RangeVariableSyntax가 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="DeclarationSyntaxNotWithinSyntaxTree">
        <source>DeclarationSyntax not within syntax tree</source>
        <target state="translated">DeclarationSyntax가 구문 트리 내에 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="StatementOrExpressionIsNotAValidType">
        <source>StatementOrExpression is not an ExecutableStatementSyntax or an ExpressionSyntax</source>
        <target state="translated">StatementOrExpression은 ExecutableStatementSyntax 또는 ExpressionSyntax가 아닙니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="DeclarationSyntaxNotWithinTree">
        <source>DeclarationSyntax not within tree</source>
        <target state="translated">DeclarationSyntax가 트리 내에 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="TypeParameterNotWithinTree">
        <source>TypeParameter not within tree</source>
        <target state="translated">트리 내에 TypeParameter가 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="NotWithinTree">
        <source> not within tree</source>
        <target state="translated"> 트리 내에 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="LocationMustBeProvided">
        <source>Location must be provided in order to provide minimal type qualification.</source>
        <target state="translated">최소 형식 한정자를 제공하려면 위치를 제공해야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="SemanticModelMustBeProvided">
        <source>SemanticModel must be provided in order to provide minimal type qualification.</source>
        <target state="translated">최소 형식 한정자를 제공하려면 SemanticModel을 제공해야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="NumberOfTypeParametersAndArgumentsMustMatch">
        <source>the number of type parameters and arguments should be the same</source>
        <target state="translated">형식 매개 변수와 인수 수가 같아야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ResourceInModule">
        <source>Cannot link resource files when building a module</source>
        <target state="translated">모듈을 빌드하는 동안 리소스 파일을 링크할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="NotAVbSymbol">
        <source>Not a VB symbol.</source>
        <target state="translated">VB 기호가 아닙니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ElementsCannotBeNull">
        <source>Elements cannot be null.</source>
        <target state="translated">요소는 null일 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="HDN_UnusedImportClause">
        <source>Unused import clause.</source>
        <target state="translated">사용하지 않는 import 절입니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="HDN_UnusedImportStatement">
        <source>Unused import statement.</source>
        <target state="translated">사용하지 않는 import 문입니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="WrongSemanticModelType">
        <source>Expected a {0} SemanticModel.</source>
        <target state="translated">{0} SemanticModel이 필요합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="PositionNotWithinTree">
        <source>Position must be within span of the syntax tree.</source>
        <target state="translated">위치는 구문 트리 범위 내에 있어야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="SpeculatedSyntaxNodeCannotBelongToCurrentCompilation">
        <source>Syntax node to be speculated cannot belong to a syntax tree from the current compilation.</source>
        <target state="translated">추측한 구문 노드는 현재 컴파일에서 구문 트리에 속할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ChainingSpeculativeModelIsNotSupported">
        <source>Chaining speculative semantic model is not supported. You should create a speculative model from the non-speculative ParentModel.</source>
        <target state="translated">이론적 의미 체계 모델 연결은 지원되지 않습니다. 비이론적 ParentModel에서 이론적 모델을 만들어야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_ToolName">
        <source>Microsoft (R) Visual Basic Compiler</source>
        <target state="translated">Microsoft (R) Visual Basic 컴파일러</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_LogoLine1">
        <source>{0} version {1}</source>
        <target state="translated">{0} 버전 {1}</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_LogoLine2">
        <source>Copyright (C) Microsoft Corporation. All rights reserved.</source>
        <target state="translated">Copyright (C) Microsoft Corporation. All rights reserved.</target>
        <note />
      </trans-unit>
      <trans-unit id="IDS_LangVersions">
        <source>Supported language versions:</source>
        <target state="translated">지원되는 언어 버전:</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_PdbLocalNameTooLong">
        <source>Local name '{0}' is too long for PDB.  Consider shortening or compiling without /debug.</source>
        <target state="translated">PDB에 대한 '{0}' 로컬 이름이 너무 깁니다. 줄이거나 /debug 없이 컴파일하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_PdbLocalNameTooLong_Title">
        <source>Local name is too long for PDB</source>
        <target state="translated">로컬 이름이 너무 길어서 PDB에 사용할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_PdbUsingNameTooLong">
        <source>Import string '{0}' is too long for PDB.  Consider shortening or compiling without /debug.</source>
        <target state="translated">PDB에 대한 '{0}' 가져오기 문자열이 너무 깁니다. 줄이거나 /debug 없이 컴파일하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_PdbUsingNameTooLong_Title">
        <source>Import string is too long for PDB</source>
        <target state="translated">가져오기 문자열이 너무 길어서 PDB에 사용할 수 없음</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_XMLDocCrefToTypeParameter">
        <source>XML comment has a tag with a 'cref' attribute '{0}' that bound to a type parameter.  Use the &lt;typeparamref&gt; tag instead.</source>
        <target state="translated">XML 주석에 형식 매개 변수로 바인딩되는 'cref' 특성('{0}')이 포함된 태그가 있습니다. 대신 &lt;typeparamref&gt; 태그를 사용하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_XMLDocCrefToTypeParameter_Title">
        <source>XML comment has a tag with a 'cref' attribute that bound to a type parameter</source>
        <target state="translated">XML 주석에 형식 매개 변수에 바인딩된 'cref' 특성이 포함된 태그가 있음</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_LinkedNetmoduleMetadataMustProvideFullPEImage">
        <source>Linked netmodule metadata must provide a full PE image: '{0}'.</source>
        <target state="translated">링크된 netmodule 메타데이터는 전체 PE 이미지를 제공해야 합니다. '{0}'</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_AnalyzerCannotBeCreated">
        <source>An instance of analyzer {0} cannot be created from {1} : {2}.</source>
        <target state="translated">{0} 분석기 인스턴스는 {1}에서 만들 수 없습니다({2}).</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_AnalyzerCannotBeCreated_Title">
        <source>Instance of analyzer cannot be created</source>
        <target state="translated">분석기 인스턴스를 만들 수 없음</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NoAnalyzerInAssembly">
        <source>The assembly {0} does not contain any analyzers.</source>
        <target state="translated">{0} 어셈블리에는 분석기가 포함되어 있지 않습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_NoAnalyzerInAssembly_Title">
        <source>Assembly does not contain any analyzers</source>
        <target state="translated">어셈블리에는 분석기가 포함되어 있지 않습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UnableToLoadAnalyzer">
        <source>Unable to load analyzer assembly {0} : {1}.</source>
        <target state="translated">{0} 분석기 어셈블리를 로드할 수 없습니다({1}).</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_UnableToLoadAnalyzer_Title">
        <source>Unable to load analyzer assembly</source>
        <target state="translated">분석기 어셈블리를 로드할 수 없음</target>
        <note />
      </trans-unit>
      <trans-unit id="INF_UnableToLoadSomeTypesInAnalyzer">
        <source>Skipping some types in analyzer assembly {0} due to a ReflectionTypeLoadException : {1}.</source>
        <target state="translated">ReflectionTypeLoadException로 인해 {0} 분석기 어셈블리에서 일부 형식을 건너뜁니다({1}).</target>
        <note />
      </trans-unit>
      <trans-unit id="INF_UnableToLoadSomeTypesInAnalyzer_Title">
        <source>Skip loading types in analyzer assembly that fail due to a ReflectionTypeLoadException</source>
        <target state="translated">ReflectionTypeLoadException으로 인해 실패한 분석기 어셈블리에서 형식 로드를 건너뜀</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CantReadRulesetFile">
        <source>Error reading ruleset file {0} - {1}</source>
        <target state="translated">{0} ruleset 파일을 읽는 동안 오류가 발생했습니다. {1}</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PlatformDoesntSupport">
        <source>{0} is not supported in current project type.</source>
        <target state="translated">{0}은(는) 현재 프로젝트 형식에서 지원되지 않습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CantUseRequiredAttribute">
        <source>The RequiredAttribute attribute is not permitted on Visual Basic types.</source>
        <target state="translated">RequiredAttribute 특성은 Visual Basic 형식에서 허용되지 않습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_EncodinglessSyntaxTree">
        <source>Cannot emit debug information for a source text without encoding.</source>
        <target state="translated">인코딩하지 않고 원본 텍스트에 대한 디버그 정보를 생성할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InvalidFormatSpecifier">
        <source>'{0}' is not a valid format specifier</source>
        <target state="translated">'{0}'은(는) 유효한 서식 지정자가 아닙니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InvalidPreprocessorConstantType">
        <source>Preprocessor constant '{0}' of type '{1}' is not supported, only primitive types are allowed.</source>
        <target state="translated">'{1}' 형식의 전처리기 상수 '{0}'은(는) 지원되지 않습니다. 기본 형식만 허용됩니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExpectedWarningKeyword">
        <source>'Warning' expected.</source>
        <target state="translated">'Warning'이 필요합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CannotBeMadeNullable1">
        <source>'{0}' cannot be made nullable.</source>
        <target state="translated">'{0}'은(는) nullable이 될 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadConditionalWithRef">
        <source>Leading '?' can only appear inside a 'With' statement, but not inside an object member initializer.</source>
        <target state="translated">선행 '?'는 'With' 문 내에만 나타날 수 있고 개체 멤버 이니셜라이저 내에는 나타날 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NullPropagatingOpInExpressionTree">
        <source>A null propagating operator cannot be converted into an expression tree.</source>
        <target state="translated">null 전파 연산자는 식 트리로 변환할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_TooLongOrComplexExpression">
        <source>An expression is too long or complex to compile</source>
        <target state="translated">식이 너무 길거나 복잡하여 컴파일할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExpressionDoesntHaveName">
        <source>This expression does not have a name.</source>
        <target state="translated">이 식에는 이름이 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InvalidNameOfSubExpression">
        <source>This sub-expression cannot be used inside NameOf argument.</source>
        <target state="translated">이 부분식은 NameOf 인수 내부에서 사용할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_MethodTypeArgsUnexpected">
        <source>Method type arguments unexpected.</source>
        <target state="translated">예기치 않은 메서드 형식 인수입니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="NoNoneSearchCriteria">
        <source>SearchCriteria is expected.</source>
        <target state="translated">SearchCriteria가 필요합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InvalidAssemblyCulture">
        <source>Assembly culture strings may not contain embedded NUL characters.</source>
        <target state="translated">어셈블리 문화권 문자열에는 포함된 NUL 문자가 포함되지 않을 수 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InReferencedAssembly">
        <source>There is an error in a referenced assembly '{0}'.</source>
        <target state="translated">참조되는 어셈블리 '{0}'에 오류가 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InterpolationFormatWhitespace">
        <source>Format specifier may not contain trailing whitespace.</source>
        <target state="translated">서식 지정자에는 후행 공백이 포함될 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InterpolationAlignmentOutOfRange">
        <source>Alignment value is outside of the supported range.</source>
        <target state="translated">맞춤 값이 지원되는 범위를 벗어납니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InterpolatedStringFactoryError">
        <source>There were one or more errors emitting a call to {0}.{1}. Method or its return type may be missing or malformed.</source>
        <target state="translated">{0}.{1}에 대한 호출을 내보내는 동안 하나 이상의 오류가 발생했습니다. 메서드 또는 반환 형식이 없거나 잘못되었을 수 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="HDN_UnusedImportClause_Title">
        <source>Unused import clause</source>
        <target state="translated">사용하지 않는 import 절</target>
        <note />
      </trans-unit>
      <trans-unit id="HDN_UnusedImportStatement_Title">
        <source>Unused import statement</source>
        <target state="translated">사용하지 않는 import 문</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ConstantStringTooLong">
        <source>Length of String constant resulting from concatenation exceeds System.Int32.MaxValue.  Try splitting the string into multiple constants.</source>
        <target state="translated">연결에서 생성된 문자열 상수의 길이가 System.Int32.MaxValue를 초과합니다.  문자열을 여러 상수로 분할해 보세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_LanguageVersion">
        <source>Visual Basic {0} does not support {1}.</source>
        <target state="translated">Visual Basic {0}에서는 {1}을(를) 지원하지 않습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadPdbData">
        <source>Error reading debug information for '{0}'</source>
        <target state="translated">'{0}'에 대한 디버그 정보 읽기 오류</target>
        <note />
      </trans-unit>
      <trans-unit id="FEATURE_ArrayLiterals">
        <source>array literal expressions</source>
        <target state="translated">배열 리터럴 식</target>
        <note />
      </trans-unit>
      <trans-unit id="FEATURE_AsyncExpressions">
        <source>async methods or lambdas</source>
        <target state="translated">비동기 메서드 또는 람다</target>
        <note />
      </trans-unit>
      <trans-unit id="FEATURE_AutoProperties">
        <source>auto-implemented properties</source>
        <target state="translated">자동 구현 속성</target>
        <note />
      </trans-unit>
      <trans-unit id="FEATURE_ReadonlyAutoProperties">
        <source>readonly auto-implemented properties</source>
        <target state="translated">읽기 전용 자동 구현 속성</target>
        <note />
      </trans-unit>
      <trans-unit id="FEATURE_CoContraVariance">
        <source>variance</source>
        <target state="translated">가변성</target>
        <note />
      </trans-unit>
      <trans-unit id="FEATURE_CollectionInitializers">
        <source>collection initializers</source>
        <target state="translated">컬렉션 이니셜라이저</target>
        <note />
      </trans-unit>
      <trans-unit id="FEATURE_GlobalNamespace">
        <source>declaring a Global namespace</source>
        <target state="translated">전역 네임스페이스 선언</target>
        <note />
      </trans-unit>
      <trans-unit id="FEATURE_Iterators">
        <source>iterators</source>
        <target state="translated">반복기</target>
        <note />
      </trans-unit>
      <trans-unit id="FEATURE_LineContinuation">
        <source>implicit line continuation</source>
        <target state="translated">암시적 줄 연속</target>
        <note />
      </trans-unit>
      <trans-unit id="FEATURE_StatementLambdas">
        <source>multi-line lambda expressions</source>
        <target state="translated">여러 줄 람다 식</target>
        <note />
      </trans-unit>
      <trans-unit id="FEATURE_SubLambdas">
        <source>'Sub' lambda expressions</source>
        <target state="translated">'Sub' 람다 식</target>
        <note />
      </trans-unit>
      <trans-unit id="FEATURE_NullPropagatingOperator">
        <source>null conditional operations</source>
        <target state="translated">Null 조건부 연산</target>
        <note />
      </trans-unit>
      <trans-unit id="FEATURE_NameOfExpressions">
        <source>'nameof' expressions</source>
        <target state="translated">'nameof' 식</target>
        <note />
      </trans-unit>
      <trans-unit id="FEATURE_RegionsEverywhere">
        <source>region directives within method bodies or regions crossing boundaries of declaration blocks</source>
        <target state="translated">선언 블록의 경계에 걸쳐 있는 영역 또는 메서드 본문 내의 region 지시문</target>
        <note />
      </trans-unit>
      <trans-unit id="FEATURE_MultilineStringLiterals">
        <source>multiline string literals</source>
        <target state="translated">여러 줄 문자열 리터럴</target>
        <note />
      </trans-unit>
      <trans-unit id="FEATURE_CObjInAttributeArguments">
        <source>CObj in attribute arguments</source>
        <target state="translated">특성 인수의 CObj</target>
        <note />
      </trans-unit>
      <trans-unit id="FEATURE_LineContinuationComments">
        <source>line continuation comments</source>
        <target state="translated">줄 연속 설명</target>
        <note />
      </trans-unit>
      <trans-unit id="FEATURE_TypeOfIsNot">
        <source>TypeOf IsNot expression</source>
        <target state="translated">TypeOf IsNot 식</target>
        <note />
      </trans-unit>
      <trans-unit id="FEATURE_YearFirstDateLiterals">
        <source>year-first date literals</source>
        <target state="translated">연도 우선 날짜 리터럴</target>
        <note />
      </trans-unit>
      <trans-unit id="FEATURE_WarningDirectives">
        <source>warning directives</source>
        <target state="translated">warning 지시문</target>
        <note />
      </trans-unit>
      <trans-unit id="FEATURE_PartialModules">
        <source>partial modules</source>
        <target state="translated">부분 모듈</target>
        <note />
      </trans-unit>
      <trans-unit id="FEATURE_PartialInterfaces">
        <source>partial interfaces</source>
        <target state="translated">부분 인터페이스</target>
        <note />
      </trans-unit>
      <trans-unit id="FEATURE_ImplementingReadonlyOrWriteonlyPropertyWithReadwrite">
        <source>implementing read-only or write-only property with read-write property</source>
        <target state="translated">읽기/쓰기 속성을 사용하여 읽기 전용 또는 쓰기 전용 속성을 구현합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="FEATURE_DigitSeparators">
        <source>digit separators</source>
        <target state="translated">숫자 구분 기호</target>
        <note />
      </trans-unit>
      <trans-unit id="FEATURE_BinaryLiterals">
        <source>binary literals</source>
        <target state="translated">이진 리터럴</target>
        <note />
      </trans-unit>
      <trans-unit id="FEATURE_Tuples">
        <source>tuples</source>
        <target state="translated">튜플</target>
        <note />
      </trans-unit>
      <trans-unit id="FEATURE_PrivateProtected">
        <source>Private Protected</source>
        <target state="translated">Private Protected</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DebugEntryPointNotSourceMethodDefinition">
        <source>Debug entry point must be a definition of a method declared in the current compilation.</source>
        <target state="translated">디버그 진입점은 현재 컴파일에서 선언된 메서드의 정의여야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InvalidPathMap">
        <source>The pathmap option was incorrectly formatted.</source>
        <target state="translated">pathmap 옵션의 형식이 잘못되었습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="SyntaxTreeIsNotASubmission">
        <source>Syntax tree should be created from a submission.</source>
        <target state="translated">구문 트리가 전송에서 만들어져야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_TooManyUserStrings">
        <source>Combined length of user strings used by the program exceeds allowed limit. Try to decrease use of string or XML literals.</source>
        <target state="translated">프로그램에서 사용하는 사용자 문자열의 결합된 길이가 허용 한도를 초과합니다. 문자열이나 XML 리터럴의 사용을 줄여 보세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_PeWritingFailure">
        <source>An error occurred while writing the output file: {0}</source>
        <target state="translated">출력 파일을 쓰는 동안 오류가 발생함: {0}</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_OptionMustBeAbsolutePath">
        <source>Option '{0}' must be an absolute path.</source>
        <target state="translated">옵션 '{0}'은(는) 절대 경로여야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_SourceLinkRequiresPdb">
        <source>/sourcelink switch is only supported when emitting PDB.</source>
        <target state="translated">/sourcelink 스위치는 PDB를 내보낼 때만 지원됩니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_TupleDuplicateElementName">
        <source>Tuple element names must be unique.</source>
        <target state="translated">튜플 요소 이름은 고유해야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_TupleLiteralNameMismatch">
        <source>The tuple element name '{0}' is ignored because a different name or no name is specified by the target type '{1}'.</source>
        <target state="translated">튜플 요소 이름 '{0}'은(는) 대상 형식 '{1}'에서 다른 이름이 지정되었거나 이름이 지정되지 않았기 때문에 무시됩니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_TupleLiteralNameMismatch_Title">
        <source>The tuple element name is ignored because a different name or no name is specified by the assignment target.</source>
        <target state="translated">튜플 요소 이름은 할당 대상에서 다른 이름이 지정되었거나 이름이 지정되지 않았기 때문에 무시됩니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_TupleReservedElementName">
        <source>Tuple element name '{0}' is only allowed at position {1}.</source>
        <target state="translated">튜플 요소 이름 '{0}'은(는) {1} 위치에서만 허용됩니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_TupleReservedElementNameAnyPosition">
        <source>Tuple element name '{0}' is disallowed at any position.</source>
        <target state="translated">튜플 요소 이름 '{0}'은(는) 어떤 위치에서도 허용되지 않습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_TupleTooFewElements">
        <source>Tuple must contain at least two elements.</source>
        <target state="translated">튜플에는 요소가 두 개 이상 있어야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_TupleElementNamesAttributeMissing">
        <source>Cannot define a class or member that utilizes tuples because the compiler required type '{0}' cannot be found. Are you missing a reference?</source>
        <target state="translated">컴파일러에서 요구하는 '{0}' 형식을 찾지 못했기 때문에 튜플을 사용하는 클래스 또는 멤버를 정의할 수 없습니다. 참조가 있는지 확인하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ExplicitTupleElementNamesAttribute">
        <source>Cannot reference 'System.Runtime.CompilerServices.TupleElementNamesAttribute' explicitly. Use the tuple syntax to define tuple names.</source>
        <target state="translated">System.Runtime.CompilerServices.TupleElementNamesAttribute'를 명시적으로 참조할 수 없습니다. 튜플 구문을 사용하여 튜플 이름을 정의하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_RefReturningCallInExpressionTree">
        <source>An expression tree may not contain a call to a method or property that returns by reference.</source>
        <target state="translated">식 트리에는 참조로 반환하는 메서드 또는 속성에 대한 호출을 사용할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_CannotEmbedWithoutPdb">
        <source>/embed switch is only supported when emitting a PDB.</source>
        <target state="translated">/embed 스위치는 PDB를 내보낼 때만 지원됩니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InvalidInstrumentationKind">
        <source>Invalid instrumentation kind: {0}</source>
        <target state="translated">잘못된 계측 종류: {0}</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_DocFileGen">
        <source>Error writing to XML documentation file: {0}</source>
        <target state="translated">XML 문서 파일 쓰기 오류: {0}</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadAssemblyName">
        <source>Invalid assembly name: {0}</source>
        <target state="translated">잘못된 어셈블리 이름: {0}</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_TypeForwardedToMultipleAssemblies">
        <source>Module '{0}' in assembly '{1}' is forwarding the type '{2}' to multiple assemblies: '{3}' and '{4}'.</source>
        <target state="translated">'{1}' 어셈블리의 '{0}' 모듈이 여러 어셈블리 '{3}' 및 '{4}'에 '{2}' 형식을 전달하고 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_Merge_conflict_marker_encountered">
        <source>Merge conflict marker encountered</source>
        <target state="translated">병합 충돌 표식을 발견했습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NoRefOutWhenRefOnly">
        <source>Do not use refout when using refonly.</source>
        <target state="translated">refonly를 사용할 때 refout을 사용하면 안 됩니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_NoNetModuleOutputWhenRefOutOrRefOnly">
        <source>Cannot compile net modules when using /refout or /refonly.</source>
        <target state="translated">/refout 또는 /refonly를 사용할 때 NET 모듈을 컴파일할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadNonTrailingNamedArgument">
        <source>Named argument '{0}' is used out-of-position but is followed by an unnamed argument</source>
        <target state="translated">명명된 인수 '{0}'은(는) 잘못된 위치에 사용되었지만 뒤에 명명되지 않은 인수가 옵니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadDocumentationMode">
        <source>Provided documentation mode is unsupported or invalid: '{0}'.</source>
        <target state="translated">제공한 문서 모드가 지원되지 않거나 잘못되었습니다. '{0}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadLanguageVersion">
        <source>Provided language version is unsupported or invalid: '{0}'.</source>
        <target state="translated">제공한 언어 버전이 지원되지 않거나 잘못되었습니다. '{0}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_BadSourceCodeKind">
        <source>Provided source code kind is unsupported or invalid: '{0}'</source>
        <target state="translated">제공된 소스 코드 종류가 지원되지 않거나 잘못되었습니다. '{0}'</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_TupleInferredNamesNotAvailable">
        <source>Tuple element name '{0}' is inferred. Please use language version {1} or greater to access an element by its inferred name.</source>
        <target state="translated">튜플 요소 이름 '{0}'이(가) 유추됩니다. 언어 버전 {1} 이상을 사용하여 유추된 이름으로 요소에 액세스하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_Experimental">
        <source>'{0}' is for evaluation purposes only and is subject to change or removal in future updates.</source>
        <target state="translated">'{0}'은(는) 평가 목적으로 제공되며, 이후 업데이트에서 변경되거나 제거될 수 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_Experimental_Title">
        <source>Type is for evaluation purposes only and is subject to change or removal in future updates.</source>
        <target state="translated">형식은 평가 목적으로 제공되며, 이후 업데이트에서 변경되거나 제거될 수 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InvalidDebugInfo">
        <source>Unable to read debug information of method '{0}' (token 0x{1}) from assembly '{2}'</source>
        <target state="translated">'{2}' 어셈블리에서 '{0}' 메서드(토큰 0x{1})의 디버그 정보를 읽을 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="IConversionExpressionIsNotVisualBasicConversion">
        <source>{0} is not a valid Visual Basic conversion expression</source>
        <target state="translated">{0}은(는) 유효한 Visual Basic 변환 식이 아닙니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="IArgumentIsNotVisualBasicArgument">
        <source>{0} is not a valid Visual Basic argument</source>
        <target state="translated">{0}은(는) 유효한 Visual Basic 인수가 아닙니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="FEATURE_LeadingDigitSeparator">
        <source>leading digit separator</source>
        <target state="translated">선행 숫자 구분 기호</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_ValueTupleResolutionAmbiguous3">
        <source>Predefined type '{0}' is declared in multiple referenced assemblies: '{1}' and '{2}'</source>
        <target state="translated">미리 정의된 형식 '{0}'이(가) 여러 참조된 어셈블리('{1}' 및 '{2}')에서 선언되었습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ICompoundAssignmentOperationIsNotVisualBasicCompoundAssignment">
        <source>{0} is not a valid Visual Basic compound assignment operation</source>
        <target state="translated">{0}은(는) 유효한 Visual Basic 복합 할당 연산이 아닙니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ERR_InvalidHashAlgorithmName">
        <source>Invalid hash algorithm name: '{0}'</source>
        <target state="translated">잘못된 해시 알고리즘 이름: '{0}'</target>
        <note />
      </trans-unit>
      <trans-unit id="FEATURE_InterpolatedStrings">
        <source>interpolated strings</source>
        <target state="translated">보간된 문자열</target>
        <note />
      </trans-unit>
      <trans-unit id="FTL_InvalidInputFileName">
        <source>File name '{0}' is empty, contains invalid characters, has a drive specification without an absolute path, or is too long</source>
        <target state="translated">'{0}' 파일 이름이 비어 있거나, 잘못된 문자가 있거나, 절대 경로가 없는 드라이브 사양이 있거나, 너무 깁니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_AttributeNotSupportedInVB">
        <source>'{0}' is not supported in VB.</source>
        <target state="translated">'{0}'은(는) VB에서 지원되지 않습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="WRN_AttributeNotSupportedInVB_Title">
        <source>Attribute is not supported in VB</source>
        <target state="translated">특성은 VB에서 지원되지 않습니다.</target>
        <note />
      </trans-unit>
    </body>
  </file>
</xliff>