<?xml version="1.0" encoding="utf-8"?>
<!-- Copyright (c)  Microsoft.  All Rights Reserved.  Licensed under the Apache License, Version 2.0.  See License.txt in the project root for license information. -->


<!--

Most significant structural changes from native/LM trees:

   End statements are now part of the statement they belong to, instead of separate. Each kind of Block statement
   has its own node kind. Block is used for a block of statements. 

   ? (nullable) modifier is not part of identifiers, instead part of declarator and type.

   Language model did not have separate node for parenthesized argument list. Seemed like it occurred enough places to be worth its own node.
   
   AsClause node added to represent "As" plus a type and a derived class AsNewClause used for As New. Used in various places. Centralizes
   the fields associated with these constructs so that common code can use them.
   
   Instead of a single ArgumentNode, 3 different possible nodes: SimpleArgument, NamedArgument, RangeArgument
   
   HandlesClause, ImplementsClause split into own nodes that contain a list.

   Property declarations and Auto property declarations are merged into a single node type
   
   Parameters with and without optional values are merged into a single node type (is this really a good idea?)
   
   Variable declarations with normal type, "New" type and initializer merged into a single node type. 
   
   Most uses of "IdentifierNode" in LM became "Identifier" instead (which is more than a simple renaming, since IdentifierNode derived from NameNode in
   LM, but Identifier just inherits Token node and SimpleName is what inherits Name).
   
   If and ElseIf statements unified into a single structure with two kinds.
   
   CallStatement (renamed Invocation) has a single child of type CallOrIndex, instead of the target and argument list separated.
   
   The way literals are represented is tricky. We have to have all expression inherit Expression, but also all tokens inherit Token. So we 
   have a Literal node, with different Kinds and a Token field that has the token.
   
   QualifiedExpression split into MemberAccess (.identifier, !identifier, .@identifier) and XmlMemberAccess (.<x>, .@<x>, ...<x>), in order
   to get better typing of the right hand side.
   
   NewExpression, NewObjectInitializerExpression, CollectionInitializerExpression combined into NewObject.
   
   Lambda now represents by abstract class and two derived classes.
    
   LinqExpression and LinqOperatorExpression the same class. Use NULL source for the first query operator.
   
   Unify FromItem and LinqSource into the same node (CollectionRangeVariable).
   
   When FromExpression was used as the source of an Aggregate, instead use JoinOrAggregateSource.
   
   Remove CrossJoin node, just represent as FromOperators with a source.
-->

<!-- 

General TODO:

Look at use of word "Declaration" and make it consistent.
Look at use of word "Clause" and make it consistent.

Add XML Documentation in all the places it is needed.
Unify Enum declarations with other block type declarations.

-->

<!-- TODO: Add in "BadExpression",  etc. -->

<define-parse-tree namespace="Microsoft.CodeAnalysis.VisualBasic" visitor="VisualBasicSyntaxVisitor" rewrite-visitor="VisualBasicSyntaxRewriter" factory-class="SyntaxFactory" contextual-factory-class="ContextAwareSyntaxFactory" xmlns="http://schemas.microsoft.com/VisualStudio/Roslyn/Compiler" >
  <definitions>

    <!--
    <node-structure name="SyntaxNode" abstract="true" partial="true" predefined="true">
      <description>The base class for all nodes.</description>
      <lm-equiv name="SyntaxNode"></lm-equiv>
      <native-equiv name="ParseTreeNode"></native-equiv>
    </node-structure>
    -->

    <node-structure name="VisualBasicSyntaxNode" abstract="true" partial="true" predefined="true" root="true">
      <description>The base class for all nodes in the VB syntax tree.</description>
      <lm-equiv name="SyntaxNode"></lm-equiv>
      <native-equiv name="ParseTreeNode"></native-equiv>
    </node-structure>

    <!--<node-structure name="SyntaxNode" parent="VisualBasicSyntaxNode" abstract="true" partial="true">
      <description>The base class for all nodes in the VB syntax tree except tokens and trivia.</description>
     </node-structure>-->

    <!-- ************************************************************************************************** -->
    <!-- **  GENERAL STATEMENT PRIMITIVES                                                                ** -->
    <!-- ************************************************************************************************** -->

    <!--****************
      -  Statement
      ******************-->
    <node-structure name="StatementSyntax" parent="VisualBasicSyntaxNode" abstract="true">
      <description>
        The base class for all nodes that represent statements. This includes
        both declaration statements, such as class declarations as well as executable statements.
      </description>
      <lm-equiv name="StatementNode"></lm-equiv>
      <native-equiv name="Statement"></native-equiv>
      <native-equiv name="StatementList">
        The StatementList and Statement structures
        are combined into a single structure. The Previous/NextInBlock and Previous/NextLexical have no direct equivalent,
        helper routines for these operations are very easy to write.
      </native-equiv>
    </node-structure>

    <!--****************
      -  ExecutableStatement
      ******************-->
    <node-structure name="ExecutableStatementSyntax" parent="StatementSyntax" abstract="true">
      <description>
        The base class for all nodes that represent executable statements.
      </description>
    </node-structure>

    <!--****************
      -  MemberDeclaration
      ******************-->
    <node-structure name="DeclarationStatementSyntax" parent="StatementSyntax" abstract="true">
      <description>
        The base class for all nodes that represent statements that declare options, imports, members, etc.
      </description>
    </node-structure>

    <!--****************
      -  EmptyStatement
      ******************-->
    <node-structure name="EmptyStatementSyntax" parent="StatementSyntax">
      <description>
        A class to represent an empty statement.  This can occur when a colon is on a line without anything else.

      </description>
      <lm-equiv name="StatementNode"></lm-equiv>
      <native-equiv name="Statement"></native-equiv>

      <node-kind name="EmptyStatement">
        <native-equiv name="Statement.Opcodes.Empty" />
      </node-kind>

      <child name="Empty" kind="EmptyToken">
        <description>An empty token because all non terminals must have a token.</description>
      </child>
    </node-structure>

    <!--****************
      -  EndBlockStatement
      ******************-->
    <node-structure name="EndBlockStatementSyntax" parent="DeclarationStatementSyntax">
      <description>Represents an "End XXX" statement, where XXX is a single keyword.</description>
      <lm-equiv name="EndBlockNode"></lm-equiv>
      <native-equiv name=""></native-equiv>

      <node-kind name="EndIfStatement">
        <lm-equiv name="EndBlock" />
        <native-equiv name="Statement.Opcodes.EndIf" />
      </node-kind>
      <node-kind name="EndUsingStatement">
        <lm-equiv name="EndBlock" />
        <native-equiv name="Statement.Opcodes.EndUsing" />
      </node-kind>
      <node-kind name="EndWithStatement">
        <lm-equiv name="EndBlock" />
        <native-equiv name="Statement.Opcodes.EndWith" />
      </node-kind>
      <node-kind name="EndSelectStatement">
        <lm-equiv name="EndBlock" />
        <native-equiv name="Statement.Opcodes.EndSelect" />
      </node-kind>
      <node-kind name="EndStructureStatement">
        <lm-equiv name="EndBlock" />
        <native-equiv name="Statement.Opcodes.EndStructure" />
      </node-kind>
      <node-kind name="EndEnumStatement">
        <lm-equiv name="EndBlock" />
        <native-equiv name="Statement.Opcodes.EndEnum" />
      </node-kind>
      <node-kind name="EndInterfaceStatement">
        <lm-equiv name="EndBlock" />
        <native-equiv name="Statement.Opcodes.EndInterface" />
      </node-kind>
      <node-kind name="EndClassStatement">
        <lm-equiv name="EndBlock" />
        <native-equiv name="Statement.Opcodes.EndClass" />
      </node-kind>
      <node-kind name="EndModuleStatement">
        <lm-equiv name="EndBlock" />
        <native-equiv name="Statement.Opcodes.EndModule" />
      </node-kind>
      <node-kind name="EndNamespaceStatement">
        <lm-equiv name="EndBlock" />
        <native-equiv name="Statement.Opcodes.EndNamespace" />
      </node-kind>
      <node-kind name="EndSubStatement">
        <lm-equiv name="EndBlock" />
        <native-equiv name="Statement.Opcodes.EndSub" />
      </node-kind>
      <node-kind name="EndFunctionStatement">
        <lm-equiv name="EndBlock" />
        <native-equiv name="Statement.Opcodes.EndFunction" />
      </node-kind>
      <node-kind name="EndGetStatement">
        <lm-equiv name="EndBlock" />
        <native-equiv name="Statement.Opcodes.EndGet" />
      </node-kind>
      <node-kind name="EndSetStatement">
        <lm-equiv name="EndBlock" />
        <native-equiv name="Statement.Opcodes.EndSet" />
      </node-kind>
      <node-kind name="EndPropertyStatement">
        <lm-equiv name="EndBlock" />
        <native-equiv name="Statement.Opcodes.EndProperty" />
      </node-kind>
      <node-kind name="EndOperatorStatement">
        <lm-equiv name="EndBlock" />
        <native-equiv name="Statement.Opcodes.EndOperator" />
      </node-kind>
      <node-kind name="EndEventStatement">
        <lm-equiv name="EndBlock" />
        <native-equiv name="Statement.Opcodes.EndEvent" />
      </node-kind>
      <node-kind name="EndAddHandlerStatement">
        <lm-equiv name="EndBlock" />
        <native-equiv name="Statement.Opcodes.EndAddHandler" />
      </node-kind>
      <node-kind name="EndRemoveHandlerStatement">
        <lm-equiv name="EndBlock" />
        <native-equiv name="Statement.Opcodes.EndRemoveHandler" />
      </node-kind>
      <node-kind name="EndRaiseEventStatement">
        <lm-equiv name="EndBlock" />
        <native-equiv name="Statement.Opcodes.EndRaiseEvent" />
      </node-kind>
      <node-kind name="EndWhileStatement">
        <lm-equiv name="EndBlock" />
        <native-equiv name="Statement.Opcodes.EndWhile" />
      </node-kind>
      <node-kind name="EndTryStatement">
        <lm-equiv name="EndBlock" />
        <native-equiv name="Statement.Opcodes.EndTry" />
      </node-kind>
      <node-kind name="EndSyncLockStatement">
        <lm-equiv name="EndBlock" />
        <native-equiv name="Statement.Opcodes.EndSyncLock" />
      </node-kind>

      <child name="EndKeyword" kind="EndKeyword">
        <description>The "End" keyword</description>
        <lm-equiv name="EndKeyword"></lm-equiv>
        <native-equiv name=""></native-equiv>
      </child>

      <child name="BlockKeyword">
        <description>
          The keyword that ends the block. Must be one of:
          "If", "Using", "With", "Select", "Structure", "Enum", "Interface", "Class", "Module", "Namespace", "Sub", "Function", "Get, "Set", "Property", "Operator", "Event", "AddHandler", "RemoveHandler", "RaiseEvent", "While", "Try" or "SyncLock".
        </description>
        <lm-equiv name="Block"></lm-equiv>
        <native-equiv name=""></native-equiv>
        <kind name="IfKeyword" node-kind="EndIfStatement"/>
        <kind name="UsingKeyword" node-kind="EndUsingStatement"/>
        <kind name="WithKeyword" node-kind="EndWithStatement"/>
        <kind name="SelectKeyword" node-kind="EndSelectStatement"/>
        <kind name="StructureKeyword" node-kind="EndStructureStatement"/>
        <kind name="EnumKeyword" node-kind="EndEnumStatement"/>
        <kind name="InterfaceKeyword" node-kind="EndInterfaceStatement"/>
        <kind name="ClassKeyword" node-kind="EndClassStatement"/>
        <kind name="ModuleKeyword" node-kind="EndModuleStatement"/>
        <kind name="NamespaceKeyword" node-kind="EndNamespaceStatement"/>
        <kind name="SubKeyword" node-kind="EndSubStatement"/>
        <kind name="FunctionKeyword" node-kind="EndFunctionStatement"/>
        <kind name="GetKeyword" node-kind="EndGetStatement"/>
        <kind name="SetKeyword" node-kind="EndSetStatement"/>
        <kind name="PropertyKeyword" node-kind="EndPropertyStatement"/>
        <kind name="OperatorKeyword" node-kind="EndOperatorStatement"/>
        <kind name="EventKeyword" node-kind="EndEventStatement"/>
        <kind name="AddHandlerKeyword" node-kind="EndAddHandlerStatement"/>
        <kind name="RemoveHandlerKeyword" node-kind="EndRemoveHandlerStatement"/>
        <kind name="RaiseEventKeyword" node-kind="EndRaiseEventStatement"/>
        <kind name="WhileKeyword" node-kind="EndWhileStatement"/>
        <kind name="TryKeyword" node-kind="EndTryStatement"/>
        <kind name="SyncLockKeyword" node-kind="EndSyncLockStatement"/>
      </child>
    </node-structure>


    <!-- ************************************************************************************************** -->
    <!-- **  FILE LEVEL STATEMENTS (SOURCE FILE/OPTIONS/ATTRIBUTES/IMPORTS)                              ** -->
    <!-- ************************************************************************************************** -->

    <!--****************
      -  Program
      ******************-->
    <node-structure name="CompilationUnitSyntax" partial="true" parent="VisualBasicSyntaxNode">
      <description>Represents an entire source file of VB code.</description>
      <lm-equiv name="ProgramNode"></lm-equiv>
      <native-equiv name="FileBlockStatement"></native-equiv>

      <node-kind name="CompilationUnit">
        <lm-equiv name="Program" />
        <native-equiv name="Statement.Opcodes.File" />
      </node-kind>

      <!-- REVIEW: Instead, we could just have this be a StatementBody. The split up form will be easier
      for consumers to use, however. -->

      <child name="Options" optional="true" list="true"  kind="@OptionStatementSyntax">
        <description>Represents the list of Option statements at the beginning of a source file.</description>
        <lm-equiv name="ProgramNode.Contents">
          The ProgramNode.Contents statements are split up into
          OptionStatements, ImportStatements, AttributeStatements and TypeAndNamespaceDeclarations.
        </lm-equiv>
        <native-equiv name="FileBlockStatement.Children">
          The FileBlockStatement.Children statements are split up into
          OptionStatements, ImportStatements, AttributeStatements and TypeAndNamespaceDeclarations.
        </native-equiv>
      </child>

      <child name="Imports" optional="true" list="true"  kind="@ImportsStatementSyntax">
        <description>Represents the list of Imports statements at the beginning of a source file.</description>
        <lm-equiv name="ProgramNode.Contents">
          The ProgramNode.Contents statements are split up into
          OptionStatements, ImportStatements, AttributeStatements and TypeAndNamespaceDeclarations.
        </lm-equiv>
        <native-equiv name="FileBlockStatement.Children">
          The FileBlockStatement.Children statements are split up into
          OptionStatements, ImportStatements, AttributeStatements and TypeAndNamespaceDeclarations.
        </native-equiv>
      </child>

      <child name="Attributes" optional="true" list="true"   kind="AttributesStatement">
        <description>
          Represents the list of AttributeStatements at the beginning of a source file
          that contain the Assembly and Module attributes.
        </description>

        <lm-equiv name="ProgramNode.Contents">
          The ProgramNode.Contents statements are split up into
          OptionStatements, ImportStatements, AttributeStatements and TypeAndNamespaceDeclarations.
        </lm-equiv>

        <native-equiv name="FileBlockStatement.Children">
          The FileBlockStatement.Children statements are split up into
          OptionStatements, ImportStatements, AttributeStatements and TypeAndNamespaceDeclarations.
        </native-equiv>
      </child>

      <!-- TODO: Should the kind be more specific? -->
      <child name="Members" optional="true" list="true" kind="@StatementSyntax">
        <description>
          Represents the members of the default namespace for this source file: all
          the top-level type and namespace declarations in the file. May also contain Statements that are
          not valid
        </description>
        <lm-equiv name="ProgramNode.Contents">
          The ProgramNode.Contents statements are split up into
          OptionStatements, ImportStatements, AttributeStatements and TypeAndNamespaceDeclarations.
        </lm-equiv>
        <native-equiv name="FileBlockStatement.Children">
          The FileBlockStatement.Children statements are split up into
          OptionStatements, ImportStatements, AttributeStatements and TypeAndNamespaceDeclarations.
        </native-equiv>
      </child>

      <child name="EndOfFileToken" kind="EndOfFileToken">
        <description>
          Represents the end of the source file. This token may have trivia (whitespace, comments, ...)
          attached to it.
        </description>
      </child>

    </node-structure>

    <!--********************
      -  OptionStatement
      **********************-->
    <node-structure name="OptionStatementSyntax" parent="DeclarationStatementSyntax">
      <description>Represents an Option statement, such as "Option Strict On".</description>
      <lm-equiv name="OptionDirectiveNode"></lm-equiv>
      <native-equiv name="OptionStatement"></native-equiv>
      <spec-section>6.2</spec-section>
      <grammar>OptionStatement</grammar>

      <node-kind name="OptionStatement">
        <lm-equiv name="OptionDirective" />
        <native-equiv name="Statement.Opcodes.OptionCompareText" />
        <native-equiv name="Statement.Opcodes.OptionCompareBinary" />
        <native-equiv name="Statement.Opcodes.OptionExplicitOn" />
        <native-equiv name="Statement.Opcodes.OptionExplicitOff" />
        <native-equiv name="Statement.Opcodes.OptionStrictOn" />
        <native-equiv name="Statement.Opcodes.OptionStrictOff" />
        <native-equiv name="Statement.Opcodes.OptionInferOn" />
        <native-equiv name="Statement.Opcodes.OptionInferOff" />
      </node-kind>

      <child name="OptionKeyword" kind="OptionKeyword">
        <description>The "Option" keyword.</description>
        <lm-equiv name="OptionKeyword"></lm-equiv>
        <native-equiv name=""></native-equiv>
      </child>

      <child name="NameKeyword" kind="ExplicitKeyword|StrictKeyword|CompareKeyword|InferKeyword">
        <description>The keyword that identifies the option being set: Explicit, Strict, Compare or Infer.</description>
        <lm-equiv name="Name"></lm-equiv>
        <native-equiv name=""></native-equiv>
      </child>

      <child name="ValueKeyword" optional="true" kind="OnKeyword|OffKeyword|TextKeyword|BinaryKeyword">
        <description>The keyword that identifiers the value being set for the option: On, Off, Text or Binary.</description>
        <lm-equiv name="Value"></lm-equiv>
        <native-equiv name=""></native-equiv>
        <!-- TODO: constraint: Text and Binary iff CompareKeyword? -->
      </child>
    </node-structure>

    <!--********************
      -  ImportStatementNode
      **********************-->
    <node-structure name="ImportsStatementSyntax" parent="DeclarationStatementSyntax">
      <description>Represents an Imports statement, which has one or more imports clauses.</description>
      <lm-equiv name="ImportsDirectiveNode"></lm-equiv>
      <native-equiv name="ImportsStatement"></native-equiv>
      <spec-section>6.3</spec-section>
      <grammar>ImportsStatement</grammar>

      <node-kind name="ImportsStatement">
        <lm-equiv name="ImportsDirective" />
        <native-equiv name="" />
      </node-kind>

      <child name="ImportsKeyword" kind="ImportsKeyword">
        <description>The "Imports" keyword.</description>
        <lm-equiv name="ImportsKeyword"></lm-equiv>
        <native-equiv name=""></native-equiv>
      </child>

      <child name="ImportsClauses" optional="true" list="true" separator-kind="CommaToken" separator-name="Commas" kind="@ImportsClauseSyntax" min-count="1">
        <description>A list of one or more import clauses. Each clause is either an alias, namespace or XML namespace import.</description>
        <lm-equiv name="Imports"></lm-equiv>
        <native-equiv name="Imports"></native-equiv>
      </child>
    </node-structure>

    <node-structure name="ImportsClauseSyntax" parent="VisualBasicSyntaxNode" abstract="true">
      <description>The base class for the possible clauses of an Imports statement. </description>
      <lm-equiv name="ImportNode"></lm-equiv>
      <native-equiv name="ImportDirective"></native-equiv>
      <spec-section>6.3</spec-section>
      <grammar>ImportsClause</grammar>
    </node-structure>

    <!--********************
      -  SimpleImportsClause
      **********************-->
    <node-structure name="SimpleImportsClauseSyntax" parent="ImportsClauseSyntax">
      <description>Represents the clause of an Imports statement that imports all members of a type or namespace or aliases a type or namespace.</description>
      <lm-equiv name="ImportNameNode"></lm-equiv>
      <native-equiv name="NamespaceImportDirective"></native-equiv>

      <node-kind name="SimpleImportsClause">
        <lm-equiv name="ImportName" />
        <native-equiv name="Modes.XmlNamespace" />
        <!-- REVIEW: This looks wrong. -->
      </node-kind>

      <child name="Alias" kind="ImportAliasClause" optional="true">
        <description>An optional alias for the namespace or type being imported.</description>
      </child>

      <child name="Name" kind="@NameSyntax">
        <description>The namespace or type being imported.</description>
        <lm-equiv name="Name"></lm-equiv>
        <native-equiv name="ImportedName"></native-equiv>
      </child>
    </node-structure>

    <!--********************
      -  ImportAliasClauseSyntax
      **********************-->
    <node-structure name="ImportAliasClauseSyntax" parent="VisualBasicSyntaxNode">
      <description>Represents an alias identifier followed by an "=" token in an Imports clause.</description>

      <node-kind name="ImportAliasClause" />

      <child name="Identifier" kind="IdentifierToken">
        <description>The identifier being introduced.</description>
      </child>

      <child name="EqualsToken" kind="EqualsToken">
        <description>The "=" token.</description>
      </child>
    </node-structure>

    <!--********************
      -  XmlNamespaceImportsClause
      **********************-->
    <node-structure name="XmlNamespaceImportsClauseSyntax" parent="ImportsClauseSyntax">
      <description>Defines a XML namespace for XML expressions.</description>
      <lm-equiv name="ImportXmlNamespaceNode"></lm-equiv>
      <native-equiv name="XmlNamespaceImportDirective"></native-equiv>

      <node-kind name="XmlNamespaceImportsClause">
        <lm-equiv name="ImportXmlNamespace" />
        <native-equiv name="Modes.XmlNamespace" />
      </node-kind>

      <child name="LessThanToken" kind="LessThanToken"></child>

      <child name="XmlNamespace" kind="XmlAttribute">
        <description>Identifies the XML namespace alias and URI.</description>
        <lm-equiv name="Namespace"></lm-equiv>
        <native-equiv name="NamespaceDeclaration"></native-equiv>
      </child>

      <child name="GreaterThanToken" kind="GreaterThanToken"></child>
    </node-structure>


    <!-- ************************************************************************************************** -->
    <!-- **  NAMESPACE AND TYPE DECLARATIONS                                                             ** -->
    <!-- ************************************************************************************************** -->

    <!--********************
      -  NamespaceBlock
      **********************-->
    <node-structure name="NamespaceBlockSyntax" parent="DeclarationStatementSyntax">
      <description>
        Represents a Namespace statement, its contents and the End Namespace statement.
      </description>
      <lm-equiv name="NamespaceNode"></lm-equiv>
      <native-equiv name="NamespaceStatement"></native-equiv>

      <node-kind name="NamespaceBlock">
        <lm-equiv name="Namespace" />
        <native-equiv name="Statement.Opcodes.Namespace" />
      </node-kind>

      <child name="NamespaceStatement" kind="NamespaceStatement">
        <description>The statement that begins the NamespaceBlock. </description>
        <lm-equiv name=""></lm-equiv>
        <native-equiv name=""></native-equiv>
      </child>

      <child name="Members" list="true" optional="true" kind="@NamespaceBlockSyntax|@TypeBlockSyntax|@EmptyStatementSyntax">
        <description>The declarations contained in the namespace statement.</description>
        <lm-equiv name="Contents"></lm-equiv>
        <native-equiv name="Children"></native-equiv>
      </child>

      <child name="EndNamespaceStatement" kind="EndNamespaceStatement">
        <description>
          The End Namespace statement that ends the block.
        </description>
        <lm-equiv name="EndBlock"></lm-equiv>
        <native-equiv name="TerminatingConstruct"></native-equiv>
      </child>
    </node-structure>

    <!--********************
      -  NamespaceStatement
      **********************-->
    <node-structure name="NamespaceStatementSyntax" parent="DeclarationStatementSyntax">
      <description>
        Represents the beginning statement of a namespace declaration. This node
        always appears as the Begin of a BlockStatement with Kind=NamespaceBlock.
      </description>
      <lm-equiv name="NamespaceNode"></lm-equiv>
      <native-equiv name="NamespaceStatement"></native-equiv>

      <node-kind name="NamespaceStatement">
        <lm-equiv name="Namespace" />
        <native-equiv name="Statement.Opcodes.Namespace" />
      </node-kind>

      <child name="NamespaceKeyword" kind="NamespaceKeyword">
        <description>The "Namespace" keyword.</description>
        <lm-equiv name="NamespaceKeyword"></lm-equiv>
        <native-equiv name=""></native-equiv>
      </child>

      <child name="Name" kind="@NameSyntax">
        <description>A (possibly dotted) name denoting the namespace being declared.</description>
        <lm-equiv name="Name"></lm-equiv>
        <native-equiv name="Name"></native-equiv>
      </child>
    </node-structure>

    <!--********************
      -  TypeBlock
      **********************-->
    <node-structure name="TypeBlockSyntax" parent="DeclarationStatementSyntax" abstract="true">
      <description>
        Represents a declaration of a Class, Interface, Structure, Module, its contents and the End statement that ends it.
      </description>
      <lm-equiv name="TypeDeclarationNode"></lm-equiv>
      <native-equiv name="TypeStatement"></native-equiv>

      <child name="Inherits" list="true" optional="true"  kind="InheritsStatement" order="20">
        <description>A list of the Inherits declarations for the type. </description>
      </child>

      <child name="Implements" list="true" optional="true"  kind="ImplementsStatement" order="30">
        <description>A list of the Implements declarations for the type. </description>
      </child>

      <child name="Members" list="true" optional="true" kind="@StatementSyntax" order="40">
        <description>The declarations contained in the type or module.</description>
      </child>
    </node-structure>

    <!--********************
      -  ModuleBlock
      **********************-->
    <node-structure name="ModuleBlockSyntax" parent="TypeBlockSyntax">
      <description>
        Represents a declaration of Module, its contents and the End statement that ends it.
      </description>
      <lm-equiv name="TypeDeclarationNode"></lm-equiv>
      <native-equiv name="TypeStatement"></native-equiv>

      <node-kind name="ModuleBlock">
        <lm-equiv name="TypeDeclaration" />
        <native-equiv name="Statement.Opcodes.Module" />
      </node-kind>

      <child name="ModuleStatement" kind="ModuleStatement" order="10">
        <description>The "Module" statement that begins the block.</description>
      </child>

      <child name="EndModuleStatement" kind="EndModuleStatement" order="50">
        <description>
          The "End Module" statement that ends the block.
        </description>
      </child>
    </node-structure>

    <!--********************
      -  StructureBlock
      **********************-->
    <node-structure name="StructureBlockSyntax" parent="TypeBlockSyntax">
      <description>
        Represents a declaration of a Structure, its contents and the End statement that ends it.
      </description>
      <lm-equiv name="TypeDeclarationNode"></lm-equiv>
      <native-equiv name="TypeStatement"></native-equiv>

      <node-kind name="StructureBlock">
        <lm-equiv name="TypeDeclaration" />
        <native-equiv name="Statement.Opcodes.Structure" />
      </node-kind>

      <child name="StructureStatement" kind="StructureStatement" order="10">
        <description>The "Structure" statement that begins the block.</description>
      </child>

      <child name="EndStructureStatement" kind="EndStructureStatement" order="50">
        <description>
          The "End Structure" statement that ends the block.
        </description>
      </child>
    </node-structure>

    <!--********************
      -  InterfaceBlock
      **********************-->
    <node-structure name="InterfaceBlockSyntax" parent="TypeBlockSyntax">
      <description>
        Represents a declaration of a Interface, its contents and the End statement that ends it.
      </description>
      <lm-equiv name="TypeDeclarationNode"></lm-equiv>
      <native-equiv name="TypeStatement"></native-equiv>

      <node-kind name="InterfaceBlock">
        <lm-equiv name="TypeDeclaration" />
        <native-equiv name="Statement.Opcodes.Interface" />
      </node-kind>

      <child name="InterfaceStatement" kind="InterfaceStatement" order="10">
        <description>The "Interface" statement that begins the block.</description>
      </child>

      <child name="EndInterfaceStatement" kind="EndInterfaceStatement" order="50">
        <description>
          The "End Interface" statement that ends the block.
        </description>
      </child>
    </node-structure>

    <!--********************
      -  ClassBlock
      **********************-->
    <node-structure name="ClassBlockSyntax" parent="TypeBlockSyntax">
      <description>
        Represents a declaration of a Class its contents and the End statement that ends it.
      </description>
      <lm-equiv name="TypeDeclarationNode"></lm-equiv>
      <native-equiv name="TypeStatement"></native-equiv>

      <node-kind name="ClassBlock">
        <lm-equiv name="TypeDeclaration" />
        <native-equiv name="Statement.Opcodes.Class" />
      </node-kind>

      <child name="ClassStatement" kind="ClassStatement" order="10">
        <description>The "Class" statement that begins the block.</description>
      </child>

      <child name="EndClassStatement" kind="EndClassStatement" order="50">
        <description>
          The "End Class" statement that ends the block.
        </description>
      </child>
    </node-structure>

    <!--********************
      -  EnumBlock
      **********************-->
    <node-structure name="EnumBlockSyntax" parent="DeclarationStatementSyntax">
      <description>
        Represents a declaration of an Enum, its contents and the End Enum statement that ends it.
      </description>
      <lm-equiv name="TypeDeclarationNode"></lm-equiv>
      <native-equiv name="TypeStatement"></native-equiv>

      <node-kind name="EnumBlock">
        <lm-equiv name="TypeDeclaration" />
        <native-equiv name="Statement.Opcodes.Class" />
      </node-kind>

      <child name="EnumStatement" kind="EnumStatement">
        <description>The statement that begins the type or module. </description>
        <lm-equiv name=""></lm-equiv>
        <native-equiv name=""></native-equiv>
      </child>

      <child name="Members" list="true" optional="true"  kind="EnumMemberDeclaration|EmptyStatement">
        <description>The declarations contained in the enumeration.</description>
        <lm-equiv name="Contents"></lm-equiv>
        <native-equiv name="Children"></native-equiv>
      </child>

      <child name="EndEnumStatement" kind="EndEnumStatement">
        <description>
          The End XXX statement that ends the block.
        </description>
        <lm-equiv name="EndBlock"></lm-equiv>
        <native-equiv name="TerminatingConstruct"></native-equiv>
      </child>
    </node-structure>

    <!--********************
      -  InheritsOrImplementsStatement
      **********************-->
    <node-structure name="InheritsOrImplementsStatementSyntax" parent="DeclarationStatementSyntax" abstract="true">
      <description>
        Represents an Inherits or Implements statement in a Class, Structure or Interface.
      </description>
    </node-structure>

    <node-structure name="InheritsStatementSyntax" parent="InheritsOrImplementsStatementSyntax">
      <description>
        Represents an Inherits statement in a Class, Structure or Interface.
      </description>

      <node-kind name="InheritsStatement" />

      <child name="InheritsKeyword" kind="InheritsKeyword">
        <description>The "Inherits" keyword.</description>
      </child>

      <child name="Types" list="true" separator-kind="CommaToken" separator-name="Commas" kind="NonArrayTypeName" min-count="1">
        <description>A list of the types being inherited.</description>
      </child>
    </node-structure>

    <node-structure name="ImplementsStatementSyntax" parent="InheritsOrImplementsStatementSyntax">
      <description>
        Represents an Implements statement in a Class or Structure.
      </description>

      <node-kind name="ImplementsStatement" />

      <child name="ImplementsKeyword" kind="ImplementsKeyword">
        <description>The "Implements" keyword.</description>
      </child>

      <child name="Types" list="true" separator-kind="CommaToken" separator-name="Commas" kind="NonArrayTypeName" min-count="1">
        <description>A list of the types being implemented.</description>
      </child>
    </node-structure>


    <!--********************
      -  TypeStatement
      **********************-->
    <node-structure name="TypeStatementSyntax" parent="DeclarationStatementSyntax" abstract="true">
      <description>
        Abstract class for the beginning statement of a Module, Class, Interface or Structure declaration. This node
        always appears as the Begin of a TypeBlock with Kind=ModuleDeclarationBlock, ClassDeclarationBlock, InterfaceDeclarationBlock or StructureDeclarationBlock.
      </description>
      <lm-equiv name="TypeDeclarationNode"></lm-equiv>
      <native-equiv name="TypeStatement"></native-equiv>

      <child name="AttributeLists" optional="true" list="true" kind="AttributeList" order="10">
        <description>A list of all attribute lists on this declaration. If no attributes were specified, an empty list is returned.</description>
        <lm-equiv name="Attributes"></lm-equiv>
        <native-equiv name="Attributes"></native-equiv>
      </child>

      <child name="Modifiers" optional="true" list="true" kind="PublicKeyword|PrivateKeyword|ProtectedKeyword|FriendKeyword|ShadowsKeyword|MustInheritKeyword|NotInheritableKeyword|PartialKeyword" order="20">
        <description>
          A list of all the modifier tokens that were present on this declaration. If no modifiers were specified, an empty list is returned.
        </description>
        <lm-equiv name="ModifierTokens"></lm-equiv>
        <native-equiv name="Specifiers"></native-equiv>
      </child>

      <child name="Identifier" kind="IdentifierToken" order="40">
        <description>The name of the type being declared.</description>
        <lm-equiv name="Name"></lm-equiv>
        <native-equiv name="Name"></native-equiv>
      </child>

      <child name="TypeParameterList" optional="true" kind="TypeParameterList" order="50">
        <!-- REVIEW: Add constraint that this can't be present for a Module. -->
        <description>
          If present, a type parameter list with generic parameters for this type. If no generic parameters were
          present, Nothing is returned.
        </description>
      </child>

    </node-structure>

    <!--********************
      -  ModuleStatement
      **********************-->
    <node-structure name="ModuleStatementSyntax" parent="TypeStatementSyntax">
      <description>
        Represents the beginning statement of a Module declaration. This node
        always appears as the Begin of a TypeBlock with Kind=ModuleDeclarationBlock.
      </description>
      <lm-equiv name="TypeDeclarationNode"></lm-equiv>
      <native-equiv name="TypeStatement"></native-equiv>

      <node-kind name="ModuleStatement">
        <lm-equiv name="Type" />
        <native-equiv name="Statement.Opcodes.Module" />
      </node-kind>

      <child name="ModuleKeyword" kind="ModuleKeyword" order="30">
        <description>The "Module" keyword.</description>
      </child>
    </node-structure>

    <!--********************
      -  StructureStatement
      **********************-->
    <node-structure name="StructureStatementSyntax" parent="TypeStatementSyntax">
      <description>
        Represents the beginning statement of a Structure declaration. This node
        always appears as the Begin of a TypeBlock with Kind=StructureDeclarationBlock.
      </description>
      <lm-equiv name="TypeDeclarationNode"></lm-equiv>
      <native-equiv name="TypeStatement"></native-equiv>

      <node-kind name="StructureStatement">
        <lm-equiv name="Type" />
        <native-equiv name="Statement.Opcodes.Structure" />
      </node-kind>

      <child name="StructureKeyword" kind="StructureKeyword" order="30">
        <description>The "Structure" keyword.</description>
      </child>
    </node-structure>

    <!--********************
      -  InterfaceStatement
      **********************-->
    <node-structure name="InterfaceStatementSyntax" parent="TypeStatementSyntax">
      <description>
        Represents the beginning statement of a Interface declaration. This node
        always appears as the Begin of a TypeBlock with Kind=InterfaceDeclarationBlock.
      </description>
      <lm-equiv name="TypeDeclarationNode"></lm-equiv>
      <native-equiv name="TypeStatement"></native-equiv>

      <node-kind name="InterfaceStatement">
        <lm-equiv name="Type" />
        <native-equiv name="Statement.Opcodes.Interface" />
      </node-kind>

      <child name="InterfaceKeyword" kind="InterfaceKeyword" order="30">
        <description>The "Interface" keyword.</description>
      </child>
    </node-structure>

    <!--********************
      -  ClassStatement
      **********************-->
    <node-structure name="ClassStatementSyntax" parent="TypeStatementSyntax">
      <description>
        Represents the beginning statement of a Class declaration. This node
        always appears as the Begin of a TypeBlock with Kind=ClassDeclarationBlock.
      </description>
      <lm-equiv name="TypeDeclarationNode"></lm-equiv>
      <native-equiv name="TypeStatement"></native-equiv>

      <node-kind name="ClassStatement">
        <lm-equiv name="Type" />
        <native-equiv name="Statement.Opcodes.Class" />
      </node-kind>

      <child name="ClassKeyword" kind="ClassKeyword" order="30">
        <description>The "Class" keyword.</description>
      </child>
    </node-structure>

    <!--********************
      -  EnumStatement
      **********************-->
    <node-structure name="EnumStatementSyntax" parent="DeclarationStatementSyntax">
      <description>
        Represents the beginning statement of an Enum declaration. This node
        always appears as the Begin of an EnumBlock with Kind=EnumDeclarationBlock.
      </description>
      <lm-equiv name="TypeDeclarationNode"></lm-equiv>
      <native-equiv name="TypeStatement"></native-equiv>

      <node-kind name="EnumStatement">
        <lm-equiv name="Type" />
        <native-equiv name="Statement.Opcodes.Enum" />
      </node-kind>

      <child name="AttributeLists" optional="true" list="true" kind="AttributeList">
        <description>A list of all attribute lists on this declaration. If no attributes were specified, an empty list is returned.</description>
        <lm-equiv name="Attributes"></lm-equiv>
        <native-equiv name="Attributes"></native-equiv>
      </child>

      <child name="Modifiers" optional="true" list="true" kind="PublicKeyword|PrivateKeyword|ProtectedKeyword|FriendKeyword|ShadowsKeyword">
        <description>
          A list of all the modifier tokens that were present on this declaration. If no modifiers were specified, an empty list is returned.
        </description>
        <lm-equiv name="ModifierTokens"></lm-equiv>
        <native-equiv name="Specifiers"></native-equiv>
      </child>

      <child name="EnumKeyword" >
        <description>The "Enum" keyword.</description>
        <lm-equiv name="TypeKeyword"></lm-equiv>
        <native-equiv name="TypeKeyword"></native-equiv>
        <kind name="EnumKeyword" node-kind="EnumStatement"/>
      </child>

      <child name="Identifier" kind="IdentifierToken">
        <description>The name of the enum being declared.</description>
        <lm-equiv name="Name"></lm-equiv>
        <native-equiv name="Name"></native-equiv>
      </child>

      <child name="UnderlyingType" optional="true" kind="@AsClauseSyntax">
        <description>Optional "As XXX" clause describing the underlying type of the enumeration. If no As clause was specified, Nothing is returned.</description>
        <lm-equiv name="UnderlyingType"></lm-equiv>
        <native-equiv name="UnderlyingRepresentation"></native-equiv>
      </child>

    </node-structure>

    <!--********************
      -  TypeParameters
      **********************-->
    <node-structure name="TypeParameterListSyntax" parent="VisualBasicSyntaxNode">
      <description>Represents the type parameter list in a declaration.</description>
      <lm-equiv name="GenericParameterList"></lm-equiv>

      <node-kind name="TypeParameterList" />

      <child name="OpenParenToken" kind="OpenParenToken">
        <description>The "(" token.</description>
        <lm-equiv name="GenericLeftParenthesis"></lm-equiv>
        <native-equiv name="GenericLeftParen"></native-equiv>
      </child>

      <child name="OfKeyword" kind="OfKeyword">
        <description>The "Of" keyword.</description>
        <lm-equiv name="OfKeyword"></lm-equiv>
        <native-equiv name="GenericOf"></native-equiv>
      </child>

      <child name="Parameters" list="true" separator-kind="CommaToken" separator-name="CommaTokens" kind="TypeParameter" min-count="1">
        <description>A list of the type parameters. There must be at least one type parameter in the list.</description>
        <lm-equiv name="GenericParameters"></lm-equiv>
        <native-equiv name="GenericParameters"></native-equiv>
      </child>

      <child name="CloseParenToken" kind="CloseParenToken">
        <description>The ")" token.</description>
        <lm-equiv name="GenericRightParenthesis"></lm-equiv>
        <native-equiv name="GenericRightParen"></native-equiv>
      </child>
    </node-structure>

    <!--********************
      -  TypeParameter
      **********************-->
    <node-structure name="TypeParameterSyntax" parent="VisualBasicSyntaxNode">
      <description>Represents a type parameter on a generic type declaration.</description>
      <lm-equiv name="GenericParameterNode"></lm-equiv>
      <native-equiv name="GenericParameter"></native-equiv>

      <node-kind name="TypeParameter">
        <lm-equiv name="GenericParameter" />
        <native-equiv name="" />
      </node-kind>

      <child name="VarianceKeyword" optional="true" kind="InKeyword|OutKeyword">
        <description>
          Represents the "In" or "Out" variance keyword on a type parameter, if present. If no variance modifier
          was present, Nothing is returned.
        </description>
        <lm-equiv name="Variance"></lm-equiv>
        <native-equiv name="Variance"></native-equiv>
      </child>

      <child name="Identifier" kind="IdentifierToken">
        <description>The name of the type parameter</description>
        <lm-equiv name="Name"></lm-equiv>
        <native-equiv name="Name"></native-equiv>
      </child>

      <child name="TypeParameterConstraintClause" optional="true" kind="@TypeParameterConstraintClauseSyntax">
        <description>The "As" keyword, if any type constraints were supplied. If no type constraints were supplied, Nothing is returned.</description>
        <lm-equiv name="AsKeyword"></lm-equiv>
        <native-equiv name="As"></native-equiv>
      </child>

    </node-structure>

    <!--**********************************
    -  TypeParameterConstraintClauseSyntax
    ***********************************-->

    <node-structure name="TypeParameterConstraintClauseSyntax" parent="VisualBasicSyntaxNode" abstract="true">
      <description>An abstract node class that is the parent of classes that describe type parameter constraint clauses.</description>
    </node-structure>

    <!--**************************************
    -  TypeParameterSingleConstraintClauseSyntax
    *****************************************-->

    <node-structure name="TypeParameterSingleConstraintClauseSyntax" parent="TypeParameterConstraintClauseSyntax" >
      <description>
        One of the type parameter constraints clauses.  This represents a constraint clause in the form of "As Constraint".
      </description>

      <node-kind name="TypeParameterSingleConstraintClause">
      </node-kind>

      <child name="AsKeyword" kind="AsKeyword">
        <description>The "As" keyword, if any type constraints were supplied. If no type constraints were supplied, Nothing is returned.</description>
        <lm-equiv name="AsKeyword"></lm-equiv>
        <native-equiv name="As"></native-equiv>
      </child>

      <child name="Constraint" kind="@ConstraintSyntax">
        <description>A list of the supplied constraints. If no constraints were supplied, Nothing is returned.</description>
      </child>

    </node-structure>

    <!--***************************************
    -  TypeParameterMultipleConstraintClauseSyntax
    *******************************************-->

    <node-structure name="TypeParameterMultipleConstraintClauseSyntax" parent="TypeParameterConstraintClauseSyntax">
      <description>One of the type parameter constraints clauses.  This represents a constraint clause in the form of "As { Constraints }".</description>

      <node-kind name="TypeParameterMultipleConstraintClause">
      </node-kind>

      <child name="AsKeyword" kind="AsKeyword">
        <description>The "As" keyword.</description>
        <lm-equiv name="AsKeyword"></lm-equiv>
        <native-equiv name="As"></native-equiv>
      </child>

      <child name="OpenBraceToken" kind="OpenBraceToken">
        <description>The "{" token.</description>
        <lm-equiv name="LeftBrace"></lm-equiv>
        <native-equiv name="LeftBrace"></native-equiv>
      </child>

      <child name="Constraints" list="true" separator-kind="CommaToken" separator-name="Commas" kind="@ConstraintSyntax" min-count="1">
        <description>A list of the supplied constraints. If no constraints were supplied, an empty list is returned.</description>
        <lm-equiv name="Constraints"></lm-equiv>
        <native-equiv name="Constraints"></native-equiv>
      </child>

      <child name="CloseBraceToken" kind="CloseBraceToken">
        <description>The "}" token.</description>
        <lm-equiv name="RightBrace"></lm-equiv>
        <native-equiv name=""></native-equiv>
      </child>

    </node-structure>

    <!--********************
      -  Constraint
      **********************-->
    <node-structure name="ConstraintSyntax" parent="VisualBasicSyntaxNode" abstract="true">
      <description>An abstract node class that is the parent of classes that describe type parameter constraints.</description>
      <lm-equiv name="ConstraintNode"></lm-equiv>
      <native-equiv name="Constraint"></native-equiv>
    </node-structure>

    <!--********************
      -  ConstraintNode
      **********************-->
    <node-structure name="SpecialConstraintSyntax" parent="ConstraintSyntax">
      <description>
        One of the special type parameter constraints: New, Class or Structure. Which kind of special constraint it
        is can be obtained from the Kind property and is one of: NewConstraint, ReferenceConstraint or ValueConstraint.
      </description>
      <lm-equiv name="NewConstraintNode"></lm-equiv>
      <lm-equiv name="ReferenceConstraintNode"></lm-equiv>
      <lm-equiv name="ValueConstraintNode"></lm-equiv>
      <native-equiv name="Constraint"></native-equiv>

      <node-kind name="NewConstraint">
        <lm-equiv name="NewConstraint" />
        <native-equiv name="Constraint.Opcodes.New" />
      </node-kind>

      <node-kind name="ClassConstraint">
        <lm-equiv name="ReferenceConstraint" />
        <native-equiv name="Constraint.Opcodes.Class" />
      </node-kind>

      <node-kind name="StructureConstraint">
        <lm-equiv name="ValueConstraint" />
        <native-equiv name="Constraint.Opcodes.Struct" />
      </node-kind>

      <child name="ConstraintKeyword" kind="NewKeyword|ClassKeyword|StructureKeyword">
        <description>The "New", "Class" or "Structure" keyword that denotes the kind of special constraint.</description>
        <lm-equiv name="NewKeyword"></lm-equiv>
        <lm-equiv name="ClassKeyword"></lm-equiv>
        <lm-equiv name="StructureKeyword"></lm-equiv>
        <native-equiv name=""></native-equiv>
      </child>
    </node-structure>

    <!--********************
      -  TypeConstraint
      **********************-->
    <node-structure name="TypeConstraintSyntax" parent="ConstraintSyntax">
      <description>Represents a type parameter constraint that is a type.</description>
      <lm-equiv name="TypeConstraintNode"></lm-equiv>
      <native-equiv name="TypeConstraint"></native-equiv>

      <node-kind name="TypeConstraint">
        <lm-equiv name="TypeConstraint" />
        <native-equiv name="Constraint.Opcodes.Type" />
      </node-kind>

      <child name="Type" kind="@TypeSyntax">
        <description>The type describing the constraint.</description>
        <lm-equiv name="ConstraintType"></lm-equiv>
        <native-equiv name="Type"></native-equiv>
      </child>
    </node-structure>

    <!-- ************************************************************************************************** -->
    <!-- **  TYPE MEMBER DECLARATIONS (Methods, Properties, Variables, ...)                              ** -->
    <!-- ************************************************************************************************** -->
    <node-structure name="EnumMemberDeclarationSyntax" parent="DeclarationStatementSyntax">
      <description>
        Represents a name and value in an EnumDeclarationBlock.
      </description>
      <lm-equiv name="EnumMemberNode"></lm-equiv>
      <native-equiv name="EnumeratorStatement"></native-equiv>
      <node-kind name="EnumMemberDeclaration">
      </node-kind>
      <child name="AttributeLists" optional="true" list="true" kind="AttributeList">
        <description></description>
        <lm-equiv name="Attributes"></lm-equiv>
        <native-equiv name=""></native-equiv>
      </child>
      <child name="Identifier" kind="IdentifierToken">
        <description></description>
        <lm-equiv name="Name"></lm-equiv>
        <native-equiv name=""></native-equiv>
      </child>
      <child name="Initializer" optional="true" kind="@EqualsValueSyntax">
        <description>An optional value for the enum member.</description>
      </child>
    </node-structure>

    <!--****************
      -  MethodBlockBase
      ******************-->
    <node-structure name="MethodBlockBaseSyntax" parent="DeclarationStatementSyntax" abstract="true">
      <description>
        Represents a block member declaration: A declaration that has a beginning
        declaration, a body of executable statements and an end statement. Examples include
        methods, constructors, operators,
        property accessors and custom event accessors.
      </description>

      <lm-equiv name="BlockNode"></lm-equiv>
      <native-equiv name="BlockStatement"></native-equiv>
      <native-equiv name="HiddenBlockStatement">TODO: Describe how these map!</native-equiv>

      <child name="Statements" optional="true" list="true" kind="@StatementSyntax" order="20">
        <description>
          The statements contained in the block statement. This might be an empty list.
        </description>
        <lm-equiv name="BlockNode.Contents"></lm-equiv>
        <native-equiv name="BlockStatement.Children"></native-equiv>
      </child>
    </node-structure>

    <!--****************
      -  MethodBlock
      ******************-->
    <node-structure name="MethodBlockSyntax" parent="MethodBlockBaseSyntax">
      <description>
        Represents a Function or Sub block declaration: A declaration that has a beginning
        declaration, a body of executable statements and an end statement.
      </description>

      <node-kind name="SubBlock">
        <lm-equiv name="Method" />
        <native-equiv name="Statement.Opcodes.ProcedureBody" />
      </node-kind>

      <node-kind name="FunctionBlock">
        <lm-equiv name="Method" />
        <native-equiv name="Statement.Opcodes.ProcedureBody" />
      </node-kind>
      
      <child name="SubOrFunctionStatement" order="10">
        <description>The "Sub" or "Function" statement that begins the block.</description>
        <kind name="SubStatement" node-kind="SubBlock"/>
        <kind name="FunctionStatement" node-kind="FunctionBlock"/>
      </child>

      <child name="EndSubOrFunctionStatement" order="30">
        <description>
          The "End Sub" or "End Function" statement that ends the block.
        </description>
        <kind name="EndSubStatement" node-kind="SubBlock"/>
        <kind name="EndFunctionStatement" node-kind="FunctionBlock"/>
      </child>
    </node-structure>

    <!--****************
      -  ConstructorBlock
      ******************-->
    <node-structure name="ConstructorBlockSyntax" parent="MethodBlockBaseSyntax">
      <description>
        Represents a constructor block declaration: A declaration that has a beginning
        declaration, a body of executable statements and an end statement.
      </description>

      <node-kind name="ConstructorBlock">
        <lm-equiv name="Method" />
        <native-equiv name="Statement.Opcodes.ProcedureBody" />
      </node-kind>

      <child name="SubNewStatement" kind="SubNewStatement" order="10">
        <description>The "Sub New" statement that begins the block. </description>
      </child>

      <child name="EndSubStatement" kind="EndSubStatement" order="30">
        <description>
          The "End Sub" statement that ends the block declaration.
        </description>
      </child>
    </node-structure>

    <!--****************
      -  OperatorBlock
      ******************-->
    <node-structure name="OperatorBlockSyntax" parent="MethodBlockBaseSyntax">
      <description>
        Represents an Operator block member declaration: A declaration that has a beginning
        declaration, a body of executable statements and an end statement.
      </description>

      <node-kind name="OperatorBlock">
        <lm-equiv name="Method" />
        <native-equiv name="Statement.Opcodes.ProcedureBody" />
      </node-kind>

      <child name="OperatorStatement" kind="OperatorStatement" order="10">
        <description>The "Operator" statement that begins the block. </description>
      </child>

      <child name="EndOperatorStatement" kind="EndOperatorStatement" order="30">
        <description>
          The "End Operator" statement that ends the block declaration.
        </description>
      </child>
    </node-structure>

    <!--****************
      -  AccessorBlock
      ******************-->
    <node-structure name="AccessorBlockSyntax" parent="MethodBlockBaseSyntax">
      <description>
        Represents an accessor block member declaration: A declaration that has a beginning
        declaration, a body of executable statements and an end statement. Examples include
        property accessors and custom event accessors.
      </description>

      <node-kind name="GetAccessorBlock">
        <lm-equiv name="Method" />
        <native-equiv name="Statement.Opcodes.PropertyGetBody" />
      </node-kind>

      <node-kind name="SetAccessorBlock">
        <lm-equiv name="Method" />
        <native-equiv name="Statement.Opcodes.PropertySetBody" />
      </node-kind>

      <node-kind name="AddHandlerAccessorBlock">
        <lm-equiv name="Method" />
        <native-equiv name="Statement.Opcodes.AddHandlerBody" />
      </node-kind>

      <node-kind name="RemoveHandlerAccessorBlock">
        <lm-equiv name="Method" />
        <native-equiv name="Statement.Opcodes.RemoveHandlerBody" />
      </node-kind>

      <node-kind name="RaiseEventAccessorBlock">
        <lm-equiv name="Method" />
        <native-equiv name="Statement.Opcodes.RaiseEventBody" />
      </node-kind>

      <child name="AccessorStatement" order="10">
        <description>The "Get", "Set", "AddHandler", "RemoveHandler", or "RaiseEvent" statement that begins the accessor block.</description>
        <kind name="GetAccessorStatement" node-kind="GetAccessorBlock"/>
        <kind name="SetAccessorStatement" node-kind="SetAccessorBlock"/>
        <kind name="AddHandlerAccessorStatement" node-kind="AddHandlerAccessorBlock"/>
        <kind name="RemoveHandlerAccessorStatement" node-kind="RemoveHandlerAccessorBlock"/>
        <kind name="RaiseEventAccessorStatement" node-kind="RaiseEventAccessorBlock"/>
      </child>

      <child name="EndAccessorStatement" order="30">
        <description>The "End Get", "End Set", "End AddHandler", "End RemoveHandler", or "End RaiseEvent" statement that ends the accessor block.</description>
        <kind name="EndGetStatement" node-kind="GetAccessorBlock"/>
        <kind name="EndSetStatement" node-kind="SetAccessorBlock"/>
        <kind name="EndAddHandlerStatement" node-kind="AddHandlerAccessorBlock"/>
        <kind name="EndRemoveHandlerStatement" node-kind="RemoveHandlerAccessorBlock"/>
        <kind name="EndRaiseEventStatement" node-kind="RaiseEventAccessorBlock"/>
      </child>
    </node-structure>

    <!--****************
      -  PropertyBlock
      ******************-->
    <node-structure name="PropertyBlockSyntax" parent="DeclarationStatementSyntax">
      <description>
        Represents a block property declaration: A declaration that has a beginning
        declaration, some get or set accessor blocks and an end statement.
      </description>

      <lm-equiv name="BlockNode"></lm-equiv>
      <native-equiv name="BlockStatement"></native-equiv>

      <node-kind name="PropertyBlock">
        <lm-equiv name="Property" />
        <native-equiv name="Statement.Opcodes.Property" />
      </node-kind>

      <child name="PropertyStatement" kind="PropertyStatement">
        <description>The property declaration that begins the block. </description>
        <lm-equiv name=""></lm-equiv>
        <native-equiv name=""></native-equiv>
      </child>

      <child name="Accessors" list="true"  kind="GetAccessorBlock|SetAccessorBlock">
        <description>
          The accessor blocks contained in the property, between the Property and
          the End Property statements.
        </description>
        <lm-equiv name="Contents"></lm-equiv>
        <native-equiv name="Children"></native-equiv>
      </child>

      <child name="EndPropertyStatement" kind="EndPropertyStatement">
        <description>
          The End Property statement that ends the block.
        </description>
        <lm-equiv name="EndBlock"></lm-equiv>
        <native-equiv name="TerminatingConstruct"></native-equiv>
      </child>
    </node-structure>

    <!--****************
      -  EventBlock
      ******************-->
    <node-structure name="EventBlockSyntax" parent="DeclarationStatementSyntax">
      <description>
        Represents a custom event declaration: A declaration that has a beginning
        event declaration, some accessor blocks and an end statement.
      </description>

      <lm-equiv name="BlockNode"></lm-equiv>
      <native-equiv name="BlockStatement"></native-equiv>

      <node-kind name="EventBlock">
        <lm-equiv name="Event" />
        <native-equiv name="Statement.Opcodes.BlockEventDeclaration" />
      </node-kind>

      <child name="EventStatement" kind="EventStatement">
        <description>The event declaration that begins the block. </description>
        <lm-equiv name=""></lm-equiv>
        <native-equiv name=""></native-equiv>
      </child>

      <child name="Accessors" list="true"  kind="AddHandlerAccessorBlock|RemoveHandlerAccessorBlock|RaiseEventAccessorBlock">
        <description>
          The accessor blocks contained in the custom event declaration, between the Event statement and
          the End Event statement.
        </description>
        <lm-equiv name="Contents"></lm-equiv>
        <native-equiv name="Children"></native-equiv>
      </child>

      <child name="EndEventStatement" kind="EndEventStatement">
        <description>
          The End Event statement that ends the block.
        </description>
        <lm-equiv name="EndBlock"></lm-equiv>
        <native-equiv name="TerminatingConstruct"></native-equiv>
      </child>
    </node-structure>

    <!--********************
      -  MethodBase
      **********************-->
    <node-structure name="MethodBaseSyntax" parent="DeclarationStatementSyntax" abstract="true">
      <description>
        An abstract node class that is the parent for declarations that are "method-like"; i.e., that
        have a parameter list and return type. This includes methods, constructors, properties, events, operators, declares, delegates,
        property accessors and custom event accessors.
      </description>
      <lm-equiv name="MethodBaseNode"></lm-equiv>
      <native-equiv name="MethodSignature"></native-equiv>

      <child name="AttributeLists" optional="true" list="true" kind="AttributeList">
        <description>A list of all attribute lists on this declaration. If no attributes were specified, Nothing is returned.</description>
        <lm-equiv name="Attributes"></lm-equiv>
        <native-equiv name="Attributes"></native-equiv>
      </child>

      <child name="Modifiers" optional="true" list="true" kind="PublicKeyword|PrivateKeyword|ProtectedKeyword|FriendKeyword|SharedKeyword|ShadowsKeyword|OverloadsKeyword|OverridesKeyword|PartialKeyword|NotOverridableKeyword|OverridableKeyword|MustOverrideKeyword|ReadOnlyKeyword|WriteOnlyKeyword|DefaultKeyword|WithEventsKeyword|WideningKeyword|NarrowingKeyword|CustomKeyword">
        <description>
          A list of all the modifier tokens that were present on this declaration. If no modifiers were specified, an empty list is returned.
          A bitfield version of all the modifiers ORed together, which is in many cases easier to use, can be obtained with the Modifiers property.
        </description>
        <lm-equiv name="ModifierTokens"></lm-equiv>
        <native-equiv name="Specifiers"></native-equiv>
      </child>

      <child name="ParameterList" optional="true" kind="ParameterList" order="30">
        <description>The method's parameter list including the parentheses. If no parameter list was present, Nothing is returned.</description>
      </child>
    </node-structure>


    <!--********************
      -  ParameterListSyntax
      **********************-->
    <node-structure name="ParameterListSyntax" parent="VisualBasicSyntaxNode">
      <description>Represents the parameter list in a method declaration.</description>

      <node-kind name="ParameterList" />

      <child name="OpenParenToken" kind="OpenParenToken" >
        <description>The "(" token that introduces the parameter list. If no parameter list was present, Nothing is returned.</description>
        <lm-equiv name="LeftParenthesis"></lm-equiv>
        <native-equiv name="LeftParen"></native-equiv>
      </child>

      <child name="Parameters" list="true" optional="true" separator-kind="CommaToken" separator-name="CommaTokens" kind="Parameter" >
        <description>The list of parameters. If no parameter list was present, Nothing is returned.</description>
        <lm-equiv name="Parameters"></lm-equiv>
        <native-equiv name="Parameters"></native-equiv>
      </child>

      <child name="CloseParenToken" kind="CloseParenToken" >
        <description>The ")" token that concludes the parameter list. If no parameter list was present, Nothing is returned.</description>
        <lm-equiv name="RightParenthesis"></lm-equiv>
        <native-equiv name="RightParen"></native-equiv>
      </child>
    </node-structure>

    <!--********************
      -  MethodStatement
      **********************-->
    <node-structure name="MethodStatementSyntax" parent="MethodBaseSyntax">
      <description>
        The statement that declares a Sub or Function. If this method has a body, this statement will
        be the Begin of a BlockStatement with Kind=MethodDeclarationBlock, and the body of the method will be the
        Body of that BlockStatement.
      </description>
      <lm-equiv name="MethodNode"></lm-equiv>
      <native-equiv name="MethodDeclarationStatement"></native-equiv>

      <node-kind name="SubStatement">
        <lm-equiv name="Method" />
        <native-equiv name="Statements.Opcodes.ProcedureDeclaration" />
        <native-equiv name="Statements.Opcodes.FunctionDeclaration" />
      </node-kind>

      <node-kind name="FunctionStatement">
        <lm-equiv name="Method" />
        <native-equiv name="Statements.Opcodes.ProcedureDeclaration" />
        <native-equiv name="Statements.Opcodes.FunctionDeclaration" />
      </node-kind>

      <child name="SubOrFunctionKeyword" order="10">
        <description>
          The "Sub" or "Function" keyword that introduces this method declaration.
        </description>
        <kind name ="SubKeyword" node-kind="SubStatement" />
        <kind name ="FunctionKeyword" node-kind="FunctionStatement" />
      </child>
      
      <child name="Identifier" kind="IdentifierToken" order="20">
        <description>The name of the method being declared.</description>
        <lm-equiv name="Name"></lm-equiv>
        <native-equiv name="MethodSignature.Name"></native-equiv>
      </child>

      <child name="TypeParameterList" optional="true" kind="TypeParameterList" order="21">
        <description>
          If present, a type parameter list with generic type parameters for this method. If no generic type parameters were
          present, Nothing is returned.
        </description>
      </child>

      <child name="AsClause" optional="true" kind="SimpleAsClause" order="60">
        <description>The "As" clause that describes the return type. If no As clause was present, Nothing is returned.</description>
      </child>

      <child name="HandlesClause" optional="true" kind="HandlesClause" order="100">
        <description>
          If present, a Handles clause indicated the events that this method handles.
        </description>
      </child>

      <child name="ImplementsClause" optional="true" kind="ImplementsClause" order="101">
        <description>
          If present, an Implements clause indicated the interface methods that this method implements.
        </description>
      </child>
    </node-structure>

    <!--********************
      -  SubNewStatement
      **********************-->
    <node-structure name="SubNewStatementSyntax" parent="MethodBaseSyntax">
      <description>
        A statement that declares a constructor. This statement will
        be the Begin of a BlockStatement with Kind=MethodDeclarationBlock, and the body of the method will be the
        Body of that BlockStatement.
      </description>
      <lm-equiv name="ConstructorDeclaration"></lm-equiv>
      <native-equiv name="Statements.Opcodes.MethodDefinitionStatement"></native-equiv>

      <node-kind name="SubNewStatement">
        <lm-equiv name="Constructor" />
        <native-equiv name="ConstructorDeclaration" />
      </node-kind>

      <child name="SubKeyword" kind="SubKeyword" order="10">
        <description>
          The "Sub" keyword.
        </description>
      </child>
      
      <child name="NewKeyword" kind="NewKeyword" order="20">
        <description>The "New" keyword in the constructor declaration.</description>
        <lm-equiv name="NewKeyword"></lm-equiv>
        <native-equiv name=""></native-equiv>
      </child>
    </node-structure>

    <!--********************
      -  DeclareStatement
      **********************-->
    <node-structure name="DeclareStatementSyntax" parent="MethodBaseSyntax">
      <description>A Declare statement that declares an external DLL method.</description>
      <lm-equiv name="DeclareNode"></lm-equiv>
      <native-equiv name="ForeignMethodDeclarationStatement"></native-equiv>

      <node-kind name="DeclareSubStatement">
        <lm-equiv name="Declare" />
        <native-equiv name="Statements.Opcodes.ForeignProcedureDeclaration" />
      </node-kind>

      <node-kind name="DeclareFunctionStatement">
        <lm-equiv name="Declare" />
        <native-equiv name="Statements.Opcodes.ForeignFunctionDeclaration" />
      </node-kind>

      <child name="DeclareKeyword" kind="DeclareKeyword" order="8">
        <description>The "Declare" keyword.</description>
        <lm-equiv name="DeclareKeyword"></lm-equiv>
        <native-equiv name="Declare"></native-equiv>
      </child>

      <child name="CharsetKeyword" optional="true" kind="AnsiKeyword|UnicodeKeyword|AutoKeyword" order="9">
        <description>If present, the keyword that defines the string translation semantics of the external method.</description>
        <lm-equiv name="StringMode"></lm-equiv>
        <native-equiv name="StringMode"></native-equiv>
      </child>
      
      <child name="SubOrFunctionKeyword" order="10">
        <description>
          The "Sub" or "Function" keyword.
        </description>
        <kind name ="SubKeyword" node-kind="DeclareSubStatement" />
        <kind name ="FunctionKeyword" node-kind="DeclareFunctionStatement" />
      </child>
      
      <child name="Identifier" kind="IdentifierToken" order="20">
        <description>The name of the method being declared.</description>
        <lm-equiv name="Name"></lm-equiv>
        <native-equiv name="MethodSignature.Name"></native-equiv>
      </child>

      <child name="LibKeyword" kind="LibKeyword" order="21">
        <description>The "Lib" keyword. </description>
        <lm-equiv name="LibKeyword"></lm-equiv>
        <native-equiv name="Lib"></native-equiv>
      </child>

      <child name="LibraryName" kind="@LiteralExpressionSyntax" order="22">
        <description>The string literal with the library name.</description>
        <lm-equiv name="Library"></lm-equiv>
        <native-equiv name="Library"></native-equiv>
      </child>

      <child name="AliasKeyword" optional="true" kind="AliasKeyword" order="23">
        <description>If present, the "Alias" keyword. If not present, returns Nothing.</description>
        <lm-equiv name="AliasKeyword"></lm-equiv>
        <native-equiv name="Al"></native-equiv>
      </child>

      <child name="AliasName" optional="true" kind="@LiteralExpressionSyntax" order="24">
        <description>The string literal with the alias. If not present, returns Nothing.</description>
        <lm-equiv name="Alias"></lm-equiv>
        <native-equiv name="Alias"></native-equiv>
      </child>

      <child name="AsClause" optional="true" kind="SimpleAsClause" order="60">
        <description>The "As" clause that describes the return type. If no As clause was present, Nothing is returned.</description>
      </child>
    </node-structure>

    <!--********************
      -  DelegateStatement
      **********************-->
    <node-structure name="DelegateStatementSyntax" parent="MethodBaseSyntax">
      <description>A statement that declares a delegate type.</description>
      <lm-equiv name="DelegateNode"></lm-equiv>
      <native-equiv name="DelegateDeclarationStatement"></native-equiv>

      <node-kind name="DelegateSubStatement">
        <lm-equiv name="Delegate" />
        <native-equiv name="Statement.Opcodes.DelegateProcedureDeclaration" />
      </node-kind>

      <node-kind name="DelegateFunctionStatement">
        <lm-equiv name="Delegate" />
        <native-equiv name="Statement.Opcodes.DelegateFunctionDeclaration" />
      </node-kind>

      <child name="DelegateKeyword" kind="DelegateKeyword" order="9">
        <description>The "Delegate" keyword.</description>
        <lm-equiv name="DelegateKeyword"></lm-equiv>
        <native-equiv name="Delegate"></native-equiv>
      </child>

      <child name="SubOrFunctionKeyword" order="10">
        <description>
          The "Sub" or "Function" keyword.
        </description>
        <kind name ="SubKeyword" node-kind="DelegateSubStatement" />
        <kind name ="FunctionKeyword" node-kind="DelegateFunctionStatement" />
      </child>
      
      <child name="Identifier" kind="IdentifierToken" order="20">
        <description>The name of the delegate being declared.</description>
        <lm-equiv name="Name"></lm-equiv>
        <native-equiv name="MethodSignatureStatement.Name"></native-equiv>
      </child>

      <child name="TypeParameterList" optional="true" kind="TypeParameterList" order="21">
        <description>
          If present, a type parameter list with generic type parameters for this delegate. If no generic type parameters were
          present, Nothing is returned.
        </description>
      </child>

      <child name="AsClause" optional="true" kind="SimpleAsClause" order="60">
        <description>The "As" clause that describes the return type. If no As clause was present, Nothing is returned.</description>
      </child>
    </node-structure>

    <!--********************
      -  EventStatement
      **********************-->
    <node-structure name="EventStatementSyntax" parent="MethodBaseSyntax">
      <description>
        A statement that declares an event. If the event being declared is a custom event, this
        statement will be the Begin of a PropertyOrEventBlock, and the accessors will be
        part of the Accessors of that node.
      </description>
      <lm-equiv name="EventNode"></lm-equiv>
      <native-equiv name="EventDeclarationStatement"></native-equiv>

      <node-kind name="EventStatement">
        <lm-equiv name="Event" />
        <native-equiv name="Statements.Opcodes.EventDeclaration" />
      </node-kind>

      <child name="CustomKeyword" kind="CustomKeyword" optional="true">
        <description>The optional Custom keyword for custom event declarations.</description>
      </child>

      <child name="EventKeyword" kind="EventKeyword" order="10">
        <description>
          The "Event" keyword that introduces this event declaration.
        </description>
      </child>
      
      <child name="Identifier" kind="IdentifierToken" order="20">
        <description>The name of the event being declared.</description>
        <lm-equiv name="Name"></lm-equiv>
        <native-equiv name="MethodSignatureStatement.Name"></native-equiv>
      </child>

      <child name="AsClause" optional="true" kind="SimpleAsClause" order="60">
        <description>The "As" clause that describes the return type. If no As clause was present, Nothing is returned.</description>
      </child>

      <child name="ImplementsClause" optional="true" kind="ImplementsClause" order="101">
        <description>
          If present, an Implements clause indicates the interface methods that this method implements.
        </description>
        <lm-equiv name="Implements"></lm-equiv>
        <native-equiv name="MethodDeclarationStatement.Implements"></native-equiv>
      </child>
    </node-structure>


    <!--********************
      -  OperatorStatement
      **********************-->
    <node-structure name="OperatorStatementSyntax" parent="MethodBaseSyntax">
      <description>
        A statement that declares an operator. If this operator has a body, this statement will
        be the Begin of a BlockStatement with Kind=MethodDeclarationBlock, and the body of the method will be the
        Body of that BlockStatement.
      </description>
      <lm-equiv name="OperatorNode"></lm-equiv>
      <native-equiv name="OperatorDefinitionStatement"></native-equiv>

      <node-kind name="OperatorStatement">
        <lm-equiv name="Operator" />
        <native-equiv name="Statements.Opcodes.OperatorDeclaration" />
      </node-kind>
      
      <child name="OperatorKeyword" kind="OperatorKeyword" order="10">
        <description>
          The "Operator" keyword that introduces this operator declaration.
        </description>
      </child>
      
      <child name="OperatorToken"  kind="CTypeKeyword|IsTrueKeyword|IsFalseKeyword|NotKeyword|PlusToken|MinusToken|AsteriskToken|SlashToken|CaretToken|BackslashToken|AmpersandToken|LessThanLessThanToken|GreaterThanGreaterThanToken|ModKeyword|OrKeyword|XorKeyword|AndKeyword|LikeKeyword|EqualsToken|LessThanGreaterThanToken|LessThanToken|LessThanEqualsToken|GreaterThanEqualsToken|GreaterThanToken" order="20">
        <description>The operator being defined.</description>
        <lm-equiv name="Operator"></lm-equiv>
        <native-equiv name="OperatorTokenType"></native-equiv>
      </child>

      <child name="AsClause" optional="true" kind="SimpleAsClause" order="60">
        <description>The "As" clause that describes the return type. If no As clause was present, Nothing is returned.</description>
      </child>
    </node-structure>

    <!--********************
      -  PropertyStatement
      **********************-->
    <node-structure name="PropertyStatementSyntax" parent="MethodBaseSyntax">
      <description>
        Statement that declares a property. If this property has accessors declared, this
        statement will be the Begin of a BlockNode, and the accessors will be
        the Body of that node. Auto properties are property declarations without a PropertyBlock.
      </description>
      <lm-equiv name="PropertyNode"></lm-equiv>
      <lm-equiv name="AutoPropertyNode">
        Normal and auto properties are declared with the same node kind. The IsAutomaticallyImplemented
        field distinguishes the cases.
      </lm-equiv>
      <native-equiv name="PropertyStatement"></native-equiv>
      <native-equiv name="AutoPropertyStatement">
        Normal and auto properties are declared with the same node kind. The IsAutomaticallyImplemented
        field distinguishes the cases.
      </native-equiv>

      <node-kind name="PropertyStatement">
        <lm-equiv name="Property" />
        <native-equiv name="Statements.Opcodes.Property" />
      </node-kind>

      <child name="PropertyKeyword" kind="PropertyKeyword" order="10">
        <description>
          The "Property" keyword that introduces this property declaration.
        </description>
      </child>
      
      <child name="Identifier" kind="IdentifierToken" order="20">
        <description>The name of the property being declared.</description>
        <lm-equiv name="Name"></lm-equiv>
        <native-equiv name="MethodSignatureStatement.Name"></native-equiv>
      </child>

      <child name="AsClause" optional="true" kind="@AsClauseSyntax" order="60">
        <description>The "As" clause that describes the return type. If no As clause was present, Nothing is returned.</description>
      </child>

      <child name="Initializer" optional="true" kind="EqualsValue" order="100">
        <description>If present, an "= initial-value" clause describing the initial value of the property.</description>
        <lm-equiv name="AutoPropertyNode.InitialValue"></lm-equiv>
        <native-equiv name="InitializerAutoPropertyDeclaration.InitialValue"></native-equiv>
      </child>

      <child name="ImplementsClause" optional="true" kind="ImplementsClause" order="101">
        <description>
          If present, an Implements clause indicated the interface methods that this method implements.
        </description>
      </child>
    </node-structure>

    <!--********************
      -  Accessor
      **********************-->
    <node-structure name="AccessorStatementSyntax" parent="MethodBaseSyntax">
      <description>
        Represents a Get or Set accessor on a property declaration or an AddHandler, RemoveHandler or RaiseEvent accessor
        on a custom event declaration. The Kind of the node determines what kind of accessor this is.
        This statement is always the Begin of a BlockNode, and the body of the accessor is
        the Body of that node.
      </description>
      <lm-equiv name="MethodNode" />
      <native-equiv name="MethodDefinitionStatement" />

      <node-kind name="GetAccessorStatement">
        <lm-equiv name="Statement.Opcodes.PropertyGet" />
      </node-kind>
      <node-kind name="SetAccessorStatement">
        <lm-equiv name="Statement.Opcodes.PropertySet" />
      </node-kind>
      <node-kind name="AddHandlerAccessorStatement">
        <lm-equiv name="Statement.Opcodes.AddHandlerDeclaration" />
      </node-kind>
      <node-kind name="RemoveHandlerAccessorStatement">
        <lm-equiv name="Statement.Opcodes.RemoveHandlerDeclaration" />
      </node-kind>
      <node-kind name="RaiseEventAccessorStatement">
        <lm-equiv name="Statement.Opcodes.RaiseEventDeclaration" />
      </node-kind>
    
      <child name="AccessorKeyword" order="10">
        <description>
          The "Get", "Set", "AddHandler", "RemoveHandler", or "RaiseEvent" keyword that introduces this accessor declaration.
        </description>
        <kind name ="GetKeyword" node-kind="GetAccessorStatement" />
        <kind name ="SetKeyword" node-kind="SetAccessorStatement" />
        <kind name ="AddHandlerKeyword" node-kind="AddHandlerAccessorStatement" />
        <kind name ="RemoveHandlerKeyword" node-kind="RemoveHandlerAccessorStatement" />
        <kind name ="RaiseEventKeyword" node-kind="RaiseEventAccessorStatement" />
      </child>
    </node-structure>

    <!--********************
      -  ImplementsClause
      **********************-->
    <!-- REVIEW: share this with the Implements statement that is inside a class? Its is structurally similar, 
    but used for different things. -->
    <node-structure name="ImplementsClauseSyntax" parent="VisualBasicSyntaxNode">
      <description>
        Represents the "Implements ..." clause on a type member, which describes which interface
        members this member implements.
      </description>

      <node-kind name="ImplementsClause" />

      <child name="ImplementsKeyword" kind="ImplementsKeyword">
        <description>The "Implements" keyword.</description>
        <lm-equiv name="EventNode.ImplementsKeyword"></lm-equiv>
        <lm-equiv name="MethodNode.ImplementsKeyword"></lm-equiv>
        <lm-equiv name="PropertyNode.ImplementsKeyword"></lm-equiv>
        <native-equiv name="PropertyStatement.Impl"></native-equiv>
        <native-equiv name="MethodDeclarationStatement.HandlesOrImplements"></native-equiv>
      </child>

      <child name="InterfaceMembers" list="true" separator-kind="CommaToken" separator-name="CommaTokens" kind="QualifiedName">
        <description>The list of interface members being implemented. </description>
        <lm-equiv name="EventNode.Implements"></lm-equiv>
        <lm-equiv name="MethodNode.Implements"></lm-equiv>
        <lm-equiv name="PropertyNode.Implements"></lm-equiv>
        <native-equiv name="PropertyStatement.Implements"></native-equiv>
        <native-equiv name="MethodDeclarationStatement.Implements"></native-equiv>
      </child>
    </node-structure>

    <!--********************
    -  HandlesClause
    **********************-->
    <node-structure name="HandlesClauseSyntax" parent="VisualBasicSyntaxNode">
      <description>
        Represents the "Handles ..." clause on a method declaration that describes which events
        this method handles.
      </description>

      <node-kind name="HandlesClause" />

      <child name="HandlesKeyword" kind="HandlesKeyword">
        <description>The "Handles" keyword.</description>
        <lm-equiv name="MethodNode.HandlesKeyword"></lm-equiv>
        <native-equiv name="MethodDeclarationStatement.HandlesOrImplements"></native-equiv>
      </child>

      <child name="Events" list="true" separator-kind="CommaToken" separator-name="CommaTokens" kind="HandlesClauseItem" min-count="1">
        <description>The list of event members being handled.</description>
        <lm-equiv name="MethodNode.Handles"></lm-equiv>
        <native-equiv name="MethodDeclarationStatement.Handles"></native-equiv>
      </child>
    </node-structure>

    <!--********************
    -  EventContainer
    **********************-->
    <node-structure name="EventContainerSyntax" abstract="true" parent="ExpressionSyntax">
      <description>
        Represents container of an event in a Handles clause item.
      </description>
    </node-structure>

    <!--********************
    -  KeywordEventContainer
    **********************-->
    <node-structure name="KeywordEventContainerSyntax" parent="EventContainerSyntax">
      <description>
        Represents event container specified through special keywords "Me", "MyBase" or "MyClass"..
      </description>

      <node-kind name="KeywordEventContainer">
      </node-kind>

      <child name="Keyword" kind="MyBaseKeyword|MeKeyword|MyClassKeyword">
        <description>
          The container of the event. This can be one of the special keywords: "Me", "MyBase" or "MyClass".
        </description>
      </child>
    </node-structure>

    <!--********************
    -  WithEventsEventContainer
    **********************-->
    <node-structure name="WithEventsEventContainerSyntax" parent="EventContainerSyntax">
      <description>
        Represents event container that refers to a WithEvents member.
      </description>

      <node-kind name="WithEventsEventContainer">
      </node-kind>

      <child name="Identifier" kind="IdentifierToken">
        <description>
          The container of the event. It is a simple identifier that refers to a WithEvents member of the containing type.
        </description>
      </child>
    </node-structure>

    <!--********************
    -  WithEventsPropertyEventContainer
    **********************-->
    <node-structure name="WithEventsPropertyEventContainerSyntax" parent="EventContainerSyntax">
      <description>
        Represents event container that refers to a WithEvents member's property.
      </description>

      <node-kind name="WithEventsPropertyEventContainer">
      </node-kind>

      <child name="WithEventsContainer" kind="WithEventsEventContainer">
        <description>
          The container of the event.
        </description>
      </child>

      <child name="DotToken" kind="DotToken">
        <description>The "." token.</description>
      </child>

      <child name="Property" kind="IdentifierName">
        <description>
          The provider of the event. It is a property of a WithEvents member of the containing type.
        </description>
      </child>
    </node-structure>

    <!--********************
      -  HandlesClauseItem: 
      **********************-->
    <node-structure name="HandlesClauseItemSyntax" parent="VisualBasicSyntaxNode">
      <description>Represents a single handled event in a "Handles ..." clause.</description>

      <node-kind name="HandlesClauseItem" />

      <child name="EventContainer" kind="KeywordEventContainer|WithEventsEventContainer">
        <description>
          The container of the event. This can either be a simple identifier (identifying a members of the containing
          type) or one of the special keywords "Me", "MyBase" or "MyClass".
        </description>
      </child>

      <child name="DotToken" kind="DotToken">
        <description>The "." token.</description>
      </child>

      <child name="EventMember" kind="IdentifierName">
        <description>The event being handled. This must be a simple identifier.</description>
      </child>
    </node-structure>

    <!--********************
      -  IncompleteMemberDeclaration
      **********************-->
    <node-structure name="IncompleteMemberSyntax" parent="DeclarationStatementSyntax">
      <description>
        Represents the beginning of a declaration. However, not enough syntax is detected to classify this as a field, method,
        property or event. This is node always represents a syntax error.
      </description>

      <node-kind name="IncompleteMember">
      </node-kind>

      <child name="AttributeLists" optional="true" list="true" kind="AttributeList">
        <description>A list of all attribute lists on this declaration. If no attributes were specified, an empty list is returned.</description>
        <lm-equiv name="Attributes"></lm-equiv>
        <native-equiv name="Attributes"></native-equiv>
      </child>

      <child name="Modifiers" optional="true" list="true" kind="PublicKeyword|PrivateKeyword|ProtectedKeyword|FriendKeyword|SharedKeyword|ShadowsKeyword|ReadOnlyKeyword|DimKeyword|ConstKeyword|WithEventsKeyword|WideningKeyword|NarrowingKeyword">
        <description>
          A list of all the modifier tokens that were present on this declaration. If no modifiers were specified, an empty list is returned.
        </description>
        <lm-equiv name="ModifierTokens"></lm-equiv>
        <native-equiv name="Specifiers"></native-equiv>
      </child>

      <child name="MissingIdentifier" optional="true" list="false" kind="IdentifierToken">
        <description>
          The missing identifier token for this incomplete member. Should only be used to have a location for error reporting.
        </description>
      </child>
    </node-structure>

    <!--********************
      -  FieldDeclaration
      **********************-->
    <node-structure name="FieldDeclarationSyntax" parent="DeclarationStatementSyntax">
      <description>
        Represents the declaration of one or more variables or constants, either as local variables or
        as class/structure members. In the case of a constant,
        it is represented by having "Const" in the Modifiers (although technically "Const" is not a modifier, it is represented
        as one in the parse trees.)
      </description>
      <lm-equiv name="FieldNode"></lm-equiv>
      <native-equiv name="VariableDeclarationStatement"></native-equiv>

      <node-kind name="FieldDeclaration">
        <lm-equiv name="Field"></lm-equiv>
        <native-equiv name="Statement.Opcodes.VariableDeclaration"></native-equiv>
      </node-kind>

      <child name="AttributeLists" optional="true" list="true" kind="AttributeList">
        <description>A list of all attribute lists on this declaration. If no attributes were specified, an empty list is returned.</description>
        <lm-equiv name="Attributes"></lm-equiv>
        <native-equiv name="Attributes"></native-equiv>
      </child>

      <child name="Modifiers" optional="true" list="true" kind="PublicKeyword|PrivateKeyword|ProtectedKeyword|FriendKeyword|SharedKeyword|ShadowsKeyword|ReadOnlyKeyword|DimKeyword|ConstKeyword|WithEventsKeyword|WideningKeyword|NarrowingKeyword">
        <description>
          A list of all the modifier tokens that were present on this declaration. If no modifiers were specified, an empty list is returned.
        </description>
        <lm-equiv name="ModifierTokens"></lm-equiv>
        <native-equiv name="Specifiers"></native-equiv>
      </child>

      <child name="Declarators" list="true" separator-kind="CommaToken" separator-name="CommaTokens" kind="VariableDeclarator" min-count="1">
        <description>
          The list of variable declarator. Each declarator specifies one or more variable names along
          with a type and/or initializer.
        </description>
        <lm-equiv name="Declarations"></lm-equiv>
        <native-equiv name="Declarations"></native-equiv>
      </child>
    </node-structure>


    <!--********************
      -  VariableDeclarator
      **********************-->
    <node-structure name="VariableDeclaratorSyntax" parent="VisualBasicSyntaxNode">
      <description>
        Represents the part of a variable or constant declaration statement that associated one or more variable
        names with a type.
      </description>
      <lm-equiv name="VariableGroupNode"></lm-equiv>
      <native-equiv name="VariableDeclaration"></native-equiv>

      <node-kind name="VariableDeclarator">
        <lm-equiv name="VariableGroup"></lm-equiv>
        <lm-equiv name="VariableGroupWIthNew"></lm-equiv>
        <lm-equiv name="VariableGroupWithValue"></lm-equiv>
        <native-equiv name="VariableDeclaration.Opcodes.NoInitializer"></native-equiv>
        <native-equiv name="VariableDeclaration.Opcodes.WithInitializer"></native-equiv>
        <native-equiv name="VariableDeclaration.Opcodes.WithNew"></native-equiv>
      </node-kind>

      <child name="Names" list="true" separator-kind="CommaToken" separator-name="CommaTokens" kind="ModifiedIdentifier" min-count="1">
        <description>The names of the variables being declared. Each name might have a "?" or "()" modifier(s) attached.</description>
        <lm-equiv name="Declarators"></lm-equiv>
        <native-equiv name="Variable"></native-equiv>
      </child>

      <child name="AsClause" optional="true" kind="@AsClauseSyntax">
        <description>
          The "As" clause that describes the return type, and possibly includes "New", "With" or "From".
          If no As clause was present, Nothing is returned.
        </description>
      </child>

      <child name="Initializer" optional="true" kind="EqualsValue">
        <description>If present, an "= initial-value" clause describing the initial value of the variable or the value of the constant.</description>
        <lm-equiv name="AutoPropertyNode.InitialValue"></lm-equiv>
        <native-equiv name="InitializerAutoPropertyDeclaration.InitialValue"></native-equiv>
      </child>
    </node-structure>


    <!-- ************************************************************************************************** -->
    <!-- **  DECLARATION PARTS (As clause, Initializer, Parameter, ...)                                  ** -->
    <!-- ************************************************************************************************** -->

    <!--********************
      -  AsClauseNode
      **********************-->
    <node-structure name="AsClauseSyntax" parent="VisualBasicSyntaxNode" abstract="true">
      <description>
        Abstract node class that represents the different kinds of "As {type-name}" clauses in a declaration: simple
        "As" clauses and "As New" clauses. The type has optional attributes associated with it, although attributes are not permitted in all possible places
        where this node occurs.
      </description>

      <child name="AsKeyword" order="-3" kind="AsKeyword">
        <description>The "As" keyword.</description>
        <lm-equiv name="Parameter.AsKeyword"></lm-equiv>
        <lm-equiv name="VariableGroupNode.AsKeyword"></lm-equiv>
        <native-equiv name="Parameter.As"></native-equiv>
        <native-equiv name="VariableDeclaration.As"></native-equiv>
      </child>
    </node-structure>

    <!--********************
      -  SimpleAsClauseNode
      **********************-->
    <node-structure name="SimpleAsClauseSyntax" parent="AsClauseSyntax">
      <description>
        Represents an "As {type-name}" clause that does not have an initializer or "New".
        The type has optional attributes associated with it, although attributes are not permitted in all possible places
        where this node occurs.
      </description>

      <!-- REVIEW: Have a different node kind where attributes are permitted? Would this add anything at all? -->
      <node-kind name="SimpleAsClause"></node-kind>

      <child name="AttributeLists" order="-1" optional="true" list="true" kind="AttributeList">
        <description>A list of all attribute lists on the type. If no attributes were specified, an empty list is returned.</description>
        <lm-equiv name="MethodBase.ReturnTypeAttributes"></lm-equiv>
        <native-equiv name="MethodSignature.ReturnTypeAttributes"></native-equiv>
      </child>

      <child name="Type" kind="@TypeSyntax" order="10">
        <description>The type-name part of the As clause.</description>
        <lm-equiv name="VariableGroupNode.VariableType"></lm-equiv>
        <lm-equiv name="ParameterNode.ParameterType"></lm-equiv>
        <lm-equiv name="CatchNode.ExceptionType"></lm-equiv>
        <native-equiv name="VariableDeclaration.Type"></native-equiv>
        <native-equiv name="Parameter.Type"></native-equiv>
        <native-equiv name="CatchStatement.Type"></native-equiv>
      </child>
    </node-structure>


    <!--********************
      -  AsNewClauseNode
      **********************-->
    <node-structure name="AsNewClauseSyntax" parent="AsClauseSyntax">
      <description>
        Represents an "As New {type-name} [arguments] [initializers]" clause in a declaration. The type has optional attributes associated with it,
        although attributes are not permitted in many places where this node occurs (they are permitted, for example, on automatically implemented
        properties.)
      </description>

      <node-kind name="AsNewClause"></node-kind>

      <child name="NewExpression" order="-2" kind="@NewExpressionSyntax">
        <description>The New expression</description>
      </child>
    </node-structure>


    <!--********************
      -  ObjectCreationInitializerNode
      **********************-->
    <node-structure name="ObjectCreationInitializerSyntax" parent="VisualBasicSyntaxNode" abstract="true">
      <description>An abstract node class that represents a "With" or "From" clause used to initializer an new object.</description>
    </node-structure>

    <node-structure name="ObjectMemberInitializerSyntax" parent="ObjectCreationInitializerSyntax">
      <description>Represents a "With {...} clause used to initialize a new object's members.</description>
      <native-equiv name="ObjectInitializerList" />

      <node-kind name="ObjectMemberInitializer" />

      <child name="WithKeyword" kind="WithKeyword">
        <description>The "With" keyword.</description>
        <lm-equiv name="WithKeyword"></lm-equiv>
        <lm-equiv name="VariableGroupWithNewNode.WithKeyword"></lm-equiv>
        <native-equiv name="With"></native-equiv>
      </child>

      <child name="OpenBraceToken" kind="OpenBraceToken">
        <description>The "{" token.</description>
        <lm-equiv name="LeftBrace"></lm-equiv>
        <lm-equiv name="VariableGroupWithNewNode.LeftBrace"></lm-equiv>
        <native-equiv name="GetLocationOfLBrace"></native-equiv>
      </child>

      <child name="Initializers" list="true" separator-kind="CommaToken" separator-name="CommaTokens" kind="@FieldInitializerSyntax">
        <description>The comma-separated list of field initializers.</description>
        <lm-equiv name="Initializers"></lm-equiv>
        <lm-equiv name="VariableGroupWithNewNode.Initializers"></lm-equiv>
        <lm-equiv name="NewWithInitializerNode.Initializers"></lm-equiv>
        <native-equiv name="BracedInitializerList"></native-equiv>
        <native-equiv name="ObjectInitializerExpression.InitialValues"></native-equiv>
      </child>

      <child name="CloseBraceToken" kind="CloseBraceToken">
        <description>The "}" token.</description>
        <lm-equiv name="RightBrace"></lm-equiv>
        <lm-equiv name="VariableGroupWithNewNode.RightBrace"></lm-equiv>
        <native-equiv name="GetLocationOfRBrace"></native-equiv>
      </child>
    </node-structure>

    <!--********************
      -  ObjectCollectionInitializerNode
      **********************-->
    <node-structure name="ObjectCollectionInitializerSyntax" parent="ObjectCreationInitializerSyntax">
      <description>Represents a "From {...} clause used to initialize a new collection object's elements.</description>
      <lm-equiv name="CollectionInitializerNode"></lm-equiv>
      <lm-equiv name="VariableGroupWithNewNode"></lm-equiv>

      <node-kind name="ObjectCollectionInitializer" />

      <child name="FromKeyword" kind="FromKeyword">
        <description>The "From" keyword.</description>
        <lm-equiv name="FromKeyword"></lm-equiv>
        <lm-equiv name="VariableGroupWithNewNode.FromKeyword"></lm-equiv>
        <native-equiv name="NewVariableDeclaration.From"></native-equiv>
        <native-equiv name="CollectionInitializerExpression.GetLocationOfFrom"></native-equiv>
        <native-equiv name="CollectionInitializerExpression.From"></native-equiv>
        <native-equiv name="NewAutoPropertyDeclaration.From"></native-equiv>
      </child>

      <!-- REVIEW: should an initializer list between braces be a node by itself, matching CollectionInitializer in the grammar? -->

      <child name="Initializer" kind="CollectionInitializer">
        <description>The initializer including the braces.</description>
      </child>

    </node-structure>

    <!--********************
      -  FieldInitializer
      **********************-->
    <node-structure name="FieldInitializerSyntax" abstract="true" parent="VisualBasicSyntaxNode">
      <description>Abstract class that represent a single field initializer used in a "With {...}" field initializer list.</description>
      <lm-equiv name="InitializerNode"></lm-equiv>
      <native-equiv name="Initializer"></native-equiv>

      <child name="KeyKeyword" optional="true" kind="KeyKeyword">
        <description>The optional "Key" keyword.</description>
        <lm-equiv name="KeyKeyword"></lm-equiv>
        <native-equiv name="Key"></native-equiv>
        <native-equiv name="Initializer.Key"></native-equiv>
        <native-equiv name="Initializer.FieldIsKey">
          "FieldIsKey" may be set to true by the native parser even in cases where
          the "Key" keyword was not set (I think in query expressions, but I'm not at all sure). More code review is needed to understand how this field
          might be computed from the new parse trees.
        </native-equiv>
      </child>
    </node-structure>


    <!--********************
      -  InferredFieldInitializer
      **********************-->
    <node-structure name="InferredFieldInitializerSyntax" parent="FieldInitializerSyntax">
      <description>
        Represent a field initializer in a With {...} initializer where the field name is inferred from
        the initializer expression.
      </description>
      <lm-equiv name="InitializerNode"></lm-equiv>
      <native-equiv name="Initializer"></native-equiv>

      <node-kind name="InferredFieldInitializer">
        <lm-equiv name="Initializer" />
        <native-equiv name="Initializer.Opcodes.Expression" />
      </node-kind>

      <!-- TODO: Add XmlMemberAccess to the kind.-->
      <child name="Expression" kind="IdentifierName|SimpleMemberAccessExpression|DictionaryAccessExpression">
        <description>The value being assigned.</description>
        <lm-equiv name="Value"></lm-equiv>
        <native-equiv name="ExpressionInitializer.Value"></native-equiv>
      </child>
    </node-structure>

    <!--********************
      -  NamedFieldInitializer
      **********************-->
    <node-structure name="NamedFieldInitializerSyntax" parent="FieldInitializerSyntax">
      <description>Represent a named field initializer in a With {...} initializer, such as ".x = expr".</description>
      <lm-equiv name="NamedInitializerNode"></lm-equiv>
      <native-equiv name="AssignmentInitializer"></native-equiv>

      <node-kind name="NamedFieldInitializer">
        <lm-equiv name="NamedInitializer" />
        <native-equiv name="Initializer.Opcodes.Assignment" />
      </node-kind>

      <child name="DotToken" kind="DotToken">
        <description>The "." token.</description>
        <lm-equiv name="Dot"></lm-equiv>
        <native-equiv name="Dot"></native-equiv>
      </child>

      <child name="Name" kind="IdentifierName">
        <description>The name of the field being initialized.</description>
        <lm-equiv name="Name"></lm-equiv>
        <native-equiv name="Name"></native-equiv>
      </child>

      <child name="EqualsToken" kind="EqualsToken">
        <description>The "=" token.</description>
        <lm-equiv name="Equal"></lm-equiv>
        <native-equiv name="Equals"></native-equiv>
      </child>

      <child name="Expression" kind="@ExpressionSyntax">
        <!-- TODO: Review the type of this child. Is Expression correct? -->
        <description>The value being assigned to the field.</description>
        <lm-equiv name="Value"></lm-equiv>
        <native-equiv name="ExpressionInitializer.Value"></native-equiv>
      </child>
    </node-structure>

    <!--********************
      -  InitializerNode
      **********************-->
    <node-structure name="EqualsValueSyntax" parent="VisualBasicSyntaxNode">
      <description>
        Represents an "= initializer" clause in a declaration for a variable, parameter or automatic property.
      </description>

      <node-kind name="EqualsValue"></node-kind>

      <child name="EqualsToken" kind="EqualsToken">
        <description>The "=" token.</description>
        <lm-equiv name="VariableGroupWithValueNode.Equal"></lm-equiv>
        <lm-equiv name="ParameterWithValueNode.Equal"></lm-equiv>
        <lm-equiv name="AutoPropertyNode.Equal"></lm-equiv>
        <native-equiv name="InitializerVariableDeclaration.Equals"></native-equiv>
        <native-equiv name="InitializerAutoPropertyDeclaration.Equals"></native-equiv>
      </child>

      <!-- REVIEW: Need to make sure that Expression is everything that can occur here. Some places
      in LM use Initializer, which can include other stuff. -->
      <child name="Value" kind="@ExpressionSyntax">
        <description>The expression used as the initial value.</description>
        <lm-equiv name="VariableGroupWithValueNode.InitialValue"></lm-equiv>
        <lm-equiv name="ParameterWithValueNode.DefaultValue"></lm-equiv>
        <lm-equiv name="AutoPropertyNode.InitialValue"></lm-equiv>
        <!-- TODO: Get native equivalent. -->
        <native-equiv name=""></native-equiv>
      </child>
    </node-structure>

    <!--********************
      -  ParameterNode
      **********************-->
    <node-structure name="ParameterSyntax" parent="VisualBasicSyntaxNode">
      <description>Represent a parameter to a method, property, constructor, etc.</description>
      <lm-equiv name="ParameterNode"></lm-equiv>
      <lm-equiv name="ParameterWithValueNode"></lm-equiv>
      <native-equiv name="Parameter"></native-equiv>
      <native-equiv name="OptionalParameter"></native-equiv>

      <node-kind name="Parameter">
        <lm-equiv name="Parameter" />
        <lm-equiv name="ParameterWithValue" />
      </node-kind>

      <child name="AttributeLists" optional="true" list="true" kind="AttributeList">
        <description>A list of all attribute lists on this parameter. If no attributes were specified, Nothing is returned.</description>
        <lm-equiv name="Attributes"></lm-equiv>
        <native-equiv name="Attributes"></native-equiv>
      </child>

      <child name="Modifiers" optional="true" list="true" kind="ByValKeyword|ByRefKeyword|OptionalKeyword|ParamArrayKeyword">
        <description>A list of the modifier tokens "ByVal", "ByRef", "Optional" or "ParamArray" that modify this parameter.</description>
        <lm-equiv name="ModifierTokens"></lm-equiv>
        <native-equiv name="Specifiers"></native-equiv>
      </child>

      <child name="Identifier" kind="ModifiedIdentifier">
        <description>The name of the parameter, including any "?" or "()" modifiers.</description>
        <lm-equiv name="Name"></lm-equiv>
        <native-equiv name="Name"></native-equiv>
      </child>

      <child name="AsClause" optional="true" kind="SimpleAsClause">
        <description>
          If present, the "As type-name" clause describing the type of the parameter. If no As clause is present,
          Nothing is returned.
        </description>
      </child>

      <child name="Default" optional="true" kind="EqualsValue">
        <description>
          If present, an initializer with the default value of the parameter. If no default value is present,
          Nothing is returned.
        </description>
      </child>
    </node-structure>


    <!--********************
      -  ModifiedIdentifier
      **********************-->
    <!-- REVIEW: Need better name. What does spec call it? -->
    <node-structure name="ModifiedIdentifierSyntax" parent="VisualBasicSyntaxNode">
      <description>
        Represents an identifier with optional "?" or "()" or "(,,,)" modifiers, as used in parameter declarations and
        variable declarations.
      </description>
      <lm-equiv name="DeclaratorNode"></lm-equiv>
      <native-equiv name="Declarator"></native-equiv>

      <node-kind name="ModifiedIdentifier">
        <lm-equiv name="Declarator" />
      </node-kind>

      <child name="Identifier" kind="IdentifierToken">
        <description>The identifier that names the item being declared.</description>
        <lm-equiv name="Name"></lm-equiv>
        <native-equiv name="Name"></native-equiv>
      </child>

      <!-- REVIEW: Is "Nullable" or "QuestionMarkToken" the right name? -->
      <child name="Nullable" optional="true" kind="QuestionToken">
        <description>The "?" token that indicates a nullable type.</description>
        <lm-equiv name="IdentifierNode.IsNullable">IsNullable moves to the ModifiedIdentifier node. </lm-equiv>
        <native-equiv name="IdentifierDescriptor.IsNullable">IsNullable moves to the ModifiedIdentifier node. </native-equiv>
      </child>

      <child name="ArrayBounds" optional="true" kind="ArgumentList">
        <description>The optional array bounds, such as "(4)" or "(0 to 5, 0 To 6)".</description>
        <lm-equiv name="IdentifierNode.IsNullable">IsNullable moves to the ModifiedIdentifier node. </lm-equiv>
        <native-equiv name="IdentifierDescriptor.IsNullable">IsNullable moves to the ModifiedIdentifier node. </native-equiv>
      </child>

      <child name="ArrayRankSpecifiers" optional="true" list="true" kind="ArrayRankSpecifier">
        <description>A list of array modifiers for the type. If no array modifiers were present, an empty list is returned.</description>
        <lm-equiv name="ArrayInfo"></lm-equiv>
        <native-equiv name="ArrayInfo"></native-equiv>
      </child>
    </node-structure>

    <node-structure name="ArrayRankSpecifierSyntax" parent="VisualBasicSyntaxNode">
      <description>Represents a modifier that describes an array type, without bounds, such as "()" or "(,)".</description>

      <node-kind name="ArrayRankSpecifier" />

      <child name="OpenParenToken" kind="OpenParenToken">
        <description>The "(" token.</description>
        <lm-equiv name="ArrayTypeNode.LeftParenthesis"></lm-equiv>
        <native-equiv name="ArrayType.LeftParen"></native-equiv>
      </child>

      <child name="CommaTokens" optional="true" list="true" kind="CommaToken">
        <description>The comma tokens in the array type. There is one less comma than the rank.</description>
        <lm-equiv name="ArrayTypeNode.Dims"></lm-equiv>
        <native-equiv name=""></native-equiv>
      </child>

      <child name="CloseParenToken" kind="CloseParenToken">
        <description>The ")" token.</description>
        <lm-equiv name="ArrayTypeNode.RightParenthesis"></lm-equiv>
        <native-equiv name=""></native-equiv>
      </child>
    </node-structure>

    <!-- ************************************************************************************************** -->
    <!-- **  ATTRIBUTES                                                                                  ** -->
    <!-- ************************************************************************************************** -->



    <!--********************
      -  AttributeListNode
      **********************-->
    <node-structure name="AttributeListSyntax" parent="VisualBasicSyntaxNode">

      <description>Represents a group of attributes within "&lt;" and "&gt;" brackets.</description>

      <lm-equiv name="AttributeGroup"></lm-equiv>
      <native-equiv name="AttributeSpecifier"></native-equiv>

      <node-kind name="AttributeList">
        <lm-equiv name="AttributeGroup" />
      </node-kind>

      <child name="LessThanToken" kind="LessThanToken">
        <description>The "&lt;" token.</description>
        <lm-equiv name="LeftBracket"></lm-equiv>
        <native-equiv name=""></native-equiv>
      </child>

      <child name="Attributes" optional="true" separator-kind="CommaToken" separator-name="CommaTokens" list="true" kind="Attribute" min-count="1">
        <description>A comma separated list of attribute declarations in this attribute list.</description>
        <lm-equiv name="Attributes"></lm-equiv>
        <native-equiv name="Values"></native-equiv>
      </child>

      <child name="GreaterThanToken" kind="GreaterThanToken">
        <description>The "&gt;" token.</description>
        <lm-equiv name="RightBracket"></lm-equiv>
        <native-equiv name=""></native-equiv>
      </child>
    </node-structure>

    <!--********************
      -  Attribute
      **********************-->
    <node-structure name="AttributeSyntax" parent="VisualBasicSyntaxNode">
      <description>Represents a single attribute declaration within an attribute list.</description>

      <lm-equiv name="AttributeNode"></lm-equiv>
      <native-equiv name="Attribute"></native-equiv>

      <node-kind name="Attribute">
        <lm-equiv name="Attribute" />
      </node-kind>

      <child name="Target" optional="true" kind="AttributeTarget">
        <description>Optional attribute target. Assembly|Module :</description>
      </child>

      <child name="Name" kind="NonArrayNonTupleTypeName">
        <description>The name of the attribute.</description>
        <lm-equiv name="Name"></lm-equiv>
        <native-equiv name="Name"></native-equiv>
      </child>

      <child name="ArgumentList" optional="true" kind="ArgumentList">
        <description>The argument list, if present. If no argument list was supplied, Nothing is returned.</description>
        <lm-equiv name="Arguments"></lm-equiv>
        <native-equiv name="Arguments" />
      </child>

    </node-structure>

    <!--********************
      -  AttributeTargetSyntax
      **********************-->
    <node-structure name="AttributeTargetSyntax" parent="VisualBasicSyntaxNode">
      <description>Represents a single attribute declaration within an attribute list.</description>

      <node-kind name="AttributeTarget">
      </node-kind>

      <child name="AttributeModifier" kind="AssemblyKeyword|ModuleKeyword">
        <description>The "Assembly" or "Module" attribute modifier, is present. If no attribute modifier is present, Nothing is returned.</description>
        <lm-equiv name="Target"></lm-equiv>
        <native-equiv name="IsAssembly"></native-equiv>
        <native-equiv name="IsModule"></native-equiv>
      </child>

      <child name="ColonToken" kind="ColonToken">
        <description>The ":" token, if an attribute modifier is present. If no attribute modifier is present, Nothing is returned.</description>
        <lm-equiv name="Colon"></lm-equiv>
        <native-equiv name="Colon"></native-equiv>
      </child>

    </node-structure>


    <!--********************
      -  AttributeStatementNode
      **********************-->
    <node-structure name="AttributesStatementSyntax" parent="DeclarationStatementSyntax">
      <description>Represents a file-level attribute, in which the attributes have no other syntactic element they are attached to.</description>
      <lm-equiv name="AttributeStatementNode"></lm-equiv>
      <native-equiv name="AttributeStatement"></native-equiv>

      <node-kind name="AttributesStatement">
        <lm-equiv name="AttributeStatement" />
        <native-equiv name="Statement.Opcodes.Attribute" />
      </node-kind>

      <child name="AttributeLists" optional="true" list="true" kind="AttributeList">
        <description>The list of attribute lists.</description>
        <lm-equiv name="Attributes"></lm-equiv>
        <native-equiv name="Attributes"></native-equiv>
      </child>
    </node-structure>


    <!-- ************************************************************************************************** -->
    <!-- **  EXECUTABLE STATEMENTS                                                                       ** -->
    <!-- ************************************************************************************************** -->

    <!--****************
      -  ExpressionStatement
      ******************-->
    <node-structure name="ExpressionStatementSyntax" parent="ExecutableStatementSyntax" >
      <description>
        Represent an expression in a statement context.
        This may only be a invocation or await expression in standard code but may be any expression in VB Interactive code.
      </description>
      <grammar>ExpressionStatement</grammar>

      <node-kind name="ExpressionStatement" />

      <child name="Expression" kind="@ExpressionSyntax">
        <description>The expression.</description>
      </child>
    </node-structure>

    <!--****************
      -  PrintStatement
      ******************-->
    <node-structure name="PrintStatementSyntax" parent="ExecutableStatementSyntax" >
      <description>Represent a "? expression" "Print" statement in VB Interactive code.</description>
      <grammar>ExpressionStatement</grammar>

      <node-kind name="PrintStatement" />

      <child name="QuestionToken" kind="QuestionToken">
        <description>"?" token.</description>
      </child>

      <child name="Expression" kind="@ExpressionSyntax">
        <description>The expression whose value is being output.</description>
      </child>
    </node-structure>

    <!--****************
      -  WhileBlock
      ******************-->
    <node-structure name="WhileBlockSyntax" parent="ExecutableStatementSyntax">
      <description>
        Represents a While...End While statement, including the While, body and End While.
      </description>

      <lm-equiv name="BlockNode"></lm-equiv>
      <native-equiv name="BlockStatement"></native-equiv>

      <node-kind name="WhileBlock">
        <lm-equiv name="While" />
        <native-equiv name="Statements.Opcodes.While" />
      </node-kind>

      <child name="WhileStatement" kind="WhileStatement">
        <description>The While statement that begins the block. </description>
        <lm-equiv name=""></lm-equiv>
        <native-equiv name=""></native-equiv>
      </child>

      <child name="Statements" optional="true" list="true" kind="@StatementSyntax">
        <description>The statements contained in the While...End While. This might be an empty list.</description>
        <lm-equiv name="BlockNode.Contents"></lm-equiv>
        <native-equiv name="BlockStatement.Children"></native-equiv>
      </child>

      <child name="EndWhileStatement" kind="EndWhileStatement">
        <description>
          The End While statement that ends the block.
        </description>
        <lm-equiv name="EndBlock"></lm-equiv>
        <native-equiv name="TerminatingConstruct"></native-equiv>
      </child>
    </node-structure>

    <!--****************
      -  UsingBlock
      ******************-->
    <node-structure name="UsingBlockSyntax" parent="ExecutableStatementSyntax">
      <description>
        Represents an entire Using...End Using statement, including the Using, body and End Using statements.
      </description>

      <lm-equiv name="BlockNode"></lm-equiv>
      <native-equiv name="BlockStatement"></native-equiv>

      <node-kind name="UsingBlock">
        <lm-equiv name="Using" />
        <native-equiv name="Statement.Opcodes.Using" />
      </node-kind>

      <child name="UsingStatement" kind="UsingStatement">
        <description>The UsingStatement that begins the Using...End Using block. </description>
        <lm-equiv name=""></lm-equiv>
        <native-equiv name=""></native-equiv>
      </child>

      <child name="Statements" optional="true" list="true" kind="@StatementSyntax">
        <description>The statements contained in the Using...End Using block. This might be an empty list.</description>
        <lm-equiv name="BlockNode.Contents"></lm-equiv>
        <native-equiv name="BlockStatement.Children"></native-equiv>
      </child>

      <child name="EndUsingStatement" kind="EndUsingStatement">
        <description>
          The End Using statement that ends the block.
        </description>
        <lm-equiv name="EndBlock"></lm-equiv>
        <native-equiv name="TerminatingConstruct"></native-equiv>
      </child>
    </node-structure>

    <!--****************
      -  SyncLockBlock
      ******************-->
    <node-structure name="SyncLockBlockSyntax" parent="ExecutableStatementSyntax">
      <description>
        Represents a entire SyncLock...End SyncLock block, including the SyncLock statement, the enclosed statements,
        and the End SyncLock statement.
      </description>

      <lm-equiv name="BlockNode"></lm-equiv>
      <native-equiv name="BlockStatement"></native-equiv>

      <node-kind name="SyncLockBlock">
        <lm-equiv name="SyncLock" />
        <native-equiv name="Statement.Opcodes.SyncLock" />
      </node-kind>

      <child name="SyncLockStatement" kind="SyncLockStatement">
        <description>The SyncLock statement that begins the block. </description>
        <lm-equiv name=""></lm-equiv>
        <native-equiv name=""></native-equiv>
      </child>

      <child name="Statements" optional="true" list="true" kind="@StatementSyntax">
        <description>The statements contained in the SyncLock...End SyncLock statement. This might be an empty list.</description>
        <lm-equiv name="BlockNode.Contents"></lm-equiv>
        <native-equiv name="BlockStatement.Children"></native-equiv>
      </child>

      <child name="EndSyncLockStatement" kind="EndSyncLockStatement">
        <description>
          The End SyncLock statement that ends the block.
        </description>
        <lm-equiv name="EndBlock"></lm-equiv>
        <native-equiv name="TerminatingConstruct"></native-equiv>
      </child>
    </node-structure>

    <!--****************
      -  WithBlock
      ******************-->
    <node-structure name="WithBlockSyntax" parent="ExecutableStatementSyntax">
      <description>
        Represents a With...End With block, include the With statement, the body of the block and the
        End With statement.
      </description>

      <lm-equiv name="BlockNode"></lm-equiv>
      <native-equiv name="BlockStatement"></native-equiv>

      <node-kind name="WithBlock">
        <lm-equiv name="With" />
        <native-equiv name="Statement.Opcodes.With" />
      </node-kind>

      <child name="WithStatement" kind="WithStatement">
        <description>The WithStatement that begins the With...End With block. </description>
        <lm-equiv name=""></lm-equiv>
        <native-equiv name=""></native-equiv>
      </child>

      <child name="Statements" optional="true" list="true" kind="@StatementSyntax">
        <description>The statements contained in the With...End With block. This might be an empty list.</description>
        <lm-equiv name="BlockNode.Contents"></lm-equiv>
        <native-equiv name="BlockStatement.Children"></native-equiv>
      </child>

      <child name="EndWithStatement" kind="EndWithStatement">
        <description>
          The End With statement that ends the block.
        </description>
        <lm-equiv name="EndBlock"></lm-equiv>
        <native-equiv name="TerminatingConstruct"></native-equiv>
      </child>
    </node-structure>

    <!--********************
      -  LocalVariable
      **********************-->
    <node-structure name="LocalDeclarationStatementSyntax" parent="ExecutableStatementSyntax">
      <description>Represents the declaration of one or more local variables or constants. </description>
      <lm-equiv name="FieldNode"></lm-equiv>
      <native-equiv name="VariableDeclarationStatement"></native-equiv>

      <node-kind name="LocalDeclarationStatement">
        <lm-equiv name="Field"></lm-equiv>
        <native-equiv name="Statement.Opcodes.VariableDeclaration"></native-equiv>
      </node-kind>
      <child name="Modifiers" list="true" kind="StaticKeyword|DimKeyword|ConstKeyword">
        <description>
          The modifier token (Static, Dim or Const) that introduces this local variable declaration.
        </description>
        <lm-equiv name="ModifierTokens"></lm-equiv>
        <native-equiv name="Specifiers"></native-equiv>
      </child>

      <child name="Declarators" list="true" separator-kind="CommaToken" separator-name="CommaTokens" kind="VariableDeclarator" min-count="1">
        <description>
          The list of variable declarator. Each declarator specifies one or more variable names along
          with a type and/or initializer.
        </description>
        <lm-equiv name="Declarations"></lm-equiv>
        <native-equiv name="Declarations"></native-equiv>
      </child>
    </node-structure>

    <!--****************
      -  Label
      ******************-->
    <node-structure name="LabelStatementSyntax" parent="ExecutableStatementSyntax">
      <description>Represents a label statement.</description>
      <lm-equiv name="LabelNode"></lm-equiv>
      <native-equiv name="LabelReferenceStatement"></native-equiv>

      <node-kind name="LabelStatement">
        <lm-equiv name="Label" />
        <native-equiv name="Statement.Opcodes.Label" />
      </node-kind>

      <child name="LabelToken" kind="IdentifierToken|IntegerLiteralToken">
        <description>
          The name of the label. If the label is a line number, returns an IntegerLiteral that is the line number,
          otherwise, returns an Identifier.
        </description>
        <lm-equiv name="Name"></lm-equiv>
        <native-equiv name="Label"></native-equiv>
      </child>

      <child name="ColonToken" kind="ColonToken">
        <description>The ":" token of the label statement.</description>
        <lm-equiv name="Colon"></lm-equiv>
      </child>
    </node-structure>

    <!--****************
      -  GoToStatement
      ******************-->
    <node-structure name="GoToStatementSyntax" parent="ExecutableStatementSyntax">
      <description>Represents a "GoTo" statement.</description>
      <lm-equiv name="GoToNode"></lm-equiv>
      <native-equiv name="LabelReferenceStatement"></native-equiv>

      <node-kind name="GoToStatement">
        <lm-equiv name="GoTo" />
        <native-equiv name="Statement.Opcodes.Goto" />
      </node-kind>

      <child name="GoToKeyword" kind="GoToKeyword">
        <description>The "GoTo" keyword.</description>
        <lm-equiv name="GoToKeyword"></lm-equiv>
        <native-equiv name=""></native-equiv>
      </child>

      <child name="Label" kind="@LabelSyntax">
        <description>
          The name of the label. If the label is a line number, wraps an IntegerLiteral that is the line number,
          otherwise, wraps an Identifier.
        </description>
        <lm-equiv name="Label"></lm-equiv>
        <native-equiv name="Label"></native-equiv>
      </child>
    </node-structure>

    <node-structure name="LabelSyntax" parent="ExpressionSyntax">
      <description>A label for a GoTo, Resume, or On Error statement.  An identifier, line number, or next keyword.</description>

      <node-kind name="IdentifierLabel">
      </node-kind>
      <node-kind name="NumericLabel">
      </node-kind>
      <node-kind name="NextLabel">
      </node-kind>

      <child name="LabelToken" >
        <description>The label name (identifier), line number (integer literal), or next keyword token.</description>
        <kind name="IdentifierToken" node-kind="IdentifierLabel"/>
        <kind name="IntegerLiteralToken" node-kind="NumericLabel"/>
        <kind name="NextKeyword" node-kind="NextLabel"/>
      </child>
    </node-structure>

    <!--****************
      -  StopOrEnd
      ******************-->
    <node-structure name="StopOrEndStatementSyntax" parent="ExecutableStatementSyntax">
      <description>
        Represents a "Stop" or "End" statement. The Kind can be used to determine which kind of statement
        this is.
      </description>
      <lm-equiv name="StopNode"></lm-equiv>
      <lm-equiv name="EndNode"></lm-equiv>
      <native-equiv name="Statement"></native-equiv>
      <spec-section>10.11</spec-section>
      <grammar>StopStatement</grammar>
      <grammar>EndStatement</grammar>

      <node-kind name="StopStatement">
        <lm-equiv name="Stop" />
        <native-equiv name="Statement.Opcodes.Stop" />
      </node-kind>

      <node-kind name="EndStatement">
        <lm-equiv name="End" />
        <native-equiv name="Statement.Opcodes.End" />
      </node-kind>

      <child name="StopOrEndKeyword" kind="StopKeyword|EndKeyword">
        <description>The "Stop" or "End" keyword.</description>
        <lm-equiv name="StopKeyword"></lm-equiv>
        <lm-equiv name="EndKeyword"></lm-equiv>
        <native-equiv name=""></native-equiv>
      </child>
    </node-structure>

    <!--****************
      -  Exit
      ******************-->
    <node-structure name="ExitStatementSyntax" parent="ExecutableStatementSyntax">
      <description>An exit statement. The kind of block being exited can be found by examining the Kind.</description>
      <lm-equiv name="ExitNode"></lm-equiv>
      <native-equiv name=""></native-equiv>
      <spec-section>10.11</spec-section>
      <grammar>ExitStatement</grammar>

      <node-kind name="ExitDoStatement">
        <lm-equiv name="Exit" />
        <native-equiv name="Statement.Opcodes.ExitDo" />
      </node-kind>
      <node-kind name="ExitForStatement">
        <lm-equiv name="Exit" />
        <native-equiv name="Statement.Opcodes.ExitFor" />
      </node-kind>
      <node-kind name="ExitSubStatement">
        <lm-equiv name="Exit" />
        <native-equiv name="Statement.Opcodes.ExitSub" />
      </node-kind>
      <node-kind name="ExitFunctionStatement">
        <lm-equiv name="Exit" />
        <native-equiv name="Statement.Opcodes.ExitFunction" />
      </node-kind>
      <node-kind name="ExitOperatorStatement">
        <lm-equiv name="Exit" />
        <native-equiv name="Statement.Opcodes.ExitOperator" />
      </node-kind>
      <node-kind name="ExitPropertyStatement">
        <lm-equiv name="Exit" />
        <native-equiv name="Statement.Opcodes.ExitProperty" />
      </node-kind>
      <node-kind name="ExitTryStatement">
        <lm-equiv name="Exit" />
        <native-equiv name="Statement.Opcodes.ExitTry" />
      </node-kind>
      <node-kind name="ExitSelectStatement">
        <lm-equiv name="Exit" />
        <native-equiv name="Statement.Opcodes.ExitSelect" />
      </node-kind>
      <node-kind name="ExitWhileStatement">
        <lm-equiv name="Exit" />
        <native-equiv name="Statement.Opcodes.ExitWhile" />
      </node-kind>

      <child name="ExitKeyword" kind="ExitKeyword">
        <description>The "Exit" keyword.</description>
        <lm-equiv name="ExitKeyword"></lm-equiv>
        <native-equiv name=""></native-equiv>
      </child>

      <child name="BlockKeyword" >
        <description>The keyword describing the block to exit.</description>
        <lm-equiv name="Block"></lm-equiv>
        <native-equiv name=""></native-equiv>
        <kind name="DoKeyword" node-kind="ExitDoStatement"/>
        <kind name="ForKeyword" node-kind="ExitForStatement"/>
        <kind name="SubKeyword" node-kind="ExitSubStatement"/>
        <kind name="FunctionKeyword" node-kind="ExitFunctionStatement"/>
        <kind name="OperatorKeyword" node-kind="ExitOperatorStatement"/>
        <kind name="PropertyKeyword" node-kind="ExitPropertyStatement"/>
        <kind name="TryKeyword" node-kind="ExitTryStatement"/>
        <kind name="SelectKeyword" node-kind="ExitSelectStatement"/>
        <kind name="WhileKeyword" node-kind="ExitWhileStatement"/>
      </child>
    </node-structure>

    <!--****************
      -  Continue
      ******************-->
    <node-structure name="ContinueStatementSyntax" parent="ExecutableStatementSyntax">
      <description>Represents a "Continue (block)" statement. THe kind of block referenced can be determined by examining the Kind.</description>
      <lm-equiv name="ContinueNode"></lm-equiv>
      <native-equiv name="Statement"></native-equiv>
      <spec-section>10.11</spec-section>
      <grammar>ContinueStatement</grammar>

      <!-- REVIEW: What kind if just "Continue" is typed? Should there be different kinds? -->
      <node-kind name="ContinueWhileStatement">
        <lm-equiv name="Continue" />
        <native-equiv name="Statement.Opcodes.ContinueWhile" />
      </node-kind>
      <node-kind name="ContinueDoStatement">
        <lm-equiv name="Continue" />
        <native-equiv name="Statement.Opcodes.ContinueDo" />
      </node-kind>
      <node-kind name="ContinueForStatement">
        <lm-equiv name="Continue" />
        <native-equiv name="Statement.Opcodes.ContinueFor" />
      </node-kind>

      <child name="ContinueKeyword" kind="ContinueKeyword">
        <description>The "Continue" keyword.</description>
        <lm-equiv name="ContinueKeyword"></lm-equiv>
        <native-equiv name=""></native-equiv>
      </child>

      <child name="BlockKeyword">
        <description>The "Do", "For" or "While" keyword that identifies the kind of loop being continued.</description>
        <lm-equiv name="Block"></lm-equiv>
        <native-equiv name=""></native-equiv>
        <kind name="DoKeyword" node-kind="ContinueDoStatement"/>
        <kind name="ForKeyword" node-kind="ContinueForStatement"/>
        <kind name="WhileKeyword" node-kind="ContinueWhileStatement"/>
      </child>
    </node-structure>


    <!--****************
      -  Return
      ******************-->
    <node-structure name="ReturnStatementSyntax" parent="ExecutableStatementSyntax">
      <description>Represents a "Return" statement.</description>
      <lm-equiv name="ReturnNode"></lm-equiv>
      <native-equiv name="ExpressionStatement"></native-equiv>
      <spec-section>10.11</spec-section>
      <grammar>ReturnStatement</grammar>

      <node-kind name="ReturnStatement">
        <lm-equiv name="Return" />
        <native-equiv name="Statement.Opcodes.Return" />
      </node-kind>

      <child name="ReturnKeyword" kind="ReturnKeyword">
        <description>The "Return" keyword.</description>
        <lm-equiv name="ReturnKeyword"></lm-equiv>
        <native-equiv name=""></native-equiv>
      </child>

      <child name="Expression" optional="true" kind="@ExpressionSyntax">
        <description>The expression being returned, if present.</description>
        <lm-equiv name="Value"></lm-equiv>
        <native-equiv name="Operand"></native-equiv>
      </child>
    </node-structure>

    <!--****************
      -  SingleLineIfStatement
      ******************-->
    <node-structure name="SingleLineIfStatementSyntax" parent="ExecutableStatementSyntax">
      <description>
        Represents a single-line "If ... Then ... Else ..." statement.
      </description>
      <spec-section>10.8.1</spec-section>
      <grammar>IfStatement</grammar>

      <node-kind name="SingleLineIfStatement" />

      <child name="IfKeyword" kind="IfKeyword">
        <description>The "If" keyword.</description>
        <lm-equiv name="IfKeyword" />
        <native-equiv name="" />
      </child>

      <child name="Condition" kind="@ExpressionSyntax">
        <description>The condition expression to be evaluated.</description>
        <lm-equiv name="Condition" />
        <native-equiv name="Operand" />
      </child>

      <child name="ThenKeyword" kind="ThenKeyword">
        <description>The "Then" keyword.</description>
        <lm-equiv name="ThenKeyword" />
        <native-equiv name="Then" />
      </child>

      <child name="Statements" optional="true" list="true" kind="@StatementSyntax">
        <description>A list of statements to be executed if the condition expression evaluates as true. Multiple statements must be separated by colons.</description>
        <lm-equiv name="BlockNode.Contents" />
        <native-equiv name="BlockStatement.Children" />
      </child>

      <child name="ElseClause" optional="true" kind="SingleLineElseClause">
        <description>An "Else" clause to be executed if the condition expression evaluates as false.</description>
      </child>

    </node-structure>

    <!--****************
      -  SingleLineElseClause
      ******************-->
    <node-structure name="SingleLineElseClauseSyntax" parent="VisualBasicSyntaxNode">
      <description>
        Represents the "Else ..." clause of a single-line "If" statement.
      </description>
      <lm-equiv name="ElseNode">A SingleLineElseClause exactly corresponds to an ElseNode -- the Else statement and its following body.</lm-equiv>
      <native-equiv name="ElseStatement">A SingleLineElseClause exactly corresponds to an ElseStatement -- the Else statement and its following body.</native-equiv>
      <spec-section>10.8.1</spec-section>
      <grammar>ElseStatement</grammar>

      <node-kind name="SingleLineElseClause">
        <lm-equiv name="Else" />
        <native-equiv name="Statement.Opcodes.LineElse" />
      </node-kind>

      <child name="ElseKeyword" kind="ElseKeyword">
        <description>The "Else" keyword.</description>
        <lm-equiv name="ElseKeyword" />
        <native-equiv name="Else" />
      </child>

      <child name="Statements" optional="true" list="true" kind="@StatementSyntax">
        <description>A list of statements to be executed. Multiple statements must be separated by colons.</description>
        <lm-equiv name="BlockNode.Contents"></lm-equiv>
        <native-equiv name="BlockStatement.Children"></native-equiv>
      </child>

    </node-structure>

    <!--****************
      -  MultiLineIfBlock
      ******************-->
    <node-structure name="MultiLineIfBlockSyntax" parent="ExecutableStatementSyntax">
      <description>
        Represents a multi-line "If ... Then ... ElseIf ... Then ... Else ... End If" block.
      </description>
      <lm-equiv name="IfNode">A MultiLineIfBlock corresponds to an IfNode -- the If statement and its following body.</lm-equiv>
      <native-equiv name="IfStatement">A MultiLineIfBlock corresponds to an IfStatement -- the If statement and its following body.</native-equiv>
      <spec-section>10.8.1</spec-section>
      <grammar>IfStatement</grammar>

      <node-kind name="MultiLineIfBlock" />

      <child name="IfStatement" kind="IfStatement">
        <description>The "If" statement that begins the "If" block.</description>
      </child>

      <child name="Statements" optional="true" list="true" kind="@StatementSyntax">
        <description>A list of statements to be executed if the condition expression evaluates as true.</description>
        <lm-equiv name="BlockNode.Contents"></lm-equiv>
        <native-equiv name="BlockStatement.Children"></native-equiv>
      </child>

      <child name="ElseIfBlocks" optional="true" list="true" kind="ElseIfBlock">
        <description>A list of "ElseIf" blocks to be evaluated, in order, if the condition expression of the "If" statement evaluates as false.</description>
      </child>

      <child name="ElseBlock" optional="true" kind="ElseBlock">
        <description>An "Else" block to be executed if the condition expression of the "If" statement and all "ElseIf" blocks evaluate as false.</description>
      </child>

      <child name="EndIfStatement" kind="EndIfStatement">
        <description>Then "End If" statement.</description>
      </child>
    </node-structure>

    <!--****************
      -  IfStatement
      ******************-->
    <node-structure name="IfStatementSyntax" parent="StatementSyntax">
      <description>
        Represents the "If ... Then" statement that begins a multi-line "If" block.
      </description>
      <lm-equiv name="IfNode">An IfStatement represents just the header statement, not the body of the If.</lm-equiv>
      <native-equiv name="IfStatement">An IfStatement represents just the header statement, not the body of the If.</native-equiv>
      <spec-section>10.8.1</spec-section>
      <grammar>IfStatement</grammar>

      <node-kind name="IfStatement">
        <lm-equiv name="If" />
        <native-equiv name="Statement.Opcodes.BlockIf" />
        <native-equiv name="Statement.Opcodes.LineIf" />
      </node-kind>

      <child name="IfKeyword" kind="IfKeyword">
        <description>The "If" keyword.</description>
        <lm-equiv name="IfKeyword"></lm-equiv>
        <native-equiv name=""></native-equiv>
      </child>

      <child name="Condition" kind="@ExpressionSyntax">
        <description>The condition expression to be evaluated.</description>
        <lm-equiv name="Condition"></lm-equiv>
        <native-equiv name="Operand"></native-equiv>
      </child>

      <child name="ThenKeyword" optional="true" kind="ThenKeyword">
        <description>The "Then" keyword.</description>
        <lm-equiv name="ThenKeyword"></lm-equiv>
        <native-equiv name="Then"></native-equiv>
      </child>
    </node-structure>

    <!--****************
      -  ElseIfBlock
      ******************-->
    <node-structure name="ElseIfBlockSyntax" parent="VisualBasicSyntaxNode">
      <description>
        Represents an "ElseIf ... Then ..." block.
      </description>
      <lm-equiv name="ElseIfNode">ElseIfBlock exactly corresponds to an ElseIfNode -- the ElseIf statement and its following body.</lm-equiv>
      <native-equiv name="ElseIfStatement">ElseIfBlock exactly corresponds to an ElseIfStatement -- the ElseIf statement and its following body.</native-equiv>
      <spec-section>10.8.1</spec-section>
      <grammar>ElseIfStatement</grammar>

      <node-kind name="ElseIfBlock">
        <lm-equiv name="ElseIf" />
        <native-equiv name="Statement.Opcodes.ElseIf" />
      </node-kind>

      <child name="ElseIfStatement" kind="ElseIfStatement">
        <description>The "ElseIf ... Then" statement the begins the "ElseIf" block.</description>
      </child>

      <child name="Statements" optional="true" list="true" kind="@StatementSyntax">
        <description>A list of statements to be executed if the condition expression of the "ElseIf" statement evaluates as true.</description>
        <lm-equiv name="BlockNode.Contents"></lm-equiv>
        <native-equiv name="BlockStatement.Children"></native-equiv>
      </child>
    </node-structure>

    <!--****************
      -  ElseIfStatement
      ******************-->
    <node-structure name="ElseIfStatementSyntax" parent="StatementSyntax">
      <description>
        Represents the "ElseIf ... Then" statement that begins an "ElseIf" block.
      </description>
      <lm-equiv name="ElseIfNode">An IfStatement represents just the header statement, not the body of the ElseIf.</lm-equiv>
      <native-equiv name="ElseIfStatement">An IfStatement represents just the header statement, not the body of the ElseIf.</native-equiv>
      <spec-section>10.8.1</spec-section>
      <grammar>ElseIfStatement</grammar>

      <node-kind name="ElseIfStatement" />

      <child name="ElseIfKeyword" kind="ElseIfKeyword">
        <description>The "ElseIf" keyword.</description>
      </child>

      <child name="Condition" kind="@ExpressionSyntax">
        <description>The condition expression to be evaluated.</description>
        <lm-equiv name="Condition"></lm-equiv>
        <native-equiv name="Operand"></native-equiv>
      </child>

      <child name="ThenKeyword" optional="true" kind="ThenKeyword">
        <description>The "Then" keyword.</description>
        <lm-equiv name="ThenKeyword"></lm-equiv>
        <native-equiv name="Then"></native-equiv>
      </child>
    </node-structure>

    <!--****************
      -  ElseBlock
      ******************-->
    <node-structure name="ElseBlockSyntax" parent="VisualBasicSyntaxNode">
      <description>
        Represents an "Else ..." block.
      </description>
      <lm-equiv name="ElseNode">An ElseBlock exactly corresponds to an ElseNode -- the Else statement and its following body.</lm-equiv>
      <native-equiv name="ElseStatement">An ElseBlock exactly corresponds to an ElseStatement -- the Else statement and its following body.</native-equiv>
      <spec-section>10.8.1</spec-section>
      <grammar>ElseStatement</grammar>

      <node-kind name="ElseBlock">
        <lm-equiv name="Else" />
        <native-equiv name="Statement.Opcodes.BlockElse" />
      </node-kind>

      <child name="ElseStatement" kind="ElseStatement">
        <description>The "Else" statement that begins the "Else" block.</description>
      </child>

      <child name="Statements" optional="true" list="true" kind="@StatementSyntax">
        <description>A list of statements to be executed.</description>
        <lm-equiv name="BlockNode.Contents"></lm-equiv>
        <native-equiv name="BlockStatement.Children"></native-equiv>
      </child>
    </node-structure>

    <!--****************
      -  Else
      ******************-->
    <node-structure name="ElseStatementSyntax" parent="StatementSyntax">
      <description>
        Represents the "Else" statement that begins an "Else" block.
      </description>
      <lm-equiv name="ElseNode">An ElseStatement represents just the header statement, not the body of the Else.</lm-equiv>
      <native-equiv name="ElseStatement">An ElseStatement represents just the header statement, not the body of the Else.</native-equiv>
      <spec-section>10.8.1</spec-section>
      <grammar>ElseStatement</grammar>

      <node-kind name="ElseStatement">
        <lm-equiv name="Else" />
        <native-equiv name="Statement.Opcodes.BlockElse" />
        <native-equiv name="Statement.Opcodes.LineElse" />
      </node-kind>

      <child name="ElseKeyword" kind="ElseKeyword">
        <description>The "Else" keyword.</description>
        <lm-equiv name="ElseKeyword"></lm-equiv>
        <native-equiv name=""></native-equiv>
      </child>
    </node-structure>

    <!--****************
      -  TryBlock
      ******************-->
    <node-structure name="TryBlockSyntax" parent="ExecutableStatementSyntax">
      <description>
        Represents a "Try ... Catch ... Finally ... End Try" block.
      </description>
      <lm-equiv name="TryNode">A TryBlock corresponds to an TryNode -- the Try statement and its following body.</lm-equiv>
      <native-equiv name="ExecutableBlockStatement">A TryBlock corresponds to a Try statement and its following body.</native-equiv>
      <spec-section>10.10.1</spec-section>
      <grammar>TryStatement</grammar>

      <node-kind name="TryBlock" />

      <child name="TryStatement" kind="TryStatement">
        <description>The "Try" statement that begins the "Try" block. </description>
      </child>

      <child name="Statements" optional="true" list="true" kind="@StatementSyntax">
        <description>A list of statements to be executed.</description>
        <lm-equiv name="BlockNode.Contents"></lm-equiv>
        <native-equiv name="BlockStatement.Children"></native-equiv>
      </child>

      <child name="CatchBlocks" optional="true" list="true" kind="CatchBlock">
        <description>A list of "Catch" blocks which may be executed if an exception is thrown while executing the statements in the "Try" block.</description>
      </child>

      <child name="FinallyBlock" optional="true" kind="FinallyBlock">
        <description>A "Finally" block to be executed before execution leaves the "Try" block.</description>
      </child>

      <child name="EndTryStatement" kind="EndTryStatement">
        <description>The "End Try" statement.</description>
      </child>
    </node-structure>

    <!--****************
      -  TryStatement
      ******************-->
    <node-structure name="TryStatementSyntax" parent="StatementSyntax">
      <description>
        Represents the "Try" statement that begins a "Try" block.
      </description>
      <lm-equiv name="TryNode"></lm-equiv>
      <native-equiv name="ExecutableBlockStatement"></native-equiv>
      <spec-section>10.10.1</spec-section>
      <grammar>TryStatement</grammar>

      <node-kind name="TryStatement">
        <lm-equiv name="Try" />
        <native-equiv name="Statement.Opcodes.Try" />
      </node-kind>

      <child name="TryKeyword" kind="TryKeyword">
        <description>The "Try" keyword.</description>
        <lm-equiv name="TryKeyword"></lm-equiv>
        <native-equiv name=""></native-equiv>
      </child>
    </node-structure>

    <!--****************
      -  CatchBlock
      ******************-->
    <node-structure name="CatchBlockSyntax" parent="VisualBasicSyntaxNode">
      <description>
        Represents a "Catch ..." block.
      </description>
      <lm-equiv name="CatchNode">A CatchBlock exactly corresponds to an CatchNode -- the Catch statement and its following body.</lm-equiv>
      <native-equiv name="CatchStatement">A CatchBlock exactly corresponds to an ElseIfStatement -- the ElseIf statement and its following body.</native-equiv>
      <spec-section>10.10.1</spec-section>
      <grammar>TryStatement&gt;</grammar>

      <node-kind name="CatchBlock">
        <lm-equiv name="Catch" />
        <native-equiv name="Statement.Opcodes.Catch" />
      </node-kind>

      <child name="CatchStatement" kind="CatchStatement">
        <description>
          The "Catch" statement that begins the "Catch" block.
        </description>
      </child>

      <child name="Statements" optional="true" list="true" kind="@StatementSyntax">
        <description>A list of statements to be executed if an exception is caught by the "Catch" block.</description>
        <lm-equiv name="BlockNode.Contents"></lm-equiv>
        <native-equiv name="BlockStatement.Children"></native-equiv>
      </child>

    </node-structure>

    <!--****************
      -  CatchStatement
      ******************-->
    <node-structure name="CatchStatementSyntax" parent="StatementSyntax">
      <description>
        Represents the "Catch ... When ..." statement that begins a "Catch" block.
      </description>
      <lm-equiv name="CatchNode"></lm-equiv>
      <native-equiv name="CatchStatement"></native-equiv>
      <spec-section>10.10.1</spec-section>
      <grammar>CatchStatement</grammar>

      <node-kind name="CatchStatement">
        <lm-equiv name="Catch" />
        <native-equiv name="Statement.Opcodes.Catch" />
      </node-kind>

      <child name="CatchKeyword" kind="CatchKeyword">
        <description>The "Catch" keyword.</description>
        <lm-equiv name="CatchKeyword"></lm-equiv>
        <native-equiv name=""></native-equiv>
      </child>

      <child name="IdentifierName" optional="true" kind="IdentifierName">
        <description>An identifier declaring a new variable or naming an existing variable to store the exception caught by the "Catch" statement.</description>
        <lm-equiv name="Name"></lm-equiv>
        <native-equiv name="Name"></native-equiv>
      </child>

      <child name="AsClause" optional="true" kind="SimpleAsClause">
        <description>A simple "As" clause specifying the type of exception to catch.</description>
        <lm-equiv name="AsKeyword"></lm-equiv>
        <lm-equiv name="ExceptionType"></lm-equiv>
        <native-equiv name="Type"></native-equiv>
      </child>

      <child name="WhenClause" optional="true" kind="CatchFilterClause">
        <description>A "When" clause to filter exceptions before catching.</description>
      </child>

    </node-structure>

    <!--*********************
      -  CatchFilterClauseSyntax
      ***********************-->
    <node-structure name="CatchFilterClauseSyntax" parent="VisualBasicSyntaxNode">
      <description>
        Represents the "When ..." clause of a "Catch" statement.
      </description>

      <node-kind name="CatchFilterClause" />

      <child name="WhenKeyword" kind="WhenKeyword">
        <description>The "When" keyword.</description>
        <lm-equiv name="WhenKeyword"></lm-equiv>
        <native-equiv name="When"></native-equiv>
      </child>

      <child name="Filter" kind="@ExpressionSyntax">
        <description>The filter expression to be evaluated.</description>
        <lm-equiv name="Filter"></lm-equiv>
        <native-equiv name="WhenClause"></native-equiv>
      </child>
    </node-structure>

    <!--****************
      -  FinallyBlock
      ******************-->
    <node-structure name="FinallyBlockSyntax" parent="VisualBasicSyntaxNode">
      <description>
        Represents a "Finally ..." block of a "Try" block.
      </description>
      <lm-equiv name="FinallyNode">A FinallyBlock exactly corresponds to an FinallyNode -- the Finally statement and its following body.</lm-equiv>
      <native-equiv name="FinallyStatement">A FinallyBlock exactly corresponds to an FinallyStatement -- the Finally statement and its following body.</native-equiv>
      <spec-section>10.10.1</spec-section>
      <grammar>TryStatement&gt;</grammar>

      <node-kind name="FinallyBlock">
        <lm-equiv name="Finally" />
        <native-equiv name="Statement.Opcodes.Finally" />
      </node-kind>

      <child name="FinallyStatement" kind="FinallyStatement">
        <description>
          The "Finally" statement that begins the "Finally" block.
        </description>
      </child>

      <child name="Statements" optional="true" list="true" kind="@StatementSyntax">
        <description>A list of statements to be executed.</description>
        <lm-equiv name="BlockNode.Contents"></lm-equiv>
        <native-equiv name="BlockStatement.Children"></native-equiv>
      </child>
    </node-structure>

    <!--****************
      -  FinallyStatement
      ******************-->
    <node-structure name="FinallyStatementSyntax" parent="StatementSyntax">
      <description>
        Represents the "Finally" statement that begins a "Finally" block.
      </description>
      <lm-equiv name="FinallyNode"></lm-equiv>
      <native-equiv name="FinallyStatement"></native-equiv>
      <spec-section>10.10.1</spec-section>
      <grammar>FinallyStatement</grammar>

      <node-kind name="FinallyStatement">
        <lm-equiv name="Finally" />
        <native-equiv name="Statement.Opcodes.Finally" />
      </node-kind>

      <child name="FinallyKeyword" kind="FinallyKeyword">
        <description>The "Finally" keyword.</description>
        <lm-equiv name="FinallyKeyword"></lm-equiv>
        <native-equiv name=""></native-equiv>
      </child>
    </node-structure>

    <!--****************
      -  Error
      ******************-->
    <node-structure name="ErrorStatementSyntax" parent="ExecutableStatementSyntax">
      <description>Represents the "Error" statement.</description>
      <lm-equiv name="ErrorNode"></lm-equiv>
      <native-equiv name="ExpressionStatement"></native-equiv>
      <spec-section>10.10.2.1</spec-section>
      <grammar>ErrorStatement</grammar>

      <node-kind name="ErrorStatement">
        <lm-equiv name="Error" />
        <native-equiv name="Statement.Opcodes.Error" />
      </node-kind>

      <child name="ErrorKeyword" kind="ErrorKeyword">
        <description>The "Error" keyword.</description>
        <lm-equiv name="ErrorKeyword"></lm-equiv>
        <native-equiv name=""></native-equiv>
      </child>

      <child name="ErrorNumber" kind="@ExpressionSyntax">
        <description>The expression that represents the error number.</description>
        <lm-equiv name="Value"></lm-equiv>
        <native-equiv name="Operand"></native-equiv>
      </child>
    </node-structure>

    <!--****************
      -  OnErrorGoto
      ******************-->
    <node-structure name="OnErrorGoToStatementSyntax" parent="ExecutableStatementSyntax">
      <description>Represents an OnError Goto statement.</description>
      <lm-equiv name="OnErrorNode"></lm-equiv>
      <native-equiv name="OnErrorStatement"></native-equiv>
      <spec-section>10.10.2.2</spec-section>
      <grammar>OnErrorStatement</grammar>

      <node-kind name="OnErrorGoToZeroStatement">
      </node-kind>

      <node-kind name="OnErrorGoToMinusOneStatement">
      </node-kind>

      <node-kind name="OnErrorGoToLabelStatement">
      </node-kind>

      <child name="OnKeyword" kind="OnKeyword">
        <description>The "On" keyword</description>
        <lm-equiv name="OnKeyword"></lm-equiv>
        <native-equiv name=""></native-equiv>
      </child>

      <child name="ErrorKeyword" kind="ErrorKeyword">
        <description>The "Error" keyword.</description>
        <lm-equiv name="ErrorKeyword"></lm-equiv>
        <native-equiv name="Error"></native-equiv>
      </child>

      <child name="GoToKeyword" kind="GoToKeyword">
        <description>The "GoTo" keyword</description>
        <lm-equiv name="GoToKeyword"></lm-equiv>
        <native-equiv name="OnErrorStatement.GoToOrResume"></native-equiv>
      </child>

      <child name="Minus" optional="true" kind="MinusToken">
        <description>An optional minus for On Error Goto -1</description>
        <lm-equiv name="OnKeyword"></lm-equiv>
        <native-equiv name=""></native-equiv>
      </child>

      <child name="Label" kind="@LabelSyntax">
        <description>
          The name of the label. If the label is a line number, 0 or -1, wraps an IntegerLiteralToken that is the line number,
          otherwise, wraps an Identifier.
        </description>
        <lm-equiv name="Label"></lm-equiv>
        <native-equiv name="LabelReferenceStatement.Label"></native-equiv>
      </child>
    </node-structure>

    <!--****************
      -  OnErrorGoto
      ******************-->
    <node-structure name="OnErrorResumeNextStatementSyntax" parent="ExecutableStatementSyntax">
      <description>Represents an OnError Resume Next statement.</description>
      <lm-equiv name="OnErrorNode"></lm-equiv>
      <native-equiv name="OnErrorStatement"></native-equiv>
      <spec-section>10.10.2.2</spec-section>
      <grammar>OnErrorStatement</grammar>

      <node-kind name="OnErrorResumeNextStatement">
      </node-kind>

      <child name="OnKeyword" kind="OnKeyword">
        <description>The "On" keyword</description>
        <lm-equiv name="OnKeyword"></lm-equiv>
        <native-equiv name=""></native-equiv>
      </child>

      <child name="ErrorKeyword" kind="ErrorKeyword">
        <description>The "Error" keyword.</description>
        <lm-equiv name="ErrorKeyword"></lm-equiv>
        <native-equiv name="Error"></native-equiv>
      </child>

      <child name="ResumeKeyword" kind="ResumeKeyword">
        <description>The "Resume" keyword.</description>
        <lm-equiv name="ResumeKeyword"></lm-equiv>
        <native-equiv name="OnErrorStatement.GoToOrResume"></native-equiv>
      </child>

      <child name="NextKeyword" kind="NextKeyword">
        <description>The "Next"</description>
        <lm-equiv name="NextKeyword"></lm-equiv>
        <native-equiv name=""></native-equiv>
      </child>

    </node-structure>


    <!--****************
      -  Resume
      ******************-->
    <node-structure name="ResumeStatementSyntax" parent="ExecutableStatementSyntax">
      <description>
        Represents a "Resume" statement. The Kind property can be used to determine if this is a
        "Resume", "Resume Next" or "Resume label" statement.
      </description>
      <lm-equiv name="ResumeNode"></lm-equiv>
      <native-equiv name="ResumeStatement"></native-equiv>
      <spec-section>10.10.2.3</spec-section>
      <grammar>ResumeStatement</grammar>

      <node-kind name="ResumeStatement">
        <lm-equiv name="Resume" />
        <native-equiv name="Statement.Opcodes.Resume" />
        <native-equiv name="ResumeStatement.ResumeTypes.None" />
      </node-kind>
      <node-kind name="ResumeLabelStatement">
        <lm-equiv name="Resume" />
        <native-equiv name="Statement.Opcodes.Resume" />
        <native-equiv name="ResumeStatement.ResumeTypes.ResumeLabel" />
      </node-kind>
      <node-kind name="ResumeNextStatement">
        <lm-equiv name="Resume" />
        <native-equiv name="Statement.Opcodes.Resume" />
        <native-equiv name="ResumeStatement.ResumeTypes.Next" />
      </node-kind>

      <child name="ResumeKeyword" kind="ResumeKeyword">
        <description>The "Resume" keyword.</description>
        <lm-equiv name="ResumeKeyword"></lm-equiv>
        <native-equiv name=""></native-equiv>
      </child>

      <child name="Label" optional="true" kind="@LabelSyntax">
        <description>
          The label. The value of this depends on the Kind.
          If Kind=Resume, returns Nothing. If Kind=ResumeNext, wraps the keyword "Next", If Kind=ResumeLabel, wraps an Identifier or
          IntegerLiteralToken with the label or line number.
        </description>
        <lm-equiv name="Label"></lm-equiv>
        <native-equiv name="LabelReferenceStatement.Label"></native-equiv>
      </child>
    </node-structure>

    <!--****************
      -  SelectBlock
      ******************-->
    <node-structure name="SelectBlockSyntax" parent="ExecutableStatementSyntax">
      <description>
        Represents a Select Case block, including the Select Case that begins it, the
        contains Case blocks and the End Select.
      </description>

      <lm-equiv name="BlockNode"></lm-equiv>
      <native-equiv name="BlockStatement"></native-equiv>
      <native-equiv name="HiddenBlockStatement">TODO: Describe how these map!</native-equiv>

      <node-kind name="SelectBlock">
        <lm-equiv name="SelectCase" />
        <native-equiv name="Statement.Opcodes.Select" />
      </node-kind>

      <child name="SelectStatement" kind="SelectStatement">
        <description>The Select Case statement that begins the block. </description>
        <lm-equiv name=""></lm-equiv>
        <native-equiv name=""></native-equiv>
      </child>

      <child name="CaseBlocks" optional="true" list="true" kind="@CaseBlockSyntax">
        <description>A list of the contained Case blocks. </description>
        <lm-equiv name="BlockNode.Contents"></lm-equiv>
        <native-equiv name="BlockStatement.Children"></native-equiv>
      </child>

      <child name="EndSelectStatement" kind="EndSelectStatement">
        <description>
          The End Select statement that ends the block.
        </description>
        <lm-equiv name="EndBlock"></lm-equiv>
        <native-equiv name="TerminatingConstruct"></native-equiv>
      </child>
    </node-structure>

    <!--****************
      -  SelectStatement
      ******************-->
    <node-structure name="SelectStatementSyntax" parent="StatementSyntax">
      <description>
        Represents a Select Case statement. This statement always occurs as the Begin
        of a SelectBlock.
      </description>
      <lm-equiv name="SelectCaseNode"></lm-equiv>
      <native-equiv name="SelectStatement"></native-equiv>
      <spec-section>10.8.2</spec-section>
      <grammar>SelectStatement</grammar>

      <node-kind name="SelectStatement">
        <lm-equiv name="SelectCase" />
        <native-equiv name="Statement.Opcodes.Select" />
      </node-kind>

      <child name="SelectKeyword" kind="SelectKeyword">
        <description>The "Select" keyword.</description>
        <lm-equiv name="SelectKeyword"></lm-equiv>
        <native-equiv name=""></native-equiv>
      </child>

      <child name="CaseKeyword" optional="true" kind="CaseKeyword">
        <description>The "Case" keyword, if present.</description>
        <lm-equiv name="CaseKeyword"></lm-equiv>
        <native-equiv name="Case"></native-equiv>
      </child>

      <child name="Expression" kind="@ExpressionSyntax">
        <description>The value that branching is based on.</description>
        <lm-equiv name="Value"></lm-equiv>
        <native-equiv name="Operand"></native-equiv>
      </child>
    </node-structure>

    <!--****************
      -  CaseBlock
      ******************-->
    <node-structure name="CaseBlockSyntax" parent="VisualBasicSyntaxNode">
      <description>Represents a case statement and its subsequent block.</description>
      <lm-equiv name="CaseBranchNode"></lm-equiv>
      <native-equiv name="CaseStatement"></native-equiv>
      <spec-section>10.8.2</spec-section>
      <grammar>CaseStatement</grammar>
      <grammar>CaseElseStatement</grammar>

      <node-kind name="CaseBlock">
        <lm-equiv name="CaseBranch" />
        <native-equiv name="Statement.Opcodes.Case" />
      </node-kind>

      <node-kind name="CaseElseBlock">
        <lm-equiv name="CaseElseBranch" />
        <native-equiv name="Statement.Opcodes.CaseElse" />
      </node-kind>

      <child name="CaseStatement" kind="CaseStatement|CaseElseStatement">
        <description>The statement that begins the case block. </description>
      </child>

      <child name="Statements" optional="true" list="true" kind="@StatementSyntax">
        <description>The statements contained in the case block. This might be an empty list.</description>
        <lm-equiv name="BlockNode.Contents"></lm-equiv>
        <native-equiv name="BlockStatement.Children"></native-equiv>
      </child>
    </node-structure>

    <!--****************
      -  CaseStatement
      ******************-->
    <node-structure name="CaseStatementSyntax" parent="StatementSyntax">
      <description>
        Represents a Case or Case Else statement. This statement is always the Begin of a CaseBlock. If this is a Case Else
        statement, the Kind=CaseElse, otherwise the Kind=Case.
      </description>
      <lm-equiv name="CaseBranchNode"></lm-equiv>
      <native-equiv name="CaseStatement"></native-equiv>
      <spec-section>10.8.2</spec-section>
      <grammar>CaseStatement</grammar>
      <grammar>CaseElseStatement</grammar>

      <node-kind name="CaseStatement">
        <lm-equiv name="CaseBranch" />
        <native-equiv name="Statement.Opcodes.Case" />
      </node-kind>

      <node-kind name="CaseElseStatement">
        <lm-equiv name="CaseElseBranch" />
        <native-equiv name="Statement.Opcodes.CaseElse" />
      </node-kind>

      <child name="CaseKeyword" kind="CaseKeyword">
        <description>The "Case" keyword</description>
        <lm-equiv name="CaseKeyword"></lm-equiv>
        <native-equiv name=""></native-equiv>
      </child>

      <child name="Cases" list="true" separator-kind="CommaToken" separator-name="CommaTokens" kind="@CaseClauseSyntax" min-count="1">
        <description>
          A list of clauses associated with this Case. If Kind=CaseElse, then this list has exactly one child,
          which is a ElseCaseClause.
        </description>
        <lm-equiv name="Cases"></lm-equiv>
        <native-equiv name="Cases"></native-equiv>
      </child>
    </node-structure>

    <!--****************
      -  CaseClause
      ******************-->
    <node-structure name="CaseClauseSyntax" abstract="true" parent="VisualBasicSyntaxNode">
      <description>Represents a single clause in a case statement. An abstract node that is the parent of different kinds of Case clauses.</description>
      <spec-section>10.8.2</spec-section>
      <grammar>CaseClause</grammar>
    </node-structure>

    <!--****************
      -  ElseCaseClause
      ******************-->
    <node-structure name="ElseCaseClauseSyntax" parent="CaseClauseSyntax">
      <description>The "Else" part in a Case Else statement.</description>
      <lm-equiv name="CaseElseBranchNode"></lm-equiv>
      <native-equiv name="ExecutableBlockStatement"></native-equiv>
      <spec-section>10.8.2</spec-section>
      <grammar>CaseElseStatement</grammar>

      <node-kind name="ElseCaseClause" />

      <child name="ElseKeyword" kind="ElseKeyword">
        <description>The "Else" keyword.</description>
        <lm-equiv name="CaseElseBranchNode.ElseKeyword"></lm-equiv>
        <native-equiv name=""></native-equiv>
      </child>
    </node-structure>

    <!--****************
      -  SimpleCaseClause
      ******************-->
    <node-structure name="SimpleCaseClauseSyntax" parent="CaseClauseSyntax">
      <description>Represents a single value in a Case.</description>
      <lm-equiv name="RangeNode"></lm-equiv>
      <native-equiv name="ValueCase"></native-equiv>
      <spec-section>10.8.2</spec-section>
      <grammar>CaseClause</grammar>

      <node-kind name="SimpleCaseClause">
        <lm-equiv name="Range" />
        <native-equiv name="Case.Opcodes.ValueCase" />
      </node-kind>

      <child name="Value" kind="@ExpressionSyntax">
        <description>The expression that denotes the value being tested against.</description>
        <native-equiv name="Value"></native-equiv>
      </child>
    </node-structure>

    <!--****************
      -  RangeCaseClause
      ******************-->
    <node-structure name="RangeCaseClauseSyntax" parent="CaseClauseSyntax">
      <description>Represents a range "expression To expression" in a Case.</description>
      <lm-equiv name="RangeNode"></lm-equiv>
      <native-equiv name="RangeCase"></native-equiv>
      <spec-section>10.8.2</spec-section>
      <grammar>CaseClause</grammar>

      <node-kind name="RangeCaseClause">
        <lm-equiv name="Range" />
        <native-equiv name="Case.Opcodes.RangeCase" />
      </node-kind>

      <child name="LowerBound" kind="@ExpressionSyntax">
        <description>The lower bound of the range.</description>
        <lm-equiv name="LowerBound"></lm-equiv>
        <native-equiv name="Low"></native-equiv>
      </child>

      <child name="ToKeyword" kind="ToKeyword">
        <description>The "To" keyword</description>
        <lm-equiv name="ToKeyword"></lm-equiv>
        <native-equiv name="High"></native-equiv>
      </child>

      <child name="UpperBound" kind="@ExpressionSyntax">
        <description>The upper bound of the range.</description>
        <lm-equiv name="UpperBound"></lm-equiv>
        <native-equiv name="High"></native-equiv>
      </child>
    </node-structure>

    <!--****************
      -  RelationalCaseClause
      ******************-->
    <node-structure name="RelationalCaseClauseSyntax" parent="CaseClauseSyntax">
      <description>Represents a relation clause in a Case statement, such as "Is &gt; expression".</description>
      <lm-equiv name="RelationalCaseNode"></lm-equiv>
      <native-equiv name="RelationalCase"></native-equiv>
      <spec-section>10.8.2</spec-section>
      <grammar>CaseClause</grammar>

      <node-kind name="CaseEqualsClause">
      </node-kind>

      <node-kind name="CaseNotEqualsClause">
      </node-kind>

      <node-kind name="CaseLessThanClause">
      </node-kind>

      <node-kind name="CaseLessThanOrEqualClause">
      </node-kind>

      <node-kind name="CaseGreaterThanOrEqualClause">
      </node-kind>

      <node-kind name="CaseGreaterThanClause">
      </node-kind>

      <child name="IsKeyword" optional="true" kind="IsKeyword">
        <description>The "Is" keyword, if present.</description>
        <lm-equiv name="IsKeyword"></lm-equiv>
        <native-equiv name="Is"></native-equiv>
      </child>

      <child name="OperatorToken">
        <description>The operator in the relational clause. One of "=", "&lt;", "&gt;", "&lt;=" or "&gt;=".</description>
        <lm-equiv name="Operator"></lm-equiv>
        <native-equiv name="RelationalOpcode"></native-equiv>
        <native-equiv name="Operator"></native-equiv>
        <kind name="EqualsToken" node-kind="CaseEqualsClause"/>
        <kind name="LessThanGreaterThanToken" node-kind="CaseNotEqualsClause"/>
        <kind name="LessThanToken" node-kind="CaseLessThanClause"/>
        <kind name="GreaterThanToken" node-kind="CaseGreaterThanClause"/>
        <kind name="LessThanEqualsToken" node-kind="CaseLessThanOrEqualClause"/>
        <kind name="GreaterThanEqualsToken" node-kind="CaseGreaterThanOrEqualClause"/>
      </child>

      <child name="Value" kind="@ExpressionSyntax">
        <description>The expression that denotes the value being tested against.</description>
        <lm-equiv name="Value"></lm-equiv>
        <native-equiv name="Value"></native-equiv>
      </child>
    </node-structure>


    <!--****************
      -  SyncLockStatement
      ******************-->
    <node-structure name="SyncLockStatementSyntax" parent="StatementSyntax">
      <description>
        Represents the "SyncLock" statement. This statement always occurs as the Begin
        of a SyncLockBlock.
      </description>
      <lm-equiv name="SyncLockNode"></lm-equiv>
      <native-equiv name="ExpressionBlockStatement">
        The SyncLock statement and the contained statements are split into a
        BlockStatement, which contains a SyncLock, Body and End SyncLock statements.
      </native-equiv>

      <node-kind name="SyncLockStatement">
        <lm-equiv name="SyncLock" />
        <native-equiv name="" />
      </node-kind>

      <child name="SyncLockKeyword" kind="SyncLockKeyword">
        <description>The "SyncLock" keyword.</description>
        <lm-equiv name="SyncLockKeyword"></lm-equiv>
        <native-equiv name=""></native-equiv>
      </child>

      <child name="Expression" kind="@ExpressionSyntax">
        <description>The expression being synchronized on.</description>
        <lm-equiv name="Value"></lm-equiv>
        <native-equiv name="Operand"></native-equiv>
      </child>
    </node-structure>

    <!--****************
      -  DoLoopBlock
      ******************-->
    <node-structure name="DoLoopBlockSyntax" parent="ExecutableStatementSyntax">
      <description>
        Represents a Do-Loop block. The Kind property can be used to determine
        if this is a Do While, Do Until, Do Loop While, Do Loop Until, or infinite Do Loop.
      </description>

      <lm-equiv name="BlockNode"></lm-equiv>
      <native-equiv name="BlockStatement"></native-equiv>
      <native-equiv name="HiddenBlockStatement">TODO: Describe how these map!</native-equiv>

      <node-kind name="SimpleDoLoopBlock">
        <lm-equiv name="DoLoop" />
        <native-equiv name="DoForever" />
      </node-kind>

      <node-kind name="DoWhileLoopBlock">
        <lm-equiv name="DoLoop" />
        <native-equiv name="DoWhileTopTest" />
      </node-kind>

      <node-kind name="DoUntilLoopBlock">
        <lm-equiv name="DoLoop" />
        <native-equiv name="DoUnitTopTest" />
      </node-kind>

      <node-kind name="DoLoopWhileBlock">
        <lm-equiv name="DoLoop" />
        <native-equiv name="DoWhileBottomTest" />
      </node-kind>

      <node-kind name="DoLoopUntilBlock">
        <lm-equiv name="DoLoop" />
        <native-equiv name="DoUntilBottomTest" />
      </node-kind>

      <child name="DoStatement">
        <description>The Do statement that begins the block.</description>
        <lm-equiv name="DoLoopNode.Operator" />
        <lm-equiv name="EndLoopNode.Operator" />
        <native-equiv name="TopTestDoStatement.WhileOrUntil" />
        <native-equiv name="BottomTestDoStatement.WhileOrUntil" />
        <kind name="SimpleDoStatement" node-kind="SimpleDoLoopBlock" />
        <kind name="DoWhileStatement" node-kind="DoWhileLoopBlock" />
        <kind name="DoUntilStatement" node-kind="DoUntilLoopBlock" />
        <kind name="SimpleDoStatement" node-kind="DoLoopWhileBlock" />
        <kind name="SimpleDoStatement" node-kind="DoLoopUntilBlock" />
      </child>

      <child name="Statements" optional="true" list="true" kind="@StatementSyntax">
        <description>The statements contained in the block statement. This might be an empty list.</description>
        <lm-equiv name="BlockNode.Contents"></lm-equiv>
        <native-equiv name="BlockStatement.Children"></native-equiv>
      </child>

      <child name="LoopStatement">
        <description>The Loop statement that ends the block.</description>
        <lm-equiv name="EndLoopNode.Operator" />
        <native-equiv name="BottomTestDoStatement.WhileOrUntil" />
        <kind name="SimpleLoopStatement" node-kind="SimpleDoLoopBlock" />
        <kind name="SimpleLoopStatement" node-kind="DoWhileLoopBlock" />
        <kind name="SimpleLoopStatement" node-kind="DoUntilLoopBlock" />
        <kind name="LoopWhileStatement" node-kind="DoLoopWhileBlock" />
        <kind name="LoopUntilStatement" node-kind="DoLoopUntilBlock" />
      </child>
    </node-structure>

    <!--****************
      -  DoStatement
      ******************-->
    <node-structure name="DoStatementSyntax" parent="StatementSyntax">
      <description>
        The Do statement that begins a Do-Loop block.
      </description>

      <node-kind name="SimpleDoStatement" />
      <node-kind name="DoWhileStatement" />
      <node-kind name="DoUntilStatement" />

      <child name="DoKeyword" kind="DoKeyword">
        <description>The "Do" keyword.</description>
      </child>

      <child name="WhileOrUntilClause" optional="true">
        <description>The "While expression" or "Until expression" clause of the Do statement, if present.</description>
        <kind name="WhileClause" node-kind="DoWhileStatement" />
        <kind name="UntilClause" node-kind="DoUntilStatement" />
      </child>
    </node-structure>

    <!--****************
      -  LoopStatement
      ******************-->
    <node-structure name="LoopStatementSyntax" parent="StatementSyntax">
      <description>
        The Loop statement that begins a Do-Loop block.
      </description>

      <node-kind name="SimpleLoopStatement" />
      <node-kind name="LoopWhileStatement" />
      <node-kind name="LoopUntilStatement" />

      <child name="LoopKeyword" kind="LoopKeyword">
        <description>The "Loop" keyword.</description>
      </child>

      <child name="WhileOrUntilClause" optional="true">
        <description>The "While expression" or "Until expression" clause of the Loop statement, if present.</description>
        <kind name="WhileClause" node-kind="LoopWhileStatement" />
        <kind name="UntilClause" node-kind="LoopUntilStatement" />
      </child>
    </node-structure>

    <!--****************
      -  WhileOrUntilClause
      ******************-->
    <node-structure name="WhileOrUntilClauseSyntax" parent="VisualBasicSyntaxNode">
      <description>
        Represents a "While expression" or "Until expression" in a Do or Loop statement. The Kind
        of the clause can be "WhileClause" or "UntilClause" to indicate which kind of clause.
      </description>

      <node-kind name="WhileClause" />
      <node-kind name="UntilClause" />

      <child name="WhileOrUntilKeyword" >
        <description>The "While" or "Until" keyword.</description>
        <lm-equiv name="DoLoopNode.Operator"></lm-equiv>
        <lm-equiv name="EndLoopNode.Operator"></lm-equiv>
        <native-equiv name="TopTestDoStatement.WhileOrUntil"></native-equiv>
        <native-equiv name="BottomTestDoStatement.WhileOrUntil"></native-equiv>
        <kind name="WhileKeyword" node-kind="WhileClause" />
        <kind name="UntilKeyword" node-kind="UntilClause" />
      </child>

      <child name="Condition" kind="@ExpressionSyntax">
        <description>The boolean expression after the While or Until.</description>
        <lm-equiv name="EndLoopNode.Condition"></lm-equiv>
        <native-equiv name="ExpressionStatement.Operand"></native-equiv>
      </child>
    </node-structure>

    <!--****************
      -  WhileStatement
      ******************-->
    <node-structure name="WhileStatementSyntax" parent="StatementSyntax">
      <description>
        The While statement that begins a While...End While block. This statement always occurs as the Begin
        of a WhileBlock.
      </description>
      <lm-equiv name="WhileNode"></lm-equiv>
      <native-equiv name="ExpressionBlockStatement"></native-equiv>

      <node-kind name="WhileStatement">
        <lm-equiv name="While" />
        <native-equiv name="Statements.Opcodes.While" />
      </node-kind>

      <child name="WhileKeyword" kind="WhileKeyword">
        <description>The "While" keyword.</description>
        <lm-equiv name="WhileKeyword"></lm-equiv>
        <native-equiv name=""></native-equiv>
      </child>

      <child name="Condition" kind="@ExpressionSyntax">
        <description>The boolean expression that controls the While loop.</description>
        <lm-equiv name="Condition"></lm-equiv>
        <native-equiv name="Operand"></native-equiv>
      </child>
    </node-structure>

    <!--****************
      -  ForOrForEachBlock
      ******************-->
    <node-structure name="ForOrForEachBlockSyntax" abstract="true" parent="ExecutableStatementSyntax">
      <description>Represents a For or For Each block.</description>

      <child name="Statements" optional="true" list="true" kind="@StatementSyntax" order="20">
        <description>The statements contained in the For or For Each loop. This might be an empty list.</description>
        <lm-equiv name="BlockNode.Contents"></lm-equiv>
        <native-equiv name="BlockStatement.Children"></native-equiv>
      </child>

      <child name="NextStatement" optional="true" kind="NextStatement" order="30">
        <description>
          The Next statement that ends the block. If two For or For Each statements are ended by a single Next statement,
          the inner For will not have a Next statement.
        </description>
        <lm-equiv name="EndBlock"></lm-equiv>
        <native-equiv name="TerminatingConstruct"></native-equiv>
      </child>
    </node-structure>

    <!--****************
      -  ForBlock
      ******************-->
    <node-structure name="ForBlockSyntax" parent="ForOrForEachBlockSyntax">
      <description>
        Represents a For block, including the introducing statement,
        the body and the "Next" (which can be omitted if a containing For has a Next with
        multiple variables).
      </description>

      <lm-equiv name="BlockNode"></lm-equiv>
      <native-equiv name="BlockStatement"></native-equiv>
      <native-equiv name="HiddenBlockStatement">TODO: Describe how these map!</native-equiv>

      <node-kind name="ForBlock">
        <lm-equiv name="For" />
        <native-equiv name="Statements.Opcodes.ForFromTo" />
      </node-kind>

      <child name="ForStatement" kind="ForStatement" order="10">
        <description>The For statement that begins the block. </description>
        <lm-equiv name=""></lm-equiv>
        <native-equiv name=""></native-equiv>
      </child>

    </node-structure>

    <!--****************
      -  ForEachBlock
      ******************-->
    <node-structure name="ForEachBlockSyntax" parent="ForOrForEachBlockSyntax">
      <description>
        Represents a For Each block, including the introducing statement,
        the body and the "Next" (which can be omitted if a containing For has a Next with
        multiple variables).
      </description>

      <lm-equiv name="BlockNode"></lm-equiv>
      <native-equiv name="BlockStatement"></native-equiv>
      <native-equiv name="HiddenBlockStatement">TODO: Describe how these map!</native-equiv>

      <node-kind name="ForEachBlock">
        <lm-equiv name="ForEach" />
        <native-equiv name="Statements.Opcodes.ForEachIn" />
      </node-kind>

      <child name="ForEachStatement" kind="ForEachStatement" order="10">
        <description>The For Each statement that begins the block. </description>
        <lm-equiv name=""></lm-equiv>
        <native-equiv name=""></native-equiv>
      </child>
    </node-structure>

    <!--****************
      -  ForOrForEachStatement
      ******************-->
    <node-structure name="ForOrForEachStatementSyntax" abstract="true" parent="StatementSyntax">
      <description>Represents a For or For Each statement.</description>

      <child name="ForKeyword" kind="ForKeyword" order="10">
        <description>The "For" keyword.</description>
        <lm-equiv name="ForKeyword"></lm-equiv>
        <native-equiv name="ForStatement.ControlVariable"></native-equiv>
      </child>

      <child name="ControlVariable" kind="@ExpressionSyntax|VariableDeclarator" order="30">
        <description>
          If the For or For Each statement is of a form that does not declare a new loop control variable, this is the
          expression that denotes the loop control variable. If this loop is of a form that does declare a new control variable,
          this is a VariableDeclarator that has the variable being declared.
        </description>
        <lm-equiv name="Variable"></lm-equiv>
        <native-equiv name="ForStatement.ControlVariable"></native-equiv>
      </child>
    </node-structure>

    <!--****************
      -  ForStatement
      ******************-->
    <node-structure name="ForStatementSyntax" parent="ForOrForEachStatementSyntax">
      <description>
        The For statement that begins a For-Next block. This statement always occurs as the Begin
        of a ForBlock. Most of the time, the End
        of that ForBlock is the corresponding Next statement. However, multiple nested For statements are ended by
        a single Next statement with multiple variables, then the inner For statements will have End set to Nothing, and the
        Next statement is the End of the outermost For statement that is being ended.
      </description>

      <lm-equiv name="ForNode"></lm-equiv>
      <native-equiv name="ForFromToStatement"></native-equiv>

      <node-kind name="ForStatement">
        <lm-equiv name="For" />
        <native-equiv name="Statement.Opcodes.ForFromTo" />
      </node-kind>

      <child name="EqualsToken" kind="EqualsToken" order="40">
        <description>The "=" token.</description>
        <lm-equiv name="Equal"></lm-equiv>
        <native-equiv name="Equals"></native-equiv>
      </child>

      <child name="FromValue" kind="@ExpressionSyntax" order="50">
        <description>The expression denoting the initial value of the iteration.</description>
        <lm-equiv name="From"></lm-equiv>
        <native-equiv name="InitialValue"></native-equiv>
      </child>

      <child name="ToKeyword" kind="ToKeyword" order="60">
        <description>The "To" keyword.</description>
        <lm-equiv name="ToKeyword"></lm-equiv>
        <native-equiv name="To"></native-equiv>
      </child>

      <child name="ToValue" kind="@ExpressionSyntax" order="70">
        <description>The expression denoting the final value of the iteration.</description>
        <lm-equiv name="To"></lm-equiv>
        <native-equiv name="FinalValue"></native-equiv>
      </child>

      <child name="StepClause" optional="true" kind="ForStepClause" order="80">
        <description>The optional Step clause.</description>
      </child>

    </node-structure>

    <!--******************
      -  ForStepClauseSyntax
      *******************-->
    <node-structure name="ForStepClauseSyntax" parent="VisualBasicSyntaxNode">
      <description>
        The Step clause in a For Statement.
      </description>

      <node-kind name="ForStepClause">
      </node-kind>

      <child name="StepKeyword" kind="StepKeyword">
        <description>The "Step" keyword.</description>
        <lm-equiv name="StepKeyword"></lm-equiv>
        <native-equiv name="Step"></native-equiv>
      </child>

      <child name="StepValue" kind="@ExpressionSyntax">
        <description>The expression denoting the step increment.</description>
        <lm-equiv name="Step"></lm-equiv>
        <native-equiv name="IncrementValue"></native-equiv>
      </child>
    </node-structure>


    <!--****************
      -  ForEach
      ******************-->
    <node-structure name="ForEachStatementSyntax" parent="ForOrForEachStatementSyntax">
      <description>
        The For Each statement that begins a For Each-Next block. This statement always occurs as the Begin
        of a ForBlock,
        and the body of the For Each-Next is the Body of that ForBlock. Most of the time, the End
        of that ForBlock is the corresponding Next statement. However, multiple nested For statements are ended by
        a single Next statement with multiple variables, then the inner For statements will have End set to Nothing, and the
        Next statement is the End of the outermost For statement that is being ended.
      </description>
      <lm-equiv name="ForEachNode"></lm-equiv>
      <native-equiv name="ForEachInStatement"></native-equiv>

      <node-kind name="ForEachStatement">
        <lm-equiv name="ForEach" />
        <native-equiv name="Statements.Opcodes.ForEachIn" />
      </node-kind>

      <!-- Ensure For i and For each i are ordered correctly -->
      <child name="EachKeyword" kind="EachKeyword" order="20">
        <description>The "Each" keyword.</description>
        <lm-equiv name="EachKeyword"></lm-equiv>
        <native-equiv name="Each"></native-equiv>
      </child>

      <child name="InKeyword" kind="InKeyword" order="40">
        <description>The "In" keyword.</description>
        <lm-equiv name="InKeyword"></lm-equiv>
        <native-equiv name="In"></native-equiv>
      </child>

      <child name="Expression" kind="@ExpressionSyntax" order="50">
        <description>The expression denoting the collection to iterate over.</description>
        <lm-equiv name="Collection"></lm-equiv>
        <native-equiv name="Collection"></native-equiv>
      </child>
    </node-structure>

    <!--****************
      -  Next
      ******************-->
    <node-structure name="NextStatementSyntax" parent="StatementSyntax">
      <description>
        The Next statement that ends a For-Next or For Each-Next block. This statement always occurs as the End
        of a ForBlock (with Kind=ForBlock or ForEachBlock),
        and the body of the For-Next is the Body of that ForBlock. The Begin of that ForBlock
        has the corresponding For or For Each statement.
      </description>
      <lm-equiv name="NextNode"></lm-equiv>
      <native-equiv name="EndNextStatement"></native-equiv>
      <spec-section>10.9.2 For...Next Statements</spec-section>
      <spec-section>10.9.3 For Each...Next Statements</spec-section>
      <grammar>ForStatement</grammar>
      <grammar>ForEachStatement</grammar>

      <node-kind name="NextStatement">
        <lm-equiv name="Next" />
        <native-equiv name="Statements.Opcodes.EndNext" />
      </node-kind>

      <child name="NextKeyword" kind="NextKeyword">
        <description>The "Next" keyword.</description>
        <lm-equiv name="NextKeyword"></lm-equiv>
        <native-equiv name=""></native-equiv>
      </child>

      <child name="ControlVariables" optional="true" separator-kind="CommaToken" separator-name="CommaTokens" list="true" kind="@ExpressionSyntax">
        <description>The variables in the Next statement, if present</description>
        <lm-equiv name="Variables"></lm-equiv>
        <native-equiv name="Variables"></native-equiv>
      </child>
    </node-structure>

    <!--****************
      -  Using
      ******************-->
    <node-structure name="UsingStatementSyntax" parent="StatementSyntax">
      <description>
        The Using statement that begins a Using block. This statement always occurs as the Begin
        of a UsingBlock, and the body of the Using is the Body of that UsingBlock.
      </description>
      <lm-equiv name="UsingNode"></lm-equiv>
      <native-equiv name="UsingStatement"></native-equiv>

      <node-kind name="UsingStatement">
        <lm-equiv name="Using" />
        <native-equiv name="Statements.Opcodes.Using" />
      </node-kind>

      <child name="UsingKeyword" kind="UsingKeyword">
        <description>The "Using" keyword.</description>
        <lm-equiv name="UsingKeyword"></lm-equiv>
        <native-equiv name=""></native-equiv>
      </child>

      <child name="Expression" optional="true" kind="@ExpressionSyntax">
        <description>
          If the Using statement is of a form that does not declare a new variable, this is the expression
          used in the using. Otherwise, Nothing is returned.
        </description>
        <lm-equiv name="Value"></lm-equiv>
        <native-equiv name="ControlExpression"></native-equiv>
      </child>

      <child name="Variables" optional="true" separator-kind="CommaToken" separator-name="CommaTokens" list="true" kind="VariableDeclarator">
        <description>
          If the Using statement is of a form that declares one or more new variables, this is the
          list of variable declarations. Otherwise, Nothing is returned.
        </description>
        <lm-equiv name="Declarations"></lm-equiv>
        <native-equiv name="Declarations"></native-equiv>
      </child>
    </node-structure>

    <!--****************
      -  Throw
      ******************-->
    <node-structure name="ThrowStatementSyntax" parent="ExecutableStatementSyntax">
      <description>Represents a Throw statement.</description>
      <lm-equiv name="ThrowNode"></lm-equiv>
      <native-equiv name="ExpressionStatement"></native-equiv>
      <spec-section>10.10.1.3</spec-section>
      <grammar>ThrowStatement</grammar>

      <node-kind name="ThrowStatement">
        <lm-equiv name="Throw" />
        <native-equiv name="Statement.Opcodes.Throw" />
      </node-kind>

      <child name="ThrowKeyword" kind="ThrowKeyword">
        <description>The "Throw" keyword</description>
        <lm-equiv name="ThrowKeyword"></lm-equiv>
        <native-equiv name=""></native-equiv>
      </child>

      <child name="Expression" optional="true" kind="@ExpressionSyntax">
        <description>The expression denoting the value being thrown.</description>
        <lm-equiv name="Value"></lm-equiv>
        <native-equiv name="Operand"></native-equiv>
      </child>
    </node-structure>

    <!--****************
      -  Assignment
      ******************-->
    <node-structure name="AssignmentStatementSyntax" parent="ExecutableStatementSyntax">
      <description>
        Represents a simple, compound, or Mid assignment statement. Which one can be determined by checking
        the Kind.
      </description>
      <lm-equiv name="AssignmentNode"></lm-equiv>
      <native-equiv name="AssignmentStatement"></native-equiv>
      <spec-section>10.6.1</spec-section>
      <spec-section>10.6.2</spec-section>
      <grammar>RegularAssignmentStatement</grammar>
      <grammar>CompoundAssignmentStatement</grammar>

      <node-kind name="SimpleAssignmentStatement">
        <lm-equiv name="Assignment" />
        <native-equiv name="Assign" />
      </node-kind>

      <node-kind name="MidAssignmentStatement">
        <lm-equiv name="Assignment" />
        <native-equiv name="Assign" />
      </node-kind>

      <node-kind name="AddAssignmentStatement">
        <lm-equiv name="Assignment" />
        <native-equiv name="Expression.Opcodes.AssignPlus" />
      </node-kind>
      <node-kind name="SubtractAssignmentStatement">
        <lm-equiv name="Assignment" />
        <native-equiv name="Expression.Opcodes.AssignMinus" />
      </node-kind>
      <node-kind name="MultiplyAssignmentStatement">
        <lm-equiv name="Assignment" />
        <native-equiv name="Expression.Opcodes.AssignMultiply" />
      </node-kind>
      <node-kind name="DivideAssignmentStatement">
        <lm-equiv name="Assignment" />
        <native-equiv name="Expression.Opcodes.AssignDivide" />
      </node-kind>
      <node-kind name="IntegerDivideAssignmentStatement">
        <lm-equiv name="Assignment" />
        <native-equiv name="Expression.Opcodes.AssignIntegralDivide" />
      </node-kind>
      <node-kind name="ExponentiateAssignmentStatement">
        <lm-equiv name="Assignment" />
        <native-equiv name="Expression.Opcodes.AssignPower" />
      </node-kind>
      <node-kind name="LeftShiftAssignmentStatement">
        <lm-equiv name="Assignment" />
        <native-equiv name="Expression.Opcodes.AssignShiftLeft" />
      </node-kind>
      <node-kind name="RightShiftAssignmentStatement">
        <lm-equiv name="Assignment" />
        <native-equiv name="Expression.Opcodes.AssignShiftRight" />
      </node-kind>
      <node-kind name="ConcatenateAssignmentStatement">
        <lm-equiv name="Assignment" />
        <native-equiv name="Expression.Opcodes.AssignConcatenate" />
      </node-kind>

      <child name="Left" kind="@ExpressionSyntax">
        <description>The target (left hand side) of the assignment.</description>
        <lm-equiv name="Target"></lm-equiv>
        <native-equiv name="Target"></native-equiv>
      </child>

      <child name="OperatorToken">
        <description>The operator used in the assignment statement. One of "=", "+=", "-=", "*=", "/=", "\=", "^=", "&amp;=", "&lt;&lt;=" or "&gt;&gt;=".</description>
        <lm-equiv name="Operator"></lm-equiv>
        <native-equiv name="Operator"></native-equiv>

        <kind name="EqualsToken" node-kind="SimpleAssignmentStatement" />
        <kind name="EqualsToken" node-kind="MidAssignmentStatement" />
        <kind name="PlusEqualsToken" node-kind="AddAssignmentStatement" />
        <kind name="MinusEqualsToken" node-kind="SubtractAssignmentStatement" />
        <kind name="AsteriskEqualsToken" node-kind="MultiplyAssignmentStatement" />
        <kind name="SlashEqualsToken" node-kind="DivideAssignmentStatement" />
        <kind name="BackslashEqualsToken" node-kind="IntegerDivideAssignmentStatement" />
        <kind name="CaretEqualsToken" node-kind="ExponentiateAssignmentStatement" />
        <kind name="LessThanLessThanEqualsToken" node-kind="LeftShiftAssignmentStatement" />
        <kind name="GreaterThanGreaterThanEqualsToken" node-kind="RightShiftAssignmentStatement" />
        <kind name="AmpersandEqualsToken" node-kind="ConcatenateAssignmentStatement" />
      </child>

      <child name="Right" kind="@ExpressionSyntax">
        <description>The source (right hand side) of the assignment.</description>
        <lm-equiv name="Source"></lm-equiv>
        <native-equiv name="Source"></native-equiv>
      </child>
    </node-structure>

    <!--****************
      -  MidExpression
      ******************-->
    <node-structure name="MidExpressionSyntax" parent="ExpressionSyntax">
      <description>Represents a left-hand side of a MidAssignment statement.</description>
      <spec-section>10.6.3</spec-section>
      <grammar>Mid Assignment Statement</grammar>

      <node-kind name="MidExpression">
      </node-kind>

      <child name="Mid" kind="IdentifierToken">
        <description>The "Mid" possibly followed by a type character.</description>
      </child>

      <child name="ArgumentList" optional="false" kind="ArgumentList">
        <description>The argument list.</description>
        <lm-equiv name="Arguments"></lm-equiv>
        <native-equiv name="Arguments"></native-equiv>
      </child>
    </node-structure>

    <!--****************
      -  CallStatement
      ******************-->
    <node-structure name="CallStatementSyntax" parent="ExecutableStatementSyntax">
      <description>Represent an call statement (also known as a invocation statement).</description>
      <lm-equiv name="CallStatementNode"></lm-equiv>
      <native-equiv name="CallStatement"></native-equiv>
      <spec-section>10.7</spec-section>
      <grammar>InvocationStatement</grammar>

      <node-kind name="CallStatement">
        <lm-equiv name="CallStatement" />
        <native-equiv name="Statement.Opcodes.Call" />
      </node-kind>

      <child name="CallKeyword" kind="CallKeyword">
        <description>The "Call" keyword.</description>
        <lm-equiv name="CallKeyword"></lm-equiv>
        <native-equiv name="CallIsExplicit"></native-equiv>
      </child>

      <!-- REVIEW: Is this really better than the way it was? -->
      <child name="Invocation" kind="InvocationExpression|SimpleMemberAccessExpression">
        <description>
          The expression denoting the call. This could be an Invocation or a MemberAccess (in the case where
          no parentheses were supplied.)
        </description>
        <lm-equiv name="Target">The target of the call is the target of the Invocation expression referenced by Invocation.</lm-equiv>
        <lm-equiv name="Arguments">The arguments of the call is the arguments of the Invocation expression referenced by Invocation.</lm-equiv>
        <native-equiv name="Target">The target of the call is the target of the Invocation expression referenced by Invocation.</native-equiv>
        <native-equiv name="Arguments">The arguments of the call is the arguments of the Invocation expression referenced by Invocation.</native-equiv>
      </child>
    </node-structure>

    <!--****************
      -  AddRemoveHandler
      ******************-->
    <node-structure name="AddRemoveHandlerStatementSyntax" parent="ExecutableStatementSyntax">
      <description>Represents an AddHandler or RemoveHandler statement. The Kind property determines which one.</description>
      <lm-equiv name="AddHandlerNode"></lm-equiv>
      <native-equiv name="HandlerStatement"></native-equiv>
      <spec-section>10.5.2</spec-section>
      <grammar>AddHandlerStatement</grammar>
      <grammar>RemoveHandlerStatement</grammar>

      <node-kind name="AddHandlerStatement">
        <lm-equiv name="AddHandler" />
        <native-equiv name="Statement.Opcodes.AddHandler" />
      </node-kind>

      <node-kind name="RemoveHandlerStatement">
        <lm-equiv name="RemoveHandler" />
        <native-equiv name="Statement.Opcodes.RemoveHandler" />
      </node-kind>

      <child name="AddHandlerOrRemoveHandlerKeyword" >
        <description>The "AddHandler" or "RemoveHandler" keyword.</description>
        <lm-equiv name="AddHandlerKeyword"></lm-equiv>
        <native-equiv name=""></native-equiv>
        <kind name="AddHandlerKeyword" node-kind="AddHandlerStatement"/>
        <kind name="RemoveHandlerKeyword" node-kind="RemoveHandlerStatement"/>
      </child>

      <child name="EventExpression" kind="@ExpressionSyntax">
        <description>The event being accessed.</description>
        <lm-equiv name="Event"></lm-equiv>
        <native-equiv name="Event"></native-equiv>
      </child>

      <child name="CommaToken" kind="CommaToken">
        <description>The "," token.</description>
        <lm-equiv name="Comma"></lm-equiv>
        <native-equiv name="Comma"></native-equiv>
      </child>

      <child name="DelegateExpression" kind="@ExpressionSyntax">
        <description>The delegate being added or removed.</description>
        <lm-equiv name="Delegate"></lm-equiv>
        <native-equiv name="Delegate"></native-equiv>
      </child>
    </node-structure>

    <!--****************
      -  RaiseEvent
      ******************-->
    <node-structure name="RaiseEventStatementSyntax" parent="ExecutableStatementSyntax">
      <description>Represent a RaiseEvent statement.</description>
      <lm-equiv name="RaiseEventNode"></lm-equiv>
      <native-equiv name="RaiseEventStatement"></native-equiv>
      <spec-section>10.5.1</spec-section>
      <grammar>RaiseEventStatement</grammar>

      <node-kind name="RaiseEventStatement">
        <lm-equiv name="RaiseEvent" />
        <native-equiv name="Statement.Opcodes.RaiseEvent" />
      </node-kind>

      <child name="RaiseEventKeyword" kind="RaiseEventKeyword">
        <description>The "RaiseEvent" keyword</description>
        <lm-equiv name="RaiseEventKeyword"></lm-equiv>
        <native-equiv name=""></native-equiv>
      </child>

      <child name="Name" kind="IdentifierName">
        <description>The name of the event being raised.</description>
        <lm-equiv name="Event"></lm-equiv>
        <native-equiv name="Event"></native-equiv>
      </child>

      <child name="ArgumentList" optional="true" kind="ArgumentList">
        <description>The argument list, if present.</description>
        <lm-equiv name="Arguments"></lm-equiv>
        <native-equiv name="Arguments"></native-equiv>
      </child>
    </node-structure>

    <!--****************
      -  WithStatement
      ******************-->
    <node-structure name="WithStatementSyntax" parent="StatementSyntax">
      <description>
        Represents a "With" statement. This statement always occurs as the BeginStatement
        of a WithBlock, and the body of the With is the Body of that WithBlock.
      </description>
      <lm-equiv name="WithNode"></lm-equiv>
      <native-equiv name="ExpressionBlockStatement"></native-equiv>
      <spec-section>10.3</spec-section>
      <grammar>WithStatement</grammar>

      <node-kind name="WithStatement">
        <lm-equiv name="With" />
        <native-equiv name="Statement.Opcodes.With" />
      </node-kind>

      <child name="WithKeyword" kind="WithKeyword">
        <description>The "With" keyword.</description>
        <lm-equiv name="WithKeyword"></lm-equiv>
        <native-equiv name=""></native-equiv>
      </child>

      <child name="Expression" kind="@ExpressionSyntax">
        <description>The expression that is the operand of the With statement.</description>
        <lm-equiv name="Value"></lm-equiv>
        <native-equiv name="Operand"></native-equiv>
      </child>
    </node-structure>

    <!--****************
      -  ReDim
      ******************-->
    <node-structure name="ReDimStatementSyntax" parent="ExecutableStatementSyntax">
      <description>Represents a ReDim statement.</description>
      <lm-equiv name="ReDimNode"></lm-equiv>
      <native-equiv name="RedimStatement"></native-equiv>
      <spec-section>10.12.1</spec-section>
      <grammar>RedimStatement</grammar>

      <node-kind name="ReDimStatement">
        <lm-equiv name="ReDim" />
        <native-equiv name="Statement.Opcodes.Redim" />
      </node-kind>
      <node-kind name="ReDimPreserveStatement">
        <lm-equiv name="ReDim" />
        <native-equiv name="Statement.Opcodes.Redim" />
      </node-kind>

      <child name="ReDimKeyword" kind="ReDimKeyword">
        <description>The "ReDim" keyword.</description>
        <lm-equiv name="ReDimKeyword"></lm-equiv>
        <native-equiv name=""></native-equiv>
      </child>

      <child name="PreserveKeyword" optional="true" kind="PreserveKeyword">
        <description>Returns Nothing if Kind=ReDim, returns the "Preserve" keyword if Kind=RedimPreserve.</description>
        <lm-equiv name="PreserveKeyword"></lm-equiv>
        <native-equiv name="Preserve"></native-equiv>
        <native-equiv name="RedimStatement.HasPreserve">
          To determine if a ReDim statement has a Preserve, the recommended way is using the Kind and
          checking for ReDimPreserve.
        </native-equiv>
      </child>

      <child name="Clauses" list="true" separator-kind="CommaToken" separator-name="CommaTokens" kind="RedimClause">
        <description>
          The list of ReDim clauses.
        </description>
        <lm-equiv name="ReDims"></lm-equiv>
        <native-equiv name="Redims"></native-equiv>
      </child>
    </node-structure>

    <!--****************
      -  RedimClause
      ******************-->
    <node-structure name="RedimClauseSyntax" parent="VisualBasicSyntaxNode">
      <description>Represents a ReDim statement clause.</description>
      <grammar>RedimClause</grammar>

      <node-kind name="RedimClause">
      </node-kind>

      <child name="Expression" kind="@ExpressionSyntax">
        <description>The target of the ReDim statement.</description>
      </child>

      <child name="ArrayBounds" kind="ArgumentList">
        <description>The ArraySizeInitializationModifier.</description>
      </child>
    </node-structure>

    <!--****************
      -  EraseStatement
      ******************-->
    <node-structure name="EraseStatementSyntax" parent="ExecutableStatementSyntax">
      <description>Represents an "Erase" statement.</description>
      <lm-equiv name="EraseNode"></lm-equiv>
      <native-equiv name="EraseStatement"></native-equiv>
      <spec-section>10.12.2</spec-section>
      <grammar>EraseStatement</grammar>

      <node-kind name="EraseStatement">
        <lm-equiv name="Erase" />
        <native-equiv name="Statement.Opcodes.Erase" />
      </node-kind>

      <child name="EraseKeyword" kind="EraseKeyword">
        <description>The "Erase" keyword.</description>
        <lm-equiv name="EraseKeyword"></lm-equiv>
        <native-equiv name=""></native-equiv>
      </child>

      <child name="Expressions" list="true" separator-kind="CommaToken" separator-name="CommaTokens" kind="@ExpressionSyntax" min-count="1">
        <description>A list of expressions denoting the arrays to erase.</description>
        <lm-equiv name="Arrays"></lm-equiv>
        <native-equiv name="Arrays"></native-equiv>
      </child>
    </node-structure>

    <!-- ************************************************************************************************** -->
    <!-- **  EXPRESSIONS                                                                                 ** -->
    <!-- ************************************************************************************************** -->

    <!--****************
      -  ExpressionNode
      ******************-->
    <node-structure name="ExpressionSyntax" parent="VisualBasicSyntaxNode" abstract="true">
      <description>An abstract base class for all node classes that define expressions.</description>
      <lm-equiv name="ExpressionNode"></lm-equiv>
      <native-equiv name="Expression"></native-equiv>
    </node-structure>

    <!--****************
      -  Literal
      ******************-->
    <node-structure name="LiteralExpressionSyntax" parent="ExpressionSyntax">
      <!-- TODO: This seems kind of indirect, but I'm not sure how else to do it. It would be nice if 
      the particular tokens directly inherited Expression. -->
      <description>
        Represents a literal. The kind of literal is determined by the Kind property: IntegerLiteral, CharacterLiteral,
        BooleanLiteral, DecimalLiteral, FloatingLiteral, DateLiteral or StringLiteral. The value of the literal can be determined
        by casting the associated Token to the correct type and getting the value from the token.
      </description>
      <lm-equiv name="LiteralNode"></lm-equiv>
      <lm-equiv name="NothingNode"></lm-equiv>
      <native-equiv name="IntegralLiteralExpression"></native-equiv>
      <native-equiv name="CharacterLiteralExpression"></native-equiv>
      <native-equiv name="BooleanLiteralExpression"></native-equiv>
      <native-equiv name="DecimalLiteralExpression"></native-equiv>
      <native-equiv name="FloatingLiteralExpression"></native-equiv>
      <native-equiv name="DateLiteralExpression"></native-equiv>
      <native-equiv name="StringLiteralExpression"></native-equiv>
      <spec-section>11.4.1</spec-section>
      <grammar>LiteralExpression</grammar>

      <node-kind name="CharacterLiteralExpression">
        <lm-equiv name="Literal" />
        <native-equiv name="Expression.Opcodes.CharacterLiteral" />
      </node-kind>
      <node-kind name="TrueLiteralExpression">
        <lm-equiv name="Literal" />
        <native-equiv name="Expression.Opcodes.BooleanLiteral" />
      </node-kind>
      <node-kind name="FalseLiteralExpression">
        <lm-equiv name="Literal" />
        <native-equiv name="Expression.Opcodes.BooleanLiteral" />
      </node-kind>
      <node-kind name="NumericLiteralExpression">
        <lm-equiv name="Literal" />
        <native-equiv name="Expression.Opcodes.DecimalLiteral" />
        <native-equiv name="Expression.Opcodes.FloatingLiteral" />
        <native-equiv name="Expression.Opcodes.IntegralLiteral" />
      </node-kind>
      <node-kind name="DateLiteralExpression">
        <lm-equiv name="Literal" />
        <native-equiv name="Expression.Opcodes.DateLiteral" />
      </node-kind>
      <node-kind name="StringLiteralExpression">
        <lm-equiv name="Literal" />
        <native-equiv name="Expression.Opcodes.StringLiteral" />
      </node-kind>
      <node-kind name="NothingLiteralExpression">
        <lm-equiv name="Nothing" />
        <native-equiv name="Expression.Opcodes.Nothing" />
      </node-kind>

      <child name="Token" kind="IntegerLiteralToken|CharacterLiteralToken|DecimalLiteralToken|FloatingLiteralToken|DateLiteralToken|StringLiteralToken|TrueKeyword|FalseKeyword|NothingKeyword">
        <description>
          The token that represents the literal. The Kind property determines what type this property returns:
          Kind=IntegerLiteral ==&gt; Returns IntegerLiteralToken.
          Kind=CharacterLiteral ==&gt; Returns CharacterLiteralToken.
          Kind=DecimalLiteral ==&gt; Returns DecimalLiteralToken
          Kind=FloatingLiteral ==&gt; Returns FloatingLiteralToken
          Kind=DateLiteral ==&gt; Returns DateLiteralToken
          Kind=StringLiteral ==&gt; Returns StringLiteralToken
          Kind=BooleanLiteral ==&gt; Returns Keyword (with it's kind being TrueKeyword or FalseKeyword)
          Kind=NothingLiteral ==&gt; Returns Keyword (with it's kind being NothingKeyword)
        </description>
        <lm-equiv name="Token"></lm-equiv>
        <native-equiv name=""></native-equiv>
      </child>
    </node-structure>

    <!--****************
      -  Parenthesized
      ******************-->
    <node-structure name="ParenthesizedExpressionSyntax" parent="ExpressionSyntax">
      <description>Represents a parenthesized expression.</description>
      <lm-equiv name="ParenthesizedNode"></lm-equiv>
      <native-equiv name="ParenthesizedExpression"></native-equiv>
      <spec-section>11.4.2</spec-section>
      <grammar>ParenthesizedExpression</grammar>

      <node-kind name="ParenthesizedExpression">
        <lm-equiv name="Parenthesized" />
        <native-equiv name="Expression.Opcodes.ParenthesizedExpression" />
      </node-kind>

      <child name="OpenParenToken" kind="OpenParenToken">
        <description>The "(" token</description>
        <lm-equiv name="LeftParenthesis"></lm-equiv>
        <native-equiv name=""></native-equiv>
      </child>

      <child name="Expression" kind="@ExpressionSyntax">
        <description>The expression inside the parentheses.</description>
        <lm-equiv name="Value"></lm-equiv>
        <native-equiv name="UnaryExpression.Operand"></native-equiv>
      </child>

      <child name="CloseParenToken" kind="CloseParenToken">
        <description>The ")" token</description>
        <lm-equiv name="RightParenthesis"></lm-equiv>
        <native-equiv name="IsRightParenMissing"></native-equiv>
      </child>
    </node-structure>

    <!--****************
      -  TupleExpression
      ******************-->
    <node-structure name="TupleExpressionSyntax" parent="ExpressionSyntax">
      <description>Represents a tuple literal expression.</description>
      <grammar>TupleExpression</grammar>

      <node-kind name="TupleExpression" />

      <child name="OpenParenToken" kind="OpenParenToken">
        <description>The "(" token</description>
      </child>

      <child name="Arguments" optional="false" list="true" optional-elements="false" separator-kind="CommaToken" separator-name="CommaTokens" kind="@SimpleArgumentSyntax" min-count="2">
        <description>The list of tuple arguments.</description>
      </child>
      
      <child name="CloseParenToken" kind="CloseParenToken">
        <description>The ")" token</description>
      </child>
    </node-structure>

      <!--****************
      -  TupleType
      ******************-->
    <node-structure name="TupleTypeSyntax" parent="TypeSyntax">
      <description>Represents a tuple type expression.</description>
      <grammar>TupleType</grammar>

      <node-kind name="TupleType">
      </node-kind>

      <child name="OpenParenToken" kind="OpenParenToken">
        <description>The "(" token</description>
      </child>

      <child name="Elements" optional="false" list="true" optional-elements="false" separator-kind="CommaToken" separator-name="CommaTokens" kind="@TupleElementSyntax" min-count="2">
        <description>The list of tuple elements.</description>
      </child>
      
      <child name="CloseParenToken" kind="CloseParenToken">
        <description>The ")" token</description>
      </child>
    </node-structure>

    <!--********************
      -  TupleElementSyntax
      **********************-->
    <node-structure name="TupleElementSyntax" abstract="true" parent="VisualBasicSyntaxNode">
      <description>Represents a single declaration of a tuple element. </description>
      <grammar>TupleElement</grammar>
    </node-structure>

    <!--********************
      -  TypedTupleElementSyntax
      **********************-->
    <node-structure name="TypedTupleElementSyntax" parent="TupleElementSyntax">
      <description>Represents a single declaration of a tuple element supplying only the type. </description>
      <grammar>TypedTupleElement</grammar>

      <node-kind name="TypedTupleElement"></node-kind>

      <child name="Type" optional="false" kind="@TypeSyntax">
        <description>The type-name part of the tuple element syntax.</description>
      </child>
    </node-structure>

    <!--********************
      -  NamedTupleElementSyntax
      **********************-->
    <node-structure name="NamedTupleElementSyntax" parent="TupleElementSyntax">
      <description>Represents a single declaration of a tuple element supplying element name and optionally a type. </description>
      <grammar>NamedTupleElement</grammar>

      <node-kind name="NamedTupleElement"></node-kind>

      <child name="Identifier" kind="IdentifierToken">
        <description>The name of the element.</description>
      </child>

      <child name="AsClause" optional="true" kind="SimpleAsClause">
        <description>A simple "As" clause specifying the type of the tuple element.</description>
      </child>
    </node-structure>
    
    <!--****************
      -  SpecialInstance
      ******************-->
    <node-structure name="InstanceExpressionSyntax"  abstract="true" parent="ExpressionSyntax">
      <description>
        Identifies one of the special instances "Me", "MyClass" or "MyBase". The Kind property
        identifies which.
      </description>
      <lm-equiv name="MeNode"></lm-equiv>
      <lm-equiv name="MyClassNode"></lm-equiv>
      <lm-equiv name="MyBaseNode"></lm-equiv>
      <native-equiv name="Expression"></native-equiv>
      <spec-section>11.4.3</spec-section>
      <spec-section>11.6</spec-section>
      <grammar>InstanceExpression</grammar>
      <grammar>MemberAccessBase</grammar>

      <child name="Keyword" >
        <description>The "Me", "MyClass" or "MyBase" keyword.</description>
        <lm-equiv name="MeKeyword"></lm-equiv>
        <native-equiv name=""></native-equiv>
        <kind name="MeKeyword" node-kind="MeExpression"/>
        <kind name="MyClassKeyword" node-kind="MyClassExpression"/>
        <kind name="MyBaseKeyword" node-kind="MyBaseExpression"/>
      </child>
    </node-structure>

    <node-structure name="MeExpressionSyntax"  parent="InstanceExpressionSyntax">
      <description>
        Identifies the special instance "Me"
      </description>
      <lm-equiv name="MeNode"></lm-equiv>
      <native-equiv name="Expression"></native-equiv>
      <spec-section>11.4.3</spec-section>
      <spec-section>11.6</spec-section>
      <grammar>InstanceExpression</grammar>
      <grammar>MemberAccessBase</grammar>

      <node-kind name="MeExpression">
        <lm-equiv name="Me" />
        <native-equiv name="Expression.Opcodes.Me" />
      </node-kind>
    </node-structure>

    <node-structure name="MyBaseExpressionSyntax"  parent="InstanceExpressionSyntax">
      <description>
        Identifies the special instance "MyBase"
      </description>
      <lm-equiv name="MyBaseNode"></lm-equiv>
      <native-equiv name="Expression"></native-equiv>
      <spec-section>11.4.3</spec-section>
      <spec-section>11.6</spec-section>
      <grammar>InstanceExpression</grammar>
      <grammar>MemberAccessBase</grammar>

      <node-kind name="MyBaseExpression">
        <lm-equiv name="MyBase" />
        <native-equiv name="Expression.Opcodes.MyBase" />
      </node-kind>
    </node-structure>

    <node-structure name="MyClassExpressionSyntax"  parent="InstanceExpressionSyntax">
      <description>
        Identifies the special instance "MyClass"
      </description>
      <lm-equiv name="MyClassNode"></lm-equiv>
      <native-equiv name="Expression"></native-equiv>
      <spec-section>11.4.3</spec-section>
      <spec-section>11.6</spec-section>
      <grammar>InstanceExpression</grammar>
      <grammar>MemberAccessBase</grammar>

      <node-kind name="MyClassExpression">
        <lm-equiv name="MyClass" />
        <native-equiv name="Expression.Opcodes.MyClass" />
      </node-kind>
    </node-structure>

    <!--****************
      -  GetType
      ******************-->
    <node-structure name="GetTypeExpressionSyntax" parent="ExpressionSyntax">
      <description>Represents a GetType expression.</description>
      <lm-equiv name="GetTypeNode"></lm-equiv>
      <native-equiv name="GetTypeExpression"></native-equiv>
      <spec-section>11.5.1</spec-section>
      <grammar>GetTypeExpression</grammar>

      <node-kind name="GetTypeExpression">
        <lm-equiv name="GetType" />
        <native-equiv name="Expression.Opcodes.GetType" />
      </node-kind>

      <child name="GetTypeKeyword" kind="GetTypeKeyword">
        <description>The "GetType" keyword.</description>
        <lm-equiv name="GetTypeKeyword"></lm-equiv>
        <native-equiv name=""></native-equiv>
      </child>

      <child name="OpenParenToken" kind="OpenParenToken">
        <description>The "(" token.</description>
        <lm-equiv name="LeftParenthesis"></lm-equiv>
        <native-equiv name=""></native-equiv>
      </child>

      <!-- TODO: TypeName cannot express a type name with missing type arguments (an open generic type). -->
      <child name="Type" kind="@TypeSyntax">
        <description>The type to get the Type object for. This can be an open generic type.</description>
        <lm-equiv name="TargetType"></lm-equiv>
        <native-equiv name="TypeToGet"></native-equiv>
      </child>

      <child name="CloseParenToken" kind="CloseParenToken">
        <description>The ")" token.</description>
        <lm-equiv name="RightParenthesis"></lm-equiv>
        <native-equiv name=""></native-equiv>
      </child>
    </node-structure>

    <!--****************
      -  TypeOf ... Is/IsNot
      ******************-->
    <node-structure name="TypeOfExpressionSyntax" parent="ExpressionSyntax">
      <description>Represents a TypeOf...Is or IsNot expression.</description>
      <lm-equiv name="IsTypeNode"></lm-equiv>
      <native-equiv name="TypeValueExpression"></native-equiv>
      <spec-section>11.5.2</spec-section>
      <grammar>TypeOfIsExpression</grammar>

      <node-kind name="TypeOfIsExpression">
        <lm-equiv name="IsType" />
        <native-equiv name="Expression.Opcodes.IsType" />
      </node-kind>

      <node-kind name="TypeOfIsNotExpression" />

      <child name="TypeOfKeyword" kind="TypeOfKeyword">
        <description>The "TypeOf" keyword.</description>
        <lm-equiv name="TypeOfKeyword"></lm-equiv>
        <native-equiv name=""></native-equiv>
      </child>

      <child name="Expression" kind="@ExpressionSyntax">
        <description>The expression being tested.</description>
        <lm-equiv name="Value"></lm-equiv>
        <native-equiv name="Value"></native-equiv>
      </child>

      <child name="OperatorToken">
        <description>The "Is" or "IsNot" keyword.</description>
        <lm-equiv name="IsKeyword"></lm-equiv>
        <native-equiv name="HasIs"></native-equiv>

        <kind name="IsKeyword" node-kind="TypeOfIsExpression" />
        <kind name="IsNotKeyword" node-kind="TypeOfIsNotExpression" />
      </child>

      <child name="Type" kind="@TypeSyntax">
        <description>The name of the type being tested against.</description>
        <lm-equiv name="TargetType"></lm-equiv>
        <native-equiv name="TargetType"></native-equiv>
      </child>
    </node-structure>

    <!--****************
      -  GetXmlNamespaceExpression
      ******************-->
    <node-structure name="GetXmlNamespaceExpressionSyntax" parent="ExpressionSyntax">
      <description>Represents a GetXmlNamespace expression.</description>
      <lm-equiv name="GetTypeNode"></lm-equiv>
      <native-equiv name="GetTypeExpression"></native-equiv>
      <spec-section>11.5.1</spec-section>
      <grammar>GetTypeExpression</grammar>

      <node-kind name="GetXmlNamespaceExpression">
      </node-kind>

      <child name="GetXmlNamespaceKeyword" kind="GetXmlNamespaceKeyword">
        <description>The "GetXmlNamespace" keyword.</description>
      </child>

      <child name="OpenParenToken" kind="OpenParenToken">
        <description>The "(" token.</description>
        <lm-equiv name="LeftParenthesis"></lm-equiv>
        <native-equiv name=""></native-equiv>
      </child>

      <child name="Name" kind="@XmlPrefixNameSyntax" optional="true">
        <description>The Xml namespace name being referenced.</description>
      </child>

      <child name="CloseParenToken" kind="CloseParenToken">
        <description>The ")" token.</description>
        <lm-equiv name="RightParenthesis"></lm-equiv>
        <native-equiv name=""></native-equiv>
      </child>
    </node-structure>

    <!--****************
      -  MemberAccess
      ******************-->
    <node-structure name="MemberAccessExpressionSyntax" parent="ExpressionSyntax">
      <description>
        Represents member access (.name) or dictionary access (!name).
        The Kind property determines which kind of access.
      </description>

      <lm-equiv name="QualifiedNode"></lm-equiv>
      <native-equiv name="QualifiedExpression"></native-equiv>
      <spec-section>11.6</spec-section>
      <spec-section>11.7</spec-section>
      <spec-section>11.24</spec-section>
      <grammar>MemberAccessExpression</grammar>
      <grammar>DictionaryAccessExpression</grammar>

      <node-kind name="SimpleMemberAccessExpression">
        <lm-equiv name="Qualified" />
        <native-equiv name="Expression.Opcodes.DotQualified" />
      </node-kind>
      <node-kind name="DictionaryAccessExpression">
        <lm-equiv name="Qualified" />
        <native-equiv name="Expression.Opcodes.BangQualified" />
      </node-kind>

      <child name="Expression" optional="true" kind="@ExpressionSyntax">
        <description>The expression on the left-hand-side of the "." or "!" token.</description>
        <lm-equiv name="Base"></lm-equiv>
        <native-equiv name="Base"></native-equiv>
      </child>

      <child name="OperatorToken">
        <description>The "." or "!" token.</description>
        <lm-equiv name="Separator"></lm-equiv>
        <native-equiv name=""></native-equiv>
        <kind name="DotToken" node-kind="SimpleMemberAccessExpression" />
        <kind name="ExclamationToken" node-kind="DictionaryAccessExpression" />
      </child>

      <child name="Name" kind="@SimpleNameSyntax">
        <description>The identifier after the "." or "!" token.</description>
        <lm-equiv name="Value"></lm-equiv>
        <native-equiv name="Name"></native-equiv>
      </child>
    </node-structure>

    <node-structure name="XmlMemberAccessExpressionSyntax" parent="ExpressionSyntax">
      <description>
        Represents an XML member element access (node.&lt;Element&gt;), attribute access (node.@Attribute) or descendants access (node...&lt;Descendant&gt;).
        The Kind property determines which kind of access.
      </description>
      <grammar>XmlMemberAccessExpression</grammar>

      <node-kind name="XmlElementAccessExpression">
        <lm-equiv name="Qualified" />
        <native-equiv name="Expression.Opcodes.XmlElementQualified" />
      </node-kind>
      <node-kind name="XmlDescendantAccessExpression">
        <lm-equiv name="Qualified" />
        <native-equiv name="Expression.Opcodes.XmlElementQualified" />
      </node-kind>
      <node-kind name="XmlAttributeAccessExpression">
        <lm-equiv name="Qualified" />
        <native-equiv name="Expression.Opcodes.XmlElementQualified" />
      </node-kind>

      <child name="Base" optional="true" kind="@ExpressionSyntax">
        <description>The expression on the left-hand-side of the ".", ".@" or "..." .</description>
        <lm-equiv name="Base"></lm-equiv>
        <native-equiv name="Base"></native-equiv>
      </child>

      <child name="Token1" kind="DotToken">
        <description>The initial dot "." part of the separator.</description>
        <lm-equiv name="Separator"></lm-equiv>
        <native-equiv name=""></native-equiv>
      </child>

      <child name="Token2" optional="true" kind="DotToken|AtToken">
        <description>The "@" part of .@ or the second "." of "...".</description>
        <lm-equiv name="Separator"></lm-equiv>
        <native-equiv name=""></native-equiv>
      </child>

      <child name="Token3" optional="true" kind="DotToken">
        <description>The third "." in a "..." separator.</description>
        <lm-equiv name="Separator"></lm-equiv>
        <native-equiv name=""></native-equiv>
      </child>

      <!-- XmlName is called XmlQualifiedName in the VB spec-->
      <child name="Name" kind="XmlName|XmlBracketedName">
        <description>The identifier after the ".", ".@" or "..."</description>
        <lm-equiv name="Value"></lm-equiv>
        <native-equiv name="Name"></native-equiv>
      </child>
    </node-structure>



    <!--****************
      -  Invocation
      ******************-->
    <node-structure name="InvocationExpressionSyntax" parent="ExpressionSyntax">
      <description>Represents an invocation expression consisting of an invocation target and an optional argument list or an array, parameterized property or object default property index.</description>
      <lm-equiv name="CallOrIndexNode"></lm-equiv>
      <lm-equiv name="CallStatementNode"></lm-equiv>
      <native-equiv name="CallOrIndexExpression"></native-equiv>
      <native-equiv name="CallStatement"></native-equiv>
      <spec-section>11.8</spec-section>
      <grammar>InvocationExpression</grammar>

      <node-kind name="InvocationExpression">
        <lm-equiv name="CallOrIndex" />
        <native-equiv name="Expression.Opcodes.CallOrIndex" />
      </node-kind>

      <child name="Expression" optional="true" kind="@ExpressionSyntax">
        <description>The target of the call or index expression.</description>
        <lm-equiv name="Target"></lm-equiv>
        <native-equiv name="Target"></native-equiv>
      </child>

      <child name="ArgumentList" optional="true" kind="ArgumentList">
        <description>The argument list.</description>
        <lm-equiv name="Arguments"></lm-equiv>
        <native-equiv name="Arguments"></native-equiv>
      </child>
    </node-structure>

    <node-structure name="NewExpressionSyntax" parent="ExpressionSyntax" abstract="true" partial="true">
      <description>
        Base class for object, array and anonymous object creation expressions
      </description>

      <child name="NewKeyword" kind="NewKeyword">
        <description>The "New" keyword.</description>
        <!-- TODO: more equivalents here.-->
        <lm-equiv name="NewKeyword"></lm-equiv>
        <native-equiv name=""></native-equiv>
      </child>

      <child name="AttributeLists" optional="true" list="true" kind="AttributeList">
        <description>A list of all attribute lists on the type. If no attributes were specified, an empty list is returned.</description>
        <lm-equiv name="MethodBase.ReturnTypeAttributes"></lm-equiv>
        <native-equiv name="MethodSignature.ReturnTypeAttributes"></native-equiv>
      </child>
    </node-structure>


    <!--****************
      -  NewObject
      ******************-->
    <node-structure name="ObjectCreationExpressionSyntax" parent="NewExpressionSyntax">
      <description>
        Represents a New expression that creates a new non-array object, possibly with a "With" or "From" clause.
      </description>
      <lm-equiv name="NewNode"></lm-equiv>
      <lm-equiv name="NewWithInitializerNode"></lm-equiv>
      <lm-equiv name="CollectionInitializerNode"></lm-equiv>
      <native-equiv name="NewObjectInitializerExpression"></native-equiv>
      <native-equiv name="NewExpression"></native-equiv>
      <native-equiv name="CollectionInitializerExpression"></native-equiv>

      <node-kind name="ObjectCreationExpression">
        <lm-equiv name="NewNode" />
        <lm-equiv name="NewWithInitializer" />
        <lm-equiv name="CollectionInitializer" />
        <native-equiv name="Expression.Opcodes.New" />
        <native-equiv name="Expression.Opcodes.NewObjectInitializer" />
        <native-equiv name="Expression.Opcodes.CollectionInitializer" />
      </node-kind>

      <child name="Type" kind="NonArrayTypeName">
        <description>The type of the object being initialized.</description>
        <lm-equiv name="InstanceType"></lm-equiv>
        <native-equiv name="InstanceType"></native-equiv>
      </child>

      <child name="ArgumentList" optional="true" kind="ArgumentList">
        <description>The argument list, if present. If no argument list was supplied, Nothing is returned.</description>
        <!-- TODO: more equivalents here; qualify these.-->
        <lm-equiv name="Arguments"></lm-equiv>
        <lm-equiv name="VariableGroupWithNewNode.Arguments"></lm-equiv>
        <native-equiv name="NewAutoPropertyDeclaration.Arguments" />
      </child>

      <child name="Initializer" optional="true" kind="@ObjectCreationInitializerSyntax">
        <description>An optional From or With clause to initialize the new object.</description>
        <native-equiv name="NewVariableDeclaration.ObjectInitializer" />
        <native-equiv name="NewAutoPropertyDeclaration.ObjectInitializer" />
      </child>
    </node-structure>

    <!--****************
      -  AnonymousObjectCreationExpression
      ******************-->
    <node-structure name="AnonymousObjectCreationExpressionSyntax" parent="NewExpressionSyntax">
      <description>
        Represents a New expression that create an object of anonymous type.
      </description>
      <lm-equiv name="NewWithInitializerNode"></lm-equiv>
      <native-equiv name="NewObjectInitializerExpression"></native-equiv>

      <node-kind name="AnonymousObjectCreationExpression">
        <lm-equiv name="NewWithInitializer">If an anonymous object is being initialized, maps to NewAnonymousObject</lm-equiv>
        <native-equiv name="Expression.Opcodes.NewObjectInitializer">If an anonymous object is being initialized, maps to NewAnonymousObject</native-equiv>
      </node-kind>

      <child name="Initializer" kind="ObjectMemberInitializer">
        <description>The With clause to initialize the new object.</description>
        <native-equiv name="NewVariableDeclaration.ObjectInitializer" />
        <native-equiv name="NewAutoPropertyDeclaration.ObjectInitializer" />
      </child>
    </node-structure>

    <!-- TODO: New Array Expression -->
    <!--****************
      -  ArrayCreationExpression
      ******************-->
    <node-structure name="ArrayCreationExpressionSyntax" parent="NewExpressionSyntax">
      <description>
        Represents an expression that creates a new array.
      </description>
      <lm-equiv name="NewArrayInitializerNode"></lm-equiv>
      <native-equiv name="NewArrayInitializerExpression"></native-equiv>

      <node-kind name="ArrayCreationExpression">
        <lm-equiv name="NewArrayInitializerNode"></lm-equiv>
        <native-equiv name="Expression.Opcodes.NewArrayInitializer"></native-equiv>
      </node-kind>

      <child name="Type" kind="NonArrayTypeName">
        <description>The element type of the array being created.</description>
        <lm-equiv name="ArrayType"></lm-equiv>
        <native-equiv name=""></native-equiv>
      </child>

      <child name="ArrayBounds" optional="true" kind="ArgumentList">
        <description>The optional array bounds, such as "(4)" or "(0 to 5, 0 To 6)".</description>
        <!-- TODO: get equivalents. -->
        <lm-equiv name=""></lm-equiv>
        <native-equiv name=""></native-equiv>
      </child>

      <child name="RankSpecifiers" optional="true" list="true" kind="ArrayRankSpecifier">
        <description>A list of array modifiers such as "()" or "(,)". If no array modifiers were present, an empty list is returned.</description>
        <!-- TODO: get equivalents. -->
        <lm-equiv name=""></lm-equiv>
        <native-equiv name=""></native-equiv>
      </child>

      <child name="Initializer" kind="CollectionInitializer">
        <description>The initializer including the braces.</description>
      </child>

    </node-structure>

    <!--****************
      -  CollectionInitializerSyntax
      ******************-->
    <node-structure name="CollectionInitializerSyntax" parent="ExpressionSyntax">
      <description>
        Represents an expression that creates a new array without naming the element type.
      </description>
      <lm-equiv name="ArrayInitializerNode"></lm-equiv>
      <native-equiv name="ArrayInitializerExpression"></native-equiv>

      <node-kind name="CollectionInitializer">
        <lm-equiv name="ArrayInitializer"></lm-equiv>
        <native-equiv name="Expression.Opcodes.ArrayInitializer"></native-equiv>
      </node-kind>

      <child name="OpenBraceToken" kind="OpenBraceToken">
        <description>The "{" token.</description>
        <lm-equiv name="LeftBrace"></lm-equiv>
        <native-equiv name="BracedInitializerList.GetLocationOfLBrace"></native-equiv>
      </child>

      <child name="Initializers" optional="true" list="true" separator-kind="CommaToken" separator-name="CommaTokens" kind="@ExpressionSyntax">
        <description>The list of initializers between the braces.</description>
        <lm-equiv name="Initializers"></lm-equiv>
        <native-equiv name="BracedInitializerList.InitialValues"></native-equiv>
      </child>

      <child name="CloseBraceToken" kind="CloseBraceToken">
        <description>The "}" token.</description>
        <lm-equiv name="RightBrace"></lm-equiv>
        <native-equiv name="BracedInitializerList.RBracePresent"></native-equiv>
        <native-equiv name="BracedInitializerList.GetLocationOfRBrace"></native-equiv>
      </child>
    </node-structure>

    <!--****************
      -  Cast
      ******************-->
    <node-structure name="CastExpressionSyntax" parent="ExpressionSyntax" abstract="true">
      <description>
        Represents a CType, DirectCast or TryCast conversion expression. The Kind property determines which
        kind of cast it is.
      </description>
      <lm-equiv name="CastNode"></lm-equiv>
      <native-equiv name="ConversionExpression"></native-equiv>
      <spec-section>11.11</spec-section>
      <grammar>CastExpression</grammar>

      <child name="Keyword">
        <description>The "CType", "DirectCast" or "TryCast" keyword.</description>
        <lm-equiv name="Cast"></lm-equiv>
        <native-equiv name=""></native-equiv>
        <kind name="CTypeKeyword" node-kind="CTypeExpression"/>
        <kind name="DirectCastKeyword" node-kind="DirectCastExpression"/>
        <kind name="TryCastKeyword" node-kind="TryCastExpression"/>
      </child>

      <child name="OpenParenToken" kind="OpenParenToken">
        <description>The "(" token.</description>
        <lm-equiv name="LeftParenthesis"></lm-equiv>
        <native-equiv name=""></native-equiv>
      </child>

      <child name="Expression" kind="@ExpressionSyntax">
        <description>The expression being cast.</description>
        <lm-equiv name="Value"></lm-equiv>
        <native-equiv name="TypeValueExpression.Value"></native-equiv>
      </child>

      <child name="CommaToken" kind="CommaToken">
        <description>The "," token.</description>
        <lm-equiv name="Comma"></lm-equiv>
        <native-equiv name=""></native-equiv>
      </child>

      <child name="Type" kind="@TypeSyntax">
        <description>The type the expression is being cast to.</description>
        <lm-equiv name="TargetType"></lm-equiv>
        <native-equiv name="TypeValueExpression.TargetType"></native-equiv>
      </child>

      <child name="CloseParenToken" kind="CloseParenToken">
        <description>The ")" token.</description>
        <lm-equiv name="RightParenthesis"></lm-equiv>
        <native-equiv name=""></native-equiv>
      </child>
    </node-structure>

    <node-structure name="CTypeExpressionSyntax" parent="CastExpressionSyntax">
      <node-kind name="CTypeExpression" />
    </node-structure>

    <node-structure name="DirectCastExpressionSyntax" parent="CastExpressionSyntax">
      <node-kind name="DirectCastExpression" />
    </node-structure>

    <node-structure name="TryCastExpressionSyntax" parent="CastExpressionSyntax">
      <node-kind name="TryCastExpression" />
    </node-structure>

    <!--****************
      -  PredefinedCast
      ******************-->
    <node-structure name="PredefinedCastExpressionSyntax" parent="ExpressionSyntax">
      <description>Represents a cast to a pre-defined type using a pre-defined cast expression, such as CInt or CLng.</description>
      <lm-equiv name="PredefinedCastNode"></lm-equiv>
      <native-equiv name="UnaryExpression"></native-equiv>
      <spec-section>11.11</spec-section>
      <grammar>CastExpression</grammar>

      <node-kind name="PredefinedCastExpression">
        <lm-equiv name="PredefinedCast" />
        <native-equiv name="Expression.Opcodes.CastBoolean">The built-in type being cast to is represented by BuiltInCast.Type</native-equiv>
        <native-equiv name="Expression.Opcodes.CastCharacter">The built-in type being cast to is represented by BuiltInCast.Type</native-equiv>
        <native-equiv name="Expression.Opcodes.CastDate">The built-in type being cast to is represented by BuiltInCast.Type</native-equiv>
        <native-equiv name="Expression.Opcodes.CastDouble">The built-in type being cast to is represented by BuiltInCast.Type</native-equiv>
        <native-equiv name="Expression.Opcodes.CastSignedByte">The built-in type being cast to is represented by BuiltInCast.Type</native-equiv>
        <native-equiv name="Expression.Opcodes.CastByte">The built-in type being cast to is represented by BuiltInCast.Type</native-equiv>
        <native-equiv name="Expression.Opcodes.CastShort">The built-in type being cast to is represented by BuiltInCast.Type</native-equiv>
        <native-equiv name="Expression.Opcodes.CastUnsignedShort">The built-in type being cast to is represented by BuiltInCast.Type</native-equiv>
        <native-equiv name="Expression.Opcodes.CastInteger">The built-in type being cast to is represented by BuiltInCast.Type</native-equiv>
        <native-equiv name="Expression.Opcodes.CastUnsignedInteger">The built-in type being cast to is represented by BuiltInCast.Type</native-equiv>
        <native-equiv name="Expression.Opcodes.CastLong">The built-in type being cast to is represented by BuiltInCast.Type</native-equiv>
        <native-equiv name="Expression.Opcodes.CastUnsignedLong">The built-in type being cast to is represented by BuiltInCast.Type</native-equiv>
        <native-equiv name="Expression.Opcodes.CastDecimal">The built-in type being cast to is represented by BuiltInCast.Type</native-equiv>
        <native-equiv name="Expression.Opcodes.CastSingle">The built-in type being cast to is represented by BuiltInCast.Type</native-equiv>
        <native-equiv name="Expression.Opcodes.CastString">The built-in type being cast to is represented by BuiltInCast.Type</native-equiv>
        <native-equiv name="Expression.Opcodes.CastObject">The built-in type being cast to is represented by BuiltInCast.Type</native-equiv>
      </node-kind>

      <child name="Keyword" kind="CObjKeyword|CBoolKeyword|CDateKeyword|CCharKeyword|CStrKeyword|CDecKeyword|CByteKeyword|CSByteKeyword|CUShortKeyword|CShortKeyword|CUIntKeyword|CIntKeyword|CULngKeyword|CLngKeyword|CSngKeyword|CDblKeyword">
        <description>The keyword that was used in the cast operation.</description>
        <lm-equiv name="Cast"></lm-equiv>
        <native-equiv name=""></native-equiv>
      </child>

      <child name="OpenParenToken" kind="OpenParenToken">
        <description>The "(" token.</description>
        <lm-equiv name="LeftParenthesis"></lm-equiv>
        <native-equiv name=""></native-equiv>
      </child>

      <child name="Expression" kind="@ExpressionSyntax">
        <description>The expression being cast.</description>
        <lm-equiv name="Value"></lm-equiv>
        <native-equiv name=""></native-equiv>
      </child>

      <child name="CloseParenToken" kind="CloseParenToken">
        <description>The ")" token.</description>
        <lm-equiv name="RightParenthesis"></lm-equiv>
        <native-equiv name=""></native-equiv>
      </child>
    </node-structure>

    <!--****************
      -  BinaryOperator
      ******************-->
    <node-structure name="BinaryExpressionSyntax" parent="ExpressionSyntax">
      <description>
        Represents a binary operator. The Kind property classifies the operators into
        similar kind of operators (arithmetic, relational, logical or string);
        the exact operation being performed is determined by the Operator property.
      </description>
      <lm-equiv name="BinaryOperatorNode"></lm-equiv>
      <native-equiv name="BinaryExpression"></native-equiv>
      <spec-section>11.12</spec-section>
      <grammar>ArithmeticOperatorExpression</grammar>
      <grammar>RelationalOperatorExpression</grammar>
      <grammar>LikeOperatorExpression</grammar>
      <grammar>ConcatenationOperatorExpression</grammar>
      <grammar>ShortCircuitLogicalOperatorExpression</grammar>
      <grammar>LogicalOperatorExpression</grammar>
      <grammar>ShiftOperatorExpression</grammar>

      <node-kind name="AddExpression">
        <lm-equiv name="BinaryOperator" />
        <native-equiv name="Expression.Opcodes.Plus" />
      </node-kind>
      <node-kind name="SubtractExpression">
        <lm-equiv name="BinaryOperator" />
        <native-equiv name="Expression.Opcodes.Minus" />
      </node-kind>
      <node-kind name="MultiplyExpression">
        <lm-equiv name="BinaryOperator" />
        <native-equiv name="Expression.Opcodes.Multiply" />
      </node-kind>
      <node-kind name="DivideExpression">
        <lm-equiv name="BinaryOperator" />
        <native-equiv name="Expression.Opcodes.Divide" />
      </node-kind>
      <node-kind name="IntegerDivideExpression">
        <lm-equiv name="BinaryOperator" />
        <native-equiv name="Expression.Opcodes.IntegralDivide" />
      </node-kind>
      <node-kind name="ExponentiateExpression">
        <lm-equiv name="BinaryOperator" />
        <native-equiv name="Expression.Opcodes.Power" />
      </node-kind>
      <node-kind name="LeftShiftExpression">
        <lm-equiv name="BinaryOperator" />
        <native-equiv name="Expression.Opcodes.ShiftLeft" />
      </node-kind>
      <node-kind name="RightShiftExpression">
        <lm-equiv name="BinaryOperator" />
        <native-equiv name="Expression.Opcodes.ShiftRight" />
      </node-kind>
      <node-kind name="ConcatenateExpression">
        <lm-equiv name="BinaryOperator" />
        <native-equiv name="Expression.Opcodes.Concatenate" />
      </node-kind>
      <node-kind name="ModuloExpression">
        <lm-equiv name="BinaryOperator" />
        <native-equiv name="Expression.Opcodes.Modulus" />
      </node-kind>
      <node-kind name="EqualsExpression">
        <lm-equiv name="BinaryOperator" />
        <native-equiv name="Expression.Opcodes.Equal" />
      </node-kind>
      <node-kind name="NotEqualsExpression">
        <lm-equiv name="BinaryOperator" />
        <native-equiv name="Expression.Opcodes.NotEqual" />
      </node-kind>
      <node-kind name="LessThanExpression">
        <lm-equiv name="BinaryOperator" />
        <native-equiv name="Expression.Opcodes.Less" />
      </node-kind>
      <node-kind name="LessThanOrEqualExpression">
        <lm-equiv name="BinaryOperator" />
        <native-equiv name="Expression.Opcodes.LessEqual" />
      </node-kind>
      <node-kind name="GreaterThanOrEqualExpression">
        <lm-equiv name="BinaryOperator" />
        <native-equiv name="Expression.Opcodes.GreaterEqual" />
      </node-kind>
      <node-kind name="GreaterThanExpression">
        <lm-equiv name="BinaryOperator" />
        <native-equiv name="Expression.Opcodes.Greater" />
      </node-kind>
      <node-kind name="IsExpression">
        <lm-equiv name="BinaryOperator" />
        <native-equiv name="Expression.Opcodes.Is" />
      </node-kind>
      <node-kind name="IsNotExpression">
        <lm-equiv name="BinaryOperator" />
        <native-equiv name="Expression.Opcodes.IsNot" />
      </node-kind>
      <node-kind name="LikeExpression">
        <lm-equiv name="BinaryOperator" />
        <native-equiv name="Expression.Opcodes.Like" />
      </node-kind>
      <node-kind name="OrExpression">
        <lm-equiv name="BinaryOperator" />
        <native-equiv name="Expression.Opcodes.Or" />
      </node-kind>
      <node-kind name="ExclusiveOrExpression">
        <lm-equiv name="BinaryOperator" />
        <native-equiv name="Expression.Opcodes.Xor" />
      </node-kind>
      <node-kind name="AndExpression">
        <lm-equiv name="BinaryOperator" />
        <native-equiv name="Expression.Opcodes.And" />
      </node-kind>
      <node-kind name="OrElseExpression">
        <lm-equiv name="BinaryOperator" />
        <native-equiv name="Expression.Opcodes.OrElse" />
      </node-kind>
      <node-kind name="AndAlsoExpression">
        <lm-equiv name="BinaryOperator" />
        <native-equiv name="Expression.Opcodes.AndAlso" />
      </node-kind>

      <child name="Left" kind="@ExpressionSyntax">
        <description>The left operand.</description>
        <lm-equiv name="Left"></lm-equiv>
        <native-equiv name="Left"></native-equiv>
      </child>

      <child name="OperatorToken">
        <description></description>
        <lm-equiv name="Operator"></lm-equiv>
        <native-equiv name=""></native-equiv>
        <kind name="PlusToken" node-kind="AddExpression"/>
        <kind name="MinusToken" node-kind="SubtractExpression"/>
        <kind name="AsteriskToken" node-kind="MultiplyExpression"/>
        <kind name="SlashToken" node-kind="DivideExpression"/>
        <kind name="BackslashToken" node-kind="IntegerDivideExpression"/>
        <kind name="CaretToken" node-kind="ExponentiateExpression"/>
        <kind name="ModKeyword" node-kind="ModuloExpression"/>
        <kind name="LessThanLessThanToken" node-kind="LeftShiftExpression"/>
        <kind name="GreaterThanGreaterThanToken" node-kind="RightShiftExpression"/>
        <kind name="EqualsToken" node-kind="EqualsExpression"/>
        <kind name="LessThanGreaterThanToken" node-kind="NotEqualsExpression"/>
        <kind name="LessThanToken" node-kind="LessThanExpression"/>
        <kind name="LessThanEqualsToken" node-kind="LessThanOrEqualExpression"/>
        <kind name="GreaterThanToken" node-kind="GreaterThanExpression"/>
        <kind name="GreaterThanEqualsToken" node-kind="GreaterThanOrEqualExpression"/>
        <kind name="IsKeyword" node-kind="IsExpression"/>
        <kind name="IsNotKeyword" node-kind="IsNotExpression"/>
        <kind name="LikeKeyword" node-kind="LikeExpression"/>
        <kind name="AmpersandToken" node-kind="ConcatenateExpression"/>
        <kind name="OrKeyword" node-kind="OrExpression"/>
        <kind name="XorKeyword" node-kind="ExclusiveOrExpression"/>
        <kind name="AndKeyword" node-kind="AndExpression"/>
        <kind name="OrElseKeyword" node-kind="OrElseExpression"/>
        <kind name="AndAlsoKeyword" node-kind="AndAlsoExpression"/>
      </child>

      <child name="Right" kind="@ExpressionSyntax">
        <description>The right operand.</description>
        <lm-equiv name="Right"></lm-equiv>
        <native-equiv name="Right"></native-equiv>
      </child>
    </node-structure>


    <!--****************
      -  UnaryOperator
      ******************-->
    <node-structure name="UnaryExpressionSyntax" parent="ExpressionSyntax">
      <description>Describes a unary operator: Plus, Negate, Not or AddressOf.</description>
      <lm-equiv name="UnaryOperatorNode"></lm-equiv>
      <native-equiv name="UnaryExpression"></native-equiv>

      <node-kind name="UnaryPlusExpression">
        <lm-equiv name="UnaryOperator" />
        <native-equiv name="Expression.Opcodes.UnaryPlus" />
      </node-kind>
      <node-kind name="UnaryMinusExpression">
        <lm-equiv name="UnaryOperator" />
        <native-equiv name="Expression.Opcodes.Negate" />
      </node-kind>
      <node-kind name="NotExpression">
        <lm-equiv name="UnaryOperator" />
        <native-equiv name="Expression.Opcodes.Not" />
      </node-kind>
      <node-kind name="AddressOfExpression">
        <lm-equiv name="UnaryOperator" />
        <native-equiv name="Expression.Opcodes.AddressOf" />
      </node-kind>

      <child name="OperatorToken" >
        <description>The token that is the operator.</description>
        <lm-equiv name="Operator"></lm-equiv>
        <native-equiv name=""></native-equiv>
        <kind name="PlusToken"  node-kind="UnaryPlusExpression"/>
        <kind name="MinusToken"  node-kind="UnaryMinusExpression"/>
        <kind name="NotKeyword"  node-kind="NotExpression"/>
        <kind name="AddressOfKeyword"  node-kind="AddressOfExpression"/>
      </child>

      <child name="Operand" kind="@ExpressionSyntax">
        <description>The expression being operated on.</description>
        <lm-equiv name="Operand"></lm-equiv>
        <native-equiv name="Operand"></native-equiv>
      </child>
    </node-structure>

    <!--****************
      -  ConditionalExpression
      ******************-->
    <node-structure name="BinaryConditionalExpressionSyntax" parent="ExpressionSyntax">
      <description>Represents a conditional expression, If(condition, true-expr, false-expr) or If(expr, nothing-expr).</description>
      <lm-equiv name="IfOperatorNode"></lm-equiv>
      <native-equiv name="IIfExpression"></native-equiv>

      <node-kind name="BinaryConditionalExpression">
        <lm-equiv name="IfOperator" />
        <native-equiv name="Expression.Opcodes.IIf" />
      </node-kind>

      <child name="IfKeyword" kind="IfKeyword">
        <description>The "If" keyword</description>
        <lm-equiv name="IfKeyword"></lm-equiv>
        <native-equiv name=""></native-equiv>
      </child>

      <child name="OpenParenToken" kind="OpenParenToken">
        <description>The "(" token</description>
        <lm-equiv name="LeftParenthesis"></lm-equiv>
        <native-equiv name=""></native-equiv>
      </child>

      <child name="FirstExpression" kind="@ExpressionSyntax">
        <description>The first expression inside the parentheses.</description>
        <lm-equiv name="Value"></lm-equiv>
        <native-equiv name="Operand"></native-equiv>
      </child>

      <child name="CommaToken" kind="CommaToken">
        <description>The "," token.</description>
        <lm-equiv name="Comma"></lm-equiv>
        <native-equiv name="Comma"></native-equiv>
      </child>

      <child name="SecondExpression" kind="@ExpressionSyntax">
        <description>The second expression inside the parentheses.</description>
        <lm-equiv name="Value"></lm-equiv>
        <native-equiv name="Operand"></native-equiv>
      </child>

      <child name="CloseParenToken" kind="CloseParenToken">
        <description>The ")" token</description>
        <lm-equiv name="RightParenthesis"></lm-equiv>
        <native-equiv name="IsRightParenMissing"></native-equiv>
      </child>

    </node-structure>

    <node-structure name="TernaryConditionalExpressionSyntax" parent="ExpressionSyntax">
      <description>Represents a conditional expression, If(condition, true-expr, false-expr) or If(expr, nothing-expr).</description>
      <lm-equiv name="IfOperatorNode"></lm-equiv>
      <native-equiv name="IIfExpression"></native-equiv>

      <node-kind name="TernaryConditionalExpression">
        <lm-equiv name="IfOperator" />
        <native-equiv name="Expression.Opcodes.IIf" />
      </node-kind>

      <child name="IfKeyword" kind="IfKeyword">
        <description>The "If" keyword</description>
        <lm-equiv name="IfKeyword"></lm-equiv>
        <native-equiv name=""></native-equiv>
      </child>

      <child name="OpenParenToken" kind="OpenParenToken">
        <description>The "(" token</description>
        <lm-equiv name="LeftParenthesis"></lm-equiv>
        <native-equiv name=""></native-equiv>
      </child>

      <child name="Condition" kind="@ExpressionSyntax">
        <description>The first expression inside the parentheses.</description>
        <lm-equiv name="Value"></lm-equiv>
        <native-equiv name="Operand"></native-equiv>
      </child>

      <child name="FirstCommaToken" kind="CommaToken">
        <description>The "," token.</description>
        <lm-equiv name="Comma"></lm-equiv>
        <native-equiv name="Comma"></native-equiv>
      </child>

      <child name="WhenTrue" kind="@ExpressionSyntax">
        <description>The second expression inside the parentheses.</description>
        <lm-equiv name="Value"></lm-equiv>
        <native-equiv name="Operand"></native-equiv>
      </child>

      <child name="SecondCommaToken" kind="CommaToken">
        <description>The "," token.</description>
        <lm-equiv name="Comma"></lm-equiv>
        <native-equiv name="Comma"></native-equiv>
      </child>

      <child name="WhenFalse" kind="@ExpressionSyntax">
        <description>The second expression inside the parentheses.</description>
        <lm-equiv name="Value"></lm-equiv>
        <native-equiv name="Operand"></native-equiv>
      </child>

      <child name="CloseParenToken" kind="CloseParenToken">
        <description>The ")" token</description>
        <lm-equiv name="RightParenthesis"></lm-equiv>
        <native-equiv name="IsRightParenMissing"></native-equiv>
      </child>

    </node-structure>


    <!--****************
      -  Lambda
      ******************-->
    <node-structure name="LambdaExpressionSyntax" abstract="true" parent="ExpressionSyntax">
      <description>Represents a lambda expression, either single line or multi-line. </description>
      <lm-equiv name="LambdaNode"></lm-equiv>
      <native-equiv name="LambdaExpression"></native-equiv>
      <spec-section>11.20</spec-section>
      <grammar>LambdaExpression</grammar>

      <child name="SubOrFunctionHeader" kind="@LambdaHeaderSyntax">
        <description>The header part of the lambda that includes the "Sub" or "Function" keyword, the argument list and return type.</description>
      </child>

    </node-structure>


    <!--****************
      -  SingleLineLambdaExpression
      ******************-->
    <node-structure name="SingleLineLambdaExpressionSyntax" parent="LambdaExpressionSyntax">
      <description>Represents a single line lambda expression. </description>
      <lm-equiv name="LambdaNode"></lm-equiv>
      <native-equiv name="LambdaExpression"></native-equiv>
      <spec-section>11.20</spec-section>
      <grammar>LambdaExpression</grammar>

      <node-kind name="SingleLineFunctionLambdaExpression">
        <lm-equiv name="Lambda" />
        <native-equiv name="Expression.Opcodes.Lambda" />
      </node-kind>

      <node-kind name="SingleLineSubLambdaExpression">
        <lm-equiv name="Lambda" />
        <native-equiv name="Expression.Opcodes.Lambda" />
      </node-kind>

      <child name="Body" kind="@ExpressionSyntax|@StatementSyntax">
        <description>
          The body of the lambda. Depending on the kind of lambda, this is either a Statement
          (single-line Sub lambda) or Expression (single-line Function).
        </description>
      </child>
    </node-structure>


    <!--****************
      -  MultiLineLambdaExpression
      ******************-->
    <node-structure name="MultiLineLambdaExpressionSyntax" parent="LambdaExpressionSyntax">
      <description>Represents a multi-line lambda expression. </description>
      <lm-equiv name="LambdaNode"></lm-equiv>
      <native-equiv name="LambdaExpression"></native-equiv>
      <spec-section>11.20</spec-section>
      <grammar>LambdaExpression</grammar>

      <node-kind name="MultiLineFunctionLambdaExpression">
        <lm-equiv name="Lambda" />
        <native-equiv name="Expression.Opcodes.Lambda" />
      </node-kind>

      <node-kind name="MultiLineSubLambdaExpression">
        <lm-equiv name="Lambda" />
        <native-equiv name="Expression.Opcodes.Lambda" />
      </node-kind>

      <child name="Statements" optional="true" list="true" kind="@StatementSyntax">
        <description>
          The body of the lambda. Depending on the kind of lambda, this is either a StatementBody (multi-line lambda), Statement
          (single-line Sub lambda) or Expression (single-line Function). This might be an empty list.
        </description>
        <lm-equiv name="BlockNode.Contents"></lm-equiv>
        <native-equiv name="BlockStatement.Children"></native-equiv>
      </child>

      <child name="EndSubOrFunctionStatement" kind="EndSubStatement|EndFunctionStatement">
        <description>
          Returns the "End Sub" or "End Function" statement if this is a multi-line lambda.
        </description>
      </child>
    </node-structure>


    <!--****************
      -  LambdaHeader
      ******************-->
    <node-structure name="LambdaHeaderSyntax" parent="MethodBaseSyntax">
      <description>Represents the header part of a lambda expression</description>
      <lm-equiv name="LambdaNode"></lm-equiv>
      <native-equiv name="LambdaExpression"></native-equiv>
      <spec-section>11.20</spec-section>
      <grammar>LambdaExpression</grammar>

      <node-kind name="SubLambdaHeader" />

      <node-kind name="FunctionLambdaHeader" />

      <child name="SubOrFunctionKeyword" order="10">
        <description>
          The "Sub" or "Function" keyword that introduces this lambda expression.
        </description>
        <kind name ="SubKeyword" node-kind="SubLambdaHeader" />
        <kind name ="FunctionKeyword" node-kind="FunctionLambdaHeader" />
      </child>

      <child name="AsClause" optional="true" kind="SimpleAsClause" order="60">
        <description>The "As" clause that describes the return type. If no As clause was present, Nothing is returned.</description>
      </child>
    </node-structure>



    <!--****************
      -  ArgumentListNode
      ******************-->
    <node-structure name="ArgumentListSyntax" parent="VisualBasicSyntaxNode">
      <description>Represents a parenthesized argument list.</description>
      <native-equiv name="ParenthesizedArgumentList"></native-equiv>

      <node-kind name="ArgumentList" />

      <child name="OpenParenToken" kind="OpenParenToken">
        <description>The "(" token.</description>
        <lm-equiv name="LeftParenthesis"></lm-equiv>
        <native-equiv name=""></native-equiv>
      </child>

      <child name="Arguments" optional="true" list="true" optional-elements="true" separator-kind="CommaToken" separator-name="CommaTokens" kind="@ArgumentSyntax">
        <description>The list of arguments. This may be empty. Omitted argument are represented by an OmittedArgumentSyntax node.</description>
        <lm-equiv name="Arguments"></lm-equiv>
        <native-equiv name="Values"></native-equiv>
      </child>

      <child name="CloseParenToken" kind="CloseParenToken">
        <description>The ")" token.</description>
        <lm-equiv name="RightParenthesis"></lm-equiv>
        <native-equiv name="ClosingParenthesisIsPresent">
          To determine if the closing parenthesis was present,
          check the RightParenToken to see if it has an empty Span.
        </native-equiv>
      </child>
    </node-structure>

    <!--****************
      -  ArgumentNode
      ******************-->
    <node-structure name="ArgumentSyntax" parent="VisualBasicSyntaxNode" abstract="true">
      <description>Base class for the possible kinds of arguments that can appear in an argument list.</description>
      <lm-equiv name="ArgumentNode"></lm-equiv>
      <native-equiv name="Argument"></native-equiv>

    </node-structure>

    <!--****************
      -  OmittedArgumentNode
      ******************-->
    <node-structure name="OmittedArgumentSyntax" parent="ArgumentSyntax">
      <description>
        Represents an omitted argument in an argument list. An omitted argument is not considered a syntax error but
        a valid case when no argument is required.
      </description>
      <lm-equiv name="ArgumentNode"></lm-equiv>
      <native-equiv name="Argument"></native-equiv>

      <node-kind name="OmittedArgument">
      </node-kind>

      <child name="Empty" kind="EmptyToken">
        <description>An empty token because all non terminals must have a token.</description>
      </child>

    </node-structure>


    <!--********************
      -  SimpleArgumentSyntax
      **********************-->
    <node-structure name="SimpleArgumentSyntax" parent="ArgumentSyntax">
      <description>Represents an argument that is just an optional argument name and an expression.</description>

      <node-kind name="SimpleArgument">
        <lm-equiv name="Argument" />
      </node-kind>

      <child name="NameColonEquals" kind="NameColonEquals" optional="true">
        <description>The optional name and ":=" prefix of a named argument.</description>
      </child>

      <child name="Expression" kind="@ExpressionSyntax">
        <description>The expression that is the argument.</description>
        <lm-equiv name="Value"></lm-equiv>
        <native-equiv name="Value"></native-equiv>
      </child>

    </node-structure>

    <!--********************
      -  NameColonEqualsSyntax
      **********************-->
    <node-structure name="NameColonEqualsSyntax" parent="VisualBasicSyntaxNode">
      <description>Represents an identifier name followed by a ":=" token in a named argument.</description>

      <node-kind name="NameColonEquals" />

      <child name="Name" kind="IdentifierName">
        <description>The name used to identify the named argument.</description>
      </child>

      <child name="ColonEqualsToken" kind="ColonEqualsToken">
        <description>The ":=" token.</description>
      </child>
    </node-structure>

    <!--********************
      -  RangeArgumentNode
      **********************-->
    <node-structure name="RangeArgumentSyntax" parent="ArgumentSyntax">
      <description>
        Represents a range argument, such as "0 to 5", used in array bounds. The "Value" property
        represents the upper bound of the range.
      </description>
      <lm-equiv name="ArgumentNode"></lm-equiv>
      <native-equiv name="Argument"></native-equiv>

      <node-kind name="RangeArgument">
        <lm-equiv name="Range" />
        <lm-equiv name="Argument" />
        <native-equiv name="" />
      </node-kind>

      <child name="LowerBound" kind="@ExpressionSyntax">
        <description>The lower bound of the range. This is typically the integer constant zero.</description>
        <lm-equiv name="LowerBound"></lm-equiv>
        <native-equiv name="lowerBound"></native-equiv>
      </child>

      <child name="ToKeyword" kind="ToKeyword">
        <description>
          The "To" keyword.
        </description>
        <lm-equiv name="ToKeyword"></lm-equiv>
        <native-equiv name="To"></native-equiv>
      </child>

      <child name="UpperBound" kind="@ExpressionSyntax">
        <description>The upper bound of the range.</description>
        <lm-equiv name="LowerBound"></lm-equiv>
        <native-equiv name="lowerBound"></native-equiv>
      </child>

    </node-structure>

    <!-- ************************************************************************************************** -->
    <!-- **  QUERY (LINQ) EXPRESSIONS                                                                    ** -->
    <!-- ************************************************************************************************** -->

    <!--********************
      - QueryExpressionSyntax
      **********************-->
    <node-structure name="QueryExpressionSyntax" parent="ExpressionSyntax">
      <description>
        This class represents a query expression. A query expression is composed of one or
        more query operators in a row. The first query operator must be a From or Aggregate.
      </description>
      <lm-equiv name="LinqNode"></lm-equiv>
      <native-equiv name="LinqExpression"></native-equiv>
      <spec-section>11.21</spec-section>
      <grammar>QueryExpression</grammar>

      <node-kind name="QueryExpression"/>

      <child name="Clauses" list="true" kind="@QueryClauseSyntax">
        <description>
          A list of all the query operators in this query expression. This list always contains
          at least one operator.
        </description>
      </child>
    </node-structure>

    <!--********************
      - QueryClauseSyntax
      **********************-->
    <node-structure name="QueryClauseSyntax" abstract="true" parent="VisualBasicSyntaxNode">
      <description>
        This is a base class for all query operators.
      </description>
      <lm-equiv name="LinqOperatorNode"></lm-equiv>
      <native-equiv name="LinqOperatorExpression"></native-equiv>
      <spec-section>11.21</spec-section>
      <grammar>QueryOperator</grammar>
    </node-structure>


    <!--********************
      -  CollectionRangeVariable
      **********************-->
    <node-structure name="CollectionRangeVariableSyntax" parent="VisualBasicSyntaxNode">
      <description>Describes a single variable of the form "x [As Type] In expression" for use in query expressions.</description>
      <lm-equiv name="FromItemNode">When used in a From</lm-equiv>
      <lm-equiv name="LinqSourceNode">When used in a Join</lm-equiv>
      <native-equiv name="FromItem">When used in a From</native-equiv>
      <lm-equiv name="LinqSource">When used in a Join</lm-equiv>
      <spec-section>11.21.1</spec-section>
      <grammar>CollectionRangeVariableDeclaration</grammar>

      <node-kind name="CollectionRangeVariable">
        <lm-equiv name="FromItem">When used in a From</lm-equiv>
        <lm-equiv name="LinqSource">When used in a Join</lm-equiv>
        <native-equiv name="Expressions.Opcodes.LinqSource" />
      </node-kind>

      <child name="Identifier" kind="ModifiedIdentifier">
        <description>The name of the range variable being defined.</description>
        <lm-equiv name="Declarator.Name">In a From or Join</lm-equiv>
        <native-equiv name="Declarator.Name">In a From or Join</native-equiv>
      </child>

      <child name="AsClause" optional="true" kind="SimpleAsClause">
        <description>Describes the type of the variable being defined.</description>
        <lm-equiv name="VariableGroup.VariableType">In an Let or From query operator.</lm-equiv>
        <native-equiv name="VariableDeclaration.Type">In an Let or From query operator.</native-equiv>
      </child>

      <child name="InKeyword" kind="InKeyword">
        <description>The "In" keyword.</description>
        <lm-equiv name="InKeyword"></lm-equiv>
        <native-equiv name="FromItem.InOrEq"></native-equiv>
      </child>

      <!-- REVIEW: right name? -->
      <child name="Expression" kind="@ExpressionSyntax">
        <description>The expression that serves as the source of items for the range variable.</description>
        <lm-equiv name="Source"></lm-equiv>
        <native-equiv name="Source"></native-equiv>
      </child>
    </node-structure>

    <!--********************
      -  ExpressionRangeVariable
      **********************-->
    <node-structure name="ExpressionRangeVariableSyntax" parent="VisualBasicSyntaxNode">
      <description>Describes a single variable of the form "[x [As Type] =] expression" for use in query expressions.</description>
      <lm-equiv name="InitializerNode"></lm-equiv>
      <lm-equiv name="FromItemNode">When used in a Let.</lm-equiv>
      <native-equiv name="Initializer"></native-equiv>
      <native-equiv name="FromItem">When used in a Let.</native-equiv>
      <spec-section>11.21.1</spec-section>
      <grammar>ExpressionRangeVariableDeclaration</grammar>

      <node-kind name="ExpressionRangeVariable">
        <lm-equiv name="Initializer" />
        <lm-equiv name="FromItem" />
        <native-equiv name="" />
        <native-equiv name="" />
      </node-kind>

      <child name="NameEquals" optional="true" kind="VariableNameEquals">
        <description>
          The optional name and type of the expression range variable. If omitted, the name of the expression range variable
          is inferred from the expression.
        </description>
      </child>

      <child name="Expression" kind="@ExpressionSyntax">
        <description>The expression used to initialize the expression variable. </description>
        <lm-equiv name="Initializer.Value"></lm-equiv>
        <lm-equiv name="FromItem.Source"></lm-equiv>
        <native-equiv name="ExpressionInitializer.Value"></native-equiv>
        <native-equiv name="FromItem.Source"></native-equiv>
      </child>
    </node-structure>

    <!--********************
      -  AggregationRangeVariable
      **********************-->
    <node-structure name="AggregationRangeVariableSyntax" parent="VisualBasicSyntaxNode">
      <description>
        Describes a single variable of the form "[x [As Type] =] aggregation-function" for use in the Into clause
        of Aggregate or Group By or Group Join query operators.
      </description>
      <lm-equiv name="InitializerNode"></lm-equiv>
      <lm-equiv name="FromItemNode">When used in a Let.</lm-equiv>
      <native-equiv name="Initializer"></native-equiv>
      <native-equiv name="FromItem">When used in a Let.</native-equiv>
      <spec-section>11.21.1</spec-section>
      <grammar>ExpressionRangeVariableDeclaration</grammar>

      <node-kind name="AggregationRangeVariable">
        <lm-equiv name="Initializer" />
        <lm-equiv name="FromItem" />
        <native-equiv name="" />
        <native-equiv name="" />
      </node-kind>

      <child name="NameEquals" optional="true" kind="VariableNameEquals">
        <description>
          The optional name and type of the expression range variable. If omitted, the name of the expression range variable
          is inferred from the aggregation expression.
        </description>
      </child>

      <child name="Aggregation" kind="FunctionAggregation|GroupAggregation">
        <description>
          The name of the aggregation function. The "Group" aggregation function is represented by the
          identifier "Group".
        </description>
        <lm-equiv name="AggregateFunction"></lm-equiv>
        <native-equiv name="AggFunc"></native-equiv>
      </child>
    </node-structure>

    <!--********************
      -  VariableNameEquals
      **********************-->
    <node-structure name="VariableNameEqualsSyntax" parent="VisualBasicSyntaxNode">
      <description>
        Represents the name and optional type of an expression range variable.
      </description>

      <node-kind name="VariableNameEquals"/>

      <child name="Identifier" kind="ModifiedIdentifier">
        <description>The name of the variable being defined.</description>
        <lm-equiv name="Declarator.Name">In a Linq query operator</lm-equiv>
        <native-equiv name="Declarator.Name">In a Linq query operator </native-equiv>
      </child>

      <child name="AsClause" optional="true" kind="SimpleAsClause">
        <description>Describes the type of the variable being defined.</description>
        <lm-equiv name="VariableGroup.VariableType">In an Let or From query operator.</lm-equiv>
        <native-equiv name="VariableDeclaration.Type">In an Let or From query operator.</native-equiv>
      </child>

      <child name="EqualsToken" kind="EqualsToken">
        <description>The "=" token.</description>
        <lm-equiv name="Equal"></lm-equiv>
        <native-equiv name=""></native-equiv>
      </child>
    </node-structure>

    <!--********************
      -  Aggregation
      **********************-->
    <node-structure name="AggregationSyntax" abstract="true" parent="ExpressionSyntax">
      <description>
        Represents aggregation in aggregation range variable declaration of a
        Group By, Group Join or Aggregate query operator.
      </description>
    </node-structure>

    <!--********************
      -  FunctionAggregation
      **********************-->
    <node-structure name="FunctionAggregationSyntax" parent="AggregationSyntax">
      <description>
        Represents an invocation of an Aggregation function in the aggregation range variable declaration of a
        Group By, Group Join or Aggregate query operator.
      </description>
      <lm-equiv name="AggregationNode"></lm-equiv>
      <native-equiv name="AggregationExpression"></native-equiv>
      <spec-section>11.21.12</spec-section>

      <node-kind name="FunctionAggregation">
        <lm-equiv name="Aggregation" />
        <native-equiv name="Expression.Opcodes.Aggregation" />
      </node-kind>

      <!-- Just "Name"? "AggregateFunction"? -->
      <child name="FunctionName" kind="IdentifierToken">
        <description>The name of the aggregation function.</description>
        <lm-equiv name="AggregateFunction"></lm-equiv>
        <native-equiv name="AggFunc"></native-equiv>
      </child>

      <child name="OpenParenToken" optional="true" kind="OpenParenToken">
        <description>The "(" token if present.</description>
        <lm-equiv name="LeftParenthesis"></lm-equiv>
        <native-equiv name="HaveLParen"></native-equiv>
      </child>

      <child name="Argument" optional="true" kind="@ExpressionSyntax">
        <description>The argument to the aggregation function.</description>
        <lm-equiv name="Argument"></lm-equiv>
        <native-equiv name="Argument"></native-equiv>
      </child>

      <child name="CloseParenToken" optional="true" kind="CloseParenToken">
        <description>The ")" token, if present.</description>
        <lm-equiv name="RightParenthesis"></lm-equiv>
        <native-equiv name="HaveRParen"></native-equiv>
        <native-equiv name="RParenLocation"></native-equiv>
      </child>
    </node-structure>

    <!--********************
      -  GroupAggregation
      **********************-->
    <node-structure name="GroupAggregationSyntax" parent="AggregationSyntax">
      <description>
        Represents the use of "Group" as the aggregation function in the in the aggregation range variable declaration of a
        Group By or Group Join query operator.
      </description>
      <lm-equiv name="GroupReferenceNode"></lm-equiv>
      <native-equiv name=""></native-equiv>

      <node-kind name="GroupAggregation">
        <lm-equiv name="GroupReference" />
        <native-equiv name="Expression.Opcodes.GroupRef" />
      </node-kind>

      <child name="GroupKeyword" kind="GroupKeyword">
        <description>The "Group" keyword.</description>
        <lm-equiv name="GroupKeyword"></lm-equiv>
        <native-equiv name=""></native-equiv>
      </child>
    </node-structure>

    <!--********************
      - FromClause
      **********************-->
    <node-structure name="FromClauseSyntax" parent="QueryClauseSyntax">
      <description>
        Represents a "From" query operator. If this is the beginning of a query, the Source will be Nothing. Otherwise,
        the Source will be the part of the query to the left of the From.
      </description>
      <lm-equiv name="FromNode"></lm-equiv>
      <lm-equiv name="CrossJoinNode">CrossJoinExpression is no longer used. Instead the Source property of the FromClause defines the source.</lm-equiv>
      <native-equiv name="FromExpression"></native-equiv>
      <native-equiv name="CrossJoinExpression">CrossJoinExpression is no longer used. Instead the Source property of the FromClause defines the source.</native-equiv>
      <spec-section>11.21.4</spec-section>
      <grammar>FromClause</grammar>

      <node-kind name="FromClause">
        <lm-equiv name="From" />
        <native-equiv name="Expression.Opcodes.From" />
      </node-kind>

      <child name="FromKeyword" kind="FromKeyword">
        <description>The "From" keyword.</description>
        <lm-equiv name="FromKeyword"></lm-equiv>
        <native-equiv name=""></native-equiv>
      </child>

      <child name="Variables" list="true" separator-kind="CommaToken" separator-name="CommaTokens" kind="CollectionRangeVariable" min-count="1">
        <description>The list of collection variables declared by this From operator.</description>
        <lm-equiv name="Items"></lm-equiv>
        <native-equiv name="FromItems"></native-equiv>
      </child>
    </node-structure>

    <!--********************
      -  LetClause
      **********************-->
    <!-- REVIEW: Unify with Select or From? Or should it stay its own node? -->
    <node-structure name="LetClauseSyntax" parent="QueryClauseSyntax">
      <description>Represents a "Let" query operator.</description>
      <lm-equiv name="LetNode"></lm-equiv>
      <lm-equiv name="CrossJoinNode">CrossJoinExpression is no longer used. Instead the Source property of the LetClause defines the source.</lm-equiv>
      <native-equiv name="FromExpression"></native-equiv>
      <native-equiv name="CrossJoinExpression">CrossJoinExpression is no longer used. Instead the Source property of the LetClause defines the source.</native-equiv>
      <spec-section>11.21.6</spec-section>
      <grammar>LetClause</grammar>

      <node-kind name="LetClause">
        <lm-equiv name="Let" />
        <native-equiv name="Expression.Opcodes.Let" />
      </node-kind>

      <child name="LetKeyword" kind="LetKeyword">
        <description>The "Let" keyword.</description>
        <lm-equiv name="LetKeyword"></lm-equiv>
        <native-equiv name=""></native-equiv>
      </child>

      <child name="Variables" list="true" separator-kind="CommaToken" separator-name="VariableCommas" kind="ExpressionRangeVariable" min-count="1">
        <description>The list of expression range variable being defined by the Let operator.</description>
        <lm-equiv name="Items"></lm-equiv>
        <native-equiv name="FromItems"></native-equiv>
      </child>
    </node-structure>

    <!--********************
      -  AggregateClause
      **********************-->
    <node-structure name="AggregateClauseSyntax" parent="QueryClauseSyntax">
      <description>Represents an Aggregate query operator.</description>
      <lm-equiv name="AggregateNode"></lm-equiv>
      <native-equiv name="AggregateExpression"></native-equiv>
      <spec-section>11.21.13</spec-section>
      <grammar>AggregateClause</grammar>

      <node-kind name="AggregateClause">
        <lm-equiv name="Aggregate" />
        <native-equiv name="Expression.Opcodes.Aggregate" />
      </node-kind>

      <child name="AggregateKeyword" kind="AggregateKeyword">
        <description>The "Aggregate" keyword.</description>
        <lm-equiv name="AggregateKeyword"></lm-equiv>
        <native-equiv name=""></native-equiv>
      </child>

      <child name="Variables" list="true" separator-kind="CommaToken" separator-name="CommaTokens" kind="CollectionRangeVariable" min-count="1">
        <description>The list of collection range variables declared by this Aggregate operator.</description>
        <lm-equiv name="Items"></lm-equiv>
        <native-equiv name="FromItems"></native-equiv>
      </child>

      <child name="AdditionalQueryOperators" optional="true" list="true" kind="@QueryClauseSyntax">
        <description>A list of additional query operators. It may be empty. </description>
      </child>

      <child name="IntoKeyword" kind="IntoKeyword">
        <description>The "Into" keyword.</description>
        <lm-equiv name="IntoKeyword"></lm-equiv>
        <native-equiv name=""></native-equiv>
      </child>

      <child name="AggregationVariables" list="true" separator-kind="CommaToken" separator-name="VariableCommas" kind="AggregationRangeVariable" min-count="1">
        <description>The list of new variables being defined by the aggregation. </description>
        <lm-equiv name="Projection"></lm-equiv>
        <native-equiv name="Projection"></native-equiv>
      </child>
    </node-structure>

    <!--********************
      -  DistinctClause
      **********************-->
    <node-structure name="DistinctClauseSyntax" parent="QueryClauseSyntax">
      <description>Represents the "Distinct" query operator.</description>
      <lm-equiv name="DistinctNode"></lm-equiv>
      <native-equiv name="DistinctExpression"></native-equiv>
      <spec-section>11.21.8</spec-section>
      <grammar>DistinctClause</grammar>

      <node-kind name="DistinctClause">
        <lm-equiv name="Distinct" />
        <native-equiv name="Expression.Opcodes.Distinct" />
      </node-kind>

      <child name="DistinctKeyword" kind="DistinctKeyword">
        <description>The "Distinct" keyword.</description>
        <lm-equiv name="DistinctKeyword"></lm-equiv>
        <native-equiv name=""></native-equiv>
      </child>
    </node-structure>

    <!--********************
      -  WhereClause
      **********************-->
    <node-structure name="WhereClauseSyntax" parent="QueryClauseSyntax">
      <description>Represents a "Where" query operator.</description>
      <lm-equiv name="WhereNode"></lm-equiv>
      <native-equiv name="WhereExpression"></native-equiv>

      <node-kind name="WhereClause">
        <lm-equiv name="Where" />
        <native-equiv name="Expression.Opcodes.Where" />
      </node-kind>

      <child name="WhereKeyword" kind="WhereKeyword">
        <description>The "Where" keyword.</description>
        <lm-equiv name="WhereKeyword"></lm-equiv>
        <native-equiv name=""></native-equiv>
      </child>

      <child name="Condition" kind="@ExpressionSyntax">
        <description>The boolean expression used for filtering.</description>
        <lm-equiv name="Predicate"></lm-equiv>
        <native-equiv name="Predicate"></native-equiv>
      </child>
    </node-structure>

    <!--********************
      -  PartitionWhileClause
      **********************-->
    <node-structure name="PartitionWhileClauseSyntax" parent="QueryClauseSyntax">
      <description>Represents a "Skip While" or "Take While" query operator. The Kind property tells which.</description>
      <lm-equiv name="SkipWhileNode"></lm-equiv>
      <lm-equiv name="TakeWhileNode"></lm-equiv>
      <native-equiv name="WhileExpression"></native-equiv>
      <spec-section>11.21.10</spec-section>
      <grammar>PartitionClause</grammar>

      <node-kind name="SkipWhileClause">
        <lm-equiv name="SkipWhile" />
        <native-equiv name="Expression.Opcodes.SkipWhile" />
      </node-kind>
      <node-kind name="TakeWhileClause">
        <lm-equiv name="TakeWhile" />
        <native-equiv name="Expression.Opcodes.TakeWhile" />
      </node-kind>

      <child name="SkipOrTakeKeyword">
        <description>The "Skip" or "Take" keyword.</description>
        <lm-equiv name="SkipKeyword"></lm-equiv>
        <lm-equiv name="TakeKeyword"></lm-equiv>
        <native-equiv name=""></native-equiv>
        <kind name="SkipKeyword" node-kind="SkipWhileClause"/>
        <kind name="TakeKeyword" node-kind="TakeWhileClause"/>
      </child>

      <child name="WhileKeyword" kind="WhileKeyword">
        <description>The "While" keyword.</description>
        <lm-equiv name="WhileKeyword"></lm-equiv>
        <native-equiv name="While"></native-equiv>
      </child>

      <child name="Condition" kind="@ExpressionSyntax">
        <description>The boolean expression used for partitioning.</description>
        <lm-equiv name="Predicate"></lm-equiv>
        <native-equiv name="Predicate"></native-equiv>
      </child>
    </node-structure>


    <!--********************
      -  PartitionClause
      **********************-->
    <node-structure name="PartitionClauseSyntax" parent="QueryClauseSyntax">
      <description>Represents a "Skip" or "Take" query operator. The Kind property tells which.</description>
      <lm-equiv name="SkipNode"></lm-equiv>
      <lm-equiv name="TakeNode"></lm-equiv>
      <native-equiv name="SkipTakeExpression"></native-equiv>
      <spec-section>11.21.10</spec-section>
      <grammar>PartitionClause</grammar>

      <node-kind name="SkipClause">
        <lm-equiv name="Skip" />
        <native-equiv name="Expression.Opcodes.Skip" />
      </node-kind>
      <node-kind name="TakeClause">
        <lm-equiv name="Take" />
        <native-equiv name="Expression.Opcodes.Take" />
      </node-kind>

      <child name="SkipOrTakeKeyword" >
        <description>The "Skip" or "Take" keyword.</description>
        <lm-equiv name="SkipKeyword"></lm-equiv>
        <lm-equiv name="TakeKeyword"></lm-equiv>
        <native-equiv name=""></native-equiv>
        <kind name="SkipKeyword" node-kind="SkipClause"/>
        <kind name="TakeKeyword" node-kind="TakeClause"/>
      </child>

      <child name="Count" kind="@ExpressionSyntax">
        <description>Represents the expression with the number of items to take or skip.</description>
        <lm-equiv name="Count"></lm-equiv>
        <native-equiv name="Count"></native-equiv>
      </child>
    </node-structure>

    <!--********************
      -  GroupByClause
      **********************-->
    <node-structure name="GroupByClauseSyntax" parent="QueryClauseSyntax">
      <description>Represents the "Group By" query operator.</description>
      <lm-equiv name="GroupByNode"></lm-equiv>
      <native-equiv name="GroupByExpression"></native-equiv>

      <node-kind name="GroupByClause">
        <lm-equiv name="GroupBy" />
        <native-equiv name="Expression.Opcodes.GroupBy" />
      </node-kind>

      <child name="GroupKeyword" kind="GroupKeyword">
        <description>The "Group" keyword.</description>
        <lm-equiv name="GroupKeyword"></lm-equiv>
        <native-equiv name=""></native-equiv>
      </child>

      <child name="Items" list="true" optional="true" separator-kind="CommaToken" separator-name="ItemCommas" kind="ExpressionRangeVariable" min-count="1">
        <description>The optional list of variables being grouped; the contents of the Group clause. If none were specified, an empty list is returned.</description>
        <lm-equiv name="Items"></lm-equiv>
        <native-equiv name="Element"></native-equiv>
      </child>

      <child name="ByKeyword" kind="ByKeyword">
        <description>The "By" keyword.</description>
        <lm-equiv name="ByKeyword"></lm-equiv>
        <native-equiv name="By"></native-equiv>
        <native-equiv name="HaveBy"></native-equiv>
      </child>

      <child name="Keys" list="true" separator-kind="CommaToken" separator-name="KeyCommas" kind="ExpressionRangeVariable" min-count="1">
        <description>The key values being used for grouping.</description>
        <lm-equiv name="Keys"></lm-equiv>
        <native-equiv name="Key"></native-equiv>
      </child>

      <child name="IntoKeyword" kind="IntoKeyword">
        <description></description>
        <lm-equiv name="IntoKeyword"></lm-equiv>
        <native-equiv name=""></native-equiv>
      </child>

      <child name="AggregationVariables" list="true" separator-kind="CommaToken" separator-name="VariableCommas" kind="AggregationRangeVariable" min-count="1">
        <description>The list of new variables that calculate aggregations. </description>
        <lm-equiv name="Projection"></lm-equiv>
        <native-equiv name="Projection"></native-equiv>
      </child>
    </node-structure>

    <!--********************
      -  JoinClause
      **********************-->
    <node-structure name="JoinClauseSyntax" parent="QueryClauseSyntax" abstract="true">
      <description>Represents a Join or a Group Join  query operator.</description>

      <child name="JoinKeyword" order="1" kind="JoinKeyword">
        <description>The "Join" keyword.</description>
        <lm-equiv name="JoinKeyword"></lm-equiv>
        <native-equiv name=""></native-equiv>
      </child>

      <child name="JoinedVariables" order="1" list="true" separator-kind="CommaToken" separator-name="CommaTokens" kind="CollectionRangeVariable" min-count="1">
        <description>Defines the collection range variables being joined to. </description>
        <lm-equiv name="JoinTo"></lm-equiv>
        <native-equiv name="JoinTo"></native-equiv>
      </child>

      <child name="AdditionalJoins" order="1" list="true" optional="true" kind="SimpleJoinClause|GroupJoinClause">
        <description>
          An additional Join or Group Join query operator.
        </description>
      </child>

      <child name="OnKeyword" order="1" kind="OnKeyword">
        <description>The "On" keyword.</description>
        <lm-equiv name="OnKeyword"></lm-equiv>
        <native-equiv name="On"></native-equiv>
      </child>

      <!-- We need separatedSyntaxList to have Token separators.-->
      <child name="JoinConditions" order="1" list="true" separator-kind="AndKeyword" kind="JoinCondition" min-count="1">
        <description>
          The conditions indicating what expressions to compare during the join. Each condition is a JoinCondition, and
          the separators are "And" keywords.
        </description>
        <lm-equiv name="Predicate"></lm-equiv>
        <native-equiv name="Predicate"></native-equiv>
      </child>
    </node-structure>


    <!--********************
      -  JoinCondition
      **********************-->
    <node-structure name="JoinConditionSyntax" parent="VisualBasicSyntaxNode">
      <description>
        Represents the "expression Equals expression" condition in a Join.
      </description>

      <node-kind name="JoinCondition"/>

      <child name="Left" kind="@ExpressionSyntax">
        <description>The left expression in the Join condition.</description>
      </child>

      <child name="EqualsKeyword" kind="EqualsKeyword">
        <description>The "Equals" keyword.</description>
      </child>

      <child name="Right" kind="@ExpressionSyntax">
        <description>The right expression in the Join condition.</description>
      </child>
    </node-structure>

    <!--********************
      -  SimpleJoinClause
      **********************-->
    <node-structure name="SimpleJoinClauseSyntax" parent="JoinClauseSyntax">
      <description>Represents a Join query operator.</description>
      <lm-equiv name="InnerJoinNode"></lm-equiv>
      <native-equiv name="InnerJoinExpression"></native-equiv>
      <spec-section></spec-section>

      <node-kind name="SimpleJoinClause">
        <lm-equiv name="InnerJoin"></lm-equiv>
        <native-equiv name="Expression.Opcodes.InnerJoin"></native-equiv>
      </node-kind>

    </node-structure>

    <!--********************
      -  GroupJoinClause
      **********************-->
    <node-structure name="GroupJoinClauseSyntax" parent="JoinClauseSyntax">
      <description>Represents the "Group Join" query operator.</description>
      <lm-equiv name="GroupJoinNode"></lm-equiv>
      <native-equiv name="GroupJoinExpression"></native-equiv>
      <spec-section>11.21.14</spec-section>
      <grammar>GroupJoinClause</grammar>

      <node-kind name="GroupJoinClause">
        <lm-equiv name="GroupJoin" />
        <native-equiv name="Expression.Opcodes.GroupJoin" />
      </node-kind>

      <child name="GroupKeyword" order="0" kind="GroupKeyword">
        <description>The "Group" keyword.</description>
        <lm-equiv name="GroupKeyword"></lm-equiv>
        <native-equiv name=""></native-equiv>
      </child>

      <child name="IntoKeyword" order="2" kind="IntoKeyword">
        <description>The "Into" keyword.</description>
        <lm-equiv name="IntoKeyword"></lm-equiv>
        <native-equiv name="Into"></native-equiv>
      </child>

      <child name="AggregationVariables" order="2" list="true" separator-kind="CommaToken" separator-name="VariableCommas" kind="AggregationRangeVariable" min-count="1">
        <description>The list of new variables that calculate aggregations. </description>
        <lm-equiv name="Projection"></lm-equiv>
        <native-equiv name="Projection"></native-equiv>
      </child>
    </node-structure>

    <!--********************
      -  OrderBy
      **********************-->
    <node-structure name="OrderByClauseSyntax" parent="QueryClauseSyntax">
      <description>Represents the "Order By" query operator.</description>
      <lm-equiv name="OrderByNode"></lm-equiv>
      <native-equiv name="OrderByExpression"></native-equiv>
      <spec-section>11.21.11</spec-section>
      <grammar>OrderByClause</grammar>

      <node-kind name="OrderByClause">
        <lm-equiv name="OrderBy" />
        <native-equiv name="Expression.Opcodes.OrderBy" />
      </node-kind>

      <child name="OrderKeyword" kind="OrderKeyword">
        <description>The "Order" keyword</description>
        <lm-equiv name="OrderKeyword"></lm-equiv>
        <native-equiv name=""></native-equiv>
      </child>

      <child name="ByKeyword" kind="ByKeyword">
        <description>The "By" keyword.</description>
        <lm-equiv name="ByKeyword"></lm-equiv>
        <native-equiv name=""></native-equiv>
      </child>

      <child name="Orderings" list="true" separator-kind="CommaToken" separator-name="CommaTokens" kind="@OrderingSyntax" min-count="1">
        <description>The list of OrderExpression's to sort by.</description>
        <lm-equiv name="Items"></lm-equiv>
        <native-equiv name="OrderByItems"></native-equiv>
      </child>
    </node-structure>


    <!--********************
      -  OrderExpression
      **********************-->
    <node-structure name="OrderingSyntax" parent="VisualBasicSyntaxNode">
      <description>An expression to order by, plus an optional ordering. The Kind indicates whether to order in ascending or descending order.</description>
      <lm-equiv name="OrderByItemNode"></lm-equiv>
      <native-equiv name="OrderByItem"></native-equiv>
      <spec-section>11.21.11</spec-section>
      <grammar>OrderExpression</grammar>

      <node-kind name="AscendingOrdering">
        <lm-equiv name="OrderByItem" />
        <native-equiv name="OrderByItem.IsAscending" />
      </node-kind>
      <node-kind name="DescendingOrdering">
        <lm-equiv name="OrderByItem" />
        <native-equiv name="OrderByItem.IsDescending" />
      </node-kind>

      <child name="Expression" kind="@ExpressionSyntax">
        <description>The expression to sort by.</description>
        <lm-equiv name="Value"></lm-equiv>
        <native-equiv name="OrderExpression"></native-equiv>
      </child>

      <child name="AscendingOrDescendingKeyword" optional="true" >
        <description>
          The "Ascending" or "Descending" keyword, if present. To determine whether to sort in ascending or descending order, checking
          the Kind property is easier.
        </description>
        <lm-equiv name="Direction"></lm-equiv>
        <native-equiv name="AscendingDescending"></native-equiv>
        <kind name="AscendingKeyword" node-kind="AscendingOrdering"/>
        <kind name="DescendingKeyword" node-kind="DescendingOrdering"/>
      </child>
    </node-structure>

    <!--********************
      -  SelectClause
      **********************-->
    <node-structure name="SelectClauseSyntax" parent="QueryClauseSyntax">
      <description>Represents the "Select" query operator.</description>
      <lm-equiv name="SelectNode"></lm-equiv>
      <native-equiv name="SelectExpression"></native-equiv>
      <spec-section>11.21.7</spec-section>
      <grammar>SelectClause</grammar>

      <node-kind name="SelectClause">
        <lm-equiv name="Select" />
        <native-equiv name="Expression.Opcodes.Select" />
      </node-kind>

      <child name="SelectKeyword" kind="SelectKeyword">
        <description>The "Select" keyword.</description>
        <lm-equiv name="SelectKeyword"></lm-equiv>
        <native-equiv name=""></native-equiv>
      </child>

      <child name="Variables" list="true" separator-kind="CommaToken" separator-name="VariableCommas" kind="ExpressionRangeVariable" min-count="1">
        <description>The list of expression range variables being defined by the Select query operator.</description>
        <lm-equiv name="Projection"></lm-equiv>
        <native-equiv name="Projection"></native-equiv>
      </child>
    </node-structure>

    <!--****************
      -  Xml Expressions
      ******************-->

    <node-structure name="XmlNodeSyntax" parent="ExpressionSyntax" abstract="true">
      <description>
        This is the base class for all XML expression syntax nodes (XmlDocument and XmlElement).
      </description>
    </node-structure>

    <node-structure name="XmlDocumentSyntax" parent="XmlNodeSyntax">
      <description>
        Represents an XML Document literal expression.
      </description>
      <node-kind name="XmlDocument">
      </node-kind>

      <child name="Declaration" kind="XmlDeclaration"></child>

      <child name="PrecedingMisc" optional="true" list="true" kind="XmlComment|XmlProcessingInstruction"></child>

      <child name="Root" kind="XmlElement|XmlEmptyElement|XmlEmbeddedExpression"></child>

      <child name="FollowingMisc" optional="true" list="true" kind="XmlComment|XmlProcessingInstruction"></child>

    </node-structure>

    <node-structure name="XmlDeclarationSyntax" parent="VisualBasicSyntaxNode">
      <description>
        Represents the XML declaration prologue in an XML literal expression.
      </description>
      <node-kind name="XmlDeclaration">
      </node-kind>

      <child name="LessThanQuestionToken" kind="LessThanQuestionToken"></child>

      <!-- Should there be xml keyword tokens for Xml/Version/Standalone/Encoding???-->
      <!-- But these keywords are really contextual keywords, maybe contextualkind on NCName is better-->
      <child name="XmlKeyword" kind="XmlKeyword"></child>

      <child name="Version" kind="XmlDeclarationOption"></child>

      <child name="Encoding" optional="true" kind="XmlDeclarationOption"></child>

      <child name="Standalone" optional="true" kind="XmlDeclarationOption"></child>

      <child name="QuestionGreaterThanToken" kind="QuestionGreaterThanToken"></child>

    </node-structure>

    <!-- DTD Object Model 
      
      <node-structure name="XmlDocumentTypeSyntax" parent="XmlNodeSyntax">
          <node-kind name="XmlDocumentType">
          </node-kind>

          <child name="BeginDocTypeToken" kind="BeginDocTypeToken"></child>
          <child name="Name" kind="XmlNameToken"></child>
          <child name="ExternalID" kind="XmlSystemID|XmlPublicID" optional="true"></child>
                
          <child name="InternalSubSet" kind="XmlInternalSubset" optional="true"></child>
          <child name="GreaterThanToken" kind="GreaterThanToken"></child>
      </node-structure>

       <node-structure name="XmlExternalIDSyntax" parent="VisualBasicSyntaxNode" abstract="true">
      </node-structure>

      <node-structure name="XmlSystemIDSyntax" parent="XmlExternalIDSyntax">
          <node-kind name="XmlSystemID">
          </node-kind>

          <child name="SystemKeyword" kind="SystemKeyword"></child>
          <child name="SystemLiteral" kind="@XmlStringSyntax"></child>
      </node-structure>

      <node-structure name="XmlPublicIDSyntax" parent="XmlExternalIDSyntax" >
          <node-kind name="XmlPublicID">
          </node-kind>

          <child name="PublicKeyword" kind="PublicKeyword"></child>
          <child name="PublicLiteral" kind="@XmlStringSyntax"></child>
          <child name="SystemLiteral" kind="@XmlStringSyntax"></child>
      </node-structure>

      <node-structure name="XmlInternalSubsetSyntax" parent="VisualBasicSyntaxNode">
          <node-kind name="XmlInternalSubset">
          </node-kind>

          <child name="OpenBracketToken" kind="OpenBracketToken"></child>
          <child name="Text" kind="XmlTextLiteralToken" optional="true"></child>
          <child name="CloseBracketToken" kind="CloseBracketToken"></child>
      </node-structure>
      
      -->

    <node-structure name="XmlDeclarationOptionSyntax" parent="VisualBasicSyntaxNode">
      <description>Represents an XML document prologue option - version, encoding, standalone or whitespace in an XML literal expression.</description>

      <node-kind name="XmlDeclarationOption" />

      <child name="Name" kind="XmlNameToken"></child>
      <child name="Equals" kind="EqualsToken"></child>
      <child name="Value" kind="XmlString"></child>
    </node-structure>

    <node-structure name="XmlElementSyntax" parent="XmlNodeSyntax">
      <description>Represents an XML element with content in an XML literal expression.</description>

      <node-kind name="XmlElement" />

      <child name="StartTag" kind="XmlElementStartTag"></child>

      <child name="Content" optional="true " list="true" kind="@XmlNodeSyntax"></child>

      <child name="EndTag" kind="XmlElementEndTag"></child>
    </node-structure>

    <node-structure name="XmlTextSyntax" parent="XmlNodeSyntax">
      <description>
        Represents Xml text.
      </description>

      <node-kind name="XmlText">
      </node-kind>

      <child name="TextTokens" list="true" kind="XmlTextLiteralToken">
        <description>
          A list of all the text tokens in the Xml text.
          This list always contains at least one token.
        </description>
      </child>
    </node-structure>

    <node-structure name="XmlElementStartTagSyntax" parent="XmlNodeSyntax">
      <description>
        Represents the start tag of an XML element of the form &lt;element&gt;.
      </description>
      <node-kind name="XmlElementStartTag">
      </node-kind>

      <child name="LessThanToken" kind="LessThanToken"></child>

      <child name="Name" kind="XmlName|XmlEmbeddedExpression"></child>

      <child name="Attributes" optional="true" list="true" kind="XmlAttribute|XmlEmbeddedExpression"></child>

      <child name="GreaterThanToken" kind="GreaterThanToken"></child>

    </node-structure>

    <node-structure name="XmlElementEndTagSyntax" parent="XmlNodeSyntax">
      <description>
        Represents the end tag of an XML element of the form &lt;/element&gt;.
      </description>
      <node-kind name="XmlElementEndTag">
      </node-kind>

      <child name="LessThanSlashToken" kind="LessThanSlashToken"></child>

      <child name="Name" optional="true" kind="XmlName"></child>

      <child name="GreaterThanToken" kind="GreaterThanToken"></child>
    </node-structure>

    <node-structure name="XmlEmptyElementSyntax" parent="XmlNodeSyntax">
      <description>
        Represents an empty XML element of the form &lt;element /&gt;
      </description>
      <node-kind name="XmlEmptyElement">
      </node-kind>

      <child name="LessThanToken" kind="LessThanToken"></child>

      <child name="Name" kind="XmlName|XmlEmbeddedExpression"></child>

      <child name="Attributes" optional="true" list="true" kind="XmlAttribute|XmlEmbeddedExpression"></child>

      <child name="SlashGreaterThanToken" kind="SlashGreaterThanToken"></child>

    </node-structure>

    <node-structure name="XmlAttributeSyntax" parent="BaseXmlAttributeSyntax">
      <description>Represents an XML attribute in an XML literal expression.</description>

      <node-kind name="XmlAttribute" />

      <child name="Name" kind="XmlName|XmlEmbeddedExpression">
      </child>

      <child name="EqualsToken" kind="EqualsToken">
      </child>

      <child name="Value" kind="XmlString|XmlEmbeddedExpression">
      </child>
    </node-structure>

    <node-structure name="BaseXmlAttributeSyntax" abstract="true" parent="XmlNodeSyntax">
      <description>Represents an XML attribute in an XML literal expression.</description>
    </node-structure>

    <node-structure name="XmlStringSyntax" parent="XmlNodeSyntax">
      <description>Represents a string of XML characters embedded as the content of an XML element.</description>
      <node-kind name="XmlString">
      </node-kind>

      <child name="StartQuoteToken" kind="DoubleQuoteToken|SingleQuoteToken"></child>
      <child name="TextTokens" optional="true" list="true" kind="XmlTextLiteralToken|XmlEntityLiteralToken"></child>
      <child name="EndQuoteToken" kind="DoubleQuoteToken|SingleQuoteToken"></child>
    </node-structure>

    <node-structure name="XmlPrefixNameSyntax" parent="XmlNodeSyntax">
      <description>Represents an XML name of the form 'name' appearing in GetXmlNamespace().</description>

      <node-kind name="XmlPrefixName" />

      <child name="Name" kind="XmlNameToken"></child>
    </node-structure>

    <node-structure name="XmlNameSyntax" parent="XmlNodeSyntax">
      <description>Represents an XML name of the form 'name' or 'namespace:name' appearing in source as part of an XML literal or member access expression or an XML namespace import clause.</description>

      <node-kind name="XmlName" />

      <child name="Prefix" optional="true" kind="XmlPrefix"></child>
      <child name="LocalName" kind="XmlNameToken"></child>
    </node-structure>

    <node-structure name="XmlBracketedNameSyntax" parent="XmlNodeSyntax">
      <description>Represents an XML name of the form &lt;xml-name&gt; appearing in source as part of an XML literal or member access expression or an XML namespace import clause.</description>

      <node-kind name="XmlBracketedName" />

      <child name="LessThanToken" kind="LessThanToken"></child>
      <child name="Name" kind="XmlName"></child>
      <child name="GreaterThanToken" kind="GreaterThanToken"></child>
    </node-structure>

    <node-structure name="XmlPrefixSyntax" parent="VisualBasicSyntaxNode">
      <description>Represents an XML namespace prefix of the form 'prefix:' as in xml:ns="".</description>

      <node-kind name="XmlPrefix" />

      <child name="Name" kind="XmlNameToken"></child>
      <child name="ColonToken" kind="ColonToken"></child>
    </node-structure>

    <node-structure name="XmlCommentSyntax" parent="XmlNodeSyntax">
      <description>Represents an XML comment of the form &lt;!-- Comment --&gt; appearing in an XML literal expression.</description>

      <node-kind name="XmlComment" />

      <child name="LessThanExclamationMinusMinusToken" kind="LessThanExclamationMinusMinusToken"></child>

      <!--The scanner will mark multiple -'s in the string with an error on the token -->
      <child name="TextTokens" list="true" kind="XmlTextLiteralToken">
      </child>

      <child name="MinusMinusGreaterThanToken" kind="MinusMinusGreaterThanToken">
      </child>

    </node-structure>

    <node-structure name="XmlProcessingInstructionSyntax" parent="XmlNodeSyntax">
      <description>Represents an XML processing instruction of the form '&lt;? XMLProcessingTarget XMLProcessingValue ?&gt;'.</description>

      <node-kind name="XmlProcessingInstruction" />

      <child name="LessThanQuestionToken" kind="LessThanQuestionToken"></child>

      <!-- TODO this name is really an XMLName, colon's are allowed -->
      <!-- In the spec this is a PiTarget, an XmlName with colon's allowed - Xml-->
      <child name="Name" kind="XmlNameToken">
      </child>

      <!-- rename XmlPIToken to something better.  This is the char data in the pi-->
      <child name="TextTokens" list="true" kind="XmlTextLiteralToken"></child>

      <child name="QuestionGreaterThanToken" kind="QuestionGreaterThanToken">
      </child>

    </node-structure>

    <node-structure name="XmlCDataSectionSyntax" parent="XmlNodeSyntax">
      <description>Represents an XML CDATA section in an XML literal expression.</description>
      <node-kind name="XmlCDataSection">
      </node-kind>

      <child name="BeginCDataToken" kind="BeginCDataToken"></child>

      <child name="TextTokens" list="true" kind="XmlTextLiteralToken"></child>

      <child name="EndCDataToken" kind="EndCDataToken">
      </child>

    </node-structure>

    <node-structure name="XmlEmbeddedExpressionSyntax" parent="XmlNodeSyntax">
      <description>Represents an embedded expression in an XML literal e.g. '&lt;name&gt;&lt;%= obj.Name =%&gt;&lt;/name&gt;'.</description>

      <node-kind name="XmlEmbeddedExpression" />

      <child name="LessThanPercentEqualsToken" kind="LessThanPercentEqualsToken"></child>

      <child name="Expression" kind="@ExpressionSyntax">
      </child>

      <child name="PercentGreaterThanToken" kind="PercentGreaterThanToken">
      </child>

    </node-structure>


    <!-- ************************************************************************************************** -->
    <!-- **  TYPES                                                                                       ** -->
    <!-- ************************************************************************************************** -->


    <!--********************
      -  TypeName
      **********************-->
    <node-structure name="TypeSyntax" parent="ExpressionSyntax" abstract="true">
      <description>
        Abstract node class that represents the textual description of a type, possibly
        include generic type arguments, qualified names, array specifiers, nullable specifier and the like.
      </description>
      <lm-equiv name="TypeNode"></lm-equiv>
      <native-equiv name="Type"></native-equiv>
    </node-structure>


    <!--********************
      -  ArrayTypeName
      **********************-->
    <node-structure name="ArrayTypeSyntax" parent="TypeSyntax">
      <description>Represents an array type, such as "A() or "A(,)", without bounds specified for the array.</description>
      <lm-equiv name="ArrayTypeNode"></lm-equiv>
      <native-equiv name="ArrayType"></native-equiv>

      <node-kind name="ArrayType">
        <lm-equiv name="ArrayType" />
        <native-equiv name="Type.Opcode.ArrayWithoutSizes" />
      </node-kind>

      <child name="ElementType" kind="NonArrayTypeName">
        <description>The type of the elements of the array.</description>
        <lm-equiv name="ElementType"></lm-equiv>
        <native-equiv name="ElementType"></native-equiv>
      </child>

      <child name="RankSpecifiers" list="true" kind="ArrayRankSpecifier">
        <description>Represents the list of "()" or "(,,)" modifiers on the array type.</description>
      </child>
    </node-structure>

    <!--********************
      -  NullableTypeName
      **********************-->
    <node-structure name="NullableTypeSyntax" parent="TypeSyntax">
      <description>A type name that represents a nullable type, such as "Integer?".</description>
      <lm-equiv name="NullableTypeNode"></lm-equiv>
      <native-equiv name="NullableType"></native-equiv>

      <node-kind name="NullableType">
        <lm-equiv name="NullableType" />
        <native-equiv name="Type.Opcodes.Nullable" />
      </node-kind>

      <child name="ElementType" kind="PredefinedType|@NameSyntax|TupleType">
        <description>The kind of type that is this type is a nullable of. Cannot be an array type or a nullable type.</description>
        <lm-equiv name="ElementType"></lm-equiv>
        <native-equiv name="ElementType"></native-equiv>
      </child>

      <child name="QuestionMarkToken" kind="QuestionToken">
        <description>The "?" token.</description>
        <lm-equiv name="QuestionMark"></lm-equiv>
        <native-equiv name="QuestionMark"></native-equiv>
      </child>
    </node-structure>

    <!--********************
      -  PredefinedTypeName
      **********************-->
    <node-structure name="PredefinedTypeSyntax" parent="TypeSyntax">
      <description>Represents an occurrence of a Visual Basic built-in type such as Integer or String in source code.</description>
      <lm-equiv name="PredefinedTypeNode"></lm-equiv>
      <native-equiv name=""></native-equiv>

      <node-kind name="PredefinedType">
        <lm-equiv name="PredefinedType" />
        <native-equiv name="" />
      </node-kind>

      <child name="Keyword" kind="ObjectKeyword|BooleanKeyword|DateKeyword|CharKeyword|StringKeyword|DecimalKeyword|ByteKeyword|SByteKeyword|UShortKeyword|ShortKeyword|UIntegerKeyword|IntegerKeyword|ULongKeyword|LongKeyword|SingleKeyword|DoubleKeyword" syntax-facts-internal="true">
        <description>The keyword that was used to describe the built-in type.</description>
        <lm-equiv name="Keyword"></lm-equiv>
        <native-equiv name=""></native-equiv>
      </child>
    </node-structure>

    <node-kind-alias name="NonArrayTypeName" alias="PredefinedType|NullableType|@NameSyntax|TupleType">
      <description>A type name that cannot be an array type.</description>
    </node-kind-alias>

    <node-kind-alias name="NonArrayNonTupleTypeName" alias="PredefinedType|NullableType|@NameSyntax">
      <description>A type name that cannot be an array or tuple type.</description>
    </node-kind-alias>


    <!-- ************************************************************************************************** -->
    <!-- **  NAMES                                                                                        ** -->
    <!-- ************************************************************************************************** -->

    <!--********************
      -  Name
      **********************-->
    <node-structure name="NameSyntax" parent="TypeSyntax" abstract="true">
      <description>
        Abstract node class that represents a name, possibly
        include generic arguments and qualified names.
      </description>
      <lm-equiv name="NameNode"></lm-equiv>
      <native-equiv name="Name"></native-equiv>
    </node-structure>

    <!--********************
      -  SimpleName
      **********************-->
    <node-structure name="SimpleNameSyntax" parent="NameSyntax" abstract="true">
      <description>
        Abstract node class that represents a name, possibly
        include generic arguments.
      </description>
      <lm-equiv name="NameNode"></lm-equiv>
      <native-equiv name="Name"></native-equiv>

      <child name="Identifier" kind="IdentifierToken">
        <description>The identifier in the name.</description>
        <native-equiv name="ID" />
      </child>
    </node-structure>

    <!--********************
      -  IdentifierName
      **********************-->
    <node-structure name="IdentifierNameSyntax" parent="SimpleNameSyntax">
      <description>Represents a type name consisting of a single identifier (which might include brackets or a type character).</description>
      <lm-equiv name="IdentifierNode">The ? modifier (IsNullable) is no longer present on Identifiers. It moves to declarators and types.</lm-equiv>
      <lm-equiv name="NamedTypeNode"></lm-equiv>
      <native-equiv name="SimpleName">The ? modifier (IsNullable) is no longer present on Identifiers. It moves to declarators and types.</native-equiv>
      <native-equiv name="IdentifierDescriptor">The ? modifier (IsNullable) is no longer present on Identifiers. It moves to declarators and types.</native-equiv>
      <native-equiv name="NamedType"></native-equiv>

      <node-kind name="IdentifierName">
        <lm-equiv name="Identifier" />
        <native-equiv name="Name.Opcodes.Simple" />
      </node-kind>

    </node-structure>

    <!--********************
      -  GenericName
      **********************-->
    <node-structure name="GenericNameSyntax" parent="SimpleNameSyntax">
      <description>Represents a simple type name with one or more generic arguments, such as "X(Of Y, Z).</description>
      <lm-equiv name="GenericNameNode"></lm-equiv>
      <lm-equiv name="NamedTypeNode"></lm-equiv>
      <native-equiv name="SimpleWithArgumentsName"></native-equiv>
      <native-equiv name="NamedType"></native-equiv>

      <node-kind name="GenericName">
        <lm-equiv name="GenericName" />
        <native-equiv name="Name.Opcodes.SimpleWithArguments" />
      </node-kind>

      <child name="TypeArgumentList" kind="TypeArgumentList">
        <description>The generic argument list.</description>
        <lm-equiv name="Arguments"></lm-equiv>
        <native-equiv name="Arguments"></native-equiv>
      </child>
    </node-structure>

    <!--********************
      -  QualifiedName
      **********************-->
    <node-structure name="QualifiedNameSyntax" parent="NameSyntax">
      <description>Represents a qualified type name, for example X.Y or X(Of Z).Y.</description>
      <lm-equiv name="QualifiedNameNode"></lm-equiv>
      <lm-equiv name="NamedTypeNode"></lm-equiv>
      <native-equiv name="QualifiedName"></native-equiv>
      <native-equiv name="NamedType"></native-equiv>

      <node-kind name="QualifiedName">
        <lm-equiv name="QualifiedName" />
        <native-equiv name="Name.Opcodes.Qualified" />
      </node-kind>

      <child name="Left" kind="@NameSyntax">
        <description>
          The part of the name that appears to the left of the dot. This can itself
          be any name.
        </description>
        <lm-equiv name="Base"></lm-equiv>
        <native-equiv name="Base"></native-equiv>
      </child>

      <child name="DotToken" kind="DotToken">
        <description>The "." token that separates the names.</description>
        <lm-equiv name="Dot"></lm-equiv>
        <native-equiv name="Dot"></native-equiv>
      </child>

      <child name="Right" kind="@SimpleNameSyntax">
        <description>
          The part of the name that appears to the right of the dot. This must be
          a simple identifier.
        </description>
        <lm-equiv name="Name"></lm-equiv>
        <native-equiv name="Qualifier"></native-equiv>
      </child>
    </node-structure>


    <!--********************
      -  GlobalName
      **********************-->
    <node-structure name="GlobalNameSyntax" parent="NameSyntax">
      <description>Represents a name in the global namespace.</description>
      <lm-equiv name="GlobalNamespaceNode"></lm-equiv>
      <native-equiv name="Name"></native-equiv>

      <node-kind name="GlobalName">
        <lm-equiv name="GlobalNamespace" />
        <native-equiv name="Name.Opcodes.GlobalNameSpace" />
      </node-kind>

      <child name="GlobalKeyword" kind="GlobalKeyword">
        <description>The "Global" keyword.</description>
        <lm-equiv name="GlobalKeyword"></lm-equiv>
        <native-equiv name=""></native-equiv>
      </child>
    </node-structure>

    <!--********************
      -  GenericArguments
      **********************-->
    <node-structure name="TypeArgumentListSyntax" parent="VisualBasicSyntaxNode">
      <description>Represents a parenthesized list of generic type arguments.</description>
      <lm-equiv name=""></lm-equiv>
      <native-equiv name=""></native-equiv>

      <node-kind name="TypeArgumentList" />

      <child name="OpenParenToken" kind="OpenParenToken">
        <description>The "(" token.</description>
        <lm-equiv name="LeftParenthesis"></lm-equiv>
        <native-equiv name="LeftParen"></native-equiv>
      </child>
      <child name="OfKeyword" kind="OfKeyword">
        <description>The "Of" keyword.</description>
        <lm-equiv name="OfKeyword"></lm-equiv>
        <native-equiv name=""></native-equiv>
      </child>
      <child name="Arguments" list="true" separator-kind="CommaToken" separator-name="CommaTokens" kind="@TypeSyntax" min-count="1">
        <description>A list of all the type arguments.</description>
        <lm-equiv name="Arguments"></lm-equiv>
        <native-equiv name="Arguments"></native-equiv>
      </child>
      <child name="CloseParenToken" kind="CloseParenToken">
        <description>The ")" token.</description>
        <lm-equiv name="RightParenthesis"></lm-equiv>
        <native-equiv name="RightParen"></native-equiv>
      </child>
    </node-structure>

    <!-- ************************************************************************************************** -->
    <!-- **  CREF reference syntax                                                                       ** -->
    <!-- ************************************************************************************************** -->

    <node-structure name="CrefReferenceSyntax" parent="VisualBasicSyntaxNode">
      <description>
        Syntax node class that represents a value of 'cref' attribute
        inside documentation comment trivia.
      </description>

      <node-kind name="CrefReference" />

      <!-- 
        General form is:
            [mandatory] TypeSyntax      /// note that name may be CrefOperatorReferenceSyntax or
                                        /// QualifiedCrefNameSyntax like:
                                        ///    A.B(Of T).Operator+
                                        ///    Operator CType
                                        
            [ optional] Signature       /// Signature in format '([TypeA{,... TypeB...}])'
            
            [ optional] AsClause        /// As clause with CType returning type
      -->

      <child name="Name" optional="false" kind="@TypeSyntax"/>
      <child name="Signature" optional="true" kind="CrefSignature"/>
      <child name="AsClause" optional="true" kind="SimpleAsClause"/>
    </node-structure>

    <node-structure name="CrefSignatureSyntax" parent="VisualBasicSyntaxNode">
      <description>
        Represents a parenthesized list of argument types for a signature inside CrefReferenceSyntax syntax.
      </description>

      <node-kind name="CrefSignature" />

      <child name="OpenParenToken" kind="OpenParenToken"/>
      <child name="ArgumentTypes" list="true" separator-kind="CommaToken" separator-name="CommaTokens" kind="CrefSignaturePart"/>
      <child name="CloseParenToken" kind="CloseParenToken"/>
    </node-structure>

    <node-structure name="CrefSignaturePartSyntax" parent="VisualBasicSyntaxNode">
      <node-kind name="CrefSignaturePart" />

      <child name="Modifier" optional="true" kind="ByValKeyword|ByRefKeyword"/>
      <child name="Type" optional="true" kind="@TypeSyntax"/>
    </node-structure>

    <node-structure name="CrefOperatorReferenceSyntax" parent="NameSyntax">
      <node-kind name="CrefOperatorReference" />

      <child name="OperatorKeyword" kind="OperatorKeyword" order="10"/>
      <child name="OperatorToken" kind="CTypeKeyword|IsTrueKeyword|IsFalseKeyword|NotKeyword|PlusToken|MinusToken|AsteriskToken|SlashToken|CaretToken|BackslashToken|AmpersandToken|LessThanLessThanToken|GreaterThanGreaterThanToken|ModKeyword|OrKeyword|XorKeyword|AndKeyword|LikeKeyword|EqualsToken|LessThanGreaterThanToken|LessThanToken|LessThanEqualsToken|GreaterThanEqualsToken|GreaterThanToken" order="20" />
    </node-structure>

    <node-structure name="QualifiedCrefOperatorReferenceSyntax" parent="NameSyntax">
      <node-kind name="QualifiedCrefOperatorReference" />
      <child name="Left" kind="@NameSyntax" />
      <child name="DotToken" kind="DotToken" />
      <child name="Right" kind="CrefOperatorReference" />
    </node-structure>

    <!-- ************************************************************************************************** -->
    <!-- **  Visual Basic 11.0 Syntax                                                                    ** -->
    <!-- ************************************************************************************************** -->

    <!--****************
      -  YieldStatement
      ******************-->
    <node-structure name="YieldStatementSyntax" parent="ExecutableStatementSyntax">
      <description>Represent a Yield statement.</description>
      <lm-equiv name="YieldStatementNode"></lm-equiv>
      <native-equiv name="YieldStatement"></native-equiv>

      <node-kind name="YieldStatement">
        <lm-equiv name="YieldStatement" />
        <native-equiv name="Statement.Opcodes.Yield" />
      </node-kind>

      <child name="YieldKeyword" kind="YieldKeyword">
        <description>The "Yield" keyword.</description>
        <lm-equiv name="YieldKeyword"></lm-equiv>
      </child>

      <child name="Expression" kind="@ExpressionSyntax">
        <description>
          The expression whose value is being yielded.
        </description>
      </child>
    </node-structure>

    <!--****************
      -  AwaitExpression
      ******************-->
    <node-structure name="AwaitExpressionSyntax" parent="ExpressionSyntax">
      <description>Represents an Await expression.</description>
      <lm-equiv name="AwaitExpressionNode"></lm-equiv>
      <native-equiv name="AwaitExpression"></native-equiv>

      <node-kind name="AwaitExpression">
        <lm-equiv name="AwaitExpression" />
        <native-equiv name="Expression.Opcodes.Await" />
      </node-kind>

      <child name="AwaitKeyword" kind="AwaitKeyword">
        <description>The "Await" keyword.</description>
        <lm-equiv name="AwaitKeyword"></lm-equiv>
      </child>

      <child name="Expression" kind="@ExpressionSyntax">
        <description>
          The expression being awaited.
        </description>
      </child>
    </node-structure>

    <!-- ************************************************************************************************** -->
    <!-- **  TOKENS                                                                                      ** -->
    <!-- ************************************************************************************************** -->

    <!--********************
      -  Token
      **********************-->
    <node-structure name="SyntaxToken" token-root="true" abstract="true" parent="VisualBasicSyntaxNode">
      <description>
        Represents a single syntactic token in a VB program. A token is a
        keyword, punctuator, literal, identifier or XML token. The type of keyword or
        punctuator can be determined from the Kind property.
      </description>
      <lm-equiv name="VbToken"></lm-equiv>
      <native-equiv name="PunctuatorLocation"></native-equiv>
    </node-structure>

    <!--********************
      -  Keyword
      **********************-->
    <node-structure name="KeywordSyntax" parent="SyntaxToken" default-trailing-trivia="space" has-default-factory="true">
      <description>
        Represents a single keyword in a VB program. Which keyword can be determined from the Kind property.
      </description>
      <lm-equiv name="VbToken"></lm-equiv>
      <native-equiv name="PunctuatorLocation"></native-equiv>

      <node-kind name="AddHandlerKeyword" token-text="AddHandler">
        <lm-equiv name="AddHandlerKeyword" />
        <native-equiv name="" />
      </node-kind>
      <node-kind name="AddressOfKeyword" token-text="AddressOf">
        <lm-equiv name="AddressOfKeyword" />
        <native-equiv name="" />
      </node-kind>
      <node-kind name="AliasKeyword" token-text="Alias">
        <lm-equiv name="AliasKeyword" />
        <native-equiv name="" />
      </node-kind>
      <node-kind name="AndKeyword" token-text="And">
        <lm-equiv name="AndKeyword" />
        <native-equiv name="" />
      </node-kind>
      <node-kind name="AndAlsoKeyword" token-text="AndAlso">
        <lm-equiv name="AndAlsoKeyword" />
        <native-equiv name="" />
      </node-kind>
      <node-kind name="AsKeyword" token-text="As">
        <lm-equiv name="AsKeyword" />
        <native-equiv name="" />
      </node-kind>
      <node-kind name="BooleanKeyword" token-text="Boolean">
        <lm-equiv name="BooleanKeyword" />
        <native-equiv name="" />
      </node-kind>
      <node-kind name="ByRefKeyword" token-text="ByRef">
        <lm-equiv name="ByRefKeyword" />
        <native-equiv name="" />
      </node-kind>
      <node-kind name="ByteKeyword" token-text="Byte">
        <lm-equiv name="ByteKeyword" />
        <native-equiv name="" />
      </node-kind>
      <node-kind name="ByValKeyword" token-text="ByVal">
        <lm-equiv name="ByValKeyword" />
        <native-equiv name="" />
      </node-kind>
      <node-kind name="CallKeyword" token-text="Call">
        <lm-equiv name="CallKeyword" />
        <native-equiv name="" />
      </node-kind>
      <node-kind name="CaseKeyword" token-text="Case">
        <lm-equiv name="CaseKeyword" />
        <native-equiv name="" />
      </node-kind>
      <node-kind name="CatchKeyword" token-text="Catch">
        <lm-equiv name="CatchKeyword" />
        <native-equiv name="" />
      </node-kind>
      <node-kind name="CBoolKeyword" token-text="CBool">
        <lm-equiv name="CBoolKeyword" />
        <native-equiv name="" />
      </node-kind>
      <node-kind name="CByteKeyword" token-text="CByte">
        <lm-equiv name="CByteKeyword" />
        <native-equiv name="" />
      </node-kind>
      <node-kind name="CCharKeyword" token-text="CChar">
        <lm-equiv name="CCharKeyword" />
        <native-equiv name="" />
      </node-kind>
      <node-kind name="CDateKeyword" token-text="CDate">
        <lm-equiv name="CDateKeyword" />
        <native-equiv name="" />
      </node-kind>
      <node-kind name="CDecKeyword" token-text="CDec">
        <lm-equiv name="CDecKeyword" />
        <native-equiv name="" />
      </node-kind>
      <node-kind name="CDblKeyword" token-text="CDbl">
        <lm-equiv name="CDblKeyword" />
        <native-equiv name="" />
      </node-kind>
      <node-kind name="CharKeyword" token-text="Char">
        <lm-equiv name="CharKeyword" />
        <native-equiv name="" />
      </node-kind>
      <node-kind name="CIntKeyword" token-text="CInt">
        <lm-equiv name="CIntKeyword" />
        <native-equiv name="" />
      </node-kind>
      <node-kind name="ClassKeyword" token-text="Class">
        <lm-equiv name="ClassKeyword" />
        <native-equiv name="" />
      </node-kind>
      <node-kind name="CLngKeyword" token-text="CLng">
        <lm-equiv name="CLngKeyword" />
        <native-equiv name="" />
      </node-kind>
      <node-kind name="CObjKeyword" token-text="CObj">
        <lm-equiv name="CObjKeyword" />
        <native-equiv name="" />
      </node-kind>
      <node-kind name="ConstKeyword" token-text="Const">
        <lm-equiv name="ConstKeyword" />
        <native-equiv name="" />
      </node-kind>
      <node-kind name="ReferenceKeyword" token-text="R">
        <lm-equiv name="ReferenceKeyword" />
        <native-equiv name="" />
      </node-kind>
      <node-kind name="ContinueKeyword" token-text="Continue">
        <lm-equiv name="ContinueKeyword" />
        <native-equiv name="" />
      </node-kind>
      <node-kind name="CSByteKeyword" token-text="CSByte">
        <lm-equiv name="CSByteKeyword" />
        <native-equiv name="" />
      </node-kind>
      <node-kind name="CShortKeyword" token-text="CShort">
        <lm-equiv name="CShortKeyword" />
        <native-equiv name="" />
      </node-kind>
      <node-kind name="CSngKeyword" token-text="CSng">
        <lm-equiv name="CSngKeyword" />
        <native-equiv name="" />
      </node-kind>
      <node-kind name="CStrKeyword" token-text="CStr">
        <lm-equiv name="CStrKeyword" />
        <native-equiv name="" />
      </node-kind>
      <node-kind name="CTypeKeyword" token-text="CType">
        <lm-equiv name="CTypeKeyword" />
        <native-equiv name="" />
      </node-kind>
      <node-kind name="CUIntKeyword" token-text="CUInt">
        <lm-equiv name="CUIntKeyword" />
        <native-equiv name="" />
      </node-kind>
      <node-kind name="CULngKeyword" token-text="CULng">
        <lm-equiv name="CULngKeyword" />
        <native-equiv name="" />
      </node-kind>
      <node-kind name="CUShortKeyword" token-text="CUShort">
        <lm-equiv name="CUShortKeyword" />
        <native-equiv name="" />
      </node-kind>
      <node-kind name="DateKeyword" token-text="Date">
        <lm-equiv name="DateKeyword" />
        <native-equiv name="" />
      </node-kind>
      <node-kind name="DecimalKeyword" token-text="Decimal">
        <lm-equiv name="DecimalKeyword" />
        <native-equiv name="" />
      </node-kind>
      <node-kind name="DeclareKeyword" token-text="Declare">
        <lm-equiv name="DeclareKeyword" />
        <native-equiv name="" />
      </node-kind>
      <node-kind name="DefaultKeyword" token-text="Default">
        <lm-equiv name="DefaultKeyword" />
        <native-equiv name="" />
      </node-kind>
      <node-kind name="DelegateKeyword" token-text="Delegate">
        <lm-equiv name="DelegateKeyword" />
        <native-equiv name="" />
      </node-kind>
      <node-kind name="DimKeyword" token-text="Dim">
        <lm-equiv name="DimKeyword" />
        <native-equiv name="" />
      </node-kind>
      <node-kind name="DirectCastKeyword" token-text="DirectCast">
        <lm-equiv name="DirectCastKeyword" />
        <native-equiv name="" />
      </node-kind>
      <node-kind name="DoKeyword" token-text="Do">
        <lm-equiv name="DoKeyword" />
        <native-equiv name="" />
      </node-kind>
      <node-kind name="DoubleKeyword" token-text="Double">
        <lm-equiv name="DoubleKeyword" />
        <native-equiv name="" />
      </node-kind>
      <node-kind name="EachKeyword" token-text="Each">
        <lm-equiv name="EachKeyword" />
        <native-equiv name="" />
      </node-kind>
      <node-kind name="ElseKeyword" token-text="Else">
        <lm-equiv name="ElseKeyword" />
        <native-equiv name="" />
      </node-kind>
      <node-kind name="ElseIfKeyword" token-text="ElseIf">
        <lm-equiv name="ElseIfKeyword" />
        <native-equiv name="" />
      </node-kind>
      <node-kind name="EndKeyword" token-text="End">
        <lm-equiv name="EndKeyword" />
        <native-equiv name="" />
      </node-kind>
      <node-kind name="EnumKeyword" token-text="Enum">
        <lm-equiv name="EnumKeyword" />
        <native-equiv name="" />
      </node-kind>
      <node-kind name="EraseKeyword" token-text="Erase">
        <lm-equiv name="EraseKeyword" />
        <native-equiv name="" />
      </node-kind>
      <node-kind name="ErrorKeyword" token-text="Error">
        <lm-equiv name="ErrorKeyword" />
        <native-equiv name="" />
      </node-kind>
      <node-kind name="EventKeyword" token-text="Event">
        <lm-equiv name="EventKeyword" />
        <native-equiv name="" />
      </node-kind>
      <node-kind name="ExitKeyword" token-text="Exit">
        <lm-equiv name="ExitKeyword" />
        <native-equiv name="" />
      </node-kind>
      <node-kind name="FalseKeyword" token-text="False">
        <lm-equiv name="FalseKeyword" />
        <native-equiv name="" />
      </node-kind>
      <node-kind name="FinallyKeyword" token-text="Finally">
        <lm-equiv name="FinallyKeyword" />
        <native-equiv name="" />
      </node-kind>
      <node-kind name="ForKeyword" token-text="For">
        <lm-equiv name="ForKeyword" />
        <native-equiv name="" />
      </node-kind>
      <node-kind name="FriendKeyword" token-text="Friend">
        <lm-equiv name="FriendKeyword" />
        <native-equiv name="" />
      </node-kind>
      <node-kind name="FunctionKeyword" token-text="Function">
        <lm-equiv name="FunctionKeyword" />
        <native-equiv name="" />
      </node-kind>
      <node-kind name="GetKeyword" token-text="Get">
        <lm-equiv name="GetKeyword" />
        <native-equiv name="" />
      </node-kind>
      <node-kind name="GetTypeKeyword" token-text="GetType">
        <lm-equiv name="GetTypeKeyword" />
        <native-equiv name="" />
      </node-kind>
      <node-kind name="GetXmlNamespaceKeyword" token-text="GetXmlNamespace">
        <lm-equiv name="GetXmlNamespaceKeyword" />
        <native-equiv name="" />
      </node-kind>
      <node-kind name="GlobalKeyword" token-text="Global">
        <lm-equiv name="GlobalKeyword" />
        <native-equiv name="" />
      </node-kind>
      <node-kind name="GoToKeyword" token-text="GoTo">
        <lm-equiv name="GoToKeyword" />
        <native-equiv name="" />
      </node-kind>
      <node-kind name="HandlesKeyword" token-text="Handles">
        <lm-equiv name="HandlesKeyword" />
        <native-equiv name="" />
      </node-kind>
      <node-kind name="IfKeyword" token-text="If">
        <lm-equiv name="IfKeyword" />
        <native-equiv name="" />
      </node-kind>
      <node-kind name="ImplementsKeyword" token-text="Implements">
        <lm-equiv name="ImplementsKeyword" />
        <native-equiv name="" />
      </node-kind>
      <node-kind name="ImportsKeyword" token-text="Imports">
        <lm-equiv name="ImportsKeyword" />
        <native-equiv name="" />
      </node-kind>
      <node-kind name="InKeyword" token-text="In">
        <lm-equiv name="InKeyword" />
        <native-equiv name="" />
      </node-kind>
      <node-kind name="InheritsKeyword" token-text="Inherits">
        <lm-equiv name="InheritsKeyword" />
        <native-equiv name="" />
      </node-kind>
      <node-kind name="IntegerKeyword" token-text="Integer">
        <lm-equiv name="IntegerKeyword" />
        <native-equiv name="" />
      </node-kind>
      <node-kind name="InterfaceKeyword" token-text="Interface">
        <lm-equiv name="InterfaceKeyword" />
        <native-equiv name="" />
      </node-kind>
      <node-kind name="IsKeyword" token-text="Is">
        <lm-equiv name="IsKeyword" />
        <native-equiv name="" />
      </node-kind>
      <node-kind name="IsNotKeyword" token-text="IsNot">
        <lm-equiv name="IsNotKeyword" />
        <native-equiv name="" />
      </node-kind>
      <node-kind name="LetKeyword" token-text="Let">
        <lm-equiv name="LetKeyword" />
        <native-equiv name="" />
      </node-kind>
      <node-kind name="LibKeyword" token-text="Lib">
        <lm-equiv name="LibKeyword" />
        <native-equiv name="" />
      </node-kind>
      <node-kind name="LikeKeyword" token-text="Like">
        <lm-equiv name="LikeKeyword" />
        <native-equiv name="" />
      </node-kind>
      <node-kind name="LongKeyword" token-text="Long">
        <lm-equiv name="LongKeyword" />
        <native-equiv name="" />
      </node-kind>
      <node-kind name="LoopKeyword" token-text="Loop">
        <lm-equiv name="LoopKeyword" />
        <native-equiv name="" />
      </node-kind>
      <node-kind name="MeKeyword" token-text="Me">
        <lm-equiv name="MeKeyword" />
        <native-equiv name="" />
      </node-kind>
      <node-kind name="ModKeyword" token-text="Mod">
        <lm-equiv name="ModKeyword" />
        <native-equiv name="" />
      </node-kind>
      <node-kind name="ModuleKeyword" token-text="Module">
        <lm-equiv name="ModuleKeyword" />
        <native-equiv name="" />
      </node-kind>
      <node-kind name="MustInheritKeyword" token-text="MustInherit">
        <lm-equiv name="MustInheritKeyword" />
        <native-equiv name="" />
      </node-kind>
      <node-kind name="MustOverrideKeyword" token-text="MustOverride">
        <lm-equiv name="MustOverrideKeyword" />
        <native-equiv name="" />
      </node-kind>
      <node-kind name="MyBaseKeyword" token-text="MyBase">
        <lm-equiv name="MyBaseKeyword" />
        <native-equiv name="" />
      </node-kind>
      <node-kind name="MyClassKeyword" token-text="MyClass">
        <lm-equiv name="MyClassKeyword" />
        <native-equiv name="" />
      </node-kind>
      <node-kind name="NameOfKeyword" token-text="NameOf">
      </node-kind>
      <node-kind name="NamespaceKeyword" token-text="Namespace">
        <lm-equiv name="NamespaceKeyword" />
        <native-equiv name="" />
      </node-kind>
      <node-kind name="NarrowingKeyword" token-text="Narrowing">
        <lm-equiv name="NarrowingKeyword" />
        <native-equiv name="" />
      </node-kind>
      <node-kind name="NextKeyword" token-text="Next">
        <lm-equiv name="NextKeyword" />
        <native-equiv name="" />
      </node-kind>
      <node-kind name="NewKeyword" token-text="New">
        <lm-equiv name="NewKeyword" />
        <native-equiv name="" />
      </node-kind>
      <node-kind name="NotKeyword" token-text="Not">
        <lm-equiv name="NotKeyword" />
        <native-equiv name="" />
      </node-kind>
      <node-kind name="NothingKeyword" token-text="Nothing">
        <lm-equiv name="NothingKeyword" />
        <native-equiv name="" />
      </node-kind>
      <node-kind name="NotInheritableKeyword" token-text="NotInheritable">
        <lm-equiv name="NotInheritableKeyword" />
        <native-equiv name="" />
      </node-kind>
      <node-kind name="NotOverridableKeyword" token-text="NotOverridable">
        <lm-equiv name="NotOverridableKeyword" />
        <native-equiv name="" />
      </node-kind>
      <node-kind name="ObjectKeyword" token-text="Object">
        <lm-equiv name="ObjectKeyword" />
        <native-equiv name="" />
      </node-kind>
      <node-kind name="OfKeyword" token-text="Of">
        <lm-equiv name="OfKeyword" />
        <native-equiv name="" />
      </node-kind>
      <node-kind name="OnKeyword" token-text="On">
        <lm-equiv name="OnKeyword" />
        <native-equiv name="" />
      </node-kind>
      <node-kind name="OperatorKeyword" token-text="Operator">
        <lm-equiv name="OperatorKeyword" />
        <native-equiv name="" />
      </node-kind>
      <node-kind name="OptionKeyword" token-text="Option">
        <lm-equiv name="OptionKeyword" />
        <native-equiv name="" />
      </node-kind>
      <node-kind name="OptionalKeyword" token-text="Optional">
        <lm-equiv name="OptionalKeyword" />
        <native-equiv name="" />
      </node-kind>
      <node-kind name="OrKeyword" token-text="Or">
        <lm-equiv name="OrKeyword" />
        <native-equiv name="" />
      </node-kind>
      <node-kind name="OrElseKeyword" token-text="OrElse">
        <lm-equiv name="OrElseKeyword" />
        <native-equiv name="" />
      </node-kind>
      <node-kind name="OverloadsKeyword" token-text="Overloads">
        <lm-equiv name="OverloadsKeyword" />
        <native-equiv name="" />
      </node-kind>
      <node-kind name="OverridableKeyword" token-text="Overridable">
        <lm-equiv name="OverridableKeyword" />
        <native-equiv name="" />
      </node-kind>
      <node-kind name="OverridesKeyword" token-text="Overrides">
        <lm-equiv name="OverridesKeyword" />
        <native-equiv name="" />
      </node-kind>
      <node-kind name="ParamArrayKeyword" token-text="ParamArray">
        <lm-equiv name="ParamArrayKeyword" />
        <native-equiv name="" />
      </node-kind>
      <node-kind name="PartialKeyword" token-text="Partial">
        <lm-equiv name="PartialKeyword" />
        <native-equiv name="" />
      </node-kind>
      <node-kind name="PrivateKeyword" token-text="Private">
        <lm-equiv name="PrivateKeyword" />
        <native-equiv name="" />
      </node-kind>
      <node-kind name="PropertyKeyword" token-text="Property">
        <lm-equiv name="PropertyKeyword" />
        <native-equiv name="" />
      </node-kind>
      <node-kind name="ProtectedKeyword" token-text="Protected">
        <lm-equiv name="ProtectedKeyword" />
        <native-equiv name="" />
      </node-kind>
      <node-kind name="PublicKeyword" token-text="Public">
        <lm-equiv name="PublicKeyword" />
        <native-equiv name="" />
      </node-kind>
      <node-kind name="RaiseEventKeyword" token-text="RaiseEvent">
        <lm-equiv name="RaiseEventKeyword" />
        <native-equiv name="" />
      </node-kind>
      <node-kind name="ReadOnlyKeyword" token-text="ReadOnly">
        <lm-equiv name="ReadOnlyKeyword" />
        <native-equiv name="" />
      </node-kind>
      <node-kind name="ReDimKeyword" token-text="ReDim">
        <lm-equiv name="ReDimKeyword" />
        <native-equiv name="" />
      </node-kind>
      <node-kind name="REMKeyword" token-text="REM">
        <lm-equiv name="REMKeyword" />
        <native-equiv name="" />
      </node-kind>
      <node-kind name="RemoveHandlerKeyword" token-text="RemoveHandler">
        <lm-equiv name="RemoveHandlerKeyword" />
        <native-equiv name="" />
      </node-kind>
      <node-kind name="ResumeKeyword" token-text="Resume">
        <lm-equiv name="ResumeKeyword" />
        <native-equiv name="" />
      </node-kind>
      <node-kind name="ReturnKeyword" token-text="Return">
        <lm-equiv name="ReturnKeyword" />
        <native-equiv name="" />
      </node-kind>
      <node-kind name="SByteKeyword" token-text="SByte">
        <lm-equiv name="SByteKeyword" />
        <native-equiv name="" />
      </node-kind>
      <node-kind name="SelectKeyword" token-text="Select">
        <lm-equiv name="SelectKeyword" />
        <native-equiv name="" />
      </node-kind>
      <node-kind name="SetKeyword" token-text="Set">
        <lm-equiv name="SetKeyword" />
        <native-equiv name="" />
      </node-kind>
      <node-kind name="ShadowsKeyword" token-text="Shadows">
        <lm-equiv name="ShadowsKeyword" />
        <native-equiv name="" />
      </node-kind>
      <node-kind name="SharedKeyword" token-text="Shared">
        <lm-equiv name="SharedKeyword" />
        <native-equiv name="" />
      </node-kind>
      <node-kind name="ShortKeyword" token-text="Short">
        <lm-equiv name="ShortKeyword" />
        <native-equiv name="" />
      </node-kind>
      <node-kind name="SingleKeyword" token-text="Single">
        <lm-equiv name="SingleKeyword" />
        <native-equiv name="" />
      </node-kind>
      <node-kind name="StaticKeyword" token-text="Static">
        <lm-equiv name="StaticKeyword" />
        <native-equiv name="" />
      </node-kind>
      <node-kind name="StepKeyword" token-text="Step">
        <lm-equiv name="StepKeyword" />
        <native-equiv name="" />
      </node-kind>
      <node-kind name="StopKeyword" token-text="Stop">
        <lm-equiv name="StopKeyword" />
        <native-equiv name="" />
      </node-kind>
      <node-kind name="StringKeyword" token-text="String">
        <lm-equiv name="StringKeyword" />
        <native-equiv name="" />
      </node-kind>
      <node-kind name="StructureKeyword" token-text="Structure">
        <lm-equiv name="StructureKeyword" />
        <native-equiv name="" />
      </node-kind>
      <node-kind name="SubKeyword" token-text="Sub">
        <lm-equiv name="SubKeyword" />
        <native-equiv name="" />
      </node-kind>
      <node-kind name="SyncLockKeyword" token-text="SyncLock">
        <lm-equiv name="SyncLockKeyword" />
        <native-equiv name="" />
      </node-kind>
      <node-kind name="ThenKeyword" token-text="Then">
        <lm-equiv name="ThenKeyword" />
        <native-equiv name="" />
      </node-kind>
      <node-kind name="ThrowKeyword" token-text="Throw">
        <lm-equiv name="ThrowKeyword" />
        <native-equiv name="" />
      </node-kind>
      <node-kind name="ToKeyword" token-text="To">
        <lm-equiv name="ToKeyword" />
        <native-equiv name="" />
      </node-kind>
      <node-kind name="TrueKeyword" token-text="True">
        <lm-equiv name="TrueKeyword" />
        <native-equiv name="" />
      </node-kind>
      <node-kind name="TryKeyword" token-text="Try">
        <lm-equiv name="TryKeyword" />
        <native-equiv name="" />
      </node-kind>
      <node-kind name="TryCastKeyword" token-text="TryCast">
        <lm-equiv name="TryCastKeyword" />
        <native-equiv name="" />
      </node-kind>
      <node-kind name="TypeOfKeyword" token-text="TypeOf">
        <lm-equiv name="TypeOfKeyword" />
        <native-equiv name="" />
      </node-kind>
      <node-kind name="UIntegerKeyword" token-text="UInteger">
        <lm-equiv name="UIntegerKeyword" />
        <native-equiv name="" />
      </node-kind>
      <node-kind name="ULongKeyword" token-text="ULong">
        <lm-equiv name="ULongKeyword" />
        <native-equiv name="" />
      </node-kind>
      <node-kind name="UShortKeyword" token-text="UShort">
        <lm-equiv name="UShortKeyword" />
        <native-equiv name="" />
      </node-kind>
      <node-kind name="UsingKeyword" token-text="Using">
        <lm-equiv name="UsingKeyword" />
        <native-equiv name="" />
      </node-kind>
      <node-kind name="WhenKeyword" token-text="When">
        <lm-equiv name="WhenKeyword" />
        <native-equiv name="" />
      </node-kind>
      <node-kind name="WhileKeyword" token-text="While">
        <lm-equiv name="WhileKeyword" />
        <native-equiv name="" />
      </node-kind>
      <node-kind name="WideningKeyword" token-text="Widening">
        <lm-equiv name="WideningKeyword" />
        <native-equiv name="" />
      </node-kind>
      <node-kind name="WithKeyword" token-text="With">
        <lm-equiv name="WithKeyword" />
        <native-equiv name="" />
      </node-kind>
      <node-kind name="WithEventsKeyword" token-text="WithEvents">
        <lm-equiv name="WithEventsKeyword" />
        <native-equiv name="" />
      </node-kind>
      <node-kind name="WriteOnlyKeyword" token-text="WriteOnly">
        <lm-equiv name="WriteOnlyKeyword" />
        <native-equiv name="" />
      </node-kind>
      <node-kind name="XorKeyword" token-text="Xor">
        <lm-equiv name="XorKeyword" />
        <native-equiv name="" />
      </node-kind>
      <!-- Obsolete Keywords -->
      <node-kind name="EndIfKeyword" token-text="EndIf">
        <lm-equiv name="EndIfKeyword" />
        <native-equiv name="" />
      </node-kind>
      <node-kind name="GosubKeyword" token-text="Gosub">
        <lm-equiv name="GosubKeyword" />
        <native-equiv name="" />
      </node-kind>
      <node-kind name="VariantKeyword" token-text="Variant">
        <lm-equiv name="VariantKeyword" />
        <native-equiv name="" />
      </node-kind>
      <node-kind name="WendKeyword" token-text="Wend">
        <lm-equiv name="WendKeyword" />
        <native-equiv name="" />
      </node-kind>

      <!-- Contextual Keywords -->
      <node-kind name="AggregateKeyword" token-text="Aggregate">
        <lm-equiv name="AggregateKeyword" />
        <native-equiv name="" />
      </node-kind>
      <node-kind name="AllKeyword" token-text="All">
        <lm-equiv name="AllKeyword" />
        <native-equiv name="" />
      </node-kind>
      <node-kind name="AnsiKeyword" token-text="Ansi">
        <lm-equiv name="AnsiKeyword" />
        <native-equiv name="" />
      </node-kind>
      <node-kind name="AscendingKeyword" token-text="Ascending">
        <lm-equiv name="AscendingKeyword" />
        <native-equiv name="" />
      </node-kind>
      <node-kind name="AssemblyKeyword" token-text="Assembly">
        <lm-equiv name="AssemblyKeyword" />
        <native-equiv name="" />
      </node-kind>
      <node-kind name="AutoKeyword" token-text="Auto">
        <lm-equiv name="AutoKeyword" />
        <native-equiv name="" />
      </node-kind>
      <node-kind name="BinaryKeyword" token-text="Binary">
        <lm-equiv name="BinaryKeyword" />
        <native-equiv name="" />
      </node-kind>
      <node-kind name="ByKeyword" token-text="By">
        <lm-equiv name="ByKeyword" />
        <native-equiv name="" />
      </node-kind>
      <node-kind name="CompareKeyword" token-text="Compare">
        <lm-equiv name="CompareKeyword" />
        <native-equiv name="" />
      </node-kind>
      <node-kind name="CustomKeyword" token-text="Custom">
        <lm-equiv name="CustomKeyword" />
        <native-equiv name="" />
      </node-kind>
      <node-kind name="DescendingKeyword" token-text="Descending">
        <lm-equiv name="DescendingKeyword" />
        <native-equiv name="" />
      </node-kind>
      <node-kind name="DisableKeyword" token-text="Disable">
        <lm-equiv name="DisableKeyword" />
        <native-equiv name="" />
      </node-kind>
      <node-kind name="DistinctKeyword" token-text="Distinct">
        <lm-equiv name="DistinctKeyword" />
        <native-equiv name="" />
      </node-kind>
      <node-kind name="EnableKeyword" token-text="Enable">
        <lm-equiv name="EnableKeyword" />
        <native-equiv name="" />
      </node-kind>
      <node-kind name="EqualsKeyword" token-text="Equals">
        <lm-equiv name="EqualsKeyword" />
        <native-equiv name="" />
      </node-kind>
      <node-kind name="ExplicitKeyword" token-text="Explicit">
        <lm-equiv name="ExplicitKeyword" />
        <native-equiv name="" />
      </node-kind>
      <node-kind name="ExternalSourceKeyword" token-text="ExternalSource">
        <lm-equiv name="ExternalSourceKeyword" />
        <native-equiv name="" />
      </node-kind>
      <node-kind name="ExternalChecksumKeyword" token-text="ExternalChecksum">
        <lm-equiv name="ExternalChecksumKeyword" />
        <native-equiv name="" />
      </node-kind>
      <node-kind name="FromKeyword" token-text="From">
        <lm-equiv name="FromKeyword" />
        <native-equiv name="" />
      </node-kind>
      <node-kind name="GroupKeyword" token-text="Group">
        <lm-equiv name="GroupKeyword" />
        <native-equiv name="" />
      </node-kind>
      <node-kind name="InferKeyword" token-text="Infer">
        <lm-equiv name="InferKeyword" />
        <native-equiv name="" />
      </node-kind>
      <node-kind name="IntoKeyword" token-text="Into">
        <lm-equiv name="IntoKeyword" />
        <native-equiv name="" />
      </node-kind>
      <node-kind name="IsFalseKeyword" token-text="IsFalse">
        <lm-equiv name="IsFalseKeyword" />
        <native-equiv name="" />
      </node-kind>
      <node-kind name="IsTrueKeyword" token-text="IsTrue">
        <lm-equiv name="IsTrueKeyword" />
        <native-equiv name="" />
      </node-kind>
      <node-kind name="JoinKeyword" token-text="Join">
        <lm-equiv name="JoinKeyword" />
        <native-equiv name="" />
      </node-kind>
      <node-kind name="KeyKeyword" token-text="Key">
        <lm-equiv name="KeyKeyword" />
        <native-equiv name="" />
      </node-kind>
      <node-kind name="MidKeyword" token-text="Mid">
        <lm-equiv name="MidKeyword" />
        <native-equiv name="" />
      </node-kind>
      <node-kind name="OffKeyword" token-text="Off">
        <lm-equiv name="OffKeyword" />
        <native-equiv name="" />
      </node-kind>
      <node-kind name="OrderKeyword" token-text="Order">
        <lm-equiv name="OrderKeyword" />
        <native-equiv name="" />
      </node-kind>
      <node-kind name="OutKeyword" token-text="Out">
        <lm-equiv name="OutKeyword" />
        <native-equiv name="" />
      </node-kind>
      <node-kind name="PreserveKeyword" token-text="Preserve">
        <lm-equiv name="PreserveKeyword" />
        <native-equiv name="" />
      </node-kind>
      <node-kind name="RegionKeyword" token-text="Region">
        <lm-equiv name="RegionKeyword" />
        <native-equiv name="" />
      </node-kind>
      <node-kind name="SkipKeyword" token-text="Skip">
        <lm-equiv name="SkipKeyword" />
        <native-equiv name="" />
      </node-kind>
      <node-kind name="StrictKeyword" token-text="Strict">
        <lm-equiv name="StrictKeyword" />
        <native-equiv name="" />
      </node-kind>
      <node-kind name="TakeKeyword" token-text="Take">
        <lm-equiv name="TakeKeyword" />
        <native-equiv name="" />
      </node-kind>
      <node-kind name="TextKeyword" token-text="Text">
        <lm-equiv name="TextKeyword" />
        <native-equiv name="" />
      </node-kind>
      <node-kind name="UnicodeKeyword" token-text="Unicode">
        <lm-equiv name="UnicodeKeyword" />
        <native-equiv name="" />
      </node-kind>
      <node-kind name="UntilKeyword" token-text="Until">
        <lm-equiv name="UntilKeyword" />
        <native-equiv name="" />
      </node-kind>
      <node-kind name="WarningKeyword" token-text="Warning">
        <lm-equiv name="WarningKeyword" />
        <native-equiv name="" />
      </node-kind>
      <node-kind name="WhereKeyword" token-text="Where">
        <lm-equiv name="WhereKeyword" />
        <native-equiv name="" />
      </node-kind>

      <!-- Obsolete Type -->
      <node-kind name="TypeKeyword" token-text="Type">
        <lm-equiv name="TypeKeyword" />
        <native-equiv name="" />
      </node-kind>

      <!-- Xml Contextual Keywords -->
      <node-kind name="XmlKeyword" token-text="xml"></node-kind>

      <!-- Visual Basic 11.0 Keywords -->

      <node-kind name="AsyncKeyword" token-text="Async">
        <lm-equiv name="AsyncKeyword" />
        <native-equiv name="" />
      </node-kind>
      <node-kind name="AwaitKeyword" token-text="Await">
        <lm-equiv name="AwaitKeyword" />
        <native-equiv name="" />
      </node-kind>
      <node-kind name="IteratorKeyword" token-text="Iterator">
        <lm-equiv name="IteratorKeyword" />
        <native-equiv name="" />
      </node-kind>
      <node-kind name="YieldKeyword" token-text="Yield">
        <lm-equiv name="YieldKeyword" />
        <native-equiv name="" />
      </node-kind>

    </node-structure>

    <!--********************
      -  Punctuation
      **********************-->
    <node-structure name="PunctuationSyntax" parent="SyntaxToken" default-trailing-trivia="space" has-default-factory="true">
      <description>
        Represents a single punctuation mark or operator in a VB program. Which one can be determined from the Kind property.
      </description>
      <lm-equiv name="VbToken"></lm-equiv>
      <native-equiv name="PunctuatorLocation"></native-equiv>

      <node-kind name="ExclamationToken" token-text="!">
        <lm-equiv name="BangToken" />
        <native-equiv name="" />
      </node-kind>
      <node-kind name="AtToken" token-text="@">
        <lm-equiv name="AtToken" />
        <native-equiv name="" />
      </node-kind>
      <node-kind name="CommaToken" token-text=",">
        <lm-equiv name="CommaToken" />
        <native-equiv name="" />
      </node-kind>
      <node-kind name="HashToken" token-text="#">
        <lm-equiv name="SharpToken" />
        <native-equiv name="" />
      </node-kind>
      <node-kind name="AmpersandToken" token-text="&amp;">
        <lm-equiv name="ConcatToken" />
        <native-equiv name="" />
      </node-kind>
      <node-kind name="SingleQuoteToken" token-text="'">
        <lm-equiv name="SingleQuoteToken" />
        <native-equiv name="" />
      </node-kind>
      <node-kind name="OpenParenToken" token-text="(">
        <lm-equiv name="LeftParenToken" />
        <native-equiv name="" />
      </node-kind>
      <node-kind name="CloseParenToken" token-text=")">
        <lm-equiv name="RightParenToken" />
        <native-equiv name="" />
      </node-kind>
      <node-kind name="OpenBraceToken" token-text="{">
        <lm-equiv name="LeftBraceToken" />
        <native-equiv name="" />
      </node-kind>
      <node-kind name="CloseBraceToken" token-text="}">
        <lm-equiv name="RightBraceToken" />
        <native-equiv name="" />
      </node-kind>
      <node-kind name="SemicolonToken" token-text=";">
        <lm-equiv name="SemicolonToken" />
        <native-equiv name="" />
      </node-kind>
      <node-kind name="AsteriskToken" token-text="*">
        <lm-equiv name="MultiplyToken" />
        <native-equiv name="" />
      </node-kind>
      <node-kind name="PlusToken" token-text="+">
        <lm-equiv name="PlusToken" />
        <native-equiv name="" />
      </node-kind>
      <node-kind name="MinusToken" token-text="-">
        <lm-equiv name="MinusToken" />
        <native-equiv name="" />
      </node-kind>
      <node-kind name="DotToken" token-text=".">
        <lm-equiv name="DotToken" />
        <native-equiv name="" />
      </node-kind>
      <node-kind name="SlashToken" token-text="/">
        <lm-equiv name="DivideToken" />
        <native-equiv name="" />
      </node-kind>
      <node-kind name="ColonToken" token-text=":">
        <lm-equiv name="ColonToken" />
        <native-equiv name="" />
      </node-kind>
      <node-kind name="LessThanToken" token-text="&lt;">
        <lm-equiv name="LessToken" />
        <native-equiv name="" />
      </node-kind>
      <node-kind name="LessThanEqualsToken" token-text="&lt;=">
        <lm-equiv name="LessEqualToken" />
        <native-equiv name="" />
      </node-kind>
      <node-kind name="LessThanGreaterThanToken" token-text="&lt;&gt;">
        <lm-equiv name="NotEqualToken" />
        <native-equiv name="" />
      </node-kind>
      <node-kind name="EqualsToken" token-text="=">
        <lm-equiv name="EqualToken" />
        <native-equiv name="" />
      </node-kind>
      <node-kind name="GreaterThanToken" token-text="&gt;">
        <lm-equiv name="GreaterToken" />
        <native-equiv name="" />
      </node-kind>
      <node-kind name="GreaterThanEqualsToken" token-text="&gt;=">
        <lm-equiv name="GreaterEqualToken" />
        <native-equiv name="" />
      </node-kind>
      <node-kind name="BackslashToken" token-text="\">
        <lm-equiv name="IntegralDivideToken" />
        <native-equiv name="" />
      </node-kind>
      <node-kind name="CaretToken" token-text="^">
        <lm-equiv name="PowerToken" />
        <native-equiv name="" />
      </node-kind>
      <node-kind name="ColonEqualsToken" token-text=":=">
        <lm-equiv name="ColonEqualToken" />
        <native-equiv name="" />
      </node-kind>
      <node-kind name="AmpersandEqualsToken" token-text="&amp;=">
        <lm-equiv name="ConcatEqualToken" />
        <native-equiv name="" />
      </node-kind>
      <node-kind name="AsteriskEqualsToken" token-text="*=">
        <lm-equiv name="MultiplyEqualToken" />
        <native-equiv name="" />
      </node-kind>
      <node-kind name="PlusEqualsToken" token-text="+=">
        <lm-equiv name="PlusEqualToken" />
        <native-equiv name="" />
      </node-kind>
      <node-kind name="MinusEqualsToken" token-text="-=">
        <lm-equiv name="MinusEqualToken" />
        <native-equiv name="" />
      </node-kind>
      <node-kind name="SlashEqualsToken" token-text="/=">
        <lm-equiv name="DivideEqualToken" />
        <native-equiv name="" />
      </node-kind>
      <node-kind name="BackslashEqualsToken" token-text="\=">
        <lm-equiv name="IntegralDivideEqualToken" />
        <native-equiv name="" />
      </node-kind>
      <node-kind name="CaretEqualsToken" token-text="^=">
        <lm-equiv name="PowerEqualToken" />
        <native-equiv name="" />
      </node-kind>
      <node-kind name="LessThanLessThanToken" token-text="&lt;&lt;">
        <lm-equiv name="LeftShiftToken" />
        <native-equiv name="" />
      </node-kind>
      <node-kind name="GreaterThanGreaterThanToken" token-text="&gt;&gt;">
        <lm-equiv name="RightShiftToken" />
        <native-equiv name="" />
      </node-kind>
      <node-kind name="LessThanLessThanEqualsToken" token-text="&lt;&lt;=">
        <lm-equiv name="LeftShiftEqualToken" />
        <native-equiv name="" />
      </node-kind>
      <node-kind name="GreaterThanGreaterThanEqualsToken" token-text="&gt;&gt;=">
        <lm-equiv name="RightShiftEqualToken" />
        <native-equiv name="" />
      </node-kind>
      <node-kind name="QuestionToken" token-text="?">
        <lm-equiv name="QuestionMarkToken" />
        <native-equiv name="" />
      </node-kind>
      <node-kind name="DoubleQuoteToken" token-text="&quot;">
        <lm-equiv name="QuoteToken" />
        <native-equiv name="tkQuote" />
      </node-kind>
      <node-kind name="DollarSignDoubleQuoteToken" token-text="$&quot;"/>
      <node-kind name="EndOfInterpolatedStringToken" token-text=""/>
      <node-kind name="StatementTerminatorToken" token-text="vbCrLf">
        <lm-equiv name="" />
        <native-equiv name="tokens.tkEOL" />
      </node-kind>
      <node-kind name="EndOfFileToken">
        <lm-equiv name="" />
        <native-equiv name="tokens.tkEOF" />
      </node-kind>
      <node-kind name="EmptyToken" token-text="">
      </node-kind>


      <!--********************
      -  Xml specific tokens
      **********************-->
      <node-kind name="SlashGreaterThanToken" token-text="/&gt;">
        <lm-equiv name="XmlEndEmptyElementToken" />
        <native-equiv name="" />
      </node-kind>
      <node-kind name="LessThanSlashToken" token-text="&lt;/">
        <lm-equiv name="XmlBeginEndElementToken" />
        <native-equiv name="" />
      </node-kind>
      <node-kind name="LessThanExclamationMinusMinusToken" token-text="&lt;!--">
        <lm-equiv name="XmlBeginCommentToken" />
        <native-equiv name="" />
      </node-kind>
      <node-kind name="MinusMinusGreaterThanToken" token-text="--&gt;">
        <lm-equiv name="XmlEndCommentToken" />
        <native-equiv name="" />
      </node-kind>
      <node-kind name="LessThanQuestionToken" token-text="&lt;?">
        <lm-equiv name="XmlBeginPIToken" />
        <native-equiv name="" />
      </node-kind>
      <node-kind name="QuestionGreaterThanToken" token-text="?&gt;">
        <lm-equiv name="XmlEndPIToken" />
        <native-equiv name="" />
      </node-kind>
      <node-kind name="LessThanPercentEqualsToken" token-text="&lt;%=">
        <lm-equiv name="XmlBeginEmbeddedToken" />
        <native-equiv name="" />
      </node-kind>
      <node-kind name="PercentGreaterThanToken" token-text="%&gt;">
        <lm-equiv name="XmlEndEmbeddedToken" />
        <native-equiv name="" />
      </node-kind>
      <node-kind name="BeginCDataToken" token-text="&lt;![CDATA[">
        <lm-equiv name="XmlBeginCDataToken" />
        <native-equiv name="" />
      </node-kind>
      <node-kind name="EndCDataToken" token-text="]]&gt;">
        <lm-equiv name="XmlEndCDataToken" />
        <native-equiv name="" />
      </node-kind>
      <node-kind name="EndOfXmlToken" token-text="">
        <lm-equiv name="XmlAbort" />
        <native-equiv name="" />
      </node-kind>
    </node-structure>

    <node-structure name="BadTokenSyntax" parent="PunctuationSyntax" no-factory="true" >
      <description>
        Represents a sequence of characters appearing in source with no possible meaning in the Visual Basic language (e.g. the semicolon ';').
        This token should only appear in SkippedTokenTrivia as an artifact of parsing error recovery.
      </description>
      <node-kind name="BadToken" token-text="">
        <lm-equiv name="" />
        <native-equiv name="" />
      </node-kind>
    </node-structure>

    <!--********************
      -  XmlNameToken
      **********************-->
    <node-structure name="XmlNameTokenSyntax" parent="SyntaxToken">
      <description>Represents an Xml NCName per Namespaces in XML 1.0</description>
      <node-kind name="XmlNameToken"></node-kind>

      <field name="PossibleKeywordKind" type="NodeKind"></field>
    </node-structure>

    <!--********************
      -  XmlTextToken
      **********************-->
    <node-structure name="XmlTextTokenSyntax" parent="SyntaxToken">
      <description>
        Represents character data in Xml content also known as PCData or in an Xml attribute value. All text is here for now
        even text that does not need normalization such as comment, pi and cdata text.
      </description>

      <node-kind name="XmlTextLiteralToken">
        <lm-equiv name="XmlCharDataToken" />
        <native-equiv name="" />
      </node-kind>

      <node-kind name="XmlEntityLiteralToken">
      </node-kind>

      <node-kind name="DocumentationCommentLineBreakToken">
      </node-kind>

      <field name="Value" type="text">
        <description>The text of the attribute or pcdata after normalization.</description>
        <lm-equiv name="Value"></lm-equiv>
        <native-equiv name="Value"></native-equiv>
      </field>
    </node-structure>

    <!--********************
      -  InterpolatedStringTextToken
      **********************-->
    <node-structure name="InterpolatedStringTextTokenSyntax" parent="SyntaxToken">
      <description>
        Represents literal character data in interpolated string expression.
      </description>

      <node-kind name="InterpolatedStringTextToken" />

      <field name="Value" type="text">
        <description>The text.</description>
      </field>
    </node-structure>

    <!--********************
      -  Identifier
      **********************-->
    <node-structure name="IdentifierTokenSyntax" parent="SyntaxToken" default-trailing-trivia="space" no-factory="true">
      <description>Represents an identifier token. This might include brackets around the name and a type character.</description>
      <lm-equiv name="Identifier">
        Identifier in language model maps to either Identifier or SimpleName, depending on the context it
        is used in.
      </lm-equiv>
      <native-equiv name="IdentifierDescriptor"></native-equiv>

      <node-kind name="IdentifierToken">
        <lm-equiv name="Identifier"></lm-equiv>
        <native-equiv name="tokens.tkID"></native-equiv>
      </node-kind>

      <field name="PossibleKeywordKind" type="NodeKind">
        <description>Contextual Nodekind</description>
      </field>

      <field name="IsBracketed" type="boolean">
        <description>If true, the identifier was enclosed in brackets, such as "[End]".</description>
        <lm-equiv name="IsBracketed"></lm-equiv>
        <native-equiv name="IsBracketed"></native-equiv>
      </field>

      <field name="IdentifierText" type="text">
        <description>The text of the identifier, not including the brackets or type character.</description>
        <lm-equiv name="Name"></lm-equiv>
        <native-equiv name="Name"></native-equiv>
      </field>

      <field name="TypeCharacter" type="TypeCharacter">
        <description>
          The type character suffix, if present. Returns TypeCharacter.None if no type character was present. The
          only allowed values are None, Integer, Long, Decimal, Single, Double and String.
        </description>
        <lm-equiv name="TypeCharacter"></lm-equiv>
        <native-equiv name="TypeCharacter"></native-equiv>
      </field>
    </node-structure>


    <!--********************
      -  TypeSuffix
      **********************-->
    <enumeration name="TypeCharacter">
      <description>
        Represents one of the type characters or literal suffixes of VB. Used to describe
        a) the type character suffixes that can be placed on identifiers, and
        b) the suffixes that can be placed on integer literals.
      </description>
      <lm-equiv name="TypeCharacter"></lm-equiv>
      <native-equiv name="typeChars"></native-equiv>
      <native-equiv name="Type.Opcodes"></native-equiv>

      <enumerators>
        <enumerator name="None" />
        <enumerator name="Integer">
          <description>The "%" type character."</description>
        </enumerator>
        <enumerator name="Long">
          <description>The "&amp;" type character."</description>
        </enumerator>
        <enumerator name="Decimal">
          <description>The "@" type character."</description>
        </enumerator>
        <enumerator name="Single">
          <description>The "!" type character."</description>
        </enumerator>
        <enumerator name="Double">
          <description>The "#" type character."</description>
        </enumerator>
        <enumerator name="String">
          <description>The "$" type character."</description>
        </enumerator>

        <enumerator name="ShortLiteral">
          <description>The "S" literal suffix denoting "Short"</description>
        </enumerator>
        <enumerator name="UShortLiteral">
          <description>The "US" literal suffix denoting "UShort"</description>
        </enumerator>
        <enumerator name="IntegerLiteral">
          <description>The "I" literal suffix denoting "Integer"</description>
        </enumerator>
        <enumerator name="UIntegerLiteral">
          <description>The "UI" literal suffix denoting "UInteger"</description>
        </enumerator>
        <enumerator name="LongLiteral">
          <description>The "L" literal suffix denoting "Long"</description>
        </enumerator>
        <enumerator name="ULongLiteral">
          <description>The "UL" literal suffix denoting "ULong"</description>
        </enumerator>
        <enumerator name="SingleLiteral">
          <description>The "F" literal suffix denoting "Single"</description>
        </enumerator>
        <enumerator name="DoubleLiteral">
          <description>The "R" literal suffix denoting "Double"</description>
        </enumerator>
        <enumerator name="DecimalLiteral">
          <description>The "D" literal suffix denoting "Decimal"</description>
        </enumerator>
      </enumerators>
    </enumeration>

    <!--********************
      -  IntegerLiteralToken
      **********************-->
    <node-structure name="IntegerLiteralTokenSyntax" parent="SyntaxToken" no-factory="true">
      <description>Represents an integer literal token.</description>
      <native-equiv name="IntegralLiteralExpression" />

      <node-kind name="IntegerLiteralToken">
        <lm-equiv name="TokenKind.IntegralLiteralToken" />
        <native-equiv name="tokens.tkIntCon" />
      </node-kind>

      <field name="Base" type="LiteralBase">
        <description>Whether the token was specified in base 10, 16, 8 or 2.</description>
      </field>

      <field name="TypeSuffix" type="TypeCharacter">
        <description>
          The type suffix or type character that was on the literal, if any. If no suffix was present,
          TypeCharacter.None is returned.
        </description>
        <native-equiv name="Token.m_IntLiteral.m_TypeCharacter"></native-equiv>
      </field>

      <field name="Value" type="Uint64">
        <description>The value of the token.</description>
        <native-equiv name="Token.m_IntLiteral.m_Value" />
      </field>
    </node-structure>

    <!--********************
      -  FloatingLiteralToken
      **********************-->
    <node-structure name="FloatingLiteralTokenSyntax" parent="SyntaxToken" no-factory="true">
      <description>Represents an floating literal token.</description>
      <native-equiv name="FloatingLiteralExpression" />

      <node-kind name="FloatingLiteralToken">
        <lm-equiv name="TokenKind.FloatingLiteralToken" />
        <native-equiv name="tokens.tkFltCon" />
      </node-kind>

      <field name="TypeSuffix" type="TypeCharacter">
        <description>
          The type suffix or type character that was on the literal, if any. If no suffix was present,
          TypeCharacter.None is returned.
        </description>
        <native-equiv name="Token.m_FloatLiteral.m_TypeCharacter"></native-equiv>
      </field>

      <field name="Value" type="Float64">
        <description>The value of the token.</description>
        <native-equiv name="Token.m_FloatLiteral.m_Value" />
      </field>
    </node-structure>

    <!--********************
      -  DecimalLiteralToken
      **********************-->
    <node-structure name="DecimalLiteralTokenSyntax" parent="SyntaxToken">
      <description>Represents a Decimal literal token.</description>
      <native-equiv name="DecimalLiteralExpression" />

      <node-kind name="DecimalLiteralToken">
        <lm-equiv name="TokenKind.DecimalLiteralToken" />
        <native-equiv name="tokens.tkDecCon" />
      </node-kind>

      <field name="TypeSuffix" type="TypeCharacter">
        <description>
          The type suffix or type character that was on the literal, if any. If no suffix was present,
          TypeCharacter.None is returned.
        </description>
        <native-equiv name="Token.m_DecimalLiteral.m_TypeCharacter"></native-equiv>
      </field>

      <field name="Value" type="Decimal">
        <description>The value of the token.</description>
        <native-equiv name="Token.m_DecimalLiteral.m_Value" />
      </field>
    </node-structure>

    <!--********************
      -  DecimalLiteralToken
      **********************-->
    <node-structure name="DateLiteralTokenSyntax" parent="SyntaxToken">
      <description>Represents an Date literal token.</description>
      <native-equiv name="DateLiteralExpression" />

      <node-kind name="DateLiteralToken">
        <lm-equiv name="TokenKind.DateLiteralToken" />
        <native-equiv name="tokens.tkDateCon" />
      </node-kind>

      <field name="Value" type="DateTime">
        <description>The value of the token.</description>
        <native-equiv name="Token.m_DateLiteral.m_Value" />
      </field>
    </node-structure>

    <!--********************
      -  StringLiteralToken
      **********************-->
    <node-structure name="StringLiteralTokenSyntax" parent="SyntaxToken">
      <description>Represents an string literal token.</description>
      <native-equiv name="StringLiteralExpression" />

      <node-kind name="StringLiteralToken">
        <lm-equiv name="TokenKind.StringLiteralToken" />
        <native-equiv name="tokens.tkStrCon" />
      </node-kind>

      <field name="Value" type="text">
        <description>The value of the string, after removing the quotation marks and combining doubled quotation marks.</description>
        <native-equiv name="Token.m_IntLiteral.m_Value" />
        <!-- TODO: Fix this.-->
      </field>
    </node-structure>

    <!--********************
      -  CharacterLiteralToken
      **********************-->
    <node-structure name="CharacterLiteralTokenSyntax" parent="SyntaxToken">
      <description>Represents an string literal token.</description>
      <native-equiv name="CharLiteralExpression" />

      <node-kind name="CharacterLiteralToken">
        <lm-equiv name="TokenKind.CharLiteralToken" />
        <native-equiv name="tokens.tkCharCon" />
      </node-kind>

      <field name="Value" type="character">
        <description>The value of the character, after removing the quotation marks.</description>
        <native-equiv name="Token.m_IntLiteral.m_Value" />
        <!-- TODO: Fix this.-->
      </field>
    </node-structure>

    <enumeration name="LiteralBase">
      <description>
        The four possible number bases that a literal can be written in.
      </description>
      <native-equiv name="LiteralBase"></native-equiv>

      <enumerators>
        <enumerator name="Decimal" />
        <enumerator name="Hexadecimal" />
        <enumerator name="Octal" />
        <enumerator name="Binary" />
      </enumerators>
    </enumeration>

    <!-- ************************************************************************************************** -->
    <!-- **  STRUCTURED TRIVIA                                                                          ** -->
    <!-- ************************************************************************************************** -->

    <node-structure name="StructuredTriviaSyntax" abstract="true" parent="VisualBasicSyntaxNode">
      <description>Abstract class that represent structured trivia.</description>
    </node-structure>

    <!--********************
      -  SkippedTokens
      **********************-->
    <node-structure name="SkippedTokensTriviaSyntax" parent="StructuredTriviaSyntax">
      <description>
        Represents tokens that were skipped by the parser as part of error recovery, and thus
        are not part of any syntactic structure.
      </description>
      <node-kind name="SkippedTokensTrivia"/>

      <child name="Tokens" optional="true" list="true" kind="@SyntaxToken">
        <description>
          The list of tokens that were skipped by the parser.
        </description>
      </child>
    </node-structure>

    <!--********************
      -  XmlDocumentation
      **********************-->
    <node-structure name="DocumentationCommentTriviaSyntax" parent="StructuredTriviaSyntax">
      <description>Represents a documentation comment e.g. ''' &lt;Summary&gt; appearing in source.</description>
      <node-kind name="DocumentationCommentTrivia">
        <lm-equiv name="XmlDocCommentToken" />
        <native-equiv name="" />
      </node-kind>

      <child name="Content" optional="true" list="true" kind="@XmlNodeSyntax"></child>

    </node-structure>

    <node-structure name="XmlCrefAttributeSyntax" parent="BaseXmlAttributeSyntax">
      <description>
        A symbol referenced by a cref attribute (e.g. in a &lt;see&gt; or &lt;seealso&gt; documentation comment tag).
        For example, the M in &lt;see cref="M" /&gt;.
      </description>

      <node-kind name="XmlCrefAttribute" />
      <child name="Name" kind="XmlName"/>
      <!-- TODO: Validate/Assert that the name is indeed 'cref' -->
      <child name="EqualsToken" kind="EqualsToken"/>
      <child name="StartQuoteToken" kind="DoubleQuoteToken|SingleQuoteToken"></child>
      <child name="Reference" kind="CrefReference"/>
      <child name="EndQuoteToken" kind="DoubleQuoteToken|SingleQuoteToken"></child>
    </node-structure>

    <node-structure name="XmlNameAttributeSyntax" parent="BaseXmlAttributeSyntax">
      <description>
        A param or type param symbol referenced by a name attribute (e.g. in a &lt;param&gt;
        or &lt;typeparam&gt; documentation comment tag). For example, the M in &lt;param name="M" /&gt;.
      </description>

      <node-kind name="XmlNameAttribute" />
      <child name="Name" kind="XmlName"/>
      <!-- TODO: Validate/Assert that the name is indeed 'name' -->
      <child name="EqualsToken" kind="EqualsToken"/>
      <child name="StartQuoteToken" kind="DoubleQuoteToken|SingleQuoteToken"></child>
      <child name="Reference" kind="@IdentifierNameSyntax"/>
      <child name="EndQuoteToken" kind="DoubleQuoteToken|SingleQuoteToken"></child>
    </node-structure>

    <node-structure name="ConditionalAccessExpressionSyntax" parent="ExpressionSyntax">
      <description>
        ExpressionSyntax node representing the object conditionally accessed.
      </description>

      <grammar>ConditionalAccessExpression</grammar>

      <node-kind name="ConditionalAccessExpression">
      </node-kind>

      <child name="Expression" optional="true" kind="@ExpressionSyntax">
        <description>The expression on the left-hand-side of the "?".</description>
      </child>
      <child name="QuestionMarkToken" kind="QuestionToken">
        <description>"?" token.</description>
      </child>
      <child name="WhenNotNull" kind="DictionaryAccessExpression|SimpleMemberAccessExpression|XmlElementAccessExpression|XmlDescendantAccessExpression|XmlAttributeAccessExpression|InvocationExpression|ConditionalAccessExpression">
        <description>ExpressionSyntax node representing the access expression to be executed when the object is not null."</description>
      </child>
    </node-structure>

    <!--****************
      -  NameOf
      ******************-->
    <node-structure name="NameOfExpressionSyntax" parent="ExpressionSyntax">
      <description>Represents a NameOf expression.</description>

      <node-kind name="NameOfExpression">
      </node-kind>

      <child name="NameOfKeyword" kind="NameOfKeyword">
        <description>The "NameOf" keyword.</description>
      </child>

      <child name="OpenParenToken" kind="OpenParenToken">
        <description>The "(" token.</description>
      </child>

      <child name="Argument" kind="@ExpressionSyntax">
        <description>The argument.</description>
      </child>

      <child name="CloseParenToken" kind="CloseParenToken">
        <description>The ")" token.</description>
      </child>
    </node-structure>

    <!--****************
      -  InterpolatedStringExpression
      ******************-->
    <node-structure name="InterpolatedStringExpressionSyntax" parent="ExpressionSyntax">
      <description>Represents an interpolated string expression.</description>

      <node-kind name="InterpolatedStringExpression" />

      <child name="DollarSignDoubleQuoteToken" kind="DollarSignDoubleQuoteToken">
        <description>The opening '$"', '$“', or '$”' token.</description>
      </child>

      <child name="Contents" kind="InterpolatedStringText|Interpolation" list="true">
        <description>The contents of the interpolated string.</description>
      </child>

      <child name="DoubleQuoteToken" kind="DoubleQuoteToken">
        <description>The closing '"', '”', or '“' token.</description>
      </child>
    </node-structure>

    <!--****************
      -  InterpolatedStringContent
      ******************-->
    <node-structure name="InterpolatedStringContentSyntax" parent="VisualBasicSyntaxNode" abstract="true">
      <description>Represents either text content or an interpolation.</description>
    </node-structure>

    <!--****************
      -  InterpolatedStringText
      ******************-->
    <node-structure name="InterpolatedStringTextSyntax" parent="InterpolatedStringContentSyntax">
      <description>Represents literal text content in an interpolated string.</description>

      <node-kind name="InterpolatedStringText" />

      <child name="TextToken" kind="InterpolatedStringTextToken">
        <description>The text token.</description>
      </child>
    </node-structure>

    <!--****************
      -  Interpolation
      ******************-->
    <node-structure name="InterpolationSyntax" parent="InterpolatedStringContentSyntax">
      <description>Represents an interpolation of an expression in an interpolated string expression e.g. '{expression[,alignment][:formatString]}'.</description>

      <node-kind name="Interpolation" />

      <child name="OpenBraceToken" kind="OpenBraceToken">
        <description>The opening curly brace '{' token.</description>
      </child>

      <child name="Expression" kind="@ExpressionSyntax">
        <description>The expression whose formatted value should be embedded in the resultant string.</description>
      </child>

      <child name="AlignmentClause" kind="InterpolationAlignmentClause" optional="true">
        <description>Optional. The alignment clause ',alignment' of the embedded expression.</description>
      </child>

      <child name="FormatClause" kind="InterpolationFormatClause" optional="true">
        <description>Optional. The format string clause ':formatString' of the embedded expression.</description>
      </child>

      <child name="CloseBraceToken" kind="CloseBraceToken">
        <description>The closing curly brace '}' token of the embedded expression.</description>
      </child>
    </node-structure>

    <!--****************
      -  InterpolationAlignmentClause
      ******************-->
    <node-structure name="InterpolationAlignmentClauseSyntax" parent="VisualBasicSyntaxNode">
      <description>Represents an alignment clause ',alignment' of an interpolated string embedded expression.</description>

      <node-kind name="InterpolationAlignmentClause" />

      <child name="CommaToken" kind="CommaToken">
        <description>The comma ',' token.</description>
      </child>

      <child name="Value" kind="@ExpressionSyntax">
        <description>An expression representing the alignment of the interpolated expression.</description>
      </child>
    </node-structure>

    <!--****************
      -  InterpolationFormatClause
      ******************-->
    <node-structure name="InterpolationFormatClauseSyntax" parent="VisualBasicSyntaxNode">
      <description>Represents a format string clause ':formatString' of an interpolated string embedded expression.</description>

      <node-kind name="InterpolationFormatClause" />

      <child name="ColonToken" kind="ColonToken">
        <description>The ':' token.</description>
      </child>

      <child name="FormatStringToken" kind="InterpolatedStringTextToken">
        <description>The format string.</description>
      </child>
    </node-structure>

    <!--********************
      -  Directive
      **********************-->
    <node-structure name="DirectiveTriviaSyntax" parent="StructuredTriviaSyntax" abstract="true" >
      <description>Represents a pre-processing directive (such as #If, #Const or #Region) appearing in source.</description>
      <child name="HashToken" kind="HashToken">
        <description>The "#" token in a preprocessor directive.</description>
      </child>
    </node-structure>

    <!-- ************************************************************************************************** -->
    <!-- **  TRIVIA                                                                                      ** -->
    <!-- ************************************************************************************************** -->

    <!--********************
      -  Trivia
      **********************-->
    <node-structure name="SyntaxTrivia" trivia-root="true" parent="VisualBasicSyntaxNode" syntax-facts-internal="true">
      <description>
        Trivia nodes represents parts of the program text that are
        not parts of the syntactic grammar, such as spaces, newlines, comments, preprocessors directives,
        and disabled code.
      </description>
      <node-kind name="WhitespaceTrivia">
        <description>Represents true whitespace: spaces, tabs, newlines and the like.</description>
      </node-kind>
      <node-kind name="EndOfLineTrivia">
        <description>Represents line breaks that are syntactically insignificant.</description>
      </node-kind>
      <node-kind name="ColonTrivia" token-text=":">
        <description>Represents colons that are syntactically insignificant.</description>
      </node-kind>
      <node-kind name="CommentTrivia">
        <description>Represents a comment.</description>
      </node-kind>
      <node-kind name="ConflictMarkerTrivia">
        <description>Trivia created when merge conflict markers (like "&lt;&lt;&lt;&lt;&lt;&lt;&lt;") are detected in source code.</description>
      </node-kind>
      <node-kind name="LineContinuationTrivia" token-text="_&#13;&#10;">
        <description>Represents an explicit line continuation character at the end of a line, i.e., _</description>
      </node-kind>
      <node-kind name="DocumentationCommentExteriorTrivia" token-text="'''">
        <description>Represents a ''' prefix for an XML Documentation Comment.</description>
      </node-kind>
      <node-kind name="DisabledTextTrivia">
        <description>Represents text in a false preprocessor block</description>
      </node-kind>
    </node-structure>

    <!-- ************************************************************************************************** -->
    <!-- **  Preprocessor Statements                                                                     ** -->
    <!-- ************************************************************************************************** -->

    <node-structure name="ConstDirectiveTriviaSyntax" parent="DirectiveTriviaSyntax">
      <description>Represents a #Const pre-processing constant declaration appearing in source.</description>
      <node-kind name="ConstDirectiveTrivia"></node-kind>

      <child name="ConstKeyword" kind="ConstKeyword">
        <description>The "Const" keyword.</description>
      </child>
      <child name="Name" kind="IdentifierToken">
        <description>The name of the pre-processing constant being defined.</description>
      </child>
      <child name="EqualsToken" kind="EqualsToken">
        <description>The "=" token.</description>
      </child>
      <child name="Value" kind="@ExpressionSyntax">
        <description>An expression representing the value of the pre-processing constant being defined.</description>
      </child>
    </node-structure>

    <node-structure name="IfDirectiveTriviaSyntax" parent="DirectiveTriviaSyntax">
      <description>Represents the beginning of an #If pre-processing directive appearing in source.</description>
      <node-kind name="IfDirectiveTrivia"></node-kind>
      <node-kind name="ElseIfDirectiveTrivia"></node-kind>

      <child name="ElseKeyword" optional="true" kind="ElseKeyword"></child>
      <child name="IfOrElseIfKeyword" kind="IfKeyword|ElseIfKeyword"></child>
      <child name="Condition" kind="@ExpressionSyntax"></child>
      <child name="ThenKeyword" optional="true" kind="ThenKeyword"></child>
    </node-structure>

    <node-structure name="ElseDirectiveTriviaSyntax" parent="DirectiveTriviaSyntax">
      <description>Represents an #Else pre-processing directive appearing in source.</description>
      <node-kind name="ElseDirectiveTrivia"></node-kind>

      <child name="ElseKeyword" kind="ElseKeyword"></child>
    </node-structure>

    <node-structure name="EndIfDirectiveTriviaSyntax" parent="DirectiveTriviaSyntax">
      <description>Represents an #End If pre-processing directive appearing in source.</description>
      <node-kind name="EndIfDirectiveTrivia"></node-kind>

      <child name="EndKeyword" kind="EndKeyword"></child>
      <child name="IfKeyword" kind="IfKeyword"></child>
    </node-structure>

    <node-structure name="RegionDirectiveTriviaSyntax" parent="DirectiveTriviaSyntax">
      <description>Represents the beginning of a #Region directive appearing in source.</description>
      <node-kind name="RegionDirectiveTrivia"></node-kind>

      <child name="RegionKeyword" kind="RegionKeyword">
        <description>The "Region" keyword.</description>
      </child>
      <child name="Name" kind="StringLiteralToken">
        <description>The label of the code region being defined.</description>
      </child>
    </node-structure>

    <node-structure name="EndRegionDirectiveTriviaSyntax" parent="DirectiveTriviaSyntax">
      <description>Represents an #End Region directive appearing in source.</description>
      <node-kind name="EndRegionDirectiveTrivia"></node-kind>

      <child name="EndKeyword" kind="EndKeyword">
        <description>The "End" keyword.</description>
      </child>
      <child name="RegionKeyword" kind="RegionKeyword">
        <description>The "Region" keyword.</description>
      </child>
    </node-structure>

    <node-structure name="ExternalSourceDirectiveTriviaSyntax" parent="DirectiveTriviaSyntax">
      <description>Represents the beginning of a #ExternalSource pre-processing directive appearing in source.</description>
      <node-kind name="ExternalSourceDirectiveTrivia"></node-kind>

      <child name="ExternalSourceKeyword" kind="ExternalSourceKeyword"></child>
      <child name="OpenParenToken" kind="OpenParenToken"></child>
      <child name="ExternalSource" kind="StringLiteralToken"></child>
      <child name="CommaToken" kind="CommaToken"></child>
      <child name="LineStart" kind="IntegerLiteralToken"></child>
      <child name="CloseParenToken" kind="CloseParenToken"></child>
    </node-structure>

    <node-structure name="EndExternalSourceDirectiveTriviaSyntax" parent="DirectiveTriviaSyntax">
      <description>Represents an #End ExternalSource pre-processing directive appearing in source.</description>
      <node-kind name="EndExternalSourceDirectiveTrivia"></node-kind>

      <child name="EndKeyword" kind="EndKeyword"></child>
      <child name="ExternalSourceKeyword" kind="ExternalSourceKeyword"></child>
    </node-structure>

    <node-structure name="ExternalChecksumDirectiveTriviaSyntax" parent="DirectiveTriviaSyntax">
      <description>Represents an #ExternalChecksum pre-processing directive appearing in source.</description>
      <node-kind name="ExternalChecksumDirectiveTrivia"></node-kind>

      <child name="ExternalChecksumKeyword" kind="ExternalChecksumKeyword"></child>
      <child name="OpenParenToken" kind="OpenParenToken"></child>
      <child name="ExternalSource" kind="StringLiteralToken"></child>
      <child name="FirstCommaToken" kind="CommaToken"></child>
      <child name="Guid" kind="StringLiteralToken"></child>
      <child name="SecondCommaToken" kind="CommaToken"></child>
      <child name="Checksum" kind="StringLiteralToken"></child>
      <child name="CloseParenToken" kind="CloseParenToken"></child>
    </node-structure>

    <node-structure name="EnableWarningDirectiveTriviaSyntax" parent="DirectiveTriviaSyntax">
      <description>Represents #Enable Warning pre-processing directive appearing in source.</description>
      <node-kind name="EnableWarningDirectiveTrivia"></node-kind>
      <child name="EnableKeyword" kind="EnableKeyword"></child>
      <child name="WarningKeyword" kind="WarningKeyword"></child>
      <child name="ErrorCodes" list="true" separator-kind="CommaToken" separator-name="CommaTokens" kind="@IdentifierNameSyntax"/>
    </node-structure>

    <node-structure name="DisableWarningDirectiveTriviaSyntax" parent="DirectiveTriviaSyntax">
      <description>Represents #Disable Warning pre-processing directive appearing in source.</description>
      <node-kind name="DisableWarningDirectiveTrivia"></node-kind>
      <child name="DisableKeyword" kind="DisableKeyword"></child>
      <child name="WarningKeyword" kind="WarningKeyword"></child>
      <child name="ErrorCodes" list="true" separator-kind="CommaToken" separator-name="CommaTokens" kind="@IdentifierNameSyntax"/>
    </node-structure>

    <node-structure name="ReferenceDirectiveTriviaSyntax" parent="DirectiveTriviaSyntax">
      <description>Represents an #r directive appearing in scripts.</description>
      <node-kind name="ReferenceDirectiveTrivia"></node-kind>

      <child name="ReferenceKeyword" kind="ReferenceKeyword"/>
      <child name="File" kind="StringLiteralToken"/>
    </node-structure>

    <!-- ************************************************************************************************** -->
    <!-- **  ERROR NODES                                                                                 ** -->
    <!-- ************************************************************************************************** -->

    <!--****************
      -  BadDirective
      ******************-->

    <node-structure name="BadDirectiveTriviaSyntax" parent="DirectiveTriviaSyntax">
      <description>
        Represents an unrecognized pre-processing directive.
        This occurs when the parser encounters a hash '#' token at the beginning of a physical line but does recognize the text that follows as a valid Visual Basic pre-processing directive.
      </description>
      <node-kind name="BadDirectiveTrivia"></node-kind>
    </node-structure>
  </definitions>
</define-parse-tree>
